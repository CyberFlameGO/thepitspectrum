# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 67 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 76 A6         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 77 A6         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 11 A5         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD CD B6         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8051 C9               ret                 ; key was pressed.
 53+  8052
 54+  8052              ;
 55+  8052              ; Waits number of frames for keypress. If got, returns 1, if not 0
 56+  8052              ; Inputs:
 57+  8052              ; a - number of frames to waits
 58+  8052              ; Ouputs:
 59+  8052              ; e - 0 not pressed, 1 pressed
 60+  8052              utilities_waitforkey_forframes:
 61+  8052 21 08 5C         ld hl,23560         ; LAST K system variable.
 62+  8055 36 00            ld (hl),0           ; put null value there.
 63+  8057 47               ld b,a              ; number of frames to wait
 64+  8058              utilities_waitforkey_forframes0:
 65+  8058 7E               ld a,(hl)           ; new value of LAST K.
 66+  8059 FE 00            cp 0                ; is it still zero?
 67+  805B 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 68+  805D 1E 01            ld e,1              ; set the pressed flag
 69+  805F C9               ret                 ; key was pressed.
 70+  8060              utilities_waitforkey_forframes1:
 71+  8060 76               halt                ; wait for frame
 72+  8061 76               halt                ; wait for frame
 73+  8062 10 F4            djnz utilities_waitforkey_forframes0 ; loop again
 74+  8064 1E 00            ld e,0              ; nothing pressed in time
 75+  8066 C9               ret
 76+  8067
 77+  8067              ;
 78+  8067              ; Clears the screen
 79+  8067              ; Inputs:
 80+  8067              ; a - attribute colour
 81+  8067              utilities_clearscreen:
 82+  8067 76               halt
 83+  8068 21 00 58         ld hl,22528         ; attr
 84+  806B 11 01 58         ld de,22529         ; attr+1
 85+  806E 01 FF 02         ld bc,767
 86+  8071 77               ld (hl),a
 87+  8072 ED B0            ldir
 88+  8074
 89+  8074 21 00 40         ld hl, 16384        ;pixels
 90+  8077 11 01 40         ld de, 16385        ;pixels + 1
 91+  807A 01 FF 17         ld bc, 6143         ;pixels area length - 1
 92+  807D 36 00            ld (hl), 0          ;set first byte to '0'
 93+  807F ED B0            ldir                ;copy bytes
 94+  8081
 95+  8081 C9               ret
 96+  8082
 97+  8082              ;
 98+  8082              ; Wait for a number of frames
 99+  8082              ; Inputs:
100+  8082              ; b - number of frames
101+  8082              utilities_pauseforframes:
102+  8082 76               halt
103+  8083 10 FD            djnz utilities_pauseforframes
104+  8085 C9               ret
105+  8086
106+  8086              utilities_readkey:
107+  8086 21 A6 80         LD HL,utilties_keymap              ; Point HL at the keyboard list
108+  8089 16 08            LD D,8                                  ; This is the number of ports (rows) to check
109+  808B 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
110+  808D              utilities_readkey_0:
111+  808D 46               LD B,(HL)                               ; Get the keyboard port address from table
112+  808E 23               INC HL                                  ; Increment to list of keys
113+  808F ED 78            IN A,(C)                                ; Read the row of keys in
114+  8091 E6 1F            AND $1F                                     ; We are only interested in the first five bits
115+  8093 1E 05            LD E,5                                  ; This is the number of keys in the row
116+  8095              utilities_readkey_1:
117+  8095 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
118+  8097 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
119+  8099 23               INC HL                                  ; Go to next table address
120+  809A 1D               DEC E                                   ; Decrement key loop counter
121+  809B 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
122+  809D 15               DEC D                                   ; Decrement row loop counter
123+  809E 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
124+  80A0 A7               AND A                                   ; Clear A (no key found)
125+  80A1 C3 86 80         jp utilities_readkey
126+  80A4              utilities_readkey_2:
127+  80A4 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
128+  80A5 C9               RET
129+  80A6
130+  80A6              utilties_keymap:
131+  80A6 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
131+  80AA 43 56
132+  80AC FD 41 53 44      defb $FD,"A","S","D","F","G"
132+  80B0 46 47
133+  80B2 FB 51 57 45      defb $FB,"Q","W","E","R","T"
133+  80B6 52 54
134+  80B8 F7 31 32 33      defb $F7,"1","2","3","4","5"
134+  80BC 34 35
135+  80BE EF 30 39 38      defb $EF,"0","9","8","7","6"
135+  80C2 37 36
136+  80C4 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
136+  80C8 55 59
137+  80CA BF 23 4C 4B      defb $BF,"#","L","K","J","H"
137+  80CE 4A 48
138+  80D0 7F 20 23 4D      defb $7F," ","#","M","N","B"
138+  80D4 4E 42
# file closed: utilities.asm
 22   80D6                  include "strings.asm"
# file opened: strings.asm
  1+  80D6              string_score1:
  2+  80D6 04 00 53 43      defb 4,0,'SCORE1',255
  2+  80DA 4F 52 45 31
  2+  80DE FF
  3+  80DF              string_scorenumbers1:
  4+  80DF 04 01 30 30      defb 4,1,'000000',255
  4+  80E3 30 30 30 30
  4+  80E7 FF
  5+  80E8              string_company:
  6+  80E8 0E 00 45 4E      defb 14,0,'ENV',255
  6+  80EC 56 FF
  7+  80EE              string_credits:
  8+  80EE 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  80F2 41 59 45 52
  8+  80F6 20 31 FF
  9+  80F9              string_score2:
 10+  80F9 16 00 53 43      defb 22,0,'SCORE2',255
 10+  80FD 4F 52 45 32
 10+  8101 FF
 11+  8102              string_scorenumbers2:
 12+  8102 16 01 30 30      defb 22,1,'000000',255
 12+  8106 30 30 30 30
 12+  810A FF
 13+  810B              string_titlescreen_copyright:
 14+  810B 04 16 7F 20      defb 4,22, 127,' 1982 AW ZILEC ELC LTD',255
 14+  810F 31 39 38 32
 14+  8113 20 41 57 20
 14+  8117 5A 49 4C 45
 14+  811B 43 20 45 4C
 14+  811F 43 20 4C 54
 14+  8123 44 FF
 15+  8125
 16+  8125
 17+  8125              string_alttitlescreen_1:
 18+  8125 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  8129 45 44 49 54
 18+  812D 53 20 31 FF
 19+  8131              string_alttitlescreen_2:
 20+  8131 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  8135 20 20 20 20
 20+  8139 20 20 20 20
 20+  813D 20 54 48 45
 20+  8141 20 4F 42 4A
 20+  8145 45 43 54 FE
 21+  8149 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  814D 20 20 20 20
 21+  8151 20 20 20 20
 21+  8155 4F 46 20 54
 21+  8159 48 49 53 20
 21+  815D 47 41 4D 45
 21+  8161 FE
 22+  8162 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  8166 20 20 20 20
 22+  816A 20 20 20 49
 22+  816E 53 20 54 4F
 22+  8172 20 44 49 47
 22+  8176 20 44 4F 57
 22+  817A 4E FE
 23+  817C 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  8180 20 20 20 20
 23+  8184 20 20 54 4F
 23+  8188 20 54 48 45
 23+  818C 20 42 4F 54
 23+  8190 54 4F 4D 20
 23+  8194 50 49 54 FE
 24+  8198 00 06 20 20      defb 0,6,'               AND',254
 24+  819C 20 20 20 20
 24+  81A0 20 20 20 20
 24+  81A4 20 20 20 20
 24+  81A8 20 41 4E 44
 24+  81AC FE
 25+  81AD 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  81B1 20 20 20 20
 25+  81B5 20 20 43 4F
 25+  81B9 4C 4C 45 43
 25+  81BD 54 20 41 54
 25+  81C1 20 4C 45 41
 25+  81C5 53 54 FE
 26+  81C8 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  81CC 20 20 20 20
 26+  81D0 20 20 20 4F
 26+  81D4 4E 45 20 4C
 26+  81D8 41 52 47 45
 26+  81DC 20 4A 45 57
 26+  81E0 45 4C FE
 27+  81E3 00 09 20 20      defb 0,9,'              THEN',254
 27+  81E7 20 20 20 20
 27+  81EB 20 20 20 20
 27+  81EF 20 20 20 20
 27+  81F3 54 48 45 4E
 27+  81F7 FE
 28+  81F8 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  81FC 20 20 20 20
 28+  8200 20 20 20 52
 28+  8204 45 54 55 52
 28+  8208 4E 20 54 4F
 28+  820C 20 53 48 49
 28+  8210 50 FE
 29+  8212 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  8216 20 20 20 20
 29+  821A 20 20 20 54
 29+  821E 48 52 55 20
 29+  8222 55 50 50 45
 29+  8226 52 20 50 49
 29+  822A 54 FF
 30+  822C              string_alttitlescreen_3:
 31+  822C 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  8230 20 20 53 49
 31+  8234 4E 47 4C 45
 31+  8238 20 42 4F 4E
 31+  823C 55 53 20 20
 31+  8240 35 30 30 30
 31+  8244 20 50 4F 49
 31+  8248 4E 54 53 FE
 32+  824C 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  8250 20 20 20 20
 32+  8254 43 4F 4C 4C
 32+  8258 45 43 54 20
 32+  825C 31 20 4C 41
 32+  8260 52 47 45 20
 32+  8264 4A 45 57 45
 32+  8268 4C FE
 33+  826A 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  826E 20 20 20 20
 33+  8272 20 41 4E 44
 33+  8276 20 52 45 54
 33+  827A 55 52 4E 20
 33+  827E 54 4F 20 53
 33+  8282 48 49 50 FE
 34+  8286 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  828A 20 20 44 4F
 34+  828E 55 42 4C 45
 34+  8292 20 42 4F 4E
 34+  8296 55 53 20 20
 34+  829A 31 30 30 30
 34+  829E 30 20 50 4F
 34+  82A2 49 4E 54 53
 34+  82A6 FE
 35+  82A7 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  82AB 20 20 43 4F
 35+  82AF 4C 4C 45 43
 35+  82B3 54 20 41 4C
 35+  82B7 4C 20 33 20
 35+  82BB 4C 41 52 47
 35+  82BF 45 20 4A 45
 35+  82C3 57 45 4C 53
 35+  82C7 FE
 36+  82C8 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  82CC 20 20 20 20
 36+  82D0 20 4F 52 20
 36+  82D4 20 20 41 4C
 36+  82D8 4C 20 34 20
 36+  82DC 53 4D 41 4C
 36+  82E0 4C 20 4A 45
 36+  82E4 57 45 4C 53
 36+  82E8 FE
 37+  82E9 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  82ED 20 20 54 52
 37+  82F1 49 50 4C 45
 37+  82F5 20 42 4F 4E
 37+  82F9 55 53 20 20
 37+  82FD 31 35 30 30
 37+  8301 30 20 50 4F
 37+  8305 49 4E 54 53
 37+  8309 FE
 38+  830A 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  830E 20 20 20 20
 38+  8312 20 43 4F 4C
 38+  8316 4C 45 43 54
 38+  831A 20 41 4C 4C
 38+  831E 20 37 20 4A
 38+  8322 45 57 45 4C
 38+  8326 53 FF
 39+  8328
 40+  8328              string_lifescreen_player:
 41+  8328 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  832C 4C 41 59 45
 41+  8330 52 20 31 20
 41+  8334 FF
 42+  8335              string_lifescreen_lives:
 43+  8335 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  8339 4D 45 4E 20
 43+  833D 4C 45 46 54
 43+  8341 FF
 44+  8342              string_lifescreen_lastman:
 45+  8342 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  8346 53 54 20 4D
 45+  834A 41 4E FF
 46+  834D
 47+  834D              string_gameoverscreen_gameover:
 48+  834D 0C 06 47 41      defb 12,6,'GAME OVER',255
 48+  8351 4D 45 20 4F
 48+  8355 56 45 52 FF
 49+  8359              string_gameoverscreen_copyright:
 50+  8359 05 12 7F 20      defb 5,18,127,' 1982 AW ZILEC ELC LTD',255
 50+  835D 31 39 38 32
 50+  8361 20 41 57 20
 50+  8365 5A 49 4C 45
 50+  8369 43 20 45 4C
 50+  836D 43 20 4C 54
 50+  8371 44 FF
 51+  8373              string_gameoverscreen_bestscores:
 52+  8373 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  8377 53 54 20 53
 52+  837B 43 4F 52 45
 52+  837F 53 20 54 4F
 52+  8383 44 41 59 FF
 53+  8387              string_gameover_credits:
 54+  8387 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  838B 45 44 49 54
 54+  838F 53 20 30 FF
 55+  8393
 56+  8393              string_highscore_congratulations:
 57+  8393 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 57+  8397 4E 47 52 41
 57+  839B 54 55 4C 41
 57+  839F 54 49 4F 4E
 57+  83A3 53 FF
 58+  83A5              string_highscore_player1:
 59+  83A5 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 59+  83A9 41 59 45 52
 59+  83AD 20 31 FF
 60+  83B0              string_highscore_player2:
 61+  83B0 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 61+  83B4 41 59 45 52
 61+  83B8 20 32 FF
 62+  83BB              string_highscore_youhaveearned:
 63+  83BB 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 63+  83BF 55 20 48 41
 63+  83C3 56 45 20 45
 63+  83C7 41 52 4E 45
 63+  83CB 44 FF
 64+  83CD              string_highscore_place1:
 65+  83CD 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 65+  83D1 45 20 47 52
 65+  83D5 45 41 54 45
 65+  83D9 53 54 20 53
 65+  83DD 43 4F 52 45
 65+  83E1 FF
 66+  83E2              string_highscore_place2:
 67+  83E2 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 67+  83E6 45 20 32 4E
 67+  83EA 44 20 42 45
 67+  83EE 53 54 20 53
 67+  83F2 43 4F 52 45
 67+  83F6 FF
 68+  83F7              string_highscore_place3:
 69+  83F7 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 69+  83FB 45 20 33 52
 69+  83FF 44 20 42 45
 69+  8403 53 54 20 53
 69+  8407 43 4F 52 45
 69+  840B FF
 70+  840C              string_highscore_pleaseenter
 71+  840C 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 71+  8410 43 4F 52 44
 71+  8414 20 59 4F 55
 71+  8418 52 20 49 4E
 71+  841C 49 54 49 41
 71+  8420 4C 53 20 42
 71+  8424 45 4C 4F 57
 71+  8428 FF
 72+  8429              ;
 73+  8429              ; Prints specified string
 74+  8429              ; Inputs:
 75+  8429              ; de: pointer to string
 76+  8429              ; bc: length of string
 77+  8429              ;
 78+  8429              ; Print String Data
 79+  8429              ; First two bytes of string contain X and Y char position, then the string
 80+  8429              ; Individual strings are terminated with 0xFE
 81+  8429              ; End of data is terminated with 0xFF
 82+  8429              ; HL: Address of string
 83+  8429              ;
 84+  8429 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
 85+  842A 23                                   INC HL                          ; Increase HL to the next memory location
 86+  842B 56                                   LD D,(HL)                       ; Fetch the Y coordinate
 87+  842C 23                                   INC HL                          ; Increase HL to the next memory location
 88+  842D CD 40 84                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
 89+  8430 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
 90+  8431 23                                   INC HL                          ; Increase HL to the next character
 91+  8432 FE FE                                CP 0xFE                         ; Compare with 0xFE
 92+  8434 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
 93+  8436 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
 94+  8437 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
 95+  8438 CD 50 84                             CALL Print_Char                 ; Print the character
 96+  843B E1                                   POP HL                          ; Retrieve HL back off the stack
 97+  843C 1C                                   INC E                           ; Go to the next screen address
 98+  843D 18 F1                                JR string_print_0               ; Loop back to print next character
 99+  843F C9                                   RET
100+  8440
101+  8440              ; Get screen address
102+  8440              ; D = Y character position
103+  8440              ; E = X character position
104+  8440              ; Returns address in DE
105+  8440              ;
106+  8440 7A           string_getcharaddress:       LD A,D
107+  8441 E6 07                                AND %00000111
108+  8443 1F                                   RRA
109+  8444 1F                                   RRA
110+  8445 1F                                   RRA
111+  8446 1F                                   RRA
112+  8447 B3                                   OR E
113+  8448 5F                                   LD E,A
114+  8449 7A                                   LD A,D
115+  844A E6 18                                AND %00011000
116+  844C F6 40                                OR %01000000
117+  844E 57                                   LD D,A
118+  844F C9                                   RET                             ; Returns screen address in DE
119+  8450
120+  8450              ; Print a single character out
121+  8450              ; A:  Character to print
122+  8450              ; DE: Screen address to print character at
123+  8450              ;
124+  8450 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
125+  8453 06 00                                LD B,0                          ; Set BC to A
126+  8455 4F                                   LD C,A
127+  8456 E6 FF                                AND 0xFF                        ; Clear the carry bit
128+  8458 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
129+  845A CB 10                                RL B
130+  845C CB 11                                RL C
131+  845E CB 10                                RL B
132+  8460 CB 11                                RL C
133+  8462 CB 10                                RL B
134+  8464 09                                   ADD HL,BC                       ; Get the character address in HL
135+  8465 0E 08                                LD C,8                          ; Loop counter
136+  8467 D5                                   PUSH DE
137+  8468 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
138+  8469 12                                   LD (DE),A                       ; Stick A onto the screen
139+  846A 14                                   INC D                           ; Goto next line on screen
140+  846B 2C                                   INC L                           ; Goto next byte of character
141+  846C 0D                                   DEC C                           ; Decrease the loop counter
142+  846D 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
143+  846F D1                                   POP DE
144+  8470 C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   8471                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  8471              buffer_buffer:
  2+  8471 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A171
  4+  A171              buffer_attr_buffer:
  5+  A171 00 00 00...      defs 928                    ; attrs buffer area
  6+  A511
  7+  A511              buffer_tmp:
  8+  A511 00 00            defb 0,0                    ; temp area
  9+  A513
 10+  A513              buffer_updatedlines:
 11+  A513 FF FF FF...      defs 21,255
 12+  A528
 13+  A528              buffer_updateall:
 14+  A528 00               defb 0
 15+  A529
 16+  A529              ;
 17+  A529              ; Stores a line number in the update list
 18+  A529              ; Inputs:
 19+  A529              ; a - row number
 20+  A529              buffer_marklineforupdate:
 21+  A529 5F               ld e,a                          ; store in e
 22+  A52A 06 15            ld b,21
 23+  A52C 21 13 A5         ld hl,buffer_updatedlines
 24+  A52F              buffer_marklineforupdate0:
 25+  A52F 7E               ld a,(hl)                       ; get the line stored in updated lines
 26+  A530 BB               cp e                            ; is this the same as the row number passed in?
 27+  A531 C8               ret z                           ; if so, don't need to do anything
 28+  A532 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 29+  A534 C2 39 A5         jp nz,buffer_marklineforupdate1 ; if not, move to next
 30+  A537 73               ld (hl),e                       ; if it is, this spot is empty, so store the row number
 31+  A538 C9               ret                             ; and finish
 32+  A539              buffer_marklineforupdate1:
 33+  A539 23               inc hl
 34+  A53A 10 F3            djnz buffer_marklineforupdate0
 35+  A53C C9               ret
 36+  A53D
 37+  A53D              ;
 38+  A53D              ; Zeroes the updated lines list
 39+  A53D              ;
 40+  A53D              buffer_clearlist:
 41+  A53D 06 15            ld b,21
 42+  A53F 21 13 A5         ld hl,buffer_updatedlines
 43+  A542              buffer_clearlist0:
 44+  A542 36 FF            ld (hl),255
 45+  A544 23               inc hl
 46+  A545 10 FB            djnz buffer_clearlist0
 47+  A547 C9               ret
 48+  A548
 49+  A548              ;
 50+  A548              ; Copies the buffer to the screen. Use stack.
 51+  A548              ; Inputs:
 52+  A548              ; a - row number to display - 0 is first line
 53+  A548              ;
 54+  A548              buffer_bufferlinetoscreen:
 55+  A548 4F               ld c,a                          ; store a
 56+  A549 ED 5B 76 A6      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 57+  A54D 83               add a,e                       ; add the row number
 58+  A54E 11 00 01         ld de,256
 59+  A551 CD 3A 80         call utilities_multiply
 60+  A554 54 5D            ld de,hl
 61+  A556 21 71 84         ld hl,buffer_buffer
 62+  A559 19               add hl,de                   ; add the offset
 63+  A55A 79               ld a,c                      ; get original row back
 64+  A55B ED 73 B9 A5      ld (buffer_bufferlinetoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
 65+  A55F D9               exx
 66+  A560 0E 00            ld c,0                      ; zero horizontal
 67+  A562 47               ld b,a                      ; load the row number into vertical coord
 68+  A563 04               inc b
 69+  A564 04               inc b                       ; move forward 2 to allow for scores
 70+  A565 CD 60 A7         call screen_getcelladdress  ; get the memory into de
 71+  A568 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
 72+  A56B 19               add hl,de
 73+  A56C              buffer_bufferlinetoscreen0:
 74+  A56C D9               exx                         ; hl is now buffer
 75+  A56D 23               inc hl
 76+  A56E 23               inc hl                      ; move hl forward 2 to skip first two blocks
 77+  A56F F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
 78+  A570 F1               pop af
 79+  A571 C1               pop bc
 80+  A572 D1               pop de
 81+  A573 DD E1            pop ix
 82+  A575 D9               exx                         ; hl is now screen
 83+  A576 08               ex af,af'
 84+  A577 F1               pop af
 85+  A578 C1               pop bc
 86+  A579 D1               pop de
 87+  A57A F9               ld sp,hl                    ; sp pointing at screen
 88+  A57B D5               push de
 89+  A57C C5               push bc
 90+  A57D F5               push af
 91+  A57E 08               ex af,af'
 92+  A57F D9               exx                         ; hl is now buffer
 93+  A580 DD E5            push ix
 94+  A582 D5               push de
 95+  A583 C5               push bc
 96+  A584 F5               push af
 97+  A585 1E 0E            ld e,14                    ; do another fourteen for right hand side
 98+  A587 16 00            ld d,0
 99+  A589 19               add hl,de
100+  A58A F9               ld sp,hl                    ; sp pointing at buffer
101+  A58B F1               pop af
102+  A58C C1               pop bc
103+  A58D D1               pop de
104+  A58E DD E1            pop ix
105+  A590                  ;pop ix
106+  A590 D9               exx                         ; hl is now screen
107+  A591 08               ex af,af'
108+  A592 1E 0E            ld e,14
109+  A594 16 00            ld d,0
110+  A596 19               add hl,de
111+  A597 F1               pop af
112+  A598 C1               pop bc
113+  A599 D1               pop de
114+  A59A                  ;pop iy
115+  A59A F9               ld sp,hl                    ; sp pointing at screen
116+  A59B                  ;push iy
117+  A59B D5               push de
118+  A59C C5               push bc
119+  A59D F5               push af
120+  A59E 08               ex af,af'
121+  A59F D9               exx                         ; hl is now buffer
122+  A5A0 DD E5            push ix
123+  A5A2 D5               push de
124+  A5A3 C5               push bc
125+  A5A4 F5               push af
126+  A5A5 1E 10            ld e,16
127+  A5A7 16 00            ld d,0
128+  A5A9 19               add hl,de
129+  A5AA D9               exx                         ; hl is now screen
130+  A5AB 1E 0E            ld e,14
131+  A5AD 16 00            ld d,0
132+  A5AF ED 52            sbc hl,de
133+  A5B1 24               inc h
134+  A5B2 7C               ld a,h
135+  A5B3 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
136+  A5B5 C2 6C A5         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
137+  A5B8              buffer_bufferlinetoscreen1:
138+  A5B8 31 00 00         ld sp,0
139+  A5BB D9               exx
140+  A5BC C9               ret
141+  A5BD
142+  A5BD              ;
143+  A5BD              ; Copies the buffer to the screen for updated lines. Use stack.
144+  A5BD              ; Inputs: none
145+  A5BD              ;
146+  A5BD              buffer_buffertoscreen:
147+  A5BD 3A 28 A5         ld a,(buffer_updateall)      ; get the all update flag
148+  A5C0 FE 00            cp 0
149+  A5C2 CA CE A5         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
150+  A5C5 CD EF A5         call buffer_allbuffertoscreen ; otherwise, draw whole screen
151+  A5C8 21 28 A5         ld hl,buffer_updateall
152+  A5CB 36 00            ld (hl),0                    ; reset flag
153+  A5CD C9               ret
154+  A5CE              buffer_buffertoscreen2:
155+  A5CE 06 15            ld b,21
156+  A5D0 FD 21 13 A5      ld iy,buffer_updatedlines    ; the location of the updated lines
157+  A5D4              buffer_buffertoscreen0:
158+  A5D4 FD 7E 00         ld a,(iy)
159+  A5D7 FE FF            cp 255
160+  A5D9 CA EB A5         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
161+  A5DC C5               push bc
162+  A5DD FD E5            push iy
163+  A5DF F3               di
164+  A5E0 CD 48 A5         call buffer_bufferlinetoscreen
165+  A5E3 FB               ei
166+  A5E4 FD E1            pop iy
167+  A5E6 C1               pop bc
168+  A5E7 FD 23            inc iy
169+  A5E9 10 E9            djnz buffer_buffertoscreen0
170+  A5EB              buffer_buffertoscreen1:
171+  A5EB CD 03 A6         call buffer_buffertoattrsfast
172+  A5EE C9               ret
173+  A5EF
174+  A5EF              ;
175+  A5EF              ; Copies the buffer to the screen. Use stack.
176+  A5EF              ; Inputs: none
177+  A5EF              ;
178+  A5EF              buffer_allbuffertoscreen:
179+  A5EF 06 15            ld b,21
180+  A5F1 3E 00            ld a,0
181+  A5F3              buffer_allbuffertoscreen0:
182+  A5F3 C5               push bc
183+  A5F4 F5               push af
184+  A5F5 F3               di
185+  A5F6 CD 48 A5         call buffer_bufferlinetoscreen
186+  A5F9 FB               ei
187+  A5FA F1               pop af
188+  A5FB C1               pop bc
189+  A5FC 3C               inc a
190+  A5FD 10 F4            djnz buffer_allbuffertoscreen0
191+  A5FF
192+  A5FF CD 03 A6         call buffer_buffertoattrsfast
193+  A602 C9               ret
194+  A603
195+  A603              ;
196+  A603              ; Copies the attrs buffer to screen with the stack
197+  A603              ;
198+  A603              buffer_buffertoattrsfast:
199+  A603 ED 73 72 A6      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
200+  A607 3A 76 A6         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
201+  A60A 11 20 00         ld de,32
202+  A60D CD 3A 80         call utilities_multiply
203+  A610 54 5D            ld de,hl
204+  A612 21 71 A1         ld hl,buffer_attr_buffer
205+  A615 19               add hl,de                       ; add the offset, start of attr buffer now in hl
206+  A616 D9               exx
207+  A617 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
208+  A61A FD 21 11 A5      ld iy,buffer_tmp
209+  A61E FD 36 00 15      ld (iy),21              ; number of times to loop
210+  A622              buffer_buffertoattrsfast0:
211+  A622 D9               exx                         ; hl is now buffer
212+  A623 23               inc hl
213+  A624 23               inc hl                      ; move hl forward 2 to skip first two blocks
214+  A625 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
215+  A626 F1               pop af
216+  A627 C1               pop bc
217+  A628 D1               pop de
218+  A629 DD E1            pop ix
219+  A62B D9               exx                         ; hl is now screen
220+  A62C 08               ex af,af'
221+  A62D F1               pop af
222+  A62E C1               pop bc
223+  A62F D1               pop de
224+  A630 F9               ld sp,hl                    ; sp pointing at screen
225+  A631 D5               push de
226+  A632 C5               push bc
227+  A633 F5               push af
228+  A634 08               ex af,af'
229+  A635 D9               exx                         ; hl is now buffer
230+  A636 DD E5            push ix
231+  A638 D5               push de
232+  A639 C5               push bc
233+  A63A F5               push af
234+  A63B 1E 0E            ld e,14                    ; do another fourteen for right hand side
235+  A63D 16 00            ld d,0
236+  A63F 19               add hl,de
237+  A640 F9               ld sp,hl                    ; sp pointing at buffer
238+  A641 F1               pop af
239+  A642 C1               pop bc
240+  A643 D1               pop de
241+  A644 DD E1            pop ix
242+  A646 D9               exx                         ; hl is now screen
243+  A647 08               ex af,af'
244+  A648 1E 0E            ld e,14
245+  A64A 16 00            ld d,0
246+  A64C 19               add hl,de
247+  A64D F1               pop af
248+  A64E C1               pop bc
249+  A64F D1               pop de
250+  A650 F9               ld sp,hl                    ; sp pointing at screen
251+  A651 D5               push de
252+  A652 C5               push bc
253+  A653 F5               push af
254+  A654 08               ex af,af'
255+  A655 D9               exx                         ; hl is now buffer
256+  A656 DD E5            push ix
257+  A658 D5               push de
258+  A659 C5               push bc
259+  A65A F5               push af
260+  A65B 1E 10            ld e,16
261+  A65D 16 00            ld d,0
262+  A65F 19               add hl,de
263+  A660 D9               exx                         ; hl is now screen
264+  A661 11 12 00         ld de,18
265+  A664 19               add hl,de
266+  A665 FD 7E 00         ld a,(iy)
267+  A668 3D               dec a
268+  A669 FE 00            cp 0
269+  A66B FD 77 00         ld (iy),a
270+  A66E C2 22 A6         jp nz,buffer_buffertoattrsfast0 ; do another row
271+  A671              buffer_buffertoattrsfast1:
272+  A671 31 00 00         ld sp,0
273+  A674 D9               exx
274+  A675 C9               ret
# file closed: screen/buffer.asm
 24   A676                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A676              screen_offset:
  2+  A676 00               defb 0                      ; offset from top of screen in lines
  3+  A677
  4+  A677              screen_tmp:
  5+  A677 00 00            defb 0,0                      ; temporary memory
  6+  A679
  7+  A679              screen_setscorecolours:
  8+  A679 21 61 B0         ld hl,score_colours
  9+  A67C 11 00 58         ld de,22528                     ; attrs here
 10+  A67F 01 40 00         ld bc,64
 11+  A682 ED B0            ldir
 12+  A684 C9               ret
 13+  A685
 14+  A685              screen_sethighscorecolours:
 15+  A685 21 A1 B0         ld hl,high_score_colours
 16+  A688 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A68B 01 20 00         ld bc,32
 18+  A68E ED B0            ldir
 19+  A690 C9               ret
 20+  A691
 21+  A691              ; Draw the screen
 22+  A691              ; Inputs:
 23+  A691              ; none
 24+  A691              ; Notes:
 25+  A691              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A691              screen_draw:
 27+  A691                  ;call clear_screen
 28+  A691 0E 00            ld c,0                      ; horiz
 29+  A693 06 00            ld b,0                      ; vert, 0 at top
 30+  A695 DD 21 23 AB      ld ix,level01               ; point ix at level data
 31+  A699 FD 21 71 A1      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A69D              screen_draw0:
 33+  A69D DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A6A0 C5               push bc                     ; store bc, contains loop count
 35+  A6A1 CD 03 A8         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A6A4 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A6A5 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A6A8 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A6AB CD F8 A7         call screen_getblock        ; get the block data into hl
 40+  A6AE CD DE A7         call screen_showchar        ; show this character here
 41+  A6B1 C1               pop bc                      ; get the loop counter back
 42+  A6B2 DD 23            inc ix                      ; increment level location
 43+  A6B4 FD 23            inc iy                      ; increment attr location
 44+  A6B6 0C               inc c                       ; increment horiz
 45+  A6B7 79               ld a,c
 46+  A6B8 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A6BA C2 9D A6         jp nz,screen_draw0          ; if not, loop
 48+  A6BD 0E 00            ld c,0                      ; if so, reset horiz
 49+  A6BF 04               inc b                       ; increment vertical
 50+  A6C0 78               ld a,b
 51+  A6C1 FE 1D            cp 29                       ; check if at bottom
 52+  A6C3 C2 9D A6         jp nz,screen_draw0          ; if not, loop
 53+  A6C6 21 77 A6         ld hl, screen_tmp
 54+  A6C9 36 09            ld (hl),9                   ; load the block number into memory
 55+  A6CB DD 21 C3 AE      ld ix,level01rocks          ; rock memory
 56+  A6CF CD 30 A7         call screen_initobjects     ; draw rocks
 57+  A6D2 21 77 A6         ld hl, screen_tmp
 58+  A6D5 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A6D7 DD 21 C3 AF      ld ix,level01missiles       ; missile memory
 60+  A6DB CD 30 A7         call screen_initobjects     ; draw missiles
 61+  A6DE 21 77 A6         ld hl, screen_tmp
 62+  A6E1 36 08            ld (hl),08                  ; load the block number into memory
 63+  A6E3 DD 21 3C B0      ld ix,level01diamonds       ; diamond memory
 64+  A6E7 CD 30 A7         call screen_initobjects     ; draw diamonds
 65+  A6EA 21 77 A6         ld hl, screen_tmp
 66+  A6ED 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A6EF DD 21 4C B0      ld ix,level01gems           ; gems memory
 68+  A6F3 CD 30 A7         call screen_initobjects     ; draw gems
 69+  A6F6 CD FD A6         call screen_setuptext       ; draws text on the screen
 70+  A6F9 CD D1 BB         call scores_printscores     ; print the current scores
 71+  A6FC C9               ret
 72+  A6FD
 73+  A6FD              ;
 74+  A6FD              ; Sets up text on the screen
 75+  A6FD              ;
 76+  A6FD              screen_setuptext:
 77+  A6FD CD F3 BB         call scores_showtable
 78+  A700 CD 85 A6         call screen_sethighscorecolours
 79+  A703 21 D6 80         ld hl, string_score1
 80+  A706 CD 29 84         call string_print
 81+  A709 21 DF 80         ld hl, string_scorenumbers1
 82+  A70C CD 29 84         call string_print
 83+  A70F 21 E8 80         ld hl, string_company
 84+  A712 CD 29 84         call string_print
 85+  A715 21 F9 80         ld hl, string_score2
 86+  A718 CD 29 84         call string_print
 87+  A71B 21 02 81         ld hl, string_scorenumbers2
 88+  A71E CD 29 84         call string_print
 89+  A721 21 EE 80         ld hl, string_credits
 90+  A724 CD 29 84         call string_print
 91+  A727 CD 79 A6         call screen_setscorecolours
 92+  A72A C9               ret
 93+  A72B
 94+  A72B              ;
 95+  A72B              ; Sets a line of colours
 96+  A72B              ; Inputs:
 97+  A72B              ; a - colour to set
 98+  A72B              ; b - number to set
 99+  A72B              ; de - start memory location
100+  A72B              ;
101+  A72B              screen_setcolours:
102+  A72B 12               ld (de),a
103+  A72C 13               inc de
104+  A72D 10 FC            djnz screen_setcolours
105+  A72F C9               ret
106+  A730
107+  A730              ;
108+  A730              ; Draw initial object positions
109+  A730              ; Inputs:
110+  A730              ; ix - memory location of objects
111+  A730              ; a - graphic
112+  A730              screen_initobjects:
113+  A730 DD 4E 00         ld c,(ix)                   ; get the horiz coord
114+  A733 79               ld a,c
115+  A734 FE FF            cp 255
116+  A736 CA 5F A7         jp z,screen_initobjects2
117+  A739 DD 23            inc ix                      ; move to next
118+  A73B DD 46 00         ld b,(ix)                   ; get the vert coord
119+  A73E DD 23            inc ix
120+  A740 CD 71 A7         call screen_getcellattradress ; get the memory address of b,c attr into de
121+  A743 D5               push de
122+  A744 3A 77 A6         ld a,(screen_tmp)                  ; get the block number back
123+  A747 CD 03 A8         call screen_getattr         ; get the memory location for this cell's attr into hl
124+  A74A D1               pop de
125+  A74B 7E               ld a,(hl)                   ; get the attr value at the address
126+  A74C 12               ld (de),a                   ; load the attr into memory
127+  A74D 3A 77 A6         ld a,(screen_tmp)                  ; get the block number back
128+  A750 CD F8 A7         call screen_getblock        ; get the block data into hl
129+  A753 CD DE A7         call screen_showchar        ; show this character here
130+  A756
131+  A756              screen_initobjects1:
132+  A756 DD 23            inc ix                      ; move past state
133+  A758 DD 23            inc ix
134+  A75A DD 23            inc ix                      ; move past mem
135+  A75C C3 30 A7         jp screen_initobjects
136+  A75F              screen_initobjects2:
137+  A75F C9               ret
138+  A760
139+  A760
140+  A760              ;
141+  A760              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
142+  A760              ; Inputs:
143+  A760              ; bc: coords
144+  A760              ; Outputs:
145+  A760              ; de: memory location
146+  A760              ;
147+  A760              screen_getcelladdress:
148+  A760 78               ld a,b      ; vertical position.
149+  A761 E6 18            and 24      ; which segment, 0, 1 or 2?
150+  A763 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
151+  A765 57               ld d,a      ; this is our high byte.
152+  A766 78               ld a,b      ; what was that vertical position again?
153+  A767 E6 07            and 7       ; which row within segment?
154+  A769 0F               rrca        ; multiply row by 32.
155+  A76A 0F               rrca
156+  A76B 0F               rrca
157+  A76C 5F               ld e,a      ; low byte.
158+  A76D 79               ld a,c      ; add on y coordinate.
159+  A76E 83               add a,e     ; mix with low byte.
160+  A76F 5F               ld e,a      ; address of screen position in de.
161+  A770 C9               ret
162+  A771
163+  A771              ;
164+  A771              ; Calculate buffer address of attribute for character at (b, c).
165+  A771              ; Inputs:
166+  A771              ; bc: coords
167+  A771              ; Outputs:
168+  A771              ; de: memory location
169+  A771              ;
170+  A771              screen_getcellattradress:
171+  A771 11 71 A1         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
172+  A774 69               ld l,c      ; x position.
173+  A775 26 00            ld h,0      ; 0 h
174+  A777 19               add hl,de
175+  A778 54 5D            ld de,hl    ; horiz done
176+  A77A 78               ld a,b      ; do vert
177+  A77B D5               push de
178+  A77C C5               push bc
179+  A77D 11 20 00         ld de,32
180+  A780 CD 3A 80         call utilities_multiply
181+  A783 C1               pop bc
182+  A784 D1               pop de
183+  A785 19               add hl,de
184+  A786 54 5D            ld de,hl    ; vert done
185+  A788 C9               ret
186+  A789
187+  A789              ;
188+  A789              ; Calculate buffer address of attribute for character at (b, c).
189+  A789              ; Inputs:
190+  A789              ; bc: coords
191+  A789              ; Outputs:
192+  A789              ; de: memory location
193+  A789              ;
194+  A789              screen_getscreenattradress:
195+  A789 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
196+  A78C 69               ld l,c      ; x position.
197+  A78D 26 00            ld h,0      ; 0 h
198+  A78F 19               add hl,de
199+  A790 54 5D            ld de,hl    ; horiz done
200+  A792 78               ld a,b      ; do vert
201+  A793 D5               push de
202+  A794 C5               push bc
203+  A795 11 20 00         ld de,32
204+  A798 CD 3A 80         call utilities_multiply
205+  A79B C1               pop bc
206+  A79C D1               pop de
207+  A79D 19               add hl,de
208+  A79E 54 5D            ld de,hl    ; vert done
209+  A7A0 C9               ret
210+  A7A1
211+  A7A1              ;
212+  A7A1              ; Gets the attr memory location for a screen coord
213+  A7A1              ; Will overwrite bc
214+  A7A1              ; Inputs:
215+  A7A1              ; bc - screen coords
216+  A7A1              ; Outputs:
217+  A7A1              ; de - memory location
218+  A7A1              ; bc - character coords
219+  A7A1              ;
220+  A7A1              screen_getattraddressfromscreencoords:
221+  A7A1 78               ld a,b                          ; get the player block coords of current block
222+  A7A2 E6 F8            and 248                         ; find closest multiple of eight
223+  A7A4 0F               rrca
224+  A7A5 0F               rrca
225+  A7A6 0F               rrca                ; divide by 8
226+  A7A7 47               ld b,a
227+  A7A8 79               ld a,c
228+  A7A9 48               ld c,b                         ; swap b and c
229+  A7AA E6 F8            and 248
230+  A7AC 0F               rrca
231+  A7AD 0F               rrca
232+  A7AE 0F               rrca                ; divide by 8
233+  A7AF 47               ld b,a
234+  A7B0 CD 71 A7         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
235+  A7B3 C9               ret
236+  A7B4
237+  A7B4
238+  A7B4              ; Gets the nearest cell coords for a screen coord
239+  A7B4              ; Will overwrite bc
240+  A7B4              ; Inputs:
241+  A7B4              ; bc - screen coords
242+  A7B4              ; Outputs:
243+  A7B4              ; bc - character coords
244+  A7B4              ;
245+  A7B4              screen_getcharcoordsfromscreencoords:
246+  A7B4 78               ld a,b                          ; get the player block coords of current block
247+  A7B5 E6 F8            and 248                         ; find closest multiple of eight
248+  A7B7 0F               rrca
249+  A7B8 0F               rrca
250+  A7B9 0F               rrca                ; divide by 8
251+  A7BA 47               ld b,a
252+  A7BB 79               ld a,c
253+  A7BC 48               ld c,b                         ; swap b and c
254+  A7BD E6 F8            and 248
255+  A7BF 0F               rrca
256+  A7C0 0F               rrca
257+  A7C1 0F               rrca                ; divide by 8
258+  A7C2 47               ld b,a
259+  A7C3 C9               ret
260+  A7C4
261+  A7C4              ; Gets the screen coords for a cell coord
262+  A7C4              ; Will overwrite bc
263+  A7C4              ; Inputs:
264+  A7C4              ; bc - char coords
265+  A7C4              ; Outputs:
266+  A7C4              ; bc - screen coords
267+  A7C4              ;
268+  A7C4              screen_getscreencoordsfromcharcoords:
269+  A7C4 78               ld a,b                          ; get the player block coords of current block
270+  A7C5 07               rlca
271+  A7C6 07               rlca
272+  A7C7 07               rlca                ; multiply by 8
273+  A7C8 47               ld b,a
274+  A7C9 79               ld a,c
275+  A7CA 48               ld c,b                         ; swap b and c
276+  A7CB 07               rlca
277+  A7CC 07               rlca
278+  A7CD 07               rlca                ; divide by 8
279+  A7CE 47               ld b,a
280+  A7CF C9               ret
281+  A7D0
282+  A7D0              ;
283+  A7D0              ; Get buffer address for a character at b,c - b vert
284+  A7D0              ; Buffer memory is stored as sequential block
285+  A7D0              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
286+  A7D0              ; Inputs:
287+  A7D0              ; bc - coords
288+  A7D0              ; Outputs:
289+  A7D0              ; de - memory location of first byte
290+  A7D0              screen_getbufferaddress:
291+  A7D0 21 71 84         ld hl, buffer_buffer    ; first get screen buffer start
292+  A7D3 50               ld d,b                  ; then work out vertical offset
293+  A7D4 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
294+  A7D6 19               add hl,de               ; add to base
295+  A7D7 59               ld e,c                  ; then add horizontal offset (c)
296+  A7D8 16 00            ld d,0
297+  A7DA 19               add hl,de               ; add to base
298+  A7DB 54 5D            ld de,hl
299+  A7DD C9               ret
300+  A7DE
301+  A7DE              ;
302+  A7DE              ; Display character hl at (b, c) to buffer.
303+  A7DE              ; Stored sequentially
304+  A7DE              ; Inputs:
305+  A7DE              ; hl: block address
306+  A7DE              ; bc: coords
307+  A7DE              ;
308+  A7DE              screen_showchar:
309+  A7DE 3E 00            ld a,0
310+  A7E0 E5               push hl
311+  A7E1 CD D0 A7         call screen_getbufferaddress ; get the current screen buffer pointer
312+  A7E4 E1               pop hl
313+  A7E5 06 08            ld b,8              ; number of pixels high.
314+  A7E7              screen_showchar0:
315+  A7E7 7E               ld a,(hl)           ; source graphic.
316+  A7E8 12               ld (de),a           ; transfer to screen.
317+  A7E9 23               inc hl              ; next piece of data.
318+  A7EA E5               push hl             ; store hl
319+  A7EB 62 6B            ld hl,de            ; put de in hl
320+  A7ED 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
321+  A7EF 16 00            ld d,0
322+  A7F1 19               add hl,de              ; add de to hl
323+  A7F2 54 5D            ld de,hl            ; load back to de
324+  A7F4 E1               pop hl              ; restore hl
325+  A7F5
326+  A7F5 10 F0            djnz screen_showchar0 ; repeat
327+  A7F7 C9               ret
328+  A7F8
329+  A7F8
330+  A7F8              ;
331+  A7F8              ; Get cell graphic.
332+  A7F8              ; Inputs:
333+  A7F8              ; a: block
334+  A7F8              ; Outputs:
335+  A7F8              ; hl: memory
336+  A7F8              ;
337+  A7F8              screen_getblock:
338+  A7F8 07               rlca                        ; multiply block number by eight.
339+  A7F9 07               rlca
340+  A7FA 07               rlca
341+  A7FB 5F               ld e,a                      ; displacement to graphic address.
342+  A7FC 16 00            ld d,0                      ; no high byte.
343+  A7FE 21 C1 B0         ld hl,sprites               ; address of character blocks.
344+  A801 19               add hl,de                   ; point to block.
345+  A802 C9               ret
346+  A803
347+  A803              ;
348+  A803              ; Get cell attribute.
349+  A803              ; Inputs:
350+  A803              ; a: block
351+  A803              ; Outputs:
352+  A803              ; hl: memory
353+  A803              ;
354+  A803              screen_getattr:
355+  A803 5F               ld e,a                      ; displacement to attribute address.
356+  A804 16 00            ld d,0                      ; no high byte.
357+  A806 21 39 B1         ld hl,sprite_attrs          ; address of block attributes.
358+  A809 19               add hl,de                   ; point to attribute.
359+  A80A C9               ret
360+  A80B
# file closed: screen/screen.asm
 25   A80B                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A80B              ;
  2+  A80B              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A80B              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A80B              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A80B              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A80B              ; routine takes care of all the shifting itself. This means that sprite
  7+  A80B              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A80B              ; space they would require in pre-shifted form.
  9+  A80B              ; Inputs:
 10+  A80B              ; hl - sprite data
 11+  A80B              ; bc - screen coords
 12+  A80B              ;
 13+  A80B              sprites_drawsprite7:
 14+  A80B EE 07            xor 7               ; complement last 3 bits.
 15+  A80D 3C               inc a               ; add one for luck!
 16+  A80E              sprites_drawsprite3:
 17+  A80E CB 11            rl c                ; ...into middle byte...
 18+  A810 CB 12            rl d                ; ...and finally into left character cell.
 19+  A812 3D               dec a               ; count shifts we've done.
 20+  A813 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A815                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A815 79               ld a,c              ; left edge of image is currently in e.
 23+  A816 4A               ld c,d              ; put right edge there instead.
 24+  A817 57               ld d,a              ; and the left edge back into c.
 25+  A818 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A81A              sprites_drawsprite:
 27+  A81A ED 43 7F A8      ld (dispx),bc       ; store coords in dispx for now.
 28+  A81E E5               push hl
 29+  A81F CD 5D A8         call sprites_scadd  ; calculate screen address.
 30+  A822 E1               pop hl
 31+  A823 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A825              sprites_drawsprite1:
 33+  A825 08               ex af,af'           ; store loop counter.
 34+  A826 D5               push de             ; store screen address.
 35+  A827 4E               ld c,(hl)           ; first sprite graphic.
 36+  A828 23               inc hl              ; increment poiinter to sprite data.
 37+  A829 22 81 A8         ld (sprtmp),hl      ; store it for later.
 38+  A82C 16 00            ld d,0              ; blank right byte for now.
 39+  A82E 78               ld a,b              ; b holds y position.
 40+  A82F E6 07            and 7               ; how are we straddling character cells?
 41+  A831 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A833 FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A835 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A837 A7               and a               ; oops, carry flag is set so clear it.
 45+  A838              sprites_drawsprite2:
 46+  A838 CB 19            rr c                ; rotate left byte right...
 47+  A83A CB 1A            rr d                ; ...into right byte.
 48+  A83C 3D               dec a               ; one less shift to do.
 49+  A83D 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A83F              sprites_drawsprite0:
 51+  A83F E1               pop hl              ; pop screen address from stack.
 52+  A840 7E               ld a,(hl)           ; what's there already.
 53+  A841 A9               xor c               ; merge in image data.
 54+  A842 77               ld (hl),a           ; place onto screen.
 55+  A843 23               inc hl
 56+  A844 7E               ld a,(hl)           ; what's already there.
 57+  A845 AA               xor d               ; right edge of sprite image data.
 58+  A846 77               ld (hl),a           ; plonk it on screen.
 59+  A847 3A 7F A8         ld a,(dispx)        ; vertical coordinate.
 60+  A84A 3C               inc a               ; next line down.
 61+  A84B 32 7F A8         ld (dispx),a        ; store new position.
 62+  A84E 2B               dec hl
 63+  A84F 11 20 00         ld de,32            ; add 32 to get to the next row
 64+  A852 19               add hl,de           ; add 32
 65+  A853              sprites_drawsprite6:
 66+  A853 EB               ex de,hl            ; screen address in de.
 67+  A854 2A 81 A8         ld hl,(sprtmp)      ; restore graphic address.
 68+  A857 08               ex af,af'           ; restore loop counter.
 69+  A858 3D               dec a               ; decrement it.
 70+  A859 C2 25 A8         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 71+  A85C C9               ret                 ; job done.
 72+  A85D
 73+  A85D              ;
 74+  A85D              ; This routine returns a buffer address for (c, b) in de (c vert).
 75+  A85D              ; For example: 0,0 will be at memory offset 0
 76+  A85D              ; 1,0 (1 down) will be at memory offset 1
 77+  A85D              ; 0,7 will be at memory offset 0
 78+  A85D              ; 9,1 will be at memory offset 8+1
 79+  A85D              ; 8,0 will be at memory offset 256
 80+  A85D              ; 9,0 will be at memory offset 257
 81+  A85D              ; Outputs:
 82+  A85D              ; de - coords
 83+  A85D              ;
 84+  A85D              sprites_scadd:
 85+  A85D 79               ld a,c               ; calculate vertical offset
 86+  A85E E6 F8            and 248             ;  to get nearest multiple of 8
 87+  A860 0F               rrca
 88+  A861 0F               rrca
 89+  A862 0F               rrca                ; divide by 8
 90+  A863 67               ld h,a
 91+  A864 78               ld a,b               ; calculate horizontal offset
 92+  A865 E6 F8            and 248             ;  to get nearest multiple of 8
 93+  A867 0F               rrca
 94+  A868 0F               rrca
 95+  A869 0F               rrca                ; divide by 8
 96+  A86A 6F               ld l,a
 97+  A86B C5               push bc             ; store the screen coords
 98+  A86C 44 4D            ld bc,hl            ; load bc with the character coords
 99+  A86E CD D0 A7         call screen_getbufferaddress
100+  A871 C1               pop bc              ; get back screen coords, de is now memory of character
101+  A872 79               ld a,c              ; now add the vertical within the cell
102+  A873 E6 07            and 7
103+  A875 0F               rrca                ; multiply by 32.
104+  A876 0F               rrca
105+  A877 0F               rrca
106+  A878 6F               ld l,a
107+  A879 26 00            ld h,0
108+  A87B 19               add hl,de
109+  A87C 54 5D            ld de,hl
110+  A87E C9               ret
111+  A87F
112+  A87F 00           dispx   defb 0           ; general-use coordinates.
113+  A880 00           dispy   defb 0
114+  A881 00 00        sprtmp  defb 0,0           ; sprite temporary address.
115+  A883
# file closed: screen/sprites.asm
 26   A883                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  A883              ;
  2+  A883              ; Draws the title screen
  3+  A883              ;
  4+  A883              titlescreen_show:
  5+  A883 CD FB A8         call titlescreen_init
  6+  A886 CD A4 A8         call titlescreen_drawtitle
  7+  A889 3E FA            ld a,250                              ; wait for 200 frames
  8+  A88B CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
  9+  A88E 7B               ld a,e
 10+  A88F FE 01            cp 1                                  ; was anything pressed?
 11+  A891 C8               ret z                                 ; end titlescreen if so
 12+  A892
 13+  A892 CD 0E A9         call titlescreen_alt_init             ; otherwise, draw alt screen
 14+  A895 CD C0 A8         call titlescreen_alt_drawtitle
 15+  A898 3E FA            ld a,250                              ; wait for 200 frames
 16+  A89A CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 17+  A89D 7B               ld a,e
 18+  A89E FE 01            cp 1                                  ; was anything pressed?
 19+  A8A0 C2 83 A8         jp nz,titlescreen_show                ; start again if not
 20+  A8A3 C9               ret
 21+  A8A4
 22+  A8A4              ;
 23+  A8A4              ; Draws the iconic logo
 24+  A8A4              ;
 25+  A8A4              titlescreen_drawtitle:
 26+  A8A4 06 66            ld b,102              ; number of points
 27+  A8A6 DD 21 1B A9      ld ix,titlescreen_logo_data
 28+  A8AA              titlescreen_drawtitle0:
 29+  A8AA C5               push bc
 30+  A8AB DD 4E 00         ld c,(ix)                   ; got horiz
 31+  A8AE DD 23            inc ix
 32+  A8B0 DD 46 00         ld b,(ix)                   ; got vert
 33+  A8B3 DD 23            inc ix
 34+  A8B5 CD 89 A7         call screen_getscreenattradress ; memory in de
 35+  A8B8 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 36+  A8B9 3E 13            ld a,19
 37+  A8BB 12               ld (de),a
 38+  A8BC C1               pop bc
 39+  A8BD 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 40+  A8BF C9               ret
 41+  A8C0
 42+  A8C0              ;
 43+  A8C0              ; Draws the alternate title screen
 44+  A8C0              ;
 45+  A8C0              titlescreen_alt_drawtitle:
 46+  A8C0 21 25 81         ld hl,string_alttitlescreen_1
 47+  A8C3 CD 29 84         call string_print
 48+  A8C6 21 31 81         ld hl,string_alttitlescreen_2
 49+  A8C9 CD 29 84         call string_print
 50+  A8CC 21 2C 82         ld hl,string_alttitlescreen_3
 51+  A8CF CD 29 84         call string_print
 52+  A8D2 06 20            ld b,32
 53+  A8D4 3E 43            ld a,67
 54+  A8D6 11 00 58         ld de,22528                         ; top row attrs here
 55+  A8D9 CD 2B A7         call screen_setcolours
 56+  A8DC 06 20            ld b,32
 57+  A8DE 3E 46            ld a,70
 58+  A8E0 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 59+  A8E3 CD 2B A7         call screen_setcolours
 60+  A8E6 06 20            ld b,32
 61+  A8E8 3E 43            ld a,67
 62+  A8EA 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 63+  A8ED CD 2B A7         call screen_setcolours
 64+  A8F0 06 20            ld b,32
 65+  A8F2 3E 42            ld a,66
 66+  A8F4 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 67+  A8F7 CD 2B A7         call screen_setcolours
 68+  A8FA C9               ret
 69+  A8FB
 70+  A8FB              ;
 71+  A8FB              ; Initialises the screen
 72+  A8FB              ;
 73+  A8FB              titlescreen_init:
 74+  A8FB              ; We want a black screen.
 75+  A8FB 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 76+  A8FD                                      ; bright (64).
 77+  A8FD CD 67 80         call utilities_clearscreen
 78+  A900 32 8D 5C         ld (23693),a        ; set our screen colours.
 79+  A903 3E 01            ld a,1              ; 2 is the code for red.
 80+  A905 D3 FE            out (254),a         ; write to port 254.
 81+  A907
 82+  A907 21 0B 81         ld hl,string_titlescreen_copyright
 83+  A90A CD 29 84         call string_print
 84+  A90D
 85+  A90D C9               ret
 86+  A90E
 87+  A90E              ;
 88+  A90E              ; Initialises the screen
 89+  A90E              ;
 90+  A90E              titlescreen_alt_init:
 91+  A90E              ; We want a black screen.
 92+  A90E 3E 47            ld a,71             ; white ink (7) on black paper (0),
 93+  A910                                      ; bright (64).
 94+  A910 CD 67 80         call utilities_clearscreen
 95+  A913 32 8D 5C         ld (23693),a        ; set our screen colours.
 96+  A916 3E 00            ld a,0              ; 2 is the code for red.
 97+  A918 D3 FE            out (254),a         ; write to port 254.
 98+  A91A
 99+  A91A C9               ret
100+  A91B
101+  A91B              ;
102+  A91B              ; Horiz, vert
103+  A91B              ;
104+  A91B              titlescreen_logo_data:
105+  A91B 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
105+  A91F 0A 00 0C 00
105+  A923 0F 00 11 00
105+  A927 12 00 13 00
106+  A92B 09 01 0C 01      defb 9,1,12,1,15,1,17,1
106+  A92F 0F 01 11 01
107+  A933 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
107+  A937 0D 02 0E 02
107+  A93B 0F 02 11 02
107+  A93F 12 02 13 02
108+  A943 09 03 0C 03      defb 9,3,12,3,15,3,17,3
108+  A947 0F 03 11 03
109+  A94B 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
109+  A94F 0F 04 11 04
109+  A953 12 04 13 04
110+  A957 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
110+  A95B 02 06 03 06
110+  A95F 04 06 05 06
110+  A963 06 06 07 06
110+  A967 08 06 09 06
110+  A96B 0A 06 0B 06
111+  A96F 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
111+  A973 12 06 13 06
111+  A977 14 06 15 06
111+  A97B 16 06 17 06
111+  A97F 18 06 19 06
111+  A983 1A 06 1B 06
112+  A987 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20
112+  A98B 02 09 02 0A
112+  A98F 02 0B 02 0C
112+  A993 02 0D 02 0E
112+  A997 02 0F 02 10
112+  A99B 02 11 02 12
112+  A99F 02 13 02 14
113+  A9A3 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20
113+  A9A7 19 09 19 0A
113+  A9AB 19 0B 19 0C
113+  A9AF 19 0D 19 0E
113+  A9B3 19 0F 19 10
113+  A9B7 19 11 19 12
113+  A9BB 19 13 19 14
114+  A9BF 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
114+  A9C3 05 0B 06 0B
114+  A9C7 07 0B 08 0B
114+  A9CB 09 0B 0A 0B
114+  A9CF 0B 0B
115+  A9D1 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
115+  A9D5 0B 09 0B 0A
116+  A9D9 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19,16,20
116+  A9DD 10 10 10 11
116+  A9E1 10 12 10 13
116+  A9E5 10 14
117+  A9E7
# file closed: screen/titlescreen.asm
 27   A9E7                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  A9E7              ;
  2+  A9E7              ; Draws the life remaining screen
  3+  A9E7              ;
  4+  A9E7              lifescreen_draw:
  5+  A9E7 CD 2D AA         call lifescreen_init
  6+  A9EA
  7+  A9EA 3A A5 B6         ld a,(game_currentplayer)             ; get the current player
  8+  A9ED C6 30            add 48                                ; add 48 to get char
  9+  A9EF 21 32 83         ld hl,string_lifescreen_player+10
 10+  A9F2 77               ld (hl),a                             ; load this to the string we're about to show
 11+  A9F3
 12+  A9F3 21 28 83         ld hl,string_lifescreen_player
 13+  A9F6 CD 29 84         call string_print
 14+  A9F9
 15+  A9F9 3A DC B6         ld a,(player+9)                       ; get the current player lives
 16+  A9FC C6 30            add 48                                ; add 48 to get the character
 17+  A9FE FE 31            cp 49
 18+  AA00 C2 13 AA         jp nz,lifescreen_draw0
 19+  AA03 21 42 83         ld hl,string_lifescreen_lastman
 20+  AA06
 21+  AA06 06 08            ld b,8
 22+  AA08 3E 0A            ld a,10                                ; set red
 23+  AA0A 11 6C 58         ld de,22528+108                        ; attrs here
 24+  AA0D CD 2B A7         call screen_setcolours
 25+  AA10
 26+  AA10 C3 1A AA         jp lifescreen_draw1
 27+  AA13              lifescreen_draw0:
 28+  AA13 21 37 83         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  AA16 77               ld (hl),a                             ; load this to the string we're about to show
 30+  AA17 21 35 83         ld hl,string_lifescreen_lives
 31+  AA1A              lifescreen_draw1:
 32+  AA1A CD 29 84         call string_print
 33+  AA1D
 34+  AA1D 3E 86            ld a,134
 35+  AA1F 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AA22 06 0A            ld b,10
 37+  AA24 CD 2B A7         call screen_setcolours
 38+  AA27
 39+  AA27 3E 64            ld a,100                              ; wait for 200 frames
 40+  AA29 CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 41+  AA2C
 42+  AA2C C9               ret
 43+  AA2D
 44+  AA2D              ;
 45+  AA2D              ; Initialises the screen
 46+  AA2D              ;
 47+  AA2D              lifescreen_init:
 48+  AA2D              ; We want a blue screen.
 49+  AA2D                  ;call $0D6B
 50+  AA2D 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 51+  AA2F                                      ; bright (64).
 52+  AA2F CD 67 80         call utilities_clearscreen
 53+  AA32 32 8D 5C         ld (23693),a        ; set our screen colours.
 54+  AA35 3E 01            ld a,1              ; 1 is the code for blue.
 55+  AA37 D3 FE            out (254),a         ; write to port 254.
 56+  AA39                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 57+  AA39
 58+  AA39 C9               ret
# file closed: screen/lifescreen.asm
 28   AA3A                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AA3A              ;
  2+  AA3A              ; Draws the game over screen
  3+  AA3A              ;
  4+  AA3A              gameover_draw:
  5+  AA3A CD 07 BC         call scores_processhighscores
  6+  AA3D
  7+  AA3D              gameover_draw0:
  8+  AA3D CD 7D AA         call gameover_enterhighscores
  9+  AA40
 10+  AA40 CD 16 AB         call gameover_init
 11+  AA43
 12+  AA43 21 4D 83         ld hl,string_gameoverscreen_gameover
 13+  AA46 CD 29 84         call string_print
 14+  AA49
 15+  AA49 21 59 83         ld hl,string_gameoverscreen_copyright
 16+  AA4C CD 29 84         call string_print
 17+  AA4F
 18+  AA4F CD 60 AA         call gameover_commontext
 19+  AA52
 20+  AA52 06 0B            ld b,11
 21+  AA54 3E 42            ld a,66
 22+  AA56 11 2B 58         ld de,22528+43                         ; attrs here
 23+  AA59 CD 2B A7         call screen_setcolours
 24+  AA5C CD 47 80         call utilities_waitforkey   ; wait for keypress
 25+  AA5F
 26+  AA5F C9               ret
 27+  AA60
 28+  AA60              ;
 29+  AA60              ; Draws text shared by the game over and high score screens
 30+  AA60              ;
 31+  AA60              gameover_commontext:
 32+  AA60 CD FD A6         call screen_setuptext       ; show scores
 33+  AA63 CD D1 BB         call scores_printscores     ; print the current scores
 34+  AA66
 35+  AA66 21 87 83         ld hl,string_gameover_credits
 36+  AA69 CD 29 84         call string_print
 37+  AA6C
 38+  AA6C 21 73 83         ld hl,string_gameoverscreen_bestscores
 39+  AA6F CD 29 84         call string_print
 40+  AA72
 41+  AA72 06 20            ld b,32
 42+  AA74 3E 45            ld a,69
 43+  AA76 11 C0 5A         ld de,22528+704                         ; attrs here
 44+  AA79 CD 2B A7         call screen_setcolours
 45+  AA7C
 46+  AA7C C9               ret
 47+  AA7D
 48+  AA7D              ;
 49+  AA7D              ; If required, enter highscore
 50+  AA7D              ;
 51+  AA7D              gameover_enterhighscores:
 52+  AA7D                  ; check if we need to enter initial
 53+  AA7D 3A 06 BC         ld a,(scores_highscoretmp)
 54+  AA80 FE 00            cp 0
 55+  AA82 C8               ret z
 56+  AA83 CD AC AA         call gameover_enterhighscores_init
 57+  AA86 3A 06 BC         ld a,(scores_highscoretmp)
 58+  AA89 3D               dec a
 59+  AA8A 3D               dec a
 60+  AA8B 3D               dec a                                   ; get high score location back to position of name
 61+  AA8C 16 00            ld d,0
 62+  AA8E 5F               ld e,a
 63+  AA8F 21 8D BB         ld hl,scores_table
 64+  AA92 19               add hl,de                               ; load memory into hl
 65+  AA93 08               ex af,af'
 66+  AA94 06 03            ld b,3                                  ; collect three chars
 67+  AA96              gameover_draw2:
 68+  AA96 C5               push bc
 69+  AA97 E5               push hl
 70+  AA98 CD 86 80         call utilities_readkey               ; get key into a
 71+  AA9B E1               pop hl
 72+  AA9C 77               ld (hl),a
 73+  AA9D 23               inc hl
 74+  AA9E E5               push hl
 75+  AA9F CD F3 BB         call scores_showtable
 76+  AAA2 E1               pop hl
 77+  AAA3 06 0F            ld b,15
 78+  AAA5 CD 82 80         call utilities_pauseforframes
 79+  AAA8 C1               pop bc
 80+  AAA9 10 EB            djnz gameover_draw2
 81+  AAAB C9               ret
 82+  AAAC
 83+  AAAC              ;
 84+  AAAC              ; Displays the screen text for high score entry
 85+  AAAC              ;
 86+  AAAC              gameover_enterhighscores_init:
 87+  AAAC
 88+  AAAC CD 16 AB         call gameover_init
 89+  AAAF CD 60 AA         call gameover_commontext
 90+  AAB2
 91+  AAB2 21 93 83         ld hl,string_highscore_congratulations
 92+  AAB5 CD 29 84         call string_print
 93+  AAB8
 94+  AAB8 3A A5 B6         ld a,(game_currentplayer)
 95+  AABB FE 01            cp 1
 96+  AABD 21 A5 83         ld hl,string_highscore_player1
 97+  AAC0 C3 C6 AA         jp gameover_enterhighscores_init1
 98+  AAC3              gameover_enterhighscores_init0:
 99+  AAC3 21 B0 83         ld hl,string_highscore_player2
100+  AAC6              gameover_enterhighscores_init1:
101+  AAC6 CD 29 84         call string_print
102+  AAC9
103+  AAC9 06 60            ld b,96
104+  AACB 3E 43            ld a,67
105+  AACD 11 A0 58         ld de,22528+160                         ; attrs here
106+  AAD0 CD 2B A7         call screen_setcolours
107+  AAD3
108+  AAD3 21 BB 83         ld hl,string_highscore_youhaveearned
109+  AAD6 CD 29 84         call string_print
110+  AAD9
111+  AAD9 3A 06 BC         ld a,(scores_highscoretmp)
112+  AADC FE 05            cp 5
113+  AADE CA EC AA         jp z, gameover_enterhighscores_init2    ; first place
114+  AAE1 FE 11            cp 17
115+  AAE3 CA F2 AA         jp z, gameover_enterhighscores_init3    ; 2nd place
116+  AAE6 21 F7 83         ld hl,string_highscore_place3           ; 3rd place
117+  AAE9 C3 F8 AA         jp gameover_enterhighscores_init4
118+  AAEC              gameover_enterhighscores_init2
119+  AAEC 21 CD 83         ld hl,string_highscore_place1
120+  AAEF C3 F8 AA         jp gameover_enterhighscores_init4
121+  AAF2              gameover_enterhighscores_init3
122+  AAF2 21 E2 83         ld hl,string_highscore_place2
123+  AAF5 C3 F8 AA         jp gameover_enterhighscores_init4
124+  AAF8              gameover_enterhighscores_init4
125+  AAF8 CD 29 84         call string_print
126+  AAFB
127+  AAFB 06 60            ld b,96
128+  AAFD 3E 42            ld a,66
129+  AAFF 11 40 59         ld de,22528+320                         ; attrs here
130+  AB02 CD 2B A7         call screen_setcolours
131+  AB05
132+  AB05 21 0C 84         ld hl,string_highscore_pleaseenter
133+  AB08 CD 29 84         call string_print
134+  AB0B
135+  AB0B 06 60            ld b,96
136+  AB0D 3E 46            ld a,70
137+  AB0F 11 E0 59         ld de,22528+480                         ; attrs here
138+  AB12 CD 2B A7         call screen_setcolours
139+  AB15 C9               ret
140+  AB16
141+  AB16              ;
142+  AB16              ; Initialises the screen
143+  AB16              ;
144+  AB16              gameover_init:
145+  AB16              ; We want a black screen.
146+  AB16 3E 47            ld a,71             ; white ink (7) on black paper (0),
147+  AB18                                      ; bright (64).
148+  AB18 CD 67 80         call utilities_clearscreen
149+  AB1B 32 8D 5C         ld (23693),a        ; set our screen colours.
150+  AB1E 3E 00            ld a,0              ; 2 is the code for red.
151+  AB20 D3 FE            out (254),a         ; write to port 254.
152+  AB22 C9               ret
# file closed: screen/gameover.asm
 29   AB23
 30   AB23                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  AB23              ; ###############################################################
  2+  AB23              ; Data for level 1
  3+  AB23              ; ###############################################################
  4+  AB23              level01:
  5+  AB23
  6+  AB23                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  AB23
  8+  AB23 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  AB27 05 05 05 05
  8+  AB2B 05 05 05 05
  8+  AB2F 05 05 02 01
  8+  AB33 01 01 03 05
  8+  AB37 05 05 05 05
  8+  AB3B 05 05 05 05
  8+  AB3F 05 05 00 00
  9+  AB43 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  AB47 05 05 05 05
  9+  AB4B 05 05 05 05
  9+  AB4F 02 01 01 01
  9+  AB53 01 01 01 01
  9+  AB57 03 05 05 05
  9+  AB5B 05 05 05 05
  9+  AB5F 05 05 00 00
 10+  AB63 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  AB67 05 05 05 05
 10+  AB6B 05 05 02 01
 10+  AB6F 01 01 01 01
 10+  AB73 01 01 01 01
 10+  AB77 01 01 03 05
 10+  AB7B 0D 0D 0D 0D
 10+  AB7F 0D 0D 00 00
 11+  AB83 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  AB87 01 01 00 01
 11+  AB8B 01 01 01 01
 11+  AB8F 01 01 01 01
 11+  AB93 01 01 01 01
 11+  AB97 01 01 01 03
 11+  AB9B 05 05 05 05
 11+  AB9F 05 05 00 00
 12+  ABA3 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  ABA7 04 04 04 04
 12+  ABAB 04 04 01 01
 12+  ABAF 01 01 01 01
 12+  ABB3 01 01 01 01
 12+  ABB7 01 01 01 01
 12+  ABBB 01 01 01 01
 12+  ABBF 00 01 00 00
 13+  ABC3 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  ABC7 04 04 04 04
 13+  ABCB 04 04 04 04
 13+  ABCF 01 01 01 01
 13+  ABD3 01 01 01 01
 13+  ABD7 01 01 01 01
 13+  ABDB 00 00 00 00
 13+  ABDF 00 01 00 00
 14+  ABE3 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  ABE7 04 01 01 01
 14+  ABEB 01 01 04 04
 14+  ABEF 04 04 01 01
 14+  ABF3 01 01 01 01
 14+  ABF7 01 00 00 00
 14+  ABFB 00 01 01 01
 14+  ABFF 01 01 00 00
 15+  AC03 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  AC07 04 04 04 04
 15+  AC0B 04 01 04 04
 15+  AC0F 04 04 04 04
 15+  AC13 04 04 00 00
 15+  AC17 00 00 04 04
 15+  AC1B 04 04 04 04
 15+  AC1F 04 01 00 00
 16+  AC23 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  AC27 01 04 01 01
 16+  AC2B 01 01 04 04
 16+  AC2F 04 04 04 04
 16+  AC33 04 04 00 04
 16+  AC37 04 04 04 04
 16+  AC3B 04 04 04 04
 16+  AC3F 04 01 00 00
 17+  AC43 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  AC47 00 00 00 00
 17+  AC4B 00 04 04 04
 17+  AC4F 04 04 04 04
 17+  AC53 04 04 00 04
 17+  AC57 04 04 04 04
 17+  AC5B 04 04 04 04
 17+  AC5F 04 01 00 00
 18+  AC63 00 00 01 07      defb 00,00,01,07,07,07,07,07,07,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  AC67 07 07 07 07
 18+  AC6B 07 01 04 04
 18+  AC6F 04 04 04 04
 18+  AC73 04 04 00 04
 18+  AC77 04 04 04 04
 18+  AC7B 04 04 04 04
 18+  AC7F 04 01 00 00
 19+  AC83 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  AC87 00 00 00 00
 19+  AC8B 00 01 04 04
 19+  AC8F 04 04 04 04
 19+  AC93 04 04 00 04
 19+  AC97 04 04 04 04
 19+  AC9B 04 00 00 00
 19+  AC9F 00 01 00 00
 20+  ACA3 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  ACA7 00 00 00 00
 20+  ACAB 00 01 04 04
 20+  ACAF 04 04 04 04
 20+  ACB3 04 04 00 04
 20+  ACB7 04 04 04 04
 20+  ACBB 04 00 04 04
 20+  ACBF 00 01 00 00
 21+  ACC3 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  ACC7 06 06 06 06
 21+  ACCB 06 01 04 04
 21+  ACCF 04 04 04 04
 21+  ACD3 04 04 00 04
 21+  ACD7 04 04 04 04
 21+  ACDB 04 00 04 04
 21+  ACDF 00 01 00 00
 22+  ACE3 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  ACE7 06 06 06 06
 22+  ACEB 06 01 04 00
 22+  ACEF 00 00 00 00
 22+  ACF3 00 00 00 00
 22+  ACF7 00 00 00 00
 22+  ACFB 00 00 04 04
 22+  ACFF 00 01 00 00
 23+  AD03 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  AD07 06 06 06 06
 23+  AD0B 06 01 04 00
 23+  AD0F 04 04 04 04
 23+  AD13 04 04 00 04
 23+  AD17 04 04 00 04
 23+  AD1B 04 04 04 04
 23+  AD1F 00 01 00 00
 24+  AD23 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  AD27 06 06 06 06
 24+  AD2B 06 01 04 00
 24+  AD2F 04 04 04 04
 24+  AD33 04 04 00 04
 24+  AD37 04 04 00 04
 24+  AD3B 04 04 04 04
 24+  AD3F 00 01 00 00
 25+  AD43 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  AD47 01 01 01 01
 25+  AD4B 01 01 04 00
 25+  AD4F 04 04 04 04
 25+  AD53 04 04 00 04
 25+  AD57 04 04 00 04
 25+  AD5B 04 04 04 04
 25+  AD5F 00 01 00 00
 26+  AD63 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  AD67 04 04 04 04
 26+  AD6B 04 04 04 00
 26+  AD6F 04 04 04 04
 26+  AD73 04 04 00 04
 26+  AD77 04 04 00 00
 26+  AD7B 00 00 04 04
 26+  AD7F 04 01 00 00
 27+  AD83 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  AD87 04 04 00 00
 27+  AD8B 00 00 00 00
 27+  AD8F 04 04 04 04
 27+  AD93 04 04 00 04
 27+  AD97 04 04 04 04
 27+  AD9B 04 00 04 04
 27+  AD9F 04 01 00 00
 28+  ADA3 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  ADA7 04 04 00 04
 28+  ADAB 04 04 04 04
 28+  ADAF 04 04 04 04
 28+  ADB3 04 04 00 04
 28+  ADB7 04 04 04 04
 28+  ADBB 04 00 04 04
 28+  ADBF 04 01 00 00
 29+  ADC3 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  ADC7 04 04 00 04
 29+  ADCB 04 04 01 01
 29+  ADCF 01 01 01 01
 29+  ADD3 01 01 01 01
 29+  ADD7 01 01 01 01
 29+  ADDB 04 00 04 04
 29+  ADDF 04 01 00 00
 30+  ADE3 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  ADE7 04 04 00 04
 30+  ADEB 04 04 01 00
 30+  ADEF 00 00 00 00
 30+  ADF3 00 00 00 00
 30+  ADF7 00 00 00 01
 30+  ADFB 04 00 04 04
 30+  ADFF 04 01 00 00
 31+  AE03 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  AE07 04 04 00 04
 31+  AE0B 04 04 01 00
 31+  AE0F 00 00 00 00
 31+  AE13 00 00 00 00
 31+  AE17 00 00 00 01
 31+  AE1B 04 00 04 04
 31+  AE1F 04 01 00 00
 32+  AE23 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  AE27 04 04 00 04
 32+  AE2B 04 04 01 00
 32+  AE2F 00 00 00 00
 32+  AE33 00 00 00 00
 32+  AE37 00 00 00 01
 32+  AE3B 04 00 04 04
 32+  AE3F 04 01 00 00
 33+  AE43 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  AE47 04 04 00 04
 33+  AE4B 04 04 04 00
 33+  AE4F 00 00 00 00
 33+  AE53 00 00 00 00
 33+  AE57 00 00 00 04
 33+  AE5B 04 04 04 04
 33+  AE5F 04 01 00 00
 34+  AE63 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  AE67 04 04 04 04
 34+  AE6B 04 04 01 00
 34+  AE6F 00 00 00 00
 34+  AE73 00 00 00 00
 34+  AE77 00 00 00 01
 34+  AE7B 04 04 04 04
 34+  AE7F 04 01 00 00
 35+  AE83 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  AE87 04 04 04 04
 35+  AE8B 04 04 01 00
 35+  AE8F 00 00 01 00
 35+  AE93 00 00 00 01
 35+  AE97 00 00 00 01
 35+  AE9B 04 04 04 04
 35+  AE9F 04 01 00 00
 36+  AEA3 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  AEA7 01 01 01 01
 36+  AEAB 01 01 01 01
 36+  AEAF 01 01 01 01
 36+  AEB3 01 01 01 01
 36+  AEB7 01 01 01 01
 36+  AEBB 01 01 01 01
 36+  AEBF 01 01 00 00
 37+  AEC3
 38+  AEC3              ; ###############################################################
 39+  AEC3              ; Object data: horiz, vert, state, memh, meml
 40+  AEC3              ; ###############################################################
 41+  AEC3              level01rocks:
 42+  AEC3 09 04 00 00      defb 9,4,0,0,0
 42+  AEC7 00
 43+  AEC8 0C 07 00 00      defb 12,7,0,0,0
 43+  AECC 00
 44+  AECD 10 07 00 00      defb 16,7,0,0,0
 44+  AED1 00
 45+  AED2 0B 08 00 00      defb 11,8,0,0,0
 45+  AED6 00
 46+  AED7 0A 0A 00 00      defb 10,10,0,0,0
 46+  AEDB 00
 47+  AEDC 0C 0A 00 00      defb 12,10,0,0,0
 47+  AEE0 00
 48+  AEE1 0D 09 00 00      defb 13,9,0,0,0
 48+  AEE5 00
 49+  AEE6 0E 08 00 00      defb 14,8,0,0,0
 49+  AEEA 00
 50+  AEEB 0F 0B 00 00      defb 15,11,0,0,0
 50+  AEEF 00
 51+  AEF0 0B 0C 00 00      defb 11,12,0,0,0
 51+  AEF4 00
 52+  AEF5 11 0C 00 00      defb 17,12,0,0,0
 52+  AEF9 00
 53+  AEFA 13 08 00 00      defb 19,8,0,0,0
 53+  AEFE 00
 54+  AEFF 16 09 00 00      defb 22,9,0,0,0
 54+  AF03 00
 55+  AF04 13 0A 00 00      defb 19,10,0,0,0
 55+  AF08 00
 56+  AF09 15 0A 00 00      defb 21,10,0,0,0
 56+  AF0D 00
 57+  AF0E 15 0C 00 00      defb 21,12,0,0,0
 57+  AF12 00
 58+  AF13 16 0C 00 00      defb 22,12,0,0,0
 58+  AF17 00
 59+  AF18 18 0A 00 00      defb 24,10,0,0,0
 59+  AF1C 00
 60+  AF1D 19 09 00 00      defb 25,9,0,0,0
 60+  AF21 00
 61+  AF22 1C 09 00 00      defb 28,9,0,0,0
 61+  AF26 00
 62+  AF27 1B 0C 00 00      defb 27,12,0,0,0
 62+  AF2B 00
 63+  AF2C 1A 0D 00 00      defb 26,13,0,0,0
 63+  AF30 00
 64+  AF31 19 0E 00 00      defb 25,14,0,0,0
 64+  AF35 00
 65+  AF36 19 10 00 00      defb 25,16,0,0,0
 65+  AF3A 00
 66+  AF3B 1A 11 00 00      defb 26,17,0,0,0
 66+  AF3F 00
 67+  AF40 1B 11 00 00      defb 27,17,0,0,0
 67+  AF44 00
 68+  AF45 1C 12 00 00      defb 28,18,0,0,0
 68+  AF49 00
 69+  AF4A 1A 13 00 00      defb 26,19,0,0,0
 69+  AF4E 00
 70+  AF4F 1B 15 00 00      defb 27,21,0,0,0
 70+  AF53 00
 71+  AF54 1A 17 00 00      defb 26,23,0,0,0
 71+  AF58 00
 72+  AF59 1B 18 00 00      defb 27,24,0,0,0
 72+  AF5D 00
 73+  AF5E 19 18 00 00      defb 25,24,0,0,0
 73+  AF62 00
 74+  AF63 18 17 00 00      defb 24,23,0,0,0
 74+  AF67 00
 75+  AF68 13 14 00 00      defb 19,20,0,0,0
 75+  AF6C 00
 76+  AF6D 14 12 00 00      defb 20,18,0,0,0
 76+  AF71 00
 77+  AF72 14 10 00 00      defb 20,16,0,0,0
 77+  AF76 00
 78+  AF77 15 10 00 00      defb 21,16,0,0,0
 78+  AF7B 00
 79+  AF7C 16 12 00 00      defb 22,18,0,0,0
 79+  AF80 00
 80+  AF81 11 14 00 00      defb 17,20,0,0,0
 80+  AF85 00
 81+  AF86 0D 11 00 00      defb 13,17,0,0,0
 81+  AF8A 00
 82+  AF8B 0C 13 00 00      defb 12,19,0,0,0
 82+  AF8F 00
 83+  AF90 0B 13 00 00      defb 11,19,0,0,0
 83+  AF94 00
 84+  AF95 0A 11 00 00      defb 10,17,0,0,0
 84+  AF99 00
 85+  AF9A 05 12 00 00      defb 5,18,0,0,0
 85+  AF9E 00
 86+  AF9F 07 16 00 00      defb 7,22,0,0,0
 86+  AFA3 00
 87+  AFA4 09 17 00 00      defb 9,23,0,0,0
 87+  AFA8 00
 88+  AFA9 07 18 00 00      defb 7,24,0,0,0
 88+  AFAD 00
 89+  AFAE 05 18 00 00      defb 5,24,0,0,0
 89+  AFB2 00
 90+  AFB3 06 19 00 00      defb 6,25,0,0,0
 90+  AFB7 00
 91+  AFB8 08 19 00 00      defb 8,25,0,0,0
 91+  AFBC 00
 92+  AFBD 04 17 00 00      defb 4,23,0,0,0
 92+  AFC1 00
 93+  AFC2 FF               defb 255
 94+  AFC3
 95+  AFC3              level01missiles:
 96+  AFC3 0B 17 00 00      defb 11,23,0,0,0
 96+  AFC7 00
 97+  AFC8 0B 16 00 00      defb 11,22,0,0,0
 97+  AFCC 00
 98+  AFCD 0C 17 00 00      defb 12,23,0,0,0
 98+  AFD1 00
 99+  AFD2 0C 16 00 00      defb 12,22,0,0,0
 99+  AFD6 00
100+  AFD7 0D 17 00 00      defb 13,23,0,0,0
100+  AFDB 00
101+  AFDC 0D 16 00 00      defb 13,22,0,0,0
101+  AFE0 00
102+  AFE1 0E 17 00 00      defb 14,23,0,0,0
102+  AFE5 00
103+  AFE6 0E 16 00 00      defb 14,22,0,0,0
103+  AFEA 00
104+  AFEB 0F 17 00 00      defb 15,23,0,0,0
104+  AFEF 00
105+  AFF0 0F 16 00 00      defb 15,22,0,0,0
105+  AFF4 00
106+  AFF5 10 17 00 00      defb 16,23,0,0,0
106+  AFF9 00
107+  AFFA 10 16 00 00      defb 16,22,0,0,0
107+  AFFE 00
108+  AFFF 11 17 00 00      defb 17,23,0,0,0
108+  B003 00
109+  B004 11 16 00 00      defb 17,22,0,0,0
109+  B008 00
110+  B009 12 17 00 00      defb 18,23,0,0,0
110+  B00D 00
111+  B00E 12 16 00 00      defb 18,22,0,0,0
111+  B012 00
112+  B013 13 17 00 00      defb 19,23,0,0,0
112+  B017 00
113+  B018 13 16 00 00      defb 19,22,0,0,0
113+  B01C 00
114+  B01D 14 17 00 00      defb 20,23,0,0,0
114+  B021 00
115+  B022 14 16 00 00      defb 20,22,0,0,0
115+  B026 00
116+  B027 15 17 00 00      defb 21,23,0,0,0
116+  B02B 00
117+  B02C 15 16 00 00      defb 21,22,0,0,0
117+  B030 00
118+  B031 16 17 00 00      defb 22,23,0,0,0
118+  B035 00
119+  B036 16 16 00 00      defb 22,22,0,0,0
119+  B03A 00
120+  B03B FF               defb 255
121+  B03C
122+  B03C              ;
123+  B03C              ; Diamonds: x,y,state,mem1+mem2
124+  B03C              ;
125+  B03C              level01diamonds:
126+  B03C 0C 1B 00 00      defb 12,27,0,0,0
126+  B040 00
127+  B041 10 1B 00 00      defb 16,27,0,0,0
127+  B045 00
128+  B046 15 1B 00 00      defb 21,27,0,0,0
128+  B04A 00
129+  B04B FF               defb 255
130+  B04C
131+  B04C              level01gems:
132+  B04C 12 14 00 00      defb 18,20,0,0,0
132+  B050 00
133+  B051 06 18 00 00      defb 6,24,0,0,0
133+  B055 00
134+  B056 19 17 00 00      defb 25,23,0,0,0
134+  B05A 00
135+  B05B 1C 11 00 00      defb 28,17,0,0,0
135+  B05F 00
136+  B060 FF               defb 255
137+  B061              ;
138+  B061              ; Score area colours
139+  B061              ;
140+  B061              score_colours:
141+  B061 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  B065 47 47 47 47
141+  B069 47 47 47 42
141+  B06D 43 43 43 43
141+  B071 43 43 43 43
141+  B075 42 47 47 47
141+  B079 47 47 47 47
141+  B07D 47 47 47 47
142+  B081 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  B085 47 47 47 47
142+  B089 47 47 47 46
142+  B08D 46 46 46 46
142+  B091 46 46 46 46
142+  B095 46 47 47 47
142+  B099 47 47 47 47
142+  B09D 47 47 47 47
143+  B0A1
144+  B0A1              high_score_colours:
145+  B0A1 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  B0A5 42 42 47 47
145+  B0A9 47 47 47 47
145+  B0AD 43 43 43 47
145+  B0B1 47 47 47 47
145+  B0B5 47 46 46 46
145+  B0B9 47 47 47 47
145+  B0BD 47 47 00 00
# file closed: leveldata/level01.asm
 31   B0C1                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B0C1              ; Tiles graphics.
  2+  B0C1              sprites:
  3+  B0C1 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B0C5 00 00 00 00
  4+  B0C9 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B0CD FF FF FF FF
  5+  B0D1 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B0D5 1F 3F 7F FF
  6+  B0D9 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B0DD F8 FC FE FF
  7+  B0E1 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B0E5 55 AA 55 AA
  8+  B0E9 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B0ED 00 00 00 00
  9+  B0F1 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  B0F5 FF FF FF FF
 10+  B0F9 FF FF 00 00      defb    255,255,  0,  0,  0,  0,  0,  0   ; 7, trapdoor
 10+  B0FD 00 00 00 00
 11+  B101 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B105 F1 72 34 18
 12+  B109 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B10D FE FE FF 7E
 13+  B111 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B115 FE FF 7E 3C
 14+  B119 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B11D 00 00 FF FF
 15+  B121 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 12, missile
 15+  B125 FF 7E 3C 18
 16+  B129 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B12D 00 00 00 00
 17+  B131 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B135 00 3C 5A 34
 18+  B139
 19+  B139              sprite_attrs:
 20+  B139 46               defb    070 ; 0, space
 21+  B13A 65               defb    101 ; 1, cyan block
 22+  B13B 4D               defb    077 ; 2, slope left
 23+  B13C 4D               defb    077 ; 3, slope right
 24+  B13D 46               defb    070 ; 4, dirt
 25+  B13E 4E               defb    078 ; 5, sky
 26+  B13F 4C               defb    076 ; 6, slime
 27+  B140 42               defb    066 ; 7, trapdoor
 28+  B141 46               defb    070 ; 8, diamond
 29+  B142 42               defb    066 ; 9, rock
 30+  B143 42               defb    066 ; 10, rock 2
 31+  B144 49           	defb    073 ; 11, sky, trapdoor
 32+  B145 43           	defb    067 ; 12, missile
 33+  B146 4A               defb    074 ; 13, sky, red ink (tank)
 34+  B147 46               defb    070 ; 14, gem
 35+  B148
 36+  B148              player_sprite:
 37+  B148 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 37+  B14C 38 3D C3 80
 38+  B150 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 38+  B154 3C 1C 16 32
 39+  B158 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 39+  B15C 3C 38 68 4C
 40+  B160 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 40+  B164 1C BC C3 01
 41+  B168 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 41+  B16C 3C 3C 64 0C
 42+  B170 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 42+  B174 3C 3C 26 30
 43+  B178 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 43+  B17C 1E 5C FD 5F
 44+  B180 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 44+  B184 4F 8F 19 03
 45+  B188 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 45+  B18C F2 F1 98 C0
 46+  B190 FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 46+  B194 48 08 14 2A
 47+  B198 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 47+  B19C 38 78 44 C3
 48+  B1A0 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 48+  B1A4 1C 1E 22 C3
 49+  B1A8
 50+  B1A8              ;
 51+  B1A8              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 52+  B1A8              ;
 53+  B1A8              ship_sprite:
 54+  B1A8 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 54+  B1AC 03 1F 7F FF
 55+  B1B0 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 55+  B1B4 FF FF FF FF
 56+  B1B8 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 56+  B1BC FF FF FF FF
 57+  B1C0 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 57+  B1C4 C0 F8 FE FF
 58+  B1C8 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 58+  B1CC 03 03 02 07
 59+  B1D0 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 59+  B1D4 FF 0F 07 83
 60+  B1D8 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 60+  B1DC FF 10 20 C1
 61+  B1E0 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 61+  B1E4 C0 C0 40 E0
 62+  B1E8 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 62+  B1EC 03 03 02 07
 63+  B1F0 F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 63+  B1F4 FF 08 04 83
 64+  B1F8 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 64+  B1FC FF F0 E0 C1
 65+  B200 CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 65+  B204 C0 C0 40 E0
 66+  B208
 67+  B208              ;
 68+  B208              ;  First 8 frames are tank, last frame is the gun barrel
 69+  B208              ;
 70+  B208              tank_sprite:
 71+  B208 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 71+  B20C 7F 00 00 00
 72+  B210 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 72+  B214 FE FF 7F 40
 73+  B218 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 73+  B21C 03 FF FF 01
 74+  B220 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
 74+  B224 E0 C0 00 00
 75+  B228 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
 75+  B22C F7 E1 7F 3F
 76+  B230 FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
 76+  B234 54 16 FF FF
 77+  B238 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
 77+  B23C 9B A8 FF FF
 78+  B240 FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
 78+  B244 9F AF FE FC
 79+  B248 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0
 79+  B24C 1F 00 00 00
# file closed: graphics/graphics.asm
 32   B250
 33   B250                  include "game\control.asm"
# file opened: game/control.asm
  1+  B250              ;
  2+  B250              ; Check the keyboard then move
  3+  B250              ;
  4+  B250              control_keyboard:
  5+  B250 3A DE B6         ld a,(player+11)    ; first, check if player is dying
  6+  B253 FE 00            cp 0
  7+  B255 C0               ret nz               ; if so, can't move
  8+  B256 3A D8 B6         ld a,(player+5)      ; next, check if the player has pixels left to move
  9+  B259 FE 00            cp 0
 10+  B25B CA 62 B2         jp z, control_keyboard5
 11+  B25E CD 67 B3         call control_automove
 12+  B261 C9               ret
 13+  B262              control_keyboard5:
 14+  B262 3A D9 B6         ld a,(player+6)      ; next, check if the player is digging
 15+  B265 FE 00            cp 0
 16+  B267 CA 6E B2         jp z, control_keyboard0
 17+  B26A CD A5 B2         call control_dig
 18+  B26D C9               ret
 19+  B26E              control_keyboard0:
 20+  B26E 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 21+  B271 ED 78            in a,(c)            ; read keyboard.
 22+  B273 47               ld b,a              ; store result in b register.
 23+  B274 CB 18            rr b                ; check outermost key (q).
 24+  B276 D2 95 B2         jp nc,control_keyboard1
 25+  B279 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 26+  B27C ED 78            in a,(c)            ; read keyboard.
 27+  B27E 47               ld b,a              ; store result in b register.
 28+  B27F CB 18            rr b                ; check outermost key (a).
 29+  B281 D2 99 B2         jp nc,control_keyboard2
 30+  B284 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 31+  B287 ED 78            in a,(c)            ; read keyboard.
 32+  B289 47               ld b,a              ; store result in b register.
 33+  B28A CB 18            rr b                ; check outermost key (p).
 34+  B28C D2 9D B2         jp nc,control_keyboard3
 35+  B28F CB 18            rr b                ; check next key.
 36+  B291 D2 A1 B2         jp nc,control_keyboard4
 37+  B294 C9               ret
 38+  B295              control_keyboard1:
 39+  B295 CD B0 B3         call control_pl_moveup         ; player up.
 40+  B298 C9               ret
 41+  B299              control_keyboard2:
 42+  B299 CD DF B3         call control_pl_movedown       ; player down.
 43+  B29C C9               ret
 44+  B29D              control_keyboard3:
 45+  B29D CD 3C B4         call control_pl_moveright       ; player left.
 46+  B2A0 C9               ret
 47+  B2A1              control_keyboard4:
 48+  B2A1 CD 0C B4         call control_pl_moveleft       ; player right.
 49+  B2A4 C9               ret
 50+  B2A5
 51+  B2A5              ;
 52+  B2A5              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 53+  B2A5              ;
 54+  B2A5              control_dig:
 55+  B2A5 ED 4B D3 B6      ld bc,(player)      ; load the current coords into bc
 56+  B2A9 C5               push bc
 57+  B2AA 3A D5 B6         ld a,(player+2)     ; get the direction
 58+  B2AD FE 01            cp 1                ; left
 59+  B2AF CA C7 B2         jp z,control_dig0
 60+  B2B2 FE 02            cp 2                ; right
 61+  B2B4 CA DC B2         jp z,control_dig1
 62+  B2B7 FE 03            cp 3                ; down
 63+  B2B9 CA 00 B3         jp z,control_dig5
 64+  B2BC FE 00            cp 0                ; up
 65+  B2BE CA F0 B2         jp z,control_dig4
 66+  B2C1 21 D9 B6         ld hl,player+6
 67+  B2C4 36 00            ld (hl),0           ; turn off digging
 68+  B2C6 C9               ret                 ; return
 69+  B2C7              control_dig0:           ; going left
 70+  B2C7 CD 5D A8         call sprites_scadd  ; get the current coord
 71+  B2CA 62 6B            ld hl,de
 72+  B2CC 2B               dec hl              ; move one left
 73+  B2CD C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
 74+  B2CE 78               ld a,b
 75+  B2CF 06 08            ld b,8
 76+  B2D1 90               sub b
 77+  B2D2 47               ld b,a
 78+  B2D3 79               ld a,c
 79+  B2D4 0E 08            ld c,8
 80+  B2D6 91               sub c
 81+  B2D7 4F               ld c,a
 82+  B2D8 C5               push bc
 83+  B2D9 C3 09 B3         jp control_dig2
 84+  B2DC              control_dig1:
 85+  B2DC CD 5D A8         call sprites_scadd  ; get the current coord
 86+  B2DF 62 6B            ld hl,de
 87+  B2E1 23               inc hl              ; move one right
 88+  B2E2 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
 89+  B2E3 3E 08            ld a,8
 90+  B2E5 80               add a,b
 91+  B2E6 47               ld b,a
 92+  B2E7 79               ld a,c
 93+  B2E8 0E 08            ld c,8
 94+  B2EA 91               sub c
 95+  B2EB 4F               ld c,a
 96+  B2EC C5               push bc
 97+  B2ED C3 09 B3         jp control_dig2
 98+  B2F0              control_dig4:
 99+  B2F0 CD 5D A8         call sprites_scadd  ; get the current coord
100+  B2F3 62 6B            ld hl,de
101+  B2F5 11 20 00         ld de,32
102+  B2F8 ED 52            sbc hl,de             ; move one up
103+  B2FA C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
104+  B2FB 0D               dec c
105+  B2FC C5               push bc
106+  B2FD C3 21 B3         jp control_dig6
107+  B300              control_dig5:
108+  B300 CD 5D A8         call sprites_scadd  ; get the current coord
109+  B303 62 6B            ld hl,de
110+  B305 24               inc h              ; move one down
111+  B306                                     ; not bothered about working out bc here, since rock will never fall if digging down
112+  B306 C3 09 B3         jp control_dig2
113+  B309              ; Normal (not up) digging
114+  B309              control_dig2:
115+  B309 3A DB B6         ld a,(player+8)     ; get the number of rows we need to overwrite
116+  B30C 47               ld b,a              ; rows to copy over
117+  B30D E5               push hl             ; store the memory location of the first row for later
118+  B30E              control_dig3:
119+  B30E CD 50 B3         call control_getpixelrow
120+  B311 77               ld (hl),a           ; load contents into row
121+  B312 11 20 00         ld de,32
122+  B315 19               add hl,de           ; move to next row
123+  B316 10 F6            djnz control_dig3
124+  B318 E1               pop hl              ; get the original memory location back
125+  B319 11 20 00         ld de,32
126+  B31C ED 52            sbc hl,de           ; move to above row, ready for checking for rock
127+  B31E C3 37 B3         jp control_dig10
128+  B321              ; Special case for going up
129+  B321              control_dig6:
130+  B321 3A DB B6         ld a,(player+8)     ; get the number of rows we need to overwrite
131+  B324 47               ld b,a              ; rows to copy over
132+  B325              control_dig7:
133+  B325 CD 50 B3         call control_getpixelrow
134+  B328              control_dig12:
135+  B328 77               ld (hl),a           ; load empty into row
136+  B329 11 20 00         ld de,32
137+  B32C ED 52            sbc hl,de           ; move up to next row
138+  B32E 0D               dec c               ; decrease c to track rows
139+  B32F 10 F4            djnz control_dig7
140+  B331 79               ld a,c
141+  B332 D6 07            sub 7
142+  B334 C1               pop bc
143+  B335 4F               ld c,a
144+  B336 C5               push bc             ; store the decreased c coord
145+  B337              control_dig10:
146+  B337 DD 21 DA B6      ld ix,player+7
147+  B33B DD 7E 00         ld a,(ix)     ; get the dig frame number
148+  B33E 3D               dec a
149+  B33F DD 77 00         ld (ix),a
150+  B342                  ; call the check for rocks above the removed dirt
151+  B342 DD 21 D9 B6      ld ix,player+6
152+  B346 DD 7E 00         ld a,(ix)     ; get the dig state
153+  B349 FE 00            cp 0
154+  B34B C1               pop bc
155+  B34C CC 26 BA         call z, rocks_checkforfalling ; make the check if we're no longer digging
156+  B34F C9               ret
157+  B350
158+  B350              ;
159+  B350              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
160+  B350              ; Inputs:
161+  B350              ; hl - memory of pixel row
162+  B350              ; Outputs:
163+  B350              ; a - modified row to write
164+  B350              ;
165+  B350              control_getpixelrow:
166+  B350 3A DA B6         ld a,(player+7)     ; get the dig frame number
167+  B353 FE 00            cp 0                ; is this the last dig
168+  B355 CA 5C B3         jp z,control_getpixelrow1
169+  B358 7E               ld a,(hl)           ; if not, xor with 255 to flip it
170+  B359 EE FF            xor 255
171+  B35B C9               ret
172+  B35C              control_getpixelrow1:
173+  B35C DD 21 D9 B6      ld ix,player+6
174+  B360 DD 36 00 00      ld (ix),0           ; turn off digging
175+  B364 3E 00            ld a,0              ; if it is, load with empty
176+  B366 C9               ret
177+  B367
178+  B367              ;
179+  B367              ; Auto move the player until pixels is zero
180+  B367              ;
181+  B367              control_automove:
182+  B367 5F               ld e,a              ; store the number of pixels left to move in e
183+  B368 ED 4B D3 B6      ld bc,(player)      ; load the current coords into bc
184+  B36C 21 D5 B6         ld hl,player+2      ; get the direction
185+  B36F 7E               ld a,(hl)
186+  B370 FE 03            cp 3                ; down
187+  B372 CA 86 B3         jp z,control_automove3  ; don't need to do anything
188+  B375 FE 00            cp 0                ; going up
189+  B377 CA 92 B3         jp z,control_automove2
190+  B37A FE 01            cp 1                ; going left?
191+  B37C CA 9E B3         jp z,control_automove0
192+  B37F 78               ld a,b
193+  B380 3C               inc a               ; if we're going right, increment a twice for two pixels
194+  B381 3C               inc a
195+  B382 47               ld b,a
196+  B383 C3 A2 B3         jp control_automove1
197+  B386              control_automove3:
198+  B386 79               ld a,c
199+  B387 3C               inc a
200+  B388 3C               inc a               ; if we're going down, increment twice
201+  B389 4F               ld c,a
202+  B38A FE 90            cp 144
203+  B38C CC 6A B4         call z, control_scroll_down
204+  B38F C3 A2 B3         jp control_automove1
205+  B392              control_automove2:
206+  B392 79               ld a,c
207+  B393 3D               dec a
208+  B394 3D               dec a               ; if we're going up, decrement twice
209+  B395 4F               ld c,a
210+  B396 FE 60            cp 96
211+  B398 CC 77 B4         call z, control_scroll_up
212+  B39B C3 A2 B3         jp control_automove1
213+  B39E              control_automove0:
214+  B39E 78               ld a,b
215+  B39F 3D               dec a               ; if we're going left, decrement a twice
216+  B3A0 3D               dec a
217+  B3A1 47               ld b,a
218+  B3A2              control_automove1:
219+  B3A2 ED 43 D3 B6      ld (player),bc      ; and back to player
220+  B3A6 7B               ld a,e              ; now get the pixel count back
221+  B3A7 3D               dec a               ; decrease by one
222+  B3A8 21 D8 B6         ld hl,player+5
223+  B3AB 77               ld (hl),a           ; copy back
224+  B3AC CD 1F B8         call player_justmoved
225+  B3AF C9               ret
226+  B3B0
227+  B3B0              ;
228+  B3B0              ; Moves the player up
229+  B3B0              ;
230+  B3B0              control_pl_moveup:
231+  B3B0 C5               push bc
232+  B3B1 ED 4B D3 B6      ld bc,(player)          ; get the current coords, b horiz, c vert
233+  B3B5 79               ld a,c                  ; load c into the acc
234+  B3B6 FE 18            cp 24
235+  B3B8 CA D8 B3         jp z,control_pl_moveup0 ; are we at the edge of the screen
236+  B3BB FE 60            cp 96
237+  B3BD CC 77 B4         call z, control_scroll_up
238+  B3C0 CD 17 B6         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
239+  B3C3 F5               push af
240+  B3C4 7B               ld a,e                  ; put e in a
241+  B3C5 FE 00            cp 0
242+  B3C7 CA D7 B3         jp z,control_pl_moveup1 ; don't move if we can't
243+  B3CA F1               pop af
244+  B3CB D6 01            sub 1                   ; subtract 1
245+  B3CD D6 01            sub 1                   ; subtract 1
246+  B3CF 4F               ld c,a                  ; load back to c
247+  B3D0 ED 43 D3 B6      ld (player),bc          ; load back to player
248+  B3D4 C3 D8 B3         jp control_pl_moveup0
249+  B3D7              control_pl_moveup1:
250+  B3D7 F1               pop af                  ; restore af if needed
251+  B3D8              control_pl_moveup0:
252+  B3D8 3E 00            ld a,0
253+  B3DA 32 D5 B6         ld (player+2),a        ; set direction to up
254+  B3DD C1               pop bc
255+  B3DE C9               ret
256+  B3DF              ;
257+  B3DF              ; Moves the player down
258+  B3DF              ;
259+  B3DF              control_pl_movedown:
260+  B3DF C5               push bc
261+  B3E0 ED 4B D3 B6      ld bc,(player)          ; get the current coords, b horiz, c vert
262+  B3E4 79               ld a,c                  ; load c into the acc
263+  B3E5 FE E0            cp 224
264+  B3E7 CA 05 B4         jp z,control_pl_movedown0 ; are we at the edge of the screen
265+  B3EA FE 80            cp 128
266+  B3EC CC 6A B4         call z, control_scroll_down
267+  B3EF CD EB B5         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
268+  B3F2 F5               push af
269+  B3F3 7B               ld a,e                  ; put e in a
270+  B3F4 FE 00            cp 0
271+  B3F6 CA 04 B4         jp z,control_pl_movedown1 ; don't move if we can't
272+  B3F9 F1               pop af
273+  B3FA 3C               inc a                   ; add 1
274+  B3FB 3C               inc a                   ; add 1
275+  B3FC 4F               ld c,a                  ; load back to c
276+  B3FD ED 43 D3 B6      ld (player),bc          ; load back to player
277+  B401 C3 05 B4         jp control_pl_movedown0
278+  B404              control_pl_movedown1:
279+  B404 F1               pop af                  ; restore af if needed
280+  B405              control_pl_movedown0:
281+  B405 3E 03            ld a,3
282+  B407 32 D5 B6         ld (player+2),a        ; set direction to down
283+  B40A C1               pop bc
284+  B40B C9               ret
285+  B40C              ;
286+  B40C              ; Moves the player left
287+  B40C              ;
288+  B40C              control_pl_moveleft:
289+  B40C C5               push bc
290+  B40D ED 4B D3 B6      ld bc,(player)          ; get the current coords, b horiz, c vert
291+  B411 78               ld a,b                  ; load b into the acc
292+  B412 FE 10            cp 16
293+  B414 CA 35 B4         jp z,control_pl_moveleft0 ; are we at the edge of the screen
294+  B417 CD 76 B6         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
295+  B41A F5               push af
296+  B41B 7B               ld a,e                  ; put e in a
297+  B41C FE 00            cp 0
298+  B41E CA 34 B4         jp z,control_pl_moveleft1 ; don't move if we can't
299+  B421 21 D8 B6         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
300+  B424 3E 03            ld a,3
301+  B426 77               ld (hl),a
302+  B427 F1               pop af
303+  B428 D6 01            sub 1                    ; subtract 2
304+  B42A D6 01            sub 1
305+  B42C 47               ld b,a                  ; load back to c
306+  B42D ED 43 D3 B6      ld (player),bc          ; load back to player
307+  B431 C3 35 B4         jp control_pl_moveleft0
308+  B434              control_pl_moveleft1:
309+  B434 F1               pop af
310+  B435              control_pl_moveleft0:
311+  B435 3E 01            ld a,1
312+  B437 32 D5 B6         ld (player+2),a        ; set direction to left
313+  B43A C1               pop bc
314+  B43B C9               ret
315+  B43C              ;
316+  B43C              ; Moves the player right
317+  B43C              ;
318+  B43C              control_pl_moveright:
319+  B43C C5               push bc
320+  B43D ED 4B D3 B6      ld bc,(player)          ; get the current coords, b horiz, c vert
321+  B441 78               ld a,b                  ; load b into the acc
322+  B442 FE F0            cp 240
323+  B444 CA 63 B4         jp z,control_pl_moveright0 ; are we at the edge of the screen
324+  B447 CD 4A B6         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
325+  B44A F5               push af
326+  B44B 7B               ld a,e                  ; put e in a
327+  B44C FE 00            cp 0
328+  B44E CA 62 B4         jp z,control_pl_moveright1 ; don't move if we can't
329+  B451 21 D8 B6         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
330+  B454 3E 03            ld a,3
331+  B456 77               ld (hl),a
332+  B457 F1               pop af
333+  B458 3C               inc a                   ; add 2
334+  B459 3C               inc a
335+  B45A 47               ld b,a                  ; load back to b
336+  B45B ED 43 D3 B6      ld (player),bc          ; load back to player
337+  B45F C3 63 B4         jp control_pl_moveright0
338+  B462              control_pl_moveright1:
339+  B462 F1               pop af                  ; restore af if needed
340+  B463              control_pl_moveright0:
341+  B463 3E 02            ld a,2
342+  B465 32 D5 B6         ld (player+2),a        ; set direction to right
343+  B468 C1               pop bc
344+  B469 C9               ret
345+  B46A
346+  B46A              ;
347+  B46A              ; Scrolls the screen down
348+  B46A              ;
349+  B46A              control_scroll_down:
350+  B46A F5               push af
351+  B46B 3E 08            ld a,8
352+  B46D 32 76 A6         ld (screen_offset),a
353+  B470 F1               pop af
354+  B471 21 28 A5         ld hl,buffer_updateall
355+  B474 36 01            ld (hl),1         ; flag as screen needing update
356+  B476 C9               ret
357+  B477
358+  B477              ;
359+  B477              ; Scrolls the screen up
360+  B477              ;
361+  B477              control_scroll_up:
362+  B477 F5               push af
363+  B478 3E 00            ld a,0
364+  B47A 32 76 A6         ld (screen_offset),a
365+  B47D F1               pop af
366+  B47E 21 28 A5         ld hl,buffer_updateall
367+  B481 36 01            ld (hl),1         ; flag as screen needing update
368+  B483 C9               ret
369+  B484
370+  B484
371+  B484
372+  B484
# file closed: game/control.asm
 34   B484                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  B484              ;
  2+  B484              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  3+  B484              ; Inputs:
  4+  B484              ; hl - memory location of top pixel row
  5+  B484              ; bc - screen coords, b horiz, c vert
  6+  B484              ; Outputs:
  7+  B484              ; e - 0 if not empty, 1 if empty
  8+  B484              ;
  9+  B484              movement_spaceisempty:
 10+  B484 C5               push bc
 11+  B485 E5               push hl
 12+  B486 CD AE B4         call movement_spaceisgem        ; check if space is a gem
 13+  B489 E1               pop hl
 14+  B48A C1               pop bc
 15+  B48B 7B               ld a,e
 16+  B48C FE 01            cp 1
 17+  B48E C8               ret z                           ; if e is 1, space is a gem so can move here, return
 18+  B48F 3E 08            ld a,8                          ; 8 rows to check
 19+  B491              movement_spaceisempty0:
 20+  B491 08               ex af,af'                       ; store the loop counter
 21+  B492 7E               ld a,(hl)                       ; get current pixel row
 22+  B493 FE 00            cp 0
 23+  B495 C2 A9 B4         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 24+  B498 79               ld a,c                          ; load the vertical coord
 25+  B499 3C               inc a                           ; next row down
 26+  B49A 11 20 00         ld de,32
 27+  B49D 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 28+  B49E 4F               ld c,a                          ; copy vert coord back to c
 29+  B49F 08               ex af,af'                       ; get loop counter back
 30+  B4A0 3D               dec a                           ; decrease loop counter
 31+  B4A1 C2 91 B4         jp nz, movement_spaceisempty0
 32+  B4A4 16 00            ld d,0
 33+  B4A6 1E 01            ld e,1                          ; got to end, so space is empty
 34+  B4A8 C9               ret
 35+  B4A9              movement_spaceisempty1:
 36+  B4A9 16 00            ld d,0
 37+  B4AB 1E 00            ld e,0                          ; returning false, ie space not empty
 38+  B4AD C9               ret
 39+  B4AE
 40+  B4AE              ;
 41+  B4AE              ; Check if a space contains a gem
 42+  B4AE              ; Inputs:
 43+  B4AE              ; bc - screen coords
 44+  B4AE              ; Outputs:
 45+  B4AE              ; e = 1 if gem
 46+  B4AE              movement_spaceisgem:
 47+  B4AE CD B4 A7         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 48+  B4B1 21 3C B0         ld hl,level01diamonds           ; check diamonds first
 49+  B4B4              movement_spaceisgem0:
 50+  B4B4 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 51+  B4B8 7B               ld a,e                          ; check for end of data
 52+  B4B9 FE FF            cp 255
 53+  B4BB CA D6 B4         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 54+  B4BE 23               inc hl
 55+  B4BF 23               inc hl                          ; move to state
 56+  B4C0 7E               ld a,(hl)
 57+  B4C1 23               inc hl
 58+  B4C2 23               inc hl
 59+  B4C3 23               inc hl                          ; get to next
 60+  B4C4 FE 01            cp 1                            ; check if collected
 61+  B4C6 CA B4 B4         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 62+  B4C9 7B               ld a,e                          ; load e again
 63+  B4CA B9               cp c                            ; otherwise, compare c with e
 64+  B4CB C2 B4 B4         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 65+  B4CE 7A               ld a,d                          ; get d coord
 66+  B4CF B8               cp b                            ; compare b with d
 67+  B4D0 C2 B4 B4         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 68+  B4D3 1E 01            ld e,1                          ; otherwise, exit with e = 1
 69+  B4D5 C9               ret
 70+  B4D6              movement_spaceisgem1:
 71+  B4D6 21 4C B0         ld hl,level01gems              ; check gems
 72+  B4D9              movement_spaceisgem2:
 73+  B4D9 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 74+  B4DD 7B               ld a,e                          ; check for end of data
 75+  B4DE FE FF            cp 255
 76+  B4E0 CA FB B4         jp z,movement_spaceisgem3       ; if yes, done with gems
 77+  B4E3 23               inc hl
 78+  B4E4 23               inc hl                          ; move to state
 79+  B4E5 7E               ld a,(hl)
 80+  B4E6 23               inc hl
 81+  B4E7 23               inc hl
 82+  B4E8 23               inc hl                          ; get to next
 83+  B4E9 FE 01            cp 1                            ; check if collected
 84+  B4EB CA D9 B4         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 85+  B4EE 7B               ld a,e                          ; load e again
 86+  B4EF B9               cp c                            ; otherwise, compare c with e
 87+  B4F0 C2 D9 B4         jp nz,movement_spaceisgem2      ; if different, move to next gem
 88+  B4F3 7A               ld a,d                          ; get d coord
 89+  B4F4 B8               cp b                            ; compare b with d
 90+  B4F5 C2 D9 B4         jp nz,movement_spaceisgem2      ; if different, move to next gem
 91+  B4F8 1E 01            ld e,1                          ; otherwise, exit with e = 1
 92+  B4FA C9               ret
 93+  B4FB              movement_spaceisgem3:
 94+  B4FB 1E 00            ld e,0                          ; nothing found, return e = 0
 95+  B4FD C9               ret
 96+  B4FE
 97+  B4FE              ;
 98+  B4FE              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
 99+  B4FE              ; Inputs:
100+  B4FE              ; hl - memory location of top pixel row
101+  B4FE              ; bc - screen coords, b horiz, c vert
102+  B4FE              ; Outputs:
103+  B4FE              ; e - 0 if not empty, 1 if empty
104+  B4FE              ;
105+  B4FE              movement_linebelowisempty:
106+  B4FE C5               push bc
107+  B4FF E5               push hl
108+  B500 CD AE B4         call movement_spaceisgem        ; check if space is a gem
109+  B503 E1               pop hl
110+  B504 C1               pop bc
111+  B505 7B               ld a,e
112+  B506 FE 01            cp 1
113+  B508 C8               ret z                           ; if e is 1, space is a gem so can move here, return
114+  B509 7E               ld a,(hl)                       ; get current pixel row
115+  B50A FE 00            cp 0
116+  B50C C2 14 B5         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
117+  B50F 16 00            ld d,0
118+  B511 1E 01            ld e,1                          ; got to end, so space is empty
119+  B513 C9               ret
120+  B514              movement_linebelowisempty1:
121+  B514 16 00            ld d,0
122+  B516 1E 00            ld e,0                          ; returning false, ie space not empty
123+  B518 C9               ret
124+  B519
125+  B519              ;
126+  B519              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
127+  B519              ; Inputs:
128+  B519              ; hl - memory location of top pixel row
129+  B519              ; bc - screen coords, b horiz, c vert
130+  B519              ; Outputs:
131+  B519              ; e - 0 if not empty, 1 if empty
132+  B519              ;
133+  B519              movement_lineaboveisempty:
134+  B519 C5               push bc
135+  B51A E5               push hl
136+  B51B CD AE B4         call movement_spaceisgem        ; check if space is a gem
137+  B51E E1               pop hl
138+  B51F C1               pop bc
139+  B520 7B               ld a,e
140+  B521 FE 01            cp 1
141+  B523 C8               ret z
142+  B524 7E               ld a,(hl)                       ; get current pixel row
143+  B525 FE 00            cp 0
144+  B527 C2 2F B5         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
145+  B52A 16 00            ld d,0
146+  B52C 1E 01            ld e,1                          ; got to end, so space is empty
147+  B52E C9               ret
148+  B52F              movement_lineaboveisempty1:
149+  B52F 16 00            ld d,0
150+  B531 1E 00            ld e,0                          ; returning false, ie space not empty
151+  B533 C9               ret
152+  B534
153+  B534              ;
154+  B534              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
155+  B534              ; Inputs:
156+  B534              ; hl - memory location of top pixel row
157+  B534              ; bc - screen coords, b horiz, c vert
158+  B534              ; Outputs:
159+  B534              ; none - puts player into digging mode
160+  B534              ;
161+  B534              movement_spaceisdiggable:
162+  B534 3E 08            ld a,8                          ; 8 rows to check
163+  B536              movement_spaceisdiggable0:
164+  B536 08               ex af,af'                       ; store the loop counter
165+  B537 7E               ld a,(hl)                       ; get current pixel row
166+  B538 FE 00            cp 0
167+  B53A CA 4A B5         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
168+  B53D FE 55            cp 85
169+  B53F CA 4A B5         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
170+  B542 FE AA            cp 170
171+  B544 CA 4A B5         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
172+  B547 C3 62 B5         jp movement_spaceisdiggable1     ; otherwise, stop checking
173+  B54A              movement_spaceisdiggable2:
174+  B54A 79               ld a,c                          ; load the vertical coord
175+  B54B 3C               inc a                           ; next row down
176+  B54C 11 20 00         ld de,32
177+  B54F 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
178+  B550 4F               ld c,a                          ; copy vert coord back to c
179+  B551 08               ex af,af'                       ; get loop counter back
180+  B552 3D               dec a                           ; decrease loop counter
181+  B553 C2 36 B5         jp nz, movement_spaceisdiggable0
182+  B556 21 D9 B6         ld hl,player+6
183+  B559 36 01            ld (hl),1                       ; set the player into digging mode
184+  B55B 23               inc hl
185+  B55C 36 05            ld (hl),5                      ; set the number of frame to dig for
186+  B55E 23               inc hl
187+  B55F 36 08            ld (hl),8                       ; set the number of pixels to dig
188+  B561 C9               ret
189+  B562              movement_spaceisdiggable1:
190+  B562 21 D9 B6         ld hl,player+6
191+  B565 36 00            ld (hl),0                       ; set the player out of digging mode
192+  B567 C9               ret
193+  B568
194+  B568              ;
195+  B568              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
196+  B568              ; Inputs:
197+  B568              ; hl - memory location of top pixel row
198+  B568              ; bc - screen coords, b horiz, c vert
199+  B568              ; Outputs:
200+  B568              ; none - puts player into digging mode
201+  B568              ;
202+  B568              movement_spacebelowisdiggable:
203+  B568 7E               ld a,(hl)                       ; get first pixel row
204+  B569 FE 55            cp 85
205+  B56B CA 76 B5         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
206+  B56E FE AA            cp 170
207+  B570 CA 76 B5         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
208+  B573 C3 62 B5         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
209+  B576              movement_spacebelowisdiggable3:
210+  B576 3E 08            ld a,8                          ; rows to check
211+  B578 1E 00            ld e,0                          ; count of rows to dig
212+  B57A              movement_spacebelowisdiggable0:
213+  B57A 08               ex af,af'                       ; store the loop counter
214+  B57B 7E               ld a,(hl)                       ; get current pixel row
215+  B57C FE 55            cp 85
216+  B57E CA 89 B5         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
217+  B581 FE AA            cp 170
218+  B583 CA 89 B5         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
219+  B586 C3 98 B5         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
220+  B589              movement_spacebelowisdiggable4:
221+  B589 1C               inc e                           ; inc count of rows to dig
222+  B58A              movement_spacebelowisdiggable2:
223+  B58A 79               ld a,c                          ; load the vertical coord
224+  B58B 3C               inc a                           ; next row down
225+  B58C D5               push de                         ; need e for later
226+  B58D 11 20 00         ld de,32
227+  B590 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
228+  B591 4F               ld c,a                          ; copy vert coord back to c
229+  B592 D1               pop de                          ; get e back
230+  B593 08               ex af,af'                       ; get loop counter back
231+  B594 3D               dec a                           ; incease loop counter
232+  B595 C2 7A B5         jp nz, movement_spacebelowisdiggable0
233+  B598              movement_spacebelowisdiggable5:
234+  B598 21 D9 B6         ld hl,player+6
235+  B59B 36 01            ld (hl),1                       ; set the player into digging mode
236+  B59D 23               inc hl
237+  B59E 36 03            ld (hl),3                      ; set the number of frame to dig for
238+  B5A0 23               inc hl
239+  B5A1 73               ld (hl),e                       ; set the number of pixels to dig
240+  B5A2 C9               ret
241+  B5A3              movement_spacebelowisdiggable1:
242+  B5A3 21 D9 B6         ld hl,player+6
243+  B5A6 36 00            ld (hl),0                       ; set the player out of digging mode
244+  B5A8 C9               ret
245+  B5A9
246+  B5A9              ;
247+  B5A9              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
248+  B5A9              ; Inputs:
249+  B5A9              ; hl - memory location of top pixel row
250+  B5A9              ; bc - screen coords, b horiz, c vert
251+  B5A9              ; Outputs:
252+  B5A9              ; none - puts player into digging mode
253+  B5A9              ;
254+  B5A9              movement_spaceaboveisdiggable:
255+  B5A9 7E               ld a,(hl)                       ; get first pixel row
256+  B5AA FE 55            cp 85
257+  B5AC CA B7 B5         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
258+  B5AF FE AA            cp 170
259+  B5B1 CA B7 B5         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
260+  B5B4 C3 62 B5         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
261+  B5B7              movement_spaceaboveisdiggable3:
262+  B5B7 3E 08            ld a,8                          ; rows to check
263+  B5B9 1E 00            ld e,0                          ; count of rows to dig
264+  B5BB              movement_spaceaboveisdiggable0:
265+  B5BB 08               ex af,af'                       ; store the loop counter
266+  B5BC 7E               ld a,(hl)                       ; get current pixel row
267+  B5BD FE 55            cp 85
268+  B5BF CA CA B5         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
269+  B5C2 FE AA            cp 170
270+  B5C4 CA CA B5         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
271+  B5C7 C3 DA B5         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
272+  B5CA              movement_spaceaboveisdiggable4:
273+  B5CA 1C               inc e                           ; inc count of rows to dig
274+  B5CB              movement_spaceaboveisdiggable2:
275+  B5CB 79               ld a,c                          ; load the vertical coord
276+  B5CC 3D               dec a                           ; next row up
277+  B5CD D5               push de                         ; need e for later
278+  B5CE 11 20 00         ld de,32
279+  B5D1 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
280+  B5D3 4F               ld c,a                          ; copy vert coord back to c
281+  B5D4 D1               pop de                          ; get e back
282+  B5D5 08               ex af,af'                       ; get loop counter back
283+  B5D6 3D               dec a                           ; incease loop counter
284+  B5D7 C2 BB B5         jp nz, movement_spaceaboveisdiggable0
285+  B5DA              movement_spaceaboveisdiggable5:
286+  B5DA 21 D9 B6         ld hl,player+6
287+  B5DD 36 01            ld (hl),1                       ; set the player into digging mode
288+  B5DF 23               inc hl
289+  B5E0 36 05            ld (hl),5                       ; set the number of frame to dig for
290+  B5E2 23               inc hl
291+  B5E3 73               ld (hl),e                       ; set the number of pixels to dig
292+  B5E4 C9               ret
293+  B5E5              movement_spaceaboveisdiggable1:
294+  B5E5 21 D9 B6         ld hl,player+6
295+  B5E8 36 00            ld (hl),0                       ; set the player out of digging mode
296+  B5EA C9               ret
297+  B5EB
298+  B5EB              ;
299+  B5EB              ; Checks if the player can move down
300+  B5EB              ; Inputs:
301+  B5EB              ; bc - player coords, b horiz, c vert
302+  B5EB              ; Outputs:
303+  B5EB              ; de - 1 can move
304+  B5EB              movement_checkcanmove_down:
305+  B5EB F5               push af
306+  B5EC C5               push bc
307+  B5ED CD 5D A8         call sprites_scadd              ; get the memory location of cell into de
308+  B5F0 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
309+  B5F2 24               inc h                       ; memory location of cell beneath now in hl
310+  B5F3 3E 08            ld a,8                       ; look below
311+  B5F5 81               add c
312+  B5F6 4F               ld c,a
313+  B5F7 CD FE B4         call movement_linebelowisempty       ; check space is empty
314+  B5FA 7B               ld a,e                          ; check space empty flag
315+  B5FB FE 00            cp 0
316+  B5FD CA 06 B6         jp z, movement_checkcanmove_down1 ; can't move
317+  B600 CD 1F B8         call player_justmoved
318+  B603 C1               pop bc
319+  B604 F1               pop af
320+  B605 C9               ret
321+  B606              movement_checkcanmove_down1:
322+  B606 C1               pop bc
323+  B607 CD 5D A8         call sprites_scadd              ; get the memory location of cell into de
324+  B60A 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
325+  B60C 24               inc h
326+  B60D C5               push bc
327+  B60E CD 68 B5         call movement_spacebelowisdiggable    ; can't move here, but can we dig
328+  B611 11 00 00         ld de,0
329+  B614 C1               pop bc
330+  B615 F1               pop af
331+  B616 C9               ret
332+  B617
333+  B617              ;
334+  B617              ; Checks if the player can move up
335+  B617              ; Inputs:
336+  B617              ; bc - player coords, b horiz, c vert
337+  B617              ; Outputs:
338+  B617              ; de - 1 can move
339+  B617              movement_checkcanmove_up:
340+  B617 F5               push af
341+  B618 C5               push bc
342+  B619 CD 5D A8         call sprites_scadd              ; get the memory location of cell into de
343+  B61C 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
344+  B61E 11 20 00         ld de,32
345+  B621 ED 52            sbc hl,de                       ; memory location of line above now in hl
346+  B623 0D               dec c                           ; look above
347+  B624 CD 19 B5         call movement_lineaboveisempty       ; check space is empty
348+  B627 7B               ld a,e                          ; check space empty flag
349+  B628 FE 00            cp 0
350+  B62A CA 35 B6         jp z, movement_checkcanmove_up1 ; can't move
351+  B62D 1E 01            ld e,1
352+  B62F CD 1F B8         call player_justmoved
353+  B632 C1               pop bc
354+  B633 F1               pop af
355+  B634 C9               ret
356+  B635              movement_checkcanmove_up1:
357+  B635 C1               pop bc
358+  B636 CD 5D A8         call sprites_scadd              ; get the memory location of cell into de
359+  B639 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
360+  B63B 11 20 00         ld de,32
361+  B63E ED 52            sbc hl,de                       ; memory location of line above now in hl
362+  B640 C5               push bc
363+  B641 CD A9 B5         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
364+  B644 11 00 00         ld de,0
365+  B647 C1               pop bc
366+  B648 F1               pop af
367+  B649 C9               ret
368+  B64A
369+  B64A              ;
370+  B64A              ; Checks if the player can move right
371+  B64A              ; Inputs:
372+  B64A              ; bc - player coords, b horiz, c vert
373+  B64A              ; Outputs:
374+  B64A              ; de - 1 can move
375+  B64A              movement_checkcanmove_right:
376+  B64A F5               push af
377+  B64B C5               push bc
378+  B64C CD 5D A8         call sprites_scadd              ; get the memory location of cell into de
379+  B64F 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
380+  B651 3E 08            ld a,8
381+  B653 80               add b                           ; move one cell right
382+  B654 47               ld b,a
383+  B655 23               inc hl                          ; memory location of cell to the right now in hl
384+  B656 CD 84 B4         call movement_spaceisempty       ; check space is empty
385+  B659 7B               ld a,e                          ; check space empty flag
386+  B65A FE 00            cp 0
387+  B65C CA 65 B6         jp z, movement_checkcanmove_right1 ; can't move
388+  B65F CD 1F B8         call player_justmoved
389+  B662 C1               pop bc
390+  B663 F1               pop af
391+  B664 C9               ret
392+  B665              movement_checkcanmove_right1:
393+  B665 C1               pop bc
394+  B666 CD 5D A8         call sprites_scadd              ; get the memory location of cell into de
395+  B669 62 6B            ld hl,de
396+  B66B 23               inc hl                          ; memory location of cell to the right now in hl
397+  B66C C5               push bc
398+  B66D CD 34 B5         call movement_spaceisdiggable    ; can't move here, but can we dig
399+  B670 11 00 00         ld de,0
400+  B673 C1               pop bc
401+  B674 F1               pop af
402+  B675 C9               ret
403+  B676
404+  B676              ;
405+  B676              ; Checks if the player can move left
406+  B676              ; Inputs:
407+  B676              ; bc - player coords, b horiz, c vert
408+  B676              ; Outputs:
409+  B676              ; de - 1 can move
410+  B676              movement_checkcanmove_left:
411+  B676 F5               push af
412+  B677 C5               push bc
413+  B678 CD 5D A8         call sprites_scadd              ; get the memory location of cell into de
414+  B67B 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
415+  B67D 78               ld a,b
416+  B67E 06 08            ld b,8
417+  B680 90               sub b                           ; move one cell left
418+  B681 47               ld b,a
419+  B682 2B               dec hl                          ; memory location of cell to the right now in hl
420+  B683 CD 84 B4         call movement_spaceisempty       ; check space is empty
421+  B686 7B               ld a,e                          ; check space empty flag
422+  B687 FE 00            cp 0
423+  B689 CA 92 B6         jp z, movement_checkcanmove_left1 ; can't move
424+  B68C CD 1F B8         call player_justmoved
425+  B68F C1               pop bc
426+  B690 F1               pop af
427+  B691 C9               ret
428+  B692              movement_checkcanmove_left1:
429+  B692 C1               pop bc
430+  B693 CD 5D A8         call sprites_scadd              ; get the memory location of cell into de
431+  B696 62 6B            ld hl,de
432+  B698 2B               dec hl                          ; memory location of cell to the right now in hl
433+  B699 C5               push bc
434+  B69A CD 34 B5         call movement_spaceisdiggable    ; can't move here, but can we dig
435+  B69D 11 00 00         ld de,0
436+  B6A0 C1               pop bc
437+  B6A1 F1               pop af
438+  B6A2 C9               ret
# file closed: game/movement.asm
 35   B6A3                  include "game\game.asm"
# file opened: game/game.asm
  1+  B6A3              ;
  2+  B6A3              ; The current frame count, incremented each frame
  3+  B6A3              ;
  4+  B6A3              game_framenumber:
  5+  B6A3 00               defb    0
  6+  B6A4
  7+  B6A4              ;
  8+  B6A4              ; The number of players
  9+  B6A4              ;
 10+  B6A4              game_numberplayers:
 11+  B6A4 01               defb 1
 12+  B6A5
 13+  B6A5              ;
 14+  B6A5              ; The current player
 15+  B6A5              ;
 16+  B6A5              game_currentplayer:
 17+  B6A5 01               defb 1
 18+  B6A6
 19+  B6A6              ;
 20+  B6A6              ; The default number of lives
 21+  B6A6              ;
 22+  B6A6              game_numberlives:
 23+  B6A6 01               defb 1
 24+  B6A7
 25+  B6A7              ;
 26+  B6A7              ; Moves to the next player
 27+  B6A7              ;
 28+  B6A7              game_changeplayer:
 29+  B6A7 3A A5 B6         ld a,(game_currentplayer)
 30+  B6AA FE 01            cp 1
 31+  B6AC C8               ret z                       ; if just one player, no need to change
 32+  B6AD 3D               dec a                       ; otherwise decrease by one
 33+  B6AE EE 01            xor 1                       ; xor with one to flip
 34+  B6B0 3C               inc a                       ; increment
 35+  B6B1 21 A5 B6         ld hl,game_currentplayer
 36+  B6B4 77               ld (hl),a                   ; store
 37+  B6B5 C9               ret
 38+  B6B6
 39+  B6B6              ;
 40+  B6B6              ; Sets the number of players at the start of the game
 41+  B6B6              ; Inputs:
 42+  B6B6              ; a - number of players
 43+  B6B6              game_setnumberofplayers:
 44+  B6B6 21 A4 B6         ld hl,game_numberplayers
 45+  B6B9 77               ld (hl),a
 46+  B6BA
 47+  B6BA              ;
 48+  B6BA              ; Increment frame number by 1
 49+  B6BA              ;
 50+  B6BA              game_incrementframe:
 51+  B6BA 3A A3 B6         ld a,(game_framenumber)
 52+  B6BD FE FF            cp 255
 53+  B6BF C2 C4 B6         jp nz,game_incrementframe0
 54+  B6C2 3E 00            ld a,0
 55+  B6C4              game_incrementframe0:
 56+  B6C4 3C               inc a
 57+  B6C5 32 A3 B6         ld (game_framenumber),a
 58+  B6C8 C9               ret
 59+  B6C9
 60+  B6C9              ;
 61+  B6C9              ; Returns current frame
 62+  B6C9              ; Outputs:
 63+  B6C9              ; a - current frame
 64+  B6C9              ;
 65+  B6C9              game_getcurrentframe:
 66+  B6C9 3A A3 B6         ld a,(game_framenumber)
 67+  B6CC C9               ret
 68+  B6CD
 69+  B6CD              ;
 70+  B6CD              ; Resets current frame
 71+  B6CD              ;
 72+  B6CD              game_resetcurrentframe:
 73+  B6CD 21 A3 B6         ld hl,game_framenumber
 74+  B6D0 36 00            ld (hl),0
 75+  B6D2 C9               ret
# file closed: game/game.asm
 36   B6D3                  include "game\player.asm"
# file opened: game/player.asm
  1+  B6D3              ;
  2+  B6D3              ;   Data for current player
  3+  B6D3              ;
  4+  B6D3              player:
  5+  B6D3 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  B6D5 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  B6D8 00               defb    0                   ; auto move remaining (+5)
  8+  B6D9 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  B6DC 00               defb    0                   ; lives remaining (+9)
 10+  B6DD 00               defb    0                   ; died this life (+10)
 11+  B6DE 00 00            defb    0,0                 ; crushed (+11), frames (+12)
 12+  B6E0
 13+  B6E0              ;
 14+  B6E0              ; Initializes a player at start of game
 15+  B6E0              ; Copy initial coords, copy lives, copy score
 16+  B6E0              ;
 17+  B6E0              player_init_gamestart:
 18+  B6E0 3A A6 B6         ld a,(game_numberlives)
 19+  B6E3 32 7A B7         ld (player1_lives),a
 20+  B6E6 32 7B B7         ld (player2_lives),a                        ; set the initial number of lives at game start
 21+  B6E9
 22+  B6E9 21 7E B7         ld hl,player1_score+2
 23+  B6EC 06 06            ld b,6
 24+  B6EE              player_init_gamestart0:
 25+  B6EE 36 30            ld (hl),48
 26+  B6F0 23               inc hl
 27+  B6F1 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 28+  B6F3 21 87 B7         ld hl,player2_score+2
 29+  B6F6 06 06            ld b,6
 30+  B6F8              player_init_gamestart1:
 31+  B6F8 36 30            ld (hl),48
 32+  B6FA 23               inc hl
 33+  B6FB 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 34+  B6FD C9               ret
 35+  B6FE
 36+  B6FE              ;
 37+  B6FE              ; Initializes a player at start of a life
 38+  B6FE              ; Copy initial coords, copy lives, copy score
 39+  B6FE              ;
 40+  B6FE              player_init_lifestart:
 41+  B6FE ED 4B 22 80      ld bc,(init_coord)
 42+  B702 ED 43 D3 B6      ld (player),bc
 43+  B706 01 DC B6         ld bc,player+9
 44+  B709 3A 7A B7         ld a,(player1_lives)
 45+  B70C 02               ld (bc),a
 46+  B70D 01 DD B6         ld bc,player+10
 47+  B710 3E 00            ld a,0
 48+  B712 02               ld (bc),a
 49+  B713 01 DE B6         ld bc,player+11         ; crushed
 50+  B716 3E 00            ld a,0
 51+  B718 02               ld (bc),a
 52+  B719 01 DF B6         ld bc,player+12         ; crush count
 53+  B71C 3E 00            ld a,0
 54+  B71E 02               ld (bc),a
 55+  B71F 01 D5 B6         ld bc,player+2         ; frame
 56+  B722 3E 02            ld a,2
 57+  B724 02               ld (bc),a
 58+  B725 01 D9 B6         ld bc,player+6         ; frame
 59+  B728 3E 00            ld a,0
 60+  B72A 02               ld (bc),a
 61+  B72B 01 D8 B6         ld bc,player+5         ; automove
 62+  B72E 3E 00            ld a,0
 63+  B730 02               ld (bc),a
 64+  B731 CD 30 BD         call diamonds_init      ; initialise gems
 65+  B734
 66+  B734 01 06 00         ld bc,6
 67+  B737 11 83 BB         ld de,scores_current+2
 68+  B73A 3A A5 B6         ld a,(game_currentplayer)
 69+  B73D FE 01            cp 1
 70+  B73F C2 48 B7         jp nz,player_init_lifestart0
 71+  B742 21 7E B7         ld hl,player1_score+2
 72+  B745 C3 4B B7         jp player_init_lifestart1
 73+  B748              player_init_lifestart0:
 74+  B748 21 87 B7         ld hl,player2_score+2
 75+  B74B              player_init_lifestart1:
 76+  B74B ED B0            ldir
 77+  B74D C9               ret
 78+  B74E
 79+  B74E              ;
 80+  B74E              ; Finalises a player at end of a life
 81+  B74E              ; Copy lives, copy score
 82+  B74E              ;
 83+  B74E              player_lifeend:
 84+  B74E 01 DC B6         ld bc,player+9
 85+  B751 0A               ld a,(bc)
 86+  B752 01 7A B7         ld bc,player1_lives
 87+  B755 02               ld (bc),a
 88+  B756
 89+  B756 01 06 00         ld bc,6                  ; copy current score back to correct player
 90+  B759 21 83 BB         ld hl,scores_current+2
 91+  B75C 3A A5 B6         ld a,(game_currentplayer)
 92+  B75F FE 01            cp 1
 93+  B761 C2 6A B7         jp nz,player_lifeend0
 94+  B764 11 7E B7         ld de,player1_score+2
 95+  B767 C3 6D B7         jp player_lifeend1
 96+  B76A              player_lifeend0:
 97+  B76A 11 87 B7         ld de,player2_score+2
 98+  B76D              player_lifeend1:
 99+  B76D ED B0            ldir
100+  B76F C9               ret
101+  B770
102+  B770              ;
103+  B770              ; Player just died, subtract a life
104+  B770              ;
105+  B770              player_died:
106+  B770 01 DC B6         ld bc,player+9
107+  B773 0A               ld a,(bc)
108+  B774 3D               dec a
109+  B775 02               ld (bc),a
110+  B776 CD 4E B7         call player_lifeend
111+  B779 C9               ret
112+  B77A
113+  B77A              ;
114+  B77A              ; Player lives
115+  B77A              ;
116+  B77A              player1_lives:
117+  B77A 03               defb 3
118+  B77B              player2_lives:
119+  B77B 03               defb 3
120+  B77C
121+  B77C              ;
122+  B77C              ; Player scores
123+  B77C              ;
124+  B77C              player1_score:
125+  B77C 04 01 30 30      defb 4,1,'000000',255
125+  B780 30 30 30 30
125+  B784 FF
126+  B785              player2_score:
127+  B785 16 01 30 30      defb 22,1,'000000',255
127+  B789 30 30 30 30
127+  B78D FF
128+  B78E
129+  B78E              ;
130+  B78E              ; Kills a player this life
131+  B78E              ;
132+  B78E              player_killplayer:
133+  B78E 21 DD B6         ld hl,player+10
134+  B791 36 01            ld (hl),1
135+  B793 C9               ret
136+  B794
137+  B794              ;
138+  B794              ; Crush a player this life
139+  B794              ;
140+  B794              player_crushplayer:
141+  B794 21 DE B6         ld hl,player+11             ; mark as crushed
142+  B797 36 01            ld (hl),1
143+  B799 C9               ret
144+  B79A
145+  B79A              ;
146+  B79A              ; Draws the player at the current position or deletes them
147+  B79A              ;
148+  B79A              player_drawplayer:
149+  B79A 3A D5 B6         ld a,(player+2)             ; get the current direction
150+  B79D FE 03            cp 3
151+  B79F C2 A4 B7         jp nz,player_drawplayer0
152+  B7A2 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
153+  B7A4              player_drawplayer0:
154+  B7A4 5F               ld e,a                      ; store in e
155+  B7A5 3A DE B6         ld a,(player+11)             ; get the dying flag
156+  B7A8 FE 01            cp 1
157+  B7AA CA BC B7         jp z,player_drawplayer3     ; if it's one, we're being crushed
158+  B7AD              player_drawplayer4:
159+  B7AD 3A D9 B6         ld a,(player+6)             ; get the dig flag
160+  B7B0 FE 01            cp 1
161+  B7B2 CA 05 B8         jp z,player_drawplayer1    ; get dig frame
162+  B7B5 3A D6 B6         ld a,(player+3)             ; this is normal movement so get the current frame
163+  B7B8 83               add a,e
164+  B7B9 C3 0A B8         jp player_drawplayer2
165+  B7BC              player_drawplayer3:
166+  B7BC 21 DF B6         ld hl,player+12
167+  B7BF 7E               ld a,(hl)                  ; crushing, so get the current anim flag
168+  B7C0 FE 00            cp 0
169+  B7C2 C2 CB B7         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
170+  B7C5 3E 64            ld a,100
171+  B7C7 77               ld (hl),a                   ; otherwise, load up the anim frames
172+  B7C8 C3 AD B7         jp player_drawplayer4       ; and return to the main loop to remove the current frame
173+  B7CB              player_drawplayer5:
174+  B7CB 3D               dec a
175+  B7CC 77               ld (hl),a
176+  B7CD FE 00            cp 0
177+  B7CF CC 8E B7         call z,player_killplayer    ; final animation, so kill the player
178+  B7D2 FE 14            cp 20                        ; check if we should move the rock
179+  B7D4 C2 E8 B7         jp nz,player_drawplayer8
180+  B7D7 D9               exx
181+  B7D8 08               ex af,af'
182+  B7D9 ED 4B 24 BA      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
183+  B7DD 21 09 B1         ld hl,sprites+72
184+  B7E0 CD 1A A8         call sprites_drawsprite     ; draw a rock over current
185+  B7E3 08               ex af,af'
186+  B7E4 D9               exx
187+  B7E5 C3 FE B7         jp player_drawplayer6       ; continue drawing player
188+  B7E8              player_drawplayer8:
189+  B7E8 FE 14            cp 20
190+  B7EA D2 FE B7         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
191+  B7ED ED 4B D3 B6      ld bc,(player)
192+  B7F1 CD A1 A7         call screen_getattraddressfromscreencoords ; get the attr address into de
193+  B7F4 62 6B            ld hl,de
194+  B7F6 36 42            ld (hl),66
195+  B7F8 21 09 B1         ld hl,sprites+72            ; otherwise, player is rock
196+  B7FB C3 14 B8         jp player_drawplayer7
197+  B7FE              player_drawplayer6:
198+  B7FE E6 01            and 1                       ; check for odd
199+  B800 C6 0A            add 10                      ; add 10, to get either 10 or 11
200+  B802 C3 0A B8         jp player_drawplayer2
201+  B805              player_drawplayer1:
202+  B805 3A D5 B6         ld a,(player+2)             ; digging, get the current direction again, because want all four
203+  B808 C6 06            add a,6                     ; add direction to 6 to get frame
204+  B80A              player_drawplayer2:
205+  B80A 07               rlca
206+  B80B 07               rlca
207+  B80C 07               rlca                        ; multiply by eight
208+  B80D 6F               ld l,a
209+  B80E 26 00            ld h,0
210+  B810 11 48 B1         ld de,player_sprite
211+  B813 19               add hl,de                   ; load hl with the location of the player sprite data
212+  B814              player_drawplayer7:
213+  B814 ED 4B D3 B6      ld bc,(player)              ; load bc with the start coords
214+  B818 CD 1A A8         call sprites_drawsprite     ; call the routine to draw the sprite
215+  B81B CD 4B B8         call player_storeupdatedlines ; log updated rows
216+  B81E C9               ret
217+  B81F
218+  B81F
219+  B81F              ;
220+  B81F              ; Runs after the player just moved. Changes animation frame if required
221+  B81F              ;
222+  B81F              player_justmoved:
223+  B81F D9               exx
224+  B820 3A D7 B6         ld a,(player+4)             ; get the transition count
225+  B823 FE 00            cp 0
226+  B825 CA 2B B8         jp z, player_justmoved2     ; if zero reset and change the frame
227+  B828 C3 45 B8         jp player_justmoved1       ; otherwise decrease and continue
228+  B82B              player_justmoved2:
229+  B82B                  ; reset and change frame in here
230+  B82B 3E 01            ld a,1
231+  B82D 32 D7 B6         ld (player+4),a            ; reset back to whatever
232+  B830 3A D6 B6         ld a,(player+3)             ; load the frame
233+  B833 FE 03            cp 3                       ; flip between 3 and 0
234+  B835 C2 3D B8         jp nz, player_justmoved4
235+  B838 3E 00            ld a,0
236+  B83A C3 3F B8         jp player_justmoved5
237+  B83D              player_justmoved4:
238+  B83D 3E 03            ld a,3
239+  B83F              player_justmoved5:
240+  B83F 32 D6 B6         ld (player+3),a           ; save back
241+  B842 C3 49 B8         jp player_justmoved3
242+  B845              player_justmoved1:
243+  B845                  ; decrease count
244+  B845 3D               dec a
245+  B846 32 D7 B6         ld (player+4),a
246+  B849              player_justmoved3:
247+  B849 D9               exx;
248+  B84A C9               ret
249+  B84B
250+  B84B              ;
251+  B84B              ; Stores the updated rows associated with the player
252+  B84B              ;
253+  B84B              player_storeupdatedlines:
254+  B84B ED 4B D3 B6      ld bc,(player)          ; get the screen coords into bc
255+  B84F 79               ld a,c                  ; get the player block coords of current block
256+  B850 E6 F8            and 248                 ; find closest multiple of eight
257+  B852 0F               rrca
258+  B853 0F               rrca
259+  B854 0F               rrca                    ; divide by 8
260+  B855 ED 5B 76 A6      ld de,(screen_offset)          ; load the screen offset, this is in rows
261+  B859 93               sub e
262+  B85A F5               push af
263+  B85B CD 29 A5         call buffer_marklineforupdate  ; store current row in updated lines
264+  B85E F1               pop af
265+  B85F 3D               dec a
266+  B860 F5               push af
267+  B861 CD 29 A5         call buffer_marklineforupdate  ; store line above
268+  B864 F1               pop af
269+  B865 3C               inc a
270+  B866 3C               inc a
271+  B867 CD 29 A5         call buffer_marklineforupdate  ; store line beneath
272+  B86A C9               ret
# file closed: game/player.asm
 37   B86B                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  B86B              ;
  2+  B86B              ; Ship initial position: vert,horiz
  3+  B86B              ;
  4+  B86B              ship_initpos:
  5+  B86B 00 24            defb 0,36
  6+  B86D              ship_initpos2:
  7+  B86D 00 00            defb 0,0
  8+  B86F              ship_frame:
  9+  B86F 00               defb 0
 10+  B870              ;
 11+  B870              ; The current memory location
 12+  B870              ;
 13+  B870              ship_current_sprite:
 14+  B870 00 00            defb 0,0
 15+  B872
 16+  B872              ship_current_coords:
 17+  B872 00 00            defb 0,0
 18+  B874
 19+  B874              ;
 20+  B874              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 21+  B874              ;
 22+  B874              ship_land:
 23+  B874 ED 4B 6B B8      ld bc,(ship_initpos)
 24+  B878 ED 43 6D B8      ld (ship_initpos2),bc        ; save the initial position for later use
 25+  B87C 1E 00            ld e,0                      ; store a flag to track first time round
 26+  B87E 06 09            ld b,9                      ; move down 8 pixels
 27+  B880              ship_land0:
 28+  B880 C5               push bc
 29+  B881 7B               ld a,e
 30+  B882 D5               push de                     ; store de for next time round
 31+  B883 FE 01            cp 1                        ; check first time flag
 32+  B885 C2 9A B8         jp nz,ship_land1             ; don't draw over previous one if first time
 33+  B888 CD 02 B9         call ship_draw_full         ; delete old one
 34+  B88B CD D7 B8         call ship_change_frame      ; increment the frame
 35+  B88E ED 4B 6D B8      ld bc,(ship_initpos2)       ; get the current coords
 36+  B892 81 C6 01         add c,1                     ; move down one pixels
 37+  B895 4F               ld c,a
 38+  B896 ED 43 6D B8      ld (ship_initpos2),bc
 39+  B89A              ship_land1:
 40+  B89A CD 02 B9         call ship_draw_full         ; draw the ship
 41+  B89D CD EC B8         call ship_draw_screen
 42+  B8A0 D1               pop de
 43+  B8A1 1E 01            ld e,1
 44+  B8A3 C1               pop bc
 45+  B8A4 10 DA            djnz ship_land0             ; repeat for downward movement
 46+  B8A6                  ; done moving down
 47+  B8A6                  ; now move across
 48+  B8A6 CD 9A B7         call player_drawplayer      ; draw player
 49+  B8A9 CD 02 B9         call ship_draw_full         ; delete old one
 50+  B8AC 1E 00            ld e,0                      ; store a flag to track first time round
 51+  B8AE 06 14            ld b,20                      ; move back 20 pixels pixels
 52+  B8B0              ship_land3:
 53+  B8B0 C5               push bc
 54+  B8B1 7B               ld a,e
 55+  B8B2 D5               push de                     ; store de for next time round
 56+  B8B3 FE 01            cp 1                        ; check first time flag
 57+  B8B5 C2 CA B8         jp nz,ship_land2             ; don't draw over previous one if first time
 58+  B8B8 CD 02 B9         call ship_draw_full         ; delete old one
 59+  B8BB CD D7 B8         call ship_change_frame      ; increment the frame
 60+  B8BE ED 4B 6D B8      ld bc,(ship_initpos2)       ; get the current coords
 61+  B8C2 78               ld a,b
 62+  B8C3 D6 01            sub 1                       ; move back one pixels
 63+  B8C5 47               ld b,a
 64+  B8C6 ED 43 6D B8      ld (ship_initpos2),bc
 65+  B8CA              ship_land2:
 66+  B8CA CD 02 B9         call ship_draw_full         ; draw the ship
 67+  B8CD CD EC B8         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 68+  B8D0 D1               pop de
 69+  B8D1 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 70+  B8D3 C1               pop bc
 71+  B8D4 10 DA            djnz ship_land3             ; repeat for vertical movement
 72+  B8D6 C9               ret
 73+  B8D7
 74+  B8D7              ;
 75+  B8D7              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
 76+  B8D7              ;
 77+  B8D7              ship_change_frame:
 78+  B8D7 F5               push af
 79+  B8D8 3A 6F B8         ld a,(ship_frame)
 80+  B8DB FE 00            cp 0
 81+  B8DD CA E5 B8         jp z,ship_change_frame0
 82+  B8E0 3E 00            ld a,0                      ; flip to 0
 83+  B8E2 C3 E7 B8         jp ship_change_frame1
 84+  B8E5              ship_change_frame0:
 85+  B8E5 3E 20            ld a,32                      ; flip to 32
 86+  B8E7              ship_change_frame1:
 87+  B8E7 32 6F B8         ld (ship_frame),a            ; save the frame
 88+  B8EA F1               pop af
 89+  B8EB C9               ret
 90+  B8EC
 91+  B8EC              ship_draw_screen:
 92+  B8EC 3E 00            ld a,0
 93+  B8EE CD 29 A5         call buffer_marklineforupdate
 94+  B8F1 3E 01            ld a,1
 95+  B8F3 CD 29 A5         call buffer_marklineforupdate
 96+  B8F6 3E 02            ld a,2
 97+  B8F8 CD 29 A5         call buffer_marklineforupdate   ; mark the first three rows for update
 98+  B8FB 76               halt
 99+  B8FC F3               di
100+  B8FD CD BD A5         call buffer_buffertoscreen  ; copy buffer to screen
101+  B900 FB               ei                          ; enable interupts
102+  B901 C9               ret
103+  B902
104+  B902              ship_draw_full:
105+  B902 21 A8 B1         ld hl,ship_sprite
106+  B905 ED 4B 6D B8      ld bc,(ship_initpos2)         ; load bc with the start coords
107+  B909 22 70 B8         ld (ship_current_sprite),hl  ; put into memory
108+  B90C ED 43 72 B8      ld (ship_current_coords),bc  ; put into memory
109+  B910 CD 2F B9         call ship_draw
110+  B913 08               ex af,af'
111+  B914 3A 6F B8         ld a,(ship_frame)            ; get the animation frame
112+  B917 16 00            ld d,0
113+  B919 5F               ld e,a
114+  B91A 19               add hl,de
115+  B91B 22 70 B8         ld (ship_current_sprite),hl  ; put into memory
116+  B91E 08               ex af,af'
117+  B91F ED 4B 6D B8      ld bc,(ship_initpos2)         ; load bc with the start coords
118+  B923 81 C6 08         add c,8                      ; move one line down
119+  B926 4F               ld c,a
120+  B927 ED 43 72 B8      ld (ship_current_coords),bc  ; put into memory
121+  B92B CD 2F B9         call ship_draw
122+  B92E C9               ret
123+  B92F
124+  B92F              ;
125+  B92F              ; Draw the ship
126+  B92F              ; Inputs:
127+  B92F              ; None, all in memory
128+  B92F              ;
129+  B92F              ship_draw:
130+  B92F 3E 04            ld a,4                              ; 4 pieces per half
131+  B931              ship_draw0:
132+  B931 F5               push af
133+  B932 2A 70 B8         ld hl,(ship_current_sprite)
134+  B935 ED 4B 72 B8      ld bc,(ship_current_coords)         ; load bc with the start coords
135+  B939 CD 1A A8         call sprites_drawsprite
136+  B93C 2A 70 B8         ld hl,(ship_current_sprite)
137+  B93F ED 4B 72 B8      ld bc,(ship_current_coords)         ; load bc with the start coords
138+  B943 11 08 00         ld de,8
139+  B946 19               add hl,de
140+  B947 80 C6 08         add b,8
141+  B94A 47               ld b,a
142+  B94B 22 70 B8         ld (ship_current_sprite),hl         ; put into memory
143+  B94E ED 43 72 B8      ld (ship_current_coords),bc         ; put into memory
144+  B952 F1               pop af
145+  B953 3D               dec a
146+  B954 FE 00            cp 0
147+  B956 C2 31 B9         jp nz,ship_draw0
148+  B959
149+  B959 C9               ret
150+  B95A
# file closed: game/ship.asm
 38   B95A                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  B95A              ;
  2+  B95A              ; tank initial position: vert,horiz
  3+  B95A              ;
  4+  B95A              tank_initpos:
  5+  B95A 10 D0            defb 16,208
  6+  B95C              tank_initpos2:
  7+  B95C 00 00            defb 0,0
  8+  B95E              tank_frame:
  9+  B95E 00               defb 0
 10+  B95F              tank_anim:
 11+  B95F 11               defb 17
 12+  B960              ;
 13+  B960              ; The current memory location
 14+  B960              ;
 15+  B960              tank_current_sprite:
 16+  B960 00 00            defb 0,0
 17+  B962
 18+  B962              tank_current_coords:
 19+  B962 00 00            defb 0,0
 20+  B964
 21+  B964              ;
 22+  B964              ; Initialise the tank
 23+  B964              ;
 24+  B964              tank_init:
 25+  B964 ED 4B 5A B9      ld bc,(tank_initpos)
 26+  B968 ED 43 5C B9      ld (tank_initpos2),bc       ; save the initial position for later use
 27+  B96C 21 5E B9         ld hl,tank_frame
 28+  B96F 36 00            ld (hl),0
 29+  B971 21 5F B9         ld hl,tank_anim
 30+  B974 36 11            ld (hl),17                  ; reset tank
 31+  B976 C9               ret
 32+  B977
 33+  B977              ;
 34+  B977              ;   Draw and move the tank
 35+  B977              ;   Start processing at frame 200
 36+  B977              ;   Don't move if anim is zero
 37+  B977              ;   Decrement frame if moved
 38+  B977              ;
 39+  B977              tank_process:
 40+  B977 3A 5F B9         ld a,(tank_anim)
 41+  B97A FE 00            cp 0
 42+  B97C C8               ret z                       ; return if we've already moved
 43+  B97D CD C9 B6         call game_getcurrentframe   ; get the current frame number into a
 44+  B980 FE 4B            cp 75
 45+  B982 D8               ret c                       ; return if the frame number is below 100
 46+  B983 CD 8E B9         call tank_move              ; move tank if not
 47+  B986 3A 5F B9         ld a,(tank_anim)
 48+  B989 3D               dec a
 49+  B98A 32 5F B9         ld (tank_anim),a            ; decrease the anim count
 50+  B98D C9               ret
 51+  B98E
 52+  B98E              tank_move:
 53+  B98E ED 4B 5C B9      ld bc,(tank_initpos2)
 54+  B992 C5               push bc
 55+  B993 3A 5F B9         ld a,(tank_anim)
 56+  B996 FE 11            cp 17                       ; check first time flag
 57+  B998 CA AA B9         jp z,tank_move1             ; don't draw over previous one if first time
 58+  B99B CD AF B9         call tank_draw_full         ; delete old one
 59+  B99E ED 4B 5C B9      ld bc,(tank_initpos2)       ; get the current coords
 60+  B9A2 78               ld a,b
 61+  B9A3 D6 01            sub 1                       ; move back one pixels
 62+  B9A5 47               ld b,a
 63+  B9A6 ED 43 5C B9      ld (tank_initpos2),bc
 64+  B9AA              tank_move1:
 65+  B9AA CD AF B9         call tank_draw_full         ; draw the tank
 66+  B9AD C1               pop bc
 67+  B9AE C9               ret
 68+  B9AF
 69+  B9AF              tank_draw_full:
 70+  B9AF 21 08 B2         ld hl,tank_sprite
 71+  B9B2 ED 4B 5C B9      ld bc,(tank_initpos2)         ; load bc with the start coords
 72+  B9B6 22 60 B9         ld (tank_current_sprite),hl  ; put into memory
 73+  B9B9 ED 43 62 B9      ld (tank_current_coords),bc  ; put into memory
 74+  B9BD CD E6 B9         call tank_draw
 75+  B9C0 08               ex af,af'
 76+  B9C1 3A 5E B9         ld a,(tank_frame)            ; get the animation frame
 77+  B9C4 16 00            ld d,0
 78+  B9C6 5F               ld e,a
 79+  B9C7 19               add hl,de
 80+  B9C8 22 60 B9         ld (tank_current_sprite),hl  ; put into memory
 81+  B9CB 08               ex af,af'
 82+  B9CC ED 4B 5C B9      ld bc,(tank_initpos2)         ; load bc with the start coords
 83+  B9D0 81 C6 08         add c,8                      ; move one line down
 84+  B9D3 4F               ld c,a
 85+  B9D4 ED 43 62 B9      ld (tank_current_coords),bc  ; put into memory
 86+  B9D8 CD E6 B9         call tank_draw
 87+  B9DB 3E 02            ld a,2
 88+  B9DD CD 29 A5         call buffer_marklineforupdate
 89+  B9E0 3E 03            ld a,3
 90+  B9E2 CD 29 A5         call buffer_marklineforupdate   ; mark the first two rows for update
 91+  B9E5 C9               ret
 92+  B9E6
 93+  B9E6              ;
 94+  B9E6              ; Draw the tank
 95+  B9E6              ; Inputs:
 96+  B9E6              ; None, all in memory
 97+  B9E6              ;
 98+  B9E6              tank_draw:
 99+  B9E6 3E 04            ld a,4                              ; 4 pieces per half
100+  B9E8              tank_draw0:
101+  B9E8 F5               push af
102+  B9E9 2A 60 B9         ld hl,(tank_current_sprite)
103+  B9EC ED 4B 62 B9      ld bc,(tank_current_coords)         ; load bc with the start coords
104+  B9F0 CD 1A A8         call sprites_drawsprite
105+  B9F3 2A 60 B9         ld hl,(tank_current_sprite)
106+  B9F6 ED 4B 62 B9      ld bc,(tank_current_coords)         ; load bc with the start coords
107+  B9FA 11 08 00         ld de,8
108+  B9FD 19               add hl,de
109+  B9FE 80 C6 08         add b,8
110+  BA01 47               ld b,a
111+  BA02 22 60 B9         ld (tank_current_sprite),hl         ; put into memory
112+  BA05 ED 43 62 B9      ld (tank_current_coords),bc         ; put into memory
113+  BA09 F1               pop af
114+  BA0A 3D               dec a
115+  BA0B FE 00            cp 0
116+  BA0D C2 E8 B9         jp nz,tank_draw0
117+  BA10
118+  BA10 C9               ret
119+  BA11
# file closed: game/tank.asm
 39   BA11                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  BA11              ;
  2+  BA11              ; A structure of falling rocks
  3+  BA11              ; Assume we'll never have more than 4 falling at any one time
  4+  BA11              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  BA11              ;
  6+  BA11              rocks_falling:
  7+  BA11 00 00 00 00      defb 0,0,0,0
  8+  BA15 00 00 00 00      defb 0,0,0,0
  9+  BA19 00 00 00 00      defb 0,0,0,0
 10+  BA1D 00 00 00 00      defb 0,0,0,0
 11+  BA21
 12+  BA21              rocks_tmp:
 13+  BA21 00               defb 0
 14+  BA22
 15+  BA22              rocks_tmp2:
 16+  BA22 00 00            defb 0,0
 17+  BA24
 18+  BA24              ;
 19+  BA24              ; Coords of the rock that killed us
 20+  BA24              ;
 21+  BA24              rocks_killerrock:
 22+  BA24 00 00            defb 0,0
 23+  BA26
 24+  BA26              ;
 25+  BA26              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 26+  BA26              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 27+  BA26              ; If the pixel row is not the rock bottom, stop checking.
 28+  BA26              ; Inputs:
 29+  BA26              ; hl- memory location
 30+  BA26              ;
 31+  BA26              rocks_checkforfalling:
 32+  BA26 7E               ld a,(hl)           ; get the pixel row in this memory location
 33+  BA27 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 34+  BA29 C2 2F BA         jp nz,rocks_checkforfalling2 ; not a rock, stop
 35+  BA2C CD 30 BA         call rocks_addrocktofalling ; mark the rock as falling
 36+  BA2F              rocks_checkforfalling2:
 37+  BA2F C9               ret
 38+  BA30
 39+  BA30              ;
 40+  BA30              ; Adds the rock to the structure that tracks falling rocks
 41+  BA30              ; Inputs:
 42+  BA30              ; hl - memory location of falling rock graphic
 43+  BA30              ; bc - coords of rock, c vert
 44+  BA30              rocks_addrocktofalling:
 45+  BA30 C5               push bc             ; store the coords
 46+  BA31 11 11 BA         ld de,rocks_falling
 47+  BA34 06 04            ld b,4              ; number of possible falling rocks
 48+  BA36              rocks_addrocktofalling0:
 49+  BA36 13               inc de
 50+  BA37 13               inc de
 51+  BA38 13               inc de              ; move three along to get the state
 52+  BA39 1A               ld a,(de)           ; load the state
 53+  BA3A FE 00            cp 0                ; check if this is not falling
 54+  BA3C C2 51 BA         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 55+  BA3F 3E 10            ld a,16             ; load the number of frames to wobble
 56+  BA41 12               ld (de),a
 57+  BA42 1B               dec de              ; move de back to state
 58+  BA43 3E 02            ld a,2
 59+  BA45 12               ld (de),a           ; set the state to wobbling
 60+  BA46 1B               dec de              ; move back coords
 61+  BA47 C1               pop bc              ; get back coords
 62+  BA48 78               ld a,b
 63+  BA49 12               ld (de),a           ; store the vertical
 64+  BA4A 1B               dec de
 65+  BA4B 79               ld a,c
 66+  BA4C 12               ld (de),a           ; store the horizontal
 67+  BA4D C5               push bc
 68+  BA4E C3 54 BA         jp rocks_addrocktofalling2 ; done
 69+  BA51              rocks_addrocktofalling1:
 70+  BA51 13               inc de              ; move memory along to next rock
 71+  BA52 10 E2            djnz rocks_addrocktofalling0 ; try the next rock
 72+  BA54              rocks_addrocktofalling2: ; done, return
 73+  BA54 C1               pop bc              ; to tidy up
 74+  BA55 C9               ret
 75+  BA56
 76+  BA56              ;
 77+  BA56              ; Processes any falling rocks
 78+  BA56              ;
 79+  BA56              rocks_processrocks:
 80+  BA56 DD 21 11 BA      ld ix,rocks_falling
 81+  BA5A 06 04            ld b,4              ; the number of rocks to check
 82+  BA5C              rocks_processrocks0:
 83+  BA5C C5               push bc             ; store loop count
 84+  BA5D DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 84+  BA61 46 01
 85+  BA63 DD 23            inc ix
 86+  BA65 DD 23            inc ix              ; move to the state
 87+  BA67 DD 7E 00         ld a,(ix)           ; load the state into a
 88+  BA6A FE 00            cp 0
 89+  BA6C CA 90 BA         jp z,rocks_processrocks3 ; if not falling, check next
 90+  BA6F FE 02            cp 2
 91+  BA71 C2 81 BA         jp nz, rocks_processrocks2
 92+  BA74                  ; we're wobbling
 93+  BA74 DD 23            inc ix              ; get frame number for wobble
 94+  BA76 DD 7E 00         ld a,(ix)           ; get wobble frame into a
 95+  BA79 CD 4E BB         call rocks_wobble
 96+  BA7C DD 23            inc ix              ; increment for next
 97+  BA7E C3 94 BA         jp rocks_processrocks1  ; do next rock
 98+  BA81              rocks_processrocks2:
 99+  BA81                  ; we're falling
100+  BA81 C5               push bc
101+  BA82 CD AD BA         call rocks_fall
102+  BA85 C1               pop bc
103+  BA86 CD 98 BA         call rocks_storeupdatedlines
104+  BA89 DD 23            inc ix
105+  BA8B DD 23            inc ix              ; inc ix to get to next
106+  BA8D C3 94 BA         jp rocks_processrocks1
107+  BA90              rocks_processrocks3:
108+  BA90 DD 23            inc ix
109+  BA92 DD 23            inc ix
110+  BA94              rocks_processrocks1:
111+  BA94 C1               pop bc              ; get loop count back
112+  BA95 10 C5            djnz rocks_processrocks0
113+  BA97 C9               ret
114+  BA98
115+  BA98              ;
116+  BA98              ; Stores the updated rows associated with the rock
117+  BA98              ; Inputs:
118+  BA98              ; bc - coords
119+  BA98              ;
120+  BA98              rocks_storeupdatedlines:
121+  BA98 79               ld a,c                  ; get the player block coords of current block
122+  BA99 E6 F8            and 248                 ; find closest multiple of eight
123+  BA9B 0F               rrca
124+  BA9C 0F               rrca
125+  BA9D 0F               rrca                    ; divide by 8
126+  BA9E ED 5B 76 A6      ld de,(screen_offset)          ; load the screen offset, this is in rows
127+  BAA2 93               sub e
128+  BAA3 F5               push af
129+  BAA4 CD 29 A5         call buffer_marklineforupdate  ; store current row in updated lines
130+  BAA7 F1               pop af
131+  BAA8 3C               inc a
132+  BAA9 CD 29 A5         call buffer_marklineforupdate  ; store line beneath
133+  BAAC C9               ret
134+  BAAD
135+  BAAD              ;
136+  BAAD              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
137+  BAAD              ; bc - coord of current rock graphic on screen
138+  BAAD              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
139+  BAAD              ;
140+  BAAD              rocks_fall:
141+  BAAD DD 2B            dec ix
142+  BAAF DD 2B            dec ix              ; decrease ix back to coords
143+  BAB1 ED 43 22 BA      ld (rocks_tmp2),bc  ; store original coords
144+  BAB5 3E 03            ld a,3              ; move this number of pixels
145+  BAB7              rocks_fall1:
146+  BAB7 08               ex af,af'
147+  BAB8 DD 4E 00 DD      ld bc,(ix)          ; get current coords
147+  BABC 46 01
148+  BABE CD 5D A8         call sprites_scadd  ; get the memory of the coords into de
149+  BAC1 14               inc d               ; add 256 to get next row
150+  BAC2 1A               ld a,(de)           ; get the contents of the next row
151+  BAC3 FE 00            cp 0
152+  BAC5 C2 1E BB         jp nz,rocks_fall3    ; move the rock if the row is empty
153+  BAC8 0C               inc c               ; increment the vertical
154+  BAC9 DD 71 00 DD      ld (ix),bc          ; store the new coords
154+  BACD 70 01
155+  BACF 79               ld a,c              ; get the vertical coord into a
156+  BAD0 E6 07            and 7               ; divisible by 8?
157+  BAD2 FE 00            cp 0
158+  BAD4 C2 EF BA         jp nz,rocks_fall4   ; if not, carry on
159+  BAD7 CD A1 A7         call screen_getattraddressfromscreencoords ; get the attr address into de
160+  BADA 62 6B            ld hl,de
161+  BADC 36 42            ld (hl),66          ; load this square with the yellow colour
162+  BADE DD 4E 00 DD      ld bc,(ix)
162+  BAE2 46 01
163+  BAE4 79               ld a,c              ; get vertical
164+  BAE5 D6 08            sub 8               ; look up one square
165+  BAE7 4F               ld c,a              ; put a back in c
166+  BAE8 CD A1 A7         call screen_getattraddressfromscreencoords ; get the attr address into de
167+  BAEB 62 6B            ld hl,de
168+  BAED 36 46            ld (hl),70          ; load this square with the yellow colour
169+  BAEF              rocks_fall4:
170+  BAEF 08               ex af,af'
171+  BAF0 3D               dec a
172+  BAF1 FE 00            cp 0
173+  BAF3 C2 B7 BA         jp nz,rocks_fall1   ; do another pixel if needed
174+  BAF6              rocks_fall2:
175+  BAF6 3E 09            ld a,9              ; rock graphic
176+  BAF8 ED 4B 22 BA      ld bc,(rocks_tmp2)  ; get the original coords
177+  BAFC CD F8 A7         call screen_getblock     ; get the memory into hl
178+  BAFF CD 1A A8         call sprites_drawsprite  ; draw the sprite - over the top of the current one
179+  BB02 3E 09            ld a,9
180+  BB04 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
180+  BB08 46 01
181+  BB0A CD F8 A7         call screen_getblock     ; get the memory into hl
182+  BB0D CD 1A A8         call sprites_drawsprite  ; draw the sprite - over the top of the current one
183+  BB10 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
183+  BB14 46 01
184+  BB16 CD 33 BB         call rocks_checkforplayer ; check to see if we hit a player
185+  BB19 DD 23            inc ix
186+  BB1B DD 23            inc ix                  ; get ix back to state
187+  BB1D C9               ret
188+  BB1E              rocks_fall3:
189+  BB1E 3E 00            ld a,0              ; set the state to fell
190+  BB20 DD 77 02         ld (ix+2),a           ; store the falling state
191+  BB23 DD 4E 00 DD      ld bc,(ix)          ; get the coords
191+  BB27 46 01
192+  BB29 CD A1 A7         call screen_getattraddressfromscreencoords ; get the attr address into de
193+  BB2C 62 6B            ld hl,de
194+  BB2E 36 42            ld (hl),66
195+  BB30 C3 F6 BA         jp rocks_fall2      ; rejoin main loop
196+  BB33
197+  BB33              ;
198+  BB33              ; Checks to see if the rock is hitting a player
199+  BB33              ; Inputs:
200+  BB33              ; bc - coords of rock we're checking
201+  BB33              rocks_checkforplayer:
202+  BB33 ED 5B D3 B6      ld de,(player)       ; get the player coords
203+  BB37 7B               ld a,e               ; get the vert coord first
204+  BB38 91               sub c                ; subtract the rock vertical coord from players
205+  BB39 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
206+  BB3B C0               ret nz               ; if not, hasn't hit
207+  BB3C 7A               ld a,d               ; get the player horiz coord
208+  BB3D 90               sub b                ; subtract rock coord
209+  BB3E C6 07            add 7                ; add max distance
210+  BB40 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
211+  BB42 DA 46 BB         jp c,rocks_checkforplayer0
212+  BB45 C9               ret
213+  BB46              rocks_checkforplayer0:
214+  BB46 ED 43 24 BA      ld (rocks_killerrock),bc; store the coords of the killer rock
215+  BB4A CD 94 B7         call player_crushplayer ; if so, jump out
216+  BB4D C9               ret
217+  BB4E
218+  BB4E              ;
219+  BB4E              ; Wobbles a rocks
220+  BB4E              ; Inputs:
221+  BB4E              ; bc - coord of current rock graphic on screen
222+  BB4E              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
223+  BB4E              ; a - wobble frame
224+  BB4E              rocks_wobble:
225+  BB4E 3A 21 BA         ld a,(rocks_tmp)    ; get the frame toggle
226+  BB51 1E 09            ld e,9              ; this is the rock frame
227+  BB53 83               add a,e             ; add the frame toggle
228+  BB54 C5               push bc
229+  BB55 CD F8 A7         call screen_getblock     ; get the memory into hl
230+  BB58 CD 1A A8         call sprites_drawsprite  ; draw the sprite - over the top of the current one
231+  BB5B 3A 21 BA         ld a,(rocks_tmp)    ; get the frame toggle against
232+  BB5E EE 01            xor 1               ; flip to other state
233+  BB60 32 21 BA         ld (rocks_tmp),a    ; store
234+  BB63 1E 09            ld e,9              ; this is the rock frame
235+  BB65 83               add a,e             ; add the frame toggle
236+  BB66 CD F8 A7         call screen_getblock     ; get the memory into hl
237+  BB69 C1               pop bc
238+  BB6A CD 1A A8         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
239+  BB6D DD 7E 00         ld a,(ix)           ; get the wobble count back
240+  BB70 3D               dec a               ; decrease
241+  BB71 DD 77 00         ld (ix),a           ; store
242+  BB74 FE 00            cp 0
243+  BB76 C0               ret nz              ; if we're not at zero, return
244+  BB77 DD 2B            dec ix              ; otherwise look to state location
245+  BB79 3E 01            ld a,1              ; set the state to falling
246+  BB7B DD 77 00         ld (ix),a           ; store the falling state
247+  BB7E DD 23            inc ix              ; set ix back to location of wobble count, and we're done
248+  BB80 C9               ret
249+  BB81
# file closed: game/rocks.asm
 40   BB81                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  BB81              ;
  2+  BB81              ; The score of the current player
  3+  BB81              ;
  4+  BB81              scores_current:
  5+  BB81 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  BB85 30 30 30 30
  5+  BB89 FF
  6+  BB8A
  7+  BB8A              scores_defaultname:
  8+  BB8A 2D 2D 2D         defb '---'
  9+  BB8D
 10+  BB8D              ;
 11+  BB8D              ; The current high score table
 12+  BB8D              ;
 13+  BB8D              scores_table:
 14+  BB8D 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  BB91 4D 30 30 30
 14+  BB95 30 30 30 FF
 15+  BB99 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  BB9D 4D 30 30 30
 15+  BBA1 30 30 30 FF
 16+  BBA5 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  BBA9 4D 30 30 30
 16+  BBAD 30 30 30 FF
 17+  BBB1
 18+  BBB1              ;
 19+  BBB1              ; Add thousands to the score
 20+  BBB1              ; Inputs:
 21+  BBB1              ; b - number to add
 22+  BBB1              ;
 23+  BBB1              scores_addthousands:
 24+  BBB1 21 85 BB         ld hl,scores_current+4
 25+  BBB4 CD DE BB         call scores_update
 26+  BBB7 C9               ret
 27+  BBB8
 28+  BBB8              ;
 29+  BBB8              ; Prints the score to screen
 30+  BBB8              ;
 31+  BBB8              scores_printscore:
 32+  BBB8 3A A5 B6         ld a,(game_currentplayer)   ; get current player
 33+  BBBB 21 81 BB         ld hl,scores_current
 34+  BBBE FE 01            cp 1
 35+  BBC0 C2 C8 BB         jp nz, score_printscore0    ; if not player 1
 36+  BBC3 36 04            ld (hl),4       ; set position for player 1
 37+  BBC5 C3 CA BB         jp score_printscore1
 38+  BBC8              score_printscore0:
 39+  BBC8 36 16            ld (hl),22       ; set position for player 2
 40+  BBCA              score_printscore1:
 41+  BBCA 21 81 BB         ld hl,scores_current
 42+  BBCD CD 29 84         call string_print
 43+  BBD0 C9               ret
 44+  BBD1
 45+  BBD1              ;
 46+  BBD1              ; Prints both scores to screen
 47+  BBD1              ;
 48+  BBD1              scores_printscores:
 49+  BBD1 21 7C B7         ld hl,player1_score
 50+  BBD4 CD 29 84         call string_print
 51+  BBD7 21 85 B7         ld hl,player2_score
 52+  BBDA CD 29 84         call string_print
 53+  BBDD C9               ret
 54+  BBDE
 55+  BBDE              ;
 56+  BBDE              ; Updates the current score.
 57+  BBDE              ; Inputs:
 58+  BBDE              ; hl - memory location of the score column
 59+  BBDE              ; b - number to add
 60+  BBDE              ;
 61+  BBDE              scores_update:
 62+  BBDE 7E               ld a,(hl)           ; current value of digit.
 63+  BBDF 80               add a,b             ; add points to this digit.
 64+  BBE0 77               ld (hl),a           ; place new digit back in string.
 65+  BBE1 FE 3A            cp 58               ; more than ASCII value '9'?
 66+  BBE3 D8               ret c               ; no - relax.
 67+  BBE4 D6 0A            sub 10              ; subtract 10.
 68+  BBE6 77               ld (hl),a           ; put new character back in string.
 69+  BBE7              scores_update0:
 70+  BBE7 2B               dec hl              ; previous character in string.
 71+  BBE8 34               inc (hl)            ; up this by one.
 72+  BBE9 7E               ld a,(hl)           ; what's the new value?
 73+  BBEA FE 3A            cp 58               ; gone past ASCII nine?
 74+  BBEC D8               ret c               ; no, scoring done.
 75+  BBED D6 0A            sub 10              ; down by ten.
 76+  BBEF 77               ld (hl),a           ; put it back
 77+  BBF0 C3 E7 BB         jp scores_update0   ; go round again.
 78+  BBF3
 79+  BBF3
 80+  BBF3              ;
 81+  BBF3              ; Displays the high score table at the bottom of the screen
 82+  BBF3              ;
 83+  BBF3              scores_showtable:
 84+  BBF3 21 8D BB         ld hl, scores_table
 85+  BBF6 CD 29 84         call string_print
 86+  BBF9 21 99 BB         ld hl, scores_table+12
 87+  BBFC CD 29 84         call string_print
 88+  BBFF 21 A5 BB         ld hl, scores_table+24
 89+  BC02 CD 29 84         call string_print
 90+  BC05 C9               ret
 91+  BC06
 92+  BC06              ;
 93+  BC06              ; Place to store the current position we're checking
 94+  BC06              ;
 95+  BC06              scores_highscoretmp:
 96+  BC06 00               defb 0
 97+  BC07
 98+  BC07              ;
 99+  BC07              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
100+  BC07              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
101+  BC07              ;
102+  BC07              scores_processhighscores:
103+  BC07 21 06 BC         ld hl,scores_highscoretmp
104+  BC0A 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
105+  BC0C 3E 1D            ld a,29
106+  BC0E              scores_processhighscores3:
107+  BC0E 21 8D BB         ld hl,scores_table          ; position of first score column
108+  BC11 5F               ld e,a
109+  BC12 16 00            ld d,0
110+  BC14 19               add hl,de
111+  BC15 08               ex af,af'                   ; store a for later
112+  BC16 11 83 BB         ld de,scores_current+2      ; position of current score column
113+  BC19 06 06            ld b,6                      ; times to loop
114+  BC1B              scores_processhighscores0:
115+  BC1B 7E               ld a,(hl)
116+  BC1C 4F               ld c,a                      ; get first score column
117+  BC1D 1A               ld a,(de)                   ; get first current column
118+  BC1E B9               cp c                        ; compare current with first
119+  BC1F DA 30 BC         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
120+  BC22 23               inc hl
121+  BC23 13               inc de                      ; move to next column
122+  BC24 10 F5            djnz scores_processhighscores0 ; loop
123+  BC26 08               ex af,af'                     ; still here, so must be bigger
124+  BC27 32 06 BC         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
125+  BC2A 0E 0C            ld c,12
126+  BC2C 91               sub c
127+  BC2D D2 0E BC         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
128+  BC30              scores_processhighscores4
129+  BC30 CD 34 BC         call scores_updatehighscores
130+  BC33 C9               ret
131+  BC34
132+  BC34              ;
133+  BC34              ; Update score table
134+  BC34              ;
135+  BC34              scores_updatehighscores:
136+  BC34 3A 06 BC         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
137+  BC37 FE 00            cp 0
138+  BC39 C8               ret z                       ; if this is 0, didn't get a high score
139+  BC3A FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
140+  BC3C CA 6F BC         jp z, scores_updatehighscores3
141+  BC3F                                              ; copy old score over one below, if not first
142+  BC3F 21 8D BB         ld hl,scores_table
143+  BC42 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
144+  BC45 19               add hl,de                   ; position of first column
145+  BC46 2B               dec hl
146+  BC47 2B               dec hl
147+  BC48 2B               dec hl
148+  BC49 E5               push hl
149+  BC4A 11 0C 00         ld de,12
150+  BC4D 19               add hl,de                   ; get position of next score
151+  BC4E 54 5D            ld de,hl
152+  BC50 E1               pop hl                      ; get hl back
153+  BC51 01 09 00         ld bc,9
154+  BC54 ED B0            ldir
155+  BC56 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
156+  BC58 CA 6F BC         jp z,scores_updatehighscores3
157+  BC5B 21 8D BB         ld hl,scores_table
158+  BC5E 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
159+  BC61 19               add hl,de                   ; position of first column
160+  BC62 E5               push hl
161+  BC63 11 0C 00         ld de,12
162+  BC66 19               add hl,de                   ; get position of next score
163+  BC67 54 5D            ld de,hl
164+  BC69 E1               pop hl                      ; get hl back
165+  BC6A 01 09 00         ld bc,9
166+  BC6D ED B0            ldir
167+  BC6F              scores_updatehighscores3:
168+  BC6F 06 06            ld b,6                      ; now overwrite
169+  BC71 21 8D BB         ld hl,scores_table
170+  BC74 16 00            ld d,0
171+  BC76 5F               ld e,a
172+  BC77 19               add hl,de                   ; position of first column
173+  BC78 08               ex af,af'
174+  BC79 11 83 BB         ld de,scores_current+2      ; position of current score column
175+  BC7C              scores_updatehighscores2:
176+  BC7C 1A               ld a,(de)
177+  BC7D 77               ld (hl),a
178+  BC7E 23               inc hl
179+  BC7F 13               inc de
180+  BC80 10 FA            djnz scores_updatehighscores2
181+  BC82 11 09 00         ld de,9
182+  BC85 ED 52            sbc hl,de
183+  BC87 54 5D            ld de,hl                    ; get back to start of entry
184+  BC89 21 8A BB         ld hl,scores_defaultname    ; still need to overwrite the name
185+  BC8C 01 03 00         ld bc,3                      ; 3 chars to copy
186+  BC8F ED B0            ldir
187+  BC91 C9               ret
# file closed: game/scores.asm
 41   BC92                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  BC92              diamonds_tmp:
  2+  BC92 00               defb 0
  3+  BC93
  4+  BC93              ;
  5+  BC93              ; Holds the number of thousands for the current gem type
  6+  BC93              ;
  7+  BC93              diamonds_score:
  8+  BC93 00               defb 0
  9+  BC94
 10+  BC94              ;
 11+  BC94              ; Changes the attribute of gem and diamond cells based on the frame count
 12+  BC94              ; Inputs:
 13+  BC94              ; hl - memory location of gem type
 14+  BC94              diamonds_twinkle_type:
 15+  BC94 CD C9 B6         call game_getcurrentframe       ; get current frame number
 16+  BC97 E6 07            and 7                           ; want a number from 0-7
 17+  BC99 C6 40            add 64                          ; add to 60 to get attr colour
 18+  BC9B              diamonds_twinkle_type0:
 19+  BC9B 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 20+  BC9F 08               ex af, af'
 21+  BCA0 79               ld a,c                          ; load c into a
 22+  BCA1 FE FF            cp 255                          ; is this the end?
 23+  BCA3 CA C0 BC         jp z,diamonds_twinkle_type1           ; step out if so
 24+  BCA6 23               inc hl
 25+  BCA7 23               inc hl
 26+  BCA8 7E               ld a,(hl)                       ; check the state, don't process if collected
 27+  BCA9 FE 01            cp 1
 28+  BCAB CA C1 BC         jp z,diamonds_twinkle_type2           ; step out if so
 29+  BCAE CD F0 BC         call diamonds_checkforplayer    ; check to see if we've collided with player
 30+  BCB1 DC C8 BC         call c,diamonds_collect     ; we collided
 31+  BCB4 23               inc hl
 32+  BCB5 08               ex af,af'
 33+  BCB6 5E 23 56 2B      ld de,(hl)                      ; get the memory location into de
 34+  BCBA 12               ld (de),a                       ; set the value of attr
 35+  BCBB 23               inc hl
 36+  BCBC 23               inc hl                          ; move to next diamond
 37+  BCBD C3 9B BC         jp diamonds_twinkle_type0
 38+  BCC0              diamonds_twinkle_type1:
 39+  BCC0 C9               ret
 40+  BCC1              diamonds_twinkle_type2:
 41+  BCC1 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 42+  BCC2 23               inc hl
 43+  BCC3 23               inc hl
 44+  BCC4 08               ex af,af'
 45+  BCC5 C3 9B BC         jp diamonds_twinkle_type0       ; rejoin main loop
 46+  BCC8
 47+  BCC8              ;
 48+  BCC8              ; Collect the diamond we collided with
 49+  BCC8              ; Inputs:
 50+  BCC8              ; hl - memory location of current diamond, currently on state
 51+  BCC8              ; Output:
 52+  BCC8              ; a - 70 - for yellow on black
 53+  BCC8              diamonds_collect:
 54+  BCC8 36 01            ld (hl),1                       ; collected
 55+  BCCA E5               push hl
 56+  BCCB 2B               dec hl
 57+  BCCC 2B               dec hl
 58+  BCCD 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 59+  BCD1 CD C4 A7         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 60+  BCD4 ED 5B 92 BC      ld de,(diamonds_tmp)
 61+  BCD8 16 00            ld d,0
 62+  BCDA 21 C1 B0         ld hl,sprites
 63+  BCDD 19               add hl,de
 64+  BCDE CD 1A A8         call sprites_drawsprite     ; call the routine to draw the sprite
 65+  BCE1                  ;call screen_showchar
 66+  BCE1 E1               pop hl
 67+  BCE2 08               ex af,af'
 68+  BCE3 3E 46            ld a,70
 69+  BCE5 08               ex af,af'                       ; make sure a is in the af we'll use for the attr
 70+  BCE6 D9               exx
 71+  BCE7 3A 93 BC         ld a,(diamonds_score)
 72+  BCEA 47               ld b,a
 73+  BCEB CD B1 BB         call scores_addthousands
 74+  BCEE D9               exx
 75+  BCEF C9               ret
 76+  BCF0
 77+  BCF0              ;
 78+  BCF0              ; Checks to see if the gem is hitting a player
 79+  BCF0              ; Inputs:
 80+  BCF0              ; bc - coords of diamond we're checking
 81+  BCF0              diamonds_checkforplayer:
 82+  BCF0 78               ld a,b               ; multiply b by 8
 83+  BCF1 07               rlca
 84+  BCF2 07               rlca
 85+  BCF3 07               rlca
 86+  BCF4 47               ld b,a
 87+  BCF5 ED 5B D3 B6      ld de,(player)       ; get the player coords
 88+  BCF9 7B               ld a,e               ; get the vert coord first
 89+  BCFA 90               sub b                ; subtract the diamond vertical coord from players
 90+  BCFB C6 04            add 4                ; add the max distance
 91+  BCFD FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
 92+  BCFF D0               ret nc               ; if not, hasn't hit
 93+  BD00 79               ld a,c               ; multiply c by 8
 94+  BD01 07               rlca
 95+  BD02 07               rlca
 96+  BD03 07               rlca
 97+  BD04 4F               ld c,a
 98+  BD05 7A               ld a,d               ; get the player horiz coord
 99+  BD06 91               sub c                ; subtract rock coord
100+  BD07 C6 04            add 4                ; add max distance
101+  BD09 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
102+  BD0B D0               ret nc
103+  BD0C 3E 00            ld a,0
104+  BD0E C9               ret
105+  BD0F
106+  BD0F
107+  BD0F              ;
108+  BD0F              ; Initialise diamonds and gems
109+  BD0F              ;
110+  BD0F              diamonds_twinkle
111+  BD0F 21 93 BC         ld hl,diamonds_score
112+  BD12 36 02            ld (hl),2         ; store the score we'll add
113+  BD14 21 92 BC         ld hl,diamonds_tmp
114+  BD17 36 40            ld (hl),64         ; store the location the diamond sprite
115+  BD19 21 3C B0         ld hl, level01diamonds
116+  BD1C CD 94 BC         call diamonds_twinkle_type
117+  BD1F 21 93 BC         ld hl,diamonds_score
118+  BD22 36 01            ld (hl),1         ; store the score we'll add
119+  BD24 21 92 BC         ld hl,diamonds_tmp
120+  BD27 36 70            ld (hl),112         ; store the location the gem sprite
121+  BD29 21 4C B0         ld hl, level01gems
122+  BD2C CD 94 BC         call diamonds_twinkle_type
123+  BD2F C9               ret
124+  BD30
125+  BD30              ;
126+  BD30              ; Initialise diamonds and gems
127+  BD30              ;
128+  BD30              diamonds_init:
129+  BD30 21 3C B0         ld hl, level01diamonds
130+  BD33 CD 3D BD         call diamonds_init_type
131+  BD36 21 4C B0         ld hl, level01gems
132+  BD39 CD 3D BD         call diamonds_init_type
133+  BD3C C9               ret
134+  BD3D
135+  BD3D              ;
136+  BD3D              ; Initialise diamonds or gems, get memory addresses
137+  BD3D              ; Inputs:
138+  BD3D              ; hl - memory location
139+  BD3D              diamonds_init_type:
140+  BD3D 4E               ld c,(hl)                      ; get coords into c
141+  BD3E 79               ld a,c                          ; load c into add
142+  BD3F FE FF            cp 255                          ; is this the end?
143+  BD41 CA 58 BD         jp z,diamonds_init_type1             ; step out if so
144+  BD44 23               inc hl
145+  BD45 46               ld b,(hl)                       ; get coords into b
146+  BD46 E5               push hl
147+  BD47 CD 71 A7         call screen_getcellattradress ; get memory of attr for this diamond into de
148+  BD4A E1               pop hl
149+  BD4B 23               inc hl                          ; move to state
150+  BD4C 36 00            ld (hl),0
151+  BD4E 23               inc hl                          ; move to memory
152+  BD4F 73 23 72 2B      ld (hl),de                      ; store the memory location
153+  BD53 23               inc hl                          ; move to next diamond
154+  BD54 23               inc hl
155+  BD55 C3 3D BD         jp diamonds_init_type
156+  BD58              diamonds_init_type1:
157+  BD58 C9               ret
# file closed: game/diamonds.asm
 42   BD59
 43   BD59              ;===========================================================================
 44   BD59              ; main routine - the code execution starts here.
 45   BD59              ; Sets up the new interrupt routine, the memory
 46   BD59              ; banks and jumps to the start loop.
 47   BD59              ;===========================================================================
 48   BD59              main:
 49   BD59
 50   BD59                  ; Draw the title screen
 51   BD59              main_titlescreen:
 52   BD59 CD 83 A8         call titlescreen_show
 53   BD5C CD E0 B6         call player_init_gamestart
 54   BD5F
 55   BD5F              main_lifestart:
 56   BD5F
 57   BD5F CD FE B6         call player_init_lifestart
 58   BD62
 59   BD62 CD E7 A9         call lifescreen_draw        ; show the lives remaining screen
 60   BD65
 61   BD65 CD 00 80         call init_start
 62   BD68 CD 91 A6         call screen_draw
 63   BD6B CD EF A5         call buffer_allbuffertoscreen
 64   BD6E
 65   BD6E CD 74 B8         call ship_land              ; land the ship
 66   BD71 CD 64 B9         call tank_init
 67   BD74 CD 30 BD         call diamonds_init
 68   BD77
 69   BD77
 70   BD77              mloop:
 71   BD77 76               halt
 72   BD78 CD 93 BD         call main_loop_processing
 73   BD7B
 74   BD7B 21 DD B6         ld hl,player+10
 75   BD7E 7E               ld a,(hl)                   ; check if the player died this frame
 76   BD7F FE 01            cp 1
 77   BD81 C2 77 BD         jp nz,mloop
 78   BD84 CD 70 B7         call player_died        ; do end of life housekeeping
 79   BD87 21 DC B6         ld hl,player+9        ; check lives remaining
 80   BD8A 7E               ld a,(hl)
 81   BD8B FE 00            cp 0
 82   BD8D CA B2 BD         jp z,main_gameover   ; leave the loop if we're done
 83   BD90 C3 5F BD         jp main_lifestart
 84   BD93
 85   BD93              main_loop_processing:
 86   BD93 CD BD A5         call buffer_buffertoscreen  ; copy buffer to screen
 87   BD96 CD 3D A5         call buffer_clearlist       ; zero the updated lines list
 88   BD99 CD 9A B7         call player_drawplayer      ; delete player
 89   BD9C CD 50 B2         call control_keyboard       ; check keyboard
 90   BD9F CD 9A B7         call player_drawplayer      ; draw player
 91   BDA2 CD 77 B9         call tank_process           ; prcoess the tank
 92   BDA5 CD 56 BA         call rocks_processrocks     ; process falling rocks
 93   BDA8 CD 0F BD         call diamonds_twinkle       ; make the diamonds twinkle
 94   BDAB CD B8 BB         call scores_printscore      ; update the score on screen
 95   BDAE CD BA B6         call game_incrementframe    ; increment the game frame
 96   BDB1
 97   BDB1 C9               ret
 98   BDB2
 99   BDB2              main_gameover:
100   BDB2 CD 3A AA         call gameover_draw          ; show the game over screen
101   BDB5 C3 59 BD         jp main_titlescreen         ; go back to title
102   BDB8
103   BDB8              ;===========================================================================
104   BDB8              ; Stack.
105   BDB8              ;===========================================================================
106   BDB8
107   BDB8              ; Stack: this area is reserved for the stack
108   BDB8              STACK_SIZE: equ 100    ; in words
109   BDB8
110   BDB8              ; Reserve stack space
111   BDB8 00 00            defw 0  ; WPMEM, 2
112   BDBA              stack_bottom:
113   BDBA 00 00 00...      defs    STACK_SIZE*2, 0
114   BE82              stack_top:
115   BE82 00 00            defw 0  ; WPMEM, 2
116   BE84
117   BE84                     SAVESNA "ThePit.sna", main
# file closed: main.asm
