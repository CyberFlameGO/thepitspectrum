# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 67 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 11 A7         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 12 A7         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 AC A5         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD 45 BA         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8051 C9               ret                 ; key was pressed.
 53+  8052
 54+  8052              ;
 55+  8052              ; Waits number of frames for keypress. If got, returns 1, if not 0
 56+  8052              ; Inputs:
 57+  8052              ; a - number of frames to waits
 58+  8052              ; Ouputs:
 59+  8052              ; e - 0 not pressed, 1 pressed
 60+  8052              utilities_waitforkey_forframes:
 61+  8052 21 08 5C         ld hl,23560         ; LAST K system variable.
 62+  8055 36 00            ld (hl),0           ; put null value there.
 63+  8057 47               ld b,a              ; number of frames to wait
 64+  8058              utilities_waitforkey_forframes0:
 65+  8058 7E               ld a,(hl)           ; new value of LAST K.
 66+  8059 FE 00            cp 0                ; is it still zero?
 67+  805B 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 68+  805D 1E 01            ld e,1              ; set the pressed flag
 69+  805F C9               ret                 ; key was pressed.
 70+  8060              utilities_waitforkey_forframes1:
 71+  8060 76               halt                ; wait for frame
 72+  8061 76               halt                ; wait for frame
 73+  8062 10 F4            djnz utilities_waitforkey_forframes0 ; loop again
 74+  8064 1E 00            ld e,0              ; nothing pressed in time
 75+  8066 C9               ret
 76+  8067
 77+  8067              ;
 78+  8067              ; Clears the screen
 79+  8067              ; Inputs:
 80+  8067              ; a - attribute colour
 81+  8067              utilities_clearscreen:
 82+  8067 76               halt
 83+  8068 21 00 58         ld hl,22528         ; attr
 84+  806B 11 01 58         ld de,22529         ; attr+1
 85+  806E 01 FF 02         ld bc,767
 86+  8071 77               ld (hl),a
 87+  8072 ED B0            ldir
 88+  8074
 89+  8074 21 00 40         ld hl, 16384        ;pixels
 90+  8077 11 01 40         ld de, 16385        ;pixels + 1
 91+  807A 01 FF 17         ld bc, 6143         ;pixels area length - 1
 92+  807D 36 00            ld (hl), 0          ;set first byte to '0'
 93+  807F ED B0            ldir                ;copy bytes
 94+  8081
 95+  8081 C9               ret
 96+  8082
 97+  8082              ;
 98+  8082              ; Wait for a number of frames
 99+  8082              ; Inputs:
100+  8082              ; b - number of frames
101+  8082              utilities_pauseforframes:
102+  8082 76               halt
103+  8083 10 FD            djnz utilities_pauseforframes
104+  8085 C9               ret
105+  8086
106+  8086              utilities_readkey:
107+  8086 21 A6 80         LD HL,utilties_keymap              ; Point HL at the keyboard list
108+  8089 16 08            LD D,8                                  ; This is the number of ports (rows) to check
109+  808B 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
110+  808D              utilities_readkey_0:
111+  808D 46               LD B,(HL)                               ; Get the keyboard port address from table
112+  808E 23               INC HL                                  ; Increment to list of keys
113+  808F ED 78            IN A,(C)                                ; Read the row of keys in
114+  8091 E6 1F            AND $1F                                     ; We are only interested in the first five bits
115+  8093 1E 05            LD E,5                                  ; This is the number of keys in the row
116+  8095              utilities_readkey_1:
117+  8095 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
118+  8097 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
119+  8099 23               INC HL                                  ; Go to next table address
120+  809A 1D               DEC E                                   ; Decrement key loop counter
121+  809B 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
122+  809D 15               DEC D                                   ; Decrement row loop counter
123+  809E 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
124+  80A0 A7               AND A                                   ; Clear A (no key found)
125+  80A1 C3 86 80         jp utilities_readkey
126+  80A4              utilities_readkey_2:
127+  80A4 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
128+  80A5 C9               RET
129+  80A6
130+  80A6              utilties_keymap:
131+  80A6 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
131+  80AA 43 56
132+  80AC FD 41 53 44      defb $FD,"A","S","D","F","G"
132+  80B0 46 47
133+  80B2 FB 51 57 45      defb $FB,"Q","W","E","R","T"
133+  80B6 52 54
134+  80B8 F7 31 32 33      defb $F7,"1","2","3","4","5"
134+  80BC 34 35
135+  80BE EF 30 39 38      defb $EF,"0","9","8","7","6"
135+  80C2 37 36
136+  80C4 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
136+  80C8 55 59
137+  80CA BF 23 4C 4B      defb $BF,"#","L","K","J","H"
137+  80CE 4A 48
138+  80D0 7F 20 23 4D      defb $7F," ","#","M","N","B"
138+  80D4 4E 42
139+  80D6
140+  80D6
141+  80D6              ;
142+  80D6              ; Generates a randomish number in the range 0 to e
143+  80D6              ; Inputs:
144+  80D6              ; e - upper value
145+  80D6              ; Outputs:
146+  80D6              ; a - random number
147+  80D6              utilities_randomupper
148+  80D6 3A 1B BA         ld a,(game_framenumber)
149+  80D9 6F               ld l,a
150+  80DA 26 00            ld h,0
151+  80DC 16 00            ld d,0
152+  80DE 42 4B            ld bc,de
153+  80E0              utilities_randomupper0:
154+  80E0 B7               or a
155+  80E1 ED 42            sbc hl,bc
156+  80E3 F2 E0 80         jp p,utilities_randomupper0
157+  80E6 09               add hl,bc
158+  80E7 01 00 00         ld bc,0
159+  80EA 09               add hl,bc
160+  80EB 7D               ld a,l
161+  80EC C9               ret
# file closed: utilities.asm
 22   80ED                  include "strings.asm"
# file opened: strings.asm
  1+  80ED              string_score1:
  2+  80ED 04 00 53 43      defb 4,0,'SCORE1',255
  2+  80F1 4F 52 45 31
  2+  80F5 FF
  3+  80F6              string_scorenumbers1:
  4+  80F6 04 01 30 30      defb 4,1,'000000',255
  4+  80FA 30 30 30 30
  4+  80FE FF
  5+  80FF              string_company:
  6+  80FF 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  8103 4E 54 55 52
  6+  8107 49 FF
  7+  8109              string_credits:
  8+  8109 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  810D 41 59 45 52
  8+  8111 20 31 FF
  9+  8114              string_score2:
 10+  8114 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8118 4F 52 45 32
 10+  811C FF
 11+  811D              string_scorenumbers2:
 12+  811D 16 01 30 30      defb 22,1,'000000',255
 12+  8121 30 30 30 30
 12+  8125 FF
 13+  8126              string_titlescreen_copyright:
 14+  8126 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 14+  812A 39 38 32 20
 14+  812E 20 43 45 4E
 14+  8132 54 55 52 49
 14+  8136 20 49 4E 43
 14+  813A FF
 15+  813B
 16+  813B
 17+  813B              string_alttitlescreen_1:
 18+  813B 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  813F 45 44 49 54
 18+  8143 53 20 31 FF
 19+  8147              string_alttitlescreen_2:
 20+  8147 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  814B 20 20 20 20
 20+  814F 20 20 20 20
 20+  8153 20 54 48 45
 20+  8157 20 4F 42 4A
 20+  815B 45 43 54 FE
 21+  815F 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  8163 20 20 20 20
 21+  8167 20 20 20 20
 21+  816B 4F 46 20 54
 21+  816F 48 49 53 20
 21+  8173 47 41 4D 45
 21+  8177 FE
 22+  8178 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  817C 20 20 20 20
 22+  8180 20 20 20 49
 22+  8184 53 20 54 4F
 22+  8188 20 44 49 47
 22+  818C 20 44 4F 57
 22+  8190 4E FE
 23+  8192 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  8196 20 20 20 20
 23+  819A 20 20 54 4F
 23+  819E 20 54 48 45
 23+  81A2 20 42 4F 54
 23+  81A6 54 4F 4D 20
 23+  81AA 50 49 54 FE
 24+  81AE 00 06 20 20      defb 0,6,'               AND',254
 24+  81B2 20 20 20 20
 24+  81B6 20 20 20 20
 24+  81BA 20 20 20 20
 24+  81BE 20 41 4E 44
 24+  81C2 FE
 25+  81C3 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  81C7 20 20 20 20
 25+  81CB 20 20 43 4F
 25+  81CF 4C 4C 45 43
 25+  81D3 54 20 41 54
 25+  81D7 20 4C 45 41
 25+  81DB 53 54 FE
 26+  81DE 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  81E2 20 20 20 20
 26+  81E6 20 20 20 4F
 26+  81EA 4E 45 20 4C
 26+  81EE 41 52 47 45
 26+  81F2 20 4A 45 57
 26+  81F6 45 4C FE
 27+  81F9 00 09 20 20      defb 0,9,'              THEN',254
 27+  81FD 20 20 20 20
 27+  8201 20 20 20 20
 27+  8205 20 20 20 20
 27+  8209 54 48 45 4E
 27+  820D FE
 28+  820E 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  8212 20 20 20 20
 28+  8216 20 20 20 52
 28+  821A 45 54 55 52
 28+  821E 4E 20 54 4F
 28+  8222 20 53 48 49
 28+  8226 50 FE
 29+  8228 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  822C 20 20 20 20
 29+  8230 20 20 20 54
 29+  8234 48 52 55 20
 29+  8238 55 50 50 45
 29+  823C 52 20 50 49
 29+  8240 54 FF
 30+  8242              string_alttitlescreen_3:
 31+  8242 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  8246 20 20 53 49
 31+  824A 4E 47 4C 45
 31+  824E 20 42 4F 4E
 31+  8252 55 53 20 20
 31+  8256 35 30 30 30
 31+  825A 20 50 4F 49
 31+  825E 4E 54 53 FE
 32+  8262 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  8266 20 20 20 20
 32+  826A 43 4F 4C 4C
 32+  826E 45 43 54 20
 32+  8272 31 20 4C 41
 32+  8276 52 47 45 20
 32+  827A 4A 45 57 45
 32+  827E 4C FE
 33+  8280 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  8284 20 20 20 20
 33+  8288 20 41 4E 44
 33+  828C 20 52 45 54
 33+  8290 55 52 4E 20
 33+  8294 54 4F 20 53
 33+  8298 48 49 50 FE
 34+  829C 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  82A0 20 20 44 4F
 34+  82A4 55 42 4C 45
 34+  82A8 20 42 4F 4E
 34+  82AC 55 53 20 20
 34+  82B0 31 30 30 30
 34+  82B4 30 20 50 4F
 34+  82B8 49 4E 54 53
 34+  82BC FE
 35+  82BD 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  82C1 20 20 43 4F
 35+  82C5 4C 4C 45 43
 35+  82C9 54 20 41 4C
 35+  82CD 4C 20 33 20
 35+  82D1 4C 41 52 47
 35+  82D5 45 20 4A 45
 35+  82D9 57 45 4C 53
 35+  82DD FE
 36+  82DE 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  82E2 20 20 20 20
 36+  82E6 20 4F 52 20
 36+  82EA 20 20 41 4C
 36+  82EE 4C 20 34 20
 36+  82F2 53 4D 41 4C
 36+  82F6 4C 20 4A 45
 36+  82FA 57 45 4C 53
 36+  82FE FE
 37+  82FF 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  8303 20 20 54 52
 37+  8307 49 50 4C 45
 37+  830B 20 42 4F 4E
 37+  830F 55 53 20 20
 37+  8313 31 35 30 30
 37+  8317 30 20 50 4F
 37+  831B 49 4E 54 53
 37+  831F FE
 38+  8320 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  8324 20 20 20 20
 38+  8328 20 43 4F 4C
 38+  832C 4C 45 43 54
 38+  8330 20 41 4C 4C
 38+  8334 20 37 20 4A
 38+  8338 45 57 45 4C
 38+  833C 53 FF
 39+  833E
 40+  833E              string_lifescreen_player:
 41+  833E 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  8342 4C 41 59 45
 41+  8346 52 20 31 20
 41+  834A FF
 42+  834B              string_lifescreen_lives:
 43+  834B 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  834F 4D 45 4E 20
 43+  8353 4C 45 46 54
 43+  8357 FF
 44+  8358              string_lifescreen_lastman:
 45+  8358 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  835C 53 54 20 4D
 45+  8360 41 4E FF
 46+  8363
 47+  8363              string_gameoverscreen_gameover:
 48+  8363 0C 06 47 41      defb 12,6,'GAME OVER',255
 48+  8367 4D 45 20 4F
 48+  836B 56 45 52 FF
 49+  836F              string_gameoverscreen_copyright:
 50+  836F 05 12 7F 20      defb 5,18,127,' 1982 AW ZILEC ELC LTD',255
 50+  8373 31 39 38 32
 50+  8377 20 41 57 20
 50+  837B 5A 49 4C 45
 50+  837F 43 20 45 4C
 50+  8383 43 20 4C 54
 50+  8387 44 FF
 51+  8389              string_gameoverscreen_bestscores:
 52+  8389 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  838D 53 54 20 53
 52+  8391 43 4F 52 45
 52+  8395 53 20 54 4F
 52+  8399 44 41 59 FF
 53+  839D              string_gameover_credits:
 54+  839D 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  83A1 45 44 49 54
 54+  83A5 53 20 30 FF
 55+  83A9
 56+  83A9              string_highscore_congratulations:
 57+  83A9 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 57+  83AD 4E 47 52 41
 57+  83B1 54 55 4C 41
 57+  83B5 54 49 4F 4E
 57+  83B9 53 FF
 58+  83BB              string_highscore_player1:
 59+  83BB 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 59+  83BF 41 59 45 52
 59+  83C3 20 31 FF
 60+  83C6              string_highscore_player2:
 61+  83C6 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 61+  83CA 41 59 45 52
 61+  83CE 20 32 FF
 62+  83D1              string_highscore_youhaveearned:
 63+  83D1 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 63+  83D5 55 20 48 41
 63+  83D9 56 45 20 45
 63+  83DD 41 52 4E 45
 63+  83E1 44 FF
 64+  83E3              string_highscore_place1:
 65+  83E3 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 65+  83E7 45 20 47 52
 65+  83EB 45 41 54 45
 65+  83EF 53 54 20 53
 65+  83F3 43 4F 52 45
 65+  83F7 FF
 66+  83F8              string_highscore_place2:
 67+  83F8 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 67+  83FC 45 20 32 4E
 67+  8400 44 20 42 45
 67+  8404 53 54 20 53
 67+  8408 43 4F 52 45
 67+  840C FF
 68+  840D              string_highscore_place3:
 69+  840D 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 69+  8411 45 20 33 52
 69+  8415 44 20 42 45
 69+  8419 53 54 20 53
 69+  841D 43 4F 52 45
 69+  8421 FF
 70+  8422              string_highscore_pleaseenter
 71+  8422 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 71+  8426 43 4F 52 44
 71+  842A 20 59 4F 55
 71+  842E 52 20 49 4E
 71+  8432 49 54 49 41
 71+  8436 4C 53 20 42
 71+  843A 45 4C 4F 57
 71+  843E FF
 72+  843F
 73+  843F              string_endlevel_youhaveearned:
 74+  843F 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 74+  8443 55 20 48 41
 74+  8447 56 45 20 45
 74+  844B 41 52 4E 45
 74+  844F 44 FF
 75+  8451              string_endlevel_bonus1:
 76+  8451 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 76+  8455 4E 47 4C 45
 76+  8459 20 42 4F 4E
 76+  845D 55 53 FF
 77+  8460              string_endlevel_bonus2:
 78+  8460 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 78+  8464 55 42 4C 45
 78+  8468 20 42 4F 4E
 78+  846C 55 53 FF
 79+  846F              string_endlevel_bonus3:
 80+  846F 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 80+  8473 49 50 4C 45
 80+  8477 20 42 4F 4E
 80+  847B 55 53 FF
 81+  847E              string_endlevel_points1:
 82+  847E 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 82+  8482 30 30 20 50
 82+  8486 4F 49 4E 54
 82+  848A 53 FF
 83+  848C              string_endlevel_points2:
 84+  848C 09 0F 31 30      defb 9,15,'10000 POINTS',255
 84+  8490 30 30 30 20
 84+  8494 50 4F 49 4E
 84+  8498 54 53 FF
 85+  849B              string_endlevel_points3:
 86+  849B 09 0F 31 35      defb 9,15,'15000 POINTS',255
 86+  849F 30 30 30 20
 86+  84A3 50 4F 49 4E
 86+  84A7 54 53 FF
 87+  84AA              string_endlevel_anothergo:
 88+  84AA 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 88+  84AE 56 45 20 41
 88+  84B2 4E 4F 54 48
 88+  84B6 45 52 20 47
 88+  84BA 4F FF
 89+  84BC
 90+  84BC              string_zonk:
 91+  84BC 00 00 5A 4F      defb 0,0,'ZONK!',255
 91+  84C0 4E 4B 21 FF
 92+  84C4              ;
 93+  84C4              ; Prints specified string
 94+  84C4              ; Inputs:
 95+  84C4              ; de: pointer to string
 96+  84C4              ; bc: length of string
 97+  84C4              ;
 98+  84C4              ; Print String Data
 99+  84C4              ; First two bytes of string contain X and Y char position, then the string
100+  84C4              ; Individual strings are terminated with 0xFE
101+  84C4              ; End of data is terminated with 0xFF
102+  84C4              ; HL: Address of string
103+  84C4              ;
104+  84C4 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
105+  84C5 23                                   INC HL                          ; Increase HL to the next memory location
106+  84C6 56                                   LD D,(HL)                       ; Fetch the Y coordinate
107+  84C7 23                                   INC HL                          ; Increase HL to the next memory location
108+  84C8 CD DB 84                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
109+  84CB 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
110+  84CC 23                                   INC HL                          ; Increase HL to the next character
111+  84CD FE FE                                CP 0xFE                         ; Compare with 0xFE
112+  84CF 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
113+  84D1 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
114+  84D2 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
115+  84D3 CD EB 84                             CALL Print_Char                 ; Print the character
116+  84D6 E1                                   POP HL                          ; Retrieve HL back off the stack
117+  84D7 1C                                   INC E                           ; Go to the next screen address
118+  84D8 18 F1                                JR string_print_0               ; Loop back to print next character
119+  84DA C9                                   RET
120+  84DB
121+  84DB              ; Get screen address
122+  84DB              ; D = Y character position
123+  84DB              ; E = X character position
124+  84DB              ; Returns address in DE
125+  84DB              ;
126+  84DB 7A           string_getcharaddress:       LD A,D
127+  84DC E6 07                                AND %00000111
128+  84DE 1F                                   RRA
129+  84DF 1F                                   RRA
130+  84E0 1F                                   RRA
131+  84E1 1F                                   RRA
132+  84E2 B3                                   OR E
133+  84E3 5F                                   LD E,A
134+  84E4 7A                                   LD A,D
135+  84E5 E6 18                                AND %00011000
136+  84E7 F6 40                                OR %01000000
137+  84E9 57                                   LD D,A
138+  84EA C9                                   RET                             ; Returns screen address in DE
139+  84EB
140+  84EB              ; Print a single character out
141+  84EB              ; A:  Character to print
142+  84EB              ; DE: Screen address to print character at
143+  84EB              ;
144+  84EB 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
145+  84EE 06 00                                LD B,0                          ; Set BC to A
146+  84F0 4F                                   LD C,A
147+  84F1 E6 FF                                AND 0xFF                        ; Clear the carry bit
148+  84F3 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
149+  84F5 CB 10                                RL B
150+  84F7 CB 11                                RL C
151+  84F9 CB 10                                RL B
152+  84FB CB 11                                RL C
153+  84FD CB 10                                RL B
154+  84FF 09                                   ADD HL,BC                       ; Get the character address in HL
155+  8500 0E 08                                LD C,8                          ; Loop counter
156+  8502 D5                                   PUSH DE
157+  8503 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
158+  8504 12                                   LD (DE),A                       ; Stick A onto the screen
159+  8505 14                                   INC D                           ; Goto next line on screen
160+  8506 2C                                   INC L                           ; Goto next byte of character
161+  8507 0D                                   DEC C                           ; Decrease the loop counter
162+  8508 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
163+  850A D1                                   POP DE
164+  850B C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   850C                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  850C              buffer_buffer:
  2+  850C 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A20C
  4+  A20C              buffer_attr_buffer:
  5+  A20C 00 00 00...      defs 928                    ; attrs buffer area
  6+  A5AC
  7+  A5AC              buffer_tmp:
  8+  A5AC 00 00            defb 0,0                    ; temp area
  9+  A5AE
 10+  A5AE              buffer_updatedlines:
 11+  A5AE FF FF FF...      defs 21,255
 12+  A5C3
 13+  A5C3              buffer_updateall:
 14+  A5C3 00               defb 0
 15+  A5C4
 16+  A5C4              ;
 17+  A5C4              ; Stores a line number in the update list
 18+  A5C4              ; Inputs:
 19+  A5C4              ; a - row number
 20+  A5C4              buffer_marklineforupdate:
 21+  A5C4 FE 15            cp 21
 22+  A5C6 D0               ret nc                          ; dont store lines that we shouldn't draw
 23+  A5C7 5F               ld e,a                          ; store in e
 24+  A5C8 06 15            ld b,21
 25+  A5CA 21 AE A5         ld hl,buffer_updatedlines
 26+  A5CD              buffer_marklineforupdate0:
 27+  A5CD 7E               ld a,(hl)                       ; get the line stored in updated lines
 28+  A5CE BB               cp e                            ; is this the same as the row number passed in?
 29+  A5CF C8               ret z                           ; if so, don't need to do anything
 30+  A5D0 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 31+  A5D2 C2 D7 A5         jp nz,buffer_marklineforupdate1 ; if not, move to next
 32+  A5D5 73               ld (hl),e                       ; if it is, this spot is empty, so store the row number
 33+  A5D6 C9               ret                             ; and finish
 34+  A5D7              buffer_marklineforupdate1:
 35+  A5D7 23               inc hl
 36+  A5D8 10 F3            djnz buffer_marklineforupdate0
 37+  A5DA C9               ret
 38+  A5DB
 39+  A5DB              ;
 40+  A5DB              ; Zeroes the updated lines list
 41+  A5DB              ;
 42+  A5DB              buffer_clearlist:
 43+  A5DB 06 15            ld b,21
 44+  A5DD 21 AE A5         ld hl,buffer_updatedlines
 45+  A5E0              buffer_clearlist0:
 46+  A5E0 36 FF            ld (hl),255
 47+  A5E2 23               inc hl
 48+  A5E3 10 FB            djnz buffer_clearlist0
 49+  A5E5 C9               ret
 50+  A5E6
 51+  A5E6              ;
 52+  A5E6              ; Copies the buffer to the screen. Use stack.
 53+  A5E6              ; Inputs:
 54+  A5E6              ; a - row number to display - 0 is first line
 55+  A5E6              ;
 56+  A5E6              buffer_bufferlinetoscreen:
 57+  A5E6 4F               ld c,a                          ; store a
 58+  A5E7 ED 5B 11 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 59+  A5EB 83               add a,e                       ; add the row number
 60+  A5EC 11 00 01         ld de,256
 61+  A5EF CD 3A 80         call utilities_multiply
 62+  A5F2 54 5D            ld de,hl
 63+  A5F4 21 0C 85         ld hl,buffer_buffer
 64+  A5F7 19               add hl,de                   ; add the offset
 65+  A5F8 79               ld a,c                      ; get original row back
 66+  A5F9 ED 73 57 A6      ld (buffer_bufferlinetoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
 67+  A5FD D9               exx
 68+  A5FE 0E 00            ld c,0                      ; zero horizontal
 69+  A600 47               ld b,a                      ; load the row number into vertical coord
 70+  A601 04               inc b
 71+  A602 04               inc b                       ; move forward 2 to allow for scores
 72+  A603 CD FB A7         call screen_getcelladdress  ; get the memory into de
 73+  A606 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
 74+  A609 19               add hl,de
 75+  A60A              buffer_bufferlinetoscreen0:
 76+  A60A D9               exx                         ; hl is now buffer
 77+  A60B 23               inc hl
 78+  A60C 23               inc hl                      ; move hl forward 2 to skip first two blocks
 79+  A60D F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
 80+  A60E F1               pop af
 81+  A60F C1               pop bc
 82+  A610 D1               pop de
 83+  A611 DD E1            pop ix
 84+  A613 D9               exx                         ; hl is now screen
 85+  A614 08               ex af,af'
 86+  A615 F1               pop af
 87+  A616 C1               pop bc
 88+  A617 D1               pop de
 89+  A618 F9               ld sp,hl                    ; sp pointing at screen
 90+  A619 D5               push de
 91+  A61A C5               push bc
 92+  A61B F5               push af
 93+  A61C 08               ex af,af'
 94+  A61D D9               exx                         ; hl is now buffer
 95+  A61E DD E5            push ix
 96+  A620 D5               push de
 97+  A621 C5               push bc
 98+  A622 F5               push af
 99+  A623 1E 0E            ld e,14                    ; do another fourteen for right hand side
100+  A625 16 00            ld d,0
101+  A627 19               add hl,de
102+  A628 F9               ld sp,hl                    ; sp pointing at buffer
103+  A629 F1               pop af
104+  A62A C1               pop bc
105+  A62B D1               pop de
106+  A62C DD E1            pop ix
107+  A62E                  ;pop ix
108+  A62E D9               exx                         ; hl is now screen
109+  A62F 08               ex af,af'
110+  A630 1E 0E            ld e,14
111+  A632 16 00            ld d,0
112+  A634 19               add hl,de
113+  A635 F1               pop af
114+  A636 C1               pop bc
115+  A637 D1               pop de
116+  A638                  ;pop iy
117+  A638 F9               ld sp,hl                    ; sp pointing at screen
118+  A639                  ;push iy
119+  A639 D5               push de
120+  A63A C5               push bc
121+  A63B F5               push af
122+  A63C 08               ex af,af'
123+  A63D D9               exx                         ; hl is now buffer
124+  A63E DD E5            push ix
125+  A640 D5               push de
126+  A641 C5               push bc
127+  A642 F5               push af
128+  A643 1E 10            ld e,16
129+  A645 16 00            ld d,0
130+  A647 19               add hl,de
131+  A648 D9               exx                         ; hl is now screen
132+  A649 1E 0E            ld e,14
133+  A64B 16 00            ld d,0
134+  A64D ED 52            sbc hl,de
135+  A64F 24               inc h
136+  A650 7C               ld a,h
137+  A651 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
138+  A653 C2 0A A6         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
139+  A656              buffer_bufferlinetoscreen1:
140+  A656 31 00 00         ld sp,0
141+  A659 D9               exx
142+  A65A C9               ret
143+  A65B
144+  A65B              ;
145+  A65B              ; Copies the buffer to the screen for updated lines. Use stack.
146+  A65B              ; Inputs: none
147+  A65B              ;
148+  A65B              buffer_buffertoscreen:
149+  A65B 3A C3 A5         ld a,(buffer_updateall)      ; get the all update flag
150+  A65E FE 00            cp 0
151+  A660 CA 6C A6         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
152+  A663 CD 8A A6         call buffer_allbuffertoscreen ; otherwise, draw whole screen
153+  A666 21 C3 A5         ld hl,buffer_updateall
154+  A669 36 00            ld (hl),0                    ; reset flag
155+  A66B C9               ret
156+  A66C              buffer_buffertoscreen2:
157+  A66C 06 15            ld b,21
158+  A66E FD 21 AE A5      ld iy,buffer_updatedlines    ; the location of the updated lines
159+  A672              buffer_buffertoscreen0:
160+  A672 FD 7E 00         ld a,(iy)
161+  A675 FE FF            cp 255
162+  A677 CA 89 A6         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
163+  A67A C5               push bc
164+  A67B FD E5            push iy
165+  A67D F3               di
166+  A67E CD E6 A5         call buffer_bufferlinetoscreen
167+  A681 FB               ei
168+  A682 FD E1            pop iy
169+  A684 C1               pop bc
170+  A685 FD 23            inc iy
171+  A687 10 E9            djnz buffer_buffertoscreen0
172+  A689              buffer_buffertoscreen1:
173+  A689                  ;call buffer_buffertoattrsfast
174+  A689 C9               ret
175+  A68A
176+  A68A              ;
177+  A68A              ; Copies the buffer to the screen. Use stack.
178+  A68A              ; Inputs: none
179+  A68A              ;
180+  A68A              buffer_allbuffertoscreen:
181+  A68A 06 15            ld b,21
182+  A68C 3E 00            ld a,0
183+  A68E              buffer_allbuffertoscreen0:
184+  A68E C5               push bc
185+  A68F F5               push af
186+  A690 F3               di
187+  A691 CD E6 A5         call buffer_bufferlinetoscreen
188+  A694 FB               ei
189+  A695 F1               pop af
190+  A696 C1               pop bc
191+  A697 3C               inc a
192+  A698 10 F4            djnz buffer_allbuffertoscreen0
193+  A69A
194+  A69A CD 9E A6         call buffer_buffertoattrsfast
195+  A69D C9               ret
196+  A69E
197+  A69E              ;
198+  A69E              ; Copies the attrs buffer to screen with the stack
199+  A69E              ;
200+  A69E              buffer_buffertoattrsfast:
201+  A69E ED 73 0D A7      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
202+  A6A2 3A 11 A7         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
203+  A6A5 11 20 00         ld de,32
204+  A6A8 CD 3A 80         call utilities_multiply
205+  A6AB 54 5D            ld de,hl
206+  A6AD 21 0C A2         ld hl,buffer_attr_buffer
207+  A6B0 19               add hl,de                       ; add the offset, start of attr buffer now in hl
208+  A6B1 D9               exx
209+  A6B2 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
210+  A6B5 FD 21 AC A5      ld iy,buffer_tmp
211+  A6B9 FD 36 00 15      ld (iy),21              ; number of times to loop
212+  A6BD              buffer_buffertoattrsfast0:
213+  A6BD D9               exx                         ; hl is now buffer
214+  A6BE 23               inc hl
215+  A6BF 23               inc hl                      ; move hl forward 2 to skip first two blocks
216+  A6C0 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
217+  A6C1 F1               pop af
218+  A6C2 C1               pop bc
219+  A6C3 D1               pop de
220+  A6C4 DD E1            pop ix
221+  A6C6 D9               exx                         ; hl is now screen
222+  A6C7 08               ex af,af'
223+  A6C8 F1               pop af
224+  A6C9 C1               pop bc
225+  A6CA D1               pop de
226+  A6CB F9               ld sp,hl                    ; sp pointing at screen
227+  A6CC D5               push de
228+  A6CD C5               push bc
229+  A6CE F5               push af
230+  A6CF 08               ex af,af'
231+  A6D0 D9               exx                         ; hl is now buffer
232+  A6D1 DD E5            push ix
233+  A6D3 D5               push de
234+  A6D4 C5               push bc
235+  A6D5 F5               push af
236+  A6D6 1E 0E            ld e,14                    ; do another fourteen for right hand side
237+  A6D8 16 00            ld d,0
238+  A6DA 19               add hl,de
239+  A6DB F9               ld sp,hl                    ; sp pointing at buffer
240+  A6DC F1               pop af
241+  A6DD C1               pop bc
242+  A6DE D1               pop de
243+  A6DF DD E1            pop ix
244+  A6E1 D9               exx                         ; hl is now screen
245+  A6E2 08               ex af,af'
246+  A6E3 1E 0E            ld e,14
247+  A6E5 16 00            ld d,0
248+  A6E7 19               add hl,de
249+  A6E8 F1               pop af
250+  A6E9 C1               pop bc
251+  A6EA D1               pop de
252+  A6EB F9               ld sp,hl                    ; sp pointing at screen
253+  A6EC D5               push de
254+  A6ED C5               push bc
255+  A6EE F5               push af
256+  A6EF 08               ex af,af'
257+  A6F0 D9               exx                         ; hl is now buffer
258+  A6F1 DD E5            push ix
259+  A6F3 D5               push de
260+  A6F4 C5               push bc
261+  A6F5 F5               push af
262+  A6F6 1E 10            ld e,16
263+  A6F8 16 00            ld d,0
264+  A6FA 19               add hl,de
265+  A6FB D9               exx                         ; hl is now screen
266+  A6FC 11 12 00         ld de,18
267+  A6FF 19               add hl,de
268+  A700 FD 7E 00         ld a,(iy)
269+  A703 3D               dec a
270+  A704 FE 00            cp 0
271+  A706 FD 77 00         ld (iy),a
272+  A709 C2 BD A6         jp nz,buffer_buffertoattrsfast0 ; do another row
273+  A70C              buffer_buffertoattrsfast1:
274+  A70C 31 00 00         ld sp,0
275+  A70F D9               exx
276+  A710 C9               ret
# file closed: screen/buffer.asm
 24   A711                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A711              screen_offset:
  2+  A711 00               defb 0                      ; offset from top of screen in lines
  3+  A712
  4+  A712              screen_tmp:
  5+  A712 00 00            defb 0,0                      ; temporary memory
  6+  A714
  7+  A714              screen_setscorecolours:
  8+  A714 21 2D B3         ld hl,score_colours
  9+  A717 11 00 58         ld de,22528                     ; attrs here
 10+  A71A 01 40 00         ld bc,64
 11+  A71D ED B0            ldir
 12+  A71F C9               ret
 13+  A720
 14+  A720              screen_sethighscorecolours:
 15+  A720 21 6D B3         ld hl,high_score_colours
 16+  A723 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A726 01 20 00         ld bc,32
 18+  A729 ED B0            ldir
 19+  A72B C9               ret
 20+  A72C
 21+  A72C              ; Draw the screen
 22+  A72C              ; Inputs:
 23+  A72C              ; none
 24+  A72C              ; Notes:
 25+  A72C              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A72C              screen_draw:
 27+  A72C                  ;call clear_screen
 28+  A72C 0E 00            ld c,0                      ; horiz
 29+  A72E 06 00            ld b,0                      ; vert, 0 at top
 30+  A730 DD 21 EF AD      ld ix,level01               ; point ix at level data
 31+  A734 FD 21 0C A2      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A738              screen_draw0:
 33+  A738 DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A73B C5               push bc                     ; store bc, contains loop count
 35+  A73C CD DE A8         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A73F 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A740 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A743 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A746 CD A7 A8         call screen_getblock        ; get the block data into hl
 40+  A749 CD 8D A8         call screen_showchar        ; show this character here
 41+  A74C C1               pop bc                      ; get the loop counter back
 42+  A74D DD 23            inc ix                      ; increment level location
 43+  A74F FD 23            inc iy                      ; increment attr location
 44+  A751 0C               inc c                       ; increment horiz
 45+  A752 79               ld a,c
 46+  A753 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A755 C2 38 A7         jp nz,screen_draw0          ; if not, loop
 48+  A758 0E 00            ld c,0                      ; if so, reset horiz
 49+  A75A 04               inc b                       ; increment vertical
 50+  A75B 78               ld a,b
 51+  A75C FE 1D            cp 29                       ; check if at bottom
 52+  A75E C2 38 A7         jp nz,screen_draw0          ; if not, loop
 53+  A761 21 12 A7         ld hl, screen_tmp
 54+  A764 36 09            ld (hl),9                   ; load the block number into memory
 55+  A766 DD 21 8F B1      ld ix,level01rocks          ; rock memory
 56+  A76A CD CB A7         call screen_initobjects     ; draw rocks
 57+  A76D 21 12 A7         ld hl, screen_tmp
 58+  A770 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A772 DD 21 8F B2      ld ix,level01missiles       ; missile memory
 60+  A776 CD CB A7         call screen_initobjects     ; draw missiles
 61+  A779 21 12 A7         ld hl, screen_tmp
 62+  A77C 36 08            ld (hl),08                  ; load the block number into memory
 63+  A77E DD 21 08 B3      ld ix,level01diamonds       ; diamond memory
 64+  A782 CD CB A7         call screen_initobjects     ; draw diamonds
 65+  A785 21 12 A7         ld hl, screen_tmp
 66+  A788 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A78A DD 21 18 B3      ld ix,level01gems           ; gems memory
 68+  A78E CD CB A7         call screen_initobjects     ; draw gems
 69+  A791 CD 98 A7         call screen_setuptext       ; draws text on the screen
 70+  A794 CD 37 C1         call scores_printscores     ; print the current scores
 71+  A797 C9               ret
 72+  A798
 73+  A798              ;
 74+  A798              ; Sets up text on the screen
 75+  A798              ;
 76+  A798              screen_setuptext:
 77+  A798 CD 59 C1         call scores_showtable
 78+  A79B CD 20 A7         call screen_sethighscorecolours
 79+  A79E 21 ED 80         ld hl, string_score1
 80+  A7A1 CD C4 84         call string_print
 81+  A7A4 21 F6 80         ld hl, string_scorenumbers1
 82+  A7A7 CD C4 84         call string_print
 83+  A7AA 21 FF 80         ld hl, string_company
 84+  A7AD CD C4 84         call string_print
 85+  A7B0 21 14 81         ld hl, string_score2
 86+  A7B3 CD C4 84         call string_print
 87+  A7B6 21 1D 81         ld hl, string_scorenumbers2
 88+  A7B9 CD C4 84         call string_print
 89+  A7BC 21 09 81         ld hl, string_credits
 90+  A7BF CD C4 84         call string_print
 91+  A7C2 CD 14 A7         call screen_setscorecolours
 92+  A7C5 C9               ret
 93+  A7C6
 94+  A7C6              ;
 95+  A7C6              ; Sets a line of colours
 96+  A7C6              ; Inputs:
 97+  A7C6              ; a - colour to set
 98+  A7C6              ; b - number to set
 99+  A7C6              ; de - start memory location
100+  A7C6              ;
101+  A7C6              screen_setcolours:
102+  A7C6 12               ld (de),a
103+  A7C7 13               inc de
104+  A7C8 10 FC            djnz screen_setcolours
105+  A7CA C9               ret
106+  A7CB
107+  A7CB              ;
108+  A7CB              ; Draw initial object positions
109+  A7CB              ; Inputs:
110+  A7CB              ; ix - memory location of objects
111+  A7CB              ; a - graphic
112+  A7CB              screen_initobjects:
113+  A7CB DD 4E 00         ld c,(ix)                   ; get the horiz coord
114+  A7CE 79               ld a,c
115+  A7CF FE FF            cp 255
116+  A7D1 CA FA A7         jp z,screen_initobjects2
117+  A7D4 DD 23            inc ix                      ; move to next
118+  A7D6 DD 46 00         ld b,(ix)                   ; get the vert coord
119+  A7D9 DD 23            inc ix
120+  A7DB CD 0C A8         call screen_getcellattradress ; get the memory address of b,c attr into de
121+  A7DE D5               push de
122+  A7DF 3A 12 A7         ld a,(screen_tmp)                  ; get the block number back
123+  A7E2 CD DE A8         call screen_getattr         ; get the memory location for this cell's attr into hl
124+  A7E5 D1               pop de
125+  A7E6 7E               ld a,(hl)                   ; get the attr value at the address
126+  A7E7 12               ld (de),a                   ; load the attr into memory
127+  A7E8 3A 12 A7         ld a,(screen_tmp)                  ; get the block number back
128+  A7EB CD A7 A8         call screen_getblock        ; get the block data into hl
129+  A7EE CD 8D A8         call screen_showchar        ; show this character here
130+  A7F1
131+  A7F1              screen_initobjects1:
132+  A7F1 DD 23            inc ix                      ; move past state
133+  A7F3 DD 23            inc ix
134+  A7F5 DD 23            inc ix                      ; move past mem
135+  A7F7 C3 CB A7         jp screen_initobjects
136+  A7FA              screen_initobjects2:
137+  A7FA C9               ret
138+  A7FB
139+  A7FB
140+  A7FB              ;
141+  A7FB              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
142+  A7FB              ; Inputs:
143+  A7FB              ; bc: coords
144+  A7FB              ; Outputs:
145+  A7FB              ; de: memory location
146+  A7FB              ;
147+  A7FB              screen_getcelladdress:
148+  A7FB 78               ld a,b      ; vertical position.
149+  A7FC E6 18            and 24      ; which segment, 0, 1 or 2?
150+  A7FE C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
151+  A800 57               ld d,a      ; this is our high byte.
152+  A801 78               ld a,b      ; what was that vertical position again?
153+  A802 E6 07            and 7       ; which row within segment?
154+  A804 0F               rrca        ; multiply row by 32.
155+  A805 0F               rrca
156+  A806 0F               rrca
157+  A807 5F               ld e,a      ; low byte.
158+  A808 79               ld a,c      ; add on y coordinate.
159+  A809 83               add a,e     ; mix with low byte.
160+  A80A 5F               ld e,a      ; address of screen position in de.
161+  A80B C9               ret
162+  A80C
163+  A80C              ;
164+  A80C              ; Calculate buffer address of attribute for character at (b, c).
165+  A80C              ; Inputs:
166+  A80C              ; bc: coords
167+  A80C              ; Outputs:
168+  A80C              ; de: memory location
169+  A80C              ;
170+  A80C              screen_getcellattradress:
171+  A80C 11 0C A2         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
172+  A80F 69               ld l,c      ; x position.
173+  A810 26 00            ld h,0      ; 0 h
174+  A812 19               add hl,de
175+  A813 54 5D            ld de,hl    ; horiz done
176+  A815 78               ld a,b      ; do vert
177+  A816 D5               push de
178+  A817 C5               push bc
179+  A818 11 20 00         ld de,32
180+  A81B CD 3A 80         call utilities_multiply
181+  A81E C1               pop bc
182+  A81F D1               pop de
183+  A820 19               add hl,de
184+  A821 54 5D            ld de,hl    ; vert done
185+  A823 C9               ret
186+  A824
187+  A824              ;
188+  A824              ; Calculate buffer address offset of attribute for character at (b, c).
189+  A824              ; Inputs:
190+  A824              ; bc: coords
191+  A824              ; Outputs:
192+  A824              ; de: memory location
193+  A824              ;
194+  A824              screen_getcellattroffset:
195+  A824 69               ld l,c      ; x position.
196+  A825 26 00            ld h,0      ; 0 h
197+  A827 54 5D            ld de,hl    ; horiz done
198+  A829 78               ld a,b      ; do vert
199+  A82A D5               push de
200+  A82B C5               push bc
201+  A82C 11 20 00         ld de,32
202+  A82F CD 3A 80         call utilities_multiply
203+  A832 C1               pop bc
204+  A833 D1               pop de
205+  A834 19               add hl,de
206+  A835 54 5D            ld de,hl    ; vert done
207+  A837 C9               ret
208+  A838
209+  A838              ;
210+  A838              ; Calculate buffer address of attribute for character at (b, c).
211+  A838              ; Inputs:
212+  A838              ; bc: coords
213+  A838              ; Outputs:
214+  A838              ; de: memory location
215+  A838              ;
216+  A838              screen_getscreenattradress:
217+  A838 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
218+  A83B 69               ld l,c      ; x position.
219+  A83C 26 00            ld h,0      ; 0 h
220+  A83E 19               add hl,de
221+  A83F 54 5D            ld de,hl    ; horiz done
222+  A841 78               ld a,b      ; do vert
223+  A842 D5               push de
224+  A843 C5               push bc
225+  A844 11 20 00         ld de,32
226+  A847 CD 3A 80         call utilities_multiply
227+  A84A C1               pop bc
228+  A84B D1               pop de
229+  A84C 19               add hl,de
230+  A84D 54 5D            ld de,hl    ; vert done
231+  A84F C9               ret
232+  A850
233+  A850              ;
234+  A850              ; Gets the attr memory location for a screen coord
235+  A850              ; Will overwrite bc
236+  A850              ; Inputs:
237+  A850              ; bc - screen coords
238+  A850              ; Outputs:
239+  A850              ; de - memory location
240+  A850              ; bc - character coords
241+  A850              ;
242+  A850              screen_getattraddressfromscreencoords:
243+  A850 78               ld a,b                          ; get the player block coords of current block
244+  A851 E6 F8            and 248                         ; find closest multiple of eight
245+  A853 0F               rrca
246+  A854 0F               rrca
247+  A855 0F               rrca                ; divide by 8
248+  A856 47               ld b,a
249+  A857 79               ld a,c
250+  A858 48               ld c,b                         ; swap b and c
251+  A859 E6 F8            and 248
252+  A85B 0F               rrca
253+  A85C 0F               rrca
254+  A85D 0F               rrca                ; divide by 8
255+  A85E 47               ld b,a
256+  A85F CD 0C A8         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
257+  A862 C9               ret
258+  A863
259+  A863
260+  A863              ; Gets the nearest cell coords for a screen coord
261+  A863              ; Will overwrite bc
262+  A863              ; Inputs:
263+  A863              ; bc - screen coords
264+  A863              ; Outputs:
265+  A863              ; bc - character coords
266+  A863              ;
267+  A863              screen_getcharcoordsfromscreencoords:
268+  A863 78               ld a,b                          ; get the player block coords of current block
269+  A864 E6 F8            and 248                         ; find closest multiple of eight
270+  A866 0F               rrca
271+  A867 0F               rrca
272+  A868 0F               rrca                ; divide by 8
273+  A869 47               ld b,a
274+  A86A 79               ld a,c
275+  A86B 48               ld c,b                         ; swap b and c
276+  A86C E6 F8            and 248
277+  A86E 0F               rrca
278+  A86F 0F               rrca
279+  A870 0F               rrca                ; divide by 8
280+  A871 47               ld b,a
281+  A872 C9               ret
282+  A873
283+  A873              ; Gets the screen coords for a cell coord
284+  A873              ; Will overwrite bc
285+  A873              ; Inputs:
286+  A873              ; bc - char coords
287+  A873              ; Outputs:
288+  A873              ; bc - screen coords
289+  A873              ;
290+  A873              screen_getscreencoordsfromcharcoords:
291+  A873 78               ld a,b                          ; get the player block coords of current block
292+  A874 07               rlca
293+  A875 07               rlca
294+  A876 07               rlca                ; multiply by 8
295+  A877 47               ld b,a
296+  A878 79               ld a,c
297+  A879 48               ld c,b                         ; swap b and c
298+  A87A 07               rlca
299+  A87B 07               rlca
300+  A87C 07               rlca                ; divide by 8
301+  A87D 47               ld b,a
302+  A87E C9               ret
303+  A87F
304+  A87F              ;
305+  A87F              ; Get buffer address for a character at b,c - b vert
306+  A87F              ; Buffer memory is stored as sequential block
307+  A87F              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
308+  A87F              ; Inputs:
309+  A87F              ; bc - coords
310+  A87F              ; Outputs:
311+  A87F              ; de - memory location of first byte
312+  A87F              screen_getbufferaddress:
313+  A87F 21 0C 85         ld hl, buffer_buffer    ; first get screen buffer start
314+  A882 50               ld d,b                  ; then work out vertical offset
315+  A883 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
316+  A885 19               add hl,de               ; add to base
317+  A886 59               ld e,c                  ; then add horizontal offset (c)
318+  A887 16 00            ld d,0
319+  A889 19               add hl,de               ; add to base
320+  A88A 54 5D            ld de,hl
321+  A88C C9               ret
322+  A88D
323+  A88D              ;
324+  A88D              ; Display character hl at (b, c) to buffer.
325+  A88D              ; Stored sequentially
326+  A88D              ; Inputs:
327+  A88D              ; hl: block address
328+  A88D              ; bc: coords
329+  A88D              ;
330+  A88D              screen_showchar:
331+  A88D 3E 00            ld a,0
332+  A88F E5               push hl
333+  A890 CD 7F A8         call screen_getbufferaddress ; get the current screen buffer pointer
334+  A893 E1               pop hl
335+  A894 06 08            ld b,8              ; number of pixels high.
336+  A896              screen_showchar0:
337+  A896 7E               ld a,(hl)           ; source graphic.
338+  A897 12               ld (de),a           ; transfer to screen.
339+  A898 23               inc hl              ; next piece of data.
340+  A899 E5               push hl             ; store hl
341+  A89A 62 6B            ld hl,de            ; put de in hl
342+  A89C 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
343+  A89E 16 00            ld d,0
344+  A8A0 19               add hl,de              ; add de to hl
345+  A8A1 54 5D            ld de,hl            ; load back to de
346+  A8A3 E1               pop hl              ; restore hl
347+  A8A4
348+  A8A4 10 F0            djnz screen_showchar0 ; repeat
349+  A8A6 C9               ret
350+  A8A7
351+  A8A7
352+  A8A7              ;
353+  A8A7              ; Get cell graphic.
354+  A8A7              ; Inputs:
355+  A8A7              ; a: block
356+  A8A7              ; Outputs:
357+  A8A7              ; hl: memory
358+  A8A7              ;
359+  A8A7              screen_getblock:
360+  A8A7 07               rlca                        ; multiply block number by eight.
361+  A8A8 07               rlca
362+  A8A9 07               rlca
363+  A8AA 5F               ld e,a                      ; displacement to graphic address.
364+  A8AB 16 00            ld d,0                      ; no high byte.
365+  A8AD 21 8D B3         ld hl,sprites               ; address of character blocks.
366+  A8B0 19               add hl,de                   ; point to block.
367+  A8B1 C9               ret
368+  A8B2
369+  A8B2              ;
370+  A8B2              ; Set a the attr of a coord
371+  A8B2              ; Inputs:
372+  A8B2              ; bc - char coords
373+  A8B2              ; a - attr
374+  A8B2              ;
375+  A8B2              screen_setattr:
376+  A8B2 DD E5            push ix
377+  A8B4 C5               push bc
378+  A8B5 08               ex af, af'
379+  A8B6 CD 24 A8         call screen_getcellattroffset   ; get offset into de
380+  A8B9 21 0C A2         ld hl,buffer_attr_buffer
381+  A8BC 19               add hl,de                       ; get the memory location
382+  A8BD 77               ld (hl),a                         ; set the attr
383+  A8BE ED 5B 11 A7      ld de,(screen_offset)           ; get the offset
384+  A8C2 78               ld a,b                          ; get the vertical
385+  A8C3 93               sub e                           ; subtract the offset
386+  A8C4 DA DA A8         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
387+  A8C7 FE 15            cp 21
388+  A8C9 D2 DA A8         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
389+  A8CC 47               ld b,a                          ; put the coord back in b
390+  A8CD CD 38 A8         call screen_getscreenattradress ; screen attr address in de
391+  A8D0 21 40 00         ld hl,64                        ; attr memory + two rows for scores
392+  A8D3 19               add hl,de
393+  A8D4 08               ex af, af'                      ; get attr back
394+  A8D5 77               ld (hl),a
395+  A8D6 C1               pop bc
396+  A8D7 DD E1            pop ix
397+  A8D9 C9               ret
398+  A8DA              screen_setattr0:
399+  A8DA C1               pop bc
400+  A8DB DD E1            pop ix
401+  A8DD C9               ret
402+  A8DE
403+  A8DE              ;
404+  A8DE              ; Get cell attribute.
405+  A8DE              ; Inputs:
406+  A8DE              ; a: block
407+  A8DE              ; Outputs:
408+  A8DE              ; hl: memory
409+  A8DE              ;
410+  A8DE              screen_getattr:
411+  A8DE 5F               ld e,a                      ; displacement to attribute address.
412+  A8DF 16 00            ld d,0                      ; no high byte.
413+  A8E1 21 65 B4         ld hl,sprite_attrs          ; address of block attributes.
414+  A8E4 19               add hl,de                   ; point to attribute.
415+  A8E5 C9               ret
416+  A8E6
417+  A8E6              ;
418+  A8E6              ; Checks whether a character block has anything in it
419+  A8E6              ; Inputs:
420+  A8E6              ; bc - char coords
421+  A8E6              ; Outputs:
422+  A8E6              ; a - 1, empty
423+  A8E6              screen_ischarempty:
424+  A8E6 CD 7F A8         call screen_getbufferaddress ; get the current screen buffer pointer
425+  A8E9 06 08            ld b,8                      ; check 8 rows
426+  A8EB              screen_ischarempty2:
427+  A8EB 1A               ld a,(de)                   ; check line
428+  A8EC FE 00            cp 0
429+  A8EE C2 FC A8         jp nz,screen_ischarempty1   ; if not zero, jump out with false
430+  A8F1 21 20 00         ld hl,32
431+  A8F4 19               add hl,de
432+  A8F5 54 5D            ld de,hl                    ; move to next row
433+  A8F7 10 F2            djnz screen_ischarempty2
434+  A8F9              screen_ischarempty0:
435+  A8F9 3E 01            ld a,1
436+  A8FB C9               ret
437+  A8FC              screen_ischarempty1:
438+  A8FC 3E 00            ld a,0
439+  A8FE C9               ret
440+  A8FF
441+  A8FF              ;
442+  A8FF              ; Copies a block from one place to another directly underneath, leaves the original empty
443+  A8FF              ; Inputs:
444+  A8FF              ; bc - coords of block to copy from
445+  A8FF              screen_copyblockdown
446+  A8FF CD 7F A8         call screen_getbufferaddress ; get the current screen buffer pointer for source
447+  A902 06 08            ld b,8                      ; copy 8 rows
448+  A904              screen_copyblock0:
449+  A904 1A               ld a,(de)                    ; get what we're copying
450+  A905 08               ex af,af'
451+  A906 3E 00            ld a,0
452+  A908 12               ld (de),a                    ; replace with empty
453+  A909 08               ex af,af'
454+  A90A 14               inc d                        ; add 256 to get to the next row
455+  A90B 12               ld (de),a                    ; copy to the next row
456+  A90C 15               dec d
457+  A90D 21 20 00         ld hl,32
458+  A910 19               add hl,de                       ; return back to source, next row down
459+  A911 54 5D            ld de,hl
460+  A913 10 EF            djnz screen_copyblock0
461+  A915 C9               ret
462+  A916
463+  A916              ;
464+  A916              ; Returns the first byte of a character. Useful for figuring out what's there
465+  A916              ; Inputs:
466+  A916              ; bc - coords
467+  A916              ; Outputs:
468+  A916              ; a - first byte
469+  A916              ;
470+  A916              screen_getcharfirstbyte:
471+  A916 CD 7F A8         call screen_getbufferaddress ; get the current screen buffer pointer for source
472+  A919 1A               ld a,(de)
473+  A91A C9               ret
474+  A91B
# file closed: screen/screen.asm
 25   A91B                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A91B              ;
  2+  A91B              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A91B              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A91B              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A91B              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A91B              ; routine takes care of all the shifting itself. This means that sprite
  7+  A91B              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A91B              ; space they would require in pre-shifted form.
  9+  A91B              ; Inputs:
 10+  A91B              ; hl - sprite data
 11+  A91B              ; bc - screen coords
 12+  A91B              ;
 13+  A91B              sprites_drawsprite7:
 14+  A91B EE 07            xor 7               ; complement last 3 bits.
 15+  A91D 3C               inc a               ; add one for luck!
 16+  A91E              sprites_drawsprite3:
 17+  A91E CB 11            rl c                ; ...into middle byte...
 18+  A920 CB 12            rl d                ; ...and finally into left character cell.
 19+  A922 3D               dec a               ; count shifts we've done.
 20+  A923 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A925                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A925 79               ld a,c              ; left edge of image is currently in e.
 23+  A926 4A               ld c,d              ; put right edge there instead.
 24+  A927 57               ld d,a              ; and the left edge back into c.
 25+  A928 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A92A              sprites_drawsprite:
 27+  A92A ED 43 F1 A9      ld (dispx),bc       ; store coords in dispx for now.
 28+  A92E E5               push hl
 29+  A92F CD CF A9         call sprites_scadd  ; calculate screen address.
 30+  A932 E1               pop hl
 31+  A933 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A935              sprites_drawsprite1:
 33+  A935 08               ex af,af'           ; store loop counter.
 34+  A936 D5               push de             ; store screen address.
 35+  A937 4E               ld c,(hl)           ; first sprite graphic.
 36+  A938 23               inc hl              ; increment poiinter to sprite data.
 37+  A939 22 F3 A9         ld (sprtmp),hl      ; store it for later.
 38+  A93C 16 00            ld d,0              ; blank right byte for now.
 39+  A93E 78               ld a,b              ; b holds y position.
 40+  A93F E6 07            and 7               ; how are we straddling character cells?
 41+  A941 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A943 FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A945 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A947 A7               and a               ; oops, carry flag is set so clear it.
 45+  A948              sprites_drawsprite2:
 46+  A948 CB 19            rr c                ; rotate left byte right...
 47+  A94A CB 1A            rr d                ; ...into right byte.
 48+  A94C 3D               dec a               ; one less shift to do.
 49+  A94D 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A94F              sprites_drawsprite0:
 51+  A94F E1               pop hl              ; pop screen address from stack.
 52+  A950 7E               ld a,(hl)           ; what's there already.
 53+  A951 A9               xor c               ; merge in image data.
 54+  A952 77               ld (hl),a           ; place onto screen.
 55+  A953 23               inc hl
 56+  A954 7E               ld a,(hl)           ; what's already there.
 57+  A955 AA               xor d               ; right edge of sprite image data.
 58+  A956 77               ld (hl),a           ; plonk it on screen.
 59+  A957 3A F1 A9         ld a,(dispx)        ; vertical coordinate.
 60+  A95A 3C               inc a               ; next line down.
 61+  A95B 32 F1 A9         ld (dispx),a        ; store new position.
 62+  A95E 2B               dec hl
 63+  A95F 11 20 00         ld de,32            ; add 32 to get to the next row
 64+  A962 19               add hl,de           ; add 32
 65+  A963              sprites_drawsprite6:
 66+  A963 EB               ex de,hl            ; screen address in de.
 67+  A964 2A F3 A9         ld hl,(sprtmp)      ; restore graphic address.
 68+  A967 08               ex af,af'           ; restore loop counter.
 69+  A968 3D               dec a               ; decrement it.
 70+  A969 C2 35 A9         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 71+  A96C C9               ret                 ; job done.
 72+  A96D
 73+  A96D              ; Inputs:
 74+  A96D              ; hl - sprite data
 75+  A96D              ; bc - screen coords
 76+  A96D              ;
 77+  A96D              sprites_draw2by2sprite7
 78+  A96D EE 07            xor 7               ; complement last 3 bits.
 79+  A96F 3C               inc a               ; add one for luck!
 80+  A970              sprites_draw2by2sprite3
 81+  A970 CB 12            rl d                ; rotate left...
 82+  A972 CB 11            rl c                ; ...into middle byte...
 83+  A974 CB 13            rl e                ; ...and finally into left character cell.
 84+  A976 3D               dec a               ; count shifts we've done.
 85+  A977 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 86+  A979                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 87+  A979 7B               ld a,e              ; left edge of image is currently in e.
 88+  A97A 5A               ld e,d              ; put right edge there instead.
 89+  A97B 51               ld d,c              ; middle bit goes in d.
 90+  A97C 4F               ld c,a              ; and the left edge back into c.
 91+  A97D 18 2D            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 92+  A97F              sprites_draw2by2sprite
 93+  A97F ED 43 F1 A9      ld (dispx),bc       ; store coords in dispx for now.
 94+  A983 79               ld a,c
 95+  A984 32 F5 A9         ld (sprtmp0),a         ; store vertical.
 96+  A987 E5               push hl
 97+  A988 CD CF A9         call sprites_scadd          ; calculate screen address.
 98+  A98B E1               pop hl
 99+  A98C 3E 10            ld a,16             ; height of sprite in pixels.
100+  A98E              sprites_draw2by2sprite1
101+  A98E 08               ex af,af'           ; store loop counter.
102+  A98F D5               push de             ; store screen address.
103+  A990 4E               ld c,(hl)           ; first sprite graphic.
104+  A991 23               inc hl              ; increment poiinter to sprite data.
105+  A992 56               ld d,(hl)           ; next bit of sprite image.
106+  A993 23               inc hl              ; point to next row of sprite data.
107+  A994 22 F3 A9         ld (sprtmp),hl        ; store in tmp0 for later.
108+  A997 1E 00            ld e,0              ; blank right byte for now.
109+  A999 78               ld a,b              ; b holds y position.
110+  A99A E6 07            and 7               ; how are we straddling character cells?
111+  A99C 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
112+  A99E FE 05            cp 5                ; 5 or more right shifts needed?
113+  A9A0 30 CB            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
114+  A9A2 A7               and a               ; oops, carry flag is set so clear it.
115+  A9A3              sprites_draw2by2sprite2
116+  A9A3 CB 19            rr c                ; rotate left byte right...
117+  A9A5 CB 1A            rr d                ; ...through middle byte...
118+  A9A7 CB 1B            rr e                ; ...into right byte.
119+  A9A9 3D               dec a               ; one less shift to do.
120+  A9AA 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
121+  A9AC              sprites_draw2by2sprite0
122+  A9AC E1               pop hl              ; pop screen address from stack.
123+  A9AD 7E               ld a,(hl)           ; what's there already.
124+  A9AE A9               xor c               ; merge in image data.
125+  A9AF 77               ld (hl),a           ; place onto screen.
126+  A9B0 23               inc hl               ; next character cell to right please.
127+  A9B1 7E               ld a,(hl)           ; what's there already.
128+  A9B2 AA               xor d               ; merge with middle bit of image.
129+  A9B3 77               ld (hl),a           ; put back onto screen.
130+  A9B4 23               inc hl              ; next bit of screen area.
131+  A9B5 7E               ld a,(hl)           ; what's already there.
132+  A9B6 AB               xor e               ; right edge of sprite image data.
133+  A9B7 77               ld (hl),a           ; plonk it on screen.
134+  A9B8 3A F5 A9         ld a,(sprtmp0)         ; temporary vertical coordinate.
135+  A9BB 3C               inc a               ; next line down.
136+  A9BC 32 F5 A9         ld (sprtmp0),a         ; store new position.
137+  A9BF 2B               dec hl
138+  A9C0 2B               dec hl
139+  A9C1 11 20 00         ld de,32            ; add 32 to get to the next row
140+  A9C4 19               add hl,de           ; add 32
141+  A9C5              sprites_draw2by2sprite6
142+  A9C5 EB               ex de,hl            ; screen address in de.
143+  A9C6 2A F3 A9         ld hl,(sprtmp)        ; restore graphic address.
144+  A9C9 08               ex af,af'           ; restore loop counter.
145+  A9CA 3D               dec a               ; decrement it.
146+  A9CB C2 8E A9         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
147+  A9CE C9               ret                 ; job done.
148+  A9CF
149+  A9CF
150+  A9CF              ;
151+  A9CF              ; This routine returns a buffer address for (c, b) in de (c vert).
152+  A9CF              ; For example: 0,0 will be at memory offset 0
153+  A9CF              ; 1,0 (1 down) will be at memory offset 1
154+  A9CF              ; 0,7 will be at memory offset 0
155+  A9CF              ; 9,1 will be at memory offset 8+1
156+  A9CF              ; 8,0 will be at memory offset 256
157+  A9CF              ; 9,0 will be at memory offset 257
158+  A9CF              ; Outputs:
159+  A9CF              ; de - coords
160+  A9CF              ;
161+  A9CF              sprites_scadd:
162+  A9CF 79               ld a,c               ; calculate vertical offset
163+  A9D0 E6 F8            and 248             ;  to get nearest multiple of 8
164+  A9D2 0F               rrca
165+  A9D3 0F               rrca
166+  A9D4 0F               rrca                ; divide by 8
167+  A9D5 67               ld h,a
168+  A9D6 78               ld a,b               ; calculate horizontal offset
169+  A9D7 E6 F8            and 248             ;  to get nearest multiple of 8
170+  A9D9 0F               rrca
171+  A9DA 0F               rrca
172+  A9DB 0F               rrca                ; divide by 8
173+  A9DC 6F               ld l,a
174+  A9DD C5               push bc             ; store the screen coords
175+  A9DE 44 4D            ld bc,hl            ; load bc with the character coords
176+  A9E0 CD 7F A8         call screen_getbufferaddress
177+  A9E3 C1               pop bc              ; get back screen coords, de is now memory of character
178+  A9E4 79               ld a,c              ; now add the vertical within the cell
179+  A9E5 E6 07            and 7
180+  A9E7 0F               rrca                ; multiply by 32.
181+  A9E8 0F               rrca
182+  A9E9 0F               rrca
183+  A9EA 6F               ld l,a
184+  A9EB 26 00            ld h,0
185+  A9ED 19               add hl,de
186+  A9EE 54 5D            ld de,hl
187+  A9F0 C9               ret
188+  A9F1
189+  A9F1 00           dispx   defb 0           ; general-use coordinates.
190+  A9F2 00           dispy   defb 0
191+  A9F3 00 00        sprtmp  defb 0,0           ; sprite temporary address.
192+  A9F5 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
193+  A9F7
# file closed: screen/sprites.asm
 26   A9F7                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  A9F7              ;
  2+  A9F7              ; Draws the title screen
  3+  A9F7              ;
  4+  A9F7              titlescreen_show:
  5+  A9F7 CD 6F AA         call titlescreen_init
  6+  A9FA CD 18 AA         call titlescreen_drawtitle
  7+  A9FD 3E FA            ld a,250                              ; wait for 200 frames
  8+  A9FF CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
  9+  AA02 7B               ld a,e
 10+  AA03 FE 01            cp 1                                  ; was anything pressed?
 11+  AA05 C8               ret z                                 ; end titlescreen if so
 12+  AA06
 13+  AA06 CD 82 AA         call titlescreen_alt_init             ; otherwise, draw alt screen
 14+  AA09 CD 34 AA         call titlescreen_alt_drawtitle
 15+  AA0C 3E FA            ld a,250                              ; wait for 200 frames
 16+  AA0E CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 17+  AA11 7B               ld a,e
 18+  AA12 FE 01            cp 1                                  ; was anything pressed?
 19+  AA14 C2 F7 A9         jp nz,titlescreen_show                ; start again if not
 20+  AA17 C9               ret
 21+  AA18
 22+  AA18              ;
 23+  AA18              ; Draws the iconic logo
 24+  AA18              ;
 25+  AA18              titlescreen_drawtitle:
 26+  AA18 06 67            ld b,103              ; number of points
 27+  AA1A DD 21 8F AA      ld ix,titlescreen_logo_data
 28+  AA1E              titlescreen_drawtitle0:
 29+  AA1E C5               push bc
 30+  AA1F DD 4E 00         ld c,(ix)                   ; got horiz
 31+  AA22 DD 23            inc ix
 32+  AA24 DD 46 00         ld b,(ix)                   ; got vert
 33+  AA27 DD 23            inc ix
 34+  AA29 CD 38 A8         call screen_getscreenattradress ; memory in de
 35+  AA2C 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 36+  AA2D 3E 13            ld a,19
 37+  AA2F 12               ld (de),a
 38+  AA30 C1               pop bc
 39+  AA31 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 40+  AA33 C9               ret
 41+  AA34
 42+  AA34              ;
 43+  AA34              ; Draws the alternate title screen
 44+  AA34              ;
 45+  AA34              titlescreen_alt_drawtitle:
 46+  AA34 21 3B 81         ld hl,string_alttitlescreen_1
 47+  AA37 CD C4 84         call string_print
 48+  AA3A 21 47 81         ld hl,string_alttitlescreen_2
 49+  AA3D CD C4 84         call string_print
 50+  AA40 21 42 82         ld hl,string_alttitlescreen_3
 51+  AA43 CD C4 84         call string_print
 52+  AA46 06 20            ld b,32
 53+  AA48 3E 43            ld a,67
 54+  AA4A 11 00 58         ld de,22528                         ; top row attrs here
 55+  AA4D CD C6 A7         call screen_setcolours
 56+  AA50 06 20            ld b,32
 57+  AA52 3E 46            ld a,70
 58+  AA54 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 59+  AA57 CD C6 A7         call screen_setcolours
 60+  AA5A 06 20            ld b,32
 61+  AA5C 3E 43            ld a,67
 62+  AA5E 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 63+  AA61 CD C6 A7         call screen_setcolours
 64+  AA64 06 20            ld b,32
 65+  AA66 3E 42            ld a,66
 66+  AA68 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 67+  AA6B CD C6 A7         call screen_setcolours
 68+  AA6E C9               ret
 69+  AA6F
 70+  AA6F              ;
 71+  AA6F              ; Initialises the screen
 72+  AA6F              ;
 73+  AA6F              titlescreen_init:
 74+  AA6F              ; We want a black screen.
 75+  AA6F 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 76+  AA71                                      ; bright (64).
 77+  AA71 CD 67 80         call utilities_clearscreen
 78+  AA74 32 8D 5C         ld (23693),a        ; set our screen colours.
 79+  AA77 3E 01            ld a,1              ; 2 is the code for red.
 80+  AA79 D3 FE            out (254),a         ; write to port 254.
 81+  AA7B
 82+  AA7B 21 26 81         ld hl,string_titlescreen_copyright
 83+  AA7E CD C4 84         call string_print
 84+  AA81
 85+  AA81 C9               ret
 86+  AA82
 87+  AA82              ;
 88+  AA82              ; Initialises the screen
 89+  AA82              ;
 90+  AA82              titlescreen_alt_init:
 91+  AA82              ; We want a black screen.
 92+  AA82 3E 47            ld a,71             ; white ink (7) on black paper (0),
 93+  AA84                                      ; bright (64).
 94+  AA84 CD 67 80         call utilities_clearscreen
 95+  AA87 32 8D 5C         ld (23693),a        ; set our screen colours.
 96+  AA8A 3E 00            ld a,0              ; 2 is the code for red.
 97+  AA8C D3 FE            out (254),a         ; write to port 254.
 98+  AA8E
 99+  AA8E C9               ret
100+  AA8F
101+  AA8F              ;
102+  AA8F              ; Horiz, vert
103+  AA8F              ;
104+  AA8F              titlescreen_logo_data:
105+  AA8F 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
105+  AA93 0A 00 0C 00
105+  AA97 0F 00 11 00
105+  AA9B 12 00 13 00
106+  AA9F 09 01 0C 01      defb 9,1,12,1,15,1,17,1
106+  AAA3 0F 01 11 01
107+  AAA7 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
107+  AAAB 0D 02 0E 02
107+  AAAF 0F 02 11 02
107+  AAB3 12 02 13 02
108+  AAB7 09 03 0C 03      defb 9,3,12,3,15,3,17,3
108+  AABB 0F 03 11 03
109+  AABF 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
109+  AAC3 0F 04 11 04
109+  AAC7 12 04 13 04
110+  AACB 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
110+  AACF 02 06 03 06
110+  AAD3 04 06 05 06
110+  AAD7 06 06 07 06
110+  AADB 08 06 09 06
110+  AADF 0A 06 0B 06
111+  AAE3 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
111+  AAE7 12 06 13 06
111+  AAEB 14 06 15 06
111+  AAEF 16 06 17 06
111+  AAF3 18 06 19 06
111+  AAF7 1A 06 1B 06
112+  AAFB 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
112+  AAFF 02 09 02 0A
112+  AB03 02 0B 02 0C
112+  AB07 02 0D 02 0E
112+  AB0B 02 0F 02 10
112+  AB0F 02 11 02 12
112+  AB13 02 13 02 14
112+  AB17 02 15
113+  AB19 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
113+  AB1D 19 09 19 0A
113+  AB21 19 0B 19 0C
113+  AB25 19 0D 19 0E
113+  AB29 19 0F 19 10
113+  AB2D 19 11 19 12
113+  AB31 19 13 19 14
113+  AB35 19 15
114+  AB37 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
114+  AB3B 05 0B 06 0B
114+  AB3F 07 0B 08 0B
114+  AB43 09 0B 0A 0B
114+  AB47 0B 0B
115+  AB49 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
115+  AB4D 0B 09 0B 0A
116+  AB51 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
116+  AB55 10 10 10 11
116+  AB59 10 12 10 13
117+  AB5D
# file closed: screen/titlescreen.asm
 27   AB5D                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  AB5D              ;
  2+  AB5D              ; Draws the life remaining screen
  3+  AB5D              ;
  4+  AB5D              lifescreen_draw:
  5+  AB5D CD A3 AB         call lifescreen_init
  6+  AB60
  7+  AB60 3A 1D BA         ld a,(game_currentplayer)             ; get the current player
  8+  AB63 C6 30            add 48                                ; add 48 to get char
  9+  AB65 21 48 83         ld hl,string_lifescreen_player+10
 10+  AB68 77               ld (hl),a                             ; load this to the string we're about to show
 11+  AB69
 12+  AB69 21 3E 83         ld hl,string_lifescreen_player
 13+  AB6C CD C4 84         call string_print
 14+  AB6F
 15+  AB6F 3A 54 BA         ld a,(player+9)                       ; get the current player lives
 16+  AB72 C6 30            add 48                                ; add 48 to get the character
 17+  AB74 FE 31            cp 49
 18+  AB76 C2 89 AB         jp nz,lifescreen_draw0
 19+  AB79 21 58 83         ld hl,string_lifescreen_lastman
 20+  AB7C
 21+  AB7C 06 08            ld b,8
 22+  AB7E 3E 0A            ld a,10                                ; set red
 23+  AB80 11 6C 58         ld de,22528+108                        ; attrs here
 24+  AB83 CD C6 A7         call screen_setcolours
 25+  AB86
 26+  AB86 C3 90 AB         jp lifescreen_draw1
 27+  AB89              lifescreen_draw0:
 28+  AB89 21 4D 83         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  AB8C 77               ld (hl),a                             ; load this to the string we're about to show
 30+  AB8D 21 4B 83         ld hl,string_lifescreen_lives
 31+  AB90              lifescreen_draw1:
 32+  AB90 CD C4 84         call string_print
 33+  AB93
 34+  AB93 3E 86            ld a,134
 35+  AB95 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AB98 06 0A            ld b,10
 37+  AB9A CD C6 A7         call screen_setcolours
 38+  AB9D
 39+  AB9D 3E 64            ld a,100                              ; wait for 200 frames
 40+  AB9F CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 41+  ABA2
 42+  ABA2 C9               ret
 43+  ABA3
 44+  ABA3              ;
 45+  ABA3              ; Initialises the screen
 46+  ABA3              ;
 47+  ABA3              lifescreen_init:
 48+  ABA3              ; We want a blue screen.
 49+  ABA3                  ;call $0D6B
 50+  ABA3 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 51+  ABA5                                      ; bright (64).
 52+  ABA5 CD 67 80         call utilities_clearscreen
 53+  ABA8 32 8D 5C         ld (23693),a        ; set our screen colours.
 54+  ABAB 3E 01            ld a,1              ; 1 is the code for blue.
 55+  ABAD D3 FE            out (254),a         ; write to port 254.
 56+  ABAF                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 57+  ABAF
 58+  ABAF C9               ret
# file closed: screen/lifescreen.asm
 28   ABB0                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  ABB0              ;
  2+  ABB0              ; Draws the game over screen
  3+  ABB0              ;
  4+  ABB0              gameover_draw:
  5+  ABB0 CD 6D C1         call scores_processhighscores
  6+  ABB3
  7+  ABB3              gameover_draw0:
  8+  ABB3 CD F3 AB         call gameover_enterhighscores
  9+  ABB6
 10+  ABB6 CD 91 AC         call gameover_init
 11+  ABB9
 12+  ABB9 21 63 83         ld hl,string_gameoverscreen_gameover
 13+  ABBC CD C4 84         call string_print
 14+  ABBF
 15+  ABBF 21 6F 83         ld hl,string_gameoverscreen_copyright
 16+  ABC2 CD C4 84         call string_print
 17+  ABC5
 18+  ABC5 CD D6 AB         call gameover_commontext
 19+  ABC8
 20+  ABC8 06 0B            ld b,11
 21+  ABCA 3E 42            ld a,66
 22+  ABCC 11 2B 58         ld de,22528+43                         ; attrs here
 23+  ABCF CD C6 A7         call screen_setcolours
 24+  ABD2 CD 47 80         call utilities_waitforkey   ; wait for keypress
 25+  ABD5
 26+  ABD5 C9               ret
 27+  ABD6
 28+  ABD6              ;
 29+  ABD6              ; Draws text shared by the game over and high score screens
 30+  ABD6              ;
 31+  ABD6              gameover_commontext:
 32+  ABD6 CD 98 A7         call screen_setuptext       ; show scores
 33+  ABD9 CD 37 C1         call scores_printscores     ; print the current scores
 34+  ABDC
 35+  ABDC 21 9D 83         ld hl,string_gameover_credits
 36+  ABDF CD C4 84         call string_print
 37+  ABE2
 38+  ABE2 21 89 83         ld hl,string_gameoverscreen_bestscores
 39+  ABE5 CD C4 84         call string_print
 40+  ABE8
 41+  ABE8 06 20            ld b,32
 42+  ABEA 3E 45            ld a,69
 43+  ABEC 11 C0 5A         ld de,22528+704                         ; attrs here
 44+  ABEF CD C6 A7         call screen_setcolours
 45+  ABF2
 46+  ABF2 C9               ret
 47+  ABF3
 48+  ABF3              ;
 49+  ABF3              ; If required, enter highscore
 50+  ABF3              ;
 51+  ABF3              gameover_enterhighscores:
 52+  ABF3                  ; check if we need to enter initial
 53+  ABF3 3A 6C C1         ld a,(scores_highscoretmp)
 54+  ABF6 FE 00            cp 0
 55+  ABF8 C8               ret z
 56+  ABF9 CD 27 AC         call gameover_enterhighscores_init
 57+  ABFC 3A 6C C1         ld a,(scores_highscoretmp)
 58+  ABFF 3D               dec a
 59+  AC00 3D               dec a
 60+  AC01 3D               dec a                                   ; get high score location back to position of name
 61+  AC02 16 00            ld d,0
 62+  AC04 5F               ld e,a
 63+  AC05 21 F3 C0         ld hl,scores_table
 64+  AC08 19               add hl,de                               ; load memory into hl
 65+  AC09 08               ex af,af'
 66+  AC0A 06 0F            ld b,15
 67+  AC0C CD 82 80         call utilities_pauseforframes           ; pause for a little bit
 68+  AC0F 06 03            ld b,3                                  ; collect three chars
 69+  AC11              gameover_draw2:
 70+  AC11 C5               push bc
 71+  AC12 E5               push hl
 72+  AC13 CD 86 80         call utilities_readkey               ; get key into a
 73+  AC16 E1               pop hl
 74+  AC17 77               ld (hl),a
 75+  AC18 23               inc hl
 76+  AC19 E5               push hl
 77+  AC1A CD 59 C1         call scores_showtable
 78+  AC1D E1               pop hl
 79+  AC1E 06 0F            ld b,15
 80+  AC20 CD 82 80         call utilities_pauseforframes
 81+  AC23 C1               pop bc
 82+  AC24 10 EB            djnz gameover_draw2
 83+  AC26 C9               ret
 84+  AC27
 85+  AC27              ;
 86+  AC27              ; Displays the screen text for high score entry
 87+  AC27              ;
 88+  AC27              gameover_enterhighscores_init:
 89+  AC27
 90+  AC27 CD 91 AC         call gameover_init
 91+  AC2A CD D6 AB         call gameover_commontext
 92+  AC2D
 93+  AC2D 21 A9 83         ld hl,string_highscore_congratulations
 94+  AC30 CD C4 84         call string_print
 95+  AC33
 96+  AC33 3A 1D BA         ld a,(game_currentplayer)
 97+  AC36 FE 01            cp 1
 98+  AC38 21 BB 83         ld hl,string_highscore_player1
 99+  AC3B C3 41 AC         jp gameover_enterhighscores_init1
100+  AC3E              gameover_enterhighscores_init0:
101+  AC3E 21 C6 83         ld hl,string_highscore_player2
102+  AC41              gameover_enterhighscores_init1:
103+  AC41 CD C4 84         call string_print
104+  AC44 06 60            ld b,96
105+  AC46 3E 43            ld a,67
106+  AC48 11 A0 58         ld de,22528+160                         ; attrs here
107+  AC4B CD C6 A7         call screen_setcolours
108+  AC4E
109+  AC4E 21 D1 83         ld hl,string_highscore_youhaveearned
110+  AC51 CD C4 84         call string_print
111+  AC54
112+  AC54 3A 6C C1         ld a,(scores_highscoretmp)
113+  AC57 FE 05            cp 5
114+  AC59 CA 67 AC         jp z, gameover_enterhighscores_init2    ; first place
115+  AC5C FE 11            cp 17
116+  AC5E CA 6D AC         jp z, gameover_enterhighscores_init3    ; 2nd place
117+  AC61 21 0D 84         ld hl,string_highscore_place3           ; 3rd place
118+  AC64 C3 73 AC         jp gameover_enterhighscores_init4
119+  AC67              gameover_enterhighscores_init2
120+  AC67 21 E3 83         ld hl,string_highscore_place1
121+  AC6A C3 73 AC         jp gameover_enterhighscores_init4
122+  AC6D              gameover_enterhighscores_init3
123+  AC6D 21 F8 83         ld hl,string_highscore_place2
124+  AC70 C3 73 AC         jp gameover_enterhighscores_init4
125+  AC73              gameover_enterhighscores_init4
126+  AC73 CD C4 84         call string_print
127+  AC76
128+  AC76 06 60            ld b,96
129+  AC78 3E 42            ld a,66
130+  AC7A 11 40 59         ld de,22528+320                         ; attrs here
131+  AC7D CD C6 A7         call screen_setcolours
132+  AC80
133+  AC80 21 22 84         ld hl,string_highscore_pleaseenter
134+  AC83 CD C4 84         call string_print
135+  AC86
136+  AC86 06 60            ld b,96
137+  AC88 3E 46            ld a,70
138+  AC8A 11 E0 59         ld de,22528+480                         ; attrs here
139+  AC8D CD C6 A7         call screen_setcolours
140+  AC90 C9               ret
141+  AC91
142+  AC91              ;
143+  AC91              ; Initialises the screen
144+  AC91              ;
145+  AC91              gameover_init:
146+  AC91              ; We want a black screen.
147+  AC91 3E 47            ld a,71             ; white ink (7) on black paper (0),
148+  AC93                                      ; bright (64).
149+  AC93 CD 67 80         call utilities_clearscreen
150+  AC96 32 8D 5C         ld (23693),a        ; set our screen colours.
151+  AC99 3E 00            ld a,0              ; 2 is the code for red.
152+  AC9B D3 FE            out (254),a         ; write to port 254.
153+  AC9D C9               ret
# file closed: screen/gameover.asm
 29   AC9E                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AC9E              ;
  2+  AC9E              ; Draws the level transition screen
  3+  AC9E              ;
  4+  AC9E              endlevel_draw:
  5+  AC9E CD 94 AD         call endlevel_init
  6+  ACA1 CD 7D AD         call endlevel_commontext
  7+  ACA4
  8+  ACA4 21 A9 83         ld hl,string_highscore_congratulations
  9+  ACA7 CD C4 84         call string_print
 10+  ACAA
 11+  ACAA 3A 1D BA         ld a,(game_currentplayer)
 12+  ACAD FE 01            cp 1
 13+  ACAF 21 BB 83         ld hl,string_highscore_player1
 14+  ACB2 C3 B8 AC         jp endlevel_init1
 15+  ACB5              endlevel_init0:
 16+  ACB5 21 C6 83         ld hl,string_highscore_player2
 17+  ACB8              endlevel_init1:
 18+  ACB8 CD C4 84         call string_print
 19+  ACBB
 20+  ACBB 21 3F 84         ld hl,string_endlevel_youhaveearned
 21+  ACBE CD C4 84         call string_print
 22+  ACC1
 23+  ACC1 CD 1C AD         call endlevel_workoutbonus
 24+  ACC4 D5               push de
 25+  ACC5 08               ex af,af'                               ; store the a value for later
 26+  ACC6 CD C4 84         call string_print
 27+  ACC9 D1               pop de
 28+  ACCA 62 6B            ld hl,de                                ; get the points text into de
 29+  ACCC CD C4 84         call string_print
 30+  ACCF
 31+  ACCF 21 AA 84         ld hl, string_endlevel_anothergo
 32+  ACD2 CD C4 84         call string_print
 33+  ACD5
 34+  ACD5 06 20            ld b,32
 35+  ACD7 3E 63            ld a,99
 36+  ACD9 11 60 59         ld de,22528+352                         ; attrs here
 37+  ACDC CD C6 A7         call screen_setcolours
 38+  ACDF
 39+  ACDF 06 20            ld b,32
 40+  ACE1 3E 65            ld a,101
 41+  ACE3 11 A0 59         ld de,22528+416                         ; attrs here
 42+  ACE6 CD C6 A7         call screen_setcolours
 43+  ACE9
 44+  ACE9 06 20            ld b,32
 45+  ACEB 3E 63            ld a,99
 46+  ACED 11 E0 59         ld de,22528+480                         ; attrs here
 47+  ACF0 CD C6 A7         call screen_setcolours
 48+  ACF3
 49+  ACF3 06 20            ld b,32
 50+  ACF5 3E 62            ld a,98
 51+  ACF7 11 40 5A         ld de,22528+576                         ; attrs here
 52+  ACFA CD C6 A7         call screen_setcolours
 53+  ACFD
 54+  ACFD 08               ex af,af'                               ; get back a value with bonus type
 55+  ACFE 06 14            ld b,20
 56+  AD00 CD 82 80         call utilities_pauseforframes
 57+  AD03
 58+  AD03 47               ld b,a                      ; put the bonus count in b
 59+  AD04              endlevel_init2:
 60+  AD04 C5               push bc
 61+  AD05 06 01            ld b,1
 62+  AD07 CD 17 C1         call scores_addthousands
 63+  AD0A CD FB BA         call player_recordcurrentscore
 64+  AD0D CD 37 C1         call scores_printscores     ; print the current scores
 65+  AD10 06 0A            ld b,10
 66+  AD12 CD 82 80         call utilities_pauseforframes
 67+  AD15 C1               pop bc
 68+  AD16 10 EC            djnz endlevel_init2
 69+  AD18
 70+  AD18 CD 47 80         call utilities_waitforkey   ; wait for keypress
 71+  AD1B
 72+  AD1B C9               ret
 73+  AD1C
 74+  AD1C              ;
 75+  AD1C              ; Works out the bonus
 76+  AD1C              ; Outputs:
 77+  AD1C              ; a = 15 (all seven)
 78+  AD1C              ; a = 10 (3 large or 4 small)
 79+  AD1C              ; a = 5 (1 large diamond)
 80+  AD1C              ; hl - pointer to bonus text
 81+  AD1C              ; de - pointer to points text
 82+  AD1C              ;
 83+  AD1C              endlevel_workoutbonus:
 84+  AD1C 21 0A B3         ld hl,level01diamonds+2     ; location of state of first diamond
 85+  AD1F 06 03            ld b,3                      ; number to check
 86+  AD21 16 00            ld d,0                      ; zero diamond count
 87+  AD23              endlevel_workoutbonus0:
 88+  AD23 7E               ld a,(hl)                   ; get state
 89+  AD24 FE 01            cp 1
 90+  AD26 C2 2A AD         jp nz,endlevel_workoutbonus1 ; if not, move on
 91+  AD29 14               inc d                       ; increment diamond count
 92+  AD2A              endlevel_workoutbonus1:
 93+  AD2A 23               inc hl
 94+  AD2B 23               inc hl
 95+  AD2C 23               inc hl
 96+  AD2D 23               inc hl
 97+  AD2E 23               inc hl                      ; get to next state
 98+  AD2F 10 F2            djnz endlevel_workoutbonus0
 99+  AD31
100+  AD31 21 1A B3         ld hl,level01gems+2     ; location of state of first gem
101+  AD34 06 04            ld b,4                      ; number to check
102+  AD36 1E 00            ld e,0                      ; zero gem count
103+  AD38              endlevel_workoutbonus2:
104+  AD38 7E               ld a,(hl)                   ; get state
105+  AD39 FE 01            cp 1
106+  AD3B C2 3F AD         jp nz,endlevel_workoutbonus3 ; if not, move on
107+  AD3E 1C               inc e                       ; increment diamond count
108+  AD3F              endlevel_workoutbonus3:
109+  AD3F 23               inc hl
110+  AD40 23               inc hl
111+  AD41 23               inc hl
112+  AD42 23               inc hl
113+  AD43 23               inc hl                     ; get to next state
114+  AD44 10 F2            djnz endlevel_workoutbonus2
115+  AD46
116+  AD46 7A               ld a,d
117+  AD47 83               add e
118+  AD48 FE 07            cp 7                        ; check for max bonus
119+  AD4A C2 56 AD         jp nz,endlevel_workoutbonus4 ;
120+  AD4D 3E 0F            ld a,15
121+  AD4F 21 6F 84         ld hl, string_endlevel_bonus3
122+  AD52 11 9B 84         ld de, string_endlevel_points3
123+  AD55 C9               ret                         ; return with bonus of 15
124+  AD56              endlevel_workoutbonus4:
125+  AD56 7A               ld a,d                      ; check for for diamonds
126+  AD57 FE 03            cp 3
127+  AD59 C2 65 AD         jp nz,endlevel_workoutbonus5
128+  AD5C 3E 0A            ld a,10
129+  AD5E 21 60 84         ld hl, string_endlevel_bonus2
130+  AD61 11 8C 84         ld de, string_endlevel_points2
131+  AD64 C9               ret                         ; return with bonus of ten
132+  AD65              endlevel_workoutbonus5:
133+  AD65 7B               ld a,e                      ; check for four gems
134+  AD66 FE 04            cp 4
135+  AD68 C2 74 AD         jp nz,endlevel_workoutbonus6
136+  AD6B 3E 0A            ld a,10
137+  AD6D 21 60 84         ld hl, string_endlevel_bonus2
138+  AD70 11 8C 84         ld de, string_endlevel_points2
139+  AD73 C9               ret                         ; return with bonus of 10
140+  AD74              endlevel_workoutbonus6:
141+  AD74 3E 05            ld a,5                      ; otherwise, bonus is 5
142+  AD76 21 51 84         ld hl, string_endlevel_bonus1
143+  AD79 11 7E 84         ld de, string_endlevel_points1
144+  AD7C C9               ret
145+  AD7D
146+  AD7D              ;
147+  AD7D              ; Draws text shared by the game over and high score screens
148+  AD7D              ;
149+  AD7D              endlevel_commontext:
150+  AD7D CD 98 A7         call screen_setuptext       ; show scores
151+  AD80 CD 37 C1         call scores_printscores     ; print the current scores
152+  AD83
153+  AD83 21 89 83         ld hl,string_gameoverscreen_bestscores
154+  AD86 CD C4 84         call string_print
155+  AD89
156+  AD89 06 20            ld b,32
157+  AD8B 3E 45            ld a,69
158+  AD8D 11 C0 5A         ld de,22528+704                         ; attrs here
159+  AD90 CD C6 A7         call screen_setcolours
160+  AD93
161+  AD93 C9               ret
162+  AD94
163+  AD94              ;
164+  AD94              ; Initialises the screen
165+  AD94              ;
166+  AD94              endlevel_init:
167+  AD94              ; We want a green screen.
168+  AD94 3E 61            ld a,97             ; white ink (7) on black paper (0),
169+  AD96                                      ; bright (64).
170+  AD96 CD 67 80         call utilities_clearscreen
171+  AD99 32 8D 5C         ld (23693),a        ; set our screen colours.
172+  AD9C 3E 00            ld a,0              ; 2 is the code for red.
173+  AD9E D3 FE            out (254),a         ; write to port 254.
174+  ADA0 C9               ret
# file closed: screen/endlevel.asm
 30   ADA1
 31   ADA1                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  ADA1              sound_gemcollected:
  2+  ADA1 21 C8 00         ld hl,200 ; pitch.
  3+  ADA4 11 3E 00         ld de,62 ; duration.
  4+  ADA7 CD B5 03         call 949 ; ROM beeper routine.
  5+  ADAA C9               ret
  6+  ADAB
  7+  ADAB              sound_pitchbend:
  8+  ADAB 21 F4 01         ld hl,500 ; starting pitch.
  9+  ADAE 06 FA            ld b,250 ; length of pitch bend.
 10+  ADB0              sound_pitchbend0:
 11+  ADB0 C5                push bc
 12+  ADB1 E5               push hl ; store pitch.
 13+  ADB2 11 01 00         ld de,1 ; very short duration.
 14+  ADB5 CD B5 03         call 949 ; ROM beeper routine.
 15+  ADB8 E1               pop hl ; restore pitch.
 16+  ADB9 23               inc hl ; pitch going up.
 17+  ADBA C1               pop bc
 18+  ADBB 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  ADBD C9               ret
 20+  ADBE
 21+  ADBE              sound_rockfell:
 22+  ADBE 08               ex af,af'
 23+  ADBF 1E 32            ld e,50 ; repeat 250 times.
 24+  ADC1 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  ADC4 D5           sound_rockfell2 push de
 26+  ADC5 06 20            ld b,32 ; length of step.
 27+  ADC7 C5           sound_rockfell0 push bc
 28+  ADC8 7E               ld a,(hl) ; next "random" number.
 29+  ADC9 23               inc hl ; pointer.
 30+  ADCA E6 F8            and 248 ; we want a black border.
 31+  ADCC D3 FE            out (254),a ; write to speaker.
 32+  ADCE 7B               ld a,e ; as e gets smaller...
 33+  ADCF 2F               cpl ; ...we increase the delay.
 34+  ADD0 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  ADD1 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  ADD3 C1               pop bc
 37+  ADD4 10 F1            djnz sound_rockfell0 ; next step.
 38+  ADD6 D1               pop de
 39+  ADD7 7B               ld a,e
 40+  ADD8 D6 18            sub 24 ; size of step.
 41+  ADDA FE 1E            cp 30 ; end of range.
 42+  ADDC CA ED AD         jp z,sound_rockfell5
 43+  ADDF DA ED AD         jp c, sound_rockfell5
 44+  ADE2 5F               ld e,a
 45+  ADE3 2F               cpl
 46+  ADE4 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  ADE6 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  ADE8 3D               dec a
 49+  ADE9 20 F9            jr nz,sound_rockfell3
 50+  ADEB 18 D7            jr sound_rockfell2
 51+  ADED              sound_rockfell5
 52+  ADED 08               ex af,af'
 53+  ADEE C9               ret
 54+  ADEF
# file closed: sound/sound.asm
 32   ADEF
 33   ADEF                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  ADEF              ; ###############################################################
  2+  ADEF              ; Data for level 1
  3+  ADEF              ; ###############################################################
  4+  ADEF              level01:
  5+  ADEF
  6+  ADEF                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  ADEF
  8+  ADEF 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  ADF3 05 05 05 05
  8+  ADF7 05 05 05 05
  8+  ADFB 05 05 02 01
  8+  ADFF 01 01 03 05
  8+  AE03 05 05 05 05
  8+  AE07 05 05 05 05
  8+  AE0B 05 05 00 00
  9+  AE0F 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  AE13 05 05 05 05
  9+  AE17 05 05 05 05
  9+  AE1B 02 01 01 01
  9+  AE1F 01 01 01 01
  9+  AE23 03 05 05 05
  9+  AE27 05 05 05 05
  9+  AE2B 05 05 00 00
 10+  AE2F 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  AE33 05 05 05 05
 10+  AE37 05 05 02 01
 10+  AE3B 01 01 01 01
 10+  AE3F 01 01 01 01
 10+  AE43 01 01 03 05
 10+  AE47 0D 0D 0D 0D
 10+  AE4B 0D 0D 00 00
 11+  AE4F 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  AE53 01 01 00 01
 11+  AE57 01 01 01 01
 11+  AE5B 01 01 01 01
 11+  AE5F 01 01 01 01
 11+  AE63 01 01 01 03
 11+  AE67 05 05 05 05
 11+  AE6B 05 05 00 00
 12+  AE6F 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  AE73 04 04 04 04
 12+  AE77 04 04 01 01
 12+  AE7B 01 01 01 01
 12+  AE7F 01 01 01 01
 12+  AE83 01 01 01 01
 12+  AE87 01 01 01 01
 12+  AE8B 00 01 00 00
 13+  AE8F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  AE93 04 04 04 04
 13+  AE97 04 04 04 04
 13+  AE9B 01 01 01 01
 13+  AE9F 01 01 01 01
 13+  AEA3 01 01 01 01
 13+  AEA7 00 00 00 00
 13+  AEAB 00 01 00 00
 14+  AEAF 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  AEB3 04 01 01 01
 14+  AEB7 01 01 04 04
 14+  AEBB 04 04 01 01
 14+  AEBF 01 01 01 01
 14+  AEC3 01 00 00 00
 14+  AEC7 00 01 01 01
 14+  AECB 01 01 00 00
 15+  AECF 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  AED3 04 04 04 04
 15+  AED7 04 01 04 04
 15+  AEDB 04 04 04 04
 15+  AEDF 04 04 00 00
 15+  AEE3 00 00 04 04
 15+  AEE7 04 04 04 04
 15+  AEEB 04 01 00 00
 16+  AEEF 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  AEF3 01 04 01 01
 16+  AEF7 01 01 04 04
 16+  AEFB 04 04 04 04
 16+  AEFF 04 04 00 04
 16+  AF03 04 04 04 04
 16+  AF07 04 04 04 04
 16+  AF0B 04 01 00 00
 17+  AF0F 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  AF13 00 00 00 00
 17+  AF17 00 04 04 04
 17+  AF1B 04 04 04 04
 17+  AF1F 04 04 00 04
 17+  AF23 04 04 04 04
 17+  AF27 04 04 04 04
 17+  AF2B 04 01 00 00
 18+  AF2F 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  AF33 15 15 15 15
 18+  AF37 15 01 04 04
 18+  AF3B 04 04 04 04
 18+  AF3F 04 04 00 04
 18+  AF43 04 04 04 04
 18+  AF47 04 04 04 04
 18+  AF4B 04 01 00 00
 19+  AF4F 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  AF53 00 00 00 00
 19+  AF57 00 01 04 04
 19+  AF5B 04 04 04 04
 19+  AF5F 04 04 00 04
 19+  AF63 04 04 04 04
 19+  AF67 04 00 00 00
 19+  AF6B 00 01 00 00
 20+  AF6F 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  AF73 00 00 00 00
 20+  AF77 00 01 04 04
 20+  AF7B 04 04 04 04
 20+  AF7F 04 04 00 04
 20+  AF83 04 04 04 04
 20+  AF87 04 00 04 04
 20+  AF8B 00 01 00 00
 21+  AF8F 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  AF93 06 06 06 06
 21+  AF97 06 01 04 04
 21+  AF9B 04 04 04 04
 21+  AF9F 04 04 00 04
 21+  AFA3 04 04 04 04
 21+  AFA7 04 00 04 04
 21+  AFAB 00 01 00 00
 22+  AFAF 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  AFB3 1A 1A 1A 1A
 22+  AFB7 1A 01 04 00
 22+  AFBB 00 00 00 00
 22+  AFBF 00 00 00 00
 22+  AFC3 00 00 00 00
 22+  AFC7 00 00 04 04
 22+  AFCB 00 01 00 00
 23+  AFCF 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  AFD3 1A 1A 1A 1A
 23+  AFD7 1A 01 04 00
 23+  AFDB 04 04 04 04
 23+  AFDF 04 04 00 04
 23+  AFE3 04 04 00 04
 23+  AFE7 04 04 04 04
 23+  AFEB 00 01 00 00
 24+  AFEF 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  AFF3 1A 1A 1A 1A
 24+  AFF7 1A 01 04 00
 24+  AFFB 04 04 04 04
 24+  AFFF 04 04 00 04
 24+  B003 04 04 00 04
 24+  B007 04 04 04 04
 24+  B00B 00 01 00 00
 25+  B00F 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B013 01 01 01 01
 25+  B017 01 01 04 00
 25+  B01B 04 04 04 04
 25+  B01F 04 04 00 04
 25+  B023 04 04 00 04
 25+  B027 04 04 04 04
 25+  B02B 00 01 00 00
 26+  B02F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B033 04 04 04 04
 26+  B037 04 04 04 00
 26+  B03B 04 04 04 04
 26+  B03F 04 04 00 04
 26+  B043 04 04 00 00
 26+  B047 00 00 04 04
 26+  B04B 04 01 00 00
 27+  B04F 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B053 04 04 00 00
 27+  B057 00 00 00 00
 27+  B05B 04 04 04 04
 27+  B05F 04 04 00 04
 27+  B063 04 04 04 04
 27+  B067 04 00 04 04
 27+  B06B 04 01 00 00
 28+  B06F 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B073 04 04 00 04
 28+  B077 04 04 04 04
 28+  B07B 04 04 04 04
 28+  B07F 04 04 00 04
 28+  B083 04 04 04 04
 28+  B087 04 00 04 04
 28+  B08B 04 01 00 00
 29+  B08F 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B093 04 04 00 04
 29+  B097 04 04 01 01
 29+  B09B 01 01 01 01
 29+  B09F 01 01 01 01
 29+  B0A3 01 01 01 01
 29+  B0A7 04 00 04 04
 29+  B0AB 04 01 00 00
 30+  B0AF 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B0B3 04 04 00 04
 30+  B0B7 04 04 01 00
 30+  B0BB 00 00 00 00
 30+  B0BF 00 00 00 00
 30+  B0C3 00 00 00 01
 30+  B0C7 04 00 04 04
 30+  B0CB 04 01 00 00
 31+  B0CF 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B0D3 04 04 00 04
 31+  B0D7 04 04 01 00
 31+  B0DB 00 00 00 00
 31+  B0DF 00 00 00 00
 31+  B0E3 00 00 00 01
 31+  B0E7 04 00 04 04
 31+  B0EB 04 01 00 00
 32+  B0EF 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B0F3 04 04 00 04
 32+  B0F7 04 04 01 00
 32+  B0FB 00 00 00 00
 32+  B0FF 00 00 00 00
 32+  B103 00 00 00 01
 32+  B107 04 00 04 04
 32+  B10B 04 01 00 00
 33+  B10F 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B113 04 04 00 04
 33+  B117 04 04 04 00
 33+  B11B 00 00 00 00
 33+  B11F 00 00 00 00
 33+  B123 00 00 00 04
 33+  B127 04 04 04 04
 33+  B12B 04 01 00 00
 34+  B12F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B133 04 04 04 04
 34+  B137 04 04 01 00
 34+  B13B 00 00 00 00
 34+  B13F 00 00 00 00
 34+  B143 00 00 00 01
 34+  B147 04 04 04 04
 34+  B14B 04 01 00 00
 35+  B14F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B153 04 04 04 04
 35+  B157 04 04 01 00
 35+  B15B 00 00 01 00
 35+  B15F 00 00 00 01
 35+  B163 00 00 00 01
 35+  B167 04 04 04 04
 35+  B16B 04 01 00 00
 36+  B16F 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B173 01 01 01 01
 36+  B177 01 01 01 01
 36+  B17B 01 01 01 01
 36+  B17F 01 01 01 01
 36+  B183 01 01 01 01
 36+  B187 01 01 01 01
 36+  B18B 01 01 00 00
 37+  B18F
 38+  B18F              ; ###############################################################
 39+  B18F              ; Object data: horiz, vert, state, memh, meml
 40+  B18F              ; ###############################################################
 41+  B18F              level01rocks:
 42+  B18F 09 04 00 00      defb 9,4,0,0,0
 42+  B193 00
 43+  B194 0C 07 00 00      defb 12,7,0,0,0
 43+  B198 00
 44+  B199 10 07 00 00      defb 16,7,0,0,0
 44+  B19D 00
 45+  B19E 0B 08 00 00      defb 11,8,0,0,0
 45+  B1A2 00
 46+  B1A3 0A 0A 00 00      defb 10,10,0,0,0
 46+  B1A7 00
 47+  B1A8 0C 0A 00 00      defb 12,10,0,0,0
 47+  B1AC 00
 48+  B1AD 0D 09 00 00      defb 13,9,0,0,0
 48+  B1B1 00
 49+  B1B2 0E 08 00 00      defb 14,8,0,0,0
 49+  B1B6 00
 50+  B1B7 0F 0B 00 00      defb 15,11,0,0,0
 50+  B1BB 00
 51+  B1BC 0B 0C 00 00      defb 11,12,0,0,0
 51+  B1C0 00
 52+  B1C1 11 0C 00 00      defb 17,12,0,0,0
 52+  B1C5 00
 53+  B1C6 13 08 00 00      defb 19,8,0,0,0
 53+  B1CA 00
 54+  B1CB 16 09 00 00      defb 22,9,0,0,0
 54+  B1CF 00
 55+  B1D0 13 0A 00 00      defb 19,10,0,0,0
 55+  B1D4 00
 56+  B1D5 15 0A 00 00      defb 21,10,0,0,0
 56+  B1D9 00
 57+  B1DA 15 0C 00 00      defb 21,12,0,0,0
 57+  B1DE 00
 58+  B1DF 16 0C 00 00      defb 22,12,0,0,0
 58+  B1E3 00
 59+  B1E4 18 0A 00 00      defb 24,10,0,0,0
 59+  B1E8 00
 60+  B1E9 19 09 00 00      defb 25,9,0,0,0
 60+  B1ED 00
 61+  B1EE 1C 09 00 00      defb 28,9,0,0,0
 61+  B1F2 00
 62+  B1F3 1B 0C 00 00      defb 27,12,0,0,0
 62+  B1F7 00
 63+  B1F8 1A 0D 00 00      defb 26,13,0,0,0
 63+  B1FC 00
 64+  B1FD 19 0E 00 00      defb 25,14,0,0,0
 64+  B201 00
 65+  B202 19 10 00 00      defb 25,16,0,0,0
 65+  B206 00
 66+  B207 1A 11 00 00      defb 26,17,0,0,0
 66+  B20B 00
 67+  B20C 1B 11 00 00      defb 27,17,0,0,0
 67+  B210 00
 68+  B211 1C 12 00 00      defb 28,18,0,0,0
 68+  B215 00
 69+  B216 1A 13 00 00      defb 26,19,0,0,0
 69+  B21A 00
 70+  B21B 1B 15 00 00      defb 27,21,0,0,0
 70+  B21F 00
 71+  B220 1A 17 00 00      defb 26,23,0,0,0
 71+  B224 00
 72+  B225 1B 18 00 00      defb 27,24,0,0,0
 72+  B229 00
 73+  B22A 19 18 00 00      defb 25,24,0,0,0
 73+  B22E 00
 74+  B22F 18 17 00 00      defb 24,23,0,0,0
 74+  B233 00
 75+  B234 13 14 00 00      defb 19,20,0,0,0
 75+  B238 00
 76+  B239 14 12 00 00      defb 20,18,0,0,0
 76+  B23D 00
 77+  B23E 14 10 00 00      defb 20,16,0,0,0
 77+  B242 00
 78+  B243 15 10 00 00      defb 21,16,0,0,0
 78+  B247 00
 79+  B248 16 12 00 00      defb 22,18,0,0,0
 79+  B24C 00
 80+  B24D 11 14 00 00      defb 17,20,0,0,0
 80+  B251 00
 81+  B252 0D 11 00 00      defb 13,17,0,0,0
 81+  B256 00
 82+  B257 0C 13 00 00      defb 12,19,0,0,0
 82+  B25B 00
 83+  B25C 0B 13 00 00      defb 11,19,0,0,0
 83+  B260 00
 84+  B261 0A 11 00 00      defb 10,17,0,0,0
 84+  B265 00
 85+  B266 05 12 00 00      defb 5,18,0,0,0
 85+  B26A 00
 86+  B26B 07 16 00 00      defb 7,22,0,0,0
 86+  B26F 00
 87+  B270 09 17 00 00      defb 9,23,0,0,0
 87+  B274 00
 88+  B275 07 18 00 00      defb 7,24,0,0,0
 88+  B279 00
 89+  B27A 05 18 00 00      defb 5,24,0,0,0
 89+  B27E 00
 90+  B27F 06 19 00 00      defb 6,25,0,0,0
 90+  B283 00
 91+  B284 08 19 00 00      defb 8,25,0,0,0
 91+  B288 00
 92+  B289 04 17 00 00      defb 4,23,0,0,0
 92+  B28D 00
 93+  B28E FF               defb 255
 94+  B28F
 95+  B28F              level01missiles:
 96+  B28F 0B 17 00 00      defb 11,23,0,0,0
 96+  B293 00
 97+  B294 0B 16 00 00      defb 11,22,0,0,0
 97+  B298 00
 98+  B299 0C 17 00 00      defb 12,23,0,0,0
 98+  B29D 00
 99+  B29E 0C 16 00 00      defb 12,22,0,0,0
 99+  B2A2 00
100+  B2A3 0D 17 00 00      defb 13,23,0,0,0
100+  B2A7 00
101+  B2A8 0D 16 00 00      defb 13,22,0,0,0
101+  B2AC 00
102+  B2AD 0E 17 00 00      defb 14,23,0,0,0
102+  B2B1 00
103+  B2B2 0E 16 00 00      defb 14,22,0,0,0
103+  B2B6 00
104+  B2B7 0F 17 00 00      defb 15,23,0,0,0
104+  B2BB 00
105+  B2BC 0F 16 00 00      defb 15,22,0,0,0
105+  B2C0 00
106+  B2C1 10 17 00 00      defb 16,23,0,0,0
106+  B2C5 00
107+  B2C6 10 16 00 00      defb 16,22,0,0,0
107+  B2CA 00
108+  B2CB 11 17 00 00      defb 17,23,0,0,0
108+  B2CF 00
109+  B2D0 11 16 00 00      defb 17,22,0,0,0
109+  B2D4 00
110+  B2D5 12 17 00 00      defb 18,23,0,0,0
110+  B2D9 00
111+  B2DA 12 16 00 00      defb 18,22,0,0,0
111+  B2DE 00
112+  B2DF 13 17 00 00      defb 19,23,0,0,0
112+  B2E3 00
113+  B2E4 13 16 00 00      defb 19,22,0,0,0
113+  B2E8 00
114+  B2E9 14 17 00 00      defb 20,23,0,0,0
114+  B2ED 00
115+  B2EE 14 16 00 00      defb 20,22,0,0,0
115+  B2F2 00
116+  B2F3 15 17 00 00      defb 21,23,0,0,0
116+  B2F7 00
117+  B2F8 15 16 00 00      defb 21,22,0,0,0
117+  B2FC 00
118+  B2FD 16 17 00 00      defb 22,23,0,0,0
118+  B301 00
119+  B302 16 16 00 00      defb 22,22,0,0,0
119+  B306 00
120+  B307 FF               defb 255
121+  B308
122+  B308              ;
123+  B308              ; Diamonds: x,y,state,mem1+mem2
124+  B308              ;
125+  B308              level01diamonds:
126+  B308 0C 1B 00 00      defb 12,27,0,0,0
126+  B30C 00
127+  B30D 10 1B 00 00      defb 16,27,0,0,0
127+  B311 00
128+  B312 15 1B 00 00      defb 21,27,0,0,0
128+  B316 00
129+  B317 FF               defb 255
130+  B318
131+  B318              level01gems:
132+  B318 12 14 00 00      defb 18,20,0,0,0
132+  B31C 00
133+  B31D 06 18 00 00      defb 6,24,0,0,0
133+  B321 00
134+  B322 19 17 00 00      defb 25,23,0,0,0
134+  B326 00
135+  B327 1C 11 00 00      defb 28,17,0,0,0
135+  B32B 00
136+  B32C FF               defb 255
137+  B32D              ;
138+  B32D              ; Score area colours
139+  B32D              ;
140+  B32D              score_colours:
141+  B32D 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  B331 47 47 47 47
141+  B335 47 47 47 42
141+  B339 43 43 43 43
141+  B33D 43 43 43 43
141+  B341 42 47 47 47
141+  B345 47 47 47 47
141+  B349 47 47 47 47
142+  B34D 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  B351 47 47 47 47
142+  B355 47 47 47 46
142+  B359 46 46 46 46
142+  B35D 46 46 46 46
142+  B361 46 47 47 47
142+  B365 47 47 47 47
142+  B369 47 47 47 47
143+  B36D
144+  B36D              high_score_colours:
145+  B36D 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  B371 42 42 47 47
145+  B375 47 47 47 47
145+  B379 43 43 43 47
145+  B37D 47 47 47 47
145+  B381 47 46 46 46
145+  B385 47 47 47 47
145+  B389 47 47 00 00
# file closed: leveldata/level01.asm
 34   B38D                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B38D              ; Tiles graphics.
  2+  B38D              sprites:
  3+  B38D 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B391 00 00 00 00
  4+  B395 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B399 FF FF FF FF
  5+  B39D 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B3A1 1F 3F 7F FF
  6+  B3A5 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B3A9 F8 FC FE FF
  7+  B3AD 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B3B1 55 AA 55 AA
  8+  B3B5 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B3B9 00 00 00 00
  9+  B3BD FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  B3C1 FF FF FF FF
 10+  B3C5 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  B3C9 00 00 00 00
 11+  B3CD 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B3D1 F1 72 34 18
 12+  B3D5 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B3D9 FE FE FF 7E
 13+  B3DD 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B3E1 FE FF 7E 3C
 14+  B3E5 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B3E9 00 00 FF FF
 15+  B3ED 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  B3F1 FF 42 24 18
 16+  B3F5 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B3F9 00 00 00 00
 17+  B3FD 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B401 00 3C 5A 34
 18+  B405 FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  B409 FD FE FD FE
 19+  B40D F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  B411 F4 F8 F4 F8
 20+  B415 D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  B419 D0 E0 D0 E0
 21+  B41D 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  B421 40 80 40 80
 22+  B425 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  B429 ED 00 00 00
 23+  B42D 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  B431 FF 7E 3C 18
 24+  B435 FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  B439 00 00 00 00
 25+  B43D FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  B441 00 00 00 00
 26+  B445 F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  B449 00 00 00 00
 27+  B44D C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  B451 00 00 00 00
 28+  B455 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  B459 00 00 00 00
 29+  B45D FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  B461 FF FF FF FF
 30+  B465
 31+  B465
 32+  B465              sprite_attrs:
 33+  B465 46               defb    070 ; 0, space
 34+  B466 4D               defb    077 ; 1, cyan block
 35+  B467 4D               defb    077 ; 2, slope left
 36+  B468 4D               defb    077 ; 3, slope right
 37+  B469 46               defb    070 ; 4, dirt
 38+  B46A 4E               defb    078 ; 5, sky
 39+  B46B 4C               defb    076 ; 6, slime
 40+  B46C 42               defb    066 ; 7, trapdoor
 41+  B46D 46               defb    070 ; 8, diamond
 42+  B46E 42               defb    066 ; 9, rock
 43+  B46F 42               defb    066 ; 10, rock 2
 44+  B470 49           	defb    073 ; 11, sky, trapdoor
 45+  B471 43           	defb    067 ; 12, missile
 46+  B472 4A               defb    074 ; 13, sky, red ink (tank)
 47+  B473 46               defb    070 ; 14, gem
 48+  B474 4D               defb    077 ; 15, damaged mountain
 49+  B475 4D               defb    077 ; 16, damaged mountain 2
 50+  B476 4D               defb    077 ; 17, damaged mountain 3
 51+  B477 4D               defb    077 ; 18, damaged mountain 4
 52+  B478 00           	defb 	000 ; 19, tank missile (not used
 53+  B479 43           	defb    067 ; 20, missile active
 54+  B47A 42           	defb	066	; 21, the pit 1
 55+  B47B 42           	defb	066	; 22, the pit 2
 56+  B47C 42           	defb	066	; 23, the pit 3
 57+  B47D 42           	defb	066	; 24, the pit 4
 58+  B47E 42           	defb	066	; 25, the pit 5
 59+  B47F 64           	defb    100 ; 26, slime, green on green
 60+  B480
 61+  B480
 62+  B480              player_sprite:
 63+  B480 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 63+  B484 38 3D C3 80
 64+  B488 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 64+  B48C 3C 1C 16 32
 65+  B490 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 65+  B494 3C 38 68 4C
 66+  B498 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 66+  B49C 1C BC C3 01
 67+  B4A0 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 67+  B4A4 3C 3C 64 0C
 68+  B4A8 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 68+  B4AC 3C 3C 26 30
 69+  B4B0 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 69+  B4B4 1E 5C FD 5F
 70+  B4B8 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 70+  B4BC 4F 8F 19 03
 71+  B4C0 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 71+  B4C4 F2 F1 98 C0
 72+  B4C8 FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 72+  B4CC 48 08 14 2A
 73+  B4D0 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 73+  B4D4 38 78 44 C3
 74+  B4D8 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 74+  B4DC 1C 1E 22 C3
 75+  B4E0
 76+  B4E0              ;
 77+  B4E0              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 78+  B4E0              ;
 79+  B4E0              ship_sprite:
 80+  B4E0 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 80+  B4E4 03 1F 7F FF
 81+  B4E8 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 81+  B4EC FF FF FF FF
 82+  B4F0 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 82+  B4F4 FF FF FF FF
 83+  B4F8 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 83+  B4FC C0 F8 FE FF
 84+  B500 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 84+  B504 03 03 02 07
 85+  B508 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 85+  B50C FF 0F 07 83
 86+  B510 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 86+  B514 FF 10 20 C1
 87+  B518 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 87+  B51C C0 C0 40 E0
 88+  B520 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 88+  B524 03 03 02 07
 89+  B528 F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 89+  B52C FF 08 04 83
 90+  B530 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 90+  B534 FF F0 E0 C1
 91+  B538 CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 91+  B53C C0 C0 40 E0
 92+  B540
 93+  B540              ;
 94+  B540              ;  First 8 frames are tank, last frame is the gun barrel
 95+  B540              ;
 96+  B540              tank_sprite:
 97+  B540 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 97+  B544 7F 00 00 00
 98+  B548 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 98+  B54C FE FF 7F 40
 99+  B550 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 99+  B554 03 FF FF 01
100+  B558 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
100+  B55C E0 C0 00 00
101+  B560 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
101+  B564 F7 E1 7F 3F
102+  B568 FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
102+  B56C 54 16 FF FF
103+  B570 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
103+  B574 9B A8 FF FF
104+  B578 FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
104+  B57C 9F AF FE FC
105+  B580 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
105+  B584 1F 00 00 00
106+  B588
107+  B588              monster_sprite:
108+  B588 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
108+  B58C 0B D0 16 68
109+  B590 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
109+  B594 35 AC 7F FE
110+  B598 FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
110+  B59C 8F F1 8F F1
111+  B5A0 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
111+  B5A4 18 18 00 00
112+  B5A8 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  B5AC 0B D0 16 68
113+  B5B0 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
113+  B5B4 F5 AF FF FF
114+  B5B8 BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
114+  B5BC 0F F0 0F F0
115+  B5C0 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
115+  B5C4 00 00 00 00
# file closed: graphics/graphics.asm
 35   B5C8
 36   B5C8                  include "game\control.asm"
# file opened: game/control.asm
  1+  B5C8              ;
  2+  B5C8              ; Check the keyboard then move
  3+  B5C8              ;
  4+  B5C8              control_keyboard:
  5+  B5C8 3A 56 BA         ld a,(player+11)    ; first, check if player is dying
  6+  B5CB FE 00            cp 0
  7+  B5CD C0               ret nz               ; if so, can't move
  8+  B5CE 3A 50 BA         ld a,(player+5)      ; next, check if the player has pixels left to move
  9+  B5D1 FE 00            cp 0
 10+  B5D3 CA DA B5         jp z, control_keyboard5
 11+  B5D6 CD DF B6         call control_automove
 12+  B5D9 C9               ret
 13+  B5DA              control_keyboard5:
 14+  B5DA 3A 51 BA         ld a,(player+6)      ; next, check if the player is digging
 15+  B5DD FE 00            cp 0
 16+  B5DF CA E6 B5         jp z, control_keyboard0
 17+  B5E2 CD 1D B6         call control_dig
 18+  B5E5 C9               ret
 19+  B5E6              control_keyboard0:
 20+  B5E6 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 21+  B5E9 ED 78            in a,(c)            ; read keyboard.
 22+  B5EB 47               ld b,a              ; store result in b register.
 23+  B5EC CB 18            rr b                ; check outermost key (q).
 24+  B5EE D2 0D B6         jp nc,control_keyboard1
 25+  B5F1 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 26+  B5F4 ED 78            in a,(c)            ; read keyboard.
 27+  B5F6 47               ld b,a              ; store result in b register.
 28+  B5F7 CB 18            rr b                ; check outermost key (a).
 29+  B5F9 D2 11 B6         jp nc,control_keyboard2
 30+  B5FC 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 31+  B5FF ED 78            in a,(c)            ; read keyboard.
 32+  B601 47               ld b,a              ; store result in b register.
 33+  B602 CB 18            rr b                ; check outermost key (p).
 34+  B604 D2 15 B6         jp nc,control_keyboard3
 35+  B607 CB 18            rr b                ; check next key.
 36+  B609 D2 19 B6         jp nc,control_keyboard4
 37+  B60C C9               ret
 38+  B60D              control_keyboard1:
 39+  B60D CD 28 B7         call control_pl_moveup         ; player up.
 40+  B610 C9               ret
 41+  B611              control_keyboard2:
 42+  B611 CD 57 B7         call control_pl_movedown       ; player down.
 43+  B614 C9               ret
 44+  B615              control_keyboard3:
 45+  B615 CD B4 B7         call control_pl_moveright       ; player left.
 46+  B618 C9               ret
 47+  B619              control_keyboard4:
 48+  B619 CD 84 B7         call control_pl_moveleft       ; player right.
 49+  B61C C9               ret
 50+  B61D
 51+  B61D              ;
 52+  B61D              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 53+  B61D              ;
 54+  B61D              control_dig:
 55+  B61D ED 4B 4B BA      ld bc,(player)      ; load the current coords into bc
 56+  B621 C5               push bc
 57+  B622 3A 4D BA         ld a,(player+2)     ; get the direction
 58+  B625 FE 01            cp 1                ; left
 59+  B627 CA 3F B6         jp z,control_dig0
 60+  B62A FE 02            cp 2                ; right
 61+  B62C CA 54 B6         jp z,control_dig1
 62+  B62F FE 03            cp 3                ; down
 63+  B631 CA 78 B6         jp z,control_dig5
 64+  B634 FE 00            cp 0                ; up
 65+  B636 CA 68 B6         jp z,control_dig4
 66+  B639 21 51 BA         ld hl,player+6
 67+  B63C 36 00            ld (hl),0           ; turn off digging
 68+  B63E C9               ret                 ; return
 69+  B63F              control_dig0:           ; going left
 70+  B63F CD CF A9         call sprites_scadd  ; get the current coord
 71+  B642 62 6B            ld hl,de
 72+  B644 2B               dec hl              ; move one left
 73+  B645 C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
 74+  B646 78               ld a,b
 75+  B647 06 08            ld b,8
 76+  B649 90               sub b
 77+  B64A 47               ld b,a
 78+  B64B 79               ld a,c
 79+  B64C 0E 08            ld c,8
 80+  B64E 91               sub c
 81+  B64F 4F               ld c,a
 82+  B650 C5               push bc
 83+  B651 C3 81 B6         jp control_dig2
 84+  B654              control_dig1:
 85+  B654 CD CF A9         call sprites_scadd  ; get the current coord
 86+  B657 62 6B            ld hl,de
 87+  B659 23               inc hl              ; move one right
 88+  B65A C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
 89+  B65B 3E 08            ld a,8
 90+  B65D 80               add a,b
 91+  B65E 47               ld b,a
 92+  B65F 79               ld a,c
 93+  B660 0E 08            ld c,8
 94+  B662 91               sub c
 95+  B663 4F               ld c,a
 96+  B664 C5               push bc
 97+  B665 C3 81 B6         jp control_dig2
 98+  B668              control_dig4:
 99+  B668 CD CF A9         call sprites_scadd  ; get the current coord
100+  B66B 62 6B            ld hl,de
101+  B66D 11 20 00         ld de,32
102+  B670 ED 52            sbc hl,de             ; move one up
103+  B672 C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
104+  B673 0D               dec c
105+  B674 C5               push bc
106+  B675 C3 99 B6         jp control_dig6
107+  B678              control_dig5:
108+  B678 CD CF A9         call sprites_scadd  ; get the current coord
109+  B67B 62 6B            ld hl,de
110+  B67D 24               inc h              ; move one down
111+  B67E                                     ; not bothered about working out bc here, since rock will never fall if digging down
112+  B67E C3 81 B6         jp control_dig2
113+  B681              ; Normal (not up) digging
114+  B681              control_dig2:
115+  B681 3A 53 BA         ld a,(player+8)     ; get the number of rows we need to overwrite
116+  B684 47               ld b,a              ; rows to copy over
117+  B685 E5               push hl             ; store the memory location of the first row for later
118+  B686              control_dig3:
119+  B686 CD C8 B6         call control_getpixelrow
120+  B689 77               ld (hl),a           ; load contents into row
121+  B68A 11 20 00         ld de,32
122+  B68D 19               add hl,de           ; move to next row
123+  B68E 10 F6            djnz control_dig3
124+  B690 E1               pop hl              ; get the original memory location back
125+  B691 11 20 00         ld de,32
126+  B694 ED 52            sbc hl,de           ; move to above row, ready for checking for rock
127+  B696 C3 AF B6         jp control_dig10
128+  B699              ; Special case for going up
129+  B699              control_dig6:
130+  B699 3A 53 BA         ld a,(player+8)     ; get the number of rows we need to overwrite
131+  B69C 47               ld b,a              ; rows to copy over
132+  B69D              control_dig7:
133+  B69D CD C8 B6         call control_getpixelrow
134+  B6A0              control_dig12:
135+  B6A0 77               ld (hl),a           ; load empty into row
136+  B6A1 11 20 00         ld de,32
137+  B6A4 ED 52            sbc hl,de           ; move up to next row
138+  B6A6 0D               dec c               ; decrease c to track rows
139+  B6A7 10 F4            djnz control_dig7
140+  B6A9 79               ld a,c
141+  B6AA D6 07            sub 7
142+  B6AC C1               pop bc
143+  B6AD 4F               ld c,a
144+  B6AE C5               push bc             ; store the decreased c coord
145+  B6AF              control_dig10:
146+  B6AF DD 21 52 BA      ld ix,player+7
147+  B6B3 DD 7E 00         ld a,(ix)     ; get the dig frame number
148+  B6B6 3D               dec a
149+  B6B7 DD 77 00         ld (ix),a
150+  B6BA                  ; call the check for rocks above the removed dirt
151+  B6BA DD 21 51 BA      ld ix,player+6
152+  B6BE DD 7E 00         ld a,(ix)     ; get the dig state
153+  B6C1 FE 00            cp 0
154+  B6C3 C1               pop bc
155+  B6C4 CC 72 BF         call z, rocks_checkforfalling ; make the check if we're no longer digging
156+  B6C7 C9               ret
157+  B6C8
158+  B6C8              ;
159+  B6C8              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
160+  B6C8              ; Inputs:
161+  B6C8              ; hl - memory of pixel row
162+  B6C8              ; Outputs:
163+  B6C8              ; a - modified row to write
164+  B6C8              ;
165+  B6C8              control_getpixelrow:
166+  B6C8 3A 52 BA         ld a,(player+7)     ; get the dig frame number
167+  B6CB FE 00            cp 0                ; is this the last dig
168+  B6CD CA D4 B6         jp z,control_getpixelrow1
169+  B6D0 7E               ld a,(hl)           ; if not, xor with 255 to flip it
170+  B6D1 EE FF            xor 255
171+  B6D3 C9               ret
172+  B6D4              control_getpixelrow1:
173+  B6D4 DD 21 51 BA      ld ix,player+6
174+  B6D8 DD 36 00 00      ld (ix),0           ; turn off digging
175+  B6DC 3E 00            ld a,0              ; if it is, load with empty
176+  B6DE C9               ret
177+  B6DF
178+  B6DF              ;
179+  B6DF              ; Auto move the player until pixels is zero
180+  B6DF              ;
181+  B6DF              control_automove:
182+  B6DF 5F               ld e,a              ; store the number of pixels left to move in e
183+  B6E0 ED 4B 4B BA      ld bc,(player)      ; load the current coords into bc
184+  B6E4 21 4D BA         ld hl,player+2      ; get the direction
185+  B6E7 7E               ld a,(hl)
186+  B6E8 FE 03            cp 3                ; down
187+  B6EA CA FE B6         jp z,control_automove3  ; don't need to do anything
188+  B6ED FE 00            cp 0                ; going up
189+  B6EF CA 0A B7         jp z,control_automove2
190+  B6F2 FE 01            cp 1                ; going left?
191+  B6F4 CA 16 B7         jp z,control_automove0
192+  B6F7 78               ld a,b
193+  B6F8 3C               inc a               ; if we're going right, increment a twice for two pixels
194+  B6F9 3C               inc a
195+  B6FA 47               ld b,a
196+  B6FB C3 1A B7         jp control_automove1
197+  B6FE              control_automove3:
198+  B6FE 79               ld a,c
199+  B6FF 3C               inc a
200+  B700 3C               inc a               ; if we're going down, increment twice
201+  B701 4F               ld c,a
202+  B702 FE 90            cp 144
203+  B704 CC E2 B7         call z, control_scroll_down
204+  B707 C3 1A B7         jp control_automove1
205+  B70A              control_automove2:
206+  B70A 79               ld a,c
207+  B70B 3D               dec a
208+  B70C 3D               dec a               ; if we're going up, decrement twice
209+  B70D 4F               ld c,a
210+  B70E FE 60            cp 96
211+  B710 CC EF B7         call z, control_scroll_up
212+  B713 C3 1A B7         jp control_automove1
213+  B716              control_automove0:
214+  B716 78               ld a,b
215+  B717 3D               dec a               ; if we're going left, decrement a twice
216+  B718 3D               dec a
217+  B719 47               ld b,a
218+  B71A              control_automove1:
219+  B71A ED 43 4B BA      ld (player),bc      ; and back to player
220+  B71E 7B               ld a,e              ; now get the pixel count back
221+  B71F 3D               dec a               ; decrease by one
222+  B720 21 50 BA         ld hl,player+5
223+  B723 77               ld (hl),a           ; copy back
224+  B724 CD D6 BB         call player_justmoved
225+  B727 C9               ret
226+  B728
227+  B728              ;
228+  B728              ; Moves the player up
229+  B728              ;
230+  B728              control_pl_moveup:
231+  B728 C5               push bc
232+  B729 ED 4B 4B BA      ld bc,(player)          ; get the current coords, b horiz, c vert
233+  B72D 79               ld a,c                  ; load c into the acc
234+  B72E FE 18            cp 24
235+  B730 CA 50 B7         jp z,control_pl_moveup0 ; are we at the edge of the screen
236+  B733 FE 60            cp 96
237+  B735 CC EF B7         call z, control_scroll_up
238+  B738 CD 8F B9         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
239+  B73B F5               push af
240+  B73C 7B               ld a,e                  ; put e in a
241+  B73D FE 00            cp 0
242+  B73F CA 4F B7         jp z,control_pl_moveup1 ; don't move if we can't
243+  B742 F1               pop af
244+  B743 D6 01            sub 1                   ; subtract 1
245+  B745 D6 01            sub 1                   ; subtract 1
246+  B747 4F               ld c,a                  ; load back to c
247+  B748 ED 43 4B BA      ld (player),bc          ; load back to player
248+  B74C C3 50 B7         jp control_pl_moveup0
249+  B74F              control_pl_moveup1:
250+  B74F F1               pop af                  ; restore af if needed
251+  B750              control_pl_moveup0:
252+  B750 3E 00            ld a,0
253+  B752 32 4D BA         ld (player+2),a        ; set direction to up
254+  B755 C1               pop bc
255+  B756 C9               ret
256+  B757              ;
257+  B757              ; Moves the player down
258+  B757              ;
259+  B757              control_pl_movedown:
260+  B757 C5               push bc
261+  B758 ED 4B 4B BA      ld bc,(player)          ; get the current coords, b horiz, c vert
262+  B75C 79               ld a,c                  ; load c into the acc
263+  B75D FE E0            cp 224
264+  B75F CA 7D B7         jp z,control_pl_movedown0 ; are we at the edge of the screen
265+  B762 FE 80            cp 128
266+  B764 CC E2 B7         call z, control_scroll_down
267+  B767 CD 63 B9         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
268+  B76A F5               push af
269+  B76B 7B               ld a,e                  ; put e in a
270+  B76C FE 00            cp 0
271+  B76E CA 7C B7         jp z,control_pl_movedown1 ; don't move if we can't
272+  B771 F1               pop af
273+  B772 3C               inc a                   ; add 1
274+  B773 3C               inc a                   ; add 1
275+  B774 4F               ld c,a                  ; load back to c
276+  B775 ED 43 4B BA      ld (player),bc          ; load back to player
277+  B779 C3 7D B7         jp control_pl_movedown0
278+  B77C              control_pl_movedown1:
279+  B77C F1               pop af                  ; restore af if needed
280+  B77D              control_pl_movedown0:
281+  B77D 3E 03            ld a,3
282+  B77F 32 4D BA         ld (player+2),a        ; set direction to down
283+  B782 C1               pop bc
284+  B783 C9               ret
285+  B784              ;
286+  B784              ; Moves the player left
287+  B784              ;
288+  B784              control_pl_moveleft:
289+  B784 C5               push bc
290+  B785 ED 4B 4B BA      ld bc,(player)          ; get the current coords, b horiz, c vert
291+  B789 78               ld a,b                  ; load b into the acc
292+  B78A FE 10            cp 16
293+  B78C CA AD B7         jp z,control_pl_moveleft0 ; are we at the edge of the screen
294+  B78F CD EE B9         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
295+  B792 F5               push af
296+  B793 7B               ld a,e                  ; put e in a
297+  B794 FE 00            cp 0
298+  B796 CA AC B7         jp z,control_pl_moveleft1 ; don't move if we can't
299+  B799 21 50 BA         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
300+  B79C 3E 03            ld a,3
301+  B79E 77               ld (hl),a
302+  B79F F1               pop af
303+  B7A0 D6 01            sub 1                    ; subtract 2
304+  B7A2 D6 01            sub 1
305+  B7A4 47               ld b,a                  ; load back to c
306+  B7A5 ED 43 4B BA      ld (player),bc          ; load back to player
307+  B7A9 C3 AD B7         jp control_pl_moveleft0
308+  B7AC              control_pl_moveleft1:
309+  B7AC F1               pop af
310+  B7AD              control_pl_moveleft0:
311+  B7AD 3E 01            ld a,1
312+  B7AF 32 4D BA         ld (player+2),a        ; set direction to left
313+  B7B2 C1               pop bc
314+  B7B3 C9               ret
315+  B7B4              ;
316+  B7B4              ; Moves the player right
317+  B7B4              ;
318+  B7B4              control_pl_moveright:
319+  B7B4 C5               push bc
320+  B7B5 ED 4B 4B BA      ld bc,(player)          ; get the current coords, b horiz, c vert
321+  B7B9 78               ld a,b                  ; load b into the acc
322+  B7BA FE F0            cp 240
323+  B7BC CA DB B7         jp z,control_pl_moveright0 ; are we at the edge of the screen
324+  B7BF CD C2 B9         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
325+  B7C2 F5               push af
326+  B7C3 7B               ld a,e                  ; put e in a
327+  B7C4 FE 00            cp 0
328+  B7C6 CA DA B7         jp z,control_pl_moveright1 ; don't move if we can't
329+  B7C9 21 50 BA         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
330+  B7CC 3E 03            ld a,3
331+  B7CE 77               ld (hl),a
332+  B7CF F1               pop af
333+  B7D0 3C               inc a                   ; add 2
334+  B7D1 3C               inc a
335+  B7D2 47               ld b,a                  ; load back to b
336+  B7D3 ED 43 4B BA      ld (player),bc          ; load back to player
337+  B7D7 C3 DB B7         jp control_pl_moveright0
338+  B7DA              control_pl_moveright1:
339+  B7DA F1               pop af                  ; restore af if needed
340+  B7DB              control_pl_moveright0:
341+  B7DB 3E 02            ld a,2
342+  B7DD 32 4D BA         ld (player+2),a        ; set direction to right
343+  B7E0 C1               pop bc
344+  B7E1 C9               ret
345+  B7E2
346+  B7E2              ;
347+  B7E2              ; Scrolls the screen down
348+  B7E2              ;
349+  B7E2              control_scroll_down:
350+  B7E2 F5               push af
351+  B7E3 3E 08            ld a,8
352+  B7E5 32 11 A7         ld (screen_offset),a
353+  B7E8 F1               pop af
354+  B7E9 21 C3 A5         ld hl,buffer_updateall
355+  B7EC 36 01            ld (hl),1         ; flag as screen needing update
356+  B7EE C9               ret
357+  B7EF
358+  B7EF              ;
359+  B7EF              ; Scrolls the screen up
360+  B7EF              ;
361+  B7EF              control_scroll_up:
362+  B7EF F5               push af
363+  B7F0 3E 00            ld a,0
364+  B7F2 32 11 A7         ld (screen_offset),a
365+  B7F5 F1               pop af
366+  B7F6 21 C3 A5         ld hl,buffer_updateall
367+  B7F9 36 01            ld (hl),1         ; flag as screen needing update
368+  B7FB C9               ret
369+  B7FC
370+  B7FC
371+  B7FC
372+  B7FC
# file closed: game/control.asm
 37   B7FC                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  B7FC              ;
  2+  B7FC              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  3+  B7FC              ; Inputs:
  4+  B7FC              ; hl - memory location of top pixel row
  5+  B7FC              ; bc - screen coords, b horiz, c vert
  6+  B7FC              ; Outputs:
  7+  B7FC              ; e - 0 if not empty, 1 if empty
  8+  B7FC              ;
  9+  B7FC              movement_spaceisempty:
 10+  B7FC C5               push bc
 11+  B7FD E5               push hl
 12+  B7FE CD 26 B8         call movement_spaceisgem        ; check if space is a gem
 13+  B801 E1               pop hl
 14+  B802 C1               pop bc
 15+  B803 7B               ld a,e
 16+  B804 FE 01            cp 1
 17+  B806 C8               ret z                           ; if e is 1, space is a gem so can move here, return
 18+  B807 3E 08            ld a,8                          ; 8 rows to check
 19+  B809              movement_spaceisempty0:
 20+  B809 08               ex af,af'                       ; store the loop counter
 21+  B80A 7E               ld a,(hl)                       ; get current pixel row
 22+  B80B FE 00            cp 0
 23+  B80D C2 21 B8         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 24+  B810 79               ld a,c                          ; load the vertical coord
 25+  B811 3C               inc a                           ; next row down
 26+  B812 11 20 00         ld de,32
 27+  B815 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 28+  B816 4F               ld c,a                          ; copy vert coord back to c
 29+  B817 08               ex af,af'                       ; get loop counter back
 30+  B818 3D               dec a                           ; decrease loop counter
 31+  B819 C2 09 B8         jp nz, movement_spaceisempty0
 32+  B81C 16 00            ld d,0
 33+  B81E 1E 01            ld e,1                          ; got to end, so space is empty
 34+  B820 C9               ret
 35+  B821              movement_spaceisempty1:
 36+  B821 16 00            ld d,0
 37+  B823 1E 00            ld e,0                          ; returning false, ie space not empty
 38+  B825 C9               ret
 39+  B826
 40+  B826              ;
 41+  B826              ; Check if a space contains a gem
 42+  B826              ; Inputs:
 43+  B826              ; bc - screen coords
 44+  B826              ; Outputs:
 45+  B826              ; e = 1 if gem
 46+  B826              movement_spaceisgem:
 47+  B826 CD 63 A8         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 48+  B829 21 08 B3         ld hl,level01diamonds           ; check diamonds first
 49+  B82C              movement_spaceisgem0:
 50+  B82C 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 51+  B830 7B               ld a,e                          ; check for end of data
 52+  B831 FE FF            cp 255
 53+  B833 CA 4E B8         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 54+  B836 23               inc hl
 55+  B837 23               inc hl                          ; move to state
 56+  B838 7E               ld a,(hl)
 57+  B839 23               inc hl
 58+  B83A 23               inc hl
 59+  B83B 23               inc hl                          ; get to next
 60+  B83C FE 01            cp 1                            ; check if collected
 61+  B83E CA 2C B8         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 62+  B841 7B               ld a,e                          ; load e again
 63+  B842 B9               cp c                            ; otherwise, compare c with e
 64+  B843 C2 2C B8         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 65+  B846 7A               ld a,d                          ; get d coord
 66+  B847 B8               cp b                            ; compare b with d
 67+  B848 C2 2C B8         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 68+  B84B 1E 01            ld e,1                          ; otherwise, exit with e = 1
 69+  B84D C9               ret
 70+  B84E              movement_spaceisgem1:
 71+  B84E 21 18 B3         ld hl,level01gems              ; check gems
 72+  B851              movement_spaceisgem2:
 73+  B851 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 74+  B855 7B               ld a,e                          ; check for end of data
 75+  B856 FE FF            cp 255
 76+  B858 CA 73 B8         jp z,movement_spaceisgem3       ; if yes, done with gems
 77+  B85B 23               inc hl
 78+  B85C 23               inc hl                          ; move to state
 79+  B85D 7E               ld a,(hl)
 80+  B85E 23               inc hl
 81+  B85F 23               inc hl
 82+  B860 23               inc hl                          ; get to next
 83+  B861 FE 01            cp 1                            ; check if collected
 84+  B863 CA 51 B8         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 85+  B866 7B               ld a,e                          ; load e again
 86+  B867 B9               cp c                            ; otherwise, compare c with e
 87+  B868 C2 51 B8         jp nz,movement_spaceisgem2      ; if different, move to next gem
 88+  B86B 7A               ld a,d                          ; get d coord
 89+  B86C B8               cp b                            ; compare b with d
 90+  B86D C2 51 B8         jp nz,movement_spaceisgem2      ; if different, move to next gem
 91+  B870 1E 01            ld e,1                          ; otherwise, exit with e = 1
 92+  B872 C9               ret
 93+  B873              movement_spaceisgem3:
 94+  B873 1E 00            ld e,0                          ; nothing found, return e = 0
 95+  B875 C9               ret
 96+  B876
 97+  B876              ;
 98+  B876              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
 99+  B876              ; Inputs:
100+  B876              ; hl - memory location of top pixel row
101+  B876              ; bc - screen coords, b horiz, c vert
102+  B876              ; Outputs:
103+  B876              ; e - 0 if not empty, 1 if empty
104+  B876              ;
105+  B876              movement_linebelowisempty:
106+  B876 C5               push bc
107+  B877 E5               push hl
108+  B878 CD 26 B8         call movement_spaceisgem        ; check if space is a gem
109+  B87B E1               pop hl
110+  B87C C1               pop bc
111+  B87D 7B               ld a,e
112+  B87E FE 01            cp 1
113+  B880 C8               ret z                           ; if e is 1, space is a gem so can move here, return
114+  B881 7E               ld a,(hl)                       ; get current pixel row
115+  B882 FE 00            cp 0
116+  B884 C2 8C B8         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
117+  B887 16 00            ld d,0
118+  B889 1E 01            ld e,1                          ; got to end, so space is empty
119+  B88B C9               ret
120+  B88C              movement_linebelowisempty1:
121+  B88C 16 00            ld d,0
122+  B88E 1E 00            ld e,0                          ; returning false, ie space not empty
123+  B890 C9               ret
124+  B891
125+  B891              ;
126+  B891              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
127+  B891              ; Inputs:
128+  B891              ; hl - memory location of top pixel row
129+  B891              ; bc - screen coords, b horiz, c vert
130+  B891              ; Outputs:
131+  B891              ; e - 0 if not empty, 1 if empty
132+  B891              ;
133+  B891              movement_lineaboveisempty:
134+  B891 C5               push bc
135+  B892 E5               push hl
136+  B893 CD 26 B8         call movement_spaceisgem        ; check if space is a gem
137+  B896 E1               pop hl
138+  B897 C1               pop bc
139+  B898 7B               ld a,e
140+  B899 FE 01            cp 1
141+  B89B C8               ret z
142+  B89C 7E               ld a,(hl)                       ; get current pixel row
143+  B89D FE 00            cp 0
144+  B89F C2 A7 B8         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
145+  B8A2 16 00            ld d,0
146+  B8A4 1E 01            ld e,1                          ; got to end, so space is empty
147+  B8A6 C9               ret
148+  B8A7              movement_lineaboveisempty1:
149+  B8A7 16 00            ld d,0
150+  B8A9 1E 00            ld e,0                          ; returning false, ie space not empty
151+  B8AB C9               ret
152+  B8AC
153+  B8AC              ;
154+  B8AC              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
155+  B8AC              ; Inputs:
156+  B8AC              ; hl - memory location of top pixel row
157+  B8AC              ; bc - screen coords, b horiz, c vert
158+  B8AC              ; Outputs:
159+  B8AC              ; none - puts player into digging mode
160+  B8AC              ;
161+  B8AC              movement_spaceisdiggable:
162+  B8AC 3E 08            ld a,8                          ; 8 rows to check
163+  B8AE              movement_spaceisdiggable0:
164+  B8AE 08               ex af,af'                       ; store the loop counter
165+  B8AF 7E               ld a,(hl)                       ; get current pixel row
166+  B8B0 FE 00            cp 0
167+  B8B2 CA C2 B8         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
168+  B8B5 FE 55            cp 85
169+  B8B7 CA C2 B8         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
170+  B8BA FE AA            cp 170
171+  B8BC CA C2 B8         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
172+  B8BF C3 DA B8         jp movement_spaceisdiggable1     ; otherwise, stop checking
173+  B8C2              movement_spaceisdiggable2:
174+  B8C2 79               ld a,c                          ; load the vertical coord
175+  B8C3 3C               inc a                           ; next row down
176+  B8C4 11 20 00         ld de,32
177+  B8C7 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
178+  B8C8 4F               ld c,a                          ; copy vert coord back to c
179+  B8C9 08               ex af,af'                       ; get loop counter back
180+  B8CA 3D               dec a                           ; decrease loop counter
181+  B8CB C2 AE B8         jp nz, movement_spaceisdiggable0
182+  B8CE 21 51 BA         ld hl,player+6
183+  B8D1 36 01            ld (hl),1                       ; set the player into digging mode
184+  B8D3 23               inc hl
185+  B8D4 36 05            ld (hl),5                      ; set the number of frame to dig for
186+  B8D6 23               inc hl
187+  B8D7 36 08            ld (hl),8                       ; set the number of pixels to dig
188+  B8D9 C9               ret
189+  B8DA              movement_spaceisdiggable1:
190+  B8DA 21 51 BA         ld hl,player+6
191+  B8DD 36 00            ld (hl),0                       ; set the player out of digging mode
192+  B8DF C9               ret
193+  B8E0
194+  B8E0              ;
195+  B8E0              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
196+  B8E0              ; Inputs:
197+  B8E0              ; hl - memory location of top pixel row
198+  B8E0              ; bc - screen coords, b horiz, c vert
199+  B8E0              ; Outputs:
200+  B8E0              ; none - puts player into digging mode
201+  B8E0              ;
202+  B8E0              movement_spacebelowisdiggable:
203+  B8E0 7E               ld a,(hl)                       ; get first pixel row
204+  B8E1 FE 55            cp 85
205+  B8E3 CA EE B8         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
206+  B8E6 FE AA            cp 170
207+  B8E8 CA EE B8         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
208+  B8EB C3 DA B8         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
209+  B8EE              movement_spacebelowisdiggable3:
210+  B8EE 3E 08            ld a,8                          ; rows to check
211+  B8F0 1E 00            ld e,0                          ; count of rows to dig
212+  B8F2              movement_spacebelowisdiggable0:
213+  B8F2 08               ex af,af'                       ; store the loop counter
214+  B8F3 7E               ld a,(hl)                       ; get current pixel row
215+  B8F4 FE 55            cp 85
216+  B8F6 CA 01 B9         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
217+  B8F9 FE AA            cp 170
218+  B8FB CA 01 B9         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
219+  B8FE C3 10 B9         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
220+  B901              movement_spacebelowisdiggable4:
221+  B901 1C               inc e                           ; inc count of rows to dig
222+  B902              movement_spacebelowisdiggable2:
223+  B902 79               ld a,c                          ; load the vertical coord
224+  B903 3C               inc a                           ; next row down
225+  B904 D5               push de                         ; need e for later
226+  B905 11 20 00         ld de,32
227+  B908 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
228+  B909 4F               ld c,a                          ; copy vert coord back to c
229+  B90A D1               pop de                          ; get e back
230+  B90B 08               ex af,af'                       ; get loop counter back
231+  B90C 3D               dec a                           ; incease loop counter
232+  B90D C2 F2 B8         jp nz, movement_spacebelowisdiggable0
233+  B910              movement_spacebelowisdiggable5:
234+  B910 21 51 BA         ld hl,player+6
235+  B913 36 01            ld (hl),1                       ; set the player into digging mode
236+  B915 23               inc hl
237+  B916 36 03            ld (hl),3                      ; set the number of frame to dig for
238+  B918 23               inc hl
239+  B919 73               ld (hl),e                       ; set the number of pixels to dig
240+  B91A C9               ret
241+  B91B              movement_spacebelowisdiggable1:
242+  B91B 21 51 BA         ld hl,player+6
243+  B91E 36 00            ld (hl),0                       ; set the player out of digging mode
244+  B920 C9               ret
245+  B921
246+  B921              ;
247+  B921              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
248+  B921              ; Inputs:
249+  B921              ; hl - memory location of top pixel row
250+  B921              ; bc - screen coords, b horiz, c vert
251+  B921              ; Outputs:
252+  B921              ; none - puts player into digging mode
253+  B921              ;
254+  B921              movement_spaceaboveisdiggable:
255+  B921 7E               ld a,(hl)                       ; get first pixel row
256+  B922 FE 55            cp 85
257+  B924 CA 2F B9         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
258+  B927 FE AA            cp 170
259+  B929 CA 2F B9         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
260+  B92C C3 DA B8         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
261+  B92F              movement_spaceaboveisdiggable3:
262+  B92F 3E 08            ld a,8                          ; rows to check
263+  B931 1E 00            ld e,0                          ; count of rows to dig
264+  B933              movement_spaceaboveisdiggable0:
265+  B933 08               ex af,af'                       ; store the loop counter
266+  B934 7E               ld a,(hl)                       ; get current pixel row
267+  B935 FE 55            cp 85
268+  B937 CA 42 B9         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
269+  B93A FE AA            cp 170
270+  B93C CA 42 B9         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
271+  B93F C3 52 B9         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
272+  B942              movement_spaceaboveisdiggable4:
273+  B942 1C               inc e                           ; inc count of rows to dig
274+  B943              movement_spaceaboveisdiggable2:
275+  B943 79               ld a,c                          ; load the vertical coord
276+  B944 3D               dec a                           ; next row up
277+  B945 D5               push de                         ; need e for later
278+  B946 11 20 00         ld de,32
279+  B949 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
280+  B94B 4F               ld c,a                          ; copy vert coord back to c
281+  B94C D1               pop de                          ; get e back
282+  B94D 08               ex af,af'                       ; get loop counter back
283+  B94E 3D               dec a                           ; incease loop counter
284+  B94F C2 33 B9         jp nz, movement_spaceaboveisdiggable0
285+  B952              movement_spaceaboveisdiggable5:
286+  B952 21 51 BA         ld hl,player+6
287+  B955 36 01            ld (hl),1                       ; set the player into digging mode
288+  B957 23               inc hl
289+  B958 36 05            ld (hl),5                       ; set the number of frame to dig for
290+  B95A 23               inc hl
291+  B95B 73               ld (hl),e                       ; set the number of pixels to dig
292+  B95C C9               ret
293+  B95D              movement_spaceaboveisdiggable1:
294+  B95D 21 51 BA         ld hl,player+6
295+  B960 36 00            ld (hl),0                       ; set the player out of digging mode
296+  B962 C9               ret
297+  B963
298+  B963              ;
299+  B963              ; Checks if the player can move down
300+  B963              ; Inputs:
301+  B963              ; bc - player coords, b horiz, c vert
302+  B963              ; Outputs:
303+  B963              ; de - 1 can move
304+  B963              movement_checkcanmove_down:
305+  B963 F5               push af
306+  B964 C5               push bc
307+  B965 CD CF A9         call sprites_scadd              ; get the memory location of cell into de
308+  B968 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
309+  B96A 24               inc h                       ; memory location of cell beneath now in hl
310+  B96B 3E 08            ld a,8                       ; look below
311+  B96D 81               add c
312+  B96E 4F               ld c,a
313+  B96F CD 76 B8         call movement_linebelowisempty       ; check space is empty
314+  B972 7B               ld a,e                          ; check space empty flag
315+  B973 FE 00            cp 0
316+  B975 CA 7E B9         jp z, movement_checkcanmove_down1 ; can't move
317+  B978 CD D6 BB         call player_justmoved
318+  B97B C1               pop bc
319+  B97C F1               pop af
320+  B97D C9               ret
321+  B97E              movement_checkcanmove_down1:
322+  B97E C1               pop bc
323+  B97F CD CF A9         call sprites_scadd              ; get the memory location of cell into de
324+  B982 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
325+  B984 24               inc h
326+  B985 C5               push bc
327+  B986 CD E0 B8         call movement_spacebelowisdiggable    ; can't move here, but can we dig
328+  B989 11 00 00         ld de,0
329+  B98C C1               pop bc
330+  B98D F1               pop af
331+  B98E C9               ret
332+  B98F
333+  B98F              ;
334+  B98F              ; Checks if the player can move up
335+  B98F              ; Inputs:
336+  B98F              ; bc - player coords, b horiz, c vert
337+  B98F              ; Outputs:
338+  B98F              ; de - 1 can move
339+  B98F              movement_checkcanmove_up:
340+  B98F F5               push af
341+  B990 C5               push bc
342+  B991 CD CF A9         call sprites_scadd              ; get the memory location of cell into de
343+  B994 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
344+  B996 11 20 00         ld de,32
345+  B999 ED 52            sbc hl,de                       ; memory location of line above now in hl
346+  B99B 0D               dec c                           ; look above
347+  B99C CD 91 B8         call movement_lineaboveisempty       ; check space is empty
348+  B99F 7B               ld a,e                          ; check space empty flag
349+  B9A0 FE 00            cp 0
350+  B9A2 CA AD B9         jp z, movement_checkcanmove_up1 ; can't move
351+  B9A5 1E 01            ld e,1
352+  B9A7 CD D6 BB         call player_justmoved
353+  B9AA C1               pop bc
354+  B9AB F1               pop af
355+  B9AC C9               ret
356+  B9AD              movement_checkcanmove_up1:
357+  B9AD C1               pop bc
358+  B9AE CD CF A9         call sprites_scadd              ; get the memory location of cell into de
359+  B9B1 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
360+  B9B3 11 20 00         ld de,32
361+  B9B6 ED 52            sbc hl,de                       ; memory location of line above now in hl
362+  B9B8 C5               push bc
363+  B9B9 CD 21 B9         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
364+  B9BC 11 00 00         ld de,0
365+  B9BF C1               pop bc
366+  B9C0 F1               pop af
367+  B9C1 C9               ret
368+  B9C2
369+  B9C2              ;
370+  B9C2              ; Checks if the player can move right
371+  B9C2              ; Inputs:
372+  B9C2              ; bc - player coords, b horiz, c vert
373+  B9C2              ; Outputs:
374+  B9C2              ; de - 1 can move
375+  B9C2              movement_checkcanmove_right:
376+  B9C2 F5               push af
377+  B9C3 C5               push bc
378+  B9C4 CD CF A9         call sprites_scadd              ; get the memory location of cell into de
379+  B9C7 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
380+  B9C9 3E 08            ld a,8
381+  B9CB 80               add b                           ; move one cell right
382+  B9CC 47               ld b,a
383+  B9CD 23               inc hl                          ; memory location of cell to the right now in hl
384+  B9CE CD FC B7         call movement_spaceisempty       ; check space is empty
385+  B9D1 7B               ld a,e                          ; check space empty flag
386+  B9D2 FE 00            cp 0
387+  B9D4 CA DD B9         jp z, movement_checkcanmove_right1 ; can't move
388+  B9D7 CD D6 BB         call player_justmoved
389+  B9DA C1               pop bc
390+  B9DB F1               pop af
391+  B9DC C9               ret
392+  B9DD              movement_checkcanmove_right1:
393+  B9DD C1               pop bc
394+  B9DE CD CF A9         call sprites_scadd              ; get the memory location of cell into de
395+  B9E1 62 6B            ld hl,de
396+  B9E3 23               inc hl                          ; memory location of cell to the right now in hl
397+  B9E4 C5               push bc
398+  B9E5 CD AC B8         call movement_spaceisdiggable    ; can't move here, but can we dig
399+  B9E8 11 00 00         ld de,0
400+  B9EB C1               pop bc
401+  B9EC F1               pop af
402+  B9ED C9               ret
403+  B9EE
404+  B9EE              ;
405+  B9EE              ; Checks if the player can move left
406+  B9EE              ; Inputs:
407+  B9EE              ; bc - player coords, b horiz, c vert
408+  B9EE              ; Outputs:
409+  B9EE              ; de - 1 can move
410+  B9EE              movement_checkcanmove_left:
411+  B9EE F5               push af
412+  B9EF C5               push bc
413+  B9F0 CD CF A9         call sprites_scadd              ; get the memory location of cell into de
414+  B9F3 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
415+  B9F5 78               ld a,b
416+  B9F6 06 08            ld b,8
417+  B9F8 90               sub b                           ; move one cell left
418+  B9F9 47               ld b,a
419+  B9FA 2B               dec hl                          ; memory location of cell to the right now in hl
420+  B9FB CD FC B7         call movement_spaceisempty       ; check space is empty
421+  B9FE 7B               ld a,e                          ; check space empty flag
422+  B9FF FE 00            cp 0
423+  BA01 CA 0A BA         jp z, movement_checkcanmove_left1 ; can't move
424+  BA04 CD D6 BB         call player_justmoved
425+  BA07 C1               pop bc
426+  BA08 F1               pop af
427+  BA09 C9               ret
428+  BA0A              movement_checkcanmove_left1:
429+  BA0A C1               pop bc
430+  BA0B CD CF A9         call sprites_scadd              ; get the memory location of cell into de
431+  BA0E 62 6B            ld hl,de
432+  BA10 2B               dec hl                          ; memory location of cell to the right now in hl
433+  BA11 C5               push bc
434+  BA12 CD AC B8         call movement_spaceisdiggable    ; can't move here, but can we dig
435+  BA15 11 00 00         ld de,0
436+  BA18 C1               pop bc
437+  BA19 F1               pop af
438+  BA1A C9               ret
# file closed: game/movement.asm
 38   BA1B                  include "game\game.asm"
# file opened: game/game.asm
  1+  BA1B              ;
  2+  BA1B              ; The current frame count, incremented each frame
  3+  BA1B              ;
  4+  BA1B              game_framenumber:
  5+  BA1B 00               defb    0
  6+  BA1C
  7+  BA1C              ;
  8+  BA1C              ; The number of players
  9+  BA1C              ;
 10+  BA1C              game_numberplayers:
 11+  BA1C 01               defb 1
 12+  BA1D
 13+  BA1D              ;
 14+  BA1D              ; The current player
 15+  BA1D              ;
 16+  BA1D              game_currentplayer:
 17+  BA1D 01               defb 1
 18+  BA1E
 19+  BA1E              ;
 20+  BA1E              ; The default number of lives
 21+  BA1E              ;
 22+  BA1E              game_numberlives:
 23+  BA1E 04               defb 4
 24+  BA1F
 25+  BA1F              ;
 26+  BA1F              ; Moves to the next player
 27+  BA1F              ;
 28+  BA1F              game_changeplayer:
 29+  BA1F 3A 1D BA         ld a,(game_currentplayer)
 30+  BA22 FE 01            cp 1
 31+  BA24 C8               ret z                       ; if just one player, no need to change
 32+  BA25 3D               dec a                       ; otherwise decrease by one
 33+  BA26 EE 01            xor 1                       ; xor with one to flip
 34+  BA28 3C               inc a                       ; increment
 35+  BA29 21 1D BA         ld hl,game_currentplayer
 36+  BA2C 77               ld (hl),a                   ; store
 37+  BA2D C9               ret
 38+  BA2E
 39+  BA2E              ;
 40+  BA2E              ; Sets the number of players at the start of the game
 41+  BA2E              ; Inputs:
 42+  BA2E              ; a - number of players
 43+  BA2E              game_setnumberofplayers:
 44+  BA2E 21 1C BA         ld hl,game_numberplayers
 45+  BA31 77               ld (hl),a
 46+  BA32
 47+  BA32              ;
 48+  BA32              ; Increment frame number by 1
 49+  BA32              ;
 50+  BA32              game_incrementframe:
 51+  BA32 3A 1B BA         ld a,(game_framenumber)
 52+  BA35 FE FF            cp 255
 53+  BA37 C2 3C BA         jp nz,game_incrementframe0
 54+  BA3A 3E 00            ld a,0
 55+  BA3C              game_incrementframe0:
 56+  BA3C 3C               inc a
 57+  BA3D 32 1B BA         ld (game_framenumber),a
 58+  BA40 C9               ret
 59+  BA41
 60+  BA41              ;
 61+  BA41              ; Returns current frame
 62+  BA41              ; Outputs:
 63+  BA41              ; a - current frame
 64+  BA41              ;
 65+  BA41              game_getcurrentframe:
 66+  BA41 3A 1B BA         ld a,(game_framenumber)
 67+  BA44 C9               ret
 68+  BA45
 69+  BA45              ;
 70+  BA45              ; Resets current frame
 71+  BA45              ;
 72+  BA45              game_resetcurrentframe:
 73+  BA45 21 1B BA         ld hl,game_framenumber
 74+  BA48 36 00            ld (hl),0
 75+  BA4A C9               ret
# file closed: game/game.asm
 39   BA4B                  include "game\player.asm"
# file opened: game/player.asm
  1+  BA4B              ;
  2+  BA4B              ;   Data for current player
  3+  BA4B              ;
  4+  BA4B              player:
  5+  BA4B 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  BA4D 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  BA50 00               defb    0                   ; auto move remaining (+5)
  8+  BA51 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  BA54 00               defb    0                   ; lives remaining (+9)
 10+  BA55 00               defb    0                   ; died this life (+10)
 11+  BA56 00 00            defb    0,0                 ; crushed (+11), frames (+12)
 12+  BA58 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  BA59
 14+  BA59              player_location:
 15+  BA59 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 16+  BA5A
 17+  BA5A              ;
 18+  BA5A              ; Works out which part of the screen the player is in
 19+  BA5A              ; Pit is between 3,9 and 8,9
 20+  BA5A              ; Diamond cavern is between 11,22 and 22,28
 21+  BA5A              ;
 22+  BA5A              player_getlocation:
 23+  BA5A ED 4B 4B BA      ld bc,(player)              ; get screen coords
 24+  BA5E CD 63 A8         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 25+  BA61 78               ld a,b                      ; check for pit first
 26+  BA62 FE 09            cp 9                        ; if not on this row, not in the pit
 27+  BA64 C2 73 BA         jp nz,player_getlocation0
 28+  BA67 79               ld a,c                      ; check horizontal
 29+  BA68 FE 08            cp 8
 30+  BA6A D2 73 BA         jp nc, player_getlocation0  ; if more than 8, not in the pit
 31+  BA6D 21 59 BA         ld hl,player_location
 32+  BA70 36 02            ld (hl),2                   ; load location with 2, the pit
 33+  BA72 C9               ret                         ; done
 34+  BA73              player_getlocation0:            ; check for diamond cavern
 35+  BA73 78               ld a,b                      ; first check vertical
 36+  BA74 FE 16            cp 22                       ; if above row 22, then not in cavern
 37+  BA76 DA 8A BA         jp c,player_getlocation1
 38+  BA79 79               ld a,c                      ; get the horizontal next
 39+  BA7A FE 0B            cp 11
 40+  BA7C DA 8A BA         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 41+  BA7F FE 16            cp 22
 42+  BA81 D2 8A BA         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 43+  BA84 21 59 BA         ld hl,player_location
 44+  BA87 36 01            ld (hl),1                   ; load location with 1, the cavern
 45+  BA89 C9               ret
 46+  BA8A              player_getlocation1:
 47+  BA8A 21 59 BA         ld hl,player_location
 48+  BA8D 36 00            ld (hl),0                   ; load location with 2, the pit
 49+  BA8F C9               ret                         ; done
 50+  BA90
 51+  BA90
 52+  BA90              ;
 53+  BA90              ; Initializes a player at start of game
 54+  BA90              ; Copy initial coords, copy lives, copy score
 55+  BA90              ;
 56+  BA90              player_init_gamestart:
 57+  BA90 3A 1E BA         ld a,(game_numberlives)
 58+  BA93 32 1F BB         ld (player1_lives),a
 59+  BA96 32 20 BB         ld (player2_lives),a                        ; set the initial number of lives at game start
 60+  BA99
 61+  BA99 21 23 BB         ld hl,player1_score+2
 62+  BA9C 06 06            ld b,6
 63+  BA9E              player_init_gamestart0:
 64+  BA9E 36 30            ld (hl),48
 65+  BAA0 23               inc hl
 66+  BAA1 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 67+  BAA3 21 2C BB         ld hl,player2_score+2
 68+  BAA6 06 06            ld b,6
 69+  BAA8              player_init_gamestart1:
 70+  BAA8 36 30            ld (hl),48
 71+  BAAA 23               inc hl
 72+  BAAB 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 73+  BAAD C9               ret
 74+  BAAE
 75+  BAAE              ;
 76+  BAAE              ; Initializes a player at start of a life
 77+  BAAE              ; Copy initial coords, copy lives, copy score
 78+  BAAE              ;
 79+  BAAE              player_init_lifestart:
 80+  BAAE 21 50 BA         ld hl,player+5
 81+  BAB1 06 09            ld b,9                      ; initialise 9 properties
 82+  BAB3              player_init_lifestart2:
 83+  BAB3 36 00            ld (hl),0
 84+  BAB5 23               inc hl
 85+  BAB6 10 FB            djnz player_init_lifestart2
 86+  BAB8
 87+  BAB8 21 4D BA         ld hl,player+2              ; initialise some properties
 88+  BABB 36 02            ld (hl),2
 89+  BABD 23               inc hl
 90+  BABE 36 00            ld (hl),0
 91+  BAC0 23               inc hl
 92+  BAC1 36 01            ld (hl),1
 93+  BAC3
 94+  BAC3 ED 4B 22 80      ld bc,(init_coord)
 95+  BAC7 ED 43 4B BA      ld (player),bc
 96+  BACB 01 54 BA         ld bc,player+9
 97+  BACE 3A 1F BB         ld a,(player1_lives)
 98+  BAD1 02               ld (bc),a
 99+  BAD2
100+  BAD2 CD B5 C2         call diamonds_init      ; initialise gems
101+  BAD5
102+  BAD5 01 06 00         ld bc,6
103+  BAD8 11 E9 C0         ld de,scores_current+2
104+  BADB 3A 1D BA         ld a,(game_currentplayer)
105+  BADE FE 01            cp 1
106+  BAE0 C2 E9 BA         jp nz,player_init_lifestart0
107+  BAE3 21 23 BB         ld hl,player1_score+2
108+  BAE6 C3 EC BA         jp player_init_lifestart1
109+  BAE9              player_init_lifestart0:
110+  BAE9 21 2C BB         ld hl,player2_score+2
111+  BAEC              player_init_lifestart1:
112+  BAEC ED B0            ldir
113+  BAEE C9               ret
114+  BAEF
115+  BAEF              ;
116+  BAEF              ; Finalises a player at end of a life
117+  BAEF              ; Copy lives, copy score
118+  BAEF              ;
119+  BAEF              player_lifeend:
120+  BAEF 01 54 BA         ld bc,player+9
121+  BAF2 0A               ld a,(bc)
122+  BAF3 01 1F BB         ld bc,player1_lives
123+  BAF6 02               ld (bc),a
124+  BAF7 CD FB BA         call player_recordcurrentscore
125+  BAFA C9               ret
126+  BAFB
127+  BAFB              ;
128+  BAFB              ; Copies the current score in the current
129+  BAFB              ;
130+  BAFB              player_recordcurrentscore:
131+  BAFB 01 06 00         ld bc,6                  ; copy current score back to correct player
132+  BAFE 21 E9 C0         ld hl,scores_current+2
133+  BB01 3A 1D BA         ld a,(game_currentplayer)
134+  BB04 FE 01            cp 1
135+  BB06 C2 0F BB         jp nz,player_lifeend0
136+  BB09 11 23 BB         ld de,player1_score+2
137+  BB0C C3 12 BB         jp player_lifeend1
138+  BB0F              player_lifeend0:
139+  BB0F 11 2C BB         ld de,player2_score+2
140+  BB12              player_lifeend1:
141+  BB12 ED B0            ldir
142+  BB14 C9               ret
143+  BB15
144+  BB15              ;
145+  BB15              ; Player just died, subtract a life
146+  BB15              ;
147+  BB15              player_died:
148+  BB15 01 54 BA         ld bc,player+9
149+  BB18 0A               ld a,(bc)
150+  BB19 3D               dec a
151+  BB1A 02               ld (bc),a
152+  BB1B CD EF BA         call player_lifeend
153+  BB1E C9               ret
154+  BB1F
155+  BB1F              ;
156+  BB1F              ; Player lives
157+  BB1F              ;
158+  BB1F              player1_lives:
159+  BB1F 03               defb 3
160+  BB20              player2_lives:
161+  BB20 03               defb 3
162+  BB21
163+  BB21              ;
164+  BB21              ; Player scores
165+  BB21              ;
166+  BB21              player1_score:
167+  BB21 04 01 30 30      defb 4,1,'000000',255
167+  BB25 30 30 30 30
167+  BB29 FF
168+  BB2A              player2_score:
169+  BB2A 16 01 30 30      defb 22,1,'000000',255
169+  BB2E 30 30 30 30
169+  BB32 FF
170+  BB33
171+  BB33              ;
172+  BB33              ; Kills a player this life
173+  BB33              ;
174+  BB33              player_killplayer:
175+  BB33 21 55 BA         ld hl,player+10
176+  BB36 36 01            ld (hl),1
177+  BB38 C9               ret
178+  BB39
179+  BB39              ;
180+  BB39              ; Crush a player this life
181+  BB39              ;
182+  BB39              player_crushplayer:
183+  BB39 21 56 BA         ld hl,player+11             ; mark as crushed
184+  BB3C 36 01            ld (hl),1
185+  BB3E C9               ret
186+  BB3F
187+  BB3F              player_tankkillplayer
188+  BB3F 21 56 BA         ld hl,player+11             ; mark as tanked
189+  BB42 36 02            ld (hl),2
190+  BB44 C9               ret
191+  BB45
192+  BB45              player_zonkplayer
193+  BB45 21 56 BA         ld hl,player+11             ; mark as zonked (missile)
194+  BB48 36 03            ld (hl),3
195+  BB4A C9               ret
196+  BB4B
197+  BB4B              ;
198+  BB4B              ; Draws the player at the current position or deletes them
199+  BB4B              ;
200+  BB4B              player_drawplayer:
201+  BB4B 3A 4D BA         ld a,(player+2)             ; get the current direction
202+  BB4E FE 03            cp 3
203+  BB50 C2 55 BB         jp nz,player_drawplayer0
204+  BB53 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
205+  BB55              player_drawplayer0:
206+  BB55 5F               ld e,a                      ; store in e
207+  BB56 3A 56 BA         ld a,(player+11)             ; get the dying flag
208+  BB59 FE 01            cp 1
209+  BB5B CA 6D BB         jp z,player_drawplayer3     ; if it's one, we're being crushed
210+  BB5E              player_drawplayer4:
211+  BB5E 3A 51 BA         ld a,(player+6)             ; get the dig flag
212+  BB61 FE 01            cp 1
213+  BB63 CA BC BB         jp z,player_drawplayer1    ; get dig frame
214+  BB66 3A 4E BA         ld a,(player+3)             ; this is normal movement so get the current frame
215+  BB69 83               add a,e
216+  BB6A C3 C1 BB         jp player_drawplayer2
217+  BB6D              player_drawplayer3:
218+  BB6D 21 57 BA         ld hl,player+12
219+  BB70 7E               ld a,(hl)                  ; crushing, so get the current anim flag
220+  BB71 FE 00            cp 0
221+  BB73 C2 7C BB         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
222+  BB76 3E 64            ld a,100
223+  BB78 77               ld (hl),a                   ; otherwise, load up the anim frames
224+  BB79 C3 5E BB         jp player_drawplayer4       ; and return to the main loop to remove the current frame
225+  BB7C              player_drawplayer5:
226+  BB7C 3D               dec a
227+  BB7D 77               ld (hl),a
228+  BB7E FE 00            cp 0
229+  BB80 CC 33 BB         call z,player_killplayer     ; final animation, so kill the player
230+  BB83 FE 0A            cp 10                         ; play the sound
231+  BB85 CC BE AD         call z, sound_rockfell
232+  BB88 FE 14            cp 20                        ; check if we should move the rock
233+  BB8A C2 9E BB         jp nz,player_drawplayer8
234+  BB8D D9               exx
235+  BB8E 08               ex af,af'
236+  BB8F ED 4B 70 BF      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
237+  BB93 21 D5 B3         ld hl,sprites+72
238+  BB96 CD 2A A9         call sprites_drawsprite     ; draw a rock over current
239+  BB99 08               ex af,af'
240+  BB9A D9               exx
241+  BB9B C3 B5 BB         jp player_drawplayer6       ; continue drawing player
242+  BB9E              player_drawplayer8:
243+  BB9E FE 14            cp 20
244+  BBA0 D2 B5 BB         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
245+  BBA3 ED 4B 4B BA      ld bc,(player)
246+  BBA7 CD 63 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
247+  BBAA 3E 42            ld a,66             ; load red
248+  BBAC CD B2 A8         call screen_setattr
249+  BBAF 21 D5 B3         ld hl,sprites+72            ; otherwise, player is rock
250+  BBB2 C3 CB BB         jp player_drawplayer7
251+  BBB5              player_drawplayer6:
252+  BBB5 E6 01            and 1                       ; check for odd
253+  BBB7 C6 0A            add 10                      ; add 10, to get either 10 or 11
254+  BBB9 C3 C1 BB         jp player_drawplayer2
255+  BBBC              player_drawplayer1:
256+  BBBC 3A 4D BA         ld a,(player+2)             ; digging, get the current direction again, because want all four
257+  BBBF C6 06            add a,6                     ; add direction to 6 to get frame
258+  BBC1              player_drawplayer2:
259+  BBC1 07               rlca
260+  BBC2 07               rlca
261+  BBC3 07               rlca                        ; multiply by eight
262+  BBC4 6F               ld l,a
263+  BBC5 26 00            ld h,0
264+  BBC7 11 80 B4         ld de,player_sprite
265+  BBCA 19               add hl,de                   ; load hl with the location of the player sprite data
266+  BBCB              player_drawplayer7:
267+  BBCB ED 4B 4B BA      ld bc,(player)              ; load bc with the start coords
268+  BBCF CD 2A A9         call sprites_drawsprite     ; call the routine to draw the sprite
269+  BBD2 CD 02 BC         call player_storeupdatedlines ; log updated rows
270+  BBD5 C9               ret
271+  BBD6
272+  BBD6
273+  BBD6              ;
274+  BBD6              ; Runs after the player just moved. Changes animation frame if required
275+  BBD6              ;
276+  BBD6              player_justmoved:
277+  BBD6 D9               exx
278+  BBD7 3A 4F BA         ld a,(player+4)             ; get the transition count
279+  BBDA FE 00            cp 0
280+  BBDC CA E2 BB         jp z, player_justmoved2     ; if zero reset and change the frame
281+  BBDF C3 FC BB         jp player_justmoved1       ; otherwise decrease and continue
282+  BBE2              player_justmoved2:
283+  BBE2                  ; reset and change frame in here
284+  BBE2 3E 01            ld a,1
285+  BBE4 32 4F BA         ld (player+4),a            ; reset back to whatever
286+  BBE7 3A 4E BA         ld a,(player+3)             ; load the frame
287+  BBEA FE 03            cp 3                       ; flip between 3 and 0
288+  BBEC C2 F4 BB         jp nz, player_justmoved4
289+  BBEF 3E 00            ld a,0
290+  BBF1 C3 F6 BB         jp player_justmoved5
291+  BBF4              player_justmoved4:
292+  BBF4 3E 03            ld a,3
293+  BBF6              player_justmoved5:
294+  BBF6 32 4E BA         ld (player+3),a           ; save back
295+  BBF9 C3 00 BC         jp player_justmoved3
296+  BBFC              player_justmoved1:
297+  BBFC                  ; decrease count
298+  BBFC 3D               dec a
299+  BBFD 32 4F BA         ld (player+4),a
300+  BC00              player_justmoved3:
301+  BC00 D9               exx;
302+  BC01 C9               ret
303+  BC02
304+  BC02              ;
305+  BC02              ; Stores the updated rows associated with the player
306+  BC02              ;
307+  BC02              player_storeupdatedlines:
308+  BC02 ED 4B 4B BA      ld bc,(player)          ; get the screen coords into bc
309+  BC06 79               ld a,c                  ; get the player block coords of current block
310+  BC07 E6 F8            and 248                 ; find closest multiple of eight
311+  BC09 0F               rrca
312+  BC0A 0F               rrca
313+  BC0B 0F               rrca                    ; divide by 8
314+  BC0C ED 5B 11 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
315+  BC10 93               sub e
316+  BC11 F5               push af
317+  BC12 CD C4 A5         call buffer_marklineforupdate  ; store current row in updated lines
318+  BC15 F1               pop af
319+  BC16 3D               dec a
320+  BC17 F5               push af
321+  BC18 CD C4 A5         call buffer_marklineforupdate  ; store line above
322+  BC1B F1               pop af
323+  BC1C 3C               inc a
324+  BC1D 3C               inc a
325+  BC1E CD C4 A5         call buffer_marklineforupdate  ; store line beneath
326+  BC21 C9               ret
327+  BC22
328+  BC22              ;
329+  BC22              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
330+  BC22              ; Outputs:
331+  BC22              ; a - 1 for completed level
332+  BC22              player_checkforexit:
333+  BC22 ED 4B 4B BA      ld bc,(player)                 ; get player coords
334+  BC26 ED 5B 22 80      ld de,(init_coord)             ; get start coords
335+  BC2A 78               ld a,b
336+  BC2B BA               cp d                         ; compare horiz
337+  BC2C C2 37 BC         jp nz,player_checkforexit1
338+  BC2F 79               ld a,c
339+  BC30 BB               cp e                        ; compare vert
340+  BC31 C2 37 BC         jp nz,player_checkforexit1
341+  BC34              player_checkforexit0:
342+  BC34 3E 01            ld a,1                       ; hasn't completed
343+  BC36 C9               ret
344+  BC37              player_checkforexit1:
345+  BC37 3E 00            ld a,0                       ; has completed
346+  BC39 C9               ret
# file closed: game/player.asm
 40   BC3A                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  BC3A              ;
  2+  BC3A              ; Ship initial position: vert,horiz
  3+  BC3A              ;
  4+  BC3A              ship_initpos:
  5+  BC3A 00 24            defb 0,36
  6+  BC3C              ship_initpos2:
  7+  BC3C 00 00            defb 0,0
  8+  BC3E              ship_frame:
  9+  BC3E 00               defb 0
 10+  BC3F              ;
 11+  BC3F              ; The current memory location
 12+  BC3F              ;
 13+  BC3F              ship_current_sprite:
 14+  BC3F 00 00            defb 0,0
 15+  BC41
 16+  BC41              ship_current_coords:
 17+  BC41 00 00            defb 0,0
 18+  BC43
 19+  BC43              ship_process:
 20+  BC43 3A 56 BA         ld a,(player+11)
 21+  BC46 FE 02            cp 2                        ; has the player been killed by tank?
 22+  BC48 C0               ret nz                      ; do nothing if not
 23+  BC49 CD EF B7         call control_scroll_up           ; make sure the screen is on the top screen
 24+  BC4C CD BB BC         call ship_takeoff           ; bye bye
 25+  BC4F CD 33 BB         call player_killplayer      ; killed
 26+  BC52 06 32            ld b,50
 27+  BC54 CD 82 80         call utilities_pauseforframes
 28+  BC57 C9               ret
 29+  BC58
 30+  BC58              ;
 31+  BC58              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  BC58              ;
 33+  BC58              ship_land:
 34+  BC58 ED 4B 3A BC      ld bc,(ship_initpos)
 35+  BC5C ED 43 3C BC      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  BC60 1E 00            ld e,0                      ; store a flag to track first time round
 37+  BC62 06 09            ld b,9                      ; move down 8 pixels
 38+  BC64              ship_land0:
 39+  BC64 C5               push bc
 40+  BC65 7B               ld a,e
 41+  BC66 D5               push de                     ; store de for next time round
 42+  BC67 FE 01            cp 1                        ; check first time flag
 43+  BC69 C2 7E BC         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  BC6C CD 12 BD         call ship_draw_full         ; delete old one
 45+  BC6F CD E7 BC         call ship_change_frame      ; increment the frame
 46+  BC72 ED 4B 3C BC      ld bc,(ship_initpos2)       ; get the current coords
 47+  BC76 81 C6 01         add c,1                     ; move down one pixels
 48+  BC79 4F               ld c,a
 49+  BC7A ED 43 3C BC      ld (ship_initpos2),bc
 50+  BC7E              ship_land1:
 51+  BC7E CD 12 BD         call ship_draw_full         ; draw the ship
 52+  BC81 CD FC BC         call ship_draw_screen
 53+  BC84 D1               pop de
 54+  BC85 1E 01            ld e,1
 55+  BC87 C1               pop bc
 56+  BC88 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  BC8A                  ; done moving down
 58+  BC8A                  ; now move across
 59+  BC8A CD 4B BB         call player_drawplayer      ; draw player
 60+  BC8D CD 12 BD         call ship_draw_full         ; delete old one
 61+  BC90 1E 00            ld e,0                      ; store a flag to track first time round
 62+  BC92 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  BC94              ship_land3:
 64+  BC94 C5               push bc
 65+  BC95 7B               ld a,e
 66+  BC96 D5               push de                     ; store de for next time round
 67+  BC97 FE 01            cp 1                        ; check first time flag
 68+  BC99 C2 AE BC         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  BC9C CD 12 BD         call ship_draw_full         ; delete old one
 70+  BC9F CD E7 BC         call ship_change_frame      ; increment the frame
 71+  BCA2 ED 4B 3C BC      ld bc,(ship_initpos2)       ; get the current coords
 72+  BCA6 78               ld a,b
 73+  BCA7 D6 01            sub 1                       ; move back one pixels
 74+  BCA9 47               ld b,a
 75+  BCAA ED 43 3C BC      ld (ship_initpos2),bc
 76+  BCAE              ship_land2:
 77+  BCAE CD 12 BD         call ship_draw_full         ; draw the ship
 78+  BCB1 CD FC BC         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  BCB4 D1               pop de
 80+  BCB5 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  BCB7 C1               pop bc
 82+  BCB8 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  BCBA C9               ret
 84+  BCBB
 85+  BCBB              ;
 86+  BCBB              ;   Take off the ship
 87+  BCBB              ;
 88+  BCBB              ship_takeoff:
 89+  BCBB 1E 01            ld e,1                      ; store a flag to track first time round
 90+  BCBD 06 08            ld b,8                      ; move up 8 pixels
 91+  BCBF              ship_takeoff0:
 92+  BCBF C5               push bc
 93+  BCC0 7B               ld a,e
 94+  BCC1 D5               push de                     ; store de for next time round
 95+  BCC2 FE 01            cp 1                        ; check first time flag
 96+  BCC4 C2 DA BC         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  BCC7 ED 4B 3C BC      ld bc,(ship_initpos2)       ; get the current coords
 98+  BCCB CD 12 BD         call ship_draw_full         ; delete old one
 99+  BCCE CD E7 BC         call ship_change_frame      ; increment the frame
100+  BCD1 ED 4B 3C BC      ld bc,(ship_initpos2)       ; get the current coords
101+  BCD5 0D               dec c                       ; move up one pixels
102+  BCD6 ED 43 3C BC      ld (ship_initpos2),bc
103+  BCDA              ship_takeoff1:
104+  BCDA CD 12 BD         call ship_draw_full         ; draw the ship
105+  BCDD CD FC BC         call ship_draw_screen
106+  BCE0 D1               pop de
107+  BCE1 1E 01            ld e,1
108+  BCE3 C1               pop bc
109+  BCE4 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  BCE6                  ; done moving up
111+  BCE6 C9               ret
112+  BCE7
113+  BCE7              ;
114+  BCE7              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  BCE7              ;
116+  BCE7              ship_change_frame:
117+  BCE7 F5               push af
118+  BCE8 3A 3E BC         ld a,(ship_frame)
119+  BCEB FE 00            cp 0
120+  BCED CA F5 BC         jp z,ship_change_frame0
121+  BCF0 3E 00            ld a,0                      ; flip to 0
122+  BCF2 C3 F7 BC         jp ship_change_frame1
123+  BCF5              ship_change_frame0:
124+  BCF5 3E 20            ld a,32                      ; flip to 32
125+  BCF7              ship_change_frame1:
126+  BCF7 32 3E BC         ld (ship_frame),a            ; save the frame
127+  BCFA F1               pop af
128+  BCFB C9               ret
129+  BCFC
130+  BCFC              ship_draw_screen:
131+  BCFC 3E 00            ld a,0
132+  BCFE CD C4 A5         call buffer_marklineforupdate
133+  BD01 3E 01            ld a,1
134+  BD03 CD C4 A5         call buffer_marklineforupdate
135+  BD06 3E 02            ld a,2
136+  BD08 CD C4 A5         call buffer_marklineforupdate   ; mark the first three rows for update
137+  BD0B 76               halt
138+  BD0C F3               di
139+  BD0D CD 5B A6         call buffer_buffertoscreen  ; copy buffer to screen
140+  BD10 FB               ei                          ; enable interupts
141+  BD11 C9               ret
142+  BD12
143+  BD12              ship_draw_full:
144+  BD12 21 E0 B4         ld hl,ship_sprite
145+  BD15 ED 4B 3C BC      ld bc,(ship_initpos2)         ; load bc with the start coords
146+  BD19 22 3F BC         ld (ship_current_sprite),hl  ; put into memory
147+  BD1C ED 43 41 BC      ld (ship_current_coords),bc  ; put into memory
148+  BD20 CD 3F BD         call ship_draw
149+  BD23 08               ex af,af'
150+  BD24 3A 3E BC         ld a,(ship_frame)            ; get the animation frame
151+  BD27 16 00            ld d,0
152+  BD29 5F               ld e,a
153+  BD2A 19               add hl,de
154+  BD2B 22 3F BC         ld (ship_current_sprite),hl  ; put into memory
155+  BD2E 08               ex af,af'
156+  BD2F ED 4B 3C BC      ld bc,(ship_initpos2)         ; load bc with the start coords
157+  BD33 81 C6 08         add c,8                      ; move one line down
158+  BD36 4F               ld c,a
159+  BD37 ED 43 41 BC      ld (ship_current_coords),bc  ; put into memory
160+  BD3B CD 3F BD         call ship_draw
161+  BD3E C9               ret
162+  BD3F
163+  BD3F              ;
164+  BD3F              ; Draw the ship
165+  BD3F              ; Inputs:
166+  BD3F              ; None, all in memory
167+  BD3F              ;
168+  BD3F              ship_draw:
169+  BD3F 3E 04            ld a,4                              ; 4 pieces per half
170+  BD41              ship_draw0:
171+  BD41 F5               push af
172+  BD42 2A 3F BC         ld hl,(ship_current_sprite)
173+  BD45 ED 4B 41 BC      ld bc,(ship_current_coords)         ; load bc with the start coords
174+  BD49 CD 2A A9         call sprites_drawsprite
175+  BD4C 2A 3F BC         ld hl,(ship_current_sprite)
176+  BD4F ED 4B 41 BC      ld bc,(ship_current_coords)         ; load bc with the start coords
177+  BD53 11 08 00         ld de,8
178+  BD56 19               add hl,de
179+  BD57 80 C6 08         add b,8
180+  BD5A 47               ld b,a
181+  BD5B 22 3F BC         ld (ship_current_sprite),hl         ; put into memory
182+  BD5E ED 43 41 BC      ld (ship_current_coords),bc         ; put into memory
183+  BD62 F1               pop af
184+  BD63 3D               dec a
185+  BD64 FE 00            cp 0
186+  BD66 C2 41 BD         jp nz,ship_draw0
187+  BD69
188+  BD69 C9               ret
189+  BD6A
# file closed: game/ship.asm
 41   BD6A                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  BD6A              ;
  2+  BD6A              ; tank initial position: vert,horiz
  3+  BD6A              ;
  4+  BD6A              tank_initpos:
  5+  BD6A 10 D0            defb 16,208
  6+  BD6C              tank_initpos2:
  7+  BD6C 00 00            defb 0,0
  8+  BD6E              tank_frame:
  9+  BD6E 00               defb 0
 10+  BD6F              tank_anim:
 11+  BD6F 11               defb 17
 12+  BD70
 13+  BD70              ;
 14+  BD70              ; The damage countdown
 15+  BD70              ;
 16+  BD70              tank_currentdamage:
 17+  BD70 F0               defb 240
 18+  BD71
 19+  BD71              ;
 20+  BD71              ; The damage coordinate
 21+  BD71              ;
 22+  BD71              tank_currentdamagecoord:
 23+  BD71 16 02            defb 22,2
 24+  BD73
 25+  BD73              ;
 26+  BD73              ; Controls when the tank shoots
 27+  BD73              ;
 28+  BD73              tank_count:
 29+  BD73 00               defb 0
 30+  BD74
 31+  BD74              ;
 32+  BD74              ; Holds the block number of the current damage sprite
 33+  BD74              ;
 34+  BD74              tank_damageframe:
 35+  BD74 00               defb 0
 36+  BD75
 37+  BD75              ;
 38+  BD75              ; The current memory location
 39+  BD75              ;
 40+  BD75              tank_current_sprite:
 41+  BD75 00 00            defb 0,0
 42+  BD77
 43+  BD77              tank_current_coords:
 44+  BD77 00 00            defb 0,0
 45+  BD79
 46+  BD79              ;
 47+  BD79              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  BD79              ;
 49+  BD79              tank_missile_displayed:
 50+  BD79 00               defb 0
 51+  BD7A
 52+  BD7A              ;
 53+  BD7A              ; Initialise the tank
 54+  BD7A              ;
 55+  BD7A              tank_init:
 56+  BD7A ED 4B 6A BD      ld bc,(tank_initpos)
 57+  BD7E ED 43 6C BD      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  BD82 21 6E BD         ld hl,tank_frame
 59+  BD85 36 00            ld (hl),0
 60+  BD87 21 6F BD         ld hl,tank_anim
 61+  BD8A 36 11            ld (hl),17
 62+  BD8C 21 74 BD         ld hl,tank_damageframe              ; reset tank
 63+  BD8F 36 00            ld (hl),0
 64+  BD91 21 73 BD         ld hl,tank_count
 65+  BD94 36 00            ld (hl),0
 66+  BD96 21 70 BD         ld hl,tank_currentdamage
 67+  BD99 36 F0            ld (hl),240
 68+  BD9B 21 71 BD         ld hl,tank_currentdamagecoord
 69+  BD9E 36 16            ld (hl),22
 70+  BDA0 23               inc hl
 71+  BDA1 36 02            ld (hl),2
 72+  BDA3 21 79 BD         ld hl,tank_missile_displayed
 73+  BDA6 36 00            ld (hl),0
 74+  BDA8
 75+  BDA8 C9               ret
 76+  BDA9
 77+  BDA9              ;
 78+  BDA9              ;   Draw and move the tank
 79+  BDA9              ;   Start processing at frame 200
 80+  BDA9              ;   Don't move if anim is zero
 81+  BDA9              ;   Decrement frame if moved
 82+  BDA9              ;
 83+  BDA9              tank_process:
 84+  BDA9 3A 6F BD         ld a,(tank_anim)
 85+  BDAC FE 00            cp 0
 86+  BDAE C2 B5 BD         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  BDB1 CD C6 BD         call tank_fire
 88+  BDB4 C9               ret
 89+  BDB5              tank_process0:
 90+  BDB5 CD 41 BA         call game_getcurrentframe   ; get the current frame number into a
 91+  BDB8 FE 4B            cp 75
 92+  BDBA D8               ret c                       ; return if the frame number is below 100
 93+  BDBB CD DA BE         call tank_move              ; move tank if not
 94+  BDBE 3A 6F BD         ld a,(tank_anim)
 95+  BDC1 3D               dec a
 96+  BDC2 32 6F BD         ld (tank_anim),a            ; decrease the anim count
 97+  BDC5 C9               ret
 98+  BDC6
 99+  BDC6              ;
100+  BDC6              ; Fires the tank
101+  BDC6              ;
102+  BDC6              tank_fire:
103+  BDC6 3A 73 BD         ld a,(tank_count)            ; if not, don't do anything
104+  BDC9 3C               inc a                        ; increment
105+  BDCA FE 19            cp 25                        ; have we reached fifty
106+  BDCC C2 D1 BD         jp nz,tank_fire0
107+  BDCF 3E 00            ld a,0                       ; reset if reached fifty
108+  BDD1              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  BDD1 32 73 BD         ld (tank_count),a            ; store tank count
110+  BDD4 FE 00            cp 0
111+  BDD6 CA ED BD         jp z,tank_fire7              ; If this is zero, fire
112+  BDD9 3A 79 BD         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  BDDC FE 00            cp 0
114+  BDDE C8               ret z                       ; don't do anything if not
115+  BDDF CD 94 BE         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  BDE2 3E 00            ld a,0                       ; reset the flag
117+  BDE4 32 79 BD         ld (tank_missile_displayed),a
118+  BDE7 3E 02            ld a,2
119+  BDE9 CD C4 A5         call buffer_marklineforupdate
120+  BDEC C9               ret                        ; only shoot if we're on 0
121+  BDED              tank_fire7:
122+  BDED 3A 70 BD         ld a,(tank_currentdamage)    ; get the damage countdown
123+  BDF0 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
124+  BDF2 C2 28 BE         jp nz,tank_fire1            ; not, so just do a normal frame
125+  BDF5 ED 4B 71 BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
126+  BDF9 79               ld a,c
127+  BDFA FE 0A            cp 10
128+  BDFC C2 03 BE         jp nz, tank_fire6
129+  BDFF CD CC BE         call tank_killedbytank      ; we're through, so the player has died. Kill them.
130+  BE02 C9               ret                         ; return if we're through the mountain
131+  BE03              tank_fire6:
132+  BE03 3E 0F            ld a,15
133+  BE05 32 74 BD         ld (tank_damageframe),a     ; reset the damage frame
134+  BE08 21 8D B3         ld hl,sprites               ; location of the empty block
135+  BE0B CD 8D A8         call screen_showchar        ; show this character here
136+  BE0E ED 4B 71 BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
137+  BE12 05               dec b                       ; look one above
138+  BE13 CD E6 A8         call screen_ischarempty     ; check if it is empty
139+  BE16 ED 4B 71 BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
140+  BE1A FE 01            cp 1
141+  BE1C C2 5F BE         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
142+  BE1F ED 4B 71 BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
143+  BE23 0D               dec c
144+  BE24 ED 43 71 BD      ld (tank_currentdamagecoord),bc ; store the coord
145+  BE28              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
146+  BE28 ED 4B 71 BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  BE2C 3A 70 BD         ld a,(tank_currentdamage)    ; get the damage countdown
148+  BE2F E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
149+  BE31 C2 3C BE         jp nz, tank_fire5
150+  BE34 CD 16 A9         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
151+  BE37 FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
152+  BE39 C2 7D BE         jp nz,tank_fire3            ; if it's a slope, handle this differently
153+  BE3C              tank_fire5:
154+  BE3C 3A 74 BD         ld a,(tank_damageframe)
155+  BE3F CD A7 A8         call screen_getblock        ; get the block data into hl
156+  BE42 CD 8D A8         call screen_showchar        ; show this character here
157+  BE45 3A 74 BD         ld a,(tank_damageframe)
158+  BE48 3C               inc a
159+  BE49 32 74 BD         ld (tank_damageframe),a     ; increment the damage block and store
160+  BE4C 3A 70 BD         ld a,(tank_currentdamage)    ; get the damage countdown
161+  BE4F 3D               dec a
162+  BE50 3D               dec a
163+  BE51 32 70 BD         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
164+  BE54 3A 79 BD         ld a,(tank_missile_displayed) ; is the missile displaying?
165+  BE57 FE 00            cp 0
166+  BE59 CC 94 BE         call z, tank_missilegraphic
167+  BE5C C3 86 BE         jp tank_fire4
168+  BE5F              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
169+  BE5F 05               dec b
170+  BE60 C5               push bc
171+  BE61 CD FF A8         call screen_copyblockdown       ; copy the block down
172+  BE64 ED 4B 71 BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
173+  BE68 C1               pop bc                      ; get the coord we just checked back
174+  BE69 78               ld a,b
175+  BE6A FE 00            cp 0
176+  BE6C CA 28 BE         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
177+  BE6F C5               push bc
178+  BE70 05               dec b
179+  BE71 CD E6 A8         call screen_ischarempty     ; check if it is empty
180+  BE74 C1               pop bc
181+  BE75 FE 01            cp 1                        ; if empty
182+  BE77 C2 5F BE         jp nz, tank_fire2            ; copy another one down
183+  BE7A C3 28 BE         jp tank_fire1               ; otherwise, return to main thread
184+  BE7D              tank_fire3:                      ; dealing with slopes
185+  BE7D 3A 70 BD         ld a,(tank_currentdamage)    ; get the damage countdown
186+  BE80 06 08            ld b,8
187+  BE82 90               sub b                        ; special case for slopes
188+  BE83 32 70 BD         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
189+  BE86              tank_fire4:                     ; TIDY UP
190+  BE86 CD C4 A5         call buffer_marklineforupdate
191+  BE89 3E 01            ld a,1
192+  BE8B CD C4 A5         call buffer_marklineforupdate
193+  BE8E 3E 02            ld a,2
194+  BE90 CD C4 A5         call buffer_marklineforupdate
195+  BE93 C9               ret
196+  BE94
197+  BE94              ;
198+  BE94              ; Displays or hides the missile graphic, and changes the gun
199+  BE94              ;
200+  BE94              tank_missilegraphic:
201+  BE94 3A 79 BD         ld a,(tank_missile_displayed)
202+  BE97 FE 00            cp 0
203+  BE99 C2 A1 BE         jp nz,tank_missilegraphic0
204+  BE9C 3E 13            ld a,19
205+  BE9E C3 A3 BE         jp tank_missilegraphic1
206+  BEA1              tank_missilegraphic0:
207+  BEA1 3E 00            ld a,0
208+  BEA3              tank_missilegraphic1:
209+  BEA3 32 79 BD         ld (tank_missile_displayed),a ; store the flipped graphic
210+  BEA6 ED 4B 71 BD      ld bc,(tank_currentdamagecoord)
211+  BEAA 0C               inc c
212+  BEAB 0C               inc c                   ; print the graphic 2 spaces right
213+  BEAC CD A7 A8         call screen_getblock        ; get the block data into hl
214+  BEAF CD 8D A8         call screen_showchar        ; show this character here
215+  BEB2 06 02            ld b,2
216+  BEB4 0E 18            ld c,24                     ; set gunbarrel coords
217+  BEB6 11 00 00         ld de,0
218+  BEB9 21 40 B5         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
219+  BEBC 3A 79 BD         ld a,(tank_missile_displayed)
220+  BEBF FE 00            cp 0
221+  BEC1 CA C7 BE         jp z,tank_missilegraphic2
222+  BEC4 11 40 00         ld de,64
223+  BEC7              tank_missilegraphic2:
224+  BEC7 19               add hl,de                   ; work out missile graphic
225+  BEC8 CD 8D A8         call screen_showchar        ; show this character here
226+  BECB C9               ret
227+  BECC
228+  BECC              ;
229+  BECC              ; Deal with the player being killed by the tank
230+  BECC              ;
231+  BECC              tank_killedbytank:
232+  BECC ED 4B 71 BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
233+  BED0 21 8D B3         ld hl,sprites                   ; empty sprite
234+  BED3 CD 8D A8         call screen_showchar            ; hide the last piece of dirt
235+  BED6 CD 3F BB         call player_tankkillplayer
236+  BED9 C9               ret
237+  BEDA
238+  BEDA              tank_move:
239+  BEDA ED 4B 6C BD      ld bc,(tank_initpos2)
240+  BEDE C5               push bc
241+  BEDF 3A 6F BD         ld a,(tank_anim)
242+  BEE2 FE 11            cp 17                       ; check first time flag
243+  BEE4 CA F6 BE         jp z,tank_move1             ; don't draw over previous one if first time
244+  BEE7 CD FB BE         call tank_draw_full         ; delete old one
245+  BEEA ED 4B 6C BD      ld bc,(tank_initpos2)       ; get the current coords
246+  BEEE 78               ld a,b
247+  BEEF D6 01            sub 1                       ; move back one pixels
248+  BEF1 47               ld b,a
249+  BEF2 ED 43 6C BD      ld (tank_initpos2),bc
250+  BEF6              tank_move1:
251+  BEF6 CD FB BE         call tank_draw_full         ; draw the tank
252+  BEF9 C1               pop bc
253+  BEFA C9               ret
254+  BEFB
255+  BEFB              tank_draw_full:
256+  BEFB 21 40 B5         ld hl,tank_sprite
257+  BEFE ED 4B 6C BD      ld bc,(tank_initpos2)         ; load bc with the start coords
258+  BF02 22 75 BD         ld (tank_current_sprite),hl  ; put into memory
259+  BF05 ED 43 77 BD      ld (tank_current_coords),bc  ; put into memory
260+  BF09 CD 32 BF         call tank_draw
261+  BF0C 08               ex af,af'
262+  BF0D 3A 6E BD         ld a,(tank_frame)            ; get the animation frame
263+  BF10 16 00            ld d,0
264+  BF12 5F               ld e,a
265+  BF13 19               add hl,de
266+  BF14 22 75 BD         ld (tank_current_sprite),hl  ; put into memory
267+  BF17 08               ex af,af'
268+  BF18 ED 4B 6C BD      ld bc,(tank_initpos2)         ; load bc with the start coords
269+  BF1C 81 C6 08         add c,8                      ; move one line down
270+  BF1F 4F               ld c,a
271+  BF20 ED 43 77 BD      ld (tank_current_coords),bc  ; put into memory
272+  BF24 CD 32 BF         call tank_draw
273+  BF27 3E 02            ld a,2
274+  BF29 CD C4 A5         call buffer_marklineforupdate
275+  BF2C 3E 03            ld a,3
276+  BF2E CD C4 A5         call buffer_marklineforupdate   ; mark the first two rows for update
277+  BF31 C9               ret
278+  BF32
279+  BF32              ;
280+  BF32              ; Draw the tank
281+  BF32              ; Inputs:
282+  BF32              ; None, all in memory
283+  BF32              ;
284+  BF32              tank_draw:
285+  BF32 3E 04            ld a,4                              ; 4 pieces per half
286+  BF34              tank_draw0:
287+  BF34 F5               push af
288+  BF35 2A 75 BD         ld hl,(tank_current_sprite)
289+  BF38 ED 4B 77 BD      ld bc,(tank_current_coords)         ; load bc with the start coords
290+  BF3C CD 2A A9         call sprites_drawsprite
291+  BF3F 2A 75 BD         ld hl,(tank_current_sprite)
292+  BF42 ED 4B 77 BD      ld bc,(tank_current_coords)         ; load bc with the start coords
293+  BF46 11 08 00         ld de,8
294+  BF49 19               add hl,de
295+  BF4A 80 C6 08         add b,8
296+  BF4D 47               ld b,a
297+  BF4E 22 75 BD         ld (tank_current_sprite),hl         ; put into memory
298+  BF51 ED 43 77 BD      ld (tank_current_coords),bc         ; put into memory
299+  BF55 F1               pop af
300+  BF56 3D               dec a
301+  BF57 FE 00            cp 0
302+  BF59 C2 34 BF         jp nz,tank_draw0
303+  BF5C
304+  BF5C C9               ret
305+  BF5D
# file closed: game/tank.asm
 42   BF5D                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  BF5D              ;
  2+  BF5D              ; A structure of falling rocks
  3+  BF5D              ; Assume we'll never have more than 4 falling at any one time
  4+  BF5D              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  BF5D              ;
  6+  BF5D              rocks_falling:
  7+  BF5D 00 00 00 00      defb 0,0,0,0
  8+  BF61 00 00 00 00      defb 0,0,0,0
  9+  BF65 00 00 00 00      defb 0,0,0,0
 10+  BF69 00 00 00 00      defb 0,0,0,0
 11+  BF6D
 12+  BF6D              rocks_tmp:
 13+  BF6D 00               defb 0
 14+  BF6E
 15+  BF6E              rocks_tmp2:
 16+  BF6E 00 00            defb 0,0
 17+  BF70
 18+  BF70              ;
 19+  BF70              ; Coords of the rock that killed us
 20+  BF70              ;
 21+  BF70              rocks_killerrock:
 22+  BF70 00 00            defb 0,0
 23+  BF72
 24+  BF72              ;
 25+  BF72              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 26+  BF72              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 27+  BF72              ; If the pixel row is not the rock bottom, stop checking.
 28+  BF72              ; Inputs:
 29+  BF72              ; hl- memory location
 30+  BF72              ;
 31+  BF72              rocks_checkforfalling:
 32+  BF72 7E               ld a,(hl)           ; get the pixel row in this memory location
 33+  BF73 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 34+  BF75 C2 7B BF         jp nz,rocks_checkforfalling2 ; not a rock, stop
 35+  BF78 CD 7C BF         call rocks_addrocktofalling ; mark the rock as falling
 36+  BF7B              rocks_checkforfalling2:
 37+  BF7B C9               ret
 38+  BF7C
 39+  BF7C              ;
 40+  BF7C              ; Adds the rock to the structure that tracks falling rocks
 41+  BF7C              ; Inputs:
 42+  BF7C              ; hl - memory location of falling rock graphic
 43+  BF7C              ; bc - coords of rock, c vert
 44+  BF7C              rocks_addrocktofalling:
 45+  BF7C C5               push bc             ; store the coords
 46+  BF7D 11 5D BF         ld de,rocks_falling
 47+  BF80 06 04            ld b,4              ; number of possible falling rocks
 48+  BF82              rocks_addrocktofalling0:
 49+  BF82 13               inc de
 50+  BF83                  ;inc de
 51+  BF83 13               inc de              ; move three along to get the state
 52+  BF84 1A               ld a,(de)           ; load the state
 53+  BF85 FE 00            cp 0                ; check if this is not falling
 54+  BF87 C2 9D BF         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 55+  BF8A 13               inc de              ; move to frame
 56+  BF8B 3E 10            ld a,16             ; load the number of frames to wobble
 57+  BF8D 12               ld (de),a
 58+  BF8E 1B               dec de              ; move de back to state
 59+  BF8F 3E 02            ld a,2
 60+  BF91 12               ld (de),a           ; set the state to wobbling
 61+  BF92 1B               dec de              ; move back coords
 62+  BF93 C1               pop bc              ; get back coords
 63+  BF94 78               ld a,b
 64+  BF95 12               ld (de),a           ; store the vertical
 65+  BF96 1B               dec de
 66+  BF97 79               ld a,c
 67+  BF98 12               ld (de),a           ; store the horizontal
 68+  BF99 C5               push bc
 69+  BF9A C3 A1 BF         jp rocks_addrocktofalling2 ; done
 70+  BF9D              rocks_addrocktofalling1:
 71+  BF9D 13               inc de
 72+  BF9E 13               inc de              ; move memory along to next rock
 73+  BF9F 10 E1            djnz rocks_addrocktofalling0 ; try the next rock
 74+  BFA1              rocks_addrocktofalling2: ; done, return
 75+  BFA1 C1               pop bc              ; to tidy up
 76+  BFA2 C9               ret
 77+  BFA3
 78+  BFA3              ;
 79+  BFA3              ; Processes any falling rocks
 80+  BFA3              ;
 81+  BFA3              rocks_processrocks:
 82+  BFA3 DD 21 5D BF      ld ix,rocks_falling
 83+  BFA7 06 04            ld b,4              ; the number of rocks to check
 84+  BFA9              rocks_processrocks0:
 85+  BFA9 C5               push bc             ; store loop count
 86+  BFAA DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 86+  BFAE 46 01
 87+  BFB0 DD 23            inc ix
 88+  BFB2 DD 23            inc ix              ; move to the state
 89+  BFB4 DD 7E 00         ld a,(ix)           ; load the state into a
 90+  BFB7 FE 00            cp 0
 91+  BFB9 CA DD BF         jp z,rocks_processrocks3 ; if not falling, check next
 92+  BFBC FE 02            cp 2
 93+  BFBE C2 CE BF         jp nz, rocks_processrocks2
 94+  BFC1                  ; we're wobbling
 95+  BFC1 DD 23            inc ix              ; get frame number for wobble
 96+  BFC3 DD 7E 00         ld a,(ix)           ; get wobble frame into a
 97+  BFC6 CD B5 C0         call rocks_wobble
 98+  BFC9 DD 23            inc ix              ; increment for next
 99+  BFCB C3 E1 BF         jp rocks_processrocks1  ; do next rock
100+  BFCE              rocks_processrocks2:
101+  BFCE                  ; we're falling
102+  BFCE C5               push bc
103+  BFCF CD FA BF         call rocks_fall
104+  BFD2 C1               pop bc
105+  BFD3 CD E5 BF         call rocks_storeupdatedlines
106+  BFD6 DD 23            inc ix
107+  BFD8 DD 23            inc ix              ; inc ix to get to next
108+  BFDA C3 E1 BF         jp rocks_processrocks1
109+  BFDD              rocks_processrocks3:
110+  BFDD DD 23            inc ix
111+  BFDF DD 23            inc ix
112+  BFE1              rocks_processrocks1:
113+  BFE1 C1               pop bc              ; get loop count back
114+  BFE2 10 C5            djnz rocks_processrocks0
115+  BFE4 C9               ret
116+  BFE5
117+  BFE5              ;
118+  BFE5              ; Stores the updated rows associated with the rock
119+  BFE5              ; Inputs:
120+  BFE5              ; bc - coords
121+  BFE5              ;
122+  BFE5              rocks_storeupdatedlines:
123+  BFE5 79               ld a,c                  ; get the rock block coords of current block
124+  BFE6 E6 F8            and 248                 ; find closest multiple of eight
125+  BFE8 0F               rrca
126+  BFE9 0F               rrca
127+  BFEA 0F               rrca                    ; divide by 8
128+  BFEB ED 5B 11 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
129+  BFEF 93               sub e
130+  BFF0 F5               push af
131+  BFF1 CD C4 A5         call buffer_marklineforupdate  ; store current row in updated lines
132+  BFF4 F1               pop af
133+  BFF5 3C               inc a
134+  BFF6 CD C4 A5         call buffer_marklineforupdate  ; store line beneath
135+  BFF9 C9               ret
136+  BFFA
137+  BFFA              ;
138+  BFFA              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
139+  BFFA              ; bc - coord of current rock graphic on screen
140+  BFFA              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
141+  BFFA              ;
142+  BFFA              rocks_fall:
143+  BFFA DD 2B            dec ix
144+  BFFC DD 2B            dec ix              ; decrease ix back to coords
145+  BFFE ED 43 6E BF      ld (rocks_tmp2),bc  ; store original coords
146+  C002 3E 03            ld a,3              ; move this number of pixels
147+  C004              rocks_fall1:
148+  C004 32 6D BF         ld (rocks_tmp),a    ; store loop counter
149+  C007 DD 4E 00 DD      ld bc,(ix)          ; get current coords
149+  C00B 46 01
150+  C00D CD CF A9         call sprites_scadd  ; get the memory of the coords into de
151+  C010 14               inc d               ; add 256 to get next row
152+  C011 1A               ld a,(de)           ; get the contents of the next row
153+  C012 FE 00            cp 0
154+  C014 C2 74 C0         jp nz,rocks_fall3    ; move the rock if the row is empty
155+  C017 0C               inc c               ; increment the vertical
156+  C018 DD 71 00 DD      ld (ix),bc          ; store the new coords
156+  C01C 70 01
157+  C01E 79               ld a,c              ; get the vertical coord into a
158+  C01F E6 07            and 7               ; divisible by 8?
159+  C021 FE 00            cp 0
160+  C023 C2 40 C0         jp nz,rocks_fall4   ; if not, carry on
161+  C026 CD 63 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
162+  C029 3E 42            ld a,66             ; load red
163+  C02B CD B2 A8         call screen_setattr
164+  C02E DD 4E 00 DD      ld bc,(ix)
164+  C032 46 01
165+  C034 79               ld a,c              ; get vertical
166+  C035 D6 08            sub 8               ; look up one square
167+  C037 4F               ld c,a              ; put a back in c
168+  C038 CD 63 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
169+  C03B 3E 46            ld a,70             ; load yellow
170+  C03D CD B2 A8         call screen_setattr
171+  C040              rocks_fall4:
172+  C040 3A 6D BF         ld a,(rocks_tmp)    ; get the loop counter
173+  C043 3D               dec a
174+  C044 FE 00            cp 0
175+  C046 C2 04 C0         jp nz,rocks_fall1   ; do another pixel if needed
176+  C049              rocks_fall2:
177+  C049 3E 09            ld a,9              ; rock graphic
178+  C04B ED 4B 6E BF      ld bc,(rocks_tmp2)  ; get the original coords
179+  C04F CD A7 A8         call screen_getblock     ; get the memory into hl
180+  C052 CD 2A A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
181+  C055 3E 09            ld a,9
182+  C057 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
182+  C05B 46 01
183+  C05D CD A7 A8         call screen_getblock     ; get the memory into hl
184+  C060 CD 2A A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
185+  C063 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
185+  C067 46 01
186+  C069 CD 9A C0         call rocks_checkforplayer ; check to see if we hit a player
187+  C06C DD 23            inc ix
188+  C06E DD 23            inc ix                  ; get ix back to state
189+  C070 CD 8A C0         call rocks_makesound
190+  C073 C9               ret
191+  C074              rocks_fall3:
192+  C074 3E 00            ld a,0              ; set the state to fell
193+  C076 DD 77 02         ld (ix+2),a           ; store the falling state
194+  C079 DD 4E 00 DD      ld bc,(ix)          ; get the coords
194+  C07D 46 01
195+  C07F CD 63 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
196+  C082 3E 42            ld a,66             ; load magenta
197+  C084 CD B2 A8         call screen_setattr
198+  C087 C3 49 C0         jp rocks_fall2      ; rejoin main loop
199+  C08A
200+  C08A              ;
201+  C08A              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
202+  C08A              ;
203+  C08A              rocks_makesound:
204+  C08A DD 7E 00         ld a,(ix)           ; get the state
205+  C08D FE 00            cp 0
206+  C08F C0               ret nz              ; if we haven't fallen, don't do anything
207+  C090 21 56 BA         ld hl,player+11
208+  C093 7E               ld a,(hl)
209+  C094 FE 01            cp 1
210+  C096 C4 BE AD         call nz, sound_rockfell ; only make sound if didn't kill player
211+  C099 C9               ret
212+  C09A
213+  C09A              ;
214+  C09A              ; Checks to see if the rock is hitting a player
215+  C09A              ; Inputs:
216+  C09A              ; bc - coords of rock we're checking
217+  C09A              rocks_checkforplayer:
218+  C09A ED 5B 4B BA      ld de,(player)       ; get the player coords
219+  C09E 7B               ld a,e               ; get the vert coord first
220+  C09F 91               sub c                ; subtract the rock vertical coord from players
221+  C0A0 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
222+  C0A2 C0               ret nz               ; if not, hasn't hit
223+  C0A3 7A               ld a,d               ; get the player horiz coord
224+  C0A4 90               sub b                ; subtract rock coord
225+  C0A5 C6 07            add 7                ; add max distance
226+  C0A7 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
227+  C0A9 DA AD C0         jp c,rocks_checkforplayer0
228+  C0AC C9               ret
229+  C0AD              rocks_checkforplayer0:
230+  C0AD ED 43 70 BF      ld (rocks_killerrock),bc; store the coords of the killer rock
231+  C0B1 CD 39 BB         call player_crushplayer ; if so, jump out
232+  C0B4 C9               ret
233+  C0B5
234+  C0B5              ;
235+  C0B5              ; Wobbles a rocks
236+  C0B5              ; Inputs:
237+  C0B5              ; bc - coord of current rock graphic on screen
238+  C0B5              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
239+  C0B5              ; a - wobble frame
240+  C0B5              rocks_wobble:
241+  C0B5 DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
242+  C0B8 E6 01            and 1               ; is it odd or even, gets 1 or 0
243+  C0BA 1E 09            ld e,9              ; this is the rock frame
244+  C0BC 83               add a,e             ; add the frame toggle
245+  C0BD C5               push bc
246+  C0BE CD A7 A8         call screen_getblock     ; get the memory into hl
247+  C0C1 CD 2A A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
248+  C0C4
249+  C0C4 DD 7E 00         ld a,(ix)           ; get the frame toggle again
250+  C0C7 3D               dec a               ; decrease
251+  C0C8 DD 77 00         ld (ix),a           ; store
252+  C0CB
253+  C0CB E6 01            and 1
254+  C0CD 1E 09            ld e,9              ; this is the rock frame
255+  C0CF 83               add a,e             ; add the frame toggle
256+  C0D0 CD A7 A8         call screen_getblock     ; get the memory into hl
257+  C0D3
258+  C0D3 C1               pop bc
259+  C0D4 CD 2A A9         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
260+  C0D7
261+  C0D7 DD 7E 00         ld a,(ix)           ; get the wobble count back
262+  C0DA FE 00            cp 0
263+  C0DC C0               ret nz              ; if we're not at zero, return
264+  C0DD DD 2B            dec ix              ; otherwise look to state location
265+  C0DF 3E 01            ld a,1              ; set the state to falling
266+  C0E1 DD 77 00         ld (ix),a           ; store the falling state
267+  C0E4 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
268+  C0E6 C9               ret
269+  C0E7
# file closed: game/rocks.asm
 43   C0E7                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  C0E7              ;
  2+  C0E7              ; The score of the current player
  3+  C0E7              ;
  4+  C0E7              scores_current:
  5+  C0E7 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  C0EB 30 30 30 30
  5+  C0EF FF
  6+  C0F0
  7+  C0F0              scores_defaultname:
  8+  C0F0 2D 2D 2D         defb '---'
  9+  C0F3
 10+  C0F3              ;
 11+  C0F3              ; The current high score table
 12+  C0F3              ;
 13+  C0F3              scores_table:
 14+  C0F3 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  C0F7 4D 30 30 30
 14+  C0FB 30 30 30 FF
 15+  C0FF 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  C103 4D 30 30 30
 15+  C107 30 30 30 FF
 16+  C10B 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  C10F 4D 30 30 30
 16+  C113 30 30 30 FF
 17+  C117
 18+  C117              ;
 19+  C117              ; Add thousands to the score
 20+  C117              ; Inputs:
 21+  C117              ; b - number to add
 22+  C117              ;
 23+  C117              scores_addthousands:
 24+  C117 21 EB C0         ld hl,scores_current+4
 25+  C11A CD 44 C1         call scores_update
 26+  C11D C9               ret
 27+  C11E
 28+  C11E              ;
 29+  C11E              ; Prints the score to screen
 30+  C11E              ;
 31+  C11E              scores_printscore:
 32+  C11E 3A 1D BA         ld a,(game_currentplayer)   ; get current player
 33+  C121 21 E7 C0         ld hl,scores_current
 34+  C124 FE 01            cp 1
 35+  C126 C2 2E C1         jp nz, score_printscore0    ; if not player 1
 36+  C129 36 04            ld (hl),4       ; set position for player 1
 37+  C12B C3 30 C1         jp score_printscore1
 38+  C12E              score_printscore0:
 39+  C12E 36 16            ld (hl),22       ; set position for player 2
 40+  C130              score_printscore1:
 41+  C130 21 E7 C0         ld hl,scores_current
 42+  C133 CD C4 84         call string_print
 43+  C136 C9               ret
 44+  C137
 45+  C137              ;
 46+  C137              ; Prints both scores to screen
 47+  C137              ;
 48+  C137              scores_printscores:
 49+  C137 21 21 BB         ld hl,player1_score
 50+  C13A CD C4 84         call string_print
 51+  C13D 21 2A BB         ld hl,player2_score
 52+  C140 CD C4 84         call string_print
 53+  C143 C9               ret
 54+  C144
 55+  C144              ;
 56+  C144              ; Updates the current score.
 57+  C144              ; Inputs:
 58+  C144              ; hl - memory location of the score column
 59+  C144              ; b - number to add
 60+  C144              ;
 61+  C144              scores_update:
 62+  C144 7E               ld a,(hl)           ; current value of digit.
 63+  C145 80               add a,b             ; add points to this digit.
 64+  C146 77               ld (hl),a           ; place new digit back in string.
 65+  C147 FE 3A            cp 58               ; more than ASCII value '9'?
 66+  C149 D8               ret c               ; no - relax.
 67+  C14A D6 0A            sub 10              ; subtract 10.
 68+  C14C 77               ld (hl),a           ; put new character back in string.
 69+  C14D              scores_update0:
 70+  C14D 2B               dec hl              ; previous character in string.
 71+  C14E 34               inc (hl)            ; up this by one.
 72+  C14F 7E               ld a,(hl)           ; what's the new value?
 73+  C150 FE 3A            cp 58               ; gone past ASCII nine?
 74+  C152 D8               ret c               ; no, scoring done.
 75+  C153 D6 0A            sub 10              ; down by ten.
 76+  C155 77               ld (hl),a           ; put it back
 77+  C156 C3 4D C1         jp scores_update0   ; go round again.
 78+  C159
 79+  C159
 80+  C159              ;
 81+  C159              ; Displays the high score table at the bottom of the screen
 82+  C159              ;
 83+  C159              scores_showtable:
 84+  C159 21 F3 C0         ld hl, scores_table
 85+  C15C CD C4 84         call string_print
 86+  C15F 21 FF C0         ld hl, scores_table+12
 87+  C162 CD C4 84         call string_print
 88+  C165 21 0B C1         ld hl, scores_table+24
 89+  C168 CD C4 84         call string_print
 90+  C16B C9               ret
 91+  C16C
 92+  C16C              ;
 93+  C16C              ; Place to store the current position we're checking
 94+  C16C              ;
 95+  C16C              scores_highscoretmp:
 96+  C16C 00               defb 0
 97+  C16D
 98+  C16D              ;
 99+  C16D              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
100+  C16D              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
101+  C16D              ;
102+  C16D              scores_processhighscores:
103+  C16D 21 6C C1         ld hl,scores_highscoretmp
104+  C170 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
105+  C172 3E 1D            ld a,29
106+  C174              scores_processhighscores3:
107+  C174 21 F3 C0         ld hl,scores_table          ; position of first score column
108+  C177 5F               ld e,a
109+  C178 16 00            ld d,0
110+  C17A 19               add hl,de
111+  C17B 08               ex af,af'                   ; store a for later
112+  C17C 11 E9 C0         ld de,scores_current+2      ; position of current score column
113+  C17F 06 06            ld b,6                      ; times to loop
114+  C181              scores_processhighscores0:
115+  C181 7E               ld a,(hl)
116+  C182 4F               ld c,a                      ; get first score column
117+  C183 1A               ld a,(de)                   ; get first current column
118+  C184 B9               cp c                        ; compare current with first
119+  C185 DA 96 C1         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
120+  C188 23               inc hl
121+  C189 13               inc de                      ; move to next column
122+  C18A 10 F5            djnz scores_processhighscores0 ; loop
123+  C18C 08               ex af,af'                     ; still here, so must be bigger
124+  C18D 32 6C C1         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
125+  C190 0E 0C            ld c,12
126+  C192 91               sub c
127+  C193 D2 74 C1         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
128+  C196              scores_processhighscores4
129+  C196 CD 9A C1         call scores_updatehighscores
130+  C199 C9               ret
131+  C19A
132+  C19A              ;
133+  C19A              ; Update score table
134+  C19A              ;
135+  C19A              scores_updatehighscores:
136+  C19A 3A 6C C1         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
137+  C19D FE 00            cp 0
138+  C19F C8               ret z                       ; if this is 0, didn't get a high score
139+  C1A0 FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
140+  C1A2 CA D5 C1         jp z, scores_updatehighscores3
141+  C1A5                                              ; copy old score over one below, if not first
142+  C1A5 21 F3 C0         ld hl,scores_table
143+  C1A8 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
144+  C1AB 19               add hl,de                   ; position of first column
145+  C1AC 2B               dec hl
146+  C1AD 2B               dec hl
147+  C1AE 2B               dec hl
148+  C1AF E5               push hl
149+  C1B0 11 0C 00         ld de,12
150+  C1B3 19               add hl,de                   ; get position of next score
151+  C1B4 54 5D            ld de,hl
152+  C1B6 E1               pop hl                      ; get hl back
153+  C1B7 01 09 00         ld bc,9
154+  C1BA ED B0            ldir
155+  C1BC FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
156+  C1BE CA D5 C1         jp z,scores_updatehighscores3
157+  C1C1 21 F3 C0         ld hl,scores_table
158+  C1C4 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
159+  C1C7 19               add hl,de                   ; position of first column
160+  C1C8 E5               push hl
161+  C1C9 11 0C 00         ld de,12
162+  C1CC 19               add hl,de                   ; get position of next score
163+  C1CD 54 5D            ld de,hl
164+  C1CF E1               pop hl                      ; get hl back
165+  C1D0 01 09 00         ld bc,9
166+  C1D3 ED B0            ldir
167+  C1D5              scores_updatehighscores3:
168+  C1D5 06 06            ld b,6                      ; now overwrite
169+  C1D7 21 F3 C0         ld hl,scores_table
170+  C1DA 16 00            ld d,0
171+  C1DC 5F               ld e,a
172+  C1DD 19               add hl,de                   ; position of first column
173+  C1DE 08               ex af,af'
174+  C1DF 11 E9 C0         ld de,scores_current+2      ; position of current score column
175+  C1E2              scores_updatehighscores2:
176+  C1E2 1A               ld a,(de)
177+  C1E3 77               ld (hl),a
178+  C1E4 23               inc hl
179+  C1E5 13               inc de
180+  C1E6 10 FA            djnz scores_updatehighscores2
181+  C1E8 11 09 00         ld de,9
182+  C1EB ED 52            sbc hl,de
183+  C1ED 54 5D            ld de,hl                    ; get back to start of entry
184+  C1EF 21 F0 C0         ld hl,scores_defaultname    ; still need to overwrite the name
185+  C1F2 01 03 00         ld bc,3                      ; 3 chars to copy
186+  C1F5 ED B0            ldir
187+  C1F7 C9               ret
# file closed: game/scores.asm
 44   C1F8                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  C1F8              diamonds_tmp:
  2+  C1F8 00               defb 0
  3+  C1F9
  4+  C1F9              diamonds_tmp2:
  5+  C1F9 00               defb 0
  6+  C1FA
  7+  C1FA              ;
  8+  C1FA              ; Holds the number of thousands for the current gem type
  9+  C1FA              ;
 10+  C1FA              diamonds_score:
 11+  C1FA 00               defb 0
 12+  C1FB
 13+  C1FB              ;
 14+  C1FB              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  C1FB              ; Inputs:
 16+  C1FB              ; hl - memory location of gem type
 17+  C1FB              diamonds_twinkle_type:
 18+  C1FB CD 41 BA         call game_getcurrentframe       ; get current frame number
 19+  C1FE E6 07            and 7                           ; want a number from 0-7
 20+  C200 C6 40            add 64                          ; add to 60 to get attr colour
 21+  C202 32 F9 C1         ld (diamonds_tmp2),a             ; store the colour
 22+  C205              diamonds_twinkle_type0:
 23+  C205 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  C209 79               ld a,c                          ; load c into a
 25+  C20A FE FF            cp 255                          ; is this the end?
 26+  C20C CA 34 C2         jp z,diamonds_twinkle_type1           ; step out if so
 27+  C20F 23               inc hl
 28+  C210 23               inc hl
 29+  C211 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  C212 FE 01            cp 1
 31+  C214 CA 35 C2         jp z,diamonds_twinkle_type2           ; step out if so
 32+  C217 CD 75 C2         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  C21A DC 3C C2         call c,diamonds_collect     ; we collided
 34+  C21D 23               inc hl
 35+  C21E E5               push hl
 36+  C21F E5 DD E1         ld ix,hl
 37+  C222 DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  C226 46 FE
 38+  C228 3A F9 C1         ld a,(diamonds_tmp2)
 39+  C22B CD B2 A8         call screen_setattr
 40+  C22E E1               pop hl
 41+  C22F 23               inc hl
 42+  C230 23               inc hl                          ; move to next diamond
 43+  C231 C3 05 C2         jp diamonds_twinkle_type0
 44+  C234              diamonds_twinkle_type1:
 45+  C234 C9               ret
 46+  C235              diamonds_twinkle_type2:
 47+  C235 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  C236 23               inc hl
 49+  C237 23               inc hl
 50+  C238 08               ex af,af'
 51+  C239 C3 05 C2         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  C23C
 53+  C23C              ;
 54+  C23C              ; Collect the diamond we collided with
 55+  C23C              ; Inputs:
 56+  C23C              ; hl - memory location of current diamond, currently on state
 57+  C23C              ; Output:
 58+  C23C              ; a - 70 - for yellow on black
 59+  C23C              diamonds_collect:
 60+  C23C 36 01            ld (hl),1                       ; collected
 61+  C23E E5               push hl
 62+  C23F 2B               dec hl
 63+  C240 2B               dec hl
 64+  C241 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  C245 CD 73 A8         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  C248 ED 5B F8 C1      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  C24C 16 00            ld d,0
 68+  C24E 21 8D B3         ld hl,sprites
 69+  C251 19               add hl,de
 70+  C252 CD 2A A9         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  C255 E1               pop hl
 72+  C256 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  C258 32 F9 C1         ld (diamonds_tmp2),a
 74+  C25B D9               exx
 75+  C25C 3A FA C1         ld a,(diamonds_score)
 76+  C25F 47               ld b,a
 77+  C260 CD 17 C1         call scores_addthousands
 78+  C263 3A F8 C1         ld a,(diamonds_tmp)
 79+  C266 FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  C268 C2 70 C2         jp nz,diamonds_collect0
 81+  C26B 21 58 BA         ld hl,player+13
 82+  C26E 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  C270              diamonds_collect0:
 84+  C270 CD A1 AD         call sound_gemcollected
 85+  C273 D9               exx
 86+  C274 C9               ret
 87+  C275
 88+  C275              ;
 89+  C275              ; Checks to see if the gem is hitting a player
 90+  C275              ; Inputs:
 91+  C275              ; bc - coords of diamond we're checking
 92+  C275              diamonds_checkforplayer:
 93+  C275 78               ld a,b               ; multiply b by 8
 94+  C276 07               rlca
 95+  C277 07               rlca
 96+  C278 07               rlca
 97+  C279 47               ld b,a
 98+  C27A ED 5B 4B BA      ld de,(player)       ; get the player coords
 99+  C27E 7B               ld a,e               ; get the vert coord first
100+  C27F 90               sub b                ; subtract the diamond vertical coord from players
101+  C280 C6 04            add 4                ; add the max distance
102+  C282 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  C284 D0               ret nc               ; if not, hasn't hit
104+  C285 79               ld a,c               ; multiply c by 8
105+  C286 07               rlca
106+  C287 07               rlca
107+  C288 07               rlca
108+  C289 4F               ld c,a
109+  C28A 7A               ld a,d               ; get the player horiz coord
110+  C28B 91               sub c                ; subtract rock coord
111+  C28C C6 04            add 4                ; add max distance
112+  C28E FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  C290 D0               ret nc
114+  C291 3E 00            ld a,0
115+  C293 C9               ret
116+  C294
117+  C294
118+  C294              ;
119+  C294              ; Initialise diamonds and gems
120+  C294              ;
121+  C294              diamonds_twinkle
122+  C294 21 FA C1         ld hl,diamonds_score
123+  C297 36 02            ld (hl),2         ; store the score we'll add
124+  C299 21 F8 C1         ld hl,diamonds_tmp
125+  C29C 36 40            ld (hl),64         ; store the location the diamond sprite
126+  C29E 21 08 B3         ld hl, level01diamonds
127+  C2A1 CD FB C1         call diamonds_twinkle_type
128+  C2A4 21 FA C1         ld hl,diamonds_score
129+  C2A7 36 01            ld (hl),1         ; store the score we'll add
130+  C2A9 21 F8 C1         ld hl,diamonds_tmp
131+  C2AC 36 70            ld (hl),112         ; store the location the gem sprite
132+  C2AE 21 18 B3         ld hl, level01gems
133+  C2B1 CD FB C1         call diamonds_twinkle_type
134+  C2B4 C9               ret
135+  C2B5
136+  C2B5              ;
137+  C2B5              ; Initialise diamonds and gems
138+  C2B5              ;
139+  C2B5              diamonds_init:
140+  C2B5 21 08 B3         ld hl, level01diamonds
141+  C2B8 CD C2 C2         call diamonds_init_type
142+  C2BB 21 18 B3         ld hl, level01gems
143+  C2BE CD C2 C2         call diamonds_init_type
144+  C2C1 C9               ret
145+  C2C2
146+  C2C2              ;
147+  C2C2              ; Initialise diamonds or gems, get memory addresses
148+  C2C2              ; Inputs:
149+  C2C2              ; hl - memory location
150+  C2C2              diamonds_init_type:
151+  C2C2 4E               ld c,(hl)                      ; get coords into c
152+  C2C3 79               ld a,c                          ; load c into add
153+  C2C4 FE FF            cp 255                          ; is this the end?
154+  C2C6 CA DD C2         jp z,diamonds_init_type1             ; step out if so
155+  C2C9 23               inc hl
156+  C2CA 46               ld b,(hl)                       ; get coords into b
157+  C2CB E5               push hl
158+  C2CC CD 24 A8         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  C2CF E1               pop hl
160+  C2D0 23               inc hl                          ; move to state
161+  C2D1 36 00            ld (hl),0
162+  C2D3 23               inc hl                          ; move to memory
163+  C2D4 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  C2D8 23               inc hl                          ; move to next diamond
165+  C2D9 23               inc hl
166+  C2DA C3 C2 C2         jp diamonds_init_type
167+  C2DD              diamonds_init_type1:
168+  C2DD C9               ret
# file closed: game/diamonds.asm
 45   C2DE                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  C2DE              ;
  2+  C2DE              ; Controls when missiles fall
  3+  C2DE              ;
  4+  C2DE              missiles_count:
  5+  C2DE 00               defb 0
  6+  C2DF
  7+  C2DF              ;
  8+  C2DF              ; A structure of falling missiles
  9+  C2DF              ; Assume we'll never have more than 4 falling at any one time
 10+  C2DF              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  C2DF              ;
 12+  C2DF              missiles_falling:
 13+  C2DF 00 00 00         defb 0,0,0
 14+  C2E2 00 00 00         defb 0,0,0
 15+  C2E5 00 00 00         defb 0,0,0
 16+  C2E8 00 00 00         defb 0,0,0
 17+  C2EB
 18+  C2EB              ;
 19+  C2EB              ; The coords of the missile that killed us
 20+  C2EB              ;
 21+  C2EB              missiles_killermissile:
 22+  C2EB 00 00            defb 0,0
 23+  C2ED
 24+  C2ED              ;
 25+  C2ED              ; Zeroes the state of each missile
 26+  C2ED              ;
 27+  C2ED              missiles_init:
 28+  C2ED 06 0C            ld b,12
 29+  C2EF DD 21 8F B2      ld ix,level01missiles
 30+  C2F3              missiles_init0:
 31+  C2F3 DD 36 02 00      ld (ix+2),0               ; set the state to zero
 32+  C2F7 11 05 00         ld de,5
 33+  C2FA DD 19            add ix,de
 34+  C2FC DD 36 02 00      ld (ix+2),0
 35+  C300 DD 19            add ix,de
 36+  C302 10 EF            djnz missiles_init0
 37+  C304 06 04            ld b,4                  ; reset four falling missiles
 38+  C306 21 DF C2         ld hl,missiles_falling
 39+  C309              missiles_init1:
 40+  C309 36 00            ld (hl),0
 41+  C30B 23               inc hl
 42+  C30C 36 00            ld (hl),0
 43+  C30E 23               inc hl
 44+  C30F 36 00            ld (hl),0
 45+  C311 23               inc hl
 46+  C312 10 F5            djnz missiles_init1
 47+  C314 C9               ret
 48+  C315
 49+  C315              ;
 50+  C315              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 51+  C315              ; Processes any already falling missiles
 52+  C315              ;
 53+  C315              missiles_process:
 54+  C315 3A 56 BA         ld a,(player+11)                        ; check if the player was hit by a missile previously
 55+  C318 FE 03            cp 3
 56+  C31A C2 21 C3         jp nz,missiles_process3                 ; if not, continue
 57+  C31D CD 83 C4         call missiles_zonkplayer
 58+  C320 C9               ret
 59+  C321              missiles_process3:
 60+  C321 3A 59 BA         ld a,(player_location)
 61+  C324 FE 01            cp 1
 62+  C326 C2 99 C3         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 63+  C329 21 58 BA         ld hl,player+13
 64+  C32C 7E               ld a,(hl)                               ; check if player has collected a diamond
 65+  C32D FE 01            cp 1
 66+  C32F C2 99 C3         jp nz, missiles_process0                ; don't activate if not
 67+  C332 21 DE C2         ld hl,missiles_count
 68+  C335 7E               ld a,(hl)                   ; get the missiles count
 69+  C336 3C               inc a
 70+  C337 FE 32            cp 50                                   ; have we reached the count yet
 71+  C339 CA 40 C3         jp z,missiles_process2                 ; if not, don't activate a new one
 72+  C33C 77               ld (hl),a                               ; store the updated count, and continue without activating
 73+  C33D C3 99 C3         jp missiles_process0
 74+  C340              missiles_process2:
 75+  C340 36 00            ld (hl),0                               ; zero the counter
 76+  C342 1E 0C            ld e,12
 77+  C344 CD D6 80         call utilities_randomupper              ; get random number from 0 to 11
 78+  C347 11 0A 00         ld de,10
 79+  C34A CD 3A 80         call utilities_multiply                 ; multiple random number by 10
 80+  C34D 54 5D            ld de,hl                                ; this is the offset for the random missile
 81+  C34F DD 21 8F B2      ld ix,level01missiles                   ; load the location of the missile definitions
 82+  C353 DD 19            add ix,de                               ; get to location of missile
 83+  C355 DD 7E 02         ld a,(ix+2)
 84+  C358 FE 00            cp 0
 85+  C35A CA 6A C3         jp z,missiles_process1                  ; if this missile isn't active, activate it
 86+  C35D 11 05 00         ld de,5                                 ; otherwise, check the missile above
 87+  C360 DD 19            add ix,de
 88+  C362 DD 7E 02         ld a,(ix+2)
 89+  C365 FE 00            cp 0
 90+  C367 C2 99 C3         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 91+  C36A              missiles_process1:                          ; activate a missile
 92+  C36A DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
 93+  C36E DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
 93+  C372 46 01
 94+  C374 78               ld a,b
 95+  C375 ED 5B 11 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
 96+  C379 93               sub e
 97+  C37A C5               push bc
 98+  C37B CD C4 A5         call buffer_marklineforupdate
 99+  C37E C1               pop bc
100+  C37F CD 73 A8         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
101+  C382 C5               push bc
102+  C383 3E 0C            ld a,12                                 ; inactive missile sprite
103+  C385 CD A7 A8         call screen_getblock
104+  C388 CD 2A A9         call sprites_drawsprite                 ; draw the sprite over the old one
105+  C38B C1               pop bc
106+  C38C C5               push bc
107+  C38D 3E 14            ld a,20                                 ; active missile sprite
108+  C38F CD A7 A8         call screen_getblock
109+  C392 CD 2A A9         call sprites_drawsprite                 ; draw the sprite over the old one
110+  C395 C1               pop bc
111+  C396 CD 47 C4         call missiles_addmissiletofalling
112+  C399              missiles_process0:
113+  C399 CD 9D C3         call missiles_fall
114+  C39C C9               ret
115+  C39D
116+  C39D              ;
117+  C39D              ; Processes falling missiles
118+  C39D              ;
119+  C39D              missiles_fall:
120+  C39D 06 04            ld b,4              ; number of possible falling missiles
121+  C39F DD 21 DF C2      ld ix,missiles_falling
122+  C3A3              missiles_fall0:
123+  C3A3 C5               push bc
124+  C3A4 DD 7E 02         ld a,(ix+2)
125+  C3A7 FE 00            cp 0
126+  C3A9 CA 11 C4         jp z,missiles_fall1 ; not falling move to next
127+  C3AC FE 01            cp 1                ; is this ready to fall
128+  C3AE CA B4 C3         jp z, missiles_fall3
129+  C3B1 C3 2B C4         jp missiles_fall4   ; if not, decrease the countdown
130+  C3B4              missiles_fall3:
131+  C3B4 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
131+  C3B8 46 01
132+  C3BA CD CF A9         call sprites_scadd  ; get the memory of the coords into de
133+  C3BD 14               inc d               ; add 256 to get next row
134+  C3BE 1A               ld a,(de)           ; get the contents of the next row
135+  C3BF FE 00            cp 0
136+  C3C1 C2 24 C4         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
137+  C3C4 3E 14            ld a,20                                 ; active missile sprite
138+  C3C6 CD A7 A8         call screen_getblock
139+  C3C9 CD 2A A9         call sprites_drawsprite                 ; draw the sprite over the old one
140+  C3CC DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
140+  C3D0 46 01
141+  C3D2 CD 32 C4         call missiles_storeupdatedlines
142+  C3D5 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
142+  C3D9 46 01
143+  C3DB 0C               inc c               ; move down one pixel
144+  C3DC DD 71 00 DD      ld (ix),bc          ; store the new coords
144+  C3E0 70 01
145+  C3E2 3E 14            ld a,20                                 ; active missile sprite
146+  C3E4 CD A7 A8         call screen_getblock
147+  C3E7 CD 2A A9         call sprites_drawsprite                 ; draw the sprite
148+  C3EA DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
148+  C3EE 46 01
149+  C3F0 79               ld a,c              ; get the vertical coord into a
150+  C3F1 E6 07            and 7               ; divisible by 8?
151+  C3F3 FE 00            cp 0
152+  C3F5 C2 11 C4         jp nz,missiles_fall1   ; if not, carry on
153+  C3F8 CD 63 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
154+  C3FB 3E 43            ld a,67             ; load magenta
155+  C3FD CD B2 A8         call screen_setattr
156+  C400 DD 4E 00 DD      ld bc,(ix)
156+  C404 46 01
157+  C406 79               ld a,c              ; get vertical
158+  C407 D6 08            sub 8               ; look up one square
159+  C409 4F               ld c,a              ; put a back in c
160+  C40A CD 50 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
161+  C40D 62 6B            ld hl,de
162+  C40F 36 46            ld (hl),70          ; load this square with the yellow colour
163+  C411              missiles_fall1:         ; hl at state
164+  C411 DD 4E 00 DD      ld bc,(ix)          ; get coords back
164+  C415 46 01
165+  C417 CD 68 C4         call missiles_checkforplayer ; check for player
166+  C41A DD 23            inc ix
167+  C41C DD 23            inc ix
168+  C41E DD 23            inc ix              ; get to next missile
169+  C420 C1               pop bc
170+  C421 10 80            djnz missiles_fall0
171+  C423 C9               ret
172+  C424              missiles_fall2:
173+  C424 DD 36 02 00      ld (ix+2),0
174+  C428 C3 11 C4         jp missiles_fall1   ; rejoin the loop
175+  C42B              missiles_fall4:
176+  C42B 3D               dec a               ; decrease the countdown
177+  C42C DD 77 02         ld (ix+2),a         ; store back
178+  C42F C3 11 C4         jp missiles_fall1   ; do next missile
179+  C432
180+  C432              ;
181+  C432              ; Stores the updated rows associated with the missiles
182+  C432              ; Inputs:
183+  C432              ; bc - coords
184+  C432              ;
185+  C432              missiles_storeupdatedlines:
186+  C432 79               ld a,c                  ; get the missile block coords of current block
187+  C433 E6 F8            and 248                 ; find closest multiple of eight
188+  C435 0F               rrca
189+  C436 0F               rrca
190+  C437 0F               rrca                    ; divide by 8
191+  C438 ED 5B 11 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
192+  C43C 93               sub e
193+  C43D F5               push af
194+  C43E CD C4 A5         call buffer_marklineforupdate  ; store current row in updated lines
195+  C441 F1               pop af
196+  C442 3C               inc a
197+  C443 CD C4 A5         call buffer_marklineforupdate  ; store line beneath
198+  C446 C9               ret
199+  C447
200+  C447              ;
201+  C447              ; Adds the missile to the structure that tracks falling missile
202+  C447              ; Inputs:
203+  C447              ; bc - coords of missile, c vert
204+  C447              missiles_addmissiletofalling:
205+  C447 C5               push bc             ; store the coords
206+  C448 11 DF C2         ld de,missiles_falling
207+  C44B 06 04            ld b,4              ; number of possible falling missiles
208+  C44D              missiles_addmissiletofalling0:
209+  C44D 13               inc de
210+  C44E 13               inc de              ; move three along to get the state
211+  C44F 1A               ld a,(de)           ; load the state
212+  C450 FE 00            cp 0                ; check if this is not falling
213+  C452 C2 63 C4         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
214+  C455 3E 19            ld a,25
215+  C457 12               ld (de),a           ; set the state to pre-falling
216+  C458 1B               dec de              ; move back coords
217+  C459 C1               pop bc              ; get back coords
218+  C45A 78               ld a,b
219+  C45B 12               ld (de),a           ; store the vertical
220+  C45C 1B               dec de
221+  C45D 79               ld a,c
222+  C45E 12               ld (de),a           ; store the horizontal
223+  C45F C5               push bc
224+  C460 C3 66 C4         jp missiles_addmissiletofalling2 ; done
225+  C463              missiles_addmissiletofalling1:
226+  C463 13               inc de              ; move memory along to next rock
227+  C464 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
228+  C466              missiles_addmissiletofalling2: ; done, return
229+  C466 C1               pop bc              ; to tidy up
230+  C467 C9               ret
231+  C468
232+  C468              ;
233+  C468              ; Checks to see if the missile is hitting a player
234+  C468              ; Inputs:
235+  C468              ; bc - coords of missile we're checking
236+  C468              missiles_checkforplayer:
237+  C468 ED 5B 4B BA      ld de,(player)       ; get the player coords
238+  C46C 7B               ld a,e               ; get the vert coord first
239+  C46D 91               sub c                ; subtract the missile vertical coord from players
240+  C46E FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
241+  C470 C0               ret nz               ; if not, hasn't hit
242+  C471 7A               ld a,d               ; get the player horiz coord
243+  C472 90               sub b                ; subtract missile coord
244+  C473 C6 07            add 7                ; add max distance
245+  C475 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
246+  C477 DA 7B C4         jp c,missiles_checkforplayer0
247+  C47A C9               ret
248+  C47B              missiles_checkforplayer0:
249+  C47B ED 43 EB C2      ld (missiles_killermissile),bc; store the coords of the killer missile
250+  C47F CD 45 BB         call player_zonkplayer ; if so, jump out
251+  C482 C9               ret
252+  C483
253+  C483              ;
254+  C483              ; Player has been hit, so draw text over them and mark as dead
255+  C483              ;
256+  C483              missiles_zonkplayer:
257+  C483 CD 33 BB         call player_killplayer      ; mark as dead
258+  C486 ED 4B 4B BA      ld bc,(player)              ; get player coords
259+  C48A CD 63 A8         call screen_getcharcoordsfromscreencoords ; get char coords
260+  C48D 0D               dec c
261+  C48E 0D               dec c
262+  C48F C5               push bc
263+  C490 CD 0C A8         call screen_getcellattradress ; attrs here
264+  C493 06 05            ld b,5
265+  C495 3E 42            ld a,66
266+  C497 CD C6 A7         call screen_setcolours
267+  C49A CD 5B A6         call buffer_buffertoscreen  ; copy buffer to screen
268+  C49D C1               pop bc
269+  C49E ED 5B 11 A7      ld de,(screen_offset)
270+  C4A2 78               ld a,b
271+  C4A3 93               sub e
272+  C4A4 47               ld b,a                      ; subtract the offset
273+  C4A5 04               inc b
274+  C4A6 04               inc b                       ; add two for the score rows
275+  C4A7 ED 43 BC 84      ld (string_zonk),bc         ; set coords of string
276+  C4AB 21 BC 84         ld hl,string_zonk
277+  C4AE CD C4 84         call string_print
278+  C4B1 06 14            ld b,20
279+  C4B3 CD 82 80         call utilities_pauseforframes ; pause
280+  C4B6 C9               ret
281+  C4B7
# file closed: game/missiles.asm
 46   C4B7                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  C4B7              ;
  2+  C4B7              ; Timer for deciding how fast the trap withdraws
  3+  C4B7              ;
  4+  C4B7              thepit_timer:
  5+  C4B7 00               defb 0
  6+  C4B8
  7+  C4B8              ;
  8+  C4B8              ; Ticks for the trap state. Will count to 3 then reset
  9+  C4B8              ;
 10+  C4B8              thepit_trapcount:
 11+  C4B8 00               defb 0
 12+  C4B9
 13+  C4B9              ;
 14+  C4B9              ; The horizontal coordinate of the current pit trap
 15+  C4B9              ;
 16+  C4B9              thepit_trapcoord:
 17+  C4B9 08               defb 8
 18+  C4BA
 19+  C4BA              ;
 20+  C4BA              ; Initialises the pit
 21+  C4BA              ;
 22+  C4BA              thepit_init:
 23+  C4BA 21 B9 C4         ld hl,thepit_trapcoord
 24+  C4BD 36 08            ld (hl),8
 25+  C4BF 21 B8 C4         ld hl,thepit_trapcount
 26+  C4C2 36 00            ld (hl),0
 27+  C4C4 C9               ret
 28+  C4C5
 29+  C4C5              ;
 30+  C4C5              ; Performs per frame processing on the pit room
 31+  C4C5              ;
 32+  C4C5              thepit_process:
 33+  C4C5 3A 59 BA         ld a,(player_location)
 34+  C4C8 FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 35+  C4CA C2 0E C5         jp nz,thepit_process0
 36+  C4CD 3A B7 C4         ld a,(thepit_timer)             ; get the timer
 37+  C4D0 3C               inc a
 38+  C4D1 32 B7 C4         ld (thepit_timer),a             ; store
 39+  C4D4 FE 02            cp 2                           ; have we reached the trigger?
 40+  C4D6 C2 0E C5         jp nz, thepit_process0          ; no need to do anything
 41+  C4D9 3E 00            ld a,0
 42+  C4DB 32 B7 C4         ld (thepit_timer),a             ; zero the timer and process
 43+  C4DE 3A B8 C4         ld a,(thepit_trapcount)         ; get the current count
 44+  C4E1 3C               inc a
 45+  C4E2 32 B8 C4         ld (thepit_trapcount),a         ; reset the trap count
 46+  C4E5 FE 04            cp 4                            ; do we need to begin another character?
 47+  C4E7 C2 F6 C4         jp nz,thepit_process1           ; if not, draw as normal
 48+  C4EA 3E 00            ld a,0
 49+  C4EC 32 B8 C4         ld (thepit_trapcount),a         ; reset the trap count
 50+  C4EF 3A B9 C4         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 51+  C4F2 3D               dec a
 52+  C4F3 32 B9 C4         ld (thepit_trapcoord),a         ; store the reduced coord
 53+  C4F6
 54+  C4F6              thepit_process1:                    ; draw the trapdoor in current position
 55+  C4F6 3A B9 C4         ld a,(thepit_trapcoord)
 56+  C4F9 FE 02            cp 2
 57+  C4FB CA 0E C5         jp z, thepit_process0           ; don't process outside of the pit
 58+  C4FE 4F               ld c,a
 59+  C4FF 06 0A            ld b,10                         ; vertical coord will always be the same
 60+  C501 3A B8 C4         ld a,(thepit_trapcount)         ; get the trap count
 61+  C504 5F               ld e,a                          ; store in e
 62+  C505 3E 16            ld a,22                         ; 21 is full trapdoor
 63+  C507 83               add a,e
 64+  C508 CD A7 A8         call screen_getblock
 65+  C50B CD 8D A8         call screen_showchar            ; show the char
 66+  C50E
 67+  C50E              thepit_process0:
 68+  C50E C9               ret
 69+  C50F
# file closed: game/thepit.asm
 47   C50F                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  C50F
  2+  C50F              ;
  3+  C50F              ; Where the monster currently is
  4+  C50F              ;
  5+  C50F              monster_currentcoords:
  6+  C50F 00 00            defb 0,0
  7+  C511
  8+  C511              ;
  9+  C511              ; The start coords of the monster
 10+  C511              ;
 11+  C511              monster_initcoords:
 12+  C511 70 20            defb 112,32
 13+  C513
 14+  C513              ;
 15+  C513              ; Store the memory location of the current jump position
 16+  C513              ;
 17+  C513              monster_jumppos:
 18+  C513 00 00            defb 0,0
 19+  C515
 20+  C515              ;
 21+  C515              ; The jump table for the monster.
 22+  C515              ;
 23+  C515              monster_jumptable:
 24+  C515 FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  C519 02 02 02 02
 24+  C51D 02 02 01 01
 24+  C521 01 01 01 01
 24+  C525 FF
 25+  C526
 26+  C526              ;
 27+  C526              ; The vertical direction: 0 up, 1 down
 28+  C526              ;
 29+  C526              monster_jumpdirectionvert:
 30+  C526 00               defb 0
 31+  C527
 32+  C527
 33+  C527              ;
 34+  C527              ; Initialises the pit monster
 35+  C527              ;
 36+  C527              monster_init:
 37+  C527 ED 4B 11 C5      ld bc,(monster_initcoords)              ; load the initial coords
 38+  C52B ED 43 0F C5      ld (monster_currentcoords),bc           ; save in current coords
 39+  C52F 21 16 C5         ld hl,monster_jumptable+1
 40+  C532 22 13 C5         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 41+  C535 3E 00            ld a,0
 42+  C537 32 26 C5         ld (monster_jumpdirectionvert),a        ; going up
 43+  C53A CD 77 C5         call monster_draw                       ; the monster
 44+  C53D C9               ret
 45+  C53E
 46+  C53E              ;
 47+  C53E              ; Animate the monster
 48+  C53E              ;
 49+  C53E              monster_process:
 50+  C53E CD 77 C5         call monster_draw                       ; overwrite the old sprite
 51+  C541 ED 4B 0F C5      ld bc,(monster_currentcoords)           ; get the current coords
 52+  C545 2A 13 C5         ld hl,(monster_jumppos)                 ; get the position in the jump table
 53+  C548 56               ld d,(hl)                               ; get the jump modifier
 54+  C549 3A 26 C5         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 55+  C54C FE 00            cp 0                                    ; if 0, going up, so dec vert
 56+  C54E C2 57 C5         jp nz,monster_process0
 57+  C551 79               ld a,c
 58+  C552 92               sub d
 59+  C553 23               inc hl                                  ; move forward a jump pos
 60+  C554 C3 5A C5         jp monster_process1
 61+  C557              monster_process0:
 62+  C557 79               ld a,c                                   ; going down so inc c
 63+  C558 82               add a,d
 64+  C559 2B               dec hl                                  ; move back a jump pos
 65+  C55A              monster_process1:
 66+  C55A 4F               ld c,a                                  ; get the vertical coord back
 67+  C55B ED 43 0F C5      ld (monster_currentcoords),bc           ; store the new vertical coords
 68+  C55F 7E               ld a,(hl)                               ; check the next jump pos
 69+  C560 FE FF            cp 255                                  ; if 255 reverse
 70+  C562 CA 6B C5         jp z,monster_process3
 71+  C565 22 13 C5         ld (monster_jumppos),hl                 ; store the new pos
 72+  C568 C3 73 C5         jp monster_process2                     ; keep going
 73+  C56B              monster_process3:
 74+  C56B 3A 26 C5         ld a,(monster_jumpdirectionvert)        ; get the direction
 75+  C56E EE 01            xor 1                                   ; flip it
 76+  C570 32 26 C5         ld (monster_jumpdirectionvert),a        ; store it
 77+  C573              monster_process2:
 78+  C573 CD 77 C5         call monster_draw                       ; finally, draw the monster
 79+  C576 C9               ret
 80+  C577
 81+  C577              ;
 82+  C577              ; Draw the monster at the current location
 83+  C577              ;
 84+  C577              monster_draw:
 85+  C577 ED 4B 0F C5      ld bc,(monster_currentcoords)
 86+  C57B 21 88 B5         ld hl,monster_sprite                    ; load the first frame
 87+  C57E CD 7F A9         call sprites_draw2by2sprite
 88+  C581 ED 4B 0F C5      ld bc,(monster_currentcoords)
 89+  C585 79               ld a,c
 90+  C586 E6 F8            and 248                                 ; work out the lines to update
 91+  C588 0F               rrca
 92+  C589 0F               rrca
 93+  C58A 0F               rrca
 94+  C58B ED 4B 11 A7      ld bc,(screen_offset)
 95+  C58F 91               sub c
 96+  C590 4F               ld c,a
 97+  C591 CD C4 A5         call buffer_marklineforupdate
 98+  C594 0C               inc c
 99+  C595 79               ld a,c
100+  C596 CD C4 A5         call buffer_marklineforupdate
101+  C599 0C               inc c
102+  C59A 79               ld a,c
103+  C59B CD C4 A5         call buffer_marklineforupdate
104+  C59E C9               ret
# file closed: game/monster.asm
 48   C59F
 49   C59F              ;===========================================================================
 50   C59F              ; main routine - the code execution starts here.
 51   C59F              ; Sets up the new interrupt routine, the memory
 52   C59F              ; banks and jumps to the start loop.
 53   C59F              ;===========================================================================
 54   C59F              main:
 55   C59F
 56   C59F                  ; Draw the title screen
 57   C59F              main_titlescreen:
 58   C59F CD F7 A9         call titlescreen_show
 59   C5A2 CD 90 BA         call player_init_gamestart
 60   C5A5
 61   C5A5              main_lifestart:
 62   C5A5
 63   C5A5 CD AE BA         call player_init_lifestart
 64   C5A8
 65   C5A8 CD 5D AB         call lifescreen_draw        ; show the lives remaining screen
 66   C5AB
 67   C5AB CD 00 80         call init_start
 68   C5AE CD 2C A7         call screen_draw
 69   C5B1 CD 8A A6         call buffer_allbuffertoscreen
 70   C5B4
 71   C5B4 CD ED C2         call missiles_init
 72   C5B7 CD 58 BC         call ship_land              ; land the ship
 73   C5BA CD 7A BD         call tank_init
 74   C5BD CD B5 C2         call diamonds_init
 75   C5C0 CD BA C4         call thepit_init
 76   C5C3 CD 27 C5         call monster_init
 77   C5C6
 78   C5C6              mloop:
 79   C5C6 76               halt
 80   C5C7 CD FB C5         call main_loop_processing
 81   C5CA
 82   C5CA                  ;
 83   C5CA                  ; Check if the player died
 84   C5CA                  ;
 85   C5CA 21 55 BA         ld hl,player+10
 86   C5CD 7E               ld a,(hl)                   ; check if the player died this frame
 87   C5CE FE 01            cp 1
 88   C5D0 C2 E7 C5         jp nz,mloop0
 89   C5D3 CD 15 BB         call player_died        ; do end of life housekeeping
 90   C5D6 06 28            ld b,40
 91   C5D8 CD 82 80         call utilities_pauseforframes
 92   C5DB 21 54 BA         ld hl,player+9        ; check lives remaining
 93   C5DE 7E               ld a,(hl)
 94   C5DF FE 00            cp 0
 95   C5E1 CA 29 C6         jp z,main_gameover   ; leave the loop if we're done
 96   C5E4 C3 A5 C5         jp main_lifestart    ; otherwise, start a new life
 97   C5E7              mloop0:
 98   C5E7                  ;
 99   C5E7                  ; Check if the player completed the level
100   C5E7                  ;
101   C5E7 21 58 BA         ld hl,player+13
102   C5EA 7E               ld a,(hl)
103   C5EB FE 01            cp 1
104   C5ED C2 C6 C5         jp nz,mloop
105   C5F0 CD 22 BC         call player_checkforexit
106   C5F3 FE 01            cp 1                        ; look at return, if 1, level has been completed
107   C5F5 CA 2F C6         jp z,main_endlevel          ; jump to level transition screen
108   C5F8 C3 C6 C5         jp mloop                ; start the loop again
109   C5FB
110   C5FB
111   C5FB              main_loop_processing:
112   C5FB
113   C5FB CD 5B A6         call buffer_buffertoscreen  ; copy buffer to screen
114   C5FE CD DB A5         call buffer_clearlist       ; zero the updated lines list
115   C601 CD 5A BA         call player_getlocation     ; figure out where the player is
116   C604 CD 4B BB         call player_drawplayer      ; delete player
117   C607 CD C8 B5         call control_keyboard       ; check keyboard
118   C60A CD 4B BB         call player_drawplayer      ; draw player
119   C60D CD A9 BD         call tank_process           ; prcoess the tank
120   C610 CD 43 BC         call ship_process           ; proces the ship
121   C613 CD A3 BF         call rocks_processrocks     ; process falling rocks
122   C616 CD C5 C4         call thepit_process         ; process the pit trap
123   C619 CD 15 C3         call missiles_process       ; process missiles
124   C61C CD 3E C5         call monster_process        ; process monster
125   C61F CD 94 C2         call diamonds_twinkle       ; make the diamonds twinkle
126   C622 CD 1E C1         call scores_printscore      ; update the score on screen
127   C625 CD 32 BA         call game_incrementframe    ; increment the game frame
128   C628
129   C628 C9               ret
130   C629
131   C629              main_gameover:
132   C629 CD B0 AB         call gameover_draw          ; show the game over screen
133   C62C C3 9F C5         jp main_titlescreen         ; go back to title
134   C62F
135   C62F              main_endlevel:
136   C62F CD FB BA         call player_recordcurrentscore
137   C632 CD 9E AC         call endlevel_draw          ; show the end level screen
138   C635 C3 A5 C5         jp main_lifestart           ; start a new life
139   C638
140   C638              ;===========================================================================
141   C638              ; Stack.
142   C638              ;===========================================================================
143   C638
144   C638              ; Stack: this area is reserved for the stack
145   C638              STACK_SIZE: equ 100    ; in words
146   C638
147   C638              ; Reserve stack space
148   C638 00 00            defw 0  ; WPMEM, 2
149   C63A              stack_bottom:
150   C63A 00 00 00...      defs    STACK_SIZE*2, 0
151   C702              stack_top:
152   C702 00 00            defw 0  ; WPMEM, 2
153   C704
154   C704                     SAVESNA "ThePit.sna", main
# file closed: main.asm
