# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000 CD 6B 0D         call $0D6B
  7+  8003 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8005                                      ; bright (64).
  9+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 10+  8008 AF               xor a               ; quick way to load accumulator with zero.
 11+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 12+  800C CD AF 0D         call 3503           ; ROM routine - clears screen, opens chan 2.
 13+  800F
 14+  800F C9               ret
 15+  8010
 16+  8010              ;
 17+  8010              ;   Start coord
 18+  8010              ;   vert c, horiz b
 19+  8010              start_coord:
 20+  8010 18 30            defb 24,48
 21+  8012
# file closed: init.asm
 21   8012                  include "utilities.asm"
# file opened: utilities.asm
  1+  8012              ; ##########################################################################
  2+  8012              ; Print a character
  3+  8012              ; Inputs:
  4+  8012              ; b - x coord
  5+  8012              ; c - y coord
  6+  8012              ; d - character
  7+  8012              ; e - colour
  8+  8012              ; ##########################################################################
  9+  8012              utilities_print_char:
 10+  8012 7B               ld a,e
 11+  8013 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  8016 3E 16            ld a,22
 13+  8018 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8019 78               ld a,b              ; Gets the X co-ordinate
 15+  801A 3D               dec a
 16+  801B D7               rst 16
 17+  801C 79               ld a,c              ; and the Y co-ordinate
 18+  801D D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  801E 7A               ld a,d              ; ASCII code for udg.
 20+  801F D7               rst 16              ; draw block.
 21+  8020 C9               ret
 22+  8021
 23+  8021
 24+  8021              ;Inputs:
 25+  8021              ;     DE and A are factors
 26+  8021              ;Outputs:
 27+  8021              ;     A is not changed
 28+  8021              ;     B is 0
 29+  8021              ;     C is not changed
 30+  8021              ;     DE is not changed
 31+  8021              ;     HL is the product
 32+  8021              ;Time:
 33+  8021              ;     342+6x
 34+  8021              ;
 35+  8021              utilities_multiply:
 36+  8021 06 08            ld b,8          ;7           7
 37+  8023 21 00 00         ld hl,0         ;10         10
 38+  8026 29               add hl,hl     ;11*8       88
 39+  8027 07               rlca          ;4*8        32
 40+  8028 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  802A 19                   add hl,de   ;--         --
 42+  802B 10 F9            djnz $-5      ;13*7+8     99
 43+  802D C9               ret             ;10         10
 44+  802E
 45+  802E              utilities_waitforkey:
 46+  802E 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  8031 36 00            ld (hl),0           ; put null value there.
 48+  8033              utilities_waitforkey0:
 49+  8033 7E               ld a,(hl)           ; new value of LAST K.
 50+  8034 FE 00            cp 0                ; is it still zero?
 51+  8036 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8038 C9               ret                 ; key was pressed.
 53+  8039
# file closed: utilities.asm
 22   8039                  include "strings.asm"
# file opened: strings.asm
  1+  8039              string_score1:
  2+  8039 04 00 53 43      defb 4,0,'SCORE1',255
  2+  803D 4F 52 45 31
  2+  8041 FF
  3+  8042              string_scorenumbers1:
  4+  8042 04 01 30 30      defb 4,1,'000000',255
  4+  8046 30 30 30 30
  4+  804A FF
  5+  804B              string_company:
  6+  804B 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  804F 4E 54 55 52
  6+  8053 49 FF
  7+  8055              string_credits:
  8+  8055 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  8059 41 59 45 52
  8+  805D 20 31 FF
  9+  8060              string_score2:
 10+  8060 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8064 4F 52 45 32
 10+  8068 FF
 11+  8069              string_scorenumbers2:
 12+  8069 16 01 30 30      defb 22,1,'000000',255
 12+  806D 30 30 30 30
 12+  8071 FF
 13+  8072              string_titlescreen_copyright:
 14+  8072 04 16 7F 20      defb 4,22, 127,' 1982 AW ZILEC ELC LTD',255
 14+  8076 31 39 38 32
 14+  807A 20 41 57 20
 14+  807E 5A 49 4C 45
 14+  8082 43 20 45 4C
 14+  8086 43 20 4C 54
 14+  808A 44 FF
 15+  808C
 16+  808C              ;
 17+  808C              ; Prints specified string
 18+  808C              ; Inputs:
 19+  808C              ; de: pointer to string
 20+  808C              ; bc: length of string
 21+  808C              ;
 22+  808C              ; Print String Data
 23+  808C              ; First two bytes of string contain X and Y char position, then the string
 24+  808C              ; Individual strings are terminated with 0xFE
 25+  808C              ; End of data is terminated with 0xFF
 26+  808C              ; HL: Address of string
 27+  808C              ;
 28+  808C 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
 29+  808D 23                                   INC HL                          ; Increase HL to the next memory location
 30+  808E 56                                   LD D,(HL)                       ; Fetch the Y coordinate
 31+  808F 23                                   INC HL                          ; Increase HL to the next memory location
 32+  8090 CD A3 80                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
 33+  8093 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
 34+  8094 23                                   INC HL                          ; Increase HL to the next character
 35+  8095 FE FE                                CP 0xFE                         ; Compare with 0xFE
 36+  8097 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
 37+  8099 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
 38+  809A E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
 39+  809B CD B3 80                             CALL Print_Char                 ; Print the character
 40+  809E E1                                   POP HL                          ; Retrieve HL back off the stack
 41+  809F 1C                                   INC E                           ; Go to the next screen address
 42+  80A0 18 F1                                JR string_print_0               ; Loop back to print next character
 43+  80A2 C9                                   RET
 44+  80A3
 45+  80A3              ; Get screen address
 46+  80A3              ; D = Y character position
 47+  80A3              ; E = X character position
 48+  80A3              ; Returns address in DE
 49+  80A3              ;
 50+  80A3 7A           string_getcharaddress:       LD A,D
 51+  80A4 E6 07                                AND %00000111
 52+  80A6 1F                                   RRA
 53+  80A7 1F                                   RRA
 54+  80A8 1F                                   RRA
 55+  80A9 1F                                   RRA
 56+  80AA B3                                   OR E
 57+  80AB 5F                                   LD E,A
 58+  80AC 7A                                   LD A,D
 59+  80AD E6 18                                AND %00011000
 60+  80AF F6 40                                OR %01000000
 61+  80B1 57                                   LD D,A
 62+  80B2 C9                                   RET                             ; Returns screen address in DE
 63+  80B3
 64+  80B3              ; Print a single character out
 65+  80B3              ; A:  Character to print
 66+  80B3              ; DE: Screen address to print character at
 67+  80B3              ;
 68+  80B3 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
 69+  80B6 06 00                                LD B,0                          ; Set BC to A
 70+  80B8 4F                                   LD C,A
 71+  80B9 E6 FF                                AND 0xFF                        ; Clear the carry bit
 72+  80BB CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
 73+  80BD CB 10                                RL B
 74+  80BF CB 11                                RL C
 75+  80C1 CB 10                                RL B
 76+  80C3 CB 11                                RL C
 77+  80C5 CB 10                                RL B
 78+  80C7 09                                   ADD HL,BC                       ; Get the character address in HL
 79+  80C8 0E 08                                LD C,8                          ; Loop counter
 80+  80CA D5                                   PUSH DE
 81+  80CB 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
 82+  80CC 12                                   LD (DE),A                       ; Stick A onto the screen
 83+  80CD 14                                   INC D                           ; Goto next line on screen
 84+  80CE 2C                                   INC L                           ; Goto next byte of character
 85+  80CF 0D                                   DEC C                           ; Decrease the loop counter
 86+  80D0 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
 87+  80D2 D1                                   POP DE
 88+  80D3 C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   80D4                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  80D4              screen_buffer:
  2+  80D4 00 00 00...      defs 7424                   ; area reserved for screen
  3+  9DD4
  4+  9DD4              screen_attr_buffer:
  5+  9DD4 00 00 00...      defs 928                    ; attrs buffer area
  6+  A174
  7+  A174              screen_offset:
  8+  A174 00               defb 0                      ; offset from top of screen in lines
  9+  A175
 10+  A175              screen_tmp:
 11+  A175 00               defb 0                      ; temporary memory
 12+  A176
 13+  A176              ;
 14+  A176              ; Copies the buffer to the screen. Use stack.
 15+  A176              ; Inputs: none
 16+  A176              ;
 17+  A176              screen_buffertoscreen:
 18+  A176 3A 74 A1         ld a,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 19+  A179 11 00 01         ld de,256
 20+  A17C CD 21 80         call utilities_multiply
 21+  A17F 54 5D            ld de,hl
 22+  A181 21 D4 80         ld hl,screen_buffer
 23+  A184 19               add hl,de                   ; add the offset
 24+  A185 ED 73 F1 A1      ld (screen_buffertoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
 25+  A189 D9               exx
 26+  A18A 21 50 40         ld hl,16384+80              ; where the actual screen is, but as we're using the stack it's the right hand side of the buffer (16+32+32)
 27+  A18D              screen_buffertoscreen0:
 28+  A18D D9               exx                         ; hl is now buffer
 29+  A18E F9               ld sp,hl                    ; do first sixteen for left hand side
 30+  A18F F1               pop af
 31+  A190 C1               pop bc
 32+  A191 D1               pop de
 33+  A192 DD E1            pop ix
 34+  A194 D9               exx                         ; hl is now screen
 35+  A195 08               ex af,af'
 36+  A196 F1               pop af
 37+  A197 C1               pop bc
 38+  A198 D1               pop de
 39+  A199 FD E1            pop iy
 40+  A19B F9               ld sp,hl
 41+  A19C FD E5            push iy
 42+  A19E D5               push de
 43+  A19F C5               push bc
 44+  A1A0 F5               push af
 45+  A1A1 08               ex af,af'
 46+  A1A2 D9               exx                         ; hl is now buffer
 47+  A1A3 DD E5            push ix
 48+  A1A5 D5               push de
 49+  A1A6 C5               push bc
 50+  A1A7 F5               push af
 51+  A1A8 1E 10            ld e,16                    ; do another sixteen for right hand side
 52+  A1AA 16 00            ld d,0
 53+  A1AC 19               add hl,de
 54+  A1AD F9               ld sp,hl
 55+  A1AE F1               pop af
 56+  A1AF C1               pop bc
 57+  A1B0 D1               pop de
 58+  A1B1 DD E1            pop ix
 59+  A1B3 D9               exx                         ; hl is now screen
 60+  A1B4 08               ex af,af'
 61+  A1B5 1E 10            ld e,16
 62+  A1B7 16 00            ld d,0
 63+  A1B9 19               add hl,de
 64+  A1BA F1               pop af
 65+  A1BB C1               pop bc
 66+  A1BC D1               pop de
 67+  A1BD FD E1            pop iy
 68+  A1BF F9               ld sp,hl
 69+  A1C0 FD E5            push iy
 70+  A1C2 D5               push de
 71+  A1C3 C5               push bc
 72+  A1C4 F5               push af
 73+  A1C5 08               ex af,af'
 74+  A1C6 D9               exx                         ; hl is now buffer
 75+  A1C7 DD E5            push ix
 76+  A1C9 D5               push de
 77+  A1CA C5               push bc
 78+  A1CB F5               push af
 79+  A1CC 1E 10            ld e,16
 80+  A1CE 16 00            ld d,0
 81+  A1D0 19               add hl,de
 82+  A1D1 D9               exx                         ; hl is now screen
 83+  A1D2 1E 10            ld e,16
 84+  A1D4 16 00            ld d,0
 85+  A1D6 ED 52            sbc hl,de
 86+  A1D8 24               inc h
 87+  A1D9 7C               ld a,h
 88+  A1DA E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
 89+  A1DC 20 AF            jr nz,screen_buffertoscreen0 ; next line in cell
 90+  A1DE 7C               ld a,h
 91+  A1DF D6 08            sub 8
 92+  A1E1 67               ld h,a
 93+  A1E2 7D               ld a,l
 94+  A1E3 C6 20            add a,32
 95+  A1E5 6F               ld l,a
 96+  A1E6 30 A5            jr nc,screen_buffertoscreen0
 97+  A1E8 7C               ld a,h
 98+  A1E9 C6 08            add a,8
 99+  A1EB 67               ld h,a
100+  A1EC FE 58            cp 0x58
101+  A1EE 20 9D            jr nz,screen_buffertoscreen0
102+  A1F0              screen_buffertoscreen1:
103+  A1F0 31 00 00         ld sp,0
104+  A1F3 D9               exx
105+  A1F4 CD F8 A1         call screen_buffertoattrs
106+  A1F7 C9               ret
107+  A1F8
108+  A1F8              screen_buffertoattrs:
109+  A1F8 3A 74 A1         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
110+  A1FB 11 20 00         ld de,32
111+  A1FE CD 21 80         call utilities_multiply
112+  A201 54 5D            ld de,hl
113+  A203 21 D4 9D         ld hl,screen_attr_buffer
114+  A206 19               add hl,de                       ; add the offset
115+  A207 11 40 58         ld de,22528+64                  ; add 32x2 to the attr memory address to account for the top two rows
116+  A20A 01 A0 03         ld bc,928
117+  A20D ED B0            ldir
118+  A20F C9               ret
119+  A210
120+  A210              screen_setscorecolours:
121+  A210 21 52 A9         ld hl,score_colours
122+  A213 11 00 58         ld de,22528                     ; attrs here
123+  A216 01 40 00         ld bc,64
124+  A219 ED B0            ldir
125+  A21B C9               ret
126+  A21C
127+  A21C
128+  A21C              ; Draw the screen
129+  A21C              ; Inputs:
130+  A21C              ; none
131+  A21C              ; Notes:
132+  A21C              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
133+  A21C              screen_draw:
134+  A21C                  ;call clear_screen
135+  A21C 0E 00            ld c,0                      ; horiz
136+  A21E 06 00            ld b,0                      ; vert, 0 at top
137+  A220 DD 21 CF A4      ld ix,level01               ; point ix at level data
138+  A224 FD 21 D4 9D      ld iy,screen_attr_buffer    ; point iy at attr data
139+  A228              screen_draw0:
140+  A228 DD 7E 00         ld a,(ix)                   ; load the block number
141+  A22B C5               push bc                     ; store bc, contains loop count
142+  A22C CD 48 A3         call screen_getattr         ; get the memory location for this cell's attr into hl
143+  A22F 7E               ld a,(hl)                   ; get the attr value at the address
144+  A230 FD 77 00         ld (iy),a                   ; load the attr into memory
145+  A233 DD 7E 00         ld a,(ix)                   ; load the block number
146+  A236 CD 3D A3         call screen_getblock        ; get the block data into hl
147+  A239 CD 23 A3         call screen_showchar        ; show this character here
148+  A23C C1               pop bc                      ; get the loop counter back
149+  A23D DD 23            inc ix                      ; increment level location
150+  A23F FD 23            inc iy                      ; increment attr location
151+  A241 0C               inc c                       ; increment horiz
152+  A242 79               ld a,c
153+  A243 FE 20            cp 32                       ; check if horiz has reach edge of screen
154+  A245 C2 28 A2         jp nz,screen_draw0          ; if not, loop
155+  A248 0E 00            ld c,0                      ; if so, reset horiz
156+  A24A 04               inc b                       ; increment vertical
157+  A24B 78               ld a,b
158+  A24C FE 1D            cp 29                       ; check if at bottom
159+  A24E C2 28 A2         jp nz,screen_draw0          ; if not, loop
160+  A251 21 75 A1         ld hl, screen_tmp
161+  A254 36 09            ld (hl),9                   ; load the block number into memory
162+  A256 DD 21 6F A8      ld ix,level01rocks          ; rock memory
163+  A25A CD 95 A2         call screen_initobjects     ; draw rocks
164+  A25D 21 75 A1         ld hl, screen_tmp
165+  A260 36 0C            ld (hl),12                  ; load the block number into memory
166+  A262 DD 21 09 A9      ld ix,level01missiles       ; missile memory
167+  A266 CD 95 A2         call screen_initobjects     ; draw missiles
168+  A269 CD 6D A2         call screen_setuptext       ; draws text on the screen
169+  A26C C9               ret
170+  A26D
171+  A26D              ;
172+  A26D              ; Sets up text on the screen
173+  A26D              ;
174+  A26D              screen_setuptext:
175+  A26D 21 39 80         ld hl, string_score1
176+  A270 CD 8C 80         call string_print
177+  A273 21 42 80         ld hl, string_scorenumbers1
178+  A276 CD 8C 80         call string_print
179+  A279 21 4B 80         ld hl, string_company
180+  A27C CD 8C 80         call string_print
181+  A27F 21 60 80         ld hl, string_score2
182+  A282 CD 8C 80         call string_print
183+  A285 21 69 80         ld hl, string_scorenumbers2
184+  A288 CD 8C 80         call string_print
185+  A28B 21 55 80         ld hl, string_credits
186+  A28E CD 8C 80         call string_print
187+  A291 CD 10 A2         call screen_setscorecolours
188+  A294 C9               ret
189+  A295              ;
190+  A295              ; Draw initial object positions
191+  A295              ; Inputs:
192+  A295              ; ix - memory location of objects
193+  A295              ; a - graphic
194+  A295              screen_initobjects:
195+  A295 DD 4E 00         ld c,(ix)                   ; get the horiz coord
196+  A298 79               ld a,c
197+  A299 FE FF            cp 255
198+  A29B CA C0 A2         jp z,screen_initobjects2
199+  A29E DD 23            inc ix                      ; move to next
200+  A2A0 DD 46 00         ld b,(ix)                   ; get the vert coord
201+  A2A3 DD 23            inc ix
202+  A2A5 CD D2 A2         call screen_getcellattradress ; get the memory address of b,c attr into de
203+  A2A8 D5               push de
204+  A2A9 3A 75 A1         ld a,(screen_tmp)                  ; get the block number back
205+  A2AC CD 48 A3         call screen_getattr         ; get the memory location for this cell's attr into hl
206+  A2AF D1               pop de
207+  A2B0 7E               ld a,(hl)                   ; get the attr value at the address
208+  A2B1 12               ld (de),a                   ; load the attr into memory
209+  A2B2 3A 75 A1         ld a,(screen_tmp)                  ; get the block number back
210+  A2B5 CD 3D A3         call screen_getblock        ; get the block data into hl
211+  A2B8 CD 23 A3         call screen_showchar        ; show this character here
212+  A2BB
213+  A2BB              screen_initobjects1:
214+  A2BB DD 23            inc ix                      ; move past state
215+  A2BD C3 95 A2         jp screen_initobjects
216+  A2C0              screen_initobjects2:
217+  A2C0 C9               ret
218+  A2C1
219+  A2C1
220+  A2C1              ;
221+  A2C1              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
222+  A2C1              ; Inputs:
223+  A2C1              ; bc: coords
224+  A2C1              ; Outputs:
225+  A2C1              ; de: memory location
226+  A2C1              ;
227+  A2C1              screen_getcelladdress:
228+  A2C1 78               ld a,b      ; vertical position.
229+  A2C2 E6 18            and 24      ; which segment, 0, 1 or 2?
230+  A2C4 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
231+  A2C6 57               ld d,a      ; this is our high byte.
232+  A2C7 78               ld a,b      ; what was that vertical position again?
233+  A2C8 E6 07            and 7       ; which row within segment?
234+  A2CA 0F               rrca        ; multiply row by 32.
235+  A2CB 0F               rrca
236+  A2CC 0F               rrca
237+  A2CD 5F               ld e,a      ; low byte.
238+  A2CE 79               ld a,c      ; add on y coordinate.
239+  A2CF 83               add a,e     ; mix with low byte.
240+  A2D0 5F               ld e,a      ; address of screen position in de.
241+  A2D1 C9               ret
242+  A2D2
243+  A2D2              ;
244+  A2D2              ; Calculate buffer address of attribute for character at (b, c).
245+  A2D2              ; Inputs:
246+  A2D2              ; bc: coords
247+  A2D2              ; Outputs:
248+  A2D2              ; de: memory location
249+  A2D2              ;
250+  A2D2              screen_getcellattradress:
251+  A2D2 11 D4 9D         ld de,screen_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
252+  A2D5 69               ld l,c      ; x position.
253+  A2D6 26 00            ld h,0      ; 0 h
254+  A2D8 19               add hl,de
255+  A2D9 54 5D            ld de,hl    ; horiz done
256+  A2DB 78               ld a,b      ; do vert
257+  A2DC D5               push de
258+  A2DD C5               push bc
259+  A2DE 11 20 00         ld de,32
260+  A2E1 CD 21 80         call utilities_multiply
261+  A2E4 C1               pop bc
262+  A2E5 D1               pop de
263+  A2E6 19               add hl,de
264+  A2E7 54 5D            ld de,hl    ; vert done
265+  A2E9 C9               ret
266+  A2EA
267+  A2EA              ;
268+  A2EA              ; Calculate buffer address of attribute for character at (b, c).
269+  A2EA              ; Inputs:
270+  A2EA              ; bc: coords
271+  A2EA              ; Outputs:
272+  A2EA              ; de: memory location
273+  A2EA              ;
274+  A2EA              screen_getscreenattradress:
275+  A2EA 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
276+  A2ED 69               ld l,c      ; x position.
277+  A2EE 26 00            ld h,0      ; 0 h
278+  A2F0 19               add hl,de
279+  A2F1 54 5D            ld de,hl    ; horiz done
280+  A2F3 78               ld a,b      ; do vert
281+  A2F4 D5               push de
282+  A2F5 C5               push bc
283+  A2F6 11 20 00         ld de,32
284+  A2F9 CD 21 80         call utilities_multiply
285+  A2FC C1               pop bc
286+  A2FD D1               pop de
287+  A2FE 19               add hl,de
288+  A2FF 54 5D            ld de,hl    ; vert done
289+  A301 C9               ret
290+  A302
291+  A302              ;
292+  A302              ; Gets the attr memory location for a screen coord
293+  A302              ; Will overwrite bc
294+  A302              ; Inputs:
295+  A302              ; bc - screen coords
296+  A302              ; Outputs:
297+  A302              ; de - memory location
298+  A302              ; bc - character coords
299+  A302              ;
300+  A302              screen_getattraddressfromscreencoords:
301+  A302 78               ld a,b                          ; get the player block coords of current block
302+  A303 E6 F8            and 248                         ; find closest multiple of eight
303+  A305 0F               rrca
304+  A306 0F               rrca
305+  A307 0F               rrca                ; divide by 8
306+  A308 47               ld b,a
307+  A309 79               ld a,c
308+  A30A 48               ld c,b                         ; swap b and c
309+  A30B E6 F8            and 248
310+  A30D 0F               rrca
311+  A30E 0F               rrca
312+  A30F 0F               rrca                ; divide by 8
313+  A310 47               ld b,a
314+  A311 CD D2 A2         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
315+  A314 C9               ret
316+  A315
317+  A315              ;
318+  A315              ; Get buffer address for a character at b,c - b vert
319+  A315              ; Buffer memory is stored as sequential block
320+  A315              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
321+  A315              ; Inputs:
322+  A315              ; bc - coords
323+  A315              ; Outputs:
324+  A315              ; de - memory location of first byte
325+  A315              screen_getbufferaddress:
326+  A315 21 D4 80         ld hl, screen_buffer    ; first get screen buffer start
327+  A318 50               ld d,b                  ; then work out vertical offset
328+  A319 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
329+  A31B 19               add hl,de               ; add to base
330+  A31C 59               ld e,c                  ; then add horizontal offset (c)
331+  A31D 16 00            ld d,0
332+  A31F 19               add hl,de               ; add to base
333+  A320 54 5D            ld de,hl
334+  A322 C9               ret
335+  A323
336+  A323              ;
337+  A323              ; Display character hl at (b, c) to buffer.
338+  A323              ; Stored sequentially
339+  A323              ; Inputs:
340+  A323              ; hl: block address
341+  A323              ; bc: coords
342+  A323              ;
343+  A323              screen_showchar:
344+  A323 3E 00            ld a,0
345+  A325 E5               push hl
346+  A326 CD 15 A3         call screen_getbufferaddress ; get the current screen buffer pointer
347+  A329 E1               pop hl
348+  A32A 06 08            ld b,8              ; number of pixels high.
349+  A32C              screen_showchar0:
350+  A32C 7E               ld a,(hl)           ; source graphic.
351+  A32D 12               ld (de),a           ; transfer to screen.
352+  A32E 23               inc hl              ; next piece of data.
353+  A32F E5               push hl             ; store hl
354+  A330 62 6B            ld hl,de            ; put de in hl
355+  A332 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
356+  A334 16 00            ld d,0
357+  A336 19               add hl,de              ; add de to hl
358+  A337 54 5D            ld de,hl            ; load back to de
359+  A339 E1               pop hl              ; restore hl
360+  A33A
361+  A33A 10 F0            djnz screen_showchar0 ; repeat
362+  A33C C9               ret
363+  A33D
364+  A33D
365+  A33D              ;
366+  A33D              ; Get cell graphic.
367+  A33D              ; Inputs:
368+  A33D              ; a: block
369+  A33D              ; Outputs:
370+  A33D              ; hl: memory
371+  A33D              ;
372+  A33D              screen_getblock:
373+  A33D 07               rlca                        ; multiply block number by eight.
374+  A33E 07               rlca
375+  A33F 07               rlca
376+  A340 5F               ld e,a                      ; displacement to graphic address.
377+  A341 16 00            ld d,0                      ; no high byte.
378+  A343 21 92 A9         ld hl,sprites               ; address of character blocks.
379+  A346 19               add hl,de                   ; point to block.
380+  A347 C9               ret
381+  A348
382+  A348              ;
383+  A348              ; Get cell attribute.
384+  A348              ; Inputs:
385+  A348              ; a: block
386+  A348              ; Outputs:
387+  A348              ; hl: memory
388+  A348              ;
389+  A348              screen_getattr:
390+  A348 5F               ld e,a                      ; displacement to attribute address.
391+  A349 16 00            ld d,0                      ; no high byte.
392+  A34B 21 02 AA         ld hl,sprite_attrs          ; address of block attributes.
393+  A34E 19               add hl,de                   ; point to attribute.
394+  A34F C9               ret
395+  A350
# file closed: screen/screen.asm
 24   A350                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A350              ;
  2+  A350              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A350              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A350              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A350              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A350              ; routine takes care of all the shifting itself. This means that sprite
  7+  A350              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A350              ; space they would require in pre-shifted form.
  9+  A350              ; Inputs:
 10+  A350              ; hl - sprite data
 11+  A350              ; bc - screen coords
 12+  A350              ;
 13+  A350              sprites_drawsprite7:
 14+  A350 EE 07            xor 7               ; complement last 3 bits.
 15+  A352 3C               inc a               ; add one for luck!
 16+  A353              sprites_drawsprite3:
 17+  A353 CB 11            rl c                ; ...into middle byte...
 18+  A355 CB 12            rl d                ; ...and finally into left character cell.
 19+  A357 3D               dec a               ; count shifts we've done.
 20+  A358 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A35A                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A35A 79               ld a,c              ; left edge of image is currently in e.
 23+  A35B 4A               ld c,d              ; put right edge there instead.
 24+  A35C 57               ld d,a              ; and the left edge back into c.
 25+  A35D 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A35F              sprites_drawsprite:
 27+  A35F ED 43 C4 A3      ld (dispx),bc       ; store coords in dispx for now.
 28+  A363 E5               push hl
 29+  A364 CD A2 A3         call sprites_scadd  ; calculate screen address.
 30+  A367 E1               pop hl
 31+  A368 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A36A              sprites_drawsprite1:
 33+  A36A 08               ex af,af'           ; store loop counter.
 34+  A36B D5               push de             ; store screen address.
 35+  A36C 4E               ld c,(hl)           ; first sprite graphic.
 36+  A36D 23               inc hl              ; increment poiinter to sprite data.
 37+  A36E 22 C6 A3         ld (sprtmp),hl      ; store it for later.
 38+  A371 16 00            ld d,0              ; blank right byte for now.
 39+  A373 78               ld a,b              ; b holds y position.
 40+  A374 E6 07            and 7               ; how are we straddling character cells?
 41+  A376 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A378 FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A37A 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A37C A7               and a               ; oops, carry flag is set so clear it.
 45+  A37D              sprites_drawsprite2:
 46+  A37D CB 19            rr c                ; rotate left byte right...
 47+  A37F CB 1A            rr d                ; ...into right byte.
 48+  A381 3D               dec a               ; one less shift to do.
 49+  A382 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A384              sprites_drawsprite0:
 51+  A384 E1               pop hl              ; pop screen address from stack.
 52+  A385 7E               ld a,(hl)           ; what's there already.
 53+  A386 A9               xor c               ; merge in image data.
 54+  A387 77               ld (hl),a           ; place onto screen.
 55+  A388 23               inc hl
 56+  A389 7E               ld a,(hl)           ; what's already there.
 57+  A38A AA               xor d               ; right edge of sprite image data.
 58+  A38B 77               ld (hl),a           ; plonk it on screen.
 59+  A38C 3A C4 A3         ld a,(dispx)        ; vertical coordinate.
 60+  A38F 3C               inc a               ; next line down.
 61+  A390 32 C4 A3         ld (dispx),a        ; store new position.
 62+  A393 2B               dec hl
 63+  A394 11 20 00         ld de,32            ; add 32 to get to the next row
 64+  A397 19               add hl,de           ; add 32
 65+  A398              sprites_drawsprite6:
 66+  A398 EB               ex de,hl            ; screen address in de.
 67+  A399 2A C6 A3         ld hl,(sprtmp)      ; restore graphic address.
 68+  A39C 08               ex af,af'           ; restore loop counter.
 69+  A39D 3D               dec a               ; decrement it.
 70+  A39E C2 6A A3         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 71+  A3A1 C9               ret                 ; job done.
 72+  A3A2
 73+  A3A2              ;
 74+  A3A2              ; This routine returns a buffer address for (c, b) in de (c vert).
 75+  A3A2              ; For example: 0,0 will be at memory offset 0
 76+  A3A2              ; 1,0 (1 down) will be at memory offset 1
 77+  A3A2              ; 0,7 will be at memory offset 0
 78+  A3A2              ; 9,1 will be at memory offset 8+1
 79+  A3A2              ; 8,0 will be at memory offset 256
 80+  A3A2              ; 9,0 will be at memory offset 257
 81+  A3A2              ; Outputs:
 82+  A3A2              ; de - coords
 83+  A3A2              ;
 84+  A3A2              sprites_scadd:
 85+  A3A2 79               ld a,c               ; calculate vertical offset
 86+  A3A3 E6 F8            and 248             ;  to get nearest multiple of 8
 87+  A3A5 0F               rrca
 88+  A3A6 0F               rrca
 89+  A3A7 0F               rrca                ; divide by 8
 90+  A3A8 67               ld h,a
 91+  A3A9 78               ld a,b               ; calculate horizontal offset
 92+  A3AA E6 F8            and 248             ;  to get nearest multiple of 8
 93+  A3AC 0F               rrca
 94+  A3AD 0F               rrca
 95+  A3AE 0F               rrca                ; divide by 8
 96+  A3AF 6F               ld l,a
 97+  A3B0 C5               push bc             ; store the screen coords
 98+  A3B1 44 4D            ld bc,hl            ; load bc with the character coords
 99+  A3B3 CD 15 A3         call screen_getbufferaddress
100+  A3B6 C1               pop bc              ; get back screen coords, de is now memory of character
101+  A3B7 79               ld a,c              ; now add the vertical within the cell
102+  A3B8 E6 07            and 7
103+  A3BA 0F               rrca                ; multiply by 32.
104+  A3BB 0F               rrca
105+  A3BC 0F               rrca
106+  A3BD 6F               ld l,a
107+  A3BE 26 00            ld h,0
108+  A3C0 19               add hl,de
109+  A3C1 54 5D            ld de,hl
110+  A3C3 C9               ret
111+  A3C4
112+  A3C4 00           dispx   defb 0           ; general-use coordinates.
113+  A3C5 00           dispy   defb 0
114+  A3C6 00           sprtmp  defb 0           ; sprite temporary address.
115+  A3C7
# file closed: screen/sprites.asm
 25   A3C7                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  A3C7              ;
  2+  A3C7              ; Draws the title screen
  3+  A3C7              ;
  4+  A3C7              titlescreen_show:
  5+  A3C7 CD ED A3         call titlescreen_init
  6+  A3CA CD D1 A3         call titlescreen_drawtitle
  7+  A3CD CD 2E 80         call utilities_waitforkey   ; wait for keypress
  8+  A3D0 C9               ret
  9+  A3D1
 10+  A3D1              ;
 11+  A3D1              ; Draws the iconic logo
 12+  A3D1              ;
 13+  A3D1              titlescreen_drawtitle:
 14+  A3D1 06 66            ld b,102              ; number of points
 15+  A3D3 DD 21 03 A4      ld ix,titlescreen_logo_data
 16+  A3D7              titlescreen_drawtitle0:
 17+  A3D7 C5               push bc
 18+  A3D8 DD 4E 00         ld c,(ix)                   ; got horiz
 19+  A3DB DD 23            inc ix
 20+  A3DD DD 46 00         ld b,(ix)                   ; got vert
 21+  A3E0 DD 23            inc ix
 22+  A3E2 CD EA A2         call screen_getscreenattradress ; memory in de
 23+  A3E5 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 24+  A3E6 3E 13            ld a,19
 25+  A3E8 12               ld (de),a
 26+  A3E9 C1               pop bc
 27+  A3EA 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 28+  A3EC C9               ret
 29+  A3ED
 30+  A3ED              ;
 31+  A3ED              ; Initialises the screen
 32+  A3ED              ;
 33+  A3ED              titlescreen_init:
 34+  A3ED              ; We want a black screen.
 35+  A3ED CD 6B 0D         call $0D6B
 36+  A3F0 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 37+  A3F2                                      ; bright (64).
 38+  A3F2 32 8D 5C         ld (23693),a        ; set our screen colours.
 39+  A3F5 3E 01            ld a,1              ; 2 is the code for red.
 40+  A3F7 D3 FE            out (254),a         ; write to port 254.
 41+  A3F9 CD AF 0D         call 3503           ; ROM routine - clears screen, opens chan 2.
 42+  A3FC
 43+  A3FC 21 72 80         ld hl,string_titlescreen_copyright
 44+  A3FF CD 8C 80         call string_print
 45+  A402
 46+  A402 C9               ret
 47+  A403
 48+  A403              ;
 49+  A403              ; Horiz, vert
 50+  A403              ;
 51+  A403              titlescreen_logo_data:
 52+  A403 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
 52+  A407 0A 00 0C 00
 52+  A40B 0F 00 11 00
 52+  A40F 12 00 13 00
 53+  A413 09 01 0C 01      defb 9,1,12,1,15,1,17,1
 53+  A417 0F 01 11 01
 54+  A41B 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
 54+  A41F 0D 02 0E 02
 54+  A423 0F 02 11 02
 54+  A427 12 02 13 02
 55+  A42B 09 03 0C 03      defb 9,3,12,3,15,3,17,3
 55+  A42F 0F 03 11 03
 56+  A433 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
 56+  A437 0F 04 11 04
 56+  A43B 12 04 13 04
 57+  A43F 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
 57+  A443 02 06 03 06
 57+  A447 04 06 05 06
 57+  A44B 06 06 07 06
 57+  A44F 08 06 09 06
 57+  A453 0A 06 0B 06
 58+  A457 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
 58+  A45B 12 06 13 06
 58+  A45F 14 06 15 06
 58+  A463 16 06 17 06
 58+  A467 18 06 19 06
 58+  A46B 1A 06 1B 06
 59+  A46F 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20
 59+  A473 02 09 02 0A
 59+  A477 02 0B 02 0C
 59+  A47B 02 0D 02 0E
 59+  A47F 02 0F 02 10
 59+  A483 02 11 02 12
 59+  A487 02 13 02 14
 60+  A48B 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20
 60+  A48F 19 09 19 0A
 60+  A493 19 0B 19 0C
 60+  A497 19 0D 19 0E
 60+  A49B 19 0F 19 10
 60+  A49F 19 11 19 12
 60+  A4A3 19 13 19 14
 61+  A4A7 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
 61+  A4AB 05 0B 06 0B
 61+  A4AF 07 0B 08 0B
 61+  A4B3 09 0B 0A 0B
 61+  A4B7 0B 0B
 62+  A4B9 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
 62+  A4BD 0B 09 0B 0A
 63+  A4C1 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19,16,20
 63+  A4C5 10 10 10 11
 63+  A4C9 10 12 10 13
 63+  A4CD 10 14
 64+  A4CF
# file closed: screen/titlescreen.asm
 26   A4CF
 27   A4CF                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  A4CF              ; ###############################################################
  2+  A4CF              ; Data for level 1
  3+  A4CF              ; ###############################################################
  4+  A4CF              level01:
  5+  A4CF
  6+  A4CF 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  6+  A4D3 05 05 05 05
  6+  A4D7 05 05 05 05
  6+  A4DB 05 05 02 01
  6+  A4DF 01 01 03 05
  6+  A4E3 05 05 05 05
  6+  A4E7 05 05 05 05
  6+  A4EB 05 05 00 00
  7+  A4EF 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  7+  A4F3 05 05 05 05
  7+  A4F7 05 05 05 05
  7+  A4FB 02 01 01 01
  7+  A4FF 01 01 01 01
  7+  A503 03 05 05 05
  7+  A507 05 05 05 05
  7+  A50B 05 05 00 00
  8+  A50F 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
  8+  A513 05 05 05 05
  8+  A517 05 05 02 01
  8+  A51B 01 01 01 01
  8+  A51F 01 01 01 01
  8+  A523 01 01 03 05
  8+  A527 0D 0D 0D 0D
  8+  A52B 0D 0D 00 00
  9+  A52F 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
  9+  A533 01 01 00 01
  9+  A537 01 01 01 01
  9+  A53B 01 01 01 01
  9+  A53F 01 01 01 01
  9+  A543 01 01 01 03
  9+  A547 05 05 05 05
  9+  A54B 05 05 00 00
 10+  A54F 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 10+  A553 04 04 04 04
 10+  A557 04 04 01 01
 10+  A55B 01 01 01 01
 10+  A55F 01 01 01 01
 10+  A563 01 01 01 01
 10+  A567 01 01 01 01
 10+  A56B 00 01 00 00
 11+  A56F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 11+  A573 04 04 04 04
 11+  A577 04 04 04 04
 11+  A57B 01 01 01 01
 11+  A57F 01 01 01 01
 11+  A583 01 01 01 01
 11+  A587 00 00 00 00
 11+  A58B 00 01 00 00
 12+  A58F 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 12+  A593 04 01 01 01
 12+  A597 01 01 04 04
 12+  A59B 04 04 01 01
 12+  A59F 01 01 01 01
 12+  A5A3 01 00 00 00
 12+  A5A7 00 01 01 01
 12+  A5AB 01 01 00 00
 13+  A5AF 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 13+  A5B3 04 04 04 04
 13+  A5B7 04 01 04 04
 13+  A5BB 04 04 04 04
 13+  A5BF 04 04 00 00
 13+  A5C3 00 00 04 04
 13+  A5C7 04 04 04 04
 13+  A5CB 04 01 00 00
 14+  A5CF 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 14+  A5D3 01 04 01 01
 14+  A5D7 01 01 04 04
 14+  A5DB 04 04 04 04
 14+  A5DF 04 04 00 04
 14+  A5E3 04 04 04 04
 14+  A5E7 04 04 04 04
 14+  A5EB 04 01 00 00
 15+  A5EF 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 15+  A5F3 00 00 00 00
 15+  A5F7 00 04 04 04
 15+  A5FB 04 04 04 04
 15+  A5FF 04 04 00 04
 15+  A603 04 04 04 04
 15+  A607 04 04 04 04
 15+  A60B 04 01 00 00
 16+  A60F 00 00 01 07      defb 00,00,01,07,07,07,07,07,07,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  A613 07 07 07 07
 16+  A617 07 01 04 04
 16+  A61B 04 04 04 04
 16+  A61F 04 04 00 04
 16+  A623 04 04 04 04
 16+  A627 04 04 04 04
 16+  A62B 04 01 00 00
 17+  A62F 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 17+  A633 00 00 00 00
 17+  A637 00 01 04 04
 17+  A63B 04 04 04 04
 17+  A63F 04 04 00 04
 17+  A643 04 04 04 04
 17+  A647 04 00 00 00
 17+  A64B 00 01 00 00
 18+  A64F 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 18+  A653 00 00 00 00
 18+  A657 00 01 04 04
 18+  A65B 04 04 04 04
 18+  A65F 04 04 00 04
 18+  A663 04 04 04 04
 18+  A667 04 00 04 04
 18+  A66B 00 01 00 00
 19+  A66F 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 19+  A673 06 06 06 06
 19+  A677 06 01 04 04
 19+  A67B 04 04 04 04
 19+  A67F 04 04 00 04
 19+  A683 04 04 04 04
 19+  A687 04 00 04 04
 19+  A68B 00 01 00 00
 20+  A68F 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 20+  A693 06 06 06 06
 20+  A697 06 01 04 00
 20+  A69B 00 00 00 00
 20+  A69F 00 00 00 00
 20+  A6A3 00 00 00 00
 20+  A6A7 00 00 04 04
 20+  A6AB 00 01 00 00
 21+  A6AF 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 21+  A6B3 06 06 06 06
 21+  A6B7 06 01 04 00
 21+  A6BB 04 04 04 04
 21+  A6BF 04 04 00 04
 21+  A6C3 04 04 00 04
 21+  A6C7 04 04 04 04
 21+  A6CB 00 01 00 00
 22+  A6CF 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 22+  A6D3 06 06 06 06
 22+  A6D7 06 01 04 00
 22+  A6DB 04 04 04 04
 22+  A6DF 04 04 00 04
 22+  A6E3 04 04 00 04
 22+  A6E7 04 04 04 04
 22+  A6EB 00 01 00 00
 23+  A6EF 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  A6F3 01 01 01 01
 23+  A6F7 01 01 04 00
 23+  A6FB 04 04 04 04
 23+  A6FF 04 04 00 04
 23+  A703 04 04 00 04
 23+  A707 04 04 04 04
 23+  A70B 00 01 00 00
 24+  A70F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 24+  A713 04 04 04 04
 24+  A717 04 04 04 00
 24+  A71B 04 04 04 04
 24+  A71F 04 04 00 04
 24+  A723 04 04 00 00
 24+  A727 00 00 04 04
 24+  A72B 04 01 00 00
 25+  A72F 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 25+  A733 04 04 00 00
 25+  A737 00 00 00 00
 25+  A73B 04 04 04 04
 25+  A73F 04 04 00 04
 25+  A743 04 04 04 04
 25+  A747 04 00 04 04
 25+  A74B 04 01 00 00
 26+  A74F 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 26+  A753 04 04 00 04
 26+  A757 04 04 04 04
 26+  A75B 04 04 04 04
 26+  A75F 04 04 00 04
 26+  A763 04 04 04 04
 26+  A767 04 00 04 04
 26+  A76B 04 01 00 00
 27+  A76F 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 27+  A773 04 04 00 04
 27+  A777 04 04 01 01
 27+  A77B 01 01 01 01
 27+  A77F 01 01 01 01
 27+  A783 01 01 01 01
 27+  A787 04 00 04 04
 27+  A78B 04 01 00 00
 28+  A78F 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 28+  A793 04 04 00 04
 28+  A797 04 04 01 00
 28+  A79B 00 00 00 00
 28+  A79F 00 00 00 00
 28+  A7A3 00 00 00 01
 28+  A7A7 04 00 04 04
 28+  A7AB 04 01 00 00
 29+  A7AF 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 29+  A7B3 04 04 00 04
 29+  A7B7 04 04 01 00
 29+  A7BB 00 00 00 00
 29+  A7BF 00 00 00 00
 29+  A7C3 00 00 00 01
 29+  A7C7 04 00 04 04
 29+  A7CB 04 01 00 00
 30+  A7CF 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  A7D3 04 04 00 04
 30+  A7D7 04 04 01 00
 30+  A7DB 00 00 00 00
 30+  A7DF 00 00 00 00
 30+  A7E3 00 00 00 01
 30+  A7E7 04 00 04 04
 30+  A7EB 04 01 00 00
 31+  A7EF 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 31+  A7F3 04 04 00 04
 31+  A7F7 04 04 04 00
 31+  A7FB 00 00 00 00
 31+  A7FF 00 00 00 00
 31+  A803 00 00 00 04
 31+  A807 04 04 04 04
 31+  A80B 04 01 00 00
 32+  A80F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 32+  A813 04 04 04 04
 32+  A817 04 04 01 00
 32+  A81B 00 00 00 00
 32+  A81F 00 00 00 00
 32+  A823 00 00 00 01
 32+  A827 04 04 04 04
 32+  A82B 04 01 00 00
 33+  A82F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,08,00,01,00,08,00,00,01,00,08,00,01,04,04,04,04,04,01,00,00
 33+  A833 04 04 04 04
 33+  A837 04 04 01 00
 33+  A83B 08 00 01 00
 33+  A83F 08 00 00 01
 33+  A843 00 08 00 01
 33+  A847 04 04 04 04
 33+  A84B 04 01 00 00
 34+  A84F 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 34+  A853 01 01 01 01
 34+  A857 01 01 01 01
 34+  A85B 01 01 01 01
 34+  A85F 01 01 01 01
 34+  A863 01 01 01 01
 34+  A867 01 01 01 01
 34+  A86B 01 01 00 00
 35+  A86F
 36+  A86F              ; ###############################################################
 37+  A86F              ; Rock data: horiz, vert, state
 38+  A86F              ; ###############################################################
 39+  A86F              level01rocks:
 40+  A86F 09 04 00         defb 9,4,0
 41+  A872 0C 07 00         defb 12,7,0
 42+  A875 10 07 00         defb 16,7,0
 43+  A878 0B 08 00         defb 11,8,0
 44+  A87B 0A 0A 00         defb 10,10,0
 45+  A87E 0C 0A 00         defb 12,10,0
 46+  A881 0D 09 00         defb 13,9,0
 47+  A884 0E 08 00         defb 14,8,0
 48+  A887 0F 0B 00         defb 15,11,0
 49+  A88A 0B 0C 00         defb 11,12,0
 50+  A88D 11 0C 00         defb 17,12,0
 51+  A890 13 08 00         defb 19,8,0
 52+  A893 16 09 00         defb 22,9,0
 53+  A896 13 0A 00         defb 19,10,0
 54+  A899 15 0A 00         defb 21,10,0
 55+  A89C 15 0C 00         defb 21,12,0
 56+  A89F 16 0C 00         defb 22,12,0
 57+  A8A2 18 0A 00         defb 24,10,0
 58+  A8A5 19 09 00         defb 25,9,0
 59+  A8A8 1C 09 00         defb 28,9,0
 60+  A8AB 1B 0C 00         defb 27,12,0
 61+  A8AE 1A 0D 00         defb 26,13,0
 62+  A8B1 19 0E 00         defb 25,14,0
 63+  A8B4 19 10 00         defb 25,16,0
 64+  A8B7 1A 11 00         defb 26,17,0
 65+  A8BA 1B 11 00         defb 27,17,0
 66+  A8BD 1C 12 00         defb 28,18,0
 67+  A8C0 1A 13 00         defb 26,19,0
 68+  A8C3 1B 15 00         defb 27,21,0
 69+  A8C6 1A 17 00         defb 26,23,0
 70+  A8C9 1B 18 00         defb 27,24,0
 71+  A8CC 19 18 00         defb 25,24,0
 72+  A8CF 18 17 00         defb 24,23,0
 73+  A8D2 13 14 00         defb 19,20,0
 74+  A8D5 14 12 00         defb 20,18,0
 75+  A8D8 14 10 00         defb 20,16,0
 76+  A8DB 15 10 00         defb 21,16,0
 77+  A8DE 16 12 00         defb 22,18,0
 78+  A8E1 11 14 00         defb 17,20,0
 79+  A8E4 0D 11 00         defb 13,17,0
 80+  A8E7 0C 13 00         defb 12,19,0
 81+  A8EA 0B 13 00         defb 11,19,0
 82+  A8ED 0A 11 00         defb 10,17,0
 83+  A8F0 05 12 00         defb 5,18,0
 84+  A8F3 07 16 00         defb 7,22,0
 85+  A8F6 09 17 00         defb 9,23,0
 86+  A8F9 07 18 00         defb 7,24,0
 87+  A8FC 05 18 00         defb 5,24,0
 88+  A8FF 06 19 00         defb 6,25,0
 89+  A902 08 19 00         defb 8,25,0
 90+  A905 04 17 00         defb 4,23,0
 91+  A908 FF               defb 255
 92+  A909
 93+  A909              level01missiles:
 94+  A909 0B 17 00         defb 11,23,0
 95+  A90C 0B 16 00         defb 11,22,0
 96+  A90F 0C 17 00         defb 12,23,0
 97+  A912 0C 16 00         defb 12,22,0
 98+  A915 0D 17 00         defb 13,23,0
 99+  A918 0D 16 00         defb 13,22,0
100+  A91B 0E 17 00         defb 14,23,0
101+  A91E 0E 16 00         defb 14,22,0
102+  A921 0F 17 00         defb 15,23,0
103+  A924 0F 16 00         defb 15,22,0
104+  A927 10 17 00         defb 16,23,0
105+  A92A 10 16 00         defb 16,22,0
106+  A92D 11 17 00         defb 17,23,0
107+  A930 11 16 00         defb 17,22,0
108+  A933 12 17 00         defb 18,23,0
109+  A936 12 16 00         defb 18,22,0
110+  A939 13 17 00         defb 19,23,0
111+  A93C 13 16 00         defb 19,22,0
112+  A93F 14 17 00         defb 20,23,0
113+  A942 14 16 00         defb 20,22,0
114+  A945 15 17 00         defb 21,23,0
115+  A948 15 16 00         defb 21,22,0
116+  A94B 16 17 00         defb 22,23,0
117+  A94E 16 16 00         defb 22,22,0
118+  A951 FF               defb 255
119+  A952
120+  A952              ;
121+  A952              ; Score area colours
122+  A952              ;
123+  A952              score_colours:
124+  A952 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
124+  A956 47 47 47 47
124+  A95A 47 47 47 42
124+  A95E 43 43 43 43
124+  A962 43 43 43 43
124+  A966 42 47 47 47
124+  A96A 47 47 47 47
124+  A96E 47 47 47 47
125+  A972 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
125+  A976 47 47 47 47
125+  A97A 47 47 47 46
125+  A97E 46 46 46 46
125+  A982 46 46 46 46
125+  A986 46 47 47 47
125+  A98A 47 47 47 47
125+  A98E 47 47 47 47
# file closed: leveldata/level01.asm
 28   A992                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  A992              ; Tiles graphics.
  2+  A992              sprites:
  3+  A992 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  A996 00 00 00 00
  4+  A99A FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  A99E FF FF FF FF
  5+  A9A2 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  A9A6 1F 3F 7F FF
  6+  A9AA 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  A9AE F8 FC FE FF
  7+  A9B2 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  A9B6 55 AA 55 AA
  8+  A9BA 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  A9BE 00 00 00 00
  9+  A9C2 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  A9C6 FF FF FF FF
 10+  A9CA FF FF 00 00      defb    255,255,  0,  0,  0,  0,  0,  0   ; 7, trapdoor
 10+  A9CE 00 00 00 00
 11+  A9D2 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, gem
 11+  A9D6 F1 72 34 18
 12+  A9DA 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  A9DE FE FE FF 7E
 13+  A9E2 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  A9E6 FE FF 7E 3C
 14+  A9EA 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  A9EE 00 00 FF FF
 15+  A9F2 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 12, missile
 15+  A9F6 FF 7E 3C 18
 16+  A9FA 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  A9FE 00 00 00 00
 17+  AA02
 18+  AA02              sprite_attrs:
 19+  AA02 46               defb    070 ; 0, space
 20+  AA03 65               defb    101 ; 1, cyan block
 21+  AA04 4D               defb    077 ; 2, slope left
 22+  AA05 4D               defb    077 ; 3, slope right
 23+  AA06 46               defb    070 ; 4, dirt
 24+  AA07 4E               defb    078 ; 5, sky
 25+  AA08 4C               defb    076 ; 6, slime
 26+  AA09 42               defb    066 ; 7, trapdoor
 27+  AA0A 46               defb    070 ; 8, gem
 28+  AA0B 42               defb    066 ; 9, rock
 29+  AA0C 42               defb    066 ; 10, rock 2
 30+  AA0D 49           	defb    073 ; 11, sky, trapdoor
 31+  AA0E 43           	defb    067 ; 12, missile
 32+  AA0F 4A               defb    074 ; 13, sky, red ink (tank)
 33+  AA10
 34+  AA10              player_sprite:
 35+  AA10 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 35+  AA14 38 3D C3 80
 36+  AA18 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 36+  AA1C 3C 1C 16 32
 37+  AA20 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 37+  AA24 3C 38 68 4C
 38+  AA28 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 38+  AA2C 1C BC C3 01
 39+  AA30 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 39+  AA34 3C 3C 64 0C
 40+  AA38 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 40+  AA3C 3C 3C 26 30
 41+  AA40 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 41+  AA44 1E 5C FD 5F
 42+  AA48 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 42+  AA4C 4F 8F 19 03
 43+  AA50 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 43+  AA54 F2 F1 98 C0
 44+  AA58 FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 44+  AA5C 48 08 14 2A
 45+  AA60
 46+  AA60              ;
 47+  AA60              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 48+  AA60              ;
 49+  AA60              ship_sprite:
 50+  AA60 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 50+  AA64 03 1F 7F FF
 51+  AA68 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 51+  AA6C FF FF FF FF
 52+  AA70 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 52+  AA74 FF FF FF FF
 53+  AA78 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 53+  AA7C C0 F8 FE FF
 54+  AA80 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 54+  AA84 03 03 02 07
 55+  AA88 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 55+  AA8C FF 0F 07 83
 56+  AA90 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 56+  AA94 FF 10 20 C1
 57+  AA98 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 57+  AA9C C0 C0 40 E0
 58+  AAA0 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 58+  AAA4 03 03 02 07
 59+  AAA8 F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 59+  AAAC FF 08 04 83
 60+  AAB0 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 60+  AAB4 FF F0 E0 C1
 61+  AAB8 CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 61+  AABC C0 C0 40 E0
 62+  AAC0
 63+  AAC0              ;
 64+  AAC0              ;  First 8 frames are tank, last frame is the gun barrel
 65+  AAC0              ;
 66+  AAC0              tank_sprite:
 67+  AAC0 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 67+  AAC4 7F 00 00 00
 68+  AAC8 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 68+  AACC FE FF 7F 40
 69+  AAD0 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 69+  AAD4 03 FF FF 01
 70+  AAD8 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
 70+  AADC E0 C0 00 00
 71+  AAE0 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
 71+  AAE4 F7 E1 7F 3F
 72+  AAE8 FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
 72+  AAEC 54 16 FF FF
 73+  AAF0 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
 73+  AAF4 9B A8 FF FF
 74+  AAF8 FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
 74+  AAFC 9F AF FE FC
 75+  AB00 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0
 75+  AB04 1F 00 00 00
# file closed: graphics/graphics.asm
 29   AB08
 30   AB08                  include "game\control.asm"
# file opened: game/control.asm
  1+  AB08              ;
  2+  AB08              ; Check the keyboard then move
  3+  AB08              ;
  4+  AB08              control_keyboard:
  5+  AB08 3A CE AE         ld a,(player+5)      ; first, check if the player has pixels left to move
  6+  AB0B FE 00            cp 0
  7+  AB0D CA 14 AB         jp z, control_keyboard1
  8+  AB10 CD 09 AC         call control_automove
  9+  AB13 C9               ret
 10+  AB14              control_keyboard1:
 11+  AB14 3A CF AE         ld a,(player+6)      ; next, check if the player is digging
 12+  AB17 FE 00            cp 0
 13+  AB19 CA 20 AB         jp z, control_keyboard0
 14+  AB1C CD 47 AB         call control_dig
 15+  AB1F C9               ret
 16+  AB20              control_keyboard0:
 17+  AB20 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 18+  AB23 ED 78            in a,(c)            ; read keyboard.
 19+  AB25 47               ld b,a              ; store result in b register.
 20+  AB26 CB 18            rr b                ; check outermost key (q).
 21+  AB28 D4 52 AC         call nc,control_pl_moveup         ; player up.
 22+  AB2B 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 23+  AB2E ED 78            in a,(c)            ; read keyboard.
 24+  AB30 47               ld b,a              ; store result in b register.
 25+  AB31 CB 18            rr b                ; check outermost key (a).
 26+  AB33 D4 81 AC         call nc,control_pl_movedown       ; player down.
 27+  AB36 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 28+  AB39 ED 78            in a,(c)            ; read keyboard.
 29+  AB3B 47               ld b,a              ; store result in b register.
 30+  AB3C CB 18            rr b                ; check outermost key (p).
 31+  AB3E D4 DE AC         call nc,control_pl_moveright       ; player left.
 32+  AB41 CB 18            rr b                ; check next key.
 33+  AB43 D4 AE AC         call nc,control_pl_moveleft       ; player right.
 34+  AB46 C9               ret
 35+  AB47
 36+  AB47              ;
 37+  AB47              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 38+  AB47              ;
 39+  AB47              control_dig:
 40+  AB47 ED 4B C9 AE      ld bc,(player)      ; load the current coords into bc
 41+  AB4B C5               push bc
 42+  AB4C 3A CB AE         ld a,(player+2)     ; get the direction
 43+  AB4F FE 01            cp 1                ; left
 44+  AB51 CA 69 AB         jp z,control_dig0
 45+  AB54 FE 02            cp 2                ; right
 46+  AB56 CA 7E AB         jp z,control_dig1
 47+  AB59 FE 03            cp 3                ; down
 48+  AB5B CA A2 AB         jp z,control_dig5
 49+  AB5E FE 00            cp 0                ; up
 50+  AB60 CA 92 AB         jp z,control_dig4
 51+  AB63 21 CF AE         ld hl,player+6
 52+  AB66 36 00            ld (hl),0           ; turn off digging
 53+  AB68 C9               ret                 ; return
 54+  AB69              control_dig0:           ; going left
 55+  AB69 CD A2 A3         call sprites_scadd  ; get the current coord
 56+  AB6C 62 6B            ld hl,de
 57+  AB6E 2B               dec hl              ; move one left
 58+  AB6F C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
 59+  AB70 78               ld a,b
 60+  AB71 06 08            ld b,8
 61+  AB73 90               sub b
 62+  AB74 47               ld b,a
 63+  AB75 79               ld a,c
 64+  AB76 0E 08            ld c,8
 65+  AB78 91               sub c
 66+  AB79 4F               ld c,a
 67+  AB7A C5               push bc
 68+  AB7B C3 AB AB         jp control_dig2
 69+  AB7E              control_dig1:
 70+  AB7E CD A2 A3         call sprites_scadd  ; get the current coord
 71+  AB81 62 6B            ld hl,de
 72+  AB83 23               inc hl              ; move one right
 73+  AB84 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
 74+  AB85 3E 08            ld a,8
 75+  AB87 80               add a,b
 76+  AB88 47               ld b,a
 77+  AB89 79               ld a,c
 78+  AB8A 0E 08            ld c,8
 79+  AB8C 91               sub c
 80+  AB8D 4F               ld c,a
 81+  AB8E C5               push bc
 82+  AB8F C3 AB AB         jp control_dig2
 83+  AB92              control_dig4:
 84+  AB92 CD A2 A3         call sprites_scadd  ; get the current coord
 85+  AB95 62 6B            ld hl,de
 86+  AB97 11 20 00         ld de,32
 87+  AB9A ED 52            sbc hl,de             ; move one up
 88+  AB9C C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
 89+  AB9D 0D               dec c
 90+  AB9E C5               push bc
 91+  AB9F C3 C3 AB         jp control_dig6
 92+  ABA2              control_dig5:
 93+  ABA2 CD A2 A3         call sprites_scadd  ; get the current coord
 94+  ABA5 62 6B            ld hl,de
 95+  ABA7 24               inc h              ; move one down
 96+  ABA8                                     ; not bothered about working out bc here, since rock will never fall if digging down
 97+  ABA8 C3 AB AB         jp control_dig2
 98+  ABAB              ; Normal (not up) digging
 99+  ABAB              control_dig2:
100+  ABAB 3A D1 AE         ld a,(player+8)     ; get the number of rows we need to overwrite
101+  ABAE 47               ld b,a              ; rows to copy over
102+  ABAF E5               push hl             ; store the memory location of the first row for later
103+  ABB0              control_dig3:
104+  ABB0 CD F2 AB         call control_getpixelrow
105+  ABB3 77               ld (hl),a           ; load contents into row
106+  ABB4 11 20 00         ld de,32
107+  ABB7 19               add hl,de           ; move to next row
108+  ABB8 10 F6            djnz control_dig3
109+  ABBA E1               pop hl              ; get the original memory location back
110+  ABBB 11 20 00         ld de,32
111+  ABBE ED 52            sbc hl,de           ; move to above row, ready for checking for rock
112+  ABC0 C3 D9 AB         jp control_dig10
113+  ABC3              ; Special case for going up
114+  ABC3              control_dig6:
115+  ABC3 3A D1 AE         ld a,(player+8)     ; get the number of rows we need to overwrite
116+  ABC6 47               ld b,a              ; rows to copy over
117+  ABC7              control_dig7:
118+  ABC7 CD F2 AB         call control_getpixelrow
119+  ABCA              control_dig12:
120+  ABCA 77               ld (hl),a           ; load empty into row
121+  ABCB 11 20 00         ld de,32
122+  ABCE ED 52            sbc hl,de           ; move up to next row
123+  ABD0 0D               dec c               ; decrease c to track rows
124+  ABD1 10 F4            djnz control_dig7
125+  ABD3 79               ld a,c
126+  ABD4 D6 07            sub 7
127+  ABD6 C1               pop bc
128+  ABD7 4F               ld c,a
129+  ABD8 C5               push bc             ; store the decreased c coord
130+  ABD9              control_dig10:
131+  ABD9 DD 21 D0 AE      ld ix,player+7
132+  ABDD DD 7E 00         ld a,(ix)     ; get the dig frame number
133+  ABE0 3D               dec a
134+  ABE1 DD 77 00         ld (ix),a
135+  ABE4                  ; call the check for rocks above the removed dirt
136+  ABE4 DD 21 CF AE      ld ix,player+6
137+  ABE8 DD 7E 00         ld a,(ix)     ; get the dig state
138+  ABEB FE 00            cp 0
139+  ABED C1               pop bc
140+  ABEE CC CE B0         call z, rocks_checkforfalling ; make the check if we're no longer digging
141+  ABF1 C9               ret
142+  ABF2
143+  ABF2              ;
144+  ABF2              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
145+  ABF2              ; Inputs:
146+  ABF2              ; hl - memory of pixel row
147+  ABF2              ; Outputs:
148+  ABF2              ; a - modified row to write
149+  ABF2              ;
150+  ABF2              control_getpixelrow:
151+  ABF2 3A D0 AE         ld a,(player+7)     ; get the dig frame number
152+  ABF5 FE 00            cp 0                ; is this the last dig
153+  ABF7 CA FE AB         jp z,control_getpixelrow1
154+  ABFA 7E               ld a,(hl)           ; if not, xor with 255 to flip it
155+  ABFB EE FF            xor 255
156+  ABFD C9               ret
157+  ABFE              control_getpixelrow1:
158+  ABFE DD 21 CF AE      ld ix,player+6
159+  AC02 DD 36 00 00      ld (ix),0           ; turn off digging
160+  AC06 3E 00            ld a,0              ; if it is, load with empty
161+  AC08 C9               ret
162+  AC09
163+  AC09              ;
164+  AC09              ; Auto move the player until pixels is zero
165+  AC09              ;
166+  AC09              control_automove:
167+  AC09 5F               ld e,a              ; store the number of pixels left to move in e
168+  AC0A ED 4B C9 AE      ld bc,(player)      ; load the current coords into bc
169+  AC0E 21 CB AE         ld hl,player+2      ; get the direction
170+  AC11 7E               ld a,(hl)
171+  AC12 FE 03            cp 3                ; down
172+  AC14 CA 28 AC         jp z,control_automove3  ; don't need to do anything
173+  AC17 FE 00            cp 0                ; going up
174+  AC19 CA 34 AC         jp z,control_automove2
175+  AC1C FE 01            cp 1                ; going left?
176+  AC1E CA 40 AC         jp z,control_automove0
177+  AC21 78               ld a,b
178+  AC22 3C               inc a               ; if we're going right, increment a twice for two pixels
179+  AC23 3C               inc a
180+  AC24 47               ld b,a
181+  AC25 C3 44 AC         jp control_automove1
182+  AC28              control_automove3:
183+  AC28 79               ld a,c
184+  AC29 3C               inc a
185+  AC2A 3C               inc a               ; if we're going down, increment twice
186+  AC2B 4F               ld c,a
187+  AC2C FE 90            cp 144
188+  AC2E CC 0C AD         call z, control_scroll_down
189+  AC31 C3 44 AC         jp control_automove1
190+  AC34              control_automove2:
191+  AC34 79               ld a,c
192+  AC35 3D               dec a
193+  AC36 3D               dec a               ; if we're going up, decrement twice
194+  AC37 4F               ld c,a
195+  AC38 FE 60            cp 96
196+  AC3A CC 14 AD         call z, control_scroll_up
197+  AC3D C3 44 AC         jp control_automove1
198+  AC40              control_automove0:
199+  AC40 78               ld a,b
200+  AC41 3D               dec a               ; if we're going left, decrement a twice
201+  AC42 3D               dec a
202+  AC43 47               ld b,a
203+  AC44              control_automove1:
204+  AC44 ED 43 C9 AE      ld (player),bc      ; and back to player
205+  AC48 7B               ld a,e              ; now get the pixel count back
206+  AC49 3D               dec a               ; decrease by one
207+  AC4A 21 CE AE         ld hl,player+5
208+  AC4D 77               ld (hl),a           ; copy back
209+  AC4E CD 0C AF         call player_justmoved
210+  AC51 C9               ret
211+  AC52
212+  AC52              ;
213+  AC52              ; Moves the player up
214+  AC52              ;
215+  AC52              control_pl_moveup:
216+  AC52 C5               push bc
217+  AC53 ED 4B C9 AE      ld bc,(player)          ; get the current coords, b horiz, c vert
218+  AC57 79               ld a,c                  ; load c into the acc
219+  AC58 FE 18            cp 24
220+  AC5A CA 7A AC         jp z,control_pl_moveup0 ; are we at the edge of the screen
221+  AC5D FE 60            cp 96
222+  AC5F DC 14 AD         call c, control_scroll_up
223+  AC62 CD 3A AE         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
224+  AC65 F5               push af
225+  AC66 7B               ld a,e                  ; put e in a
226+  AC67 FE 00            cp 0
227+  AC69 CA 79 AC         jp z,control_pl_moveup1 ; don't move if we can't
228+  AC6C F1               pop af
229+  AC6D D6 01            sub 1                   ; subtract 1
230+  AC6F D6 01            sub 1                   ; subtract 1
231+  AC71 4F               ld c,a                  ; load back to c
232+  AC72 ED 43 C9 AE      ld (player),bc          ; load back to player
233+  AC76 C3 7A AC         jp control_pl_moveup0
234+  AC79              control_pl_moveup1:
235+  AC79 F1               pop af                  ; restore af if needed
236+  AC7A              control_pl_moveup0:
237+  AC7A 3E 00            ld a,0
238+  AC7C 32 CB AE         ld (player+2),a        ; set direction to up
239+  AC7F C1               pop bc
240+  AC80 C9               ret
241+  AC81              ;
242+  AC81              ; Moves the player down
243+  AC81              ;
244+  AC81              control_pl_movedown:
245+  AC81 C5               push bc
246+  AC82 ED 4B C9 AE      ld bc,(player)          ; get the current coords, b horiz, c vert
247+  AC86 79               ld a,c                  ; load c into the acc
248+  AC87 FE E0            cp 224
249+  AC89 CA A7 AC         jp z,control_pl_movedown0 ; are we at the edge of the screen
250+  AC8C FE 90            cp 144
251+  AC8E D4 0C AD         call nc, control_scroll_down
252+  AC91 CD 12 AE         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
253+  AC94 F5               push af
254+  AC95 7B               ld a,e                  ; put e in a
255+  AC96 FE 00            cp 0
256+  AC98 CA A6 AC         jp z,control_pl_movedown1 ; don't move if we can't
257+  AC9B F1               pop af
258+  AC9C 3C               inc a                   ; add 1
259+  AC9D 3C               inc a                   ; add 1
260+  AC9E 4F               ld c,a                  ; load back to c
261+  AC9F ED 43 C9 AE      ld (player),bc          ; load back to player
262+  ACA3 C3 A7 AC         jp control_pl_movedown0
263+  ACA6              control_pl_movedown1:
264+  ACA6 F1               pop af                  ; restore af if needed
265+  ACA7              control_pl_movedown0:
266+  ACA7 3E 03            ld a,3
267+  ACA9 32 CB AE         ld (player+2),a        ; set direction to down
268+  ACAC C1               pop bc
269+  ACAD C9               ret
270+  ACAE              ;
271+  ACAE              ; Moves the player left
272+  ACAE              ;
273+  ACAE              control_pl_moveleft:
274+  ACAE C5               push bc
275+  ACAF ED 4B C9 AE      ld bc,(player)          ; get the current coords, b horiz, c vert
276+  ACB3 78               ld a,b                  ; load b into the acc
277+  ACB4 FE 10            cp 16
278+  ACB6 CA D7 AC         jp z,control_pl_moveleft0 ; are we at the edge of the screen
279+  ACB9 CD 94 AE         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
280+  ACBC F5               push af
281+  ACBD 7B               ld a,e                  ; put e in a
282+  ACBE FE 00            cp 0
283+  ACC0 CA D6 AC         jp z,control_pl_moveleft1 ; don't move if we can't
284+  ACC3 21 CE AE         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
285+  ACC6 3E 03            ld a,3
286+  ACC8 77               ld (hl),a
287+  ACC9 F1               pop af
288+  ACCA D6 01            sub 1                    ; subtract 2
289+  ACCC D6 01            sub 1
290+  ACCE 47               ld b,a                  ; load back to c
291+  ACCF ED 43 C9 AE      ld (player),bc          ; load back to player
292+  ACD3 C3 D7 AC         jp control_pl_moveleft0
293+  ACD6              control_pl_moveleft1:
294+  ACD6 F1               pop af
295+  ACD7              control_pl_moveleft0:
296+  ACD7 3E 01            ld a,1
297+  ACD9 32 CB AE         ld (player+2),a        ; set direction to left
298+  ACDC C1               pop bc
299+  ACDD C9               ret
300+  ACDE              ;
301+  ACDE              ; Moves the player right
302+  ACDE              ;
303+  ACDE              control_pl_moveright:
304+  ACDE C5               push bc
305+  ACDF ED 4B C9 AE      ld bc,(player)          ; get the current coords, b horiz, c vert
306+  ACE3 78               ld a,b                  ; load b into the acc
307+  ACE4 FE F0            cp 240
308+  ACE6 CA 05 AD         jp z,control_pl_moveright0 ; are we at the edge of the screen
309+  ACE9 CD 6C AE         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
310+  ACEC F5               push af
311+  ACED 7B               ld a,e                  ; put e in a
312+  ACEE FE 00            cp 0
313+  ACF0 CA 04 AD         jp z,control_pl_moveright1 ; don't move if we can't
314+  ACF3 21 CE AE         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
315+  ACF6 3E 03            ld a,3
316+  ACF8 77               ld (hl),a
317+  ACF9 F1               pop af
318+  ACFA 3C               inc a                   ; add 2
319+  ACFB 3C               inc a
320+  ACFC 47               ld b,a                  ; load back to b
321+  ACFD ED 43 C9 AE      ld (player),bc          ; load back to player
322+  AD01 C3 05 AD         jp control_pl_moveright0
323+  AD04              control_pl_moveright1:
324+  AD04 F1               pop af                  ; restore af if needed
325+  AD05              control_pl_moveright0:
326+  AD05 3E 02            ld a,2
327+  AD07 32 CB AE         ld (player+2),a        ; set direction to right
328+  AD0A C1               pop bc
329+  AD0B C9               ret
330+  AD0C
331+  AD0C              ;
332+  AD0C              ; Scrolls the screen down
333+  AD0C              ;
334+  AD0C              control_scroll_down:
335+  AD0C F5               push af
336+  AD0D 3E 07            ld a,7
337+  AD0F 32 74 A1         ld (screen_offset),a
338+  AD12 F1               pop af
339+  AD13 C9               ret
340+  AD14
341+  AD14              ;
342+  AD14              ; Scrolls the screen up
343+  AD14              ;
344+  AD14              control_scroll_up:
345+  AD14 F5               push af
346+  AD15 3E 00            ld a,0
347+  AD17 32 74 A1         ld (screen_offset),a
348+  AD1A F1               pop af
349+  AD1B C9               ret
350+  AD1C
351+  AD1C
352+  AD1C
353+  AD1C
# file closed: game/control.asm
 31   AD1C                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  AD1C              ;
  2+  AD1C              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  3+  AD1C              ; Inputs:
  4+  AD1C              ; hl - memory location of top pixel row
  5+  AD1C              ; bc - screen coords, b horiz, c vert
  6+  AD1C              ; Outputs:
  7+  AD1C              ; e - 0 if not empty, 1 if empty
  8+  AD1C              ;
  9+  AD1C              movement_spaceisempty:
 10+  AD1C 3E 08            ld a,8                          ; 8 rows to check
 11+  AD1E              movement_spaceisempty0:
 12+  AD1E 08               ex af,af'                       ; store the loop counter
 13+  AD1F 7E               ld a,(hl)                       ; get current pixel row
 14+  AD20 FE 00            cp 0
 15+  AD22 C2 36 AD         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 16+  AD25 79               ld a,c                          ; load the vertical coord
 17+  AD26 3C               inc a                           ; next row down
 18+  AD27 11 20 00         ld de,32
 19+  AD2A 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 20+  AD2B 4F               ld c,a                          ; copy vert coord back to c
 21+  AD2C 08               ex af,af'                       ; get loop counter back
 22+  AD2D 3D               dec a                           ; decrease loop counter
 23+  AD2E C2 1E AD         jp nz, movement_spaceisempty0
 24+  AD31 16 00            ld d,0
 25+  AD33 1E 01            ld e,1                          ; got to end, so space is empty
 26+  AD35 C9               ret
 27+  AD36              movement_spaceisempty1:
 28+  AD36 16 00            ld d,0
 29+  AD38 1E 00            ld e,0                          ; returning false, ie space not empty
 30+  AD3A C9               ret
 31+  AD3B
 32+  AD3B              ;
 33+  AD3B              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
 34+  AD3B              ; Inputs:
 35+  AD3B              ; hl - memory location of top pixel row
 36+  AD3B              ; bc - screen coords, b horiz, c vert
 37+  AD3B              ; Outputs:
 38+  AD3B              ; e - 0 if not empty, 1 if empty
 39+  AD3B              ;
 40+  AD3B              movement_linebelowisempty:
 41+  AD3B 7E               ld a,(hl)                       ; get current pixel row
 42+  AD3C FE 00            cp 0
 43+  AD3E C2 46 AD         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
 44+  AD41 16 00            ld d,0
 45+  AD43 1E 01            ld e,1                          ; got to end, so space is empty
 46+  AD45 C9               ret
 47+  AD46              movement_linebelowisempty1:
 48+  AD46 16 00            ld d,0
 49+  AD48 1E 00            ld e,0                          ; returning false, ie space not empty
 50+  AD4A C9               ret
 51+  AD4B
 52+  AD4B              ;
 53+  AD4B              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
 54+  AD4B              ; Inputs:
 55+  AD4B              ; hl - memory location of top pixel row
 56+  AD4B              ; bc - screen coords, b horiz, c vert
 57+  AD4B              ; Outputs:
 58+  AD4B              ; e - 0 if not empty, 1 if empty
 59+  AD4B              ;
 60+  AD4B              movement_lineaboveisempty:
 61+  AD4B 7E               ld a,(hl)                       ; get current pixel row
 62+  AD4C FE 00            cp 0
 63+  AD4E C2 56 AD         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
 64+  AD51 16 00            ld d,0
 65+  AD53 1E 01            ld e,1                          ; got to end, so space is empty
 66+  AD55 C9               ret
 67+  AD56              movement_lineaboveisempty1:
 68+  AD56 16 00            ld d,0
 69+  AD58 1E 00            ld e,0                          ; returning false, ie space not empty
 70+  AD5A C9               ret
 71+  AD5B
 72+  AD5B              ;
 73+  AD5B              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
 74+  AD5B              ; Inputs:
 75+  AD5B              ; hl - memory location of top pixel row
 76+  AD5B              ; bc - screen coords, b horiz, c vert
 77+  AD5B              ; Outputs:
 78+  AD5B              ; none - puts player into digging mode
 79+  AD5B              ;
 80+  AD5B              movement_spaceisdiggable:
 81+  AD5B 3E 08            ld a,8                          ; 8 rows to check
 82+  AD5D              movement_spaceisdiggable0:
 83+  AD5D 08               ex af,af'                       ; store the loop counter
 84+  AD5E 7E               ld a,(hl)                       ; get current pixel row
 85+  AD5F FE 00            cp 0
 86+  AD61 CA 71 AD         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
 87+  AD64 FE 55            cp 85
 88+  AD66 CA 71 AD         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
 89+  AD69 FE AA            cp 170
 90+  AD6B CA 71 AD         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
 91+  AD6E C3 89 AD         jp movement_spaceisdiggable1     ; otherwise, stop checking
 92+  AD71              movement_spaceisdiggable2:
 93+  AD71 79               ld a,c                          ; load the vertical coord
 94+  AD72 3C               inc a                           ; next row down
 95+  AD73 11 20 00         ld de,32
 96+  AD76 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 97+  AD77 4F               ld c,a                          ; copy vert coord back to c
 98+  AD78 08               ex af,af'                       ; get loop counter back
 99+  AD79 3D               dec a                           ; decrease loop counter
100+  AD7A C2 5D AD         jp nz, movement_spaceisdiggable0
101+  AD7D 21 CF AE         ld hl,player+6
102+  AD80 36 01            ld (hl),1                       ; set the player into digging mode
103+  AD82 23               inc hl
104+  AD83 36 05            ld (hl),5                      ; set the number of frame to dig for
105+  AD85 23               inc hl
106+  AD86 36 08            ld (hl),8                       ; set the number of pixels to dig
107+  AD88 C9               ret
108+  AD89              movement_spaceisdiggable1:
109+  AD89 21 CF AE         ld hl,player+6
110+  AD8C 36 00            ld (hl),0                       ; set the player out of digging mode
111+  AD8E C9               ret
112+  AD8F
113+  AD8F              ;
114+  AD8F              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
115+  AD8F              ; Inputs:
116+  AD8F              ; hl - memory location of top pixel row
117+  AD8F              ; bc - screen coords, b horiz, c vert
118+  AD8F              ; Outputs:
119+  AD8F              ; none - puts player into digging mode
120+  AD8F              ;
121+  AD8F              movement_spacebelowisdiggable:
122+  AD8F 7E               ld a,(hl)                       ; get first pixel row
123+  AD90 FE 55            cp 85
124+  AD92 CA 9D AD         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
125+  AD95 FE AA            cp 170
126+  AD97 CA 9D AD         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
127+  AD9A C3 89 AD         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
128+  AD9D              movement_spacebelowisdiggable3:
129+  AD9D 3E 08            ld a,8                          ; rows to check
130+  AD9F 1E 00            ld e,0                          ; count of rows to dig
131+  ADA1              movement_spacebelowisdiggable0:
132+  ADA1 08               ex af,af'                       ; store the loop counter
133+  ADA2 7E               ld a,(hl)                       ; get current pixel row
134+  ADA3 FE 55            cp 85
135+  ADA5 CA B0 AD         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
136+  ADA8 FE AA            cp 170
137+  ADAA CA B0 AD         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
138+  ADAD C3 BF AD         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
139+  ADB0              movement_spacebelowisdiggable4:
140+  ADB0 1C               inc e                           ; inc count of rows to dig
141+  ADB1              movement_spacebelowisdiggable2:
142+  ADB1 79               ld a,c                          ; load the vertical coord
143+  ADB2 3C               inc a                           ; next row down
144+  ADB3 D5               push de                         ; need e for later
145+  ADB4 11 20 00         ld de,32
146+  ADB7 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
147+  ADB8 4F               ld c,a                          ; copy vert coord back to c
148+  ADB9 D1               pop de                          ; get e back
149+  ADBA 08               ex af,af'                       ; get loop counter back
150+  ADBB 3D               dec a                           ; incease loop counter
151+  ADBC C2 A1 AD         jp nz, movement_spacebelowisdiggable0
152+  ADBF              movement_spacebelowisdiggable5:
153+  ADBF 21 CF AE         ld hl,player+6
154+  ADC2 36 01            ld (hl),1                       ; set the player into digging mode
155+  ADC4 23               inc hl
156+  ADC5 36 03            ld (hl),3                      ; set the number of frame to dig for
157+  ADC7 23               inc hl
158+  ADC8 73               ld (hl),e                       ; set the number of pixels to dig
159+  ADC9 C9               ret
160+  ADCA              movement_spacebelowisdiggable1:
161+  ADCA 21 CF AE         ld hl,player+6
162+  ADCD 36 00            ld (hl),0                       ; set the player out of digging mode
163+  ADCF C9               ret
164+  ADD0
165+  ADD0              ;
166+  ADD0              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
167+  ADD0              ; Inputs:
168+  ADD0              ; hl - memory location of top pixel row
169+  ADD0              ; bc - screen coords, b horiz, c vert
170+  ADD0              ; Outputs:
171+  ADD0              ; none - puts player into digging mode
172+  ADD0              ;
173+  ADD0              movement_spaceaboveisdiggable:
174+  ADD0 7E               ld a,(hl)                       ; get first pixel row
175+  ADD1 FE 55            cp 85
176+  ADD3 CA DE AD         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
177+  ADD6 FE AA            cp 170
178+  ADD8 CA DE AD         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
179+  ADDB C3 89 AD         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
180+  ADDE              movement_spaceaboveisdiggable3:
181+  ADDE 3E 08            ld a,8                          ; rows to check
182+  ADE0 1E 00            ld e,0                          ; count of rows to dig
183+  ADE2              movement_spaceaboveisdiggable0:
184+  ADE2 08               ex af,af'                       ; store the loop counter
185+  ADE3 7E               ld a,(hl)                       ; get current pixel row
186+  ADE4 FE 55            cp 85
187+  ADE6 CA F1 AD         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
188+  ADE9 FE AA            cp 170
189+  ADEB CA F1 AD         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
190+  ADEE C3 01 AE         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
191+  ADF1              movement_spaceaboveisdiggable4:
192+  ADF1 1C               inc e                           ; inc count of rows to dig
193+  ADF2              movement_spaceaboveisdiggable2:
194+  ADF2 79               ld a,c                          ; load the vertical coord
195+  ADF3 3D               dec a                           ; next row up
196+  ADF4 D5               push de                         ; need e for later
197+  ADF5 11 20 00         ld de,32
198+  ADF8 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
199+  ADFA 4F               ld c,a                          ; copy vert coord back to c
200+  ADFB D1               pop de                          ; get e back
201+  ADFC 08               ex af,af'                       ; get loop counter back
202+  ADFD 3D               dec a                           ; incease loop counter
203+  ADFE C2 E2 AD         jp nz, movement_spaceaboveisdiggable0
204+  AE01              movement_spaceaboveisdiggable5:
205+  AE01 21 CF AE         ld hl,player+6
206+  AE04 36 01            ld (hl),1                       ; set the player into digging mode
207+  AE06 23               inc hl
208+  AE07 36 05            ld (hl),5                       ; set the number of frame to dig for
209+  AE09 23               inc hl
210+  AE0A 73               ld (hl),e                       ; set the number of pixels to dig
211+  AE0B C9               ret
212+  AE0C              movement_spaceaboveisdiggable1:
213+  AE0C 21 CF AE         ld hl,player+6
214+  AE0F 36 00            ld (hl),0                       ; set the player out of digging mode
215+  AE11 C9               ret
216+  AE12
217+  AE12              ;
218+  AE12              ; Checks if the player can move down
219+  AE12              ; Inputs:
220+  AE12              ; bc - player coords, b horiz, c vert
221+  AE12              ; Outputs:
222+  AE12              ; de - 1 can move
223+  AE12              movement_checkcanmove_down:
224+  AE12 F5               push af
225+  AE13 C5               push bc
226+  AE14 CD A2 A3         call sprites_scadd              ; get the memory location of cell into de
227+  AE17 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
228+  AE19 24               inc h                       ; memory location of cell beneath now in hl
229+  AE1A CD 3B AD         call movement_linebelowisempty       ; check space is empty
230+  AE1D 7B               ld a,e                          ; check space empty flag
231+  AE1E FE 00            cp 0
232+  AE20 CA 29 AE         jp z, movement_checkcanmove_down1 ; can't move
233+  AE23 CD 0C AF         call player_justmoved
234+  AE26 C1               pop bc
235+  AE27 F1               pop af
236+  AE28 C9               ret
237+  AE29              movement_checkcanmove_down1:
238+  AE29 C1               pop bc
239+  AE2A CD A2 A3         call sprites_scadd              ; get the memory location of cell into de
240+  AE2D 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
241+  AE2F 24               inc h
242+  AE30 C5               push bc
243+  AE31 CD 8F AD         call movement_spacebelowisdiggable    ; can't move here, but can we dig
244+  AE34 11 00 00         ld de,0
245+  AE37 C1               pop bc
246+  AE38 F1               pop af
247+  AE39 C9               ret
248+  AE3A
249+  AE3A              ;
250+  AE3A              ; Checks if the player can move up
251+  AE3A              ; Inputs:
252+  AE3A              ; bc - player coords, b horiz, c vert
253+  AE3A              ; Outputs:
254+  AE3A              ; de - 1 can move
255+  AE3A              movement_checkcanmove_up:
256+  AE3A F5               push af
257+  AE3B C5               push bc
258+  AE3C CD A2 A3         call sprites_scadd              ; get the memory location of cell into de
259+  AE3F 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
260+  AE41 11 20 00         ld de,32
261+  AE44 ED 52            sbc hl,de                       ; memory location of line above now in hl
262+  AE46 CD 4B AD         call movement_lineaboveisempty       ; check space is empty
263+  AE49 7B               ld a,e                          ; check space empty flag
264+  AE4A FE 00            cp 0
265+  AE4C CA 57 AE         jp z, movement_checkcanmove_up1 ; can't move
266+  AE4F 1E 01            ld e,1
267+  AE51 CD 0C AF         call player_justmoved
268+  AE54 C1               pop bc
269+  AE55 F1               pop af
270+  AE56 C9               ret
271+  AE57              movement_checkcanmove_up1:
272+  AE57 C1               pop bc
273+  AE58 CD A2 A3         call sprites_scadd              ; get the memory location of cell into de
274+  AE5B 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
275+  AE5D 11 20 00         ld de,32
276+  AE60 ED 52            sbc hl,de                       ; memory location of line above now in hl
277+  AE62 C5               push bc
278+  AE63 CD D0 AD         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
279+  AE66 11 00 00         ld de,0
280+  AE69 C1               pop bc
281+  AE6A F1               pop af
282+  AE6B C9               ret
283+  AE6C
284+  AE6C              ;
285+  AE6C              ; Checks if the player can move right
286+  AE6C              ; Inputs:
287+  AE6C              ; bc - player coords, b horiz, c vert
288+  AE6C              ; Outputs:
289+  AE6C              ; de - 1 can move
290+  AE6C              movement_checkcanmove_right:
291+  AE6C F5               push af
292+  AE6D C5               push bc
293+  AE6E CD A2 A3         call sprites_scadd              ; get the memory location of cell into de
294+  AE71 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
295+  AE73 23               inc hl                          ; memory location of cell to the right now in hl
296+  AE74 CD 1C AD         call movement_spaceisempty       ; check space is empty
297+  AE77 7B               ld a,e                          ; check space empty flag
298+  AE78 FE 00            cp 0
299+  AE7A CA 83 AE         jp z, movement_checkcanmove_right1 ; can't move
300+  AE7D CD 0C AF         call player_justmoved
301+  AE80 C1               pop bc
302+  AE81 F1               pop af
303+  AE82 C9               ret
304+  AE83              movement_checkcanmove_right1:
305+  AE83 C1               pop bc
306+  AE84 CD A2 A3         call sprites_scadd              ; get the memory location of cell into de
307+  AE87 62 6B            ld hl,de
308+  AE89 23               inc hl                          ; memory location of cell to the right now in hl
309+  AE8A C5               push bc
310+  AE8B CD 5B AD         call movement_spaceisdiggable    ; can't move here, but can we dig
311+  AE8E 11 00 00         ld de,0
312+  AE91 C1               pop bc
313+  AE92 F1               pop af
314+  AE93 C9               ret
315+  AE94
316+  AE94              ;
317+  AE94              ; Checks if the player can move left
318+  AE94              ; Inputs:
319+  AE94              ; bc - player coords, b horiz, c vert
320+  AE94              ; Outputs:
321+  AE94              ; de - 1 can move
322+  AE94              movement_checkcanmove_left:
323+  AE94 F5               push af
324+  AE95 C5               push bc
325+  AE96 CD A2 A3         call sprites_scadd              ; get the memory location of cell into de
326+  AE99 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
327+  AE9B 2B               dec hl                          ; memory location of cell to the right now in hl
328+  AE9C CD 1C AD         call movement_spaceisempty       ; check space is empty
329+  AE9F 7B               ld a,e                          ; check space empty flag
330+  AEA0 FE 00            cp 0
331+  AEA2 CA AB AE         jp z, movement_checkcanmove_left1 ; can't move
332+  AEA5 CD 0C AF         call player_justmoved
333+  AEA8 C1               pop bc
334+  AEA9 F1               pop af
335+  AEAA C9               ret
336+  AEAB              movement_checkcanmove_left1:
337+  AEAB C1               pop bc
338+  AEAC CD A2 A3         call sprites_scadd              ; get the memory location of cell into de
339+  AEAF 62 6B            ld hl,de
340+  AEB1 2B               dec hl                          ; memory location of cell to the right now in hl
341+  AEB2 C5               push bc
342+  AEB3 CD 5B AD         call movement_spaceisdiggable    ; can't move here, but can we dig
343+  AEB6 11 00 00         ld de,0
344+  AEB9 C1               pop bc
345+  AEBA F1               pop af
346+  AEBB C9               ret
# file closed: game/movement.asm
 32   AEBC                  include "game\game.asm"
# file opened: game/game.asm
  1+  AEBC              ;
  2+  AEBC              ; The current frame count, incremented each frame
  3+  AEBC              ;
  4+  AEBC              game_framenumber:
  5+  AEBC 00               defb    0
  6+  AEBD
  7+  AEBD              ;
  8+  AEBD              ; Increment frame number by 1
  9+  AEBD              ;
 10+  AEBD              game_incrementframe:
 11+  AEBD 3A BC AE         ld a,(game_framenumber)
 12+  AEC0 3C               inc a
 13+  AEC1 32 BC AE         ld (game_framenumber),a
 14+  AEC4 C9               ret
 15+  AEC5
 16+  AEC5              ;
 17+  AEC5              ; Returns current frame
 18+  AEC5              ; Outputs:
 19+  AEC5              ; a - current frame
 20+  AEC5              ;
 21+  AEC5              game_getcurrentframe:
 22+  AEC5 3A BC AE         ld a,(game_framenumber)
 23+  AEC8 C9               ret
# file closed: game/game.asm
 33   AEC9                  include "game\player.asm"
# file opened: game/player.asm
  1+  AEC9              ;
  2+  AEC9              ;   Data for current player
  3+  AEC9              ;   horiz,vert,dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count,move remaining, is digging (0 no), digging count, pixels to dig
  4+  AEC9              player:
  5+  AEC9 00 00 02 00      defb    0,0,2,0,1,0,0,0,0
  5+  AECD 01 00 00 00
  5+  AED1 00
  6+  AED2              ;
  7+  AED2              ; Initializes a player
  8+  AED2              ;
  9+  AED2              player_init:
 10+  AED2 ED 4B 10 80      ld bc,(start_coord)
 11+  AED6 ED 43 C9 AE      ld (player),bc
 12+  AEDA C9               ret
 13+  AEDB
 14+  AEDB              ;
 15+  AEDB              ; Draws the player at the current position or deletes them
 16+  AEDB              ;
 17+  AEDB              player_drawplayer:
 18+  AEDB 3A CB AE         ld a,(player+2)             ; get the current direction
 19+  AEDE FE 03            cp 3
 20+  AEE0 C2 E5 AE         jp nz,player_drawplayer0
 21+  AEE3 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
 22+  AEE5              player_drawplayer0:
 23+  AEE5 5F               ld e,a                      ; store in e
 24+  AEE6 3A CF AE         ld a,(player+6)             ; get the dig flag
 25+  AEE9 FE 01            cp 1
 26+  AEEB CA F5 AE         jp z,player_drawplayer1    ; get dig frame
 27+  AEEE 3A CC AE         ld a,(player+3)             ; this is normal movement so get the current frame
 28+  AEF1 83               add a,e
 29+  AEF2 C3 FA AE         jp player_drawplayer2
 30+  AEF5              player_drawplayer1
 31+  AEF5 3A CB AE         ld a,(player+2)             ; get the current direction again, because want all four
 32+  AEF8 C6 06            add a,6                     ; add direction to 6 to get frame
 33+  AEFA              player_drawplayer2
 34+  AEFA 07               rlca
 35+  AEFB 07               rlca
 36+  AEFC 07               rlca                        ; multiply by eight
 37+  AEFD 6F               ld l,a
 38+  AEFE 26 00            ld h,0
 39+  AF00 11 10 AA         ld de,player_sprite
 40+  AF03 19               add hl,de                   ; load hl with the location of the player sprite data
 41+  AF04 ED 4B C9 AE      ld bc,(player)              ; load bc with the start coords
 42+  AF08 CD 5F A3         call sprites_drawsprite     ; call the routine to draw the sprite
 43+  AF0B C9               ret
 44+  AF0C
 45+  AF0C
 46+  AF0C              ;
 47+  AF0C              ; Runs after the player just moved. Changes animation frame if required
 48+  AF0C              ;
 49+  AF0C              player_justmoved:
 50+  AF0C D9               exx
 51+  AF0D 3A CD AE         ld a,(player+4)             ; get the transition count
 52+  AF10 FE 00            cp 0
 53+  AF12 CA 18 AF         jp z, player_justmoved2     ; if zero reset and change the frame
 54+  AF15 C3 32 AF         jp player_justmoved1       ; otherwise decrease and continue
 55+  AF18              player_justmoved2:
 56+  AF18                  ; reset and change frame in here
 57+  AF18 3E 01            ld a,1
 58+  AF1A 32 CD AE         ld (player+4),a            ; reset back to whatever
 59+  AF1D 3A CC AE         ld a,(player+3)             ; load the frame
 60+  AF20 FE 03            cp 3                       ; flip between 3 and 0
 61+  AF22 C2 2A AF         jp nz, player_justmoved4
 62+  AF25 3E 00            ld a,0
 63+  AF27 C3 2C AF         jp player_justmoved5
 64+  AF2A              player_justmoved4:
 65+  AF2A 3E 03            ld a,3
 66+  AF2C              player_justmoved5:
 67+  AF2C 32 CC AE         ld (player+3),a           ; save back
 68+  AF2F C3 36 AF         jp player_justmoved3
 69+  AF32              player_justmoved1:
 70+  AF32                  ; decrease count
 71+  AF32 3D               dec a
 72+  AF33 32 CD AE         ld (player+4),a
 73+  AF36              player_justmoved3:
 74+  AF36 D9               exx;
 75+  AF37 C9               ret
# file closed: game/player.asm
 34   AF38                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  AF38              ;
  2+  AF38              ; Ship initial position: vert,horiz
  3+  AF38              ;
  4+  AF38              ship_initpos:
  5+  AF38 00 24            defb 0,36
  6+  AF3A              ship_initpos2:
  7+  AF3A 00 00            defb 0,0
  8+  AF3C              ship_frame:
  9+  AF3C 00               defb 0
 10+  AF3D              ;
 11+  AF3D              ; The current memory location
 12+  AF3D              ;
 13+  AF3D              ship_current_sprite:
 14+  AF3D 00 00            defb 0,0
 15+  AF3F
 16+  AF3F              ship_current_coords:
 17+  AF3F 00 00            defb 0,0
 18+  AF41
 19+  AF41              ;
 20+  AF41              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 21+  AF41              ;
 22+  AF41              ship_land:
 23+  AF41 ED 4B 38 AF      ld bc,(ship_initpos)
 24+  AF45 ED 43 3A AF      ld (ship_initpos2),bc        ; save the initial position for later use
 25+  AF49 1E 00            ld e,0                      ; store a flag to track first time round
 26+  AF4B 06 09            ld b,9                      ; move down 8 pixels
 27+  AF4D              ship_land0:
 28+  AF4D C5               push bc
 29+  AF4E 7B               ld a,e
 30+  AF4F D5               push de                     ; store de for next time round
 31+  AF50 FE 01            cp 1                        ; check first time flag
 32+  AF52 C2 67 AF         jp nz,ship_land1             ; don't draw over previous one if first time
 33+  AF55 CD C0 AF         call ship_draw_full         ; delete old one
 34+  AF58 CD A4 AF         call ship_change_frame      ; increment the frame
 35+  AF5B ED 4B 3A AF      ld bc,(ship_initpos2)       ; get the current coords
 36+  AF5F 81 C6 01         add c,1                     ; move down one pixels
 37+  AF62 4F               ld c,a
 38+  AF63 ED 43 3A AF      ld (ship_initpos2),bc
 39+  AF67              ship_land1:
 40+  AF67 CD C0 AF         call ship_draw_full         ; draw the ship
 41+  AF6A CD B9 AF         call ship_draw_screen
 42+  AF6D D1               pop de
 43+  AF6E 1E 01            ld e,1
 44+  AF70 C1               pop bc
 45+  AF71 10 DA            djnz ship_land0             ; repeat for downward movement
 46+  AF73                  ; done moving down
 47+  AF73                  ; now move across
 48+  AF73 CD DB AE         call player_drawplayer      ; draw player
 49+  AF76 CD C0 AF         call ship_draw_full         ; delete old one
 50+  AF79 1E 00            ld e,0                      ; store a flag to track first time round
 51+  AF7B 06 14            ld b,20                      ; move back 20 pixels pixels
 52+  AF7D              ship_land3:
 53+  AF7D C5               push bc
 54+  AF7E 7B               ld a,e
 55+  AF7F D5               push de                     ; store de for next time round
 56+  AF80 FE 01            cp 1                        ; check first time flag
 57+  AF82 C2 97 AF         jp nz,ship_land2             ; don't draw over previous one if first time
 58+  AF85 CD C0 AF         call ship_draw_full         ; delete old one
 59+  AF88 CD A4 AF         call ship_change_frame      ; increment the frame
 60+  AF8B ED 4B 3A AF      ld bc,(ship_initpos2)       ; get the current coords
 61+  AF8F 78               ld a,b
 62+  AF90 D6 01            sub 1                       ; move back one pixels
 63+  AF92 47               ld b,a
 64+  AF93 ED 43 3A AF      ld (ship_initpos2),bc
 65+  AF97              ship_land2:
 66+  AF97 CD C0 AF         call ship_draw_full         ; draw the ship
 67+  AF9A CD B9 AF         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 68+  AF9D D1               pop de
 69+  AF9E 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 70+  AFA0 C1               pop bc
 71+  AFA1 10 DA            djnz ship_land3             ; repeat for vertical movement
 72+  AFA3 C9               ret
 73+  AFA4
 74+  AFA4              ;
 75+  AFA4              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
 76+  AFA4              ;
 77+  AFA4              ship_change_frame:
 78+  AFA4 F5               push af
 79+  AFA5 3A 3C AF         ld a,(ship_frame)
 80+  AFA8 FE 00            cp 0
 81+  AFAA CA B2 AF         jp z,ship_change_frame0
 82+  AFAD 3E 00            ld a,0                      ; flip to 0
 83+  AFAF C3 B4 AF         jp ship_change_frame1
 84+  AFB2              ship_change_frame0:
 85+  AFB2 3E 20            ld a,32                      ; flip to 32
 86+  AFB4              ship_change_frame1:
 87+  AFB4 32 3C AF         ld (ship_frame),a            ; save the frame
 88+  AFB7 F1               pop af
 89+  AFB8 C9               ret
 90+  AFB9
 91+  AFB9              ship_draw_screen:
 92+  AFB9 76               halt
 93+  AFBA F3               di
 94+  AFBB CD 76 A1         call screen_buffertoscreen  ; copy buffer to screen
 95+  AFBE FB               ei                          ; enable interupts
 96+  AFBF C9               ret
 97+  AFC0
 98+  AFC0              ship_draw_full:
 99+  AFC0 21 60 AA         ld hl,ship_sprite
100+  AFC3 ED 4B 3A AF      ld bc,(ship_initpos2)         ; load bc with the start coords
101+  AFC7 22 3D AF         ld (ship_current_sprite),hl  ; put into memory
102+  AFCA ED 43 3F AF      ld (ship_current_coords),bc  ; put into memory
103+  AFCE CD ED AF         call ship_draw
104+  AFD1 08               ex af,af'
105+  AFD2 3A 3C AF         ld a,(ship_frame)            ; get the animation frame
106+  AFD5 16 00            ld d,0
107+  AFD7 5F               ld e,a
108+  AFD8 19               add hl,de
109+  AFD9 22 3D AF         ld (ship_current_sprite),hl  ; put into memory
110+  AFDC 08               ex af,af'
111+  AFDD ED 4B 3A AF      ld bc,(ship_initpos2)         ; load bc with the start coords
112+  AFE1 81 C6 08         add c,8                      ; move one line down
113+  AFE4 4F               ld c,a
114+  AFE5 ED 43 3F AF      ld (ship_current_coords),bc  ; put into memory
115+  AFE9 CD ED AF         call ship_draw
116+  AFEC C9               ret
117+  AFED
118+  AFED              ;
119+  AFED              ; Draw the ship
120+  AFED              ; Inputs:
121+  AFED              ; None, all in memory
122+  AFED              ;
123+  AFED              ship_draw:
124+  AFED 3E 04            ld a,4                              ; 4 pieces per half
125+  AFEF              ship_draw0:
126+  AFEF F5               push af
127+  AFF0 2A 3D AF         ld hl,(ship_current_sprite)
128+  AFF3 ED 4B 3F AF      ld bc,(ship_current_coords)         ; load bc with the start coords
129+  AFF7 CD 5F A3         call sprites_drawsprite
130+  AFFA 2A 3D AF         ld hl,(ship_current_sprite)
131+  AFFD ED 4B 3F AF      ld bc,(ship_current_coords)         ; load bc with the start coords
132+  B001 11 08 00         ld de,8
133+  B004 19               add hl,de
134+  B005 80 C6 08         add b,8
135+  B008 47               ld b,a
136+  B009 22 3D AF         ld (ship_current_sprite),hl         ; put into memory
137+  B00C ED 43 3F AF      ld (ship_current_coords),bc         ; put into memory
138+  B010 F1               pop af
139+  B011 3D               dec a
140+  B012 FE 00            cp 0
141+  B014 C2 EF AF         jp nz,ship_draw0
142+  B017
143+  B017 C9               ret
144+  B018
# file closed: game/ship.asm
 35   B018                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  B018              ;
  2+  B018              ; tank initial position: vert,horiz
  3+  B018              ;
  4+  B018              tank_initpos:
  5+  B018 10 D0            defb 16,208
  6+  B01A              tank_initpos2:
  7+  B01A 00 00            defb 0,0
  8+  B01C              tank_frame:
  9+  B01C 00               defb 0
 10+  B01D              tank_anim:
 11+  B01D 11               defb 17
 12+  B01E              ;
 13+  B01E              ; The current memory location
 14+  B01E              ;
 15+  B01E              tank_current_sprite:
 16+  B01E 00 00            defb 0,0
 17+  B020
 18+  B020              tank_current_coords:
 19+  B020 00 00            defb 0,0
 20+  B022
 21+  B022              ;
 22+  B022              ; Initialise the tank
 23+  B022              ;
 24+  B022              tank_init:
 25+  B022 ED 4B 18 B0      ld bc,(tank_initpos)
 26+  B026 ED 43 1A B0      ld (tank_initpos2),bc       ; save the initial position for later use
 27+  B02A C9               ret
 28+  B02B
 29+  B02B              ;
 30+  B02B              ;   Draw and move the tank
 31+  B02B              ;   Start processing at frame 200
 32+  B02B              ;   Don't move if anim is zero
 33+  B02B              ;   Decrement frame if moved
 34+  B02B              ;
 35+  B02B              tank_process:
 36+  B02B 3A 1D B0         ld a,(tank_anim)
 37+  B02E FE 00            cp 0
 38+  B030 C8               ret z                       ; return if we've already moved
 39+  B031 CD C5 AE         call game_getcurrentframe   ; get the current frame number into a
 40+  B034 FE 4B            cp 75
 41+  B036 D8               ret c                       ; return if the frame number is below 100
 42+  B037 CD 42 B0         call tank_move              ; move tank if not
 43+  B03A 3A 1D B0         ld a,(tank_anim)
 44+  B03D 3D               dec a
 45+  B03E 32 1D B0         ld (tank_anim),a            ; decrease the anim count
 46+  B041 C9               ret
 47+  B042
 48+  B042              tank_move:
 49+  B042 ED 4B 1A B0      ld bc,(tank_initpos2)
 50+  B046 C5               push bc
 51+  B047 3A 1D B0         ld a,(tank_anim)
 52+  B04A FE 11            cp 17                       ; check first time flag
 53+  B04C CA 5E B0         jp z,tank_move1             ; don't draw over previous one if first time
 54+  B04F CD 63 B0         call tank_draw_full         ; delete old one
 55+  B052 ED 4B 1A B0      ld bc,(tank_initpos2)       ; get the current coords
 56+  B056 78               ld a,b
 57+  B057 D6 01            sub 1                       ; move back one pixels
 58+  B059 47               ld b,a
 59+  B05A ED 43 1A B0      ld (tank_initpos2),bc
 60+  B05E              tank_move1:
 61+  B05E CD 63 B0         call tank_draw_full         ; draw the tank
 62+  B061 C1               pop bc
 63+  B062 C9               ret
 64+  B063
 65+  B063              tank_draw_full:
 66+  B063 21 C0 AA         ld hl,tank_sprite
 67+  B066 ED 4B 1A B0      ld bc,(tank_initpos2)         ; load bc with the start coords
 68+  B06A 22 1E B0         ld (tank_current_sprite),hl  ; put into memory
 69+  B06D ED 43 20 B0      ld (tank_current_coords),bc  ; put into memory
 70+  B071 CD 90 B0         call tank_draw
 71+  B074 08               ex af,af'
 72+  B075 3A 1C B0         ld a,(tank_frame)            ; get the animation frame
 73+  B078 16 00            ld d,0
 74+  B07A 5F               ld e,a
 75+  B07B 19               add hl,de
 76+  B07C 22 1E B0         ld (tank_current_sprite),hl  ; put into memory
 77+  B07F 08               ex af,af'
 78+  B080 ED 4B 1A B0      ld bc,(tank_initpos2)         ; load bc with the start coords
 79+  B084 81 C6 08         add c,8                      ; move one line down
 80+  B087 4F               ld c,a
 81+  B088 ED 43 20 B0      ld (tank_current_coords),bc  ; put into memory
 82+  B08C CD 90 B0         call tank_draw
 83+  B08F C9               ret
 84+  B090
 85+  B090              ;
 86+  B090              ; Draw the tank
 87+  B090              ; Inputs:
 88+  B090              ; None, all in memory
 89+  B090              ;
 90+  B090              tank_draw:
 91+  B090 3E 04            ld a,4                              ; 4 pieces per half
 92+  B092              tank_draw0:
 93+  B092 F5               push af
 94+  B093 2A 1E B0         ld hl,(tank_current_sprite)
 95+  B096 ED 4B 20 B0      ld bc,(tank_current_coords)         ; load bc with the start coords
 96+  B09A CD 5F A3         call sprites_drawsprite
 97+  B09D 2A 1E B0         ld hl,(tank_current_sprite)
 98+  B0A0 ED 4B 20 B0      ld bc,(tank_current_coords)         ; load bc with the start coords
 99+  B0A4 11 08 00         ld de,8
100+  B0A7 19               add hl,de
101+  B0A8 80 C6 08         add b,8
102+  B0AB 47               ld b,a
103+  B0AC 22 1E B0         ld (tank_current_sprite),hl         ; put into memory
104+  B0AF ED 43 20 B0      ld (tank_current_coords),bc         ; put into memory
105+  B0B3 F1               pop af
106+  B0B4 3D               dec a
107+  B0B5 FE 00            cp 0
108+  B0B7 C2 92 B0         jp nz,tank_draw0
109+  B0BA
110+  B0BA C9               ret
111+  B0BB
# file closed: game/tank.asm
 36   B0BB                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  B0BB              ;
  2+  B0BB              ; A structure of falling rocks
  3+  B0BB              ; Assume we'll never have more than 4 falling at any one time
  4+  B0BB              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  B0BB              ;
  6+  B0BB              rocks_falling:
  7+  B0BB 00 00 00 00      defb 0,0,0,0
  8+  B0BF 00 00 00 00      defb 0,0,0,0
  9+  B0C3 00 00 00 00      defb 0,0,0,0
 10+  B0C7 00 00 00 00      defb 0,0,0,0
 11+  B0CB
 12+  B0CB              rocks_tmp:
 13+  B0CB 00               defb 0
 14+  B0CC
 15+  B0CC              rocks_tmp2:
 16+  B0CC 00 00            defb 0,0
 17+  B0CE
 18+  B0CE              ;
 19+  B0CE              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 20+  B0CE              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 21+  B0CE              ; If the pixel row is not the rock bottom, stop checking.
 22+  B0CE              ; Inputs:
 23+  B0CE              ; hl- memory location
 24+  B0CE              ;
 25+  B0CE              rocks_checkforfalling:
 26+  B0CE 7E               ld a,(hl)           ; get the pixel row in this memory location
 27+  B0CF FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 28+  B0D1 C2 D7 B0         jp nz,rocks_checkforfalling2 ; not a rock, stop
 29+  B0D4 CD D8 B0         call rocks_addrocktofalling ; mark the rock as falling
 30+  B0D7              rocks_checkforfalling2:
 31+  B0D7 C9               ret
 32+  B0D8
 33+  B0D8              ;
 34+  B0D8              ; Adds the rock to the structure that tracks falling rocks
 35+  B0D8              ; Inputs:
 36+  B0D8              ; hl - memory location of falling rock graphic
 37+  B0D8              ; bc - coords of rock, c vert
 38+  B0D8              rocks_addrocktofalling:
 39+  B0D8 C5               push bc             ; store the coords
 40+  B0D9 11 BB B0         ld de,rocks_falling
 41+  B0DC 06 04            ld b,4              ; number of possible falling rocks
 42+  B0DE              rocks_addrocktofalling0:
 43+  B0DE 13               inc de
 44+  B0DF 13               inc de
 45+  B0E0 13               inc de              ; move three along to get the state
 46+  B0E1 1A               ld a,(de)           ; load the state
 47+  B0E2 FE 00            cp 0                ; check if this is not falling
 48+  B0E4 C2 F9 B0         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 49+  B0E7 3E 10            ld a,16             ; load the number of frames to wobble
 50+  B0E9 12               ld (de),a
 51+  B0EA 1B               dec de              ; move de back to state
 52+  B0EB 3E 02            ld a,2
 53+  B0ED 12               ld (de),a           ; set the state to wobbling
 54+  B0EE 1B               dec de              ; move back coords
 55+  B0EF C1               pop bc              ; get back coords
 56+  B0F0 78               ld a,b
 57+  B0F1 12               ld (de),a           ; store the vertical
 58+  B0F2 1B               dec de
 59+  B0F3 79               ld a,c
 60+  B0F4 12               ld (de),a           ; store the horizontal
 61+  B0F5 C5               push bc
 62+  B0F6 C3 FC B0         jp rocks_addrocktofalling2 ; done
 63+  B0F9              rocks_addrocktofalling1:
 64+  B0F9 13               inc de              ; move memory along to next rock
 65+  B0FA 10 E2            djnz rocks_addrocktofalling0 ; try the next rock
 66+  B0FC              rocks_addrocktofalling2: ; done, return
 67+  B0FC C1               pop bc              ; to tidy up
 68+  B0FD C9               ret
 69+  B0FE
 70+  B0FE              ;
 71+  B0FE              ; Processes any falling rocks
 72+  B0FE              ;
 73+  B0FE              rocks_processrocks:
 74+  B0FE DD 21 BB B0      ld ix,rocks_falling
 75+  B102 06 04            ld b,4              ; the number of rocks to check
 76+  B104              rocks_processrocks0:
 77+  B104 C5               push bc             ; store loop count
 78+  B105 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 78+  B109 46 01
 79+  B10B DD 23            inc ix
 80+  B10D DD 23            inc ix              ; move to the state
 81+  B10F DD 7E 00         ld a,(ix)           ; load the state into a
 82+  B112 FE 00            cp 0
 83+  B114 CA 33 B1         jp z,rocks_processrocks3 ; if not falling, check next
 84+  B117 FE 02            cp 2
 85+  B119 C2 29 B1         jp nz, rocks_processrocks2
 86+  B11C                  ; we're wobbling
 87+  B11C DD 23            inc ix              ; get frame number for wobble
 88+  B11E DD 7E 00         ld a,(ix)           ; get wobble frame into a
 89+  B121 CD 98 B1         call rocks_wobble
 90+  B124 DD 23            inc ix              ; increment for next
 91+  B126 C3 37 B1         jp rocks_processrocks1  ; do next rock
 92+  B129              rocks_processrocks2:
 93+  B129                  ; we're falling
 94+  B129 CD 3B B1         call rocks_fall
 95+  B12C DD 23            inc ix
 96+  B12E DD 23            inc ix              ; inc ix to get to next
 97+  B130 C3 37 B1         jp rocks_processrocks1
 98+  B133              rocks_processrocks3:
 99+  B133 DD 23            inc ix
100+  B135 DD 23            inc ix
101+  B137              rocks_processrocks1:
102+  B137 C1               pop bc              ; get loop count back
103+  B138 10 CA            djnz rocks_processrocks0
104+  B13A C9               ret
105+  B13B
106+  B13B              ;
107+  B13B              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
108+  B13B              ; bc - coord of current rock graphic on screen
109+  B13B              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
110+  B13B              ;
111+  B13B              rocks_fall:
112+  B13B DD 2B            dec ix
113+  B13D DD 2B            dec ix              ; decrease ix back to coords
114+  B13F ED 43 CC B0      ld (rocks_tmp2),bc  ; store original coords
115+  B143 3E 03            ld a,3              ; move this number of pixels
116+  B145              rocks_fall1:
117+  B145 08               ex af,af'
118+  B146 DD 4E 00 DD      ld bc,(ix)          ; get current coords
118+  B14A 46 01
119+  B14C CD A2 A3         call sprites_scadd  ; get the memory of the coords into de
120+  B14F 14               inc d               ; add 256 to get next row
121+  B150 1A               ld a,(de)           ; get the contents of the next row
122+  B151 FE 00            cp 0
123+  B153 C2 83 B1         jp nz,rocks_fall3    ; move the rock if the row is empty
124+  B156 0C               inc c               ; increment the vertical
125+  B157 DD 71 00 DD      ld (ix),bc          ; store the new coords
125+  B15B 70 01
126+  B15D 08               ex af,af'
127+  B15E 3D               dec a
128+  B15F FE 00            cp 0
129+  B161 C2 45 B1         jp nz,rocks_fall1   ; do another pixel if needed
130+  B164              rocks_fall2:
131+  B164 3E 09            ld a,9              ; rock graphic
132+  B166 ED 4B CC B0      ld bc,(rocks_tmp2)  ; get the original coords
133+  B16A CD 3D A3         call screen_getblock     ; get the memory into hl
134+  B16D CD 5F A3         call sprites_drawsprite  ; draw the sprite - over the top of the current one
135+  B170 3E 09            ld a,9
136+  B172 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
136+  B176 46 01
137+  B178 CD 3D A3         call screen_getblock     ; get the memory into hl
138+  B17B CD 5F A3         call sprites_drawsprite  ; draw the sprite - over the top of the current one
139+  B17E DD 23            inc ix
140+  B180 DD 23            inc ix                  ; get ix back to state
141+  B182 C9               ret
142+  B183              rocks_fall3:
143+  B183 3E 00            ld a,0              ; set the state to fell
144+  B185 DD 77 02         ld (ix+2),a           ; store the falling state
145+  B188 DD 4E 00 DD      ld bc,(ix)          ; get the coords
145+  B18C 46 01
146+  B18E CD 02 A3         call screen_getattraddressfromscreencoords ; get the attr address into de
147+  B191 62 6B            ld hl,de
148+  B193 36 42            ld (hl),66
149+  B195 C3 64 B1         jp rocks_fall2      ; rejoin main loop
150+  B198
151+  B198              ;
152+  B198              ; Wobbles a rocks
153+  B198              ; Inputs:
154+  B198              ; bc - coord of current rock graphic on screen
155+  B198              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
156+  B198              ; a - wobble frame
157+  B198              rocks_wobble:
158+  B198 3A CB B0         ld a,(rocks_tmp)    ; get the frame toggle
159+  B19B 1E 09            ld e,9              ; this is the rock frame
160+  B19D 83               add a,e             ; add the frame toggle
161+  B19E C5               push bc
162+  B19F CD 3D A3         call screen_getblock     ; get the memory into hl
163+  B1A2 CD 5F A3         call sprites_drawsprite  ; draw the sprite - over the top of the current one
164+  B1A5 3A CB B0         ld a,(rocks_tmp)    ; get the frame toggle against
165+  B1A8 EE 01            xor 1               ; flip to other state
166+  B1AA 32 CB B0         ld (rocks_tmp),a    ; store
167+  B1AD 1E 09            ld e,9              ; this is the rock frame
168+  B1AF 83               add a,e             ; add the frame toggle
169+  B1B0 CD 3D A3         call screen_getblock     ; get the memory into hl
170+  B1B3 C1               pop bc
171+  B1B4 CD 5F A3         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
172+  B1B7 DD 7E 00         ld a,(ix)           ; get the wobble count back
173+  B1BA 3D               dec a               ; decrease
174+  B1BB DD 77 00         ld (ix),a           ; store
175+  B1BE FE 00            cp 0
176+  B1C0 C0               ret nz              ; if we're not at zero, return
177+  B1C1 DD 2B            dec ix              ; otherwise look to state location
178+  B1C3 3E 01            ld a,1              ; set the state to falling
179+  B1C5 DD 77 00         ld (ix),a           ; store the falling state
180+  B1C8 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
181+  B1CA C9               ret
182+  B1CB
# file closed: game/rocks.asm
 37   B1CB
 38   B1CB              ;===========================================================================
 39   B1CB              ; main routine - the code execution starts here.
 40   B1CB              ; Sets up the new interrupt routine, the memory
 41   B1CB              ; banks and jumps to the start loop.
 42   B1CB              ;===========================================================================
 43   B1CB              main:
 44   B1CB
 45   B1CB                  ; Setup stack
 46   B1CB 31 C9 B2         ld sp,stack_top
 47   B1CE
 48   B1CE                  ; Draw the title screen
 49   B1CE CD C7 A3         call titlescreen_show
 50   B1D1
 51   B1D1 CD 00 80         call init_start
 52   B1D4 CD 1C A2         call screen_draw
 53   B1D7 CD D2 AE         call player_init
 54   B1DA CD 41 AF         call ship_land              ; land the ship
 55   B1DD CD 22 B0         call tank_init
 56   B1E0
 57   B1E0              mloop:
 58   B1E0 76               halt
 59   B1E1 CD E7 B1         call main_loop_processing
 60   B1E4 C3 E0 B1         jp mloop
 61   B1E7
 62   B1E7              main_loop_processing:
 63   B1E7 F3               di
 64   B1E8 CD 76 A1         call screen_buffertoscreen  ; copy buffer to screen
 65   B1EB FB               ei                          ; enable interupts
 66   B1EC
 67   B1EC CD DB AE         call player_drawplayer      ; delete player
 68   B1EF CD 08 AB         call control_keyboard       ; check keyboard
 69   B1F2 CD DB AE         call player_drawplayer      ; draw player
 70   B1F5 CD 2B B0         call tank_process           ; prcoess the tank
 71   B1F8 CD FE B0         call rocks_processrocks     ; process falling rocks
 72   B1FB
 73   B1FB CD BD AE         call game_incrementframe    ; increment the game frame
 74   B1FE
 75   B1FE C9               ret
 76   B1FF
 77   B1FF              ;===========================================================================
 78   B1FF              ; Stack.
 79   B1FF              ;===========================================================================
 80   B1FF
 81   B1FF              ; Stack: this area is reserved for the stack
 82   B1FF              STACK_SIZE: equ 100    ; in words
 83   B1FF
 84   B1FF              ; Reserve stack space
 85   B1FF 00 00            defw 0  ; WPMEM, 2
 86   B201              stack_bottom:
 87   B201 00 00 00...      defs    STACK_SIZE*2, 0
 88   B2C9              stack_top:
 89   B2C9 00 00            defw 0  ; WPMEM, 2
 90   B2CB
 91   B2CB                     SAVESNA "ThePit.sna", main
# file closed: main.asm
