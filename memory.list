# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; main routine - the code execution starts here.
 19   8000              ; Sets up the new interrupt routine, the memory
 20   8000              ; banks and jumps to the start loop.
 21   8000              ;===========================================================================
 22   8000              main:
 23   8000 CD 13 B0         call options_show
 24   8003
 25   8003                  ; Draw the title screen
 26   8003              main_titlescreen:
 27   8003 CD 22 AC         call titlescreen_show
 28   8006 CD 6B BE         call game_init
 29   8009 CD D7 BE         call player_init_gamestart
 30   800C
 31   800C              main_lifestart:
 32   800C
 33   800C CD FD BE         call player_init_lifestart
 34   800F
 35   800F CD A2 AD         call lifescreen_draw        ; show the lives remaining screen
 36   8012
 37   8012 CD BD 80         call init_start
 38   8015 CD EC A8         call screen_draw
 39   8018 CD 3B A8         call buffer_allbuffertoscreen
 40   801B
 41   801B CD FE C7         call missiles_init
 42   801E CD FE C0         call ship_land              ; land the ship
 43   8021 CD 11 C2         call tank_init
 44   8024 CD C6 C7         call diamonds_init
 45   8027 CD AF C9         call thepit_init
 46   802A CD 46 CA         call monster_init
 47   802D CD 21 CB         call robots_init
 48   8030 CD B1 CE         call bullet_init
 49   8033
 50   8033              mloop:
 51   8033                  ;halt
 52   8033 CD 7A 80         call main_loop_processing
 53   8036
 54   8036                  ;
 55   8036                  ; Check if the player died
 56   8036                  ;
 57   8036 21 9B BE         ld hl,player+10
 58   8039 7E               ld a,(hl)                   ; check if the player died this frame
 59   803A FE 01            cp 1
 60   803C C2 66 80         jp nz,mloop0
 61   803F CD 8E BF         call player_died        ; do end of life housekeeping
 62   8042 06 28            ld b,40
 63   8044 CD 58 81         call utilities_pauseforframes
 64   8047
 65   8047 21 9A BE         ld hl,player+9        ; check lives remaining
 66   804A 7E               ld a,(hl)
 67   804B FE 00            cp 0
 68   804D C2 60 80         jp nz,mloop1         ; haven't finished, so keep going
 69   8050
 70   8050 3A 50 BE         ld a,(game_numberplayers) ; get the number of players
 71   8053 FE 01            cp 1
 72   8055 CA AE 80         jp z,main_gameover   ; if just one player, then this is game over
 73   8058
 74   8058 3A 51 BE         ld a,(game_currentplayer) ; get the current player
 75   805B FE 02            cp 2                    ; if we're here, we have no lives, and if the current player is 2, then we're done
 76   805D CA AE 80         jp z,main_gameover            ; if it's  two game over
 77   8060
 78   8060              mloop1:
 79   8060 CD 55 BE         call game_changeplayer ; change player if needed
 80   8063 C3 0C 80         jp main_lifestart    ; otherwise, start a new life
 81   8066              mloop0:
 82   8066                  ;
 83   8066                  ; Check if the player completed the level
 84   8066                  ;
 85   8066 21 9E BE         ld hl,player+13
 86   8069 7E               ld a,(hl)
 87   806A FE 01            cp 1
 88   806C C2 33 80         jp nz,mloop
 89   806F CD C8 C0         call player_checkforexit
 90   8072 FE 01            cp 1                        ; look at return, if 1, level has been completed
 91   8074 CA B4 80         jp z,main_endlevel          ; jump to level transition screen
 92   8077 C3 33 80         jp mloop                ; start the loop again
 93   807A
 94   807A
 95   807A              main_loop_processing:
 96   807A
 97   807A CD FA A7         call buffer_buffertoscreen  ; copy buffer to screen
 98   807D CD 5F A7         call buffer_clearlist       ; zero the updated lines list
 99   8080 CD A1 BE         call player_getlocation     ; figure out where the player is
100   8083 CD D2 BF         call player_drawplayer      ; delete player
101   8086 CD 4C B9         call control_input          ; check input
102   8089 CD D2 BF         call player_drawplayer      ; draw player
103   808C CD 40 C2         call tank_process           ; prcoess the tank
104   808F CD E9 C0         call ship_process           ; proces the ship
105   8092 CD 44 C4         call rocks_processrocks     ; process falling rocks
106   8095 CD BA C9         call thepit_process         ; process the pit trap
107   8098 CD 26 C8         call missiles_process       ; process missiles
108   809B CD 63 CA         call monster_process        ; process monster
109   809E CD A4 CB         call robots_process         ; process robots
110   80A1 CD F8 CE         call bullet_process         ; process the bullet
111   80A4 CD A5 C7         call diamonds_twinkle       ; make the diamonds twinkle
112   80A7 CD B7 C5         call scores_printscore      ; update the score on screen
113   80AA CD 71 BE         call game_incrementframe    ; increment the game frame
114   80AD
115   80AD C9               ret
116   80AE
117   80AE              main_gameover:
118   80AE CD 02 AE         call gameover_draw          ; show the game over screen
119   80B1 C3 03 80         jp main_titlescreen         ; go back to title
120   80B4
121   80B4              main_endlevel:
122   80B4 CD 5C BF         call player_recordcurrentstate
123   80B7 CD 0B AF         call endlevel_draw          ; show the end level screen
124   80BA C3 0C 80         jp main_lifestart           ; start a new life
125   80BD
126   80BD
127   80BD              ;===========================================================================
128   80BD              ; Include modules
129   80BD              ;===========================================================================
130   80BD                  include "init.asm"
# file opened: init.asm
  1+  80BD              ;
  2+  80BD              ; Set up at start up
  3+  80BD              ;
  4+  80BD              init_start:
  5+  80BD              ; We want a black screen.
  6+  80BD
  7+  80BD 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  80BF                                      ; bright (64).
  9+  80BF CD 3D 81         call utilities_clearscreen
 10+  80C2 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  80C5 AF               xor a               ; quick way to load accumulator with zero.
 12+  80C6 CD 9B 22         call 8859           ; set permanent border colours.
 13+  80C9
 14+  80C9 21 D1 A8         ld hl,screen_offset ; reset some temp variables
 15+  80CC 36 00            ld (hl),0
 16+  80CE 21 D2 A8         ld hl,screen_tmp
 17+  80D1 36 00            ld (hl),0
 18+  80D3 21 07 A7         ld hl,buffer_tmp
 19+  80D6 36 00            ld (hl),0
 20+  80D8 23               inc hl
 21+  80D9 36 00            ld (hl),0
 22+  80DB
 23+  80DB CD 84 BE         call game_resetcurrentframe ; reset current frame
 24+  80DE
 25+  80DE C9               ret
 26+  80DF
 27+  80DF              ;
 28+  80DF              ;   Start coord
 29+  80DF              ;   vert c, horiz b
 30+  80DF              init_coord:
 31+  80DF 18 30            defb 24,48
 32+  80E1
 33+  80E1              ;
 34+  80E1              ; Number of lives to start
 35+  80E1              ;
 36+  80E1              init_lives:
 37+  80E1 03               defb 3
 38+  80E2
 39+  80E2              ;
 40+  80E2              ; Score to start
 41+  80E2              ;
 42+  80E2              init_score:
 43+  80E2 30 30 30 30      defb '000000'
 43+  80E6 30 30
# file closed: init.asm
131   80E8                  include "utilities.asm"
# file opened: utilities.asm
  1+  80E8              ; ##########################################################################
  2+  80E8              ; Print a character
  3+  80E8              ; Inputs:
  4+  80E8              ; b - x coord
  5+  80E8              ; c - y coord
  6+  80E8              ; d - character
  7+  80E8              ; e - colour
  8+  80E8              ; ##########################################################################
  9+  80E8              utilities_print_char:
 10+  80E8 7B               ld a,e
 11+  80E9 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  80EC 3E 16            ld a,22
 13+  80EE D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  80EF 78               ld a,b              ; Gets the X co-ordinate
 15+  80F0 3D               dec a
 16+  80F1 D7               rst 16
 17+  80F2 79               ld a,c              ; and the Y co-ordinate
 18+  80F3 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  80F4 7A               ld a,d              ; ASCII code for udg.
 20+  80F5 D7               rst 16              ; draw block.
 21+  80F6 C9               ret
 22+  80F7
 23+  80F7
 24+  80F7              ;Inputs:
 25+  80F7              ;     DE and A are factors
 26+  80F7              ;Outputs:
 27+  80F7              ;     A is not changed
 28+  80F7              ;     B is 0
 29+  80F7              ;     C is not changed
 30+  80F7              ;     DE is not changed
 31+  80F7              ;     HL is the product
 32+  80F7              ;Time:
 33+  80F7              ;     342+6x
 34+  80F7              ;
 35+  80F7              utilities_multiply:
 36+  80F7 06 08            ld b,8          ;7           7
 37+  80F9 21 00 00         ld hl,0         ;10         10
 38+  80FC 29               add hl,hl     ;11*8       88
 39+  80FD 07               rlca          ;4*8        32
 40+  80FE 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8100 19                   add hl,de   ;--         --
 42+  8101 10 F9            djnz $-5      ;13*7+8     99
 43+  8103 C9               ret             ;10         10
 44+  8104
 45+  8104              utilities_waitforkey:
 46+  8104 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  8107 36 00            ld (hl),0           ; put null value there.
 48+  8109              utilities_waitforkey0:
 49+  8109 7E               ld a,(hl)           ; new value of LAST K.
 50+  810A FE 00            cp 0                ; is it still zero?
 51+  810C 20 0A            jr nz,utilities_waitforkey1           ; yes, so no key pressed.
 52+  810E 01 1F 00         ld bc,31                        ; Kempston joystick port.
 53+  8111 ED 78            in a,(c)                        ; read input.
 54+  8113 E6 10            and 16
 55+  8115 CA 09 81         jp z,utilities_waitforkey0
 56+  8118              utilities_waitforkey1:
 57+  8118 C9               ret                 ; key was pressed.
 58+  8119
 59+  8119              ;
 60+  8119              ; Waits number of frames for keypress. If got, returns 1, if not 0
 61+  8119              ; Inputs:
 62+  8119              ; a - number of frames to waits
 63+  8119              ; Ouputs:
 64+  8119              ; e - 0 not pressed, 1 pressed
 65+  8119              utilities_waitforkey_forframes:
 66+  8119 21 08 5C         ld hl,23560         ; LAST K system variable.
 67+  811C 36 00            ld (hl),0           ; put null value there.
 68+  811E 47               ld b,a              ; number of frames to wait
 69+  811F              utilities_waitforkey_forframes0:
 70+  811F 7E               ld a,(hl)           ; new value of LAST K.
 71+  8120 FE 00            cp 0                ; is it still zero?
 72+  8122 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 73+  8124 1E 01            ld e,1              ; set the pressed flag
 74+  8126 C9               ret                 ; key was pressed.
 75+  8127              utilities_waitforkey_forframes1:
 76+  8127 C5               push bc
 77+  8128 01 1F 00         ld bc,31                        ; Kempston joystick port.
 78+  812B ED 78            in a,(c)                        ; read input.
 79+  812D C1               pop bc
 80+  812E E6 10            and 16
 81+  8130 CA 36 81         jp z,utilities_waitforkey_forframes2
 82+  8133 1E 01            ld e,1              ; set the pressed flag
 83+  8135 C9               ret                 ; key was pressed.
 84+  8136              utilities_waitforkey_forframes2:
 85+  8136 76               halt                ; wait for frame
 86+  8137 76               halt                ; wait for frame
 87+  8138 10 E5            djnz utilities_waitforkey_forframes0 ; loop again
 88+  813A 1E 00            ld e,0              ; nothing pressed in time
 89+  813C C9               ret
 90+  813D
 91+  813D              ;
 92+  813D              ; Clears the screen
 93+  813D              ; Inputs:
 94+  813D              ; a - attribute colour
 95+  813D              utilities_clearscreen:
 96+  813D 76               halt
 97+  813E 21 00 58         ld hl,22528         ; attr
 98+  8141 11 01 58         ld de,22529         ; attr+1
 99+  8144 01 FF 02         ld bc,767
100+  8147 77               ld (hl),a
101+  8148 ED B0            ldir
102+  814A
103+  814A 21 00 40         ld hl, 16384        ;pixels
104+  814D 11 01 40         ld de, 16385        ;pixels + 1
105+  8150 01 FF 17         ld bc, 6143         ;pixels area length - 1
106+  8153 36 00            ld (hl), 0          ;set first byte to '0'
107+  8155 ED B0            ldir                ;copy bytes
108+  8157
109+  8157 C9               ret
110+  8158
111+  8158              ;
112+  8158              ; Wait for a number of frames
113+  8158              ; Inputs:
114+  8158              ; b - number of frames
115+  8158              utilities_pauseforframes:
116+  8158 76               halt
117+  8159 10 FD            djnz utilities_pauseforframes
118+  815B C9               ret
119+  815C
120+  815C              utilities_readkey:
121+  815C 21 7C 81         LD HL,utilties_keymap              ; Point HL at the keyboard list
122+  815F 16 08            LD D,8                                  ; This is the number of ports (rows) to check
123+  8161 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
124+  8163              utilities_readkey_0:
125+  8163 46               LD B,(HL)                               ; Get the keyboard port address from table
126+  8164 23               INC HL                                  ; Increment to list of keys
127+  8165 ED 78            IN A,(C)                                ; Read the row of keys in
128+  8167 E6 1F            AND $1F                                     ; We are only interested in the first five bits
129+  8169 1E 05            LD E,5                                  ; This is the number of keys in the row
130+  816B              utilities_readkey_1:
131+  816B CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
132+  816D 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
133+  816F 23               INC HL                                  ; Go to next table address
134+  8170 1D               DEC E                                   ; Decrement key loop counter
135+  8171 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
136+  8173 15               DEC D                                   ; Decrement row loop counter
137+  8174 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
138+  8176 A7               AND A                                   ; Clear A (no key found)
139+  8177 C3 5C 81         jp utilities_readkey
140+  817A              utilities_readkey_2:
141+  817A 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
142+  817B C9               RET
143+  817C
144+  817C              utilties_keymap:
145+  817C FE 23 5A 58      defb $FE,"#","Z","X","C","V"
145+  8180 43 56
146+  8182 FD 41 53 44      defb $FD,"A","S","D","F","G"
146+  8186 46 47
147+  8188 FB 51 57 45      defb $FB,"Q","W","E","R","T"
147+  818C 52 54
148+  818E F7 31 32 33      defb $F7,"1","2","3","4","5"
148+  8192 34 35
149+  8194 EF 30 39 38      defb $EF,"0","9","8","7","6"
149+  8198 37 36
150+  819A DF 50 4F 49      defb $DF,"P","O","I","U","Y"
150+  819E 55 59
151+  81A0 BF 23 4C 4B      defb $BF,"#","L","K","J","H"
151+  81A4 4A 48
152+  81A6 7F 20 23 4D      defb $7F," ","#","M","N","B"
152+  81AA 4E 42
153+  81AC
154+  81AC
155+  81AC              ;
156+  81AC              ; Generates a randomish number in the range 0 to e
157+  81AC              ; Inputs:
158+  81AC              ; e - upper value
159+  81AC              ; Outputs:
160+  81AC              ; a - random number
161+  81AC              utilities_randomupper
162+  81AC 3A 4F BE         ld a,(game_framenumber)
163+  81AF 6F               ld l,a
164+  81B0 26 00            ld h,0
165+  81B2 16 00            ld d,0
166+  81B4 42 4B            ld bc,de
167+  81B6              utilities_randomupper0:
168+  81B6 B7               or a
169+  81B7 ED 42            sbc hl,bc
170+  81B9 F2 B6 81         jp p,utilities_randomupper0
171+  81BC 09               add hl,bc
172+  81BD 01 00 00         ld bc,0
173+  81C0 09               add hl,bc
174+  81C1 7D               ld a,l
175+  81C2 C9               ret
# file closed: utilities.asm
132   81C3                  include "strings.asm"
# file opened: strings.asm
  1+  81C3              string_score1:
  2+  81C3 04 00 53 43      defb 4,0,'SCORE1',255
  2+  81C7 4F 52 45 31
  2+  81CB FF
  3+  81CC              string_scorenumbers1:
  4+  81CC 04 01 30 30      defb 4,1,'000000',255
  4+  81D0 30 30 30 30
  4+  81D4 FF
  5+  81D5              string_company:
  6+  81D5 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  81D9 4E 54 55 52
  6+  81DD 49 FF
  7+  81DF              string_player1:
  8+  81DF 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  81E3 41 59 45 52
  8+  81E7 20 31 FF
  9+  81EA              string_player2:
 10+  81EA 0C 01 50 4C      defb 12,1,'PLAYER 2',255
 10+  81EE 41 59 45 52
 10+  81F2 20 32 FF
 11+  81F5              string_score2:
 12+  81F5 16 00 53 43      defb 22,0,'SCORE2',255
 12+  81F9 4F 52 45 32
 12+  81FD FF
 13+  81FE              string_scorenumbers2:
 14+  81FE 16 01 30 30      defb 22,1,'000000',255
 14+  8202 30 30 30 30
 14+  8206 FF
 15+  8207              string_titlescreen_copyright:
 16+  8207 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 16+  820B 39 38 32 20
 16+  820F 20 43 45 4E
 16+  8213 54 55 52 49
 16+  8217 20 49 4E 43
 16+  821B FF
 17+  821C
 18+  821C
 19+  821C              string_alttitlescreen_1:
 20+  821C 0C 00 43 52      defb 12,0,'CREDITS 1',255
 20+  8220 45 44 49 54
 20+  8224 53 20 31 FF
 21+  8228              string_alttitlescreen_2:
 22+  8228 00 02 20 20      defb 0,2,'           THE OBJECT',254
 22+  822C 20 20 20 20
 22+  8230 20 20 20 20
 22+  8234 20 54 48 45
 22+  8238 20 4F 42 4A
 22+  823C 45 43 54 FE
 23+  8240 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 23+  8244 20 20 20 20
 23+  8248 20 20 20 20
 23+  824C 4F 46 20 54
 23+  8250 48 49 53 20
 23+  8254 47 41 4D 45
 23+  8258 FE
 24+  8259 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 24+  825D 20 20 20 20
 24+  8261 20 20 20 49
 24+  8265 53 20 54 4F
 24+  8269 20 44 49 47
 24+  826D 20 44 4F 57
 24+  8271 4E FE
 25+  8273 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 25+  8277 20 20 20 20
 25+  827B 20 20 54 4F
 25+  827F 20 54 48 45
 25+  8283 20 42 4F 54
 25+  8287 54 4F 4D 20
 25+  828B 50 49 54 FE
 26+  828F 00 06 20 20      defb 0,6,'               AND',254
 26+  8293 20 20 20 20
 26+  8297 20 20 20 20
 26+  829B 20 20 20 20
 26+  829F 20 41 4E 44
 26+  82A3 FE
 27+  82A4 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 27+  82A8 20 20 20 20
 27+  82AC 20 20 43 4F
 27+  82B0 4C 4C 45 43
 27+  82B4 54 20 41 54
 27+  82B8 20 4C 45 41
 27+  82BC 53 54 FE
 28+  82BF 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 28+  82C3 20 20 20 20
 28+  82C7 20 20 20 4F
 28+  82CB 4E 45 20 4C
 28+  82CF 41 52 47 45
 28+  82D3 20 4A 45 57
 28+  82D7 45 4C FE
 29+  82DA 00 09 20 20      defb 0,9,'              THEN',254
 29+  82DE 20 20 20 20
 29+  82E2 20 20 20 20
 29+  82E6 20 20 20 20
 29+  82EA 54 48 45 4E
 29+  82EE FE
 30+  82EF 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 30+  82F3 20 20 20 20
 30+  82F7 20 20 20 52
 30+  82FB 45 54 55 52
 30+  82FF 4E 20 54 4F
 30+  8303 20 53 48 49
 30+  8307 50 FE
 31+  8309 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 31+  830D 20 20 20 20
 31+  8311 20 20 20 54
 31+  8315 48 52 55 20
 31+  8319 55 50 50 45
 31+  831D 52 20 50 49
 31+  8321 54 FF
 32+  8323              string_alttitlescreen_3:
 33+  8323 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 33+  8327 20 20 53 49
 33+  832B 4E 47 4C 45
 33+  832F 20 42 4F 4E
 33+  8333 55 53 20 20
 33+  8337 35 30 30 30
 33+  833B 20 50 4F 49
 33+  833F 4E 54 53 FE
 34+  8343 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 34+  8347 20 20 20 20
 34+  834B 43 4F 4C 4C
 34+  834F 45 43 54 20
 34+  8353 31 20 4C 41
 34+  8357 52 47 45 20
 34+  835B 4A 45 57 45
 34+  835F 4C FE
 35+  8361 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 35+  8365 20 20 20 20
 35+  8369 20 41 4E 44
 35+  836D 20 52 45 54
 35+  8371 55 52 4E 20
 35+  8375 54 4F 20 53
 35+  8379 48 49 50 FE
 36+  837D 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 36+  8381 20 20 44 4F
 36+  8385 55 42 4C 45
 36+  8389 20 42 4F 4E
 36+  838D 55 53 20 20
 36+  8391 31 30 30 30
 36+  8395 30 20 50 4F
 36+  8399 49 4E 54 53
 36+  839D FE
 37+  839E 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 37+  83A2 20 20 43 4F
 37+  83A6 4C 4C 45 43
 37+  83AA 54 20 41 4C
 37+  83AE 4C 20 33 20
 37+  83B2 4C 41 52 47
 37+  83B6 45 20 4A 45
 37+  83BA 57 45 4C 53
 37+  83BE FE
 38+  83BF 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 38+  83C3 20 20 20 20
 38+  83C7 20 4F 52 20
 38+  83CB 20 20 41 4C
 38+  83CF 4C 20 34 20
 38+  83D3 53 4D 41 4C
 38+  83D7 4C 20 4A 45
 38+  83DB 57 45 4C 53
 38+  83DF FE
 39+  83E0 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 39+  83E4 20 20 54 52
 39+  83E8 49 50 4C 45
 39+  83EC 20 42 4F 4E
 39+  83F0 55 53 20 20
 39+  83F4 31 35 30 30
 39+  83F8 30 20 50 4F
 39+  83FC 49 4E 54 53
 39+  8400 FE
 40+  8401 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 40+  8405 20 20 20 20
 40+  8409 20 43 4F 4C
 40+  840D 4C 45 43 54
 40+  8411 20 41 4C 4C
 40+  8415 20 37 20 4A
 40+  8419 45 57 45 4C
 40+  841D 53 FF
 41+  841F
 42+  841F              string_lifescreen_player:
 43+  841F 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 43+  8423 4C 41 59 45
 43+  8427 52 20 31 20
 43+  842B FF
 44+  842C              string_lifescreen_lives:
 45+  842C 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 45+  8430 4D 45 4E 20
 45+  8434 4C 45 46 54
 45+  8438 FF
 46+  8439              string_lifescreen_lastman:
 47+  8439 0C 03 4C 41      defb 12,3,'LAST MAN',255
 47+  843D 53 54 20 4D
 47+  8441 41 4E FF
 48+  8444
 49+  8444              string_gameoverscreen_gameover:
 50+  8444 0B 06 47 41      defb 11,6,'GAME OVER',255
 50+  8448 4D 45 20 4F
 50+  844C 56 45 52 FF
 51+  8450              string_gameoverscreen_copyright:
 52+  8450 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 52+  8454 39 38 32 20
 52+  8458 43 45 4E 54
 52+  845C 55 52 49 20
 52+  8460 49 4E 43 FF
 53+  8464              string_gameoverscreen_bestscores:
 54+  8464 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 54+  8468 53 54 20 53
 54+  846C 43 4F 52 45
 54+  8470 53 20 54 4F
 54+  8474 44 41 59 FF
 55+  8478              string_gameover_credits:
 56+  8478 0C 01 43 52      defb 12,1,'CREDITS 0',255
 56+  847C 45 44 49 54
 56+  8480 53 20 30 FF
 57+  8484
 58+  8484              string_highscore_congratulations:
 59+  8484 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 59+  8488 4E 47 52 41
 59+  848C 54 55 4C 41
 59+  8490 54 49 4F 4E
 59+  8494 53 FF
 60+  8496              string_highscore_player1:
 61+  8496 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 61+  849A 41 59 45 52
 61+  849E 20 31 FF
 62+  84A1              string_highscore_player2:
 63+  84A1 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 63+  84A5 41 59 45 52
 63+  84A9 20 32 FF
 64+  84AC              string_highscore_youhaveearned:
 65+  84AC 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 65+  84B0 55 20 48 41
 65+  84B4 56 45 20 45
 65+  84B8 41 52 4E 45
 65+  84BC 44 FF
 66+  84BE              string_highscore_place1:
 67+  84BE 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 67+  84C2 45 20 47 52
 67+  84C6 45 41 54 45
 67+  84CA 53 54 20 53
 67+  84CE 43 4F 52 45
 67+  84D2 FF
 68+  84D3              string_highscore_place2:
 69+  84D3 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 69+  84D7 45 20 32 4E
 69+  84DB 44 20 42 45
 69+  84DF 53 54 20 53
 69+  84E3 43 4F 52 45
 69+  84E7 FF
 70+  84E8              string_highscore_place3:
 71+  84E8 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 71+  84EC 45 20 33 52
 71+  84F0 44 20 42 45
 71+  84F4 53 54 20 53
 71+  84F8 43 4F 52 45
 71+  84FC FF
 72+  84FD              string_highscore_pleaseenter
 73+  84FD 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 73+  8501 43 4F 52 44
 73+  8505 20 59 4F 55
 73+  8509 52 20 49 4E
 73+  850D 49 54 49 41
 73+  8511 4C 53 20 42
 73+  8515 45 4C 4F 57
 73+  8519 FF
 74+  851A
 75+  851A              string_endlevel_youhaveearned:
 76+  851A 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 76+  851E 55 20 48 41
 76+  8522 56 45 20 45
 76+  8526 41 52 4E 45
 76+  852A 44 FF
 77+  852C              string_endlevel_bonus1:
 78+  852C 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 78+  8530 4E 47 4C 45
 78+  8534 20 42 4F 4E
 78+  8538 55 53 FF
 79+  853B              string_endlevel_bonus2:
 80+  853B 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 80+  853F 55 42 4C 45
 80+  8543 20 42 4F 4E
 80+  8547 55 53 FF
 81+  854A              string_endlevel_bonus3:
 82+  854A 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 82+  854E 49 50 4C 45
 82+  8552 20 42 4F 4E
 82+  8556 55 53 FF
 83+  8559              string_endlevel_points1:
 84+  8559 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 84+  855D 30 30 20 50
 84+  8561 4F 49 4E 54
 84+  8565 53 FF
 85+  8567              string_endlevel_points2:
 86+  8567 09 0F 31 30      defb 9,15,'10000 POINTS',255
 86+  856B 30 30 30 20
 86+  856F 50 4F 49 4E
 86+  8573 54 53 FF
 87+  8576              string_endlevel_points3:
 88+  8576 09 0F 31 35      defb 9,15,'15000 POINTS',255
 88+  857A 30 30 30 20
 88+  857E 50 4F 49 4E
 88+  8582 54 53 FF
 89+  8585              string_endlevel_anothergo:
 90+  8585 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 90+  8589 56 45 20 41
 90+  858D 4E 4F 54 48
 90+  8591 45 52 20 47
 90+  8595 4F FF
 91+  8597
 92+  8597              string_zonk:
 93+  8597 00 00 5A 4F      defb 0,0,'ZONK!!',255
 93+  859B 4E 4B 21 21
 93+  859F FF
 94+  85A0
 95+  85A0
 96+  85A0              string_options_title:
 97+  85A0 0D 03 54 48      defb 13,3,'THE PIT',255
 97+  85A4 45 20 50 49
 97+  85A8 54 FF
 98+  85AA              string_options_1player:
 99+  85AA 0A 06 31 2E      defb 10,6,'1. ONE PLAYER',255
 99+  85AE 20 4F 4E 45
 99+  85B2 20 50 4C 41
 99+  85B6 59 45 52 FF
100+  85BA              string_options_2player:
101+  85BA 0A 07 32 2E      defb 10,7,'2. TWO PLAYER',255
101+  85BE 20 54 57 4F
101+  85C2 20 50 4C 41
101+  85C6 59 45 52 FF
102+  85CA              string_options_keyboard:
103+  85CA 0A 08 33 2E      defb 10,8,'3. KEYBOARD',255
103+  85CE 20 4B 45 59
103+  85D2 42 4F 41 52
103+  85D6 44 FF
104+  85D8              string_options_joystick:
105+  85D8 0A 09 34 2E      defb 10,9,'4. KEMPSTON',255
105+  85DC 20 4B 45 4D
105+  85E0 50 53 54 4F
105+  85E4 4E FF
106+  85E6              string_options_start:
107+  85E6 0A 0A 35 2E      defb 10,10,'5. START',255
107+  85EA 20 53 54 41
107+  85EE 52 54 FF
108+  85F1              string_options_vanity:
109+  85F1 08 16 53 70      defb 8,22,'Spectrum Conversion',254
109+  85F5 65 63 74 72
109+  85F9 75 6D 20 43
109+  85FD 6F 6E 76 65
109+  8601 72 73 69 6F
109+  8605 6E FE
110+  8607 07 17 62 79      defb 7,23,'by Dave Tansley, 2020',255
110+  860B 20 44 61 76
110+  860F 65 20 54 61
110+  8613 6E 73 6C 65
110+  8617 79 2C 20 32
110+  861B 30 32 30 FF
111+  861F
112+  861F              ;
113+  861F              ; Prints specified string
114+  861F              ; Inputs:
115+  861F              ; de: pointer to string
116+  861F              ; bc: length of string
117+  861F              ;
118+  861F              ; Print String Data
119+  861F              ; First two bytes of string contain X and Y char position, then the string
120+  861F              ; Individual strings are terminated with 0xFE
121+  861F              ; End of data is terminated with 0xFF
122+  861F              ; HL: Address of string
123+  861F              ;
124+  861F 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
125+  8620 23                                   INC HL                          ; Increase HL to the next memory location
126+  8621 56                                   LD D,(HL)                       ; Fetch the Y coordinate
127+  8622 23                                   INC HL                          ; Increase HL to the next memory location
128+  8623 CD 36 86                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
129+  8626 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
130+  8627 23                                   INC HL                          ; Increase HL to the next character
131+  8628 FE FE                                CP 0xFE                         ; Compare with 0xFE
132+  862A 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
133+  862C D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
134+  862D E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
135+  862E CD 46 86                             CALL Print_Char                 ; Print the character
136+  8631 E1                                   POP HL                          ; Retrieve HL back off the stack
137+  8632 1C                                   INC E                           ; Go to the next screen address
138+  8633 18 F1                                JR string_print_0               ; Loop back to print next character
139+  8635 C9                                   RET
140+  8636
141+  8636              ; Get screen address
142+  8636              ; D = Y character position
143+  8636              ; E = X character position
144+  8636              ; Returns address in DE
145+  8636              ;
146+  8636 7A           string_getcharaddress:       LD A,D
147+  8637 E6 07                                AND %00000111
148+  8639 1F                                   RRA
149+  863A 1F                                   RRA
150+  863B 1F                                   RRA
151+  863C 1F                                   RRA
152+  863D B3                                   OR E
153+  863E 5F                                   LD E,A
154+  863F 7A                                   LD A,D
155+  8640 E6 18                                AND %00011000
156+  8642 F6 40                                OR %01000000
157+  8644 57                                   LD D,A
158+  8645 C9                                   RET                             ; Returns screen address in DE
159+  8646
160+  8646              ; Print a single character out
161+  8646              ; A:  Character to print
162+  8646              ; DE: Screen address to print character at
163+  8646              ;
164+  8646 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
165+  8649 06 00                                LD B,0                          ; Set BC to A
166+  864B 4F                                   LD C,A
167+  864C E6 FF                                AND 0xFF                        ; Clear the carry bit
168+  864E CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
169+  8650 CB 10                                RL B
170+  8652 CB 11                                RL C
171+  8654 CB 10                                RL B
172+  8656 CB 11                                RL C
173+  8658 CB 10                                RL B
174+  865A 09                                   ADD HL,BC                       ; Get the character address in HL
175+  865B 0E 08                                LD C,8                          ; Loop counter
176+  865D D5                                   PUSH DE
177+  865E 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
178+  865F 12                                   LD (DE),A                       ; Stick A onto the screen
179+  8660 14                                   INC D                           ; Goto next line on screen
180+  8661 2C                                   INC L                           ; Goto next byte of character
181+  8662 0D                                   DEC C                           ; Decrease the loop counter
182+  8663 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
183+  8665 D1                                   POP DE
184+  8666 C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
133   8667                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  8667              buffer_buffer:
  2+  8667 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A367
  4+  A367              buffer_attr_buffer:
  5+  A367 00 00 00...      defs 928                    ; attrs buffer area
  6+  A707
  7+  A707              buffer_tmp:
  8+  A707 00 00            defb 0,0                    ; temp area
  9+  A709
 10+  A709              ;
 11+  A709              ; This list stores lines to be updated by the buffer.
 12+  A709              ; This is done by half line. Lines are encded with.
 13+  A709              ; 00hlllll
 14+  A709              ; Where h is the half of the screen (0 or 1), lllll is the line number
 15+  A709              buffer_updatedlines:
 16+  A709 FF FF FF...      defs 21,255
 17+  A71E
 18+  A71E              buffer_updateall:
 19+  A71E 00               defb 0
 20+  A71F
 21+  A71F              ;
 22+  A71F              ; Stores a line number in the update list
 23+  A71F              ; Inputs:
 24+  A71F              ; a - row number
 25+  A71F              buffer_marklineforupdate:
 26+  A71F FE 15            cp 21
 27+  A721 D0               ret nc                          ; dont store lines that we shouldn't draw
 28+  A722 5F               ld e,a                          ; store in e
 29+  A723 ED 4B 1A AC      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 30+  A727 79               ld a,c                          ; get the horiz coord
 31+  A728 FE 0F            cp 15
 32+  A72A CA 41 A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 33+  A72D FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 34+  A72F CA 41 A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 35+  A732 DA 3D A7         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 36+  A735 78               ld a,b                          ; get the vertical
 37+  A736 3E 20            ld a,32                         ; set the 6th bit by adding 32
 38+  A738 83               add a,e
 39+  A739 5F               ld e,a                          ; store this value
 40+  A73A C3 48 A7         jp buffer_marklineforupdate2
 41+  A73D              buffer_marklineforupdate4:
 42+  A73D 78               ld a,b
 43+  A73E C3 48 A7         jp buffer_marklineforupdate2    ; just get the vertical
 44+  A741              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 45+  A741 CD 4C A7         call buffer_storelineforupdate  ; call store update for e
 46+  A744 3E 20            ld a,32
 47+  A746 83               add a,e
 48+  A747 5F               ld e,a
 49+  A748              buffer_marklineforupdate2:
 50+  A748 CD 4C A7         call buffer_storelineforupdate  ; call store update for e
 51+  A74B C9               ret
 52+  A74C
 53+  A74C
 54+  A74C              ;
 55+  A74C              ; Stores the calculated line and half if needed
 56+  A74C              ; Inputs:
 57+  A74C              ; e - half/row
 58+  A74C              ;
 59+  A74C              buffer_storelineforupdate:
 60+  A74C 06 15            ld b,21
 61+  A74E 21 09 A7         ld hl,buffer_updatedlines
 62+  A751              buffer_storelineforupdate0:
 63+  A751 7E               ld a,(hl)                       ; get the line stored in updated lines
 64+  A752 BB               cp e                            ; is this the same as the row number passed in?
 65+  A753 C8               ret z                           ; if so, don't need to do anything
 66+  A754 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 67+  A756 C2 5B A7         jp nz,buffer_storelineforupdate1 ; if not, move to next
 68+  A759 73               ld (hl),e
 69+  A75A C9               ret
 70+  A75B              buffer_storelineforupdate1:
 71+  A75B 23               inc hl
 72+  A75C 10 F3            djnz buffer_storelineforupdate0
 73+  A75E C9               ret
 74+  A75F
 75+  A75F              ;
 76+  A75F              ; Zeroes the updated lines list
 77+  A75F              ;
 78+  A75F              buffer_clearlist:
 79+  A75F 06 15            ld b,21
 80+  A761 21 09 A7         ld hl,buffer_updatedlines
 81+  A764              buffer_clearlist0:
 82+  A764 36 FF            ld (hl),255
 83+  A766 23               inc hl
 84+  A767 10 FB            djnz buffer_clearlist0
 85+  A769 C9               ret
 86+  A76A
 87+  A76A              ;
 88+  A76A              ; Which half are we displaying? 0 left 1 right
 89+  A76A              ;
 90+  A76A              buffer_bufferhalf:
 91+  A76A 00               defb 0
 92+  A76B
 93+  A76B              ;
 94+  A76B              ; Copies the buffer to the screen. Use stack.
 95+  A76B              ; Inputs:
 96+  A76B              ; hl - half/line number to display - 0 is first half, 0 is first line
 97+  A76B              ;
 98+  A76B              buffer_bufferlinetoscreen:
 99+  A76B 7C               ld a,h
100+  A76C 32 6A A7         ld (buffer_bufferhalf),a        ; store the half
101+  A76F 7D               ld a,l
102+  A770 4F               ld c,a                          ; store a
103+  A771 ED 5B D1 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
104+  A775 83               add a,e                       ; add the row number
105+  A776 11 00 01         ld de,256
106+  A779 CD F7 80         call utilities_multiply
107+  A77C 54 5D            ld de,hl
108+  A77E 21 67 86         ld hl,buffer_buffer
109+  A781 19               add hl,de                   ; add the offset
110+  A782 79               ld a,c                      ; get original row back
111+  A783 ED 73 F6 A7      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
112+  A787 D9               exx
113+  A788 0E 00            ld c,0                      ; zero horizontal
114+  A78A 47               ld b,a                      ; load the row number into vertical coord
115+  A78B 04               inc b
116+  A78C 04               inc b                       ; move forward 2 to allow for scores
117+  A78D CD C9 A9         call screen_getcelladdress  ; get the memory into de
118+  A790 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
119+  A793 19               add hl,de
120+  A794 3A 6A A7         ld a,(buffer_bufferhalf)    ; get the half
121+  A797 FE 01            cp 1
122+  A799 CA C6 A7         jp z,buffer_bufferlinetoscreen4
123+  A79C              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
124+  A79C D9               exx                         ; hl is now buffer
125+  A79D 23               inc hl
126+  A79E 23               inc hl                      ; move hl forward 2 to skip first two blocks
127+  A79F F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
128+  A7A0 F1               pop af
129+  A7A1 C1               pop bc
130+  A7A2 D1               pop de
131+  A7A3 DD E1            pop ix
132+  A7A5 D9               exx                         ; hl is now screen
133+  A7A6 08               ex af,af'
134+  A7A7 F1               pop af
135+  A7A8 C1               pop bc
136+  A7A9 D1               pop de
137+  A7AA F9               ld sp,hl                    ; sp pointing at screen
138+  A7AB D5               push de
139+  A7AC C5               push bc
140+  A7AD F5               push af
141+  A7AE 08               ex af,af'
142+  A7AF D9               exx                         ; hl is now buffer
143+  A7B0 DD E5            push ix
144+  A7B2 D5               push de
145+  A7B3 C5               push bc
146+  A7B4 F5               push af
147+  A7B5 11 1E 00         ld de,30                    ; add thirty to get to next line
148+  A7B8 19               add hl,de
149+  A7B9 F9               ld sp,hl                    ; sp pointing at buffer
150+  A7BA D9               exx                         ; hl is now screen
151+  A7BB 08               ex af,af'
152+  A7BC 24               inc h
153+  A7BD 7C               ld a,h
154+  A7BE E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
155+  A7C0 C2 9C A7         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
156+  A7C3              buffer_bufferlinetoscreen1:
157+  A7C3 C3 F5 A7         jp buffer_bufferlinetoscreen3
158+  A7C6              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
159+  A7C6 D9               exx                         ; hl is buffer
160+  A7C7 11 10 00         ld de,16
161+  A7CA 19               add hl,de                   ; move halfway across
162+  A7CB D9               exx                         ; hl is screen
163+  A7CC 11 0E 00         ld de,14
164+  A7CF 19               add hl,de
165+  A7D0              buffer_bufferlinetoscreen2:
166+  A7D0 D9               exx                         ; hl is now buffer
167+  A7D1 F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
168+  A7D2 F1               pop af
169+  A7D3 C1               pop bc
170+  A7D4 D1               pop de
171+  A7D5 DD E1            pop ix
172+  A7D7 D9               exx                         ; hl is now screen
173+  A7D8 08               ex af,af'
174+  A7D9 F1               pop af
175+  A7DA C1               pop bc
176+  A7DB D1               pop de
177+  A7DC F9               ld sp,hl                    ; sp pointing at screen
178+  A7DD D5               push de
179+  A7DE C5               push bc
180+  A7DF F5               push af
181+  A7E0 08               ex af,af'
182+  A7E1 D9               exx                         ; hl is now buffer
183+  A7E2 DD E5            push ix
184+  A7E4 D5               push de
185+  A7E5 C5               push bc
186+  A7E6 F5               push af
187+  A7E7 11 20 00         ld de,32                    ; add thirty two to get to next line
188+  A7EA 19               add hl,de
189+  A7EB F9               ld sp,hl                    ; sp pointing at buffer
190+  A7EC D9               exx                         ; hl is now screen
191+  A7ED 08               ex af,af'
192+  A7EE 24               inc h
193+  A7EF 7C               ld a,h
194+  A7F0 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
195+  A7F2 C2 D0 A7         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
196+  A7F5              buffer_bufferlinetoscreen3:
197+  A7F5 31 00 00         ld sp,0
198+  A7F8 D9               exx
199+  A7F9 C9               ret
200+  A7FA
201+  A7FA              ;
202+  A7FA              ; Copies the buffer to the screen for updated lines. Use stack.
203+  A7FA              ; Inputs: none
204+  A7FA              ;
205+  A7FA              buffer_buffertoscreen:
206+  A7FA 3A 1E A7         ld a,(buffer_updateall)      ; get the all update flag
207+  A7FD FE 00            cp 0
208+  A7FF CA 0B A8         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
209+  A802 CD 3B A8         call buffer_allbuffertoscreen ; otherwise, draw whole screen
210+  A805 21 1E A7         ld hl,buffer_updateall
211+  A808 36 00            ld (hl),0                    ; reset flag
212+  A80A C9               ret
213+  A80B              buffer_buffertoscreen2:
214+  A80B 06 15            ld b,21
215+  A80D FD 21 09 A7      ld iy,buffer_updatedlines    ; the location of the updated lines
216+  A811              buffer_buffertoscreen0:
217+  A811 FD 7E 00         ld a,(iy)
218+  A814 FE FF            cp 255
219+  A816 CA 3A A8         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
220+  A819 6F               ld l,a
221+  A81A 26 00            ld h,0
222+  A81C E6 20            and 32                      ; and with 32 to see if 6th bit is set
223+  A81E FE 20            cp 32                       ; if so, second half of screen
224+  A820 C2 2B A8         jp nz,buffer_buffertoscreen3
225+  A823 26 01            ld h,1                      ; store half in h
226+  A825 FD 7E 00         ld a,(iy)
227+  A828 D6 20            sub 32                      ; remove 32
228+  A82A 6F               ld l,a                      ; stor in line number
229+  A82B              buffer_buffertoscreen3:
230+  A82B C5               push bc
231+  A82C FD E5            push iy
232+  A82E F3               di
233+  A82F CD 6B A7         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
234+  A832 FB               ei
235+  A833 FD E1            pop iy
236+  A835 C1               pop bc
237+  A836 FD 23            inc iy
238+  A838 10 D7            djnz buffer_buffertoscreen0
239+  A83A              buffer_buffertoscreen1:
240+  A83A                  ;call buffer_buffertoattrsfast
241+  A83A C9               ret
242+  A83B
243+  A83B              ;
244+  A83B              ; Copies the buffer to the screen. Use stack.
245+  A83B              ; Inputs: none
246+  A83B              ;
247+  A83B              buffer_allbuffertoscreen:
248+  A83B 06 15            ld b,21
249+  A83D 3E 00            ld a,0
250+  A83F              buffer_allbuffertoscreen0:
251+  A83F C5               push bc
252+  A840 F5               push af
253+  A841 F3               di
254+  A842 26 00            ld h,0
255+  A844 6F               ld l,a
256+  A845 CD 6B A7         call buffer_bufferlinetoscreen
257+  A848 FB               ei
258+  A849 F1               pop af
259+  A84A F5               push af
260+  A84B F3               di
261+  A84C 26 01            ld h,1
262+  A84E 6F               ld l,a
263+  A84F CD 6B A7         call buffer_bufferlinetoscreen
264+  A852 FB               ei
265+  A853 F1               pop af
266+  A854 C1               pop bc
267+  A855 3C               inc a
268+  A856 10 E7            djnz buffer_allbuffertoscreen0
269+  A858 F3               di
270+  A859 CD 5E A8         call buffer_buffertoattrsfast
271+  A85C FB               ei
272+  A85D C9               ret
273+  A85E
274+  A85E              ;
275+  A85E              ; Copies the attrs buffer to screen with the stack
276+  A85E              ;
277+  A85E              buffer_buffertoattrsfast:
278+  A85E ED 73 CD A8      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
279+  A862 3A D1 A8         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
280+  A865 11 20 00         ld de,32
281+  A868 CD F7 80         call utilities_multiply
282+  A86B 54 5D            ld de,hl
283+  A86D 21 67 A3         ld hl,buffer_attr_buffer
284+  A870 19               add hl,de                       ; add the offset, start of attr buffer now in hl
285+  A871 D9               exx
286+  A872 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
287+  A875 FD 21 07 A7      ld iy,buffer_tmp
288+  A879 FD 36 00 15      ld (iy),21              ; number of times to loop
289+  A87D              buffer_buffertoattrsfast0:
290+  A87D D9               exx                         ; hl is now buffer
291+  A87E 23               inc hl
292+  A87F 23               inc hl                      ; move hl forward 2 to skip first two blocks
293+  A880 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
294+  A881 F1               pop af
295+  A882 C1               pop bc
296+  A883 D1               pop de
297+  A884 DD E1            pop ix
298+  A886 D9               exx                         ; hl is now screen
299+  A887 08               ex af,af'
300+  A888 F1               pop af
301+  A889 C1               pop bc
302+  A88A D1               pop de
303+  A88B F9               ld sp,hl                    ; sp pointing at screen
304+  A88C D5               push de
305+  A88D C5               push bc
306+  A88E F5               push af
307+  A88F 08               ex af,af'
308+  A890 D9               exx                         ; hl is now buffer
309+  A891 DD E5            push ix
310+  A893 D5               push de
311+  A894 C5               push bc
312+  A895 F5               push af
313+  A896 1E 0E            ld e,14                    ; do another fourteen for right hand side
314+  A898 16 00            ld d,0
315+  A89A 19               add hl,de
316+  A89B F9               ld sp,hl                    ; sp pointing at buffer
317+  A89C F1               pop af
318+  A89D C1               pop bc
319+  A89E D1               pop de
320+  A89F DD E1            pop ix
321+  A8A1 D9               exx                         ; hl is now screen
322+  A8A2 08               ex af,af'
323+  A8A3 1E 0E            ld e,14
324+  A8A5 16 00            ld d,0
325+  A8A7 19               add hl,de
326+  A8A8 F1               pop af
327+  A8A9 C1               pop bc
328+  A8AA D1               pop de
329+  A8AB F9               ld sp,hl                    ; sp pointing at screen
330+  A8AC D5               push de
331+  A8AD C5               push bc
332+  A8AE F5               push af
333+  A8AF 08               ex af,af'
334+  A8B0 D9               exx                         ; hl is now buffer
335+  A8B1 DD E5            push ix
336+  A8B3 D5               push de
337+  A8B4 C5               push bc
338+  A8B5 F5               push af
339+  A8B6 1E 10            ld e,16
340+  A8B8 16 00            ld d,0
341+  A8BA 19               add hl,de
342+  A8BB D9               exx                         ; hl is now screen
343+  A8BC 11 12 00         ld de,18
344+  A8BF 19               add hl,de
345+  A8C0 FD 7E 00         ld a,(iy)
346+  A8C3 3D               dec a
347+  A8C4 FE 00            cp 0
348+  A8C6 FD 77 00         ld (iy),a
349+  A8C9 C2 7D A8         jp nz,buffer_buffertoattrsfast0 ; do another row
350+  A8CC              buffer_buffertoattrsfast1:
351+  A8CC 31 00 00         ld sp,0
352+  A8CF D9               exx
353+  A8D0 C9               ret
# file closed: screen/buffer.asm
134   A8D1                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A8D1              screen_offset:
  2+  A8D1 00               defb 0                      ; offset from top of screen in lines
  3+  A8D2
  4+  A8D2              screen_tmp:
  5+  A8D2 00 00            defb 0,0                      ; temporary memory
  6+  A8D4
  7+  A8D4              screen_setscorecolours:
  8+  A8D4 21 48 B6         ld hl,score_colours
  9+  A8D7 11 00 58         ld de,22528                     ; attrs here
 10+  A8DA 01 40 00         ld bc,64
 11+  A8DD ED B0            ldir
 12+  A8DF C9               ret
 13+  A8E0
 14+  A8E0              screen_sethighscorecolours:
 15+  A8E0 21 88 B6         ld hl,high_score_colours
 16+  A8E3 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A8E6 01 20 00         ld bc,32
 18+  A8E9 ED B0            ldir
 19+  A8EB C9               ret
 20+  A8EC
 21+  A8EC              ; Draw the screen
 22+  A8EC              ; Inputs:
 23+  A8EC              ; none
 24+  A8EC              ; Notes:
 25+  A8EC              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A8EC              screen_draw:
 27+  A8EC                  ;call clear_screen
 28+  A8EC 0E 00            ld c,0                      ; horiz
 29+  A8EE 06 00            ld b,0                      ; vert, 0 at top
 30+  A8F0 DD 21 0A B1      ld ix,level01               ; point ix at level data
 31+  A8F4 FD 21 67 A3      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A8F8              screen_draw0:
 33+  A8F8 DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A8FB C5               push bc                     ; store bc, contains loop count
 35+  A8FC CD B7 AA         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A8FF 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A900 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A903 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A906 CD 7E AA         call screen_getblock        ; get the block data into hl
 40+  A909 CD 5B AA         call screen_showchar        ; show this character here
 41+  A90C C1               pop bc                      ; get the loop counter back
 42+  A90D DD 23            inc ix                      ; increment level location
 43+  A90F FD 23            inc iy                      ; increment attr location
 44+  A911 0C               inc c                       ; increment horiz
 45+  A912 79               ld a,c
 46+  A913 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A915 C2 F8 A8         jp nz,screen_draw0          ; if not, loop
 48+  A918 0E 00            ld c,0                      ; if so, reset horiz
 49+  A91A 04               inc b                       ; increment vertical
 50+  A91B 78               ld a,b
 51+  A91C FE 1D            cp 29                       ; check if at bottom
 52+  A91E C2 F8 A8         jp nz,screen_draw0          ; if not, loop
 53+  A921 21 D2 A8         ld hl, screen_tmp
 54+  A924 36 09            ld (hl),9                   ; load the block number into memory
 55+  A926 DD 21 AA B4      ld ix,level01rocks          ; rock memory
 56+  A92A CD 99 A9         call screen_initobjects     ; draw rocks
 57+  A92D 21 D2 A8         ld hl, screen_tmp
 58+  A930 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A932 DD 21 AA B5      ld ix,level01missiles       ; missile memory
 60+  A936 CD 99 A9         call screen_initobjects     ; draw missiles
 61+  A939 21 D2 A8         ld hl, screen_tmp
 62+  A93C 36 08            ld (hl),08                  ; load the block number into memory
 63+  A93E DD 21 23 B6      ld ix,level01diamonds       ; diamond memory
 64+  A942 CD 99 A9         call screen_initobjects     ; draw diamonds
 65+  A945 21 D2 A8         ld hl, screen_tmp
 66+  A948 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A94A DD 21 33 B6      ld ix,level01gems           ; gems memory
 68+  A94E CD 99 A9         call screen_initobjects     ; draw gems
 69+  A951 CD 58 A9         call screen_setuptext       ; draws text on the screen
 70+  A954 CD F7 C5         call scores_printscores     ; print the current scores
 71+  A957 C9               ret
 72+  A958
 73+  A958              ;
 74+  A958              ; Sets up text on the screen
 75+  A958              ;
 76+  A958              screen_setuptext:
 77+  A958 CD 53 C6         call scores_showtable
 78+  A95B CD E0 A8         call screen_sethighscorecolours
 79+  A95E 21 C3 81         ld hl, string_score1
 80+  A961 CD 1F 86         call string_print
 81+  A964 21 CC 81         ld hl, string_scorenumbers1
 82+  A967 CD 1F 86         call string_print
 83+  A96A 21 D5 81         ld hl, string_company
 84+  A96D CD 1F 86         call string_print
 85+  A970 21 F5 81         ld hl, string_score2
 86+  A973 CD 1F 86         call string_print
 87+  A976 21 FE 81         ld hl, string_scorenumbers2
 88+  A979 CD 1F 86         call string_print
 89+  A97C 3A 51 BE         ld a,(game_currentplayer)
 90+  A97F FE 01            cp 1
 91+  A981 C2 8A A9         jp nz,screen_setuptext0
 92+  A984 21 DF 81         ld hl, string_player1
 93+  A987 C3 8D A9         jp screen_setuptext1
 94+  A98A              screen_setuptext0:
 95+  A98A 21 EA 81         ld hl, string_player2
 96+  A98D              screen_setuptext1:
 97+  A98D CD 1F 86         call string_print
 98+  A990 CD D4 A8         call screen_setscorecolours
 99+  A993 C9               ret
100+  A994
101+  A994              ;
102+  A994              ; Sets a line of colours
103+  A994              ; Inputs:
104+  A994              ; a - colour to set
105+  A994              ; b - number to set
106+  A994              ; de - start memory location
107+  A994              ;
108+  A994              screen_setcolours:
109+  A994 12               ld (de),a
110+  A995 13               inc de
111+  A996 10 FC            djnz screen_setcolours
112+  A998 C9               ret
113+  A999
114+  A999              ;
115+  A999              ; Draw initial object positions
116+  A999              ; Inputs:
117+  A999              ; ix - memory location of objects
118+  A999              ; a - graphic
119+  A999              screen_initobjects:
120+  A999 DD 4E 00         ld c,(ix)                   ; get the horiz coord
121+  A99C 79               ld a,c
122+  A99D FE FF            cp 255
123+  A99F CA C8 A9         jp z,screen_initobjects2
124+  A9A2 DD 23            inc ix                      ; move to next
125+  A9A4 DD 46 00         ld b,(ix)                   ; get the vert coord
126+  A9A7 DD 23            inc ix
127+  A9A9 CD DA A9         call screen_getcellattradress ; get the memory address of b,c attr into de
128+  A9AC D5               push de
129+  A9AD 3A D2 A8         ld a,(screen_tmp)                  ; get the block number back
130+  A9B0 CD B7 AA         call screen_getattr         ; get the memory location for this cell's attr into hl
131+  A9B3 D1               pop de
132+  A9B4 7E               ld a,(hl)                   ; get the attr value at the address
133+  A9B5 12               ld (de),a                   ; load the attr into memory
134+  A9B6 3A D2 A8         ld a,(screen_tmp)                  ; get the block number back
135+  A9B9 CD 7E AA         call screen_getblock        ; get the block data into hl
136+  A9BC CD 5B AA         call screen_showchar        ; show this character here
137+  A9BF
138+  A9BF              screen_initobjects1:
139+  A9BF DD 23            inc ix                      ; move past state
140+  A9C1 DD 23            inc ix
141+  A9C3 DD 23            inc ix                      ; move past mem
142+  A9C5 C3 99 A9         jp screen_initobjects
143+  A9C8              screen_initobjects2:
144+  A9C8 C9               ret
145+  A9C9
146+  A9C9
147+  A9C9              ;
148+  A9C9              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
149+  A9C9              ; Inputs:
150+  A9C9              ; bc: coords
151+  A9C9              ; Outputs:
152+  A9C9              ; de: memory location
153+  A9C9              ;
154+  A9C9              screen_getcelladdress:
155+  A9C9 78               ld a,b      ; vertical position.
156+  A9CA E6 18            and 24      ; which segment, 0, 1 or 2?
157+  A9CC C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
158+  A9CE 57               ld d,a      ; this is our high byte.
159+  A9CF 78               ld a,b      ; what was that vertical position again?
160+  A9D0 E6 07            and 7       ; which row within segment?
161+  A9D2 0F               rrca        ; multiply row by 32.
162+  A9D3 0F               rrca
163+  A9D4 0F               rrca
164+  A9D5 5F               ld e,a      ; low byte.
165+  A9D6 79               ld a,c      ; add on y coordinate.
166+  A9D7 83               add a,e     ; mix with low byte.
167+  A9D8 5F               ld e,a      ; address of screen position in de.
168+  A9D9 C9               ret
169+  A9DA
170+  A9DA              ;
171+  A9DA              ; Calculate buffer address of attribute for character at (b, c).
172+  A9DA              ; Inputs:
173+  A9DA              ; bc: coords
174+  A9DA              ; Outputs:
175+  A9DA              ; de: memory location
176+  A9DA              ;
177+  A9DA              screen_getcellattradress:
178+  A9DA 11 67 A3         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
179+  A9DD 69               ld l,c      ; x position.
180+  A9DE 26 00            ld h,0      ; 0 h
181+  A9E0 19               add hl,de
182+  A9E1 54 5D            ld de,hl    ; horiz done
183+  A9E3 78               ld a,b      ; do vert
184+  A9E4 D5               push de
185+  A9E5 C5               push bc
186+  A9E6 11 20 00         ld de,32
187+  A9E9 CD F7 80         call utilities_multiply
188+  A9EC C1               pop bc
189+  A9ED D1               pop de
190+  A9EE 19               add hl,de
191+  A9EF 54 5D            ld de,hl    ; vert done
192+  A9F1 C9               ret
193+  A9F2
194+  A9F2              ;
195+  A9F2              ; Calculate buffer address offset of attribute for character at (b, c).
196+  A9F2              ; Inputs:
197+  A9F2              ; bc: coords
198+  A9F2              ; Outputs:
199+  A9F2              ; de: memory location
200+  A9F2              ;
201+  A9F2              screen_getcellattroffset:
202+  A9F2 69               ld l,c      ; x position.
203+  A9F3 26 00            ld h,0      ; 0 h
204+  A9F5 54 5D            ld de,hl    ; horiz done
205+  A9F7 78               ld a,b      ; do vert
206+  A9F8 D5               push de
207+  A9F9 C5               push bc
208+  A9FA 11 20 00         ld de,32
209+  A9FD CD F7 80         call utilities_multiply
210+  AA00 C1               pop bc
211+  AA01 D1               pop de
212+  AA02 19               add hl,de
213+  AA03 54 5D            ld de,hl    ; vert done
214+  AA05 C9               ret
215+  AA06
216+  AA06              ;
217+  AA06              ; Calculate buffer address of attribute for character at (b, c).
218+  AA06              ; Inputs:
219+  AA06              ; bc: coords
220+  AA06              ; Outputs:
221+  AA06              ; de: memory location
222+  AA06              ;
223+  AA06              screen_getscreenattradress:
224+  AA06 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
225+  AA09 69               ld l,c      ; x position.
226+  AA0A 26 00            ld h,0      ; 0 h
227+  AA0C 19               add hl,de
228+  AA0D 54 5D            ld de,hl    ; horiz done
229+  AA0F 78               ld a,b      ; do vert
230+  AA10 D5               push de
231+  AA11 C5               push bc
232+  AA12 11 20 00         ld de,32
233+  AA15 CD F7 80         call utilities_multiply
234+  AA18 C1               pop bc
235+  AA19 D1               pop de
236+  AA1A 19               add hl,de
237+  AA1B 54 5D            ld de,hl    ; vert done
238+  AA1D C9               ret
239+  AA1E
240+  AA1E              ;
241+  AA1E              ; Gets the attr memory location for a screen coord
242+  AA1E              ; Will overwrite bc
243+  AA1E              ; Inputs:
244+  AA1E              ; bc - screen coords
245+  AA1E              ; Outputs:
246+  AA1E              ; de - memory location
247+  AA1E              ; bc - character coords
248+  AA1E              ;
249+  AA1E              screen_getattraddressfromscreencoords:
250+  AA1E 78               ld a,b                          ; get the player block coords of current block
251+  AA1F E6 F8            and 248                         ; find closest multiple of eight
252+  AA21 0F               rrca
253+  AA22 0F               rrca
254+  AA23 0F               rrca                ; divide by 8
255+  AA24 47               ld b,a
256+  AA25 79               ld a,c
257+  AA26 48               ld c,b                         ; swap b and c
258+  AA27 E6 F8            and 248
259+  AA29 0F               rrca
260+  AA2A 0F               rrca
261+  AA2B 0F               rrca                ; divide by 8
262+  AA2C 47               ld b,a
263+  AA2D CD DA A9         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
264+  AA30 C9               ret
265+  AA31
266+  AA31
267+  AA31              ; Gets the nearest cell coords for a screen coord
268+  AA31              ; Will overwrite bc
269+  AA31              ; Inputs:
270+  AA31              ; bc - screen coords
271+  AA31              ; Outputs:
272+  AA31              ; bc - character coords
273+  AA31              ;
274+  AA31              screen_getcharcoordsfromscreencoords:
275+  AA31 78               ld a,b                          ; get the player block coords of current block
276+  AA32 E6 F8            and 248                         ; find closest multiple of eight
277+  AA34 0F               rrca
278+  AA35 0F               rrca
279+  AA36 0F               rrca                ; divide by 8
280+  AA37 47               ld b,a
281+  AA38 79               ld a,c
282+  AA39 48               ld c,b                         ; swap b and c
283+  AA3A E6 F8            and 248
284+  AA3C 0F               rrca
285+  AA3D 0F               rrca
286+  AA3E 0F               rrca                ; divide by 8
287+  AA3F 47               ld b,a
288+  AA40 C9               ret
289+  AA41
290+  AA41              ; Gets the screen coords for a cell coord
291+  AA41              ; Will overwrite bc
292+  AA41              ; Inputs:
293+  AA41              ; bc - char coords
294+  AA41              ; Outputs:
295+  AA41              ; bc - screen coords
296+  AA41              ;
297+  AA41              screen_getscreencoordsfromcharcoords:
298+  AA41 78               ld a,b                          ; get the player block coords of current block
299+  AA42 07               rlca
300+  AA43 07               rlca
301+  AA44 07               rlca                ; multiply by 8
302+  AA45 47               ld b,a
303+  AA46 79               ld a,c
304+  AA47 48               ld c,b                         ; swap b and c
305+  AA48 07               rlca
306+  AA49 07               rlca
307+  AA4A 07               rlca                ; divide by 8
308+  AA4B 47               ld b,a
309+  AA4C C9               ret
310+  AA4D
311+  AA4D              ;
312+  AA4D              ; Get buffer address for a character at b,c - b vert
313+  AA4D              ; Buffer memory is stored as sequential block
314+  AA4D              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
315+  AA4D              ; Inputs:
316+  AA4D              ; bc - coords
317+  AA4D              ; Outputs:
318+  AA4D              ; de - memory location of first byte
319+  AA4D              screen_getbufferaddress:
320+  AA4D 21 67 86         ld hl, buffer_buffer    ; first get screen buffer start
321+  AA50 50               ld d,b                  ; then work out vertical offset
322+  AA51 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
323+  AA53 19               add hl,de               ; add to base
324+  AA54 59               ld e,c                  ; then add horizontal offset (c)
325+  AA55 16 00            ld d,0
326+  AA57 19               add hl,de               ; add to base
327+  AA58 54 5D            ld de,hl
328+  AA5A C9               ret
329+  AA5B
330+  AA5B              ;
331+  AA5B              ; Display character hl at (b, c) to buffer.
332+  AA5B              ; Stored sequentially
333+  AA5B              ; Inputs:
334+  AA5B              ; hl: block address
335+  AA5B              ; bc: coords
336+  AA5B              ;
337+  AA5B              screen_showchar:
338+  AA5B ED 43 1A AC      ld (origcoords),bc   ; store char coords
339+  AA5F 3E 00            ld a,0
340+  AA61 E5               push hl
341+  AA62 CD 4D AA         call screen_getbufferaddress ; get the current screen buffer pointer
342+  AA65 E1               pop hl
343+  AA66 06 08            ld b,8              ; number of pixels high.
344+  AA68              screen_showchar0:
345+  AA68 7E               ld a,(hl)           ; source graphic.
346+  AA69 12               ld (de),a           ; transfer to screen.
347+  AA6A 23               inc hl              ; next piece of data.
348+  AA6B E5               push hl             ; store hl
349+  AA6C 62 6B            ld hl,de            ; put de in hl
350+  AA6E 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
351+  AA70 16 00            ld d,0
352+  AA72 19               add hl,de              ; add de to hl
353+  AA73 54 5D            ld de,hl            ; load back to de
354+  AA75 E1               pop hl              ; restore hl
355+  AA76
356+  AA76 10 F0            djnz screen_showchar0 ; repeat
357+  AA78 2E 01            ld l,1
358+  AA7A CD CB AB         call sprites_marklinesforupdatechar
359+  AA7D
360+  AA7D C9               ret
361+  AA7E
362+  AA7E
363+  AA7E              ;
364+  AA7E              ; Get cell graphic.
365+  AA7E              ; Inputs:
366+  AA7E              ; a: block
367+  AA7E              ; Outputs:
368+  AA7E              ; hl: memory
369+  AA7E              ;
370+  AA7E              screen_getblock:
371+  AA7E 07               rlca                        ; multiply block number by eight.
372+  AA7F 07               rlca
373+  AA80 07               rlca
374+  AA81 5F               ld e,a                      ; displacement to graphic address.
375+  AA82 16 00            ld d,0                      ; no high byte.
376+  AA84 21 A8 B6         ld hl,sprites               ; address of character blocks.
377+  AA87 19               add hl,de                   ; point to block.
378+  AA88 C9               ret
379+  AA89
380+  AA89              ;
381+  AA89              ; Set a the attr of a coord
382+  AA89              ; Inputs:
383+  AA89              ; bc - char coords
384+  AA89              ; a - attr
385+  AA89              ;
386+  AA89              screen_setattr:
387+  AA89 DD E5            push ix
388+  AA8B C5               push bc
389+  AA8C 08               ex af, af'
390+  AA8D CD F2 A9         call screen_getcellattroffset   ; get offset into de
391+  AA90 21 67 A3         ld hl,buffer_attr_buffer
392+  AA93 19               add hl,de                       ; get the memory location
393+  AA94 08               ex af, af'                      ; get attr back
394+  AA95 77               ld (hl),a                         ; set the attr
395+  AA96 08               ex af, af'                      ; get attr back
396+  AA97 ED 5B D1 A8      ld de,(screen_offset)           ; get the offset
397+  AA9B 78               ld a,b                          ; get the vertical
398+  AA9C 93               sub e                           ; subtract the offset
399+  AA9D DA B3 AA         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
400+  AAA0 FE 15            cp 21
401+  AAA2 D2 B3 AA         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
402+  AAA5 47               ld b,a                          ; put the coord back in b
403+  AAA6 CD 06 AA         call screen_getscreenattradress ; screen attr address in de
404+  AAA9 21 40 00         ld hl,64                        ; attr memory + two rows for scores
405+  AAAC 19               add hl,de
406+  AAAD 08               ex af, af'                      ; get attr back
407+  AAAE 77               ld (hl),a
408+  AAAF C1               pop bc
409+  AAB0 DD E1            pop ix
410+  AAB2 C9               ret
411+  AAB3              screen_setattr0:
412+  AAB3 C1               pop bc
413+  AAB4 DD E1            pop ix
414+  AAB6 C9               ret
415+  AAB7
416+  AAB7              ;
417+  AAB7              ; Get cell attribute.
418+  AAB7              ; Inputs:
419+  AAB7              ; a: block
420+  AAB7              ; Outputs:
421+  AAB7              ; hl: memory
422+  AAB7              ;
423+  AAB7              screen_getattr:
424+  AAB7 5F               ld e,a                      ; displacement to attribute address.
425+  AAB8 16 00            ld d,0                      ; no high byte.
426+  AABA 21 88 B7         ld hl,sprite_attrs          ; address of block attributes.
427+  AABD 19               add hl,de                   ; point to attribute.
428+  AABE C9               ret
429+  AABF
430+  AABF              ;
431+  AABF              ; Checks whether a character block has anything in it
432+  AABF              ; Inputs:
433+  AABF              ; bc - char coords
434+  AABF              ; Outputs:
435+  AABF              ; a - 1, empty
436+  AABF              screen_ischarempty:
437+  AABF CD 4D AA         call screen_getbufferaddress ; get the current screen buffer pointer
438+  AAC2 06 08            ld b,8                      ; check 8 rows
439+  AAC4              screen_ischarempty2:
440+  AAC4 1A               ld a,(de)                   ; check line
441+  AAC5 FE 00            cp 0
442+  AAC7 C2 D5 AA         jp nz,screen_ischarempty1   ; if not zero, jump out with false
443+  AACA 21 20 00         ld hl,32
444+  AACD 19               add hl,de
445+  AACE 54 5D            ld de,hl                    ; move to next row
446+  AAD0 10 F2            djnz screen_ischarempty2
447+  AAD2              screen_ischarempty0:
448+  AAD2 3E 01            ld a,1
449+  AAD4 C9               ret
450+  AAD5              screen_ischarempty1:
451+  AAD5 3E 00            ld a,0
452+  AAD7 C9               ret
453+  AAD8
454+  AAD8              ;
455+  AAD8              ; Copies a block from one place to another directly underneath, leaves the original empty
456+  AAD8              ; Inputs:
457+  AAD8              ; bc - coords of block to copy from
458+  AAD8              screen_copyblockdown
459+  AAD8 CD 4D AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
460+  AADB 06 08            ld b,8                      ; copy 8 rows
461+  AADD              screen_copyblock0:
462+  AADD 1A               ld a,(de)                    ; get what we're copying
463+  AADE 08               ex af,af'
464+  AADF 3E 00            ld a,0
465+  AAE1 12               ld (de),a                    ; replace with empty
466+  AAE2 08               ex af,af'
467+  AAE3 14               inc d                        ; add 256 to get to the next row
468+  AAE4 12               ld (de),a                    ; copy to the next row
469+  AAE5 15               dec d
470+  AAE6 21 20 00         ld hl,32
471+  AAE9 19               add hl,de                       ; return back to source, next row down
472+  AAEA 54 5D            ld de,hl
473+  AAEC 10 EF            djnz screen_copyblock0
474+  AAEE C9               ret
475+  AAEF
476+  AAEF              ;
477+  AAEF              ; Returns the first byte of a character. Useful for figuring out what's there
478+  AAEF              ; Inputs:
479+  AAEF              ; bc - coords
480+  AAEF              ; Outputs:
481+  AAEF              ; a - first byte
482+  AAEF              ;
483+  AAEF              screen_getcharfirstbyte:
484+  AAEF CD 4D AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
485+  AAF2 1A               ld a,(de)
486+  AAF3 C9               ret
487+  AAF4
# file closed: screen/screen.asm
135   AAF4                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  AAF4              ;
  2+  AAF4              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  AAF4              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  AAF4              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  AAF4              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  AAF4              ; routine takes care of all the shifting itself. This means that sprite
  7+  AAF4              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  AAF4              ; space they would require in pre-shifted form.
  9+  AAF4              ; Inputs:
 10+  AAF4              ; hl - sprite data
 11+  AAF4              ; bc - screen coords
 12+  AAF4              ;
 13+  AAF4              sprites_drawsprite7:
 14+  AAF4 EE 07            xor 7               ; complement last 3 bits.
 15+  AAF6 3C               inc a               ; add one for luck!
 16+  AAF7              sprites_drawsprite3:
 17+  AAF7 CB 11            rl c                ; ...into middle byte...
 18+  AAF9 CB 12            rl d                ; ...and finally into left character cell.
 19+  AAFB 3D               dec a               ; count shifts we've done.
 20+  AAFC 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  AAFE                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  AAFE 79               ld a,c              ; left edge of image is currently in e.
 23+  AAFF 4A               ld c,d              ; put right edge there instead.
 24+  AB00 57               ld d,a              ; and the left edge back into c.
 25+  AB01 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  AB03              sprites_drawsprite:
 27+  AB03 ED 43 1A AC      ld (origcoords),bc  ; store coords
 28+  AB07 ED 43 1C AC      ld (dispx),bc       ; store coords in dispx for now.
 29+  AB0B E5               push hl
 30+  AB0C CD F8 AB         call sprites_scadd  ; calculate screen address.
 31+  AB0F E1               pop hl
 32+  AB10 3E 08            ld a,8              ; height of sprite in pixels.
 33+  AB12              sprites_drawsprite1:
 34+  AB12 08               ex af,af'           ; store loop counter.
 35+  AB13 D5               push de             ; store screen address.
 36+  AB14 4E               ld c,(hl)           ; first sprite graphic.
 37+  AB15 23               inc hl              ; increment poiinter to sprite data.
 38+  AB16 22 1E AC         ld (sprtmp),hl      ; store it for later.
 39+  AB19 16 00            ld d,0              ; blank right byte for now.
 40+  AB1B 78               ld a,b              ; b holds y position.
 41+  AB1C E6 07            and 7               ; how are we straddling character cells?
 42+  AB1E 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  AB20 FE 05            cp 5                ; 5 or more right shifts needed?
 44+  AB22 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  AB24 A7               and a               ; oops, carry flag is set so clear it.
 46+  AB25              sprites_drawsprite2:
 47+  AB25 CB 19            rr c                ; rotate left byte right...
 48+  AB27 CB 1A            rr d                ; ...into right byte.
 49+  AB29 3D               dec a               ; one less shift to do.
 50+  AB2A 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  AB2C              sprites_drawsprite0:
 52+  AB2C E1               pop hl              ; pop screen address from stack.
 53+  AB2D 7E               ld a,(hl)           ; what's there already.
 54+  AB2E A9               xor c               ; merge in image data.
 55+  AB2F 77               ld (hl),a           ; place onto screen.
 56+  AB30 23               inc hl
 57+  AB31 7E               ld a,(hl)           ; what's already there.
 58+  AB32 AA               xor d               ; right edge of sprite image data.
 59+  AB33 77               ld (hl),a           ; plonk it on screen.
 60+  AB34 3A 1C AC         ld a,(dispx)        ; vertical coordinate.
 61+  AB37 3C               inc a               ; next line down.
 62+  AB38 32 1C AC         ld (dispx),a        ; store new position.
 63+  AB3B 2B               dec hl
 64+  AB3C 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  AB3F 19               add hl,de           ; add 32
 66+  AB40              sprites_drawsprite6:
 67+  AB40 EB               ex de,hl            ; screen address in de.
 68+  AB41 2A 1E AC         ld hl,(sprtmp)      ; restore graphic address.
 69+  AB44 08               ex af,af'           ; restore loop counter.
 70+  AB45 3D               dec a               ; decrement it.
 71+  AB46 C2 12 AB         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  AB49 2E 02            ld l,2
 73+  AB4B CD BA AB         call sprites_marklinesforupdatescreen
 74+  AB4E C9               ret                 ; job done.
 75+  AB4F
 76+  AB4F              ; Inputs:
 77+  AB4F              ; hl - sprite data
 78+  AB4F              ; bc - screen coords
 79+  AB4F              ;
 80+  AB4F              sprites_draw2by2sprite7
 81+  AB4F EE 07            xor 7               ; complement last 3 bits.
 82+  AB51 3C               inc a               ; add one for luck!
 83+  AB52              sprites_draw2by2sprite3
 84+  AB52 CB 12            rl d                ; rotate left...
 85+  AB54 CB 11            rl c                ; ...into middle byte...
 86+  AB56 CB 13            rl e                ; ...and finally into left character cell.
 87+  AB58 3D               dec a               ; count shifts we've done.
 88+  AB59 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  AB5B                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  AB5B 7B               ld a,e              ; left edge of image is currently in e.
 91+  AB5C 5A               ld e,d              ; put right edge there instead.
 92+  AB5D 51               ld d,c              ; middle bit goes in d.
 93+  AB5E 4F               ld c,a              ; and the left edge back into c.
 94+  AB5F 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  AB61              sprites_draw2by2sprite
 96+  AB61 ED 43 1A AC      ld (origcoords),bc  ; store coords
 97+  AB65 ED 43 1C AC      ld (dispx),bc       ; store coords in dispx for now.
 98+  AB69 79               ld a,c
 99+  AB6A 32 20 AC         ld (sprtmp0),a         ; store vertical.
100+  AB6D E5               push hl
101+  AB6E CD F8 AB         call sprites_scadd          ; calculate screen address.
102+  AB71 E1               pop hl
103+  AB72 3E 10            ld a,16             ; height of sprite in pixels.
104+  AB74              sprites_draw2by2sprite1
105+  AB74 08               ex af,af'           ; store loop counter.
106+  AB75 D5               push de             ; store screen address.
107+  AB76 4E               ld c,(hl)           ; first sprite graphic.
108+  AB77 23               inc hl              ; increment poiinter to sprite data.
109+  AB78 56               ld d,(hl)           ; next bit of sprite image.
110+  AB79 23               inc hl              ; point to next row of sprite data.
111+  AB7A 22 1E AC         ld (sprtmp),hl        ; store in tmp0 for later.
112+  AB7D 1E 00            ld e,0              ; blank right byte for now.
113+  AB7F 78               ld a,b              ; b holds y position.
114+  AB80 E6 07            and 7               ; how are we straddling character cells?
115+  AB82 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  AB84 FE 05            cp 5                ; 5 or more right shifts needed?
117+  AB86 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  AB88 A7               and a               ; oops, carry flag is set so clear it.
119+  AB89              sprites_draw2by2sprite2
120+  AB89 CB 19            rr c                ; rotate left byte right...
121+  AB8B CB 1A            rr d                ; ...through middle byte...
122+  AB8D CB 1B            rr e                ; ...into right byte.
123+  AB8F 3D               dec a               ; one less shift to do.
124+  AB90 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  AB92              sprites_draw2by2sprite0
126+  AB92 E1               pop hl              ; pop screen address from stack.
127+  AB93 7E               ld a,(hl)           ; what's there already.
128+  AB94 A9               xor c               ; merge in image data.
129+  AB95 77               ld (hl),a           ; place onto screen.
130+  AB96 23               inc hl               ; next character cell to right please.
131+  AB97 7E               ld a,(hl)           ; what's there already.
132+  AB98 AA               xor d               ; merge with middle bit of image.
133+  AB99 77               ld (hl),a           ; put back onto screen.
134+  AB9A 23               inc hl              ; next bit of screen area.
135+  AB9B 7E               ld a,(hl)           ; what's already there.
136+  AB9C AB               xor e               ; right edge of sprite image data.
137+  AB9D 77               ld (hl),a           ; plonk it on screen.
138+  AB9E 3A 20 AC         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  ABA1 3C               inc a               ; next line down.
140+  ABA2 32 20 AC         ld (sprtmp0),a         ; store new position.
141+  ABA5 2B               dec hl
142+  ABA6 2B               dec hl
143+  ABA7 11 20 00         ld de,32            ; add 32 to get to the next row
144+  ABAA 19               add hl,de           ; add 32
145+  ABAB              sprites_draw2by2sprite6
146+  ABAB EB               ex de,hl            ; screen address in de.
147+  ABAC 2A 1E AC         ld hl,(sprtmp)        ; restore graphic address.
148+  ABAF 08               ex af,af'           ; restore loop counter.
149+  ABB0 3D               dec a               ; decrement it.
150+  ABB1 C2 74 AB         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  ABB4 2E 03            ld l,3
152+  ABB6 CD BA AB         call sprites_marklinesforupdatescreen
153+  ABB9 C9               ret                 ; job done.
154+  ABBA
155+  ABBA              ;
156+  ABBA              ; Marks lines for update with screen coords
157+  ABBA              ; Inputs:
158+  ABBA              ; l - number to update
159+  ABBA              ;
160+  ABBA              sprites_marklinesforupdatescreen:
161+  ABBA F5               push af
162+  ABBB ED 4B 1A AC      ld bc,(origcoords)
163+  ABBF CD 31 AA         call screen_getcharcoordsfromscreencoords
164+  ABC2 ED 43 1A AC      ld (origcoords),bc
165+  ABC6 CD D5 AB         call sprites_marklinesforupdate
166+  ABC9 F1               pop af
167+  ABCA C9               ret
168+  ABCB
169+  ABCB              ;
170+  ABCB              ; Marks lines for update with char coords
171+  ABCB              ; Inputs:
172+  ABCB              ; l - number to update
173+  ABCB              ;
174+  ABCB              sprites_marklinesforupdatechar:
175+  ABCB F5               push af
176+  ABCC ED 43 1A AC      ld (origcoords),bc
177+  ABD0 CD D5 AB         call sprites_marklinesforupdate
178+  ABD3 F1               pop af
179+  ABD4 C9               ret
180+  ABD5
181+  ABD5              ;
182+  ABD5              ; Marks lines for update
183+  ABD5              ; Inputs:
184+  ABD5              ; l - number to update
185+  ABD5              ;
186+  ABD5              sprites_marklinesforupdate:
187+  ABD5 ED 4B 1A AC      ld bc,(origcoords)
188+  ABD9 ED 5B D1 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
189+  ABDD 78               ld a,b
190+  ABDE 93               sub e
191+  ABDF 47               ld b,a
192+  ABE0 7D               ld a,l                          ; get loop counter
193+  ABE1              sprites_marklinesforupdate0:
194+  ABE1 C5               push bc
195+  ABE2 08               ex af,af'                     ; store loop counter
196+  ABE3 78               ld a,b
197+  ABE4 CD 1F A7         call buffer_marklineforupdate ; mark this line for update
198+  ABE7 ED 4B 1A AC      ld bc,(origcoords)            ; move the coords for the next line
199+  ABEB 04               inc b
200+  ABEC ED 43 1A AC      ld (origcoords),bc
201+  ABF0 C1               pop bc
202+  ABF1 04               inc b
203+  ABF2 08               ex af,af'                     ; restore loop counter
204+  ABF3 3D               dec a
205+  ABF4 C2 E1 AB         jp nz,sprites_marklinesforupdate0
206+  ABF7 C9               ret
207+  ABF8
208+  ABF8              ;
209+  ABF8              ; This routine returns a buffer address for (c, b) in de (c vert).
210+  ABF8              ; For example: 0,0 will be at memory offset 0
211+  ABF8              ; 1,0 (1 down) will be at memory offset 1
212+  ABF8              ; 0,7 will be at memory offset 0
213+  ABF8              ; 9,1 will be at memory offset 8+1
214+  ABF8              ; 8,0 will be at memory offset 256
215+  ABF8              ; 9,0 will be at memory offset 257
216+  ABF8              ; Outputs:
217+  ABF8              ; de - coords
218+  ABF8              ;
219+  ABF8              sprites_scadd:
220+  ABF8 79               ld a,c               ; calculate vertical offset
221+  ABF9 E6 F8            and 248             ;  to get nearest multiple of 8
222+  ABFB 0F               rrca
223+  ABFC 0F               rrca
224+  ABFD 0F               rrca                ; divide by 8
225+  ABFE 67               ld h,a
226+  ABFF 78               ld a,b               ; calculate horizontal offset
227+  AC00 E6 F8            and 248             ;  to get nearest multiple of 8
228+  AC02 0F               rrca
229+  AC03 0F               rrca
230+  AC04 0F               rrca                ; divide by 8
231+  AC05 6F               ld l,a
232+  AC06 C5               push bc             ; store the screen coords
233+  AC07 44 4D            ld bc,hl            ; load bc with the character coords
234+  AC09 CD 4D AA         call screen_getbufferaddress
235+  AC0C C1               pop bc              ; get back screen coords, de is now memory of character
236+  AC0D 79               ld a,c              ; now add the vertical within the cell
237+  AC0E E6 07            and 7
238+  AC10 0F               rrca                ; multiply by 32.
239+  AC11 0F               rrca
240+  AC12 0F               rrca
241+  AC13 6F               ld l,a
242+  AC14 26 00            ld h,0
243+  AC16 19               add hl,de
244+  AC17 54 5D            ld de,hl
245+  AC19 C9               ret
246+  AC1A
247+  AC1A 00 00        origcoords   defb 0,0           ; general-use coordinates.
248+  AC1C
249+  AC1C 00           dispx   defb 0           ; general-use coordinates.
250+  AC1D 00           dispy   defb 0
251+  AC1E 00 00        sprtmp  defb 0,0           ; sprite temporary address.
252+  AC20 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
253+  AC22
# file closed: screen/sprites.asm
136   AC22                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AC22              ;
  2+  AC22              ; Draws the title screen
  3+  AC22              ;
  4+  AC22              titlescreen_show:
  5+  AC22 CD B4 AC         call titlescreen_init
  6+  AC25 CD 5D AC         call titlescreen_drawtitle
  7+  AC28 3A 54 BE         ld a,(game_control)
  8+  AC2B FE 00            cp 0
  9+  AC2D CA 35 AC         jp z,titlescreen_show1
 10+  AC30 06 32            ld b,50
 11+  AC32 CD 58 81         call utilities_pauseforframes         ; pause for a second
 12+  AC35              titlescreen_show1:
 13+  AC35 3E FA            ld a,250                              ; wait for 200 frames
 14+  AC37 CD 19 81         call utilities_waitforkey_forframes   ; wait for keypress
 15+  AC3A 7B               ld a,e
 16+  AC3B FE 01            cp 1                                  ; was anything pressed?
 17+  AC3D C8               ret z                                 ; end titlescreen if so
 18+  AC3E
 19+  AC3E CD C7 AC         call titlescreen_alt_init             ; otherwise, draw alt screen
 20+  AC41 CD 79 AC         call titlescreen_alt_drawtitle
 21+  AC44 3A 54 BE         ld a,(game_control)
 22+  AC47 FE 00            cp 0
 23+  AC49 CA 51 AC         jp z,titlescreen_show0
 24+  AC4C 06 32            ld b,50
 25+  AC4E CD 58 81         call utilities_pauseforframes         ; pause for a second if joystick
 26+  AC51              titlescreen_show0:
 27+  AC51 3E FA            ld a,250                              ; wait for 200 frames
 28+  AC53 CD 19 81         call utilities_waitforkey_forframes   ; wait for keypress
 29+  AC56 7B               ld a,e
 30+  AC57 FE 01            cp 1                                  ; was anything pressed?
 31+  AC59 C2 22 AC         jp nz,titlescreen_show                ; start again if not
 32+  AC5C C9               ret
 33+  AC5D
 34+  AC5D              ;
 35+  AC5D              ; Draws the iconic logo
 36+  AC5D              ;
 37+  AC5D              titlescreen_drawtitle:
 38+  AC5D 06 67            ld b,103              ; number of points
 39+  AC5F DD 21 D4 AC      ld ix,titlescreen_logo_data
 40+  AC63              titlescreen_drawtitle0:
 41+  AC63 C5               push bc
 42+  AC64 DD 4E 00         ld c,(ix)                   ; got horiz
 43+  AC67 DD 23            inc ix
 44+  AC69 DD 46 00         ld b,(ix)                   ; got vert
 45+  AC6C DD 23            inc ix
 46+  AC6E CD 06 AA         call screen_getscreenattradress ; memory in de
 47+  AC71 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 48+  AC72 3E 13            ld a,19
 49+  AC74 12               ld (de),a
 50+  AC75 C1               pop bc
 51+  AC76 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 52+  AC78 C9               ret
 53+  AC79
 54+  AC79              ;
 55+  AC79              ; Draws the alternate title screen
 56+  AC79              ;
 57+  AC79              titlescreen_alt_drawtitle:
 58+  AC79 21 1C 82         ld hl,string_alttitlescreen_1
 59+  AC7C CD 1F 86         call string_print
 60+  AC7F 21 28 82         ld hl,string_alttitlescreen_2
 61+  AC82 CD 1F 86         call string_print
 62+  AC85 21 23 83         ld hl,string_alttitlescreen_3
 63+  AC88 CD 1F 86         call string_print
 64+  AC8B 06 20            ld b,32
 65+  AC8D 3E 43            ld a,67
 66+  AC8F 11 00 58         ld de,22528                         ; top row attrs here
 67+  AC92 CD 94 A9         call screen_setcolours
 68+  AC95 06 20            ld b,32
 69+  AC97 3E 46            ld a,70
 70+  AC99 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 71+  AC9C CD 94 A9         call screen_setcolours
 72+  AC9F 06 20            ld b,32
 73+  ACA1 3E 43            ld a,67
 74+  ACA3 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 75+  ACA6 CD 94 A9         call screen_setcolours
 76+  ACA9 06 20            ld b,32
 77+  ACAB 3E 42            ld a,66
 78+  ACAD 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 79+  ACB0 CD 94 A9         call screen_setcolours
 80+  ACB3 C9               ret
 81+  ACB4
 82+  ACB4              ;
 83+  ACB4              ; Initialises the screen
 84+  ACB4              ;
 85+  ACB4              titlescreen_init:
 86+  ACB4              ; We want a black screen.
 87+  ACB4 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 88+  ACB6                                      ; bright (64).
 89+  ACB6 CD 3D 81         call utilities_clearscreen
 90+  ACB9 32 8D 5C         ld (23693),a        ; set our screen colours.
 91+  ACBC 3E 01            ld a,1              ; 2 is the code for red.
 92+  ACBE D3 FE            out (254),a         ; write to port 254.
 93+  ACC0
 94+  ACC0 21 07 82         ld hl,string_titlescreen_copyright
 95+  ACC3 CD 1F 86         call string_print
 96+  ACC6
 97+  ACC6 C9               ret
 98+  ACC7
 99+  ACC7              ;
100+  ACC7              ; Initialises the screen
101+  ACC7              ;
102+  ACC7              titlescreen_alt_init:
103+  ACC7              ; We want a black screen.
104+  ACC7 3E 47            ld a,71             ; white ink (7) on black paper (0),
105+  ACC9                                      ; bright (64).
106+  ACC9 CD 3D 81         call utilities_clearscreen
107+  ACCC 32 8D 5C         ld (23693),a        ; set our screen colours.
108+  ACCF 3E 00            ld a,0              ; 2 is the code for red.
109+  ACD1 D3 FE            out (254),a         ; write to port 254.
110+  ACD3
111+  ACD3 C9               ret
112+  ACD4
113+  ACD4              ;
114+  ACD4              ; Horiz, vert
115+  ACD4              ;
116+  ACD4              titlescreen_logo_data:
117+  ACD4 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
117+  ACD8 0A 00 0C 00
117+  ACDC 0F 00 11 00
117+  ACE0 12 00 13 00
118+  ACE4 09 01 0C 01      defb 9,1,12,1,15,1,17,1
118+  ACE8 0F 01 11 01
119+  ACEC 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
119+  ACF0 0D 02 0E 02
119+  ACF4 0F 02 11 02
119+  ACF8 12 02 13 02
120+  ACFC 09 03 0C 03      defb 9,3,12,3,15,3,17,3
120+  AD00 0F 03 11 03
121+  AD04 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
121+  AD08 0F 04 11 04
121+  AD0C 12 04 13 04
122+  AD10 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
122+  AD14 02 06 03 06
122+  AD18 04 06 05 06
122+  AD1C 06 06 07 06
122+  AD20 08 06 09 06
122+  AD24 0A 06 0B 06
123+  AD28 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
123+  AD2C 12 06 13 06
123+  AD30 14 06 15 06
123+  AD34 16 06 17 06
123+  AD38 18 06 19 06
123+  AD3C 1A 06 1B 06
124+  AD40 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
124+  AD44 02 09 02 0A
124+  AD48 02 0B 02 0C
124+  AD4C 02 0D 02 0E
124+  AD50 02 0F 02 10
124+  AD54 02 11 02 12
124+  AD58 02 13 02 14
124+  AD5C 02 15
125+  AD5E 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
125+  AD62 19 09 19 0A
125+  AD66 19 0B 19 0C
125+  AD6A 19 0D 19 0E
125+  AD6E 19 0F 19 10
125+  AD72 19 11 19 12
125+  AD76 19 13 19 14
125+  AD7A 19 15
126+  AD7C 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
126+  AD80 05 0B 06 0B
126+  AD84 07 0B 08 0B
126+  AD88 09 0B 0A 0B
126+  AD8C 0B 0B
127+  AD8E 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
127+  AD92 0B 09 0B 0A
128+  AD96 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
128+  AD9A 10 10 10 11
128+  AD9E 10 12 10 13
129+  ADA2
# file closed: screen/titlescreen.asm
137   ADA2                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ADA2              ;
  2+  ADA2              ; Draws the life remaining screen
  3+  ADA2              ;
  4+  ADA2              lifescreen_draw:
  5+  ADA2 CD F5 AD         call lifescreen_init
  6+  ADA5
  7+  ADA5 3A 51 BE         ld a,(game_currentplayer)             ; get the current player
  8+  ADA8 C6 30            add 48                                ; add 48 to get char
  9+  ADAA 21 29 84         ld hl,string_lifescreen_player+10
 10+  ADAD 77               ld (hl),a                             ; load this to the string we're about to show
 11+  ADAE
 12+  ADAE 21 1F 84         ld hl,string_lifescreen_player
 13+  ADB1 CD 1F 86         call string_print
 14+  ADB4
 15+  ADB4 3A 9A BE         ld a,(player+9)                       ; get the current player lives
 16+  ADB7 C6 30            add 48                                ; add 48 to get the character
 17+  ADB9 FE 31            cp 49
 18+  ADBB C2 CE AD         jp nz,lifescreen_draw0
 19+  ADBE 21 39 84         ld hl,string_lifescreen_lastman
 20+  ADC1
 21+  ADC1 06 08            ld b,8
 22+  ADC3 3E 0A            ld a,10                                ; set red
 23+  ADC5 11 6C 58         ld de,22528+108                        ; attrs here
 24+  ADC8 CD 94 A9         call screen_setcolours
 25+  ADCB
 26+  ADCB C3 D5 AD         jp lifescreen_draw1
 27+  ADCE              lifescreen_draw0:
 28+  ADCE 21 2E 84         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  ADD1 77               ld (hl),a                             ; load this to the string we're about to show
 30+  ADD2 21 2C 84         ld hl,string_lifescreen_lives
 31+  ADD5              lifescreen_draw1:
 32+  ADD5 CD 1F 86         call string_print
 33+  ADD8
 34+  ADD8 3E 86            ld a,134
 35+  ADDA 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  ADDD 06 0A            ld b,10
 37+  ADDF CD 94 A9         call screen_setcolours
 38+  ADE2 3A 54 BE         ld a,(game_control)
 39+  ADE5 FE 00            cp 0
 40+  ADE7 CA EF AD         jp z,lifescreen_draw2
 41+  ADEA 06 32            ld b,50
 42+  ADEC CD 58 81         call utilities_pauseforframes         ; pause for a second if joystick
 43+  ADEF              lifescreen_draw2:
 44+  ADEF 3E 64            ld a,100                              ; wait for 200 frames
 45+  ADF1 CD 19 81         call utilities_waitforkey_forframes   ; wait for keypress
 46+  ADF4
 47+  ADF4 C9               ret
 48+  ADF5
 49+  ADF5              ;
 50+  ADF5              ; Initialises the screen
 51+  ADF5              ;
 52+  ADF5              lifescreen_init:
 53+  ADF5              ; We want a blue screen.
 54+  ADF5                  ;call $0D6B
 55+  ADF5 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 56+  ADF7                                      ; bright (64).
 57+  ADF7 CD 3D 81         call utilities_clearscreen
 58+  ADFA 32 8D 5C         ld (23693),a        ; set our screen colours.
 59+  ADFD 3E 01            ld a,1              ; 1 is the code for blue.
 60+  ADFF D3 FE            out (254),a         ; write to port 254.
 61+  AE01                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 62+  AE01
 63+  AE01 C9               ret
# file closed: screen/lifescreen.asm
138   AE02                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AE02              ;
  2+  AE02              ; Draws the game over screen
  3+  AE02              ;
  4+  AE02              gameover_draw:
  5+  AE02 3E 01            ld a,1
  6+  AE04 32 51 BE         ld (game_currentplayer),a               ; do the first player first
  7+  AE07 CD FD BE         call player_init_lifestart              ; get the player config
  8+  AE0A CD 5D AE         call gameover_enterhighscores
  9+  AE0D
 10+  AE0D 3A 50 BE         ld a,(game_numberplayers)               ; check if we need to do player 2
 11+  AE10 FE 02            cp 2
 12+  AE12 C2 20 AE         jp nz,gameover_draw0
 13+  AE15 3E 02            ld a,2
 14+  AE17 32 51 BE         ld (game_currentplayer),a               ; do the second player
 15+  AE1A CD FD BE         call player_init_lifestart              ; get the player config
 16+  AE1D CD 5D AE         call gameover_enterhighscores
 17+  AE20              gameover_draw0:
 18+  AE20 CD FE AE         call gameover_init
 19+  AE23
 20+  AE23 21 44 84         ld hl,string_gameoverscreen_gameover
 21+  AE26 CD 1F 86         call string_print
 22+  AE29
 23+  AE29 21 50 84         ld hl,string_gameoverscreen_copyright
 24+  AE2C CD 1F 86         call string_print
 25+  AE2F
 26+  AE2F CD 40 AE         call gameover_commontext
 27+  AE32
 28+  AE32 06 0B            ld b,11
 29+  AE34 3E 42            ld a,66
 30+  AE36 11 2B 58         ld de,22528+43                         ; attrs here
 31+  AE39 CD 94 A9         call screen_setcolours
 32+  AE3C CD 04 81         call utilities_waitforkey   ; wait for keypress
 33+  AE3F
 34+  AE3F C9               ret
 35+  AE40
 36+  AE40              ;
 37+  AE40              ; Draws text shared by the game over and high score screens
 38+  AE40              ;
 39+  AE40              gameover_commontext:
 40+  AE40 CD 58 A9         call screen_setuptext       ; show scores
 41+  AE43 CD F7 C5         call scores_printscores     ; print the current scores
 42+  AE46
 43+  AE46 21 78 84         ld hl,string_gameover_credits
 44+  AE49 CD 1F 86         call string_print
 45+  AE4C
 46+  AE4C 21 64 84         ld hl,string_gameoverscreen_bestscores
 47+  AE4F CD 1F 86         call string_print
 48+  AE52
 49+  AE52 06 20            ld b,32
 50+  AE54 3E 45            ld a,69
 51+  AE56 11 C0 5A         ld de,22528+704                         ; attrs here
 52+  AE59 CD 94 A9         call screen_setcolours
 53+  AE5C
 54+  AE5C C9               ret
 55+  AE5D
 56+  AE5D              ;
 57+  AE5D              ; If required, enter highscore
 58+  AE5D              ;
 59+  AE5D              gameover_enterhighscores:
 60+  AE5D                  ; check if we need to enter initial
 61+  AE5D CD 68 C6         call scores_processhighscores
 62+  AE60
 63+  AE60 3A 66 C6         ld a,(scores_highscoretmp)
 64+  AE63 FE 00            cp 0
 65+  AE65 C8               ret z
 66+  AE66 CD 94 AE         call gameover_enterhighscores_init
 67+  AE69 3A 66 C6         ld a,(scores_highscoretmp)
 68+  AE6C 3D               dec a
 69+  AE6D 3D               dec a
 70+  AE6E 3D               dec a                                   ; get high score location back to position of name
 71+  AE6F 16 00            ld d,0
 72+  AE71 5F               ld e,a
 73+  AE72 21 7C C5         ld hl,scores_table
 74+  AE75 19               add hl,de                               ; load memory into hl
 75+  AE76 08               ex af,af'
 76+  AE77 06 0F            ld b,15
 77+  AE79 CD 58 81         call utilities_pauseforframes           ; pause for a little bit
 78+  AE7C 06 03            ld b,3                                  ; collect three chars
 79+  AE7E              gameover_draw2:
 80+  AE7E C5               push bc
 81+  AE7F E5               push hl
 82+  AE80 CD 5C 81         call utilities_readkey               ; get key into a
 83+  AE83 E1               pop hl
 84+  AE84 77               ld (hl),a
 85+  AE85 23               inc hl
 86+  AE86 E5               push hl
 87+  AE87 CD 53 C6         call scores_showtable
 88+  AE8A E1               pop hl
 89+  AE8B 06 0F            ld b,15
 90+  AE8D CD 58 81         call utilities_pauseforframes
 91+  AE90 C1               pop bc
 92+  AE91 10 EB            djnz gameover_draw2
 93+  AE93 C9               ret
 94+  AE94
 95+  AE94              ;
 96+  AE94              ; Displays the screen text for high score entry
 97+  AE94              ;
 98+  AE94              gameover_enterhighscores_init:
 99+  AE94
100+  AE94 CD FE AE         call gameover_init
101+  AE97 CD 40 AE         call gameover_commontext
102+  AE9A
103+  AE9A 21 84 84         ld hl,string_highscore_congratulations
104+  AE9D CD 1F 86         call string_print
105+  AEA0
106+  AEA0 3A 51 BE         ld a,(game_currentplayer)
107+  AEA3 FE 01            cp 1
108+  AEA5 21 96 84         ld hl,string_highscore_player1
109+  AEA8 C3 AE AE         jp gameover_enterhighscores_init1
110+  AEAB              gameover_enterhighscores_init0:
111+  AEAB 21 A1 84         ld hl,string_highscore_player2
112+  AEAE              gameover_enterhighscores_init1:
113+  AEAE CD 1F 86         call string_print
114+  AEB1 06 60            ld b,96
115+  AEB3 3E 43            ld a,67
116+  AEB5 11 A0 58         ld de,22528+160                         ; attrs here
117+  AEB8 CD 94 A9         call screen_setcolours
118+  AEBB
119+  AEBB 21 AC 84         ld hl,string_highscore_youhaveearned
120+  AEBE CD 1F 86         call string_print
121+  AEC1
122+  AEC1 3A 66 C6         ld a,(scores_highscoretmp)
123+  AEC4 FE 05            cp 5
124+  AEC6 CA D4 AE         jp z, gameover_enterhighscores_init2    ; first place
125+  AEC9 FE 11            cp 17
126+  AECB CA DA AE         jp z, gameover_enterhighscores_init3    ; 2nd place
127+  AECE 21 E8 84         ld hl,string_highscore_place3           ; 3rd place
128+  AED1 C3 E0 AE         jp gameover_enterhighscores_init4
129+  AED4              gameover_enterhighscores_init2
130+  AED4 21 BE 84         ld hl,string_highscore_place1
131+  AED7 C3 E0 AE         jp gameover_enterhighscores_init4
132+  AEDA              gameover_enterhighscores_init3
133+  AEDA 21 D3 84         ld hl,string_highscore_place2
134+  AEDD C3 E0 AE         jp gameover_enterhighscores_init4
135+  AEE0              gameover_enterhighscores_init4
136+  AEE0 CD 1F 86         call string_print
137+  AEE3
138+  AEE3 06 60            ld b,96
139+  AEE5 3E 42            ld a,66
140+  AEE7 11 40 59         ld de,22528+320                         ; attrs here
141+  AEEA CD 94 A9         call screen_setcolours
142+  AEED
143+  AEED 21 FD 84         ld hl,string_highscore_pleaseenter
144+  AEF0 CD 1F 86         call string_print
145+  AEF3
146+  AEF3 06 60            ld b,96
147+  AEF5 3E 46            ld a,70
148+  AEF7 11 E0 59         ld de,22528+480                         ; attrs here
149+  AEFA CD 94 A9         call screen_setcolours
150+  AEFD C9               ret
151+  AEFE
152+  AEFE              ;
153+  AEFE              ; Initialises the screen
154+  AEFE              ;
155+  AEFE              gameover_init:
156+  AEFE              ; We want a black screen.
157+  AEFE 3E 47            ld a,71             ; white ink (7) on black paper (0),
158+  AF00                                      ; bright (64).
159+  AF00 CD 3D 81         call utilities_clearscreen
160+  AF03 32 8D 5C         ld (23693),a        ; set our screen colours.
161+  AF06 3E 00            ld a,0              ; 2 is the code for red.
162+  AF08 D3 FE            out (254),a         ; write to port 254.
163+  AF0A C9               ret
# file closed: screen/gameover.asm
139   AF0B                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AF0B              ;
  2+  AF0B              ; Draws the level transition screen
  3+  AF0B              ;
  4+  AF0B              endlevel_draw:
  5+  AF0B CD 06 B0         call endlevel_init
  6+  AF0E CD EF AF         call endlevel_commontext
  7+  AF11
  8+  AF11 21 84 84         ld hl,string_highscore_congratulations
  9+  AF14 CD 1F 86         call string_print
 10+  AF17
 11+  AF17 3A 51 BE         ld a,(game_currentplayer)
 12+  AF1A FE 01            cp 1
 13+  AF1C 21 96 84         ld hl,string_highscore_player1
 14+  AF1F C3 25 AF         jp endlevel_init1
 15+  AF22              endlevel_init0:
 16+  AF22 21 A1 84         ld hl,string_highscore_player2
 17+  AF25              endlevel_init1:
 18+  AF25 CD 1F 86         call string_print
 19+  AF28
 20+  AF28 21 1A 85         ld hl,string_endlevel_youhaveearned
 21+  AF2B CD 1F 86         call string_print
 22+  AF2E
 23+  AF2E CD 8E AF         call endlevel_workoutbonus
 24+  AF31 D5               push de
 25+  AF32 08               ex af,af'                               ; store the a value for later
 26+  AF33 CD 1F 86         call string_print
 27+  AF36 D1               pop de
 28+  AF37 62 6B            ld hl,de                                ; get the points text into de
 29+  AF39 CD 1F 86         call string_print
 30+  AF3C
 31+  AF3C 21 85 85         ld hl, string_endlevel_anothergo
 32+  AF3F CD 1F 86         call string_print
 33+  AF42
 34+  AF42 06 20            ld b,32
 35+  AF44 3E 23            ld a,35
 36+  AF46 11 60 59         ld de,22528+352                         ; attrs here
 37+  AF49 CD 94 A9         call screen_setcolours
 38+  AF4C
 39+  AF4C 06 20            ld b,32
 40+  AF4E 3E 25            ld a,37
 41+  AF50 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AF53 CD 94 A9         call screen_setcolours
 43+  AF56
 44+  AF56 06 20            ld b,32
 45+  AF58 3E 23            ld a,35
 46+  AF5A 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AF5D CD 94 A9         call screen_setcolours
 48+  AF60
 49+  AF60 06 20            ld b,32
 50+  AF62 3E 22            ld a,34
 51+  AF64 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AF67 CD 94 A9         call screen_setcolours
 53+  AF6A
 54+  AF6A 08               ex af,af'                               ; get back a value with bonus type
 55+  AF6B 06 14            ld b,20
 56+  AF6D CD 58 81         call utilities_pauseforframes
 57+  AF70
 58+  AF70 47               ld b,a                      ; put the bonus count in b
 59+  AF71              endlevel_init2:
 60+  AF71 C5               push bc
 61+  AF72 06 01            ld b,1
 62+  AF74 CD A0 C5         call scores_addthousands
 63+  AF77 CD 5C BF         call player_recordcurrentstate
 64+  AF7A CD B7 C5         call scores_printscore     ; print the current scores
 65+  AF7D 06 0A            ld b,10
 66+  AF7F CD 58 81         call utilities_pauseforframes
 67+  AF82 C1               pop bc
 68+  AF83 10 EC            djnz endlevel_init2
 69+  AF85
 70+  AF85 CD 8A BE         call game_increasedifficulty ; move the difficulty up a level
 71+  AF88
 72+  AF88 3E 64            ld a,100                              ; wait for 200 frames
 73+  AF8A CD 19 81         call utilities_waitforkey_forframes   ; wait for keypress
 74+  AF8D
 75+  AF8D C9               ret
 76+  AF8E
 77+  AF8E              ;
 78+  AF8E              ; Works out the bonus
 79+  AF8E              ; Outputs:
 80+  AF8E              ; a = 15 (all seven)
 81+  AF8E              ; a = 10 (3 large or 4 small)
 82+  AF8E              ; a = 5 (1 large diamond)
 83+  AF8E              ; hl - pointer to bonus text
 84+  AF8E              ; de - pointer to points text
 85+  AF8E              ;
 86+  AF8E              endlevel_workoutbonus:
 87+  AF8E 21 25 B6         ld hl,level01diamonds+2     ; location of state of first diamond
 88+  AF91 06 03            ld b,3                      ; number to check
 89+  AF93 16 00            ld d,0                      ; zero diamond count
 90+  AF95              endlevel_workoutbonus0:
 91+  AF95 7E               ld a,(hl)                   ; get state
 92+  AF96 FE 01            cp 1
 93+  AF98 C2 9C AF         jp nz,endlevel_workoutbonus1 ; if not, move on
 94+  AF9B 14               inc d                       ; increment diamond count
 95+  AF9C              endlevel_workoutbonus1:
 96+  AF9C 23               inc hl
 97+  AF9D 23               inc hl
 98+  AF9E 23               inc hl
 99+  AF9F 23               inc hl
100+  AFA0 23               inc hl                      ; get to next state
101+  AFA1 10 F2            djnz endlevel_workoutbonus0
102+  AFA3
103+  AFA3 21 35 B6         ld hl,level01gems+2     ; location of state of first gem
104+  AFA6 06 04            ld b,4                      ; number to check
105+  AFA8 1E 00            ld e,0                      ; zero gem count
106+  AFAA              endlevel_workoutbonus2:
107+  AFAA 7E               ld a,(hl)                   ; get state
108+  AFAB FE 01            cp 1
109+  AFAD C2 B1 AF         jp nz,endlevel_workoutbonus3 ; if not, move on
110+  AFB0 1C               inc e                       ; increment diamond count
111+  AFB1              endlevel_workoutbonus3:
112+  AFB1 23               inc hl
113+  AFB2 23               inc hl
114+  AFB3 23               inc hl
115+  AFB4 23               inc hl
116+  AFB5 23               inc hl                     ; get to next state
117+  AFB6 10 F2            djnz endlevel_workoutbonus2
118+  AFB8
119+  AFB8 7A               ld a,d
120+  AFB9 83               add e
121+  AFBA FE 07            cp 7                        ; check for max bonus
122+  AFBC C2 C8 AF         jp nz,endlevel_workoutbonus4 ;
123+  AFBF 3E 0F            ld a,15
124+  AFC1 21 4A 85         ld hl, string_endlevel_bonus3
125+  AFC4 11 76 85         ld de, string_endlevel_points3
126+  AFC7 C9               ret                         ; return with bonus of 15
127+  AFC8              endlevel_workoutbonus4:
128+  AFC8 7A               ld a,d                      ; check for for diamonds
129+  AFC9 FE 03            cp 3
130+  AFCB C2 D7 AF         jp nz,endlevel_workoutbonus5
131+  AFCE 3E 0A            ld a,10
132+  AFD0 21 3B 85         ld hl, string_endlevel_bonus2
133+  AFD3 11 67 85         ld de, string_endlevel_points2
134+  AFD6 C9               ret                         ; return with bonus of ten
135+  AFD7              endlevel_workoutbonus5:
136+  AFD7 7B               ld a,e                      ; check for four gems
137+  AFD8 FE 04            cp 4
138+  AFDA C2 E6 AF         jp nz,endlevel_workoutbonus6
139+  AFDD 3E 0A            ld a,10
140+  AFDF 21 3B 85         ld hl, string_endlevel_bonus2
141+  AFE2 11 67 85         ld de, string_endlevel_points2
142+  AFE5 C9               ret                         ; return with bonus of 10
143+  AFE6              endlevel_workoutbonus6:
144+  AFE6 3E 05            ld a,5                      ; otherwise, bonus is 5
145+  AFE8 21 2C 85         ld hl, string_endlevel_bonus1
146+  AFEB 11 59 85         ld de, string_endlevel_points1
147+  AFEE C9               ret
148+  AFEF
149+  AFEF              ;
150+  AFEF              ; Draws text shared by the game over and high score screens
151+  AFEF              ;
152+  AFEF              endlevel_commontext:
153+  AFEF CD 58 A9         call screen_setuptext       ; show scores
154+  AFF2 CD F7 C5         call scores_printscores     ; print the current scores
155+  AFF5
156+  AFF5 21 64 84         ld hl,string_gameoverscreen_bestscores
157+  AFF8 CD 1F 86         call string_print
158+  AFFB
159+  AFFB 06 20            ld b,32
160+  AFFD 3E 45            ld a,69
161+  AFFF 11 C0 5A         ld de,22528+704                         ; attrs here
162+  B002 CD 94 A9         call screen_setcolours
163+  B005
164+  B005 C9               ret
165+  B006
166+  B006              ;
167+  B006              ; Initialises the screen
168+  B006              ;
169+  B006              endlevel_init:
170+  B006              ; We want a green screen.
171+  B006 3E 21            ld a,33             ; white ink (7) on black paper (0),
172+  B008                                      ; bright (64).
173+  B008 CD 3D 81         call utilities_clearscreen
174+  B00B 32 8D 5C         ld (23693),a        ; set our screen colours.
175+  B00E 3E 00            ld a,0              ; 2 is the code for red.
176+  B010 D3 FE            out (254),a         ; write to port 254.
177+  B012 C9               ret
# file closed: screen/endlevel.asm
140   B013                  include "screen\options.asm"
# file opened: screen/options.asm
  1+  B013              ;
  2+  B013              ; Show the options screen
  3+  B013              ;
  4+  B013              options_show:
  5+  B013 CD AE B0         call options_init
  6+  B016
  7+  B016 21 A0 85         ld hl,string_options_title
  8+  B019 CD 1F 86         call string_print
  9+  B01C 21 AA 85         ld hl,string_options_1player
 10+  B01F CD 1F 86         call string_print
 11+  B022 21 BA 85         ld hl,string_options_2player
 12+  B025 CD 1F 86         call string_print
 13+  B028 21 CA 85         ld hl,string_options_keyboard
 14+  B02B CD 1F 86         call string_print
 15+  B02E 21 D8 85         ld hl,string_options_joystick
 16+  B031 CD 1F 86         call string_print
 17+  B034 21 E6 85         ld hl,string_options_start
 18+  B037 CD 1F 86         call string_print
 19+  B03A 21 F1 85         ld hl,string_options_vanity
 20+  B03D CD 1F 86         call string_print
 21+  B040
 22+  B040 3A 50 BE         ld a,(game_numberplayers)
 23+  B043 FE 01            cp 1
 24+  B045 C2 4E B0         jp nz,options_show0
 25+  B048 11 CA 58         ld de,22528+202                         ; top row attrs here
 26+  B04B C3 51 B0         jp options_show1
 27+  B04E              options_show0:
 28+  B04E 11 EA 58         ld de,22528+234                         ; top row attrs here
 29+  B051              options_show1:
 30+  B051 06 0D            ld b,13
 31+  B053 3E C7            ld a,199
 32+  B055 CD 94 A9         call screen_setcolours                  ; highlight current player
 33+  B058
 34+  B058 3A 54 BE         ld a,(game_control)
 35+  B05B FE 00            cp 0
 36+  B05D C2 66 B0         jp nz,options_show6
 37+  B060 11 0A 59         ld de,22528+266                         ; top row attrs here
 38+  B063 C3 69 B0         jp options_show7
 39+  B066              options_show6:
 40+  B066 11 2A 59         ld de,22528+298                         ; top row attrs here
 41+  B069              options_show7:
 42+  B069 06 0D            ld b,13
 43+  B06B 3E C7            ld a,199
 44+  B06D CD 94 A9         call screen_setcolours                  ; highlight current control
 45+  B070              options_show8:
 46+  B070 CD 5C 81         call utilities_readkey
 47+  B073 FE 31            cp 49                                   ; was 1 pressed
 48+  B075 C2 80 B0         jp nz,options_show2
 49+  B078 21 50 BE         ld hl,game_numberplayers
 50+  B07B 36 01            ld (hl),1
 51+  B07D C3 13 B0         jp options_show
 52+  B080              options_show2:
 53+  B080 FE 32            cp 50                                   ; was 2 pressed
 54+  B082 C2 8D B0         jp nz,options_show3
 55+  B085 21 50 BE         ld hl,game_numberplayers
 56+  B088 36 02            ld (hl),2
 57+  B08A C3 13 B0         jp options_show
 58+  B08D              options_show3:
 59+  B08D FE 33            cp 51                                   ; was 3 pressed
 60+  B08F C2 9A B0         jp nz,options_show4
 61+  B092 21 54 BE         ld hl,game_control
 62+  B095 36 00            ld (hl),0
 63+  B097 C3 13 B0         jp options_show
 64+  B09A              options_show4:
 65+  B09A FE 34            cp 52                                   ; was 4 pressed
 66+  B09C C2 A7 B0         jp nz,options_show5
 67+  B09F 21 54 BE         ld hl,game_control
 68+  B0A2 36 01            ld (hl),1
 69+  B0A4 C3 13 B0         jp options_show
 70+  B0A7              options_show5:
 71+  B0A7 FE 35            cp 53                                   ; was 5 pressed
 72+  B0A9 C8               ret z                                   ; exit if so
 73+  B0AA C3 70 B0         jp options_show8                         ; otherwise, jump to top
 74+  B0AD C9               ret
 75+  B0AE
 76+  B0AE              ;
 77+  B0AE              ; Initialise the options screen
 78+  B0AE              ;
 79+  B0AE              options_init:
 80+  B0AE 3E 47            ld a,71             ; white ink (7) on black paper (0),
 81+  B0B0                                      ; bright (64).
 82+  B0B0 CD 3D 81         call utilities_clearscreen
 83+  B0B3 32 8D 5C         ld (23693),a        ; set our screen colours.
 84+  B0B6 3E 00            ld a,0              ; 2 is the code for red.
 85+  B0B8 D3 FE            out (254),a         ; write to port 254.
 86+  B0BA
 87+  B0BA C9               ret
 88+  B0BB C9               ret
# file closed: screen/options.asm
141   B0BC
142   B0BC                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  B0BC              sound_gemcollected:
  2+  B0BC 21 C8 00         ld hl,200 ; pitch.
  3+  B0BF 11 3E 00         ld de,62 ; duration.
  4+  B0C2 CD B5 03         call 949 ; ROM beeper routine.
  5+  B0C5 C9               ret
  6+  B0C6
  7+  B0C6              sound_pitchbend:
  8+  B0C6 21 F4 01         ld hl,500 ; starting pitch.
  9+  B0C9 06 FA            ld b,250 ; length of pitch bend.
 10+  B0CB              sound_pitchbend0:
 11+  B0CB C5                push bc
 12+  B0CC E5               push hl ; store pitch.
 13+  B0CD 11 01 00         ld de,1 ; very short duration.
 14+  B0D0 CD B5 03         call 949 ; ROM beeper routine.
 15+  B0D3 E1               pop hl ; restore pitch.
 16+  B0D4 23               inc hl ; pitch going up.
 17+  B0D5 C1               pop bc
 18+  B0D6 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  B0D8 C9               ret
 20+  B0D9
 21+  B0D9              sound_rockfell:
 22+  B0D9 08               ex af,af'
 23+  B0DA 1E 32            ld e,50 ; repeat 250 times.
 24+  B0DC 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  B0DF D5           sound_rockfell2 push de
 26+  B0E0 06 20            ld b,32 ; length of step.
 27+  B0E2 C5           sound_rockfell0 push bc
 28+  B0E3 7E               ld a,(hl) ; next "random" number.
 29+  B0E4 23               inc hl ; pointer.
 30+  B0E5 E6 F8            and 248 ; we want a black border.
 31+  B0E7 D3 FE            out (254),a ; write to speaker.
 32+  B0E9 7B               ld a,e ; as e gets smaller...
 33+  B0EA 2F               cpl ; ...we increase the delay.
 34+  B0EB 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  B0EC 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  B0EE C1               pop bc
 37+  B0EF 10 F1            djnz sound_rockfell0 ; next step.
 38+  B0F1 D1               pop de
 39+  B0F2 7B               ld a,e
 40+  B0F3 D6 18            sub 24 ; size of step.
 41+  B0F5 FE 1E            cp 30 ; end of range.
 42+  B0F7 CA 08 B1         jp z,sound_rockfell5
 43+  B0FA DA 08 B1         jp c, sound_rockfell5
 44+  B0FD 5F               ld e,a
 45+  B0FE 2F               cpl
 46+  B0FF 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  B101 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  B103 3D               dec a
 49+  B104 20 F9            jr nz,sound_rockfell3
 50+  B106 18 D7            jr sound_rockfell2
 51+  B108              sound_rockfell5
 52+  B108 08               ex af,af'
 53+  B109 C9               ret
 54+  B10A
# file closed: sound/sound.asm
143   B10A
144   B10A                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  B10A              ; ###############################################################
  2+  B10A              ; Data for level 1
  3+  B10A              ; ###############################################################
  4+  B10A              level01:
  5+  B10A
  6+  B10A                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  B10A
  8+  B10A 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  B10E 05 05 05 05
  8+  B112 05 05 05 05
  8+  B116 05 05 02 01
  8+  B11A 01 01 03 05
  8+  B11E 05 05 05 05
  8+  B122 05 05 05 05
  8+  B126 05 05 00 00
  9+  B12A 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  B12E 05 05 05 05
  9+  B132 05 05 05 05
  9+  B136 02 01 01 01
  9+  B13A 01 01 01 01
  9+  B13E 03 05 05 05
  9+  B142 05 05 05 05
  9+  B146 05 05 00 00
 10+  B14A 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  B14E 05 05 05 05
 10+  B152 05 05 02 01
 10+  B156 01 01 01 01
 10+  B15A 01 01 01 01
 10+  B15E 01 01 03 05
 10+  B162 0D 0D 0D 0D
 10+  B166 0D 0D 00 00
 11+  B16A 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  B16E 01 01 00 01
 11+  B172 01 01 01 01
 11+  B176 01 01 01 01
 11+  B17A 01 01 01 01
 11+  B17E 01 01 01 03
 11+  B182 05 05 05 05
 11+  B186 05 05 00 00
 12+  B18A 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  B18E 04 04 04 04
 12+  B192 04 04 01 01
 12+  B196 01 01 01 01
 12+  B19A 01 01 01 01
 12+  B19E 01 01 01 01
 12+  B1A2 01 01 01 01
 12+  B1A6 00 01 00 00
 13+  B1AA 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  B1AE 04 04 04 04
 13+  B1B2 04 04 04 04
 13+  B1B6 01 01 01 01
 13+  B1BA 01 01 01 01
 13+  B1BE 01 01 01 01
 13+  B1C2 00 00 00 00
 13+  B1C6 00 01 00 00
 14+  B1CA 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  B1CE 04 01 01 01
 14+  B1D2 01 01 04 04
 14+  B1D6 04 04 01 01
 14+  B1DA 01 01 01 01
 14+  B1DE 01 00 00 00
 14+  B1E2 00 01 01 01
 14+  B1E6 01 01 00 00
 15+  B1EA 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  B1EE 04 04 04 04
 15+  B1F2 04 01 04 04
 15+  B1F6 04 04 04 04
 15+  B1FA 04 04 00 00
 15+  B1FE 00 00 04 04
 15+  B202 04 04 04 04
 15+  B206 04 01 00 00
 16+  B20A 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  B20E 01 04 01 01
 16+  B212 01 01 04 04
 16+  B216 04 04 04 04
 16+  B21A 04 04 00 04
 16+  B21E 04 04 04 04
 16+  B222 04 04 04 04
 16+  B226 04 01 00 00
 17+  B22A 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  B22E 00 00 00 00
 17+  B232 00 04 04 04
 17+  B236 04 04 04 04
 17+  B23A 04 04 00 04
 17+  B23E 04 04 04 04
 17+  B242 04 04 04 04
 17+  B246 04 01 00 00
 18+  B24A 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  B24E 15 15 15 15
 18+  B252 15 01 04 04
 18+  B256 04 04 04 04
 18+  B25A 04 04 00 04
 18+  B25E 04 04 04 04
 18+  B262 04 04 04 04
 18+  B266 04 01 00 00
 19+  B26A 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B26E 00 00 00 00
 19+  B272 00 01 04 04
 19+  B276 04 04 04 04
 19+  B27A 04 04 00 04
 19+  B27E 04 04 04 04
 19+  B282 04 00 00 00
 19+  B286 00 01 00 00
 20+  B28A 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B28E 00 00 00 00
 20+  B292 00 01 04 04
 20+  B296 04 04 04 04
 20+  B29A 04 04 00 04
 20+  B29E 04 04 04 04
 20+  B2A2 04 00 04 04
 20+  B2A6 00 01 00 00
 21+  B2AA 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B2AE 06 06 06 06
 21+  B2B2 06 01 04 04
 21+  B2B6 04 04 04 04
 21+  B2BA 04 04 00 04
 21+  B2BE 04 04 04 04
 21+  B2C2 04 00 04 04
 21+  B2C6 00 01 00 00
 22+  B2CA 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B2CE 1A 1A 1A 1A
 22+  B2D2 1A 01 04 00
 22+  B2D6 00 00 00 00
 22+  B2DA 00 00 00 00
 22+  B2DE 00 00 00 00
 22+  B2E2 00 00 04 04
 22+  B2E6 00 01 00 00
 23+  B2EA 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B2EE 1A 1A 1A 1A
 23+  B2F2 1A 01 04 00
 23+  B2F6 04 04 04 04
 23+  B2FA 04 04 00 04
 23+  B2FE 04 04 00 04
 23+  B302 04 04 04 04
 23+  B306 00 01 00 00
 24+  B30A 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B30E 1A 1A 1A 1A
 24+  B312 1A 01 04 00
 24+  B316 04 04 04 04
 24+  B31A 04 04 00 04
 24+  B31E 04 04 00 04
 24+  B322 04 04 04 04
 24+  B326 00 01 00 00
 25+  B32A 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B32E 01 01 01 01
 25+  B332 01 01 04 00
 25+  B336 04 04 04 04
 25+  B33A 04 04 00 04
 25+  B33E 04 04 00 04
 25+  B342 04 04 04 04
 25+  B346 00 01 00 00
 26+  B34A 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B34E 04 04 04 04
 26+  B352 04 04 04 00
 26+  B356 04 04 04 04
 26+  B35A 04 04 00 04
 26+  B35E 04 04 00 00
 26+  B362 00 00 04 04
 26+  B366 04 01 00 00
 27+  B36A 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B36E 04 04 00 00
 27+  B372 00 00 00 00
 27+  B376 04 04 04 04
 27+  B37A 04 04 00 04
 27+  B37E 04 04 04 04
 27+  B382 04 00 04 04
 27+  B386 04 01 00 00
 28+  B38A 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B38E 04 04 00 04
 28+  B392 04 04 04 04
 28+  B396 04 04 04 04
 28+  B39A 04 04 00 04
 28+  B39E 04 04 04 04
 28+  B3A2 04 00 04 04
 28+  B3A6 04 01 00 00
 29+  B3AA 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B3AE 04 04 00 04
 29+  B3B2 04 04 01 01
 29+  B3B6 01 01 01 01
 29+  B3BA 01 01 01 01
 29+  B3BE 01 01 01 01
 29+  B3C2 04 00 04 04
 29+  B3C6 04 01 00 00
 30+  B3CA 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B3CE 04 04 00 04
 30+  B3D2 04 04 01 00
 30+  B3D6 00 00 00 00
 30+  B3DA 00 00 00 00
 30+  B3DE 00 00 00 01
 30+  B3E2 04 00 04 04
 30+  B3E6 04 01 00 00
 31+  B3EA 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B3EE 04 04 00 04
 31+  B3F2 04 04 01 00
 31+  B3F6 00 00 00 00
 31+  B3FA 00 00 00 00
 31+  B3FE 00 00 00 01
 31+  B402 04 00 04 04
 31+  B406 04 01 00 00
 32+  B40A 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B40E 04 04 00 04
 32+  B412 04 04 01 00
 32+  B416 00 00 00 00
 32+  B41A 00 00 00 00
 32+  B41E 00 00 00 01
 32+  B422 04 00 04 04
 32+  B426 04 01 00 00
 33+  B42A 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B42E 04 04 00 04
 33+  B432 04 04 04 00
 33+  B436 00 00 00 00
 33+  B43A 00 00 00 00
 33+  B43E 00 00 00 04
 33+  B442 04 04 04 04
 33+  B446 04 01 00 00
 34+  B44A 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B44E 04 04 04 04
 34+  B452 04 04 01 00
 34+  B456 00 00 00 00
 34+  B45A 00 00 00 00
 34+  B45E 00 00 00 01
 34+  B462 04 04 04 04
 34+  B466 04 01 00 00
 35+  B46A 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B46E 04 04 04 04
 35+  B472 04 04 01 00
 35+  B476 00 00 01 00
 35+  B47A 00 00 00 01
 35+  B47E 00 00 00 01
 35+  B482 04 04 04 04
 35+  B486 04 01 00 00
 36+  B48A 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B48E 01 01 01 01
 36+  B492 01 01 01 01
 36+  B496 01 01 01 01
 36+  B49A 01 01 01 01
 36+  B49E 01 01 01 01
 36+  B4A2 01 01 01 01
 36+  B4A6 01 01 00 00
 37+  B4AA
 38+  B4AA              ; ###############################################################
 39+  B4AA              ; Object data: horiz, vert, state, memh, meml
 40+  B4AA              ; ###############################################################
 41+  B4AA              level01rocks:
 42+  B4AA 09 04 00 00      defb 9,4,0,0,0
 42+  B4AE 00
 43+  B4AF 0C 07 00 00      defb 12,7,0,0,0
 43+  B4B3 00
 44+  B4B4 10 07 00 00      defb 16,7,0,0,0
 44+  B4B8 00
 45+  B4B9 0B 08 00 00      defb 11,8,0,0,0
 45+  B4BD 00
 46+  B4BE 0A 0A 00 00      defb 10,10,0,0,0
 46+  B4C2 00
 47+  B4C3 0C 0A 00 00      defb 12,10,0,0,0
 47+  B4C7 00
 48+  B4C8 0D 09 00 00      defb 13,9,0,0,0
 48+  B4CC 00
 49+  B4CD 0E 08 00 00      defb 14,8,0,0,0
 49+  B4D1 00
 50+  B4D2 0F 0B 00 00      defb 15,11,0,0,0
 50+  B4D6 00
 51+  B4D7 0B 0C 00 00      defb 11,12,0,0,0
 51+  B4DB 00
 52+  B4DC 11 0C 00 00      defb 17,12,0,0,0
 52+  B4E0 00
 53+  B4E1 13 08 00 00      defb 19,8,0,0,0
 53+  B4E5 00
 54+  B4E6 16 09 00 00      defb 22,9,0,0,0
 54+  B4EA 00
 55+  B4EB 13 0A 00 00      defb 19,10,0,0,0
 55+  B4EF 00
 56+  B4F0 15 0A 00 00      defb 21,10,0,0,0
 56+  B4F4 00
 57+  B4F5 15 0C 00 00      defb 21,12,0,0,0
 57+  B4F9 00
 58+  B4FA 16 0C 00 00      defb 22,12,0,0,0
 58+  B4FE 00
 59+  B4FF 18 0A 00 00      defb 24,10,0,0,0
 59+  B503 00
 60+  B504 19 09 00 00      defb 25,9,0,0,0
 60+  B508 00
 61+  B509 1C 09 00 00      defb 28,9,0,0,0
 61+  B50D 00
 62+  B50E 1B 0C 00 00      defb 27,12,0,0,0
 62+  B512 00
 63+  B513 1A 0D 00 00      defb 26,13,0,0,0
 63+  B517 00
 64+  B518 19 0E 00 00      defb 25,14,0,0,0
 64+  B51C 00
 65+  B51D 19 10 00 00      defb 25,16,0,0,0
 65+  B521 00
 66+  B522 1A 11 00 00      defb 26,17,0,0,0
 66+  B526 00
 67+  B527 1B 11 00 00      defb 27,17,0,0,0
 67+  B52B 00
 68+  B52C 1C 12 00 00      defb 28,18,0,0,0
 68+  B530 00
 69+  B531 1A 13 00 00      defb 26,19,0,0,0
 69+  B535 00
 70+  B536 1B 15 00 00      defb 27,21,0,0,0
 70+  B53A 00
 71+  B53B 1A 17 00 00      defb 26,23,0,0,0
 71+  B53F 00
 72+  B540 1B 18 00 00      defb 27,24,0,0,0
 72+  B544 00
 73+  B545 19 18 00 00      defb 25,24,0,0,0
 73+  B549 00
 74+  B54A 18 17 00 00      defb 24,23,0,0,0
 74+  B54E 00
 75+  B54F 13 14 00 00      defb 19,20,0,0,0
 75+  B553 00
 76+  B554 14 12 00 00      defb 20,18,0,0,0
 76+  B558 00
 77+  B559 14 10 00 00      defb 20,16,0,0,0
 77+  B55D 00
 78+  B55E 15 10 00 00      defb 21,16,0,0,0
 78+  B562 00
 79+  B563 16 12 00 00      defb 22,18,0,0,0
 79+  B567 00
 80+  B568 11 14 00 00      defb 17,20,0,0,0
 80+  B56C 00
 81+  B56D 0D 11 00 00      defb 13,17,0,0,0
 81+  B571 00
 82+  B572 0C 13 00 00      defb 12,19,0,0,0
 82+  B576 00
 83+  B577 0B 13 00 00      defb 11,19,0,0,0
 83+  B57B 00
 84+  B57C 0A 11 00 00      defb 10,17,0,0,0
 84+  B580 00
 85+  B581 05 12 00 00      defb 5,18,0,0,0
 85+  B585 00
 86+  B586 07 16 00 00      defb 7,22,0,0,0
 86+  B58A 00
 87+  B58B 09 16 00 00      defb 9,22,0,0,0
 87+  B58F 00
 88+  B590 07 18 00 00      defb 7,24,0,0,0
 88+  B594 00
 89+  B595 05 18 00 00      defb 5,24,0,0,0
 89+  B599 00
 90+  B59A 06 19 00 00      defb 6,25,0,0,0
 90+  B59E 00
 91+  B59F 08 19 00 00      defb 8,25,0,0,0
 91+  B5A3 00
 92+  B5A4 04 17 00 00      defb 4,23,0,0,0
 92+  B5A8 00
 93+  B5A9 FF               defb 255
 94+  B5AA
 95+  B5AA              level01missiles:
 96+  B5AA 0B 17 00 00      defb 11,23,0,0,0
 96+  B5AE 00
 97+  B5AF 0B 16 00 00      defb 11,22,0,0,0
 97+  B5B3 00
 98+  B5B4 0C 17 00 00      defb 12,23,0,0,0
 98+  B5B8 00
 99+  B5B9 0C 16 00 00      defb 12,22,0,0,0
 99+  B5BD 00
100+  B5BE 0D 17 00 00      defb 13,23,0,0,0
100+  B5C2 00
101+  B5C3 0D 16 00 00      defb 13,22,0,0,0
101+  B5C7 00
102+  B5C8 0E 17 00 00      defb 14,23,0,0,0
102+  B5CC 00
103+  B5CD 0E 16 00 00      defb 14,22,0,0,0
103+  B5D1 00
104+  B5D2 0F 17 00 00      defb 15,23,0,0,0
104+  B5D6 00
105+  B5D7 0F 16 00 00      defb 15,22,0,0,0
105+  B5DB 00
106+  B5DC 10 17 00 00      defb 16,23,0,0,0
106+  B5E0 00
107+  B5E1 10 16 00 00      defb 16,22,0,0,0
107+  B5E5 00
108+  B5E6 11 17 00 00      defb 17,23,0,0,0
108+  B5EA 00
109+  B5EB 11 16 00 00      defb 17,22,0,0,0
109+  B5EF 00
110+  B5F0 12 17 00 00      defb 18,23,0,0,0
110+  B5F4 00
111+  B5F5 12 16 00 00      defb 18,22,0,0,0
111+  B5F9 00
112+  B5FA 13 17 00 00      defb 19,23,0,0,0
112+  B5FE 00
113+  B5FF 13 16 00 00      defb 19,22,0,0,0
113+  B603 00
114+  B604 14 17 00 00      defb 20,23,0,0,0
114+  B608 00
115+  B609 14 16 00 00      defb 20,22,0,0,0
115+  B60D 00
116+  B60E 15 17 00 00      defb 21,23,0,0,0
116+  B612 00
117+  B613 15 16 00 00      defb 21,22,0,0,0
117+  B617 00
118+  B618 16 17 00 00      defb 22,23,0,0,0
118+  B61C 00
119+  B61D 16 16 00 00      defb 22,22,0,0,0
119+  B621 00
120+  B622 FF               defb 255
121+  B623
122+  B623              ;
123+  B623              ; Diamonds: x,y,state,mem1+mem2
124+  B623              ;
125+  B623              level01diamonds:
126+  B623 0C 1B 00 00      defb 12,27,0,0,0
126+  B627 00
127+  B628 10 1B 00 00      defb 16,27,0,0,0
127+  B62C 00
128+  B62D 15 1B 00 00      defb 21,27,0,0,0
128+  B631 00
129+  B632 FF               defb 255
130+  B633
131+  B633              level01gems:
132+  B633 12 14 00 00      defb 18,20,0,0,0
132+  B637 00
133+  B638 06 18 00 00      defb 6,24,0,0,0
133+  B63C 00
134+  B63D 19 17 00 00      defb 25,23,0,0,0
134+  B641 00
135+  B642 1C 11 00 00      defb 28,17,0,0,0
135+  B646 00
136+  B647 FF               defb 255
137+  B648              ;
138+  B648              ; Score area colours
139+  B648              ;
140+  B648              score_colours:
141+  B648 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  B64C 47 47 47 47
141+  B650 47 47 47 42
141+  B654 43 43 43 43
141+  B658 43 43 43 43
141+  B65C 42 47 47 47
141+  B660 47 47 47 47
141+  B664 47 47 47 47
142+  B668 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  B66C 47 47 47 47
142+  B670 47 47 47 46
142+  B674 46 46 46 46
142+  B678 46 46 46 46
142+  B67C 46 47 47 47
142+  B680 47 47 47 47
142+  B684 47 47 47 47
143+  B688
144+  B688              high_score_colours:
145+  B688 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  B68C 42 42 47 47
145+  B690 47 47 47 47
145+  B694 43 43 43 47
145+  B698 47 47 47 47
145+  B69C 47 46 46 46
145+  B6A0 47 47 47 47
145+  B6A4 47 47 00 00
# file closed: leveldata/level01.asm
145   B6A8                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B6A8              ; Tiles graphics.
  2+  B6A8              sprites:
  3+  B6A8 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B6AC 00 00 00 00
  4+  B6B0 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B6B4 FF FF FF FF
  5+  B6B8 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B6BC 1F 3F 7F FF
  6+  B6C0 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B6C4 F8 FC FE FF
  7+  B6C8 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B6CC 55 AA 55 AA
  8+  B6D0 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B6D4 00 00 00 00
  9+  B6D8 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 6, slime block
  9+  B6DC 00 00 00 00
 10+  B6E0 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  B6E4 00 00 00 00
 11+  B6E8 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B6EC F1 72 34 18
 12+  B6F0 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B6F4 FE FE FF 7E
 13+  B6F8 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B6FC FE FF 7E 3C
 14+  B700 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B704 00 00 FF FF
 15+  B708 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  B70C FF 42 24 18
 16+  B710 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B714 00 00 00 00
 17+  B718 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B71C 00 3C 5A 34
 18+  B720 FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  B724 FD FE FD FE
 19+  B728 F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  B72C F4 F8 F4 F8
 20+  B730 D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  B734 D0 E0 D0 E0
 21+  B738 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  B73C 40 80 40 80
 22+  B740 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  B744 ED 00 00 00
 23+  B748 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  B74C FF 7E 3C 18
 24+  B750 FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  B754 00 00 00 00
 25+  B758 FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  B75C 00 00 00 00
 26+  B760 F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  B764 00 00 00 00
 27+  B768 C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  B76C 00 00 00 00
 28+  B770 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  B774 00 00 00 00
 29+  B778 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  B77C FF FF FF FF
 30+  B780 00 00 00 66  	defb    0,  0,  0,102,  0,  0,  0,  0     ; 27, bullet
 30+  B784 00 00 00 00
 31+  B788
 32+  B788
 33+  B788              sprite_attrs:
 34+  B788 46               defb    070 ; 0, space
 35+  B789 4D               defb    077 ; 1, cyan block
 36+  B78A 4D               defb    077 ; 2, slope left
 37+  B78B 4D               defb    077 ; 3, slope right
 38+  B78C 46               defb    070 ; 4, dirt
 39+  B78D 4E               defb    078 ; 5, sky
 40+  B78E 66               defb    102 ; 6, slime
 41+  B78F 42               defb    066 ; 7, trapdoor
 42+  B790 46               defb    070 ; 8, diamond
 43+  B791 42               defb    066 ; 9, rock
 44+  B792 42               defb    066 ; 10, rock 2
 45+  B793 49           	defb    073 ; 11, sky, trapdoor
 46+  B794 43           	defb    067 ; 12, missile
 47+  B795 4A               defb    074 ; 13, sky, red ink (tank)
 48+  B796 46               defb    070 ; 14, gem
 49+  B797 4D               defb    077 ; 15, damaged mountain
 50+  B798 4D               defb    077 ; 16, damaged mountain 2
 51+  B799 4D               defb    077 ; 17, damaged mountain 3
 52+  B79A 4D               defb    077 ; 18, damaged mountain 4
 53+  B79B 00           	defb 	000 ; 19, tank missile (not used
 54+  B79C 43           	defb    067 ; 20, missile active
 55+  B79D 42           	defb	066	; 21, the pit 1
 56+  B79E 42           	defb	066	; 22, the pit 2
 57+  B79F 42           	defb	066	; 23, the pit 3
 58+  B7A0 42           	defb	066	; 24, the pit 4
 59+  B7A1 42           	defb	066	; 25, the pit 5
 60+  B7A2 64           	defb    100 ; 26, slime, green on green
 61+  B7A3 46           	defb 	070 ; 27, bullet
 62+  B7A4
 63+  B7A4
 64+  B7A4              player_sprite:
 65+  B7A4 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 65+  B7A8 38 3D C3 80
 66+  B7AC 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 66+  B7B0 3C 1C 16 32
 67+  B7B4 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 67+  B7B8 3C 38 68 4C
 68+  B7BC 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 68+  B7C0 1C BC C3 01
 69+  B7C4 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 69+  B7C8 3C 3C 64 0C
 70+  B7CC 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 70+  B7D0 3C 3C 26 30
 71+  B7D4 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 71+  B7D8 1E 5C FD 5F
 72+  B7DC 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 72+  B7E0 4F 8F 19 03
 73+  B7E4 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 73+  B7E8 F2 F1 98 C0
 74+  B7EC FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 74+  B7F0 48 08 14 2A
 75+  B7F4 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 75+  B7F8 38 78 44 C3
 76+  B7FC 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 76+  B800 1C 1E 22 C3
 77+  B804 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 77+  B808 6F 45 E1 9B
 78+  B80C 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 78+  B810 F6 A2 87 D9
 79+  B814
 80+  B814              ;
 81+  B814              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 82+  B814              ;
 83+  B814              ship_sprite:
 84+  B814 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 84+  B818 03 1F 7F FF
 85+  B81C 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 85+  B820 FF FF FF FF
 86+  B824 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 86+  B828 FF FF FF FF
 87+  B82C 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 87+  B830 C0 F8 FE FF
 88+  B834 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 88+  B838 03 03 02 07
 89+  B83C 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 89+  B840 FF 0F 07 83
 90+  B844 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 90+  B848 FF 10 20 C1
 91+  B84C 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 91+  B850 C0 C0 40 E0
 92+  B854 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 92+  B858 03 03 02 07
 93+  B85C F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 93+  B860 FF 08 04 83
 94+  B864 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 94+  B868 FF F0 E0 C1
 95+  B86C CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 95+  B870 C0 C0 40 E0
 96+  B874
 97+  B874              ;
 98+  B874              ;  First 8 frames are tank, last frame is the gun barrel
 99+  B874              ;
100+  B874              tank_sprite:
101+  B874 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
101+  B878 7F 00 00 00
102+  B87C 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
102+  B880 FE FF 7F 40
103+  B884 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
103+  B888 03 FF FF 01
104+  B88C 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
104+  B890 E0 C0 00 00
105+  B894 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
105+  B898 F7 E1 7F 3F
106+  B89C FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
106+  B8A0 54 16 FF FF
107+  B8A4 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
107+  B8A8 9B A8 FF FF
108+  B8AC FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
108+  B8B0 9F AF FE FC
109+  B8B4 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
109+  B8B8 1F 00 00 00
110+  B8BC
111+  B8BC              monster_sprite:
112+  B8BC 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  B8C0 0B D0 16 68
113+  B8C4 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
113+  B8C8 35 AC 7F FE
114+  B8CC FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
114+  B8D0 8F F1 8F F1
115+  B8D4 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
115+  B8D8 18 18 00 00
116+  B8DC 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
116+  B8E0 0B D0 16 68
117+  B8E4 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
117+  B8E8 F5 AF FF FF
118+  B8EC BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
118+  B8F0 0F F0 0F F0
119+  B8F4 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
119+  B8F8 00 00 00 00
120+  B8FC
121+  B8FC              robot_sprite:
122+  B8FC 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
122+  B900 CE 12 22 66
123+  B904 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
123+  B908 4E 12 24 6C
124+  B90C 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
124+  B910 4E 32 63 03
125+  B914 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
125+  B918 CE 0A 09 1B
126+  B91C 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
126+  B920 73 48 44 66
127+  B924 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
127+  B928 72 48 24 36
128+  B92C 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
128+  B930 72 4C C6 C0
129+  B934 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
129+  B938 73 50 90 D8
130+  B93C 38 A9 BA 7C  	defb     56,169,186,124, 56, 42, 38, 96     ; dead 1
130+  B940 38 2A 26 60
131+  B944 1C 95 5D 3E  	defb	 28,149, 93, 62, 28, 84,100,  6		; dead 2
131+  B948 1C 54 64 06
# file closed: graphics/graphics.asm
146   B94C
147   B94C                  include "game\control.asm"
# file opened: game/control.asm
  1+  B94C              ;
  2+  B94C              ; Check the preferred input method then move
  3+  B94C              ;
  4+  B94C              control_input:
  5+  B94C 3A 9C BE         ld a,(player+11)    ; first, check if player is dying
  6+  B94F FE 04            cp 4                ; is the player falling
  7+  B951 CC 1B BA         call z, control_fall
  8+  B954 FE 05            cp 5                ; is the player fighting
  9+  B956 CC 08 BA         call z, control_fight
 10+  B959 3A 9C BE         ld a,(player+11)    ; first, check if player is dying
 11+  B95C FE 00            cp 0
 12+  B95E C0               ret nz               ; if so, can't move
 13+  B95F 3A 96 BE         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  B962 FE 00            cp 0
 15+  B964 CA 6B B9         jp z, control_input0
 16+  B967 CD F9 BA         call control_automove
 17+  B96A C9               ret
 18+  B96B              control_input0:
 19+  B96B 3A 97 BE         ld a,(player+6)      ; next, check if the player is digging
 20+  B96E FE 00            cp 0
 21+  B970 CA 77 B9         jp z, control_input1
 22+  B973 CD 37 BA         call control_dig
 23+  B976 C9               ret
 24+  B977              control_input1:
 25+  B977 3A 54 BE         ld a,(game_control)
 26+  B97A FE 00            cp 0                ; is this keyboard
 27+  B97C C2 83 B9         jp nz,control_input2
 28+  B97F CD 87 B9         call control_keyboard
 29+  B982 C9               ret
 30+  B983              control_input2:
 31+  B983                  ; do joystick
 32+  B983 CD CD B9         call control_joystick
 33+  B986 C9               ret
 34+  B987
 35+  B987              ;
 36+  B987              ; Check the keyboard
 37+  B987              ;
 38+  B987              control_keyboard:
 39+  B987 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 40+  B98A ED 78            in a,(c)            ; read keyboard.
 41+  B98C 47               ld b,a              ; store result in b register.
 42+  B98D CB 18            rr b                ; check outermost key (q).
 43+  B98F D2 B9 B9         jp nc,control_keyboard1
 44+  B992 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 45+  B995 ED 78            in a,(c)            ; read keyboard.
 46+  B997 47               ld b,a              ; store result in b register.
 47+  B998 CB 18            rr b                ; check outermost key (a).
 48+  B99A D2 BD B9         jp nc,control_keyboard2
 49+  B99D 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 50+  B9A0 ED 78            in a,(c)            ; read keyboard.
 51+  B9A2 47               ld b,a              ; store result in b register.
 52+  B9A3 CB 18            rr b                ; check outermost key (p).
 53+  B9A5 D2 C1 B9         jp nc,control_keyboard3
 54+  B9A8 CB 18            rr b                ; check next key.
 55+  B9AA D2 C5 B9         jp nc,control_keyboard4
 56+  B9AD 01 FE 7F         ld bc,32766         ; port for keyboard row b-space.
 57+  B9B0 ED 78            in a,(c)            ; read keyboard.
 58+  B9B2 47               ld b,a              ; store result in b register.
 59+  B9B3 CB 18            rr b                ; check outermost key (space).
 60+  B9B5 D2 C9 B9         jp nc,control_keyboard5
 61+  B9B8 C9               ret
 62+  B9B9              control_keyboard1:
 63+  B9B9 CD 42 BB         call control_pl_moveup         ; player up.
 64+  B9BC C9               ret
 65+  B9BD              control_keyboard2:
 66+  B9BD CD 6F BB         call control_pl_movedown       ; player down.
 67+  B9C0 C9               ret
 68+  B9C1              control_keyboard3:
 69+  B9C1 CD CB BB         call control_pl_moveright       ; player left.
 70+  B9C4 C9               ret
 71+  B9C5              control_keyboard4:
 72+  B9C5 CD 9B BB         call control_pl_moveleft       ; player right.
 73+  B9C8 C9               ret
 74+  B9C9              control_keyboard5:
 75+  B9C9 CD F9 BB         call control_pl_fire       ; player fire.
 76+  B9CC C9               ret
 77+  B9CD
 78+  B9CD              ;
 79+  B9CD              ; Check the joystick
 80+  B9CD              ;
 81+  B9CD              control_joystick:
 82+  B9CD 01 1F 00         ld bc,31                        ; Kempston joystick port.
 83+  B9D0 ED 78            in a,(c)                        ; read input.
 84+  B9D2 E6 02            and 2                           ; check "left" bit.
 85+  B9D4 C2 FC B9         jp nz,control_joystick3       ; move left.
 86+  B9D7 ED 78            in a,(c)                        ; read input.
 87+  B9D9 E6 01            and 1                           ; test "right" bit.
 88+  B9DB C2 00 BA         jp nz,control_joystick4       ; move right.
 89+  B9DE ED 78            in a,(c)                        ; read input.
 90+  B9E0 E6 08            and 8                           ; check "up" bit.
 91+  B9E2 C2 F4 B9         jp nz,control_joystick1       ; move up.
 92+  B9E5 ED 78            in a,(c)                        ; read input.
 93+  B9E7 E6 04            and 4                           ; check "down" bit.
 94+  B9E9 C2 F8 B9         jp nz,control_joystick2       ; move down.
 95+  B9EC ED 78            in a,(c)                        ; read input.
 96+  B9EE E6 10            and 16                          ; try the fire bit.
 97+  B9F0 C2 04 BA         jp nz,control_joystick5       ; fire pressed.
 98+  B9F3 C9               ret
 99+  B9F4              control_joystick1:
100+  B9F4 CD 42 BB         call control_pl_moveup         ; player up.
101+  B9F7 C9               ret
102+  B9F8              control_joystick2:
103+  B9F8 CD 6F BB         call control_pl_movedown       ; player down.
104+  B9FB C9               ret
105+  B9FC              control_joystick3:
106+  B9FC CD 9B BB         call control_pl_moveleft       ; player left.
107+  B9FF C9               ret
108+  BA00              control_joystick4:
109+  BA00 CD CB BB         call control_pl_moveright       ; player right.
110+  BA03 C9               ret
111+  BA04              control_joystick5:
112+  BA04 CD F9 BB         call control_pl_fire
113+  BA07 C9               ret
114+  BA08
115+  BA08              ;
116+  BA08              ; Fights the player - just flips the players anim frame
117+  BA08              ;
118+  BA08              control_fight:
119+  BA08 3A 94 BE         ld a,(player+3)             ; load the frame
120+  BA0B FE 0C            cp 12                       ; flip between 12 and 13
121+  BA0D CA 15 BA         jp z,control_fight0
122+  BA10 3E 0C            ld a,12
123+  BA12 C3 17 BA         jp control_fight1
124+  BA15              control_fight0:
125+  BA15 3E 0D            ld a,13
126+  BA17              control_fight1:
127+  BA17 32 94 BE         ld (player+3),a           ; save back
128+  BA1A C9               ret
129+  BA1B
130+  BA1B              ;
131+  BA1B              ; Falls the player
132+  BA1B              ;
133+  BA1B              control_fall:
134+  BA1B ED 4B 91 BE      ld bc,(player)              ; get coords
135+  BA1F 0C               inc c
136+  BA20 ED 43 91 BE      ld (player),bc
137+  BA24 3A 94 BE         ld a,(player+3)             ; load the frame
138+  BA27 FE 03            cp 3                       ; flip between 3 and 0
139+  BA29 C2 31 BA         jp nz, control_fall0
140+  BA2C 3E 00            ld a,0
141+  BA2E C3 33 BA         jp control_fall1
142+  BA31              control_fall0:
143+  BA31 3E 03            ld a,3
144+  BA33              control_fall1:
145+  BA33 32 94 BE         ld (player+3),a           ; save back
146+  BA36 C9               ret
147+  BA37
148+  BA37              ;
149+  BA37              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
150+  BA37              ;
151+  BA37              control_dig:
152+  BA37 ED 4B 91 BE      ld bc,(player)      ; load the current coords into bc
153+  BA3B C5               push bc
154+  BA3C 3A 93 BE         ld a,(player+2)     ; get the direction
155+  BA3F FE 01            cp 1                ; left
156+  BA41 CA 59 BA         jp z,control_dig0
157+  BA44 FE 02            cp 2                ; right
158+  BA46 CA 6E BA         jp z,control_dig1
159+  BA49 FE 03            cp 3                ; down
160+  BA4B CA 92 BA         jp z,control_dig5
161+  BA4E FE 00            cp 0                ; up
162+  BA50 CA 82 BA         jp z,control_dig4
163+  BA53 21 97 BE         ld hl,player+6
164+  BA56 36 00            ld (hl),0           ; turn off digging
165+  BA58 C9               ret                 ; return
166+  BA59              control_dig0:           ; going left
167+  BA59 CD F8 AB         call sprites_scadd  ; get the current coord
168+  BA5C 62 6B            ld hl,de
169+  BA5E 2B               dec hl              ; move one left
170+  BA5F C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
171+  BA60 78               ld a,b
172+  BA61 06 08            ld b,8
173+  BA63 90               sub b
174+  BA64 47               ld b,a
175+  BA65 79               ld a,c
176+  BA66 0E 08            ld c,8
177+  BA68 91               sub c
178+  BA69 4F               ld c,a
179+  BA6A C5               push bc
180+  BA6B C3 9B BA         jp control_dig2
181+  BA6E              control_dig1:
182+  BA6E CD F8 AB         call sprites_scadd  ; get the current coord
183+  BA71 62 6B            ld hl,de
184+  BA73 23               inc hl              ; move one right
185+  BA74 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
186+  BA75 3E 08            ld a,8
187+  BA77 80               add a,b
188+  BA78 47               ld b,a
189+  BA79 79               ld a,c
190+  BA7A 0E 08            ld c,8
191+  BA7C 91               sub c
192+  BA7D 4F               ld c,a
193+  BA7E C5               push bc
194+  BA7F C3 9B BA         jp control_dig2
195+  BA82              control_dig4:
196+  BA82 CD F8 AB         call sprites_scadd  ; get the current coord
197+  BA85 62 6B            ld hl,de
198+  BA87 11 20 00         ld de,32
199+  BA8A ED 52            sbc hl,de             ; move one up
200+  BA8C C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
201+  BA8D 0D               dec c
202+  BA8E C5               push bc
203+  BA8F C3 B3 BA         jp control_dig6
204+  BA92              control_dig5:
205+  BA92 CD F8 AB         call sprites_scadd  ; get the current coord
206+  BA95 62 6B            ld hl,de
207+  BA97 24               inc h              ; move one down
208+  BA98                                     ; not bothered about working out bc here, since rock will never fall if digging down
209+  BA98 C3 9B BA         jp control_dig2
210+  BA9B              ; Normal (not up) digging
211+  BA9B              control_dig2:
212+  BA9B 3A 99 BE         ld a,(player+8)     ; get the number of rows we need to overwrite
213+  BA9E 47               ld b,a              ; rows to copy over
214+  BA9F E5               push hl             ; store the memory location of the first row for later
215+  BAA0              control_dig3:
216+  BAA0 CD E2 BA         call control_getpixelrow
217+  BAA3 77               ld (hl),a           ; load contents into row
218+  BAA4 11 20 00         ld de,32
219+  BAA7 19               add hl,de           ; move to next row
220+  BAA8 10 F6            djnz control_dig3
221+  BAAA E1               pop hl              ; get the original memory location back
222+  BAAB 11 20 00         ld de,32
223+  BAAE ED 52            sbc hl,de           ; move to above row, ready for checking for rock
224+  BAB0 C3 C9 BA         jp control_dig10
225+  BAB3              ; Special case for going up
226+  BAB3              control_dig6:
227+  BAB3 3A 99 BE         ld a,(player+8)     ; get the number of rows we need to overwrite
228+  BAB6 47               ld b,a              ; rows to copy over
229+  BAB7              control_dig7:
230+  BAB7 CD E2 BA         call control_getpixelrow
231+  BABA              control_dig12:
232+  BABA 77               ld (hl),a           ; load empty into row
233+  BABB 11 20 00         ld de,32
234+  BABE ED 52            sbc hl,de           ; move up to next row
235+  BAC0 0D               dec c               ; decrease c to track rows
236+  BAC1 10 F4            djnz control_dig7
237+  BAC3 79               ld a,c
238+  BAC4 D6 07            sub 7
239+  BAC6 C1               pop bc
240+  BAC7 4F               ld c,a
241+  BAC8 C5               push bc             ; store the decreased c coord
242+  BAC9              control_dig10:
243+  BAC9 DD 21 98 BE      ld ix,player+7
244+  BACD DD 7E 00         ld a,(ix)     ; get the dig frame number
245+  BAD0 3D               dec a
246+  BAD1 DD 77 00         ld (ix),a
247+  BAD4                  ; call the check for rocks above the removed dirt
248+  BAD4 DD 21 97 BE      ld ix,player+6
249+  BAD8 DD 7E 00         ld a,(ix)     ; get the dig state
250+  BADB FE 00            cp 0
251+  BADD C1               pop bc
252+  BADE CC 12 C4         call z, rocks_checkforfalling ; make the check if we're no longer digging
253+  BAE1 C9               ret
254+  BAE2
255+  BAE2              ;
256+  BAE2              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
257+  BAE2              ; Inputs:
258+  BAE2              ; hl - memory of pixel row
259+  BAE2              ; Outputs:
260+  BAE2              ; a - modified row to write
261+  BAE2              ;
262+  BAE2              control_getpixelrow:
263+  BAE2 3A 98 BE         ld a,(player+7)     ; get the dig frame number
264+  BAE5 FE 00            cp 0                ; is this the last dig
265+  BAE7 CA EE BA         jp z,control_getpixelrow1
266+  BAEA 7E               ld a,(hl)           ; if not, xor with 255 to flip it
267+  BAEB EE FF            xor 255
268+  BAED C9               ret
269+  BAEE              control_getpixelrow1:
270+  BAEE DD 21 97 BE      ld ix,player+6
271+  BAF2 DD 36 00 00      ld (ix),0           ; turn off digging
272+  BAF6 3E 00            ld a,0              ; if it is, load with empty
273+  BAF8 C9               ret
274+  BAF9
275+  BAF9              ;
276+  BAF9              ; Auto move the player until pixels is zero
277+  BAF9              ;
278+  BAF9              control_automove:
279+  BAF9 5F               ld e,a              ; store the number of pixels left to move in e
280+  BAFA ED 4B 91 BE      ld bc,(player)      ; load the current coords into bc
281+  BAFE 21 93 BE         ld hl,player+2      ; get the direction
282+  BB01 7E               ld a,(hl)
283+  BB02 FE 03            cp 3                ; down
284+  BB04 CA 18 BB         jp z,control_automove3  ; don't need to do anything
285+  BB07 FE 00            cp 0                ; going up
286+  BB09 CA 24 BB         jp z,control_automove2
287+  BB0C FE 01            cp 1                ; going left?
288+  BB0E CA 30 BB         jp z,control_automove0
289+  BB11 78               ld a,b
290+  BB12 3C               inc a               ; if we're going right, increment a twice for two pixels
291+  BB13 3C               inc a
292+  BB14 47               ld b,a
293+  BB15 C3 34 BB         jp control_automove1
294+  BB18              control_automove3:
295+  BB18 79               ld a,c
296+  BB19 3C               inc a
297+  BB1A 3C               inc a               ; if we're going down, increment twice
298+  BB1B 4F               ld c,a
299+  BB1C FE 90            cp 144
300+  BB1E CC 0F BC         call z, control_scroll_down
301+  BB21 C3 34 BB         jp control_automove1
302+  BB24              control_automove2:
303+  BB24 79               ld a,c
304+  BB25 3D               dec a
305+  BB26 3D               dec a               ; if we're going up, decrement twice
306+  BB27 4F               ld c,a
307+  BB28 FE 60            cp 96
308+  BB2A CC 1C BC         call z, control_scroll_up
309+  BB2D C3 34 BB         jp control_automove1
310+  BB30              control_automove0:
311+  BB30 78               ld a,b
312+  BB31 3D               dec a               ; if we're going left, decrement a twice
313+  BB32 3D               dec a
314+  BB33 47               ld b,a
315+  BB34              control_automove1:
316+  BB34 ED 43 91 BE      ld (player),bc      ; and back to player
317+  BB38 7B               ld a,e              ; now get the pixel count back
318+  BB39 3D               dec a               ; decrease by one
319+  BB3A 21 96 BE         ld hl,player+5
320+  BB3D 77               ld (hl),a           ; copy back
321+  BB3E CD 9C C0         call player_justmoved
322+  BB41 C9               ret
323+  BB42
324+  BB42              ;
325+  BB42              ; Moves the player up
326+  BB42              ;
327+  BB42              control_pl_moveup:
328+  BB42 C5               push bc
329+  BB43 ED 4B 91 BE      ld bc,(player)          ; get the current coords, b horiz, c vert
330+  BB47 79               ld a,c                  ; load c into the acc
331+  BB48 FE 18            cp 24
332+  BB4A CA 68 BB         jp z,control_pl_moveup0 ; are we at the edge of the screen
333+  BB4D FE 60            cp 96
334+  BB4F CC 1C BC         call z, control_scroll_up
335+  BB52 CD C3 BD         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
336+  BB55 F5               push af
337+  BB56 7B               ld a,e                  ; put e in a
338+  BB57 FE 00            cp 0
339+  BB59 CA 67 BB         jp z,control_pl_moveup1 ; don't move if we can't
340+  BB5C F1               pop af
341+  BB5D D6 01            sub 1                   ; subtract 1
342+  BB5F                  ;sub 1                   ; subtract 1
343+  BB5F 4F               ld c,a                  ; load back to c
344+  BB60 ED 43 91 BE      ld (player),bc          ; load back to player
345+  BB64 C3 68 BB         jp control_pl_moveup0
346+  BB67              control_pl_moveup1:
347+  BB67 F1               pop af                  ; restore af if needed
348+  BB68              control_pl_moveup0:
349+  BB68 3E 00            ld a,0
350+  BB6A 32 93 BE         ld (player+2),a        ; set direction to up
351+  BB6D C1               pop bc
352+  BB6E C9               ret
353+  BB6F              ;
354+  BB6F              ; Moves the player down
355+  BB6F              ;
356+  BB6F              control_pl_movedown:
357+  BB6F C5               push bc
358+  BB70 ED 4B 91 BE      ld bc,(player)          ; get the current coords, b horiz, c vert
359+  BB74 79               ld a,c                  ; load c into the acc
360+  BB75 FE E0            cp 224
361+  BB77 CA 94 BB         jp z,control_pl_movedown0 ; are we at the edge of the screen
362+  BB7A FE 80            cp 128
363+  BB7C CC 0F BC         call z, control_scroll_down
364+  BB7F CD 97 BD         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
365+  BB82 F5               push af
366+  BB83 7B               ld a,e                  ; put e in a
367+  BB84 FE 00            cp 0
368+  BB86 CA 93 BB         jp z,control_pl_movedown1 ; don't move if we can't
369+  BB89 F1               pop af
370+  BB8A 3C               inc a                   ; add 1
371+  BB8B                  ;inc a                   ; add 1
372+  BB8B 4F               ld c,a                  ; load back to c
373+  BB8C ED 43 91 BE      ld (player),bc          ; load back to player
374+  BB90 C3 94 BB         jp control_pl_movedown0
375+  BB93              control_pl_movedown1:
376+  BB93 F1               pop af                  ; restore af if needed
377+  BB94              control_pl_movedown0:
378+  BB94 3E 03            ld a,3
379+  BB96 32 93 BE         ld (player+2),a        ; set direction to down
380+  BB99 C1               pop bc
381+  BB9A C9               ret
382+  BB9B              ;
383+  BB9B              ; Moves the player left
384+  BB9B              ;
385+  BB9B              control_pl_moveleft:
386+  BB9B C5               push bc
387+  BB9C ED 4B 91 BE      ld bc,(player)          ; get the current coords, b horiz, c vert
388+  BBA0 78               ld a,b                  ; load b into the acc
389+  BBA1 FE 10            cp 16
390+  BBA3 CA C4 BB         jp z,control_pl_moveleft0 ; are we at the edge of the screen
391+  BBA6 CD 22 BE         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
392+  BBA9 F5               push af
393+  BBAA 7B               ld a,e                  ; put e in a
394+  BBAB FE 00            cp 0
395+  BBAD CA C3 BB         jp z,control_pl_moveleft1 ; don't move if we can't
396+  BBB0 21 96 BE         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
397+  BBB3 3E 03            ld a,3
398+  BBB5 77               ld (hl),a
399+  BBB6 F1               pop af
400+  BBB7 D6 01            sub 1                    ; subtract 2
401+  BBB9 D6 01            sub 1
402+  BBBB 47               ld b,a                  ; load back to c
403+  BBBC ED 43 91 BE      ld (player),bc          ; load back to player
404+  BBC0 C3 C4 BB         jp control_pl_moveleft0
405+  BBC3              control_pl_moveleft1:
406+  BBC3 F1               pop af
407+  BBC4              control_pl_moveleft0:
408+  BBC4 3E 01            ld a,1
409+  BBC6 32 93 BE         ld (player+2),a        ; set direction to left
410+  BBC9 C1               pop bc
411+  BBCA C9               ret
412+  BBCB              ;
413+  BBCB              ; Moves the player right
414+  BBCB              ;
415+  BBCB              control_pl_moveright:
416+  BBCB C5               push bc
417+  BBCC ED 4B 91 BE      ld bc,(player)          ; get the current coords, b horiz, c vert
418+  BBD0 78               ld a,b                  ; load b into the acc
419+  BBD1 FE F0            cp 240
420+  BBD3 CA F2 BB         jp z,control_pl_moveright0 ; are we at the edge of the screen
421+  BBD6 CD F6 BD         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
422+  BBD9 F5               push af
423+  BBDA 7B               ld a,e                  ; put e in a
424+  BBDB FE 00            cp 0
425+  BBDD CA F1 BB         jp z,control_pl_moveright1 ; don't move if we can't
426+  BBE0 21 96 BE         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
427+  BBE3 3E 03            ld a,3
428+  BBE5 77               ld (hl),a
429+  BBE6 F1               pop af
430+  BBE7 3C               inc a                   ; add 2
431+  BBE8 3C               inc a
432+  BBE9 47               ld b,a                  ; load back to b
433+  BBEA ED 43 91 BE      ld (player),bc          ; load back to player
434+  BBEE C3 F2 BB         jp control_pl_moveright0
435+  BBF1              control_pl_moveright1:
436+  BBF1 F1               pop af                  ; restore af if needed
437+  BBF2              control_pl_moveright0:
438+  BBF2 3E 02            ld a,2
439+  BBF4 32 93 BE         ld (player+2),a        ; set direction to right
440+  BBF7 C1               pop bc
441+  BBF8 C9               ret
442+  BBF9
443+  BBF9              ;
444+  BBF9              ; Player fires
445+  BBF9              ;
446+  BBF9              control_pl_fire:
447+  BBF9 3A 93 BE         ld a,(player+2)         ; get player direction
448+  BBFC FE 00            cp 0
449+  BBFE C8               ret z
450+  BBFF FE 03            cp 3
451+  BC01 C8               ret z                   ; if up or down, don't fire
452+  BC02 3A B0 CE         ld a,(bullet_state+3)       ; get the state
453+  BC05 FE 01            cp 1
454+  BC07 C8               ret z                   ; if currently firing, don't fire
455+  BC08 CD B1 CE         call bullet_init        ; initialise the bullet
456+  BC0B CD C6 CE         call bullet_shoot       ; shoot the bullet
457+  BC0E C9               ret
458+  BC0F
459+  BC0F              ;
460+  BC0F              ; Scrolls the screen down
461+  BC0F              ;
462+  BC0F              control_scroll_down:
463+  BC0F F5               push af
464+  BC10 3E 08            ld a,8
465+  BC12 32 D1 A8         ld (screen_offset),a
466+  BC15 F1               pop af
467+  BC16 21 1E A7         ld hl,buffer_updateall
468+  BC19 36 01            ld (hl),1         ; flag as screen needing update
469+  BC1B C9               ret
470+  BC1C
471+  BC1C              ;
472+  BC1C              ; Scrolls the screen up
473+  BC1C              ;
474+  BC1C              control_scroll_up:
475+  BC1C F5               push af
476+  BC1D 3E 00            ld a,0
477+  BC1F 32 D1 A8         ld (screen_offset),a
478+  BC22 F1               pop af
479+  BC23 21 1E A7         ld hl,buffer_updateall
480+  BC26 36 01            ld (hl),1         ; flag as screen needing update
481+  BC28 C9               ret
482+  BC29
483+  BC29
484+  BC29
485+  BC29
# file closed: game/control.asm
148   BC29                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  BC29              ;
  2+  BC29              ; The number of frames to dig for
  3+  BC29              ;
  4+  BC29              movement_numberdigframes:
  5+  BC29 0A               defb 10
  6+  BC2A
  7+  BC2A              ;
  8+  BC2A              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  BC2A              ; Inputs:
 10+  BC2A              ; hl - memory location of top pixel row
 11+  BC2A              ; bc - screen coords, b horiz, c vert
 12+  BC2A              ; Outputs:
 13+  BC2A              ; e - 0 if not empty, 1 if empty
 14+  BC2A              ;
 15+  BC2A              movement_spaceisempty:
 16+  BC2A C5               push bc
 17+  BC2B E5               push hl
 18+  BC2C CD 54 BC         call movement_spaceisgem        ; check if space is a gem
 19+  BC2F E1               pop hl
 20+  BC30 C1               pop bc
 21+  BC31 7B               ld a,e
 22+  BC32 FE 01            cp 1
 23+  BC34 C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  BC35 3E 08            ld a,8                          ; 8 rows to check
 25+  BC37              movement_spaceisempty0:
 26+  BC37 08               ex af,af'                       ; store the loop counter
 27+  BC38 7E               ld a,(hl)                       ; get current pixel row
 28+  BC39 FE 00            cp 0
 29+  BC3B C2 4F BC         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  BC3E 79               ld a,c                          ; load the vertical coord
 31+  BC3F 3C               inc a                           ; next row down
 32+  BC40 11 20 00         ld de,32
 33+  BC43 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  BC44 4F               ld c,a                          ; copy vert coord back to c
 35+  BC45 08               ex af,af'                       ; get loop counter back
 36+  BC46 3D               dec a                           ; decrease loop counter
 37+  BC47 C2 37 BC         jp nz, movement_spaceisempty0
 38+  BC4A 16 00            ld d,0
 39+  BC4C 1E 01            ld e,1                          ; got to end, so space is empty
 40+  BC4E C9               ret
 41+  BC4F              movement_spaceisempty1:
 42+  BC4F 16 00            ld d,0
 43+  BC51 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  BC53 C9               ret
 45+  BC54
 46+  BC54              ;
 47+  BC54              ; Check if a space contains a gem
 48+  BC54              ; Inputs:
 49+  BC54              ; bc - screen coords
 50+  BC54              ; Outputs:
 51+  BC54              ; e = 1 if gem
 52+  BC54              movement_spaceisgem:
 53+  BC54 CD 31 AA         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  BC57 21 23 B6         ld hl,level01diamonds           ; check diamonds first
 55+  BC5A              movement_spaceisgem0:
 56+  BC5A 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  BC5E 7B               ld a,e                          ; check for end of data
 58+  BC5F FE FF            cp 255
 59+  BC61 CA 7C BC         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  BC64 23               inc hl
 61+  BC65 23               inc hl                          ; move to state
 62+  BC66 7E               ld a,(hl)
 63+  BC67 23               inc hl
 64+  BC68 23               inc hl
 65+  BC69 23               inc hl                          ; get to next
 66+  BC6A FE 01            cp 1                            ; check if collected
 67+  BC6C CA 5A BC         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  BC6F 7B               ld a,e                          ; load e again
 69+  BC70 B9               cp c                            ; otherwise, compare c with e
 70+  BC71 C2 5A BC         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  BC74 7A               ld a,d                          ; get d coord
 72+  BC75 B8               cp b                            ; compare b with d
 73+  BC76 C2 5A BC         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  BC79 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  BC7B C9               ret
 76+  BC7C              movement_spaceisgem1:
 77+  BC7C 21 33 B6         ld hl,level01gems              ; check gems
 78+  BC7F              movement_spaceisgem2:
 79+  BC7F 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  BC83 7B               ld a,e                          ; check for end of data
 81+  BC84 FE FF            cp 255
 82+  BC86 CA A1 BC         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  BC89 23               inc hl
 84+  BC8A 23               inc hl                          ; move to state
 85+  BC8B 7E               ld a,(hl)
 86+  BC8C 23               inc hl
 87+  BC8D 23               inc hl
 88+  BC8E 23               inc hl                          ; get to next
 89+  BC8F FE 01            cp 1                            ; check if collected
 90+  BC91 CA 7F BC         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  BC94 7B               ld a,e                          ; load e again
 92+  BC95 B9               cp c                            ; otherwise, compare c with e
 93+  BC96 C2 7F BC         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  BC99 7A               ld a,d                          ; get d coord
 95+  BC9A B8               cp b                            ; compare b with d
 96+  BC9B C2 7F BC         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  BC9E 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  BCA0 C9               ret
 99+  BCA1              movement_spaceisgem3:
100+  BCA1 1E 00            ld e,0                          ; nothing found, return e = 0
101+  BCA3 C9               ret
102+  BCA4
103+  BCA4              ;
104+  BCA4              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  BCA4              ; Inputs:
106+  BCA4              ; hl - memory location of top pixel row
107+  BCA4              ; bc - screen coords, b horiz, c vert
108+  BCA4              ; Outputs:
109+  BCA4              ; e - 0 if not empty, 1 if empty
110+  BCA4              ;
111+  BCA4              movement_linebelowisempty:
112+  BCA4 C5               push bc
113+  BCA5 E5               push hl
114+  BCA6 CD 54 BC         call movement_spaceisgem        ; check if space is a gem
115+  BCA9 E1               pop hl
116+  BCAA C1               pop bc
117+  BCAB 7B               ld a,e
118+  BCAC FE 01            cp 1
119+  BCAE C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  BCAF 7E               ld a,(hl)                       ; get current pixel row
121+  BCB0 FE 00            cp 0
122+  BCB2 C2 BA BC         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  BCB5 16 00            ld d,0
124+  BCB7 1E 01            ld e,1                          ; got to end, so space is empty
125+  BCB9 C9               ret
126+  BCBA              movement_linebelowisempty1:
127+  BCBA 16 00            ld d,0
128+  BCBC 1E 00            ld e,0                          ; returning false, ie space not empty
129+  BCBE C9               ret
130+  BCBF
131+  BCBF              ;
132+  BCBF              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  BCBF              ; Inputs:
134+  BCBF              ; hl - memory location of top pixel row
135+  BCBF              ; bc - screen coords, b horiz, c vert
136+  BCBF              ; Outputs:
137+  BCBF              ; e - 0 if not empty, 1 if empty
138+  BCBF              ;
139+  BCBF              movement_lineaboveisempty:
140+  BCBF C5               push bc
141+  BCC0 E5               push hl
142+  BCC1 CD 54 BC         call movement_spaceisgem        ; check if space is a gem
143+  BCC4 E1               pop hl
144+  BCC5 C1               pop bc
145+  BCC6 7B               ld a,e
146+  BCC7 FE 01            cp 1
147+  BCC9 C8               ret z
148+  BCCA 7E               ld a,(hl)                       ; get current pixel row
149+  BCCB FE 00            cp 0
150+  BCCD C2 D5 BC         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  BCD0 16 00            ld d,0
152+  BCD2 1E 01            ld e,1                          ; got to end, so space is empty
153+  BCD4 C9               ret
154+  BCD5              movement_lineaboveisempty1:
155+  BCD5 16 00            ld d,0
156+  BCD7 1E 00            ld e,0                          ; returning false, ie space not empty
157+  BCD9 C9               ret
158+  BCDA
159+  BCDA              ;
160+  BCDA              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  BCDA              ; Inputs:
162+  BCDA              ; hl - memory location of top pixel row
163+  BCDA              ; bc - screen coords, b horiz, c vert
164+  BCDA              ; Outputs:
165+  BCDA              ; none - puts player into digging mode
166+  BCDA              ;
167+  BCDA              movement_spaceisdiggable:
168+  BCDA 3E 08            ld a,8                          ; 8 rows to check
169+  BCDC              movement_spaceisdiggable0:
170+  BCDC 08               ex af,af'                       ; store the loop counter
171+  BCDD 7E               ld a,(hl)                       ; get current pixel row
172+  BCDE FE 00            cp 0
173+  BCE0 CA F0 BC         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  BCE3 FE 55            cp 85
175+  BCE5 CA F0 BC         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  BCE8 FE AA            cp 170
177+  BCEA CA F0 BC         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  BCED C3 0A BD         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  BCF0              movement_spaceisdiggable2:
180+  BCF0 79               ld a,c                          ; load the vertical coord
181+  BCF1 3C               inc a                           ; next row down
182+  BCF2 11 20 00         ld de,32
183+  BCF5 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  BCF6 4F               ld c,a                          ; copy vert coord back to c
185+  BCF7 08               ex af,af'                       ; get loop counter back
186+  BCF8 3D               dec a                           ; decrease loop counter
187+  BCF9 C2 DC BC         jp nz, movement_spaceisdiggable0
188+  BCFC 21 97 BE         ld hl,player+6
189+  BCFF 36 01            ld (hl),1                       ; set the player into digging mode
190+  BD01 23               inc hl
191+  BD02 3A 29 BC         ld a,(movement_numberdigframes)
192+  BD05 77               ld (hl),a                       ; set the number of frame to dig for
193+  BD06 23               inc hl
194+  BD07 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  BD09 C9               ret
196+  BD0A              movement_spaceisdiggable1:
197+  BD0A 21 97 BE         ld hl,player+6
198+  BD0D 36 00            ld (hl),0                       ; set the player out of digging mode
199+  BD0F C9               ret
200+  BD10
201+  BD10              ;
202+  BD10              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
203+  BD10              ; Inputs:
204+  BD10              ; hl - memory location of top pixel row
205+  BD10              ; bc - screen coords, b horiz, c vert
206+  BD10              ; Outputs:
207+  BD10              ; none - puts player into digging mode
208+  BD10              ;
209+  BD10              movement_spacebelowisdiggable:
210+  BD10 7E               ld a,(hl)                       ; get first pixel row
211+  BD11 FE 55            cp 85
212+  BD13 CA 1E BD         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
213+  BD16 FE AA            cp 170
214+  BD18 CA 1E BD         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
215+  BD1B C3 0A BD         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
216+  BD1E              movement_spacebelowisdiggable3:
217+  BD1E 3E 08            ld a,8                          ; rows to check
218+  BD20 1E 00            ld e,0                          ; count of rows to dig
219+  BD22              movement_spacebelowisdiggable0:
220+  BD22 08               ex af,af'                       ; store the loop counter
221+  BD23 7E               ld a,(hl)                       ; get current pixel row
222+  BD24 FE 55            cp 85
223+  BD26 CA 31 BD         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
224+  BD29 FE AA            cp 170
225+  BD2B CA 31 BD         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
226+  BD2E C3 40 BD         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
227+  BD31              movement_spacebelowisdiggable4:
228+  BD31 1C               inc e                           ; inc count of rows to dig
229+  BD32              movement_spacebelowisdiggable2:
230+  BD32 79               ld a,c                          ; load the vertical coord
231+  BD33 3C               inc a                           ; next row down
232+  BD34 D5               push de                         ; need e for later
233+  BD35 11 20 00         ld de,32
234+  BD38 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
235+  BD39 4F               ld c,a                          ; copy vert coord back to c
236+  BD3A D1               pop de                          ; get e back
237+  BD3B 08               ex af,af'                       ; get loop counter back
238+  BD3C 3D               dec a                           ; incease loop counter
239+  BD3D C2 22 BD         jp nz, movement_spacebelowisdiggable0
240+  BD40              movement_spacebelowisdiggable5:
241+  BD40 21 97 BE         ld hl,player+6
242+  BD43 36 01            ld (hl),1                       ; set the player into digging mode
243+  BD45 23               inc hl
244+  BD46 3A 29 BC         ld a,(movement_numberdigframes)
245+  BD49 77               ld (hl),a                       ; set the number of frame to dig for
246+  BD4A 23               inc hl
247+  BD4B 73               ld (hl),e                       ; set the number of pixels to dig
248+  BD4C C9               ret
249+  BD4D              movement_spacebelowisdiggable1:
250+  BD4D 21 97 BE         ld hl,player+6
251+  BD50 36 00            ld (hl),0                       ; set the player out of digging mode
252+  BD52 C9               ret
253+  BD53
254+  BD53              ;
255+  BD53              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
256+  BD53              ; Inputs:
257+  BD53              ; hl - memory location of top pixel row
258+  BD53              ; bc - screen coords, b horiz, c vert
259+  BD53              ; Outputs:
260+  BD53              ; none - puts player into digging mode
261+  BD53              ;
262+  BD53              movement_spaceaboveisdiggable:
263+  BD53 7E               ld a,(hl)                       ; get first pixel row
264+  BD54 FE 55            cp 85
265+  BD56 CA 61 BD         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
266+  BD59 FE AA            cp 170
267+  BD5B CA 61 BD         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
268+  BD5E C3 0A BD         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
269+  BD61              movement_spaceaboveisdiggable3:
270+  BD61 3E 08            ld a,8                          ; rows to check
271+  BD63 1E 00            ld e,0                          ; count of rows to dig
272+  BD65              movement_spaceaboveisdiggable0:
273+  BD65 08               ex af,af'                       ; store the loop counter
274+  BD66 7E               ld a,(hl)                       ; get current pixel row
275+  BD67 FE 55            cp 85
276+  BD69 CA 74 BD         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
277+  BD6C FE AA            cp 170
278+  BD6E CA 74 BD         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
279+  BD71 C3 84 BD         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
280+  BD74              movement_spaceaboveisdiggable4:
281+  BD74 1C               inc e                           ; inc count of rows to dig
282+  BD75              movement_spaceaboveisdiggable2:
283+  BD75 79               ld a,c                          ; load the vertical coord
284+  BD76 3D               dec a                           ; next row up
285+  BD77 D5               push de                         ; need e for later
286+  BD78 11 20 00         ld de,32
287+  BD7B ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
288+  BD7D 4F               ld c,a                          ; copy vert coord back to c
289+  BD7E D1               pop de                          ; get e back
290+  BD7F 08               ex af,af'                       ; get loop counter back
291+  BD80 3D               dec a                           ; incease loop counter
292+  BD81 C2 65 BD         jp nz, movement_spaceaboveisdiggable0
293+  BD84              movement_spaceaboveisdiggable5:
294+  BD84 21 97 BE         ld hl,player+6
295+  BD87 36 01            ld (hl),1                       ; set the player into digging mode
296+  BD89 23               inc hl
297+  BD8A 3A 29 BC         ld a,(movement_numberdigframes)
298+  BD8D 77               ld (hl),a                       ; set the number of frame to dig for
299+  BD8E 23               inc hl
300+  BD8F 73               ld (hl),e                       ; set the number of pixels to dig
301+  BD90 C9               ret
302+  BD91              movement_spaceaboveisdiggable1:
303+  BD91 21 97 BE         ld hl,player+6
304+  BD94 36 00            ld (hl),0                       ; set the player out of digging mode
305+  BD96 C9               ret
306+  BD97
307+  BD97              ;
308+  BD97              ; Checks if the player can move down
309+  BD97              ; Inputs:
310+  BD97              ; bc - player coords, b horiz, c vert
311+  BD97              ; Outputs:
312+  BD97              ; de - 1 can move
313+  BD97              movement_checkcanmove_down:
314+  BD97 F5               push af
315+  BD98 C5               push bc
316+  BD99 CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
317+  BD9C 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
318+  BD9E 24               inc h                       ; memory location of cell beneath now in hl
319+  BD9F 3E 08            ld a,8                       ; look below
320+  BDA1 81               add c
321+  BDA2 4F               ld c,a
322+  BDA3 CD A4 BC         call movement_linebelowisempty       ; check space is empty
323+  BDA6 7B               ld a,e                          ; check space empty flag
324+  BDA7 FE 00            cp 0
325+  BDA9 CA B2 BD         jp z, movement_checkcanmove_down1 ; can't move
326+  BDAC CD 9C C0         call player_justmoved
327+  BDAF C1               pop bc
328+  BDB0 F1               pop af
329+  BDB1 C9               ret
330+  BDB2              movement_checkcanmove_down1:
331+  BDB2 C1               pop bc
332+  BDB3 CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
333+  BDB6 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
334+  BDB8 24               inc h
335+  BDB9 C5               push bc
336+  BDBA CD 10 BD         call movement_spacebelowisdiggable    ; can't move here, but can we dig
337+  BDBD 11 00 00         ld de,0
338+  BDC0 C1               pop bc
339+  BDC1 F1               pop af
340+  BDC2 C9               ret
341+  BDC3
342+  BDC3              ;
343+  BDC3              ; Checks if the player can move up
344+  BDC3              ; Inputs:
345+  BDC3              ; bc - player coords, b horiz, c vert
346+  BDC3              ; Outputs:
347+  BDC3              ; de - 1 can move
348+  BDC3              movement_checkcanmove_up:
349+  BDC3 F5               push af
350+  BDC4 C5               push bc
351+  BDC5 CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
352+  BDC8 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
353+  BDCA 11 20 00         ld de,32
354+  BDCD ED 52            sbc hl,de                       ; memory location of line above now in hl
355+  BDCF 0D               dec c                           ; look above
356+  BDD0 CD BF BC         call movement_lineaboveisempty       ; check space is empty
357+  BDD3 7B               ld a,e                          ; check space empty flag
358+  BDD4 FE 00            cp 0
359+  BDD6 CA E1 BD         jp z, movement_checkcanmove_up1 ; can't move
360+  BDD9 1E 01            ld e,1
361+  BDDB CD 9C C0         call player_justmoved
362+  BDDE C1               pop bc
363+  BDDF F1               pop af
364+  BDE0 C9               ret
365+  BDE1              movement_checkcanmove_up1:
366+  BDE1 C1               pop bc
367+  BDE2 CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
368+  BDE5 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
369+  BDE7 11 20 00         ld de,32
370+  BDEA ED 52            sbc hl,de                       ; memory location of line above now in hl
371+  BDEC C5               push bc
372+  BDED CD 53 BD         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
373+  BDF0 11 00 00         ld de,0
374+  BDF3 C1               pop bc
375+  BDF4 F1               pop af
376+  BDF5 C9               ret
377+  BDF6
378+  BDF6              ;
379+  BDF6              ; Checks if the player can move right
380+  BDF6              ; Inputs:
381+  BDF6              ; bc - player coords, b horiz, c vert
382+  BDF6              ; Outputs:
383+  BDF6              ; de - 1 can move
384+  BDF6              movement_checkcanmove_right:
385+  BDF6 F5               push af
386+  BDF7 C5               push bc
387+  BDF8 CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
388+  BDFB 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
389+  BDFD 3E 08            ld a,8
390+  BDFF 80               add b                           ; move one cell right
391+  BE00 47               ld b,a
392+  BE01 23               inc hl                          ; memory location of cell to the right now in hl
393+  BE02 CD 2A BC         call movement_spaceisempty       ; check space is empty
394+  BE05 7B               ld a,e                          ; check space empty flag
395+  BE06 FE 00            cp 0
396+  BE08 CA 11 BE         jp z, movement_checkcanmove_right1 ; can't move
397+  BE0B CD 9C C0         call player_justmoved
398+  BE0E C1               pop bc
399+  BE0F F1               pop af
400+  BE10 C9               ret
401+  BE11              movement_checkcanmove_right1:
402+  BE11 C1               pop bc
403+  BE12 CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
404+  BE15 62 6B            ld hl,de
405+  BE17 23               inc hl                          ; memory location of cell to the right now in hl
406+  BE18 C5               push bc
407+  BE19 CD DA BC         call movement_spaceisdiggable    ; can't move here, but can we dig
408+  BE1C 11 00 00         ld de,0
409+  BE1F C1               pop bc
410+  BE20 F1               pop af
411+  BE21 C9               ret
412+  BE22
413+  BE22              ;
414+  BE22              ; Checks if the player can move left
415+  BE22              ; Inputs:
416+  BE22              ; bc - player coords, b horiz, c vert
417+  BE22              ; Outputs:
418+  BE22              ; de - 1 can move
419+  BE22              movement_checkcanmove_left:
420+  BE22 F5               push af
421+  BE23 C5               push bc
422+  BE24 CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
423+  BE27 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
424+  BE29 78               ld a,b
425+  BE2A 06 08            ld b,8
426+  BE2C 90               sub b                           ; move one cell left
427+  BE2D 47               ld b,a
428+  BE2E 2B               dec hl                          ; memory location of cell to the right now in hl
429+  BE2F CD 2A BC         call movement_spaceisempty       ; check space is empty
430+  BE32 7B               ld a,e                          ; check space empty flag
431+  BE33 FE 00            cp 0
432+  BE35 CA 3E BE         jp z, movement_checkcanmove_left1 ; can't move
433+  BE38 CD 9C C0         call player_justmoved
434+  BE3B C1               pop bc
435+  BE3C F1               pop af
436+  BE3D C9               ret
437+  BE3E              movement_checkcanmove_left1:
438+  BE3E C1               pop bc
439+  BE3F CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
440+  BE42 62 6B            ld hl,de
441+  BE44 2B               dec hl                          ; memory location of cell to the right now in hl
442+  BE45 C5               push bc
443+  BE46 CD DA BC         call movement_spaceisdiggable    ; can't move here, but can we dig
444+  BE49 11 00 00         ld de,0
445+  BE4C C1               pop bc
446+  BE4D F1               pop af
447+  BE4E C9               ret
# file closed: game/movement.asm
149   BE4F                  include "game\game.asm"
# file opened: game/game.asm
  1+  BE4F              ;
  2+  BE4F              ; The current frame count, incremented each frame
  3+  BE4F              ;
  4+  BE4F              game_framenumber:
  5+  BE4F 00               defb    0
  6+  BE50
  7+  BE50              ;
  8+  BE50              ; The number of players
  9+  BE50              ;
 10+  BE50              game_numberplayers:
 11+  BE50 01               defb 1
 12+  BE51
 13+  BE51              ;
 14+  BE51              ; The current player
 15+  BE51              ;
 16+  BE51              game_currentplayer:
 17+  BE51 01               defb 1
 18+  BE52
 19+  BE52              ;
 20+  BE52              ; The default number of lives
 21+  BE52              ;
 22+  BE52              game_numberlives:
 23+  BE52 04               defb 4
 24+  BE53
 25+  BE53              ;
 26+  BE53              ; The current difficulty
 27+  BE53              ;
 28+  BE53              game_difficulty:
 29+  BE53 00               defb 0
 30+  BE54
 31+  BE54              ;
 32+  BE54              ; Control method: 0 for keyboard, 1 for kempston
 33+  BE54              ;
 34+  BE54              game_control:
 35+  BE54 00               defb 0
 36+  BE55
 37+  BE55              ;
 38+  BE55              ; Moves to the next player
 39+  BE55              ;
 40+  BE55              game_changeplayer:
 41+  BE55 3A 50 BE         ld a,(game_numberplayers)
 42+  BE58 FE 01            cp 1
 43+  BE5A C8               ret z                       ; if just one player, no need to change
 44+  BE5B 3A 51 BE         ld a,(game_currentplayer)   ; get current player
 45+  BE5E 3D               dec a                       ; otherwise decrease by one
 46+  BE5F EE 01            xor 1                       ; xor with one to flip
 47+  BE61 3C               inc a                       ; increment
 48+  BE62 21 51 BE         ld hl,game_currentplayer
 49+  BE65 77               ld (hl),a                   ; store
 50+  BE66 C9               ret
 51+  BE67
 52+  BE67              ;
 53+  BE67              ; Sets the number of players at the start of the game
 54+  BE67              ; Inputs:
 55+  BE67              ; a - number of players
 56+  BE67              game_setnumberofplayers:
 57+  BE67 21 50 BE         ld hl,game_numberplayers
 58+  BE6A 77               ld (hl),a
 59+  BE6B
 60+  BE6B              ;
 61+  BE6B              ; Starts a game
 62+  BE6B              ;
 63+  BE6B              game_init:
 64+  BE6B 3E 01            ld a,1
 65+  BE6D 32 51 BE         ld (game_currentplayer),a
 66+  BE70 C9               ret
 67+  BE71
 68+  BE71
 69+  BE71              ;
 70+  BE71              ; Increment frame number by 1
 71+  BE71              ;
 72+  BE71              game_incrementframe:
 73+  BE71 3A 4F BE         ld a,(game_framenumber)
 74+  BE74 FE FF            cp 255
 75+  BE76 C2 7B BE         jp nz,game_incrementframe0
 76+  BE79 3E 00            ld a,0
 77+  BE7B              game_incrementframe0:
 78+  BE7B 3C               inc a
 79+  BE7C 32 4F BE         ld (game_framenumber),a
 80+  BE7F C9               ret
 81+  BE80
 82+  BE80              ;
 83+  BE80              ; Returns current frame
 84+  BE80              ; Outputs:
 85+  BE80              ; a - current frame
 86+  BE80              ;
 87+  BE80              game_getcurrentframe:
 88+  BE80 3A 4F BE         ld a,(game_framenumber)
 89+  BE83 C9               ret
 90+  BE84
 91+  BE84              ;
 92+  BE84              ; Resets current frame
 93+  BE84              ;
 94+  BE84              game_resetcurrentframe:
 95+  BE84 21 4F BE         ld hl,game_framenumber
 96+  BE87 36 00            ld (hl),0
 97+  BE89 C9               ret
 98+  BE8A
 99+  BE8A              ;
100+  BE8A              ; Increases the current difficulty
101+  BE8A              ;
102+  BE8A              game_increasedifficulty:
103+  BE8A 3A 53 BE         ld a,(game_difficulty)
104+  BE8D 3C               inc a
105+  BE8E 32 53 BE         ld (game_difficulty),a
# file closed: game/game.asm
150   BE91                  include "game\player.asm"
# file opened: game/player.asm
  1+  BE91              ;
  2+  BE91              ;   Data for current player
  3+  BE91              ;
  4+  BE91              player:
  5+  BE91 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  BE93 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  BE96 00               defb    0                   ; auto move remaining (+5)
  8+  BE97 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  BE9A 00               defb    0                   ; lives remaining (+9)
 10+  BE9B 00               defb    0                   ; died this life (+10)
 11+  BE9C 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  BE9E 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  BE9F 00               defb    0                   ; difficulty (+14)
 14+  BEA0
 15+  BEA0              player_location:
 16+  BEA0 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 17+  BEA1
 18+  BEA1              ;
 19+  BEA1              ; Works out which part of the screen the player is in
 20+  BEA1              ; Pit is between 3,9 and 8,9
 21+  BEA1              ; Diamond cavern is between 11,22 and 22,28
 22+  BEA1              ;
 23+  BEA1              player_getlocation:
 24+  BEA1 ED 4B 91 BE      ld bc,(player)              ; get screen coords
 25+  BEA5 CD 31 AA         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 26+  BEA8 78               ld a,b                      ; check for pit first
 27+  BEA9 FE 09            cp 9                        ; if not on this row, not in the pit
 28+  BEAB C2 BA BE         jp nz,player_getlocation0
 29+  BEAE 79               ld a,c                      ; check horizontal
 30+  BEAF FE 09            cp 9
 31+  BEB1 D2 BA BE         jp nc, player_getlocation0  ; if more than 9, not in the pit
 32+  BEB4 21 A0 BE         ld hl,player_location
 33+  BEB7 36 02            ld (hl),2                   ; load location with 2, the pit
 34+  BEB9 C9               ret                         ; done
 35+  BEBA              player_getlocation0:            ; check for diamond cavern
 36+  BEBA 78               ld a,b                      ; first check vertical
 37+  BEBB FE 16            cp 22                       ; if above row 22, then not in cavern
 38+  BEBD DA D1 BE         jp c,player_getlocation1
 39+  BEC0 79               ld a,c                      ; get the horizontal next
 40+  BEC1 FE 0B            cp 11
 41+  BEC3 DA D1 BE         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 42+  BEC6 FE 16            cp 22
 43+  BEC8 D2 D1 BE         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 44+  BECB 21 A0 BE         ld hl,player_location
 45+  BECE 36 01            ld (hl),1                   ; load location with 1, the cavern
 46+  BED0 C9               ret
 47+  BED1              player_getlocation1:
 48+  BED1 21 A0 BE         ld hl,player_location
 49+  BED4 36 00            ld (hl),0                   ; load location with 2, the pit
 50+  BED6 C9               ret                         ; done
 51+  BED7
 52+  BED7
 53+  BED7              ;
 54+  BED7              ; Initializes a player at start of game
 55+  BED7              ; Copy initial coords, copy lives, copy score
 56+  BED7              ;
 57+  BED7              player_init_gamestart:
 58+  BED7 3A 52 BE         ld a,(game_numberlives)
 59+  BEDA 32 98 BF         ld (player1_lives),a
 60+  BEDD 32 99 BF         ld (player2_lives),a                        ; set the initial number of lives at game start
 61+  BEE0
 62+  BEE0 21 9C BF         ld hl,player1_score+2
 63+  BEE3 06 06            ld b,6
 64+  BEE5              player_init_gamestart0:
 65+  BEE5 36 30            ld (hl),48
 66+  BEE7 23               inc hl
 67+  BEE8 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 68+  BEEA 21 A5 BF         ld hl,player2_score+2
 69+  BEED 06 06            ld b,6
 70+  BEEF              player_init_gamestart1:
 71+  BEEF 36 30            ld (hl),48
 72+  BEF1 23               inc hl
 73+  BEF2 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 74+  BEF4 3E 00            ld a,0
 75+  BEF6 32 AC BF         ld (player1_difficulty),a
 76+  BEF9 32 AD BF         ld (player2_difficulty),a                   ; set player difficulties to zero
 77+  BEFC C9               ret
 78+  BEFD
 79+  BEFD              ;
 80+  BEFD              ; Initializes a player at start of a life
 81+  BEFD              ; Copy initial coords, copy lives, copy score
 82+  BEFD              ;
 83+  BEFD              player_init_lifestart:
 84+  BEFD 21 96 BE         ld hl,player+5
 85+  BF00 06 09            ld b,9                      ; initialise 9 properties
 86+  BF02              player_init_lifestart2:
 87+  BF02 36 00            ld (hl),0
 88+  BF04 23               inc hl
 89+  BF05 10 FB            djnz player_init_lifestart2
 90+  BF07
 91+  BF07 21 93 BE         ld hl,player+2              ; initialise some properties
 92+  BF0A 36 02            ld (hl),2
 93+  BF0C 23               inc hl
 94+  BF0D 36 00            ld (hl),0
 95+  BF0F 23               inc hl
 96+  BF10 36 01            ld (hl),1
 97+  BF12
 98+  BF12 ED 4B DF 80      ld bc,(init_coord)
 99+  BF16 ED 43 91 BE      ld (player),bc
100+  BF1A
101+  BF1A 3A 51 BE         ld a,(game_currentplayer)
102+  BF1D FE 01            cp 1
103+  BF1F C2 2C BF         jp nz,player_init_lifestart4
104+  BF22 01 9A BE         ld bc,player+9
105+  BF25 3A 98 BF         ld a,(player1_lives)
106+  BF28 02               ld (bc),a
107+  BF29 C3 33 BF         jp player_init_lifestart3
108+  BF2C              player_init_lifestart4:
109+  BF2C 01 9A BE         ld bc,player+9
110+  BF2F 3A 99 BF         ld a,(player2_lives)
111+  BF32 02               ld (bc),a
112+  BF33              player_init_lifestart3:
113+  BF33
114+  BF33 CD C6 C7         call diamonds_init      ; initialise gems
115+  BF36
116+  BF36 01 06 00         ld bc,6
117+  BF39 11 72 C5         ld de,scores_current+2
118+  BF3C 3A 51 BE         ld a,(game_currentplayer)
119+  BF3F FE 01            cp 1
120+  BF41 C2 50 BF         jp nz,player_init_lifestart0
121+  BF44 3A AC BF         ld a,(player1_difficulty)       ; initialise player 1 difficulty
122+  BF47 32 53 BE         ld (game_difficulty),a
123+  BF4A 21 9C BF         ld hl,player1_score+2           ; itialise player 1 scores
124+  BF4D C3 59 BF         jp player_init_lifestart1
125+  BF50              player_init_lifestart0:
126+  BF50 3A AD BF         ld a,(player2_difficulty)       ; initialise player 2 difficulty
127+  BF53 32 53 BE         ld (game_difficulty),a
128+  BF56 21 A5 BF         ld hl,player2_score+2           ; initialise player 2 scores
129+  BF59              player_init_lifestart1:
130+  BF59 ED B0            ldir
131+  BF5B C9               ret
132+  BF5C
133+  BF5C
134+  BF5C              ;
135+  BF5C              ; Copies the current score and difficulty in the current player
136+  BF5C              ;
137+  BF5C              player_recordcurrentstate:
138+  BF5C 01 06 00         ld bc,6                  ; copy current score back to correct player
139+  BF5F 21 72 C5         ld hl,scores_current+2
140+  BF62 3A 51 BE         ld a,(game_currentplayer)
141+  BF65 FE 01            cp 1
142+  BF67 C2 7C BF         jp nz,player_recordcurrentstate0
143+  BF6A 3A 53 BE         ld a,(game_difficulty)
144+  BF6D 32 AC BF         ld (player1_difficulty),a       ; store difficulty
145+  BF70 11 9C BF         ld de,player1_score+2
146+  BF73 3A 9A BE         ld a,(player+9)
147+  BF76 32 98 BF         ld (player1_lives),a              ; record lives
148+  BF79 C3 8B BF         jp player_recordcurrentstate1
149+  BF7C              player_recordcurrentstate0:         ; do player 2
150+  BF7C 3A 53 BE         ld a,(game_difficulty)
151+  BF7F 32 AD BF         ld (player2_difficulty),a       ; store difficulty
152+  BF82 3A 9A BE         ld a,(player+9)
153+  BF85 32 99 BF         ld (player2_lives),a              ; record lives
154+  BF88 11 A5 BF         ld de,player2_score+2
155+  BF8B              player_recordcurrentstate1:
156+  BF8B ED B0            ldir
157+  BF8D C9               ret
158+  BF8E
159+  BF8E              ;
160+  BF8E              ; Player just died, subtract a life
161+  BF8E              ;
162+  BF8E              player_died:
163+  BF8E 01 9A BE         ld bc,player+9
164+  BF91 0A               ld a,(bc)
165+  BF92 3D               dec a
166+  BF93 02               ld (bc),a
167+  BF94 CD 5C BF         call player_recordcurrentstate
168+  BF97 C9               ret
169+  BF98
170+  BF98              ;
171+  BF98              ; Player lives
172+  BF98              ;
173+  BF98              player1_lives:
174+  BF98 03               defb 3
175+  BF99              player2_lives:
176+  BF99 03               defb 3
177+  BF9A
178+  BF9A              ;
179+  BF9A              ; Player scores
180+  BF9A              ;
181+  BF9A              player1_score:
182+  BF9A 04 01 30 30      defb 4,1,'000000',255
182+  BF9E 30 30 30 30
182+  BFA2 FF
183+  BFA3              player2_score:
184+  BFA3 16 01 30 30      defb 22,1,'000000',255
184+  BFA7 30 30 30 30
184+  BFAB FF
185+  BFAC
186+  BFAC              ;
187+  BFAC              ; Player difficulties
188+  BFAC              ;
189+  BFAC              player1_difficulty:
190+  BFAC 00               defb 0
191+  BFAD              player2_difficulty:
192+  BFAD 00               defb 0
193+  BFAE
194+  BFAE              ;
195+  BFAE              ; Kills a player this life
196+  BFAE              ;
197+  BFAE              player_killplayer:
198+  BFAE 21 9B BE         ld hl,player+10
199+  BFB1 36 01            ld (hl),1
200+  BFB3 C9               ret
201+  BFB4
202+  BFB4              ;
203+  BFB4              ; Crush a player this life
204+  BFB4              ;
205+  BFB4              player_crushplayer:
206+  BFB4 21 9C BE         ld hl,player+11             ; mark as crushed
207+  BFB7 36 01            ld (hl),1
208+  BFB9 C9               ret
209+  BFBA
210+  BFBA              player_tankkillplayer
211+  BFBA 21 9C BE         ld hl,player+11             ; mark as tanked
212+  BFBD 36 02            ld (hl),2
213+  BFBF C9               ret
214+  BFC0
215+  BFC0              player_zonkplayer
216+  BFC0 21 9C BE         ld hl,player+11             ; mark as zonked (missile)
217+  BFC3 36 03            ld (hl),3
218+  BFC5 C9               ret
219+  BFC6
220+  BFC6              player_pitkillplayer
221+  BFC6 21 9C BE         ld hl,player+11             ; mark as pit killed
222+  BFC9 36 04            ld (hl),4
223+  BFCB C9               ret
224+  BFCC
225+  BFCC              player_robotkillplayer
226+  BFCC 21 9C BE         ld hl,player+11             ; mark as robot killed
227+  BFCF 36 05            ld (hl),5
228+  BFD1 C9               ret
229+  BFD2
230+  BFD2              ;
231+  BFD2              ; Draws the player at the current position or deletes them
232+  BFD2              ;
233+  BFD2              player_drawplayer:
234+  BFD2 3A 93 BE         ld a,(player+2)             ; get the current direction
235+  BFD5 FE 03            cp 3
236+  BFD7 C2 DC BF         jp nz,player_drawplayer0
237+  BFDA 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
238+  BFDC              player_drawplayer0:             ; DYING CHECKS
239+  BFDC 5F               ld e,a                      ; store in e
240+  BFDD 3A 9C BE         ld a,(player+11)             ; get the dying flag
241+  BFE0 FE 01            cp 1
242+  BFE2 CA 1C C0         jp z,player_drawplayer3     ; if it's one, we're being crushed
243+  BFE5 FE 04            cp 4
244+  BFE7 CA 64 C0         jp z,player_drawplayer9     ; player is falling into the pit
245+  BFEA FE 05            cp 5
246+  BFEC CA 80 C0         jp z,player_drawplayer12    ; player has been killed by a robot
247+  BFEF              player_drawplayer4:             ; CHECK FOR DIGGING
248+  BFEF 3A 97 BE         ld a,(player+6)             ; get the dig flag
249+  BFF2 FE 01            cp 1
250+  BFF4 CA 05 C0         jp z,player_drawplayer1    ; get dig frame
251+  BFF7 3A 94 BE         ld a,(player+3)             ; this is normal movement so get the current frame
252+  BFFA 83               add a,e
253+  BFFB C3 0A C0         jp player_drawplayer2
254+  BFFE              player_drawplayer6:             ; GETTING THE DIG FRAM
255+  BFFE E6 01            and 1                       ; check for odd
256+  C000 C6 0A            add 10                      ; add 10, to get either 10 or 11
257+  C002 C3 0A C0         jp player_drawplayer2
258+  C005              player_drawplayer1:             ; GET THE NORMAL FRAME
259+  C005 3A 93 BE         ld a,(player+2)             ; digging, get the current direction again, because want all four
260+  C008 C6 06            add a,6                     ; add direction to 6 to get frame
261+  C00A              player_drawplayer2:             ; WORK OUT THE FRAME
262+  C00A 07               rlca
263+  C00B 07               rlca
264+  C00C 07               rlca                        ; multiply by eight
265+  C00D 6F               ld l,a
266+  C00E 26 00            ld h,0
267+  C010 11 A4 B7         ld de,player_sprite
268+  C013 19               add hl,de                   ; load hl with the location of the player sprite data
269+  C014              player_drawplayer7:             ; DRAW THE PlAYER
270+  C014 ED 4B 91 BE      ld bc,(player)              ; load bc with the start coords
271+  C018 CD 03 AB         call sprites_drawsprite     ; call the routine to draw the sprite
272+  C01B                  ;call player_storeupdatedlines ; log updated rows
273+  C01B C9               ret
274+  C01C              ;
275+  C01C              ; CRUSHING
276+  C01C              ;
277+  C01C              player_drawplayer3:
278+  C01C 21 9D BE         ld hl,player+12
279+  C01F 7E               ld a,(hl)                  ; crushing, so get the current anim flag
280+  C020 FE 00            cp 0
281+  C022 C2 2B C0         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
282+  C025 3E 64            ld a,100
283+  C027 77               ld (hl),a                   ; otherwise, load up the anim frames
284+  C028 C3 EF BF         jp player_drawplayer4       ; and return to the main loop to remove the current frame
285+  C02B              player_drawplayer5:
286+  C02B 3D               dec a
287+  C02C 77               ld (hl),a
288+  C02D FE 00            cp 0
289+  C02F CC AE BF         call z,player_killplayer     ; final animation, so kill the player
290+  C032 FE 0A            cp 10                         ; play the sound
291+  C034 CC D9 B0         call z, sound_rockfell
292+  C037 FE 14            cp 20                        ; check if we should move the rock
293+  C039 C2 4D C0         jp nz,player_drawplayer8
294+  C03C D9               exx
295+  C03D F5               push af
296+  C03E ED 4B 10 C4      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
297+  C042 21 F0 B6         ld hl,sprites+72
298+  C045 CD 03 AB         call sprites_drawsprite     ; draw a rock over current
299+  C048 F1               pop af
300+  C049 D9               exx
301+  C04A C3 FE BF         jp player_drawplayer6       ; continue drawing player
302+  C04D              player_drawplayer8:
303+  C04D FE 14            cp 20
304+  C04F D2 FE BF         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
305+  C052 ED 4B 91 BE      ld bc,(player)
306+  C056 CD 31 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
307+  C059 3E 42            ld a,66             ; load red
308+  C05B CD 89 AA         call screen_setattr
309+  C05E 21 F0 B6         ld hl,sprites+72            ; otherwise, player is rock
310+  C061 C3 14 C0         jp player_drawplayer7
311+  C064              ;
312+  C064              ; FALLING
313+  C064              ;
314+  C064              player_drawplayer9:             ; player is falling into the pit
315+  C064 21 9D BE         ld hl,player+12
316+  C067 7E               ld a,(hl)                   ; get the frames
317+  C068 FE 00            cp 0
318+  C06A C2 73 C0         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
319+  C06D 3E 50            ld a,80
320+  C06F 77               ld (hl),a                   ; otherwise, load up the anim frames
321+  C070 C3 EF BF         jp player_drawplayer4       ; and return to the main loop to remove the current frame
322+  C073              player_drawplayer10:
323+  C073 3D               dec a
324+  C074 77               ld (hl),a
325+  C075 FE 00            cp 0
326+  C077 CC AE BF         call z,player_killplayer     ; final frame, so kill the player
327+  C07A 3A 94 BE         ld a,(player+3)
328+  C07D C3 0A C0         jp player_drawplayer2
329+  C080              ;
330+  C080              ; ROBOT KILLED
331+  C080              ;
332+  C080              player_drawplayer12:
333+  C080 21 9D BE         ld hl,player+12
334+  C083 7E               ld a,(hl)                   ; get the frames
335+  C084 FE 00            cp 0
336+  C086 C2 8F C0         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
337+  C089 3E C8            ld a,200
338+  C08B 77               ld (hl),a                   ; otherwise, load up the anim frames
339+  C08C C3 EF BF         jp player_drawplayer4       ; and return to the main loop to remove the current frame
340+  C08F              player_drawplayer13:
341+  C08F 3D               dec a
342+  C090 77               ld (hl),a
343+  C091 FE 00            cp 0
344+  C093 CC AE BF         call z,player_killplayer     ; final frame, so kill the player
345+  C096 3A 94 BE         ld a,(player+3)
346+  C099 C3 0A C0         jp player_drawplayer2
347+  C09C
348+  C09C              ;
349+  C09C              ; Runs after the player just moved. Changes animation frame if required
350+  C09C              ;
351+  C09C              player_justmoved:
352+  C09C D9               exx
353+  C09D 3A 95 BE         ld a,(player+4)             ; get the transition count
354+  C0A0 FE 00            cp 0
355+  C0A2 CA A8 C0         jp z, player_justmoved2     ; if zero reset and change the frame
356+  C0A5 C3 C2 C0         jp player_justmoved1       ; otherwise decrease and continue
357+  C0A8              player_justmoved2:
358+  C0A8                  ; reset and change frame in here
359+  C0A8 3E 01            ld a,1
360+  C0AA 32 95 BE         ld (player+4),a            ; reset back to whatever
361+  C0AD 3A 94 BE         ld a,(player+3)             ; load the frame
362+  C0B0 FE 03            cp 3                       ; flip between 3 and 0
363+  C0B2 C2 BA C0         jp nz, player_justmoved4
364+  C0B5 3E 00            ld a,0
365+  C0B7 C3 BC C0         jp player_justmoved5
366+  C0BA              player_justmoved4:
367+  C0BA 3E 03            ld a,3
368+  C0BC              player_justmoved5:
369+  C0BC 32 94 BE         ld (player+3),a           ; save back
370+  C0BF C3 C6 C0         jp player_justmoved3
371+  C0C2              player_justmoved1:
372+  C0C2                  ; decrease count
373+  C0C2 3D               dec a
374+  C0C3 32 95 BE         ld (player+4),a
375+  C0C6              player_justmoved3:
376+  C0C6 D9               exx;
377+  C0C7 C9               ret
378+  C0C8
379+  C0C8              ;
380+  C0C8              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
381+  C0C8              ; Outputs:
382+  C0C8              ; a - 1 for completed level
383+  C0C8              player_checkforexit:
384+  C0C8 ED 4B 91 BE      ld bc,(player)                 ; get player coords
385+  C0CC ED 5B DF 80      ld de,(init_coord)             ; get start coords
386+  C0D0 78               ld a,b
387+  C0D1 BA               cp d                         ; compare horiz
388+  C0D2 C2 DD C0         jp nz,player_checkforexit1
389+  C0D5 79               ld a,c
390+  C0D6 BB               cp e                        ; compare vert
391+  C0D7 C2 DD C0         jp nz,player_checkforexit1
392+  C0DA              player_checkforexit0:
393+  C0DA 3E 01            ld a,1                       ; hasn't completed
394+  C0DC C9               ret
395+  C0DD              player_checkforexit1:
396+  C0DD 3E 00            ld a,0                       ; has completed
397+  C0DF C9               ret
# file closed: game/player.asm
151   C0E0                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  C0E0              ;
  2+  C0E0              ; Ship initial position: vert,horiz
  3+  C0E0              ;
  4+  C0E0              ship_initpos:
  5+  C0E0 00 24            defb 0,36
  6+  C0E2              ship_initpos2:
  7+  C0E2 00 00            defb 0,0
  8+  C0E4              ship_frame:
  9+  C0E4 00               defb 0
 10+  C0E5              ;
 11+  C0E5              ; The current memory location
 12+  C0E5              ;
 13+  C0E5              ship_current_sprite:
 14+  C0E5 00 00            defb 0,0
 15+  C0E7
 16+  C0E7              ship_current_coords:
 17+  C0E7 00 00            defb 0,0
 18+  C0E9
 19+  C0E9              ship_process:
 20+  C0E9 3A 9C BE         ld a,(player+11)
 21+  C0EC FE 02            cp 2                        ; has the player been killed by tank?
 22+  C0EE C0               ret nz                      ; do nothing if not
 23+  C0EF CD 1C BC         call control_scroll_up           ; make sure the screen is on the top screen
 24+  C0F2 CD 61 C1         call ship_takeoff           ; bye bye
 25+  C0F5 CD AE BF         call player_killplayer      ; killed
 26+  C0F8 06 32            ld b,50
 27+  C0FA CD 58 81         call utilities_pauseforframes
 28+  C0FD C9               ret
 29+  C0FE
 30+  C0FE              ;
 31+  C0FE              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  C0FE              ;
 33+  C0FE              ship_land:
 34+  C0FE ED 4B E0 C0      ld bc,(ship_initpos)
 35+  C102 ED 43 E2 C0      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  C106 1E 00            ld e,0                      ; store a flag to track first time round
 37+  C108 06 09            ld b,9                      ; move down 8 pixels
 38+  C10A              ship_land0:
 39+  C10A C5               push bc
 40+  C10B 7B               ld a,e
 41+  C10C D5               push de                     ; store de for next time round
 42+  C10D FE 01            cp 1                        ; check first time flag
 43+  C10F C2 24 C1         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  C112 CD A9 C1         call ship_draw_full         ; delete old one
 45+  C115 CD 8D C1         call ship_change_frame      ; increment the frame
 46+  C118 ED 4B E2 C0      ld bc,(ship_initpos2)       ; get the current coords
 47+  C11C 81 C6 01         add c,1                     ; move down one pixels
 48+  C11F 4F               ld c,a
 49+  C120 ED 43 E2 C0      ld (ship_initpos2),bc
 50+  C124              ship_land1:
 51+  C124 CD A9 C1         call ship_draw_full         ; draw the ship
 52+  C127 CD A2 C1         call ship_draw_screen
 53+  C12A D1               pop de
 54+  C12B 1E 01            ld e,1
 55+  C12D C1               pop bc
 56+  C12E 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  C130                  ; done moving down
 58+  C130                  ; now move across
 59+  C130 CD D2 BF         call player_drawplayer      ; draw player
 60+  C133 CD A9 C1         call ship_draw_full         ; delete old one
 61+  C136 1E 00            ld e,0                      ; store a flag to track first time round
 62+  C138 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  C13A              ship_land3:
 64+  C13A C5               push bc
 65+  C13B 7B               ld a,e
 66+  C13C D5               push de                     ; store de for next time round
 67+  C13D FE 01            cp 1                        ; check first time flag
 68+  C13F C2 54 C1         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  C142 CD A9 C1         call ship_draw_full         ; delete old one
 70+  C145 CD 8D C1         call ship_change_frame      ; increment the frame
 71+  C148 ED 4B E2 C0      ld bc,(ship_initpos2)       ; get the current coords
 72+  C14C 78               ld a,b
 73+  C14D D6 01            sub 1                       ; move back one pixels
 74+  C14F 47               ld b,a
 75+  C150 ED 43 E2 C0      ld (ship_initpos2),bc
 76+  C154              ship_land2:
 77+  C154 CD A9 C1         call ship_draw_full         ; draw the ship
 78+  C157 CD A2 C1         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  C15A D1               pop de
 80+  C15B 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  C15D C1               pop bc
 82+  C15E 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  C160 C9               ret
 84+  C161
 85+  C161              ;
 86+  C161              ;   Take off the ship
 87+  C161              ;
 88+  C161              ship_takeoff:
 89+  C161 1E 01            ld e,1                      ; store a flag to track first time round
 90+  C163 06 08            ld b,8                      ; move up 8 pixels
 91+  C165              ship_takeoff0:
 92+  C165 C5               push bc
 93+  C166 7B               ld a,e
 94+  C167 D5               push de                     ; store de for next time round
 95+  C168 FE 01            cp 1                        ; check first time flag
 96+  C16A C2 80 C1         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  C16D ED 4B E2 C0      ld bc,(ship_initpos2)       ; get the current coords
 98+  C171 CD A9 C1         call ship_draw_full         ; delete old one
 99+  C174 CD 8D C1         call ship_change_frame      ; increment the frame
100+  C177 ED 4B E2 C0      ld bc,(ship_initpos2)       ; get the current coords
101+  C17B 0D               dec c                       ; move up one pixels
102+  C17C ED 43 E2 C0      ld (ship_initpos2),bc
103+  C180              ship_takeoff1:
104+  C180 CD A9 C1         call ship_draw_full         ; draw the ship
105+  C183 CD A2 C1         call ship_draw_screen
106+  C186 D1               pop de
107+  C187 1E 01            ld e,1
108+  C189 C1               pop bc
109+  C18A 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  C18C                  ; done moving up
111+  C18C C9               ret
112+  C18D
113+  C18D              ;
114+  C18D              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  C18D              ;
116+  C18D              ship_change_frame:
117+  C18D F5               push af
118+  C18E 3A E4 C0         ld a,(ship_frame)
119+  C191 FE 00            cp 0
120+  C193 CA 9B C1         jp z,ship_change_frame0
121+  C196 3E 00            ld a,0                      ; flip to 0
122+  C198 C3 9D C1         jp ship_change_frame1
123+  C19B              ship_change_frame0:
124+  C19B 3E 20            ld a,32                      ; flip to 32
125+  C19D              ship_change_frame1:
126+  C19D 32 E4 C0         ld (ship_frame),a            ; save the frame
127+  C1A0 F1               pop af
128+  C1A1 C9               ret
129+  C1A2
130+  C1A2              ship_draw_screen:
131+  C1A2 76               halt
132+  C1A3 F3               di
133+  C1A4 CD FA A7         call buffer_buffertoscreen  ; copy buffer to screen
134+  C1A7 FB               ei                          ; enable interupts
135+  C1A8 C9               ret
136+  C1A9
137+  C1A9              ship_draw_full:
138+  C1A9 21 14 B8         ld hl,ship_sprite
139+  C1AC ED 4B E2 C0      ld bc,(ship_initpos2)         ; load bc with the start coords
140+  C1B0 22 E5 C0         ld (ship_current_sprite),hl  ; put into memory
141+  C1B3 ED 43 E7 C0      ld (ship_current_coords),bc  ; put into memory
142+  C1B7 CD D6 C1         call ship_draw
143+  C1BA 08               ex af,af'
144+  C1BB 3A E4 C0         ld a,(ship_frame)            ; get the animation frame
145+  C1BE 16 00            ld d,0
146+  C1C0 5F               ld e,a
147+  C1C1 19               add hl,de
148+  C1C2 22 E5 C0         ld (ship_current_sprite),hl  ; put into memory
149+  C1C5 08               ex af,af'
150+  C1C6 ED 4B E2 C0      ld bc,(ship_initpos2)         ; load bc with the start coords
151+  C1CA 81 C6 08         add c,8                      ; move one line down
152+  C1CD 4F               ld c,a
153+  C1CE ED 43 E7 C0      ld (ship_current_coords),bc  ; put into memory
154+  C1D2 CD D6 C1         call ship_draw
155+  C1D5 C9               ret
156+  C1D6
157+  C1D6              ;
158+  C1D6              ; Draw the ship
159+  C1D6              ; Inputs:
160+  C1D6              ; None, all in memory
161+  C1D6              ;
162+  C1D6              ship_draw:
163+  C1D6 3E 04            ld a,4                              ; 4 pieces per half
164+  C1D8              ship_draw0:
165+  C1D8 F5               push af
166+  C1D9 2A E5 C0         ld hl,(ship_current_sprite)
167+  C1DC ED 4B E7 C0      ld bc,(ship_current_coords)         ; load bc with the start coords
168+  C1E0 CD 03 AB         call sprites_drawsprite
169+  C1E3 2A E5 C0         ld hl,(ship_current_sprite)
170+  C1E6 ED 4B E7 C0      ld bc,(ship_current_coords)         ; load bc with the start coords
171+  C1EA 11 08 00         ld de,8
172+  C1ED 19               add hl,de
173+  C1EE 80 C6 08         add b,8
174+  C1F1 47               ld b,a
175+  C1F2 22 E5 C0         ld (ship_current_sprite),hl         ; put into memory
176+  C1F5 ED 43 E7 C0      ld (ship_current_coords),bc         ; put into memory
177+  C1F9 F1               pop af
178+  C1FA 3D               dec a
179+  C1FB FE 00            cp 0
180+  C1FD C2 D8 C1         jp nz,ship_draw0
181+  C200
182+  C200 C9               ret
183+  C201
# file closed: game/ship.asm
152   C201                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  C201              ;
  2+  C201              ; tank initial position: vert,horiz
  3+  C201              ;
  4+  C201              tank_initpos:
  5+  C201 10 D0            defb 16,208
  6+  C203              tank_initpos2:
  7+  C203 00 00            defb 0,0
  8+  C205              tank_frame:
  9+  C205 00               defb 0
 10+  C206              tank_anim:
 11+  C206 11               defb 17
 12+  C207
 13+  C207              ;
 14+  C207              ; The damage countdown
 15+  C207              ;
 16+  C207              tank_currentdamage:
 17+  C207 F0               defb 240
 18+  C208
 19+  C208              ;
 20+  C208              ; The damage coordinate
 21+  C208              ;
 22+  C208              tank_currentdamagecoord:
 23+  C208 16 02            defb 22,2
 24+  C20A
 25+  C20A              ;
 26+  C20A              ; Controls when the tank shoots
 27+  C20A              ;
 28+  C20A              tank_count:
 29+  C20A 00               defb 0
 30+  C20B
 31+  C20B              ;
 32+  C20B              ; Holds the block number of the current damage sprite
 33+  C20B              ;
 34+  C20B              tank_damageframe:
 35+  C20B 00               defb 0
 36+  C20C
 37+  C20C              ;
 38+  C20C              ; The current memory location
 39+  C20C              ;
 40+  C20C              tank_current_sprite:
 41+  C20C 00 00            defb 0,0
 42+  C20E
 43+  C20E              tank_current_coords:
 44+  C20E 00 00            defb 0,0
 45+  C210
 46+  C210              ;
 47+  C210              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  C210              ;
 49+  C210              tank_missile_displayed:
 50+  C210 00               defb 0
 51+  C211
 52+  C211              ;
 53+  C211              ; Initialise the tank
 54+  C211              ;
 55+  C211              tank_init:
 56+  C211 ED 4B 01 C2      ld bc,(tank_initpos)
 57+  C215 ED 43 03 C2      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  C219 21 05 C2         ld hl,tank_frame
 59+  C21C 36 00            ld (hl),0
 60+  C21E 21 06 C2         ld hl,tank_anim
 61+  C221 36 11            ld (hl),17
 62+  C223 21 0B C2         ld hl,tank_damageframe              ; reset tank
 63+  C226 36 00            ld (hl),0
 64+  C228 21 0A C2         ld hl,tank_count
 65+  C22B 36 00            ld (hl),0
 66+  C22D 21 07 C2         ld hl,tank_currentdamage
 67+  C230 36 F0            ld (hl),240
 68+  C232 21 08 C2         ld hl,tank_currentdamagecoord
 69+  C235 36 16            ld (hl),22
 70+  C237 23               inc hl
 71+  C238 36 02            ld (hl),2
 72+  C23A 21 10 C2         ld hl,tank_missile_displayed
 73+  C23D 36 00            ld (hl),0
 74+  C23F
 75+  C23F C9               ret
 76+  C240
 77+  C240              ;
 78+  C240              ;   Draw and move the tank
 79+  C240              ;   Start processing at frame 200
 80+  C240              ;   Don't move if anim is zero
 81+  C240              ;   Decrement frame if moved
 82+  C240              ;
 83+  C240              tank_process:
 84+  C240 3A 06 C2         ld a,(tank_anim)
 85+  C243 FE 00            cp 0
 86+  C245 C2 4C C2         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  C248 CD 5D C2         call tank_fire
 88+  C24B C9               ret
 89+  C24C              tank_process0:
 90+  C24C CD 80 BE         call game_getcurrentframe   ; get the current frame number into a
 91+  C24F FE 4B            cp 75
 92+  C251 D8               ret c                       ; return if the frame number is below 100
 93+  C252 CD 83 C3         call tank_move              ; move tank if not
 94+  C255 3A 06 C2         ld a,(tank_anim)
 95+  C258 3D               dec a
 96+  C259 32 06 C2         ld (tank_anim),a            ; decrease the anim count
 97+  C25C C9               ret
 98+  C25D
 99+  C25D              ;
100+  C25D              ; Fires the tank
101+  C25D              ;
102+  C25D              tank_fire:
103+  C25D 3A 0A C2         ld a,(tank_count)            ; if not, don't do anything
104+  C260 3C               inc a                        ; increment
105+  C261 FE 32            cp 50                        ; have we reached fifty
106+  C263 C2 68 C2         jp nz,tank_fire0
107+  C266 3E 00            ld a,0                       ; reset if reached fifty
108+  C268              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  C268 32 0A C2         ld (tank_count),a            ; store tank count
110+  C26B FE 00            cp 0
111+  C26D CA 8E C2         jp z,tank_fire7              ; If this is zero, fire
112+  C270 3A 10 C2         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  C273 FE 00            cp 0
114+  C275 C8               ret z                       ; don't do anything if not
115+  C276 CD 3D C3         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  C279 3E 00            ld a,0                       ; reset the flag
117+  C27B 32 10 C2         ld (tank_missile_displayed),a
118+  C27E 3E 02            ld a,2
119+  C280 ED 4B 08 C2      ld bc,(tank_currentdamagecoord)
120+  C284 0C               inc c
121+  C285 0C               inc c
122+  C286 ED 43 1A AC      ld (origcoords),bc
123+  C28A CD 1F A7         call buffer_marklineforupdate
124+  C28D C9               ret                        ; only shoot if we're on 0
125+  C28E              tank_fire7:
126+  C28E 3A 07 C2         ld a,(tank_currentdamage)    ; get the damage countdown
127+  C291 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
128+  C293 C2 C9 C2         jp nz,tank_fire1            ; not, so just do a normal frame
129+  C296 ED 4B 08 C2      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
130+  C29A 79               ld a,c
131+  C29B FE 0A            cp 10
132+  C29D C2 A4 C2         jp nz, tank_fire6
133+  C2A0 CD 75 C3         call tank_killedbytank      ; we're through, so the player has died. Kill them.
134+  C2A3 C9               ret                         ; return if we're through the mountain
135+  C2A4              tank_fire6:
136+  C2A4 3E 0F            ld a,15
137+  C2A6 32 0B C2         ld (tank_damageframe),a     ; reset the damage frame
138+  C2A9 21 A8 B6         ld hl,sprites               ; location of the empty block
139+  C2AC CD 5B AA         call screen_showchar        ; show this character here
140+  C2AF ED 4B 08 C2      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
141+  C2B3 05               dec b                       ; look one above
142+  C2B4 CD BF AA         call screen_ischarempty     ; check if it is empty
143+  C2B7 ED 4B 08 C2      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
144+  C2BB FE 01            cp 1
145+  C2BD C2 00 C3         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
146+  C2C0 ED 4B 08 C2      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  C2C4 0D               dec c
148+  C2C5 ED 43 08 C2      ld (tank_currentdamagecoord),bc ; store the coord
149+  C2C9              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
150+  C2C9 ED 4B 08 C2      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
151+  C2CD 3A 07 C2         ld a,(tank_currentdamage)    ; get the damage countdown
152+  C2D0 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
153+  C2D2 C2 DD C2         jp nz, tank_fire5
154+  C2D5 CD EF AA         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
155+  C2D8 FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
156+  C2DA C2 1E C3         jp nz,tank_fire3            ; if it's a slope, handle this differently
157+  C2DD              tank_fire5:
158+  C2DD 3A 0B C2         ld a,(tank_damageframe)
159+  C2E0 CD 7E AA         call screen_getblock        ; get the block data into hl
160+  C2E3 CD 5B AA         call screen_showchar        ; show this character here
161+  C2E6 3A 0B C2         ld a,(tank_damageframe)
162+  C2E9 3C               inc a
163+  C2EA 32 0B C2         ld (tank_damageframe),a     ; increment the damage block and store
164+  C2ED 3A 07 C2         ld a,(tank_currentdamage)    ; get the damage countdown
165+  C2F0 3D               dec a
166+  C2F1 3D               dec a
167+  C2F2 32 07 C2         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
168+  C2F5 3A 10 C2         ld a,(tank_missile_displayed) ; is the missile displaying?
169+  C2F8 FE 00            cp 0
170+  C2FA CC 3D C3         call z, tank_missilegraphic
171+  C2FD C3 27 C3         jp tank_fire4
172+  C300              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
173+  C300 05               dec b
174+  C301 C5               push bc
175+  C302 CD D8 AA         call screen_copyblockdown       ; copy the block down
176+  C305 ED 4B 08 C2      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
177+  C309 C1               pop bc                      ; get the coord we just checked back
178+  C30A 78               ld a,b
179+  C30B FE 00            cp 0
180+  C30D CA C9 C2         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
181+  C310 C5               push bc
182+  C311 05               dec b
183+  C312 CD BF AA         call screen_ischarempty     ; check if it is empty
184+  C315 C1               pop bc
185+  C316 FE 01            cp 1                        ; if empty
186+  C318 C2 00 C3         jp nz, tank_fire2            ; copy another one down
187+  C31B C3 C9 C2         jp tank_fire1               ; otherwise, return to main thread
188+  C31E              tank_fire3:                      ; dealing with slopes
189+  C31E 3A 07 C2         ld a,(tank_currentdamage)    ; get the damage countdown
190+  C321 06 08            ld b,8
191+  C323 90               sub b                        ; special case for slopes
192+  C324 32 07 C2         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
193+  C327              tank_fire4:                     ; TIDY UP
194+  C327 ED 4B 08 C2      ld bc,(tank_currentdamagecoord)
195+  C32B ED 43 1A AC      ld (origcoords),bc
196+  C32F CD 1F A7         call buffer_marklineforupdate
197+  C332 3E 01            ld a,1
198+  C334 CD 1F A7         call buffer_marklineforupdate
199+  C337 3E 02            ld a,2
200+  C339 CD 1F A7         call buffer_marklineforupdate
201+  C33C C9               ret
202+  C33D
203+  C33D              ;
204+  C33D              ; Displays or hides the missile graphic, and changes the gun
205+  C33D              ;
206+  C33D              tank_missilegraphic:
207+  C33D 3A 10 C2         ld a,(tank_missile_displayed)
208+  C340 FE 00            cp 0
209+  C342 C2 4A C3         jp nz,tank_missilegraphic0
210+  C345 3E 13            ld a,19
211+  C347 C3 4C C3         jp tank_missilegraphic1
212+  C34A              tank_missilegraphic0:
213+  C34A 3E 00            ld a,0
214+  C34C              tank_missilegraphic1:
215+  C34C 32 10 C2         ld (tank_missile_displayed),a ; store the flipped graphic
216+  C34F ED 4B 08 C2      ld bc,(tank_currentdamagecoord)
217+  C353 0C               inc c
218+  C354 0C               inc c                   ; print the graphic 2 spaces right
219+  C355 CD 7E AA         call screen_getblock        ; get the block data into hl
220+  C358 CD 5B AA         call screen_showchar        ; show this character here
221+  C35B 06 02            ld b,2
222+  C35D 0E 18            ld c,24                     ; set gunbarrel coords
223+  C35F 11 00 00         ld de,0
224+  C362 21 74 B8         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
225+  C365 3A 10 C2         ld a,(tank_missile_displayed)
226+  C368 FE 00            cp 0
227+  C36A CA 70 C3         jp z,tank_missilegraphic2
228+  C36D 11 40 00         ld de,64
229+  C370              tank_missilegraphic2:
230+  C370 19               add hl,de                   ; work out missile graphic
231+  C371 CD 5B AA         call screen_showchar        ; show this character here
232+  C374 C9               ret
233+  C375
234+  C375              ;
235+  C375              ; Deal with the player being killed by the tank
236+  C375              ;
237+  C375              tank_killedbytank:
238+  C375 ED 4B 08 C2      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
239+  C379 21 A8 B6         ld hl,sprites                   ; empty sprite
240+  C37C CD 5B AA         call screen_showchar            ; hide the last piece of dirt
241+  C37F CD BA BF         call player_tankkillplayer
242+  C382 C9               ret
243+  C383
244+  C383              tank_move:
245+  C383 ED 4B 03 C2      ld bc,(tank_initpos2)
246+  C387 C5               push bc
247+  C388 3A 06 C2         ld a,(tank_anim)
248+  C38B FE 11            cp 17                       ; check first time flag
249+  C38D CA 9F C3         jp z,tank_move1             ; don't draw over previous one if first time
250+  C390 CD A4 C3         call tank_draw_full         ; delete old one
251+  C393 ED 4B 03 C2      ld bc,(tank_initpos2)       ; get the current coords
252+  C397 78               ld a,b
253+  C398 D6 01            sub 1                       ; move back one pixels
254+  C39A 47               ld b,a
255+  C39B ED 43 03 C2      ld (tank_initpos2),bc
256+  C39F              tank_move1:
257+  C39F CD A4 C3         call tank_draw_full         ; draw the tank
258+  C3A2 C1               pop bc
259+  C3A3 C9               ret
260+  C3A4
261+  C3A4              tank_draw_full:
262+  C3A4 21 74 B8         ld hl,tank_sprite
263+  C3A7 ED 4B 03 C2      ld bc,(tank_initpos2)         ; load bc with the start coords
264+  C3AB 22 0C C2         ld (tank_current_sprite),hl  ; put into memory
265+  C3AE ED 43 0E C2      ld (tank_current_coords),bc  ; put into memory
266+  C3B2 CD D1 C3         call tank_draw
267+  C3B5 08               ex af,af'
268+  C3B6 3A 05 C2         ld a,(tank_frame)            ; get the animation frame
269+  C3B9 16 00            ld d,0
270+  C3BB 5F               ld e,a
271+  C3BC 19               add hl,de
272+  C3BD 22 0C C2         ld (tank_current_sprite),hl  ; put into memory
273+  C3C0 08               ex af,af'
274+  C3C1 ED 4B 03 C2      ld bc,(tank_initpos2)         ; load bc with the start coords
275+  C3C5 81 C6 08         add c,8                      ; move one line down
276+  C3C8 4F               ld c,a
277+  C3C9 ED 43 0E C2      ld (tank_current_coords),bc  ; put into memory
278+  C3CD CD D1 C3         call tank_draw
279+  C3D0 C9               ret
280+  C3D1
281+  C3D1              ;
282+  C3D1              ; Draw the tank
283+  C3D1              ; Inputs:
284+  C3D1              ; None, all in memory
285+  C3D1              ;
286+  C3D1              tank_draw:
287+  C3D1 3E 04            ld a,4                              ; 4 pieces per half
288+  C3D3              tank_draw0:
289+  C3D3 F5               push af
290+  C3D4 2A 0C C2         ld hl,(tank_current_sprite)
291+  C3D7 ED 4B 0E C2      ld bc,(tank_current_coords)         ; load bc with the start coords
292+  C3DB CD 03 AB         call sprites_drawsprite
293+  C3DE 2A 0C C2         ld hl,(tank_current_sprite)
294+  C3E1 ED 4B 0E C2      ld bc,(tank_current_coords)         ; load bc with the start coords
295+  C3E5 11 08 00         ld de,8
296+  C3E8 19               add hl,de
297+  C3E9 80 C6 08         add b,8
298+  C3EC 47               ld b,a
299+  C3ED 22 0C C2         ld (tank_current_sprite),hl         ; put into memory
300+  C3F0 ED 43 0E C2      ld (tank_current_coords),bc         ; put into memory
301+  C3F4 F1               pop af
302+  C3F5 3D               dec a
303+  C3F6 FE 00            cp 0
304+  C3F8 C2 D3 C3         jp nz,tank_draw0
305+  C3FB
306+  C3FB C9               ret
307+  C3FC
# file closed: game/tank.asm
153   C3FC                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  C3FC              ;
  2+  C3FC              ; A structure of falling rocks
  3+  C3FC              ; Assume we'll never have more than 4 falling at any one time
  4+  C3FC              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  C3FC              ;
  6+  C3FC              rocks_falling:
  7+  C3FC 00 00 00 00      defb 0,0,0,0
  8+  C400 00 00 00 00      defb 0,0,0,0
  9+  C404 00 00 00 00      defb 0,0,0,0
 10+  C408 00 00 00 00      defb 0,0,0,0
 11+  C40C
 12+  C40C              rocks_tmp:
 13+  C40C 00               defb 0
 14+  C40D
 15+  C40D              rocks_tmp2:
 16+  C40D 00 00            defb 0,0
 17+  C40F
 18+  C40F              ;
 19+  C40F              ; The number of frames to wobble for
 20+  C40F              ; Must always be 10 more than the number of frames a player digs
 21+  C40F              ;
 22+  C40F              rocks_numberofframestowobble:
 23+  C40F 14               defb 20
 24+  C410
 25+  C410              ;
 26+  C410              ; Coords of the rock that killed us
 27+  C410              ;
 28+  C410              rocks_killerrock:
 29+  C410 00 00            defb 0,0
 30+  C412
 31+  C412              ;
 32+  C412              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  C412              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  C412              ; If the pixel row is not the rock bottom, stop checking.
 35+  C412              ; Inputs:
 36+  C412              ; hl- memory location
 37+  C412              ;
 38+  C412              rocks_checkforfalling:
 39+  C412 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  C413 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  C415 C2 1B C4         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  C418 CD 1C C4         call rocks_addrocktofalling ; mark the rock as falling
 43+  C41B              rocks_checkforfalling2:
 44+  C41B C9               ret
 45+  C41C
 46+  C41C              ;
 47+  C41C              ; Adds the rock to the structure that tracks falling rocks
 48+  C41C              ; Inputs:
 49+  C41C              ; hl - memory location of falling rock graphic
 50+  C41C              ; bc - coords of rock, c vert
 51+  C41C              rocks_addrocktofalling:
 52+  C41C C5               push bc             ; store the coords
 53+  C41D 11 FC C3         ld de,rocks_falling
 54+  C420 06 04            ld b,4              ; number of possible falling rocks
 55+  C422              rocks_addrocktofalling0:
 56+  C422 13               inc de
 57+  C423                  ;inc de
 58+  C423 13               inc de              ; move three along to get the state
 59+  C424 1A               ld a,(de)           ; load the state
 60+  C425 FE 00            cp 0                ; check if this is not falling
 61+  C427 C2 3E C4         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  C42A 13               inc de              ; move to frame
 63+  C42B 3A 0F C4         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  C42E 12               ld (de),a
 65+  C42F 1B               dec de              ; move de back to state
 66+  C430 3E 02            ld a,2
 67+  C432 12               ld (de),a           ; set the state to wobbling
 68+  C433 1B               dec de              ; move back coords
 69+  C434 C1               pop bc              ; get back coords
 70+  C435 78               ld a,b
 71+  C436 12               ld (de),a           ; store the vertical
 72+  C437 1B               dec de
 73+  C438 79               ld a,c
 74+  C439 12               ld (de),a           ; store the horizontal
 75+  C43A C5               push bc
 76+  C43B C3 42 C4         jp rocks_addrocktofalling2 ; done
 77+  C43E              rocks_addrocktofalling1:
 78+  C43E 13               inc de
 79+  C43F 13               inc de              ; move memory along to next rock
 80+  C440 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  C442              rocks_addrocktofalling2: ; done, return
 82+  C442 C1               pop bc              ; to tidy up
 83+  C443 C9               ret
 84+  C444
 85+  C444              ;
 86+  C444              ; Processes any falling rocks
 87+  C444              ;
 88+  C444              rocks_processrocks:
 89+  C444 DD 21 FC C3      ld ix,rocks_falling
 90+  C448 06 04            ld b,4              ; the number of rocks to check
 91+  C44A              rocks_processrocks0:
 92+  C44A C5               push bc             ; store loop count
 93+  C44B DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  C44F 46 01
 94+  C451 DD 23            inc ix
 95+  C453 DD 23            inc ix              ; move to the state
 96+  C455 DD 7E 00         ld a,(ix)           ; load the state into a
 97+  C458 FE 00            cp 0
 98+  C45A CA 7B C4         jp z,rocks_processrocks3 ; if not falling, check next
 99+  C45D FE 02            cp 2
100+  C45F C2 6F C4         jp nz, rocks_processrocks2
101+  C462                  ; we're wobbling
102+  C462 DD 23            inc ix              ; get frame number for wobble
103+  C464 DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  C467 CD 3E C5         call rocks_wobble
105+  C46A DD 23            inc ix              ; increment for next
106+  C46C C3 7F C4         jp rocks_processrocks1  ; do next rock
107+  C46F              rocks_processrocks2:
108+  C46F                  ; we're falling
109+  C46F C5               push bc
110+  C470 CD 83 C4         call rocks_fall
111+  C473 C1               pop bc
112+  C474 DD 23            inc ix
113+  C476 DD 23            inc ix              ; inc ix to get to next
114+  C478 C3 7F C4         jp rocks_processrocks1
115+  C47B              rocks_processrocks3:
116+  C47B DD 23            inc ix
117+  C47D DD 23            inc ix
118+  C47F              rocks_processrocks1:
119+  C47F C1               pop bc              ; get loop count back
120+  C480 10 C8            djnz rocks_processrocks0
121+  C482 C9               ret
122+  C483
123+  C483              ;
124+  C483              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  C483              ; bc - coord of current rock graphic on screen
126+  C483              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  C483              ;
128+  C483              rocks_fall:
129+  C483 DD 2B            dec ix
130+  C485 DD 2B            dec ix              ; decrease ix back to coords
131+  C487 ED 43 0D C4      ld (rocks_tmp2),bc  ; store original coords
132+  C48B 3E 03            ld a,3              ; move this number of pixels
133+  C48D              rocks_fall1:
134+  C48D 32 0C C4         ld (rocks_tmp),a    ; store loop counter
135+  C490 DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  C494 46 01
136+  C496 CD F8 AB         call sprites_scadd  ; get the memory of the coords into de
137+  C499 14               inc d               ; add 256 to get next row
138+  C49A 1A               ld a,(de)           ; get the contents of the next row
139+  C49B FE 00            cp 0
140+  C49D C2 FD C4         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  C4A0 0C               inc c               ; increment the vertical
142+  C4A1 DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  C4A5 70 01
143+  C4A7 79               ld a,c              ; get the vertical coord into a
144+  C4A8 E6 07            and 7               ; divisible by 8?
145+  C4AA FE 00            cp 0
146+  C4AC C2 C9 C4         jp nz,rocks_fall4   ; if not, carry on
147+  C4AF CD 31 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  C4B2 3E 42            ld a,66             ; load red
149+  C4B4 CD 89 AA         call screen_setattr
150+  C4B7 DD 4E 00 DD      ld bc,(ix)
150+  C4BB 46 01
151+  C4BD 79               ld a,c              ; get vertical
152+  C4BE D6 08            sub 8               ; look up one square
153+  C4C0 4F               ld c,a              ; put a back in c
154+  C4C1 CD 31 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  C4C4 3E 46            ld a,70             ; load yellow
156+  C4C6 CD 89 AA         call screen_setattr
157+  C4C9              rocks_fall4:
158+  C4C9 3A 0C C4         ld a,(rocks_tmp)    ; get the loop counter
159+  C4CC 3D               dec a
160+  C4CD FE 00            cp 0
161+  C4CF C2 8D C4         jp nz,rocks_fall1   ; do another pixel if needed
162+  C4D2              rocks_fall2:
163+  C4D2 3E 09            ld a,9              ; rock graphic
164+  C4D4 ED 4B 0D C4      ld bc,(rocks_tmp2)  ; get the original coords
165+  C4D8 CD 7E AA         call screen_getblock     ; get the memory into hl
166+  C4DB CD 03 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  C4DE 3E 09            ld a,9
168+  C4E0 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  C4E4 46 01
169+  C4E6 CD 7E AA         call screen_getblock     ; get the memory into hl
170+  C4E9 CD 03 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  C4EC DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  C4F0 46 01
172+  C4F2 CD 23 C5         call rocks_checkforplayer ; check to see if we hit a player
173+  C4F5 DD 23            inc ix
174+  C4F7 DD 23            inc ix                  ; get ix back to state
175+  C4F9 CD 13 C5         call rocks_makesound
176+  C4FC C9               ret
177+  C4FD              rocks_fall3:
178+  C4FD 3E 00            ld a,0              ; set the state to fell
179+  C4FF DD 77 02         ld (ix+2),a           ; store the falling state
180+  C502 DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  C506 46 01
181+  C508 CD 31 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  C50B 3E 42            ld a,66             ; load magenta
183+  C50D CD 89 AA         call screen_setattr
184+  C510 C3 D2 C4         jp rocks_fall2      ; rejoin main loop
185+  C513
186+  C513              ;
187+  C513              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  C513              ;
189+  C513              rocks_makesound:
190+  C513 DD 7E 00         ld a,(ix)           ; get the state
191+  C516 FE 00            cp 0
192+  C518 C0               ret nz              ; if we haven't fallen, don't do anything
193+  C519 21 9C BE         ld hl,player+11
194+  C51C 7E               ld a,(hl)
195+  C51D FE 01            cp 1
196+  C51F C4 D9 B0         call nz, sound_rockfell ; only make sound if didn't kill player
197+  C522 C9               ret
198+  C523
199+  C523              ;
200+  C523              ; Checks to see if the rock is hitting a player
201+  C523              ; Inputs:
202+  C523              ; bc - coords of rock we're checking
203+  C523              rocks_checkforplayer:
204+  C523 ED 5B 91 BE      ld de,(player)       ; get the player coords
205+  C527 7B               ld a,e               ; get the vert coord first
206+  C528 91               sub c                ; subtract the rock vertical coord from players
207+  C529 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  C52B C0               ret nz               ; if not, hasn't hit
209+  C52C 7A               ld a,d               ; get the player horiz coord
210+  C52D 90               sub b                ; subtract rock coord
211+  C52E C6 07            add 7                ; add max distance
212+  C530 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  C532 DA 36 C5         jp c,rocks_checkforplayer0
214+  C535 C9               ret
215+  C536              rocks_checkforplayer0:
216+  C536 ED 43 10 C4      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  C53A CD B4 BF         call player_crushplayer ; if so, jump out
218+  C53D C9               ret
219+  C53E
220+  C53E              ;
221+  C53E              ; Wobbles a rocks
222+  C53E              ; Inputs:
223+  C53E              ; bc - coord of current rock graphic on screen
224+  C53E              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  C53E              ; a - wobble frame
226+  C53E              rocks_wobble:
227+  C53E DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  C541 E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  C543 1E 09            ld e,9              ; this is the rock frame
230+  C545 83               add a,e             ; add the frame toggle
231+  C546 C5               push bc
232+  C547 CD 7E AA         call screen_getblock     ; get the memory into hl
233+  C54A CD 03 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  C54D DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  C550 3D               dec a               ; decrease
236+  C551 DD 77 00         ld (ix),a           ; store
237+  C554 E6 01            and 1
238+  C556 1E 09            ld e,9              ; this is the rock frame
239+  C558 83               add a,e             ; add the frame toggle
240+  C559 CD 7E AA         call screen_getblock     ; get the memory into hl
241+  C55C C1               pop bc
242+  C55D CD 03 AB         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  C560 DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  C563 FE 00            cp 0
245+  C565 C0               ret nz              ; if we're not at zero, return
246+  C566 DD 2B            dec ix              ; otherwise look to state location
247+  C568 3E 01            ld a,1              ; set the state to falling
248+  C56A DD 77 00         ld (ix),a           ; store the falling state
249+  C56D DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  C56F C9               ret
251+  C570
# file closed: game/rocks.asm
154   C570                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  C570              ;
  2+  C570              ; The score of the current player
  3+  C570              ;
  4+  C570              scores_current:
  5+  C570 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  C574 30 30 30 30
  5+  C578 FF
  6+  C579
  7+  C579              scores_defaultname:
  8+  C579 2D 2D 2D         defb '---'
  9+  C57C
 10+  C57C              ;
 11+  C57C              ; The current high score table
 12+  C57C              ;
 13+  C57C              scores_table:
 14+  C57C 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  C580 4D 30 30 30
 14+  C584 30 30 30 FF
 15+  C588 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  C58C 4D 30 30 30
 15+  C590 30 30 30 FF
 16+  C594 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  C598 4D 30 30 30
 16+  C59C 30 30 30 FF
 17+  C5A0
 18+  C5A0              ;
 19+  C5A0              ; Add thousands to the score
 20+  C5A0              ; Inputs:
 21+  C5A0              ; b - number to add
 22+  C5A0              ;
 23+  C5A0              scores_addthousands:
 24+  C5A0 21 74 C5         ld hl,scores_current+4
 25+  C5A3 CD 04 C6         call scores_update
 26+  C5A6 C9               ret
 27+  C5A7
 28+  C5A7              ;
 29+  C5A7              ; Add hundreds to the score
 30+  C5A7              ; Inputs:
 31+  C5A7              ; b - number to add
 32+  C5A7              ;
 33+  C5A7              scores_addhundreds:
 34+  C5A7 21 75 C5         ld hl,scores_current+5
 35+  C5AA CD 04 C6         call scores_update
 36+  C5AD C9               ret
 37+  C5AE
 38+  C5AE              ;
 39+  C5AE              ; Temporary area for printing scores
 40+  C5AE              ;
 41+  C5AE              scores_printscore_tmp:
 42+  C5AE 00 00 00 00      defb 0,0,0,0,0,0,0,0,255
 42+  C5B2 00 00 00 00
 42+  C5B6 FF
 43+  C5B7
 44+  C5B7              ;
 45+  C5B7              ; Prints the score to screen
 46+  C5B7              ;
 47+  C5B7              scores_printscore:
 48+  C5B7 3A 51 BE         ld a,(game_currentplayer)   ; get current player
 49+  C5BA 21 70 C5         ld hl,scores_current
 50+  C5BD FE 01            cp 1
 51+  C5BF C2 C7 C5         jp nz, score_printscore0    ; if not player 1
 52+  C5C2 36 04            ld (hl),4       ; set position for player 1
 53+  C5C4 C3 C9 C5         jp score_printscore1
 54+  C5C7              score_printscore0:
 55+  C5C7 36 16            ld (hl),22       ; set position for player 2
 56+  C5C9              score_printscore1:
 57+  C5C9 CD CD C5         call score_printscoreformatted
 58+  C5CC C9               ret
 59+  C5CD
 60+  C5CD              ;
 61+  C5CD              ; Formats a score and prints to the top screen
 62+  C5CD              ; Inputs:
 63+  C5CD              ; hl - where is the score
 64+  C5CD              score_printscoreformatted:
 65+  C5CD 01 08 00         ld bc,8
 66+  C5D0 11 AE C5         ld de,scores_printscore_tmp
 67+  C5D3 ED B0            ldir                        ; copy to temp
 68+  C5D5 21 AE C5         ld hl,scores_printscore_tmp
 69+  C5D8 E5 DD E1         ld ix,hl
 70+  C5DB DD 7E 02         ld a,(ix+2)
 71+  C5DE FE 30            cp 48                   ; is it a leading zero?
 72+  C5E0 C2 F3 C5         jp nz,score_printscore2
 73+  C5E3 DD 36 02 20      ld (ix+2),32              ; load it with a space
 74+  C5E7 DD 7E 03         ld a,(ix+3)
 75+  C5EA FE 30            cp 48                   ; is it a leading zero?
 76+  C5EC C2 F3 C5         jp nz,score_printscore2
 77+  C5EF DD 36 03 20      ld (ix+3),32              ; load it with a space
 78+  C5F3              score_printscore2:
 79+  C5F3 CD 1F 86         call string_print
 80+  C5F6 C9               ret
 81+  C5F7
 82+  C5F7              ;
 83+  C5F7              ; Prints both scores to screen
 84+  C5F7              ;
 85+  C5F7              scores_printscores:
 86+  C5F7 21 9A BF         ld hl,player1_score
 87+  C5FA CD CD C5         call score_printscoreformatted
 88+  C5FD 21 A3 BF         ld hl,player2_score
 89+  C600 CD CD C5         call score_printscoreformatted
 90+  C603 C9               ret
 91+  C604
 92+  C604              ;
 93+  C604              ; Updates the current score.
 94+  C604              ; Inputs:
 95+  C604              ; hl - memory location of the score column
 96+  C604              ; b - number to add
 97+  C604              ;
 98+  C604              scores_update:
 99+  C604 7E               ld a,(hl)           ; current value of digit.
100+  C605 80               add a,b             ; add points to this digit.
101+  C606 77               ld (hl),a           ; place new digit back in string.
102+  C607 FE 3A            cp 58               ; more than ASCII value '9'?
103+  C609 D8               ret c               ; no - relax.
104+  C60A D6 0A            sub 10              ; subtract 10.
105+  C60C 77               ld (hl),a           ; put new character back in string.
106+  C60D              scores_update0:
107+  C60D 2B               dec hl              ; previous character in string.
108+  C60E 34               inc (hl)            ; up this by one.
109+  C60F 7E               ld a,(hl)           ; what's the new value?
110+  C610 FE 3A            cp 58               ; gone past ASCII nine?
111+  C612 D8               ret c               ; no, scoring done.
112+  C613 D6 0A            sub 10              ; down by ten.
113+  C615 77               ld (hl),a           ; put it back
114+  C616 C3 0D C6         jp scores_update0   ; go round again.
115+  C619
116+  C619
117+  C619              ;
118+  C619              ; Temporary area to store score
119+  C619              ;
120+  C619              scores_showtable_tmp:
121+  C619 00 00 00 00      defb 0,0,0,0,0,0,0,0,0,0,0,255
121+  C61D 00 00 00 00
121+  C621 00 00 00 FF
122+  C625
123+  C625              ;
124+  C625              ; Processes a score
125+  C625              ; Inputs:
126+  C625              ; hl - location on table
127+  C625              ;
128+  C625              scores_showtable_process:
129+  C625 01 0B 00         ld bc,11                     ; copy this many
130+  C628 11 19 C6         ld de,scores_showtable_tmp
131+  C62B ED B0            ldir
132+  C62D DD 21 19 C6      ld ix,scores_showtable_tmp   ; decide whether to show five or six numbers
133+  C631 DD 7E 05         ld a,(ix+5)
134+  C634 FE 30            cp 48                        ; is this a zero?
135+  C636 C2 4C C6         jp nz,scores_showtable_process0 ; if not, show the whole thing
136+  C639 01 05 00         ld bc,5                      ; copy this many
137+  C63C DD E5 E1         ld hl,ix
138+  C63F 11 06 00         ld de,6
139+  C642 19               add hl,de                    ; move to second digit
140+  C643 54 5D            ld de,hl
141+  C645 1B               dec de
142+  C646 ED B0            ldir
143+  C648 DD 36 0A 20      ld (ix+10),32                ; stick a space at the end
144+  C64C              scores_showtable_process0:
145+  C64C 21 19 C6         ld hl,scores_showtable_tmp
146+  C64F CD 1F 86         call string_print
147+  C652 C9               ret
148+  C653
149+  C653              ;
150+  C653              ; Displays the high score table at the bottom of the screen
151+  C653              ;
152+  C653              scores_showtable:
153+  C653 21 7C C5         ld hl, scores_table
154+  C656 CD 25 C6         call scores_showtable_process
155+  C659 21 88 C5         ld hl, scores_table+12
156+  C65C CD 25 C6         call scores_showtable_process
157+  C65F 21 94 C5         ld hl, scores_table+24
158+  C662 CD 25 C6         call scores_showtable_process
159+  C665 C9               ret
160+  C666
161+  C666              ;
162+  C666              ; Place to store the current position we're checking
163+  C666              ;
164+  C666              scores_highscoretmp:
165+  C666 00               defb 0
166+  C667
167+  C667              ;
168+  C667              ; Place to store the equal indicator
169+  C667              ;
170+  C667              scores_highscoretmp2:
171+  C667 00               defb 0
172+  C668
173+  C668              ;
174+  C668              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
175+  C668              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
176+  C668              ;
177+  C668              scores_processhighscores:
178+  C668 21 66 C6         ld hl,scores_highscoretmp
179+  C66B 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
180+  C66D 3E 1D            ld a,29
181+  C66F              scores_processhighscores3:
182+  C66F 21 7C C5         ld hl,scores_table          ; position of first score column
183+  C672 5F               ld e,a
184+  C673 16 00            ld d,0
185+  C675 19               add hl,de
186+  C676 08               ex af,af'                   ; store a for later
187+  C677 11 72 C5         ld de,scores_current+2      ; position of current score column
188+  C67A 3E 01            ld a,1
189+  C67C 32 67 C6         ld (scores_highscoretmp2),a ; set the equal indicator to 1 - this will be set to zero if a different number is found
190+  C67F 06 06            ld b,6                      ; times to loop
191+  C681              scores_processhighscores0:
192+  C681 7E               ld a,(hl)
193+  C682 4F               ld c,a                      ; get first score column
194+  C683 1A               ld a,(de)                   ; get first current column
195+  C684 B9               cp c                        ; compare current with first
196+  C685 DA A7 C6         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
197+  C688 CA 90 C6         jp z,scores_processhighscores5  ; if c is equal, then this is not a higher score, so end
198+  C68B 3E 00            ld a,0
199+  C68D 32 67 C6         ld (scores_highscoretmp2),a ; zero the equality indicator
200+  C690              scores_processhighscores5:
201+  C690 23               inc hl
202+  C691 13               inc de                      ; move to next column
203+  C692 10 ED            djnz scores_processhighscores0 ; loop
204+  C694 3A 67 C6         ld a,(scores_highscoretmp2)   ; get the equality indicator
205+  C697 FE 01            cp 1
206+  C699 CA A7 C6         jp z,scores_processhighscores4 ; if it is equal, not a highscore
207+  C69C B7               or a                            ; clear the carry flag
208+  C69D 08               ex af,af'                     ; still here, so must be bigger
209+  C69E 32 66 C6         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
210+  C6A1 0E 0C            ld c,12
211+  C6A3 91               sub c
212+  C6A4 D2 6F C6         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
213+  C6A7              scores_processhighscores4
214+  C6A7 CD AB C6         call scores_updatehighscores
215+  C6AA C9               ret
216+  C6AB
217+  C6AB              ;
218+  C6AB              ; Update score table
219+  C6AB              ;
220+  C6AB              scores_updatehighscores:
221+  C6AB 3A 66 C6         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
222+  C6AE FE 00            cp 0
223+  C6B0 C8               ret z                       ; if this is 0, didn't get a high score
224+  C6B1 FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
225+  C6B3 CA E6 C6         jp z, scores_updatehighscores3
226+  C6B6                                              ; copy old score over one below, if not first
227+  C6B6 21 7C C5         ld hl,scores_table
228+  C6B9 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
229+  C6BC 19               add hl,de                   ; position of first column
230+  C6BD 2B               dec hl
231+  C6BE 2B               dec hl
232+  C6BF 2B               dec hl
233+  C6C0 E5               push hl
234+  C6C1 11 0C 00         ld de,12
235+  C6C4 19               add hl,de                   ; get position of next score
236+  C6C5 54 5D            ld de,hl
237+  C6C7 E1               pop hl                      ; get hl back
238+  C6C8 01 09 00         ld bc,9
239+  C6CB ED B0            ldir
240+  C6CD FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
241+  C6CF CA E6 C6         jp z,scores_updatehighscores3
242+  C6D2 21 7C C5         ld hl,scores_table
243+  C6D5 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
244+  C6D8 19               add hl,de                   ; position of first column
245+  C6D9 E5               push hl
246+  C6DA 11 0C 00         ld de,12
247+  C6DD 19               add hl,de                   ; get position of next score
248+  C6DE 54 5D            ld de,hl
249+  C6E0 E1               pop hl                      ; get hl back
250+  C6E1 01 09 00         ld bc,9
251+  C6E4 ED B0            ldir
252+  C6E6              scores_updatehighscores3:
253+  C6E6 06 06            ld b,6                      ; now overwrite
254+  C6E8 21 7C C5         ld hl,scores_table
255+  C6EB 16 00            ld d,0
256+  C6ED 5F               ld e,a
257+  C6EE 19               add hl,de                   ; position of first column
258+  C6EF 08               ex af,af'
259+  C6F0 11 72 C5         ld de,scores_current+2      ; position of current score column
260+  C6F3              scores_updatehighscores2:
261+  C6F3 1A               ld a,(de)
262+  C6F4 77               ld (hl),a
263+  C6F5 23               inc hl
264+  C6F6 13               inc de
265+  C6F7 10 FA            djnz scores_updatehighscores2
266+  C6F9 11 09 00         ld de,9
267+  C6FC ED 52            sbc hl,de
268+  C6FE 54 5D            ld de,hl                    ; get back to start of entry
269+  C700 21 79 C5         ld hl,scores_defaultname    ; still need to overwrite the name
270+  C703 01 03 00         ld bc,3                      ; 3 chars to copy
271+  C706 ED B0            ldir
272+  C708 C9               ret
# file closed: game/scores.asm
155   C709                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  C709              diamonds_tmp:
  2+  C709 00               defb 0
  3+  C70A
  4+  C70A              diamonds_tmp2:
  5+  C70A 00               defb 0
  6+  C70B
  7+  C70B              ;
  8+  C70B              ; Holds the number of thousands for the current gem type
  9+  C70B              ;
 10+  C70B              diamonds_score:
 11+  C70B 00               defb 0
 12+  C70C
 13+  C70C              ;
 14+  C70C              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  C70C              ; Inputs:
 16+  C70C              ; hl - memory location of gem type
 17+  C70C              diamonds_twinkle_type:
 18+  C70C CD 80 BE         call game_getcurrentframe       ; get current frame number
 19+  C70F E6 07            and 7                           ; want a number from 0-7
 20+  C711 C6 40            add 64                          ; add to 60 to get attr colour
 21+  C713 32 0A C7         ld (diamonds_tmp2),a             ; store the colour
 22+  C716              diamonds_twinkle_type0:
 23+  C716 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  C71A 79               ld a,c                          ; load c into a
 25+  C71B FE FF            cp 255                          ; is this the end?
 26+  C71D CA 45 C7         jp z,diamonds_twinkle_type1           ; step out if so
 27+  C720 23               inc hl
 28+  C721 23               inc hl
 29+  C722 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  C723 FE 01            cp 1
 31+  C725 CA 46 C7         jp z,diamonds_twinkle_type2           ; step out if so
 32+  C728 CD 86 C7         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  C72B DC 4D C7         call c,diamonds_collect     ; we collided
 34+  C72E 23               inc hl
 35+  C72F E5               push hl
 36+  C730 E5 DD E1         ld ix,hl
 37+  C733 DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  C737 46 FE
 38+  C739 3A 0A C7         ld a,(diamonds_tmp2)
 39+  C73C CD 89 AA         call screen_setattr
 40+  C73F E1               pop hl
 41+  C740 23               inc hl
 42+  C741 23               inc hl                          ; move to next diamond
 43+  C742 C3 16 C7         jp diamonds_twinkle_type0
 44+  C745              diamonds_twinkle_type1:
 45+  C745 C9               ret
 46+  C746              diamonds_twinkle_type2:
 47+  C746 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  C747 23               inc hl
 49+  C748 23               inc hl
 50+  C749 08               ex af,af'
 51+  C74A C3 16 C7         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  C74D
 53+  C74D              ;
 54+  C74D              ; Collect the diamond we collided with
 55+  C74D              ; Inputs:
 56+  C74D              ; hl - memory location of current diamond, currently on state
 57+  C74D              ; Output:
 58+  C74D              ; a - 70 - for yellow on black
 59+  C74D              diamonds_collect:
 60+  C74D 36 01            ld (hl),1                       ; collected
 61+  C74F E5               push hl
 62+  C750 2B               dec hl
 63+  C751 2B               dec hl
 64+  C752 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  C756 CD 41 AA         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  C759 ED 5B 09 C7      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  C75D 16 00            ld d,0
 68+  C75F 21 A8 B6         ld hl,sprites
 69+  C762 19               add hl,de
 70+  C763 CD 03 AB         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  C766 E1               pop hl
 72+  C767 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  C769 32 0A C7         ld (diamonds_tmp2),a
 74+  C76C D9               exx
 75+  C76D 3A 0B C7         ld a,(diamonds_score)
 76+  C770 47               ld b,a
 77+  C771 CD A0 C5         call scores_addthousands
 78+  C774 3A 09 C7         ld a,(diamonds_tmp)
 79+  C777 FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  C779 C2 81 C7         jp nz,diamonds_collect0
 81+  C77C 21 9E BE         ld hl,player+13
 82+  C77F 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  C781              diamonds_collect0:
 84+  C781 CD BC B0         call sound_gemcollected
 85+  C784 D9               exx
 86+  C785 C9               ret
 87+  C786
 88+  C786              ;
 89+  C786              ; Checks to see if the gem is hitting a player
 90+  C786              ; Inputs:
 91+  C786              ; bc - coords of diamond we're checking
 92+  C786              diamonds_checkforplayer:
 93+  C786 78               ld a,b               ; multiply b by 8
 94+  C787 07               rlca
 95+  C788 07               rlca
 96+  C789 07               rlca
 97+  C78A 47               ld b,a
 98+  C78B ED 5B 91 BE      ld de,(player)       ; get the player coords
 99+  C78F 7B               ld a,e               ; get the vert coord first
100+  C790 90               sub b                ; subtract the diamond vertical coord from players
101+  C791 C6 04            add 4                ; add the max distance
102+  C793 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  C795 D0               ret nc               ; if not, hasn't hit
104+  C796 79               ld a,c               ; multiply c by 8
105+  C797 07               rlca
106+  C798 07               rlca
107+  C799 07               rlca
108+  C79A 4F               ld c,a
109+  C79B 7A               ld a,d               ; get the player horiz coord
110+  C79C 91               sub c                ; subtract rock coord
111+  C79D C6 04            add 4                ; add max distance
112+  C79F FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  C7A1 D0               ret nc
114+  C7A2 3E 00            ld a,0
115+  C7A4 C9               ret
116+  C7A5
117+  C7A5
118+  C7A5              ;
119+  C7A5              ; Initialise diamonds and gems
120+  C7A5              ;
121+  C7A5              diamonds_twinkle
122+  C7A5 21 0B C7         ld hl,diamonds_score
123+  C7A8 36 02            ld (hl),2         ; store the score we'll add
124+  C7AA 21 09 C7         ld hl,diamonds_tmp
125+  C7AD 36 40            ld (hl),64         ; store the location the diamond sprite
126+  C7AF 21 23 B6         ld hl, level01diamonds
127+  C7B2 CD 0C C7         call diamonds_twinkle_type
128+  C7B5 21 0B C7         ld hl,diamonds_score
129+  C7B8 36 01            ld (hl),1         ; store the score we'll add
130+  C7BA 21 09 C7         ld hl,diamonds_tmp
131+  C7BD 36 70            ld (hl),112         ; store the location the gem sprite
132+  C7BF 21 33 B6         ld hl, level01gems
133+  C7C2 CD 0C C7         call diamonds_twinkle_type
134+  C7C5 C9               ret
135+  C7C6
136+  C7C6              ;
137+  C7C6              ; Initialise diamonds and gems
138+  C7C6              ;
139+  C7C6              diamonds_init:
140+  C7C6 21 23 B6         ld hl, level01diamonds
141+  C7C9 CD D3 C7         call diamonds_init_type
142+  C7CC 21 33 B6         ld hl, level01gems
143+  C7CF CD D3 C7         call diamonds_init_type
144+  C7D2 C9               ret
145+  C7D3
146+  C7D3              ;
147+  C7D3              ; Initialise diamonds or gems, get memory addresses
148+  C7D3              ; Inputs:
149+  C7D3              ; hl - memory location
150+  C7D3              diamonds_init_type:
151+  C7D3 4E               ld c,(hl)                      ; get coords into c
152+  C7D4 79               ld a,c                          ; load c into add
153+  C7D5 FE FF            cp 255                          ; is this the end?
154+  C7D7 CA EE C7         jp z,diamonds_init_type1             ; step out if so
155+  C7DA 23               inc hl
156+  C7DB 46               ld b,(hl)                       ; get coords into b
157+  C7DC E5               push hl
158+  C7DD CD F2 A9         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  C7E0 E1               pop hl
160+  C7E1 23               inc hl                          ; move to state
161+  C7E2 36 00            ld (hl),0
162+  C7E4 23               inc hl                          ; move to memory
163+  C7E5 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  C7E9 23               inc hl                          ; move to next diamond
165+  C7EA 23               inc hl
166+  C7EB C3 D3 C7         jp diamonds_init_type
167+  C7EE              diamonds_init_type1:
168+  C7EE C9               ret
# file closed: game/diamonds.asm
156   C7EF                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  C7EF              ;
  2+  C7EF              ; Controls when missiles fall
  3+  C7EF              ;
  4+  C7EF              missiles_count:
  5+  C7EF 00               defb 0
  6+  C7F0
  7+  C7F0              ;
  8+  C7F0              ; A structure of falling missiles
  9+  C7F0              ; Assume we'll never have more than 4 falling at any one time
 10+  C7F0              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  C7F0              ;
 12+  C7F0              missiles_falling:
 13+  C7F0 00 00 00         defb 0,0,0
 14+  C7F3 00 00 00         defb 0,0,0
 15+  C7F6 00 00 00         defb 0,0,0
 16+  C7F9 00 00 00         defb 0,0,0
 17+  C7FC
 18+  C7FC              ;
 19+  C7FC              ; The coords of the missile that killed us
 20+  C7FC              ;
 21+  C7FC              missiles_killermissile:
 22+  C7FC 00 00            defb 0,0
 23+  C7FE
 24+  C7FE              ;
 25+  C7FE              ; Zeroes the state of each missile
 26+  C7FE              ;
 27+  C7FE              missiles_init:
 28+  C7FE 06 0C            ld b,12
 29+  C800 DD 21 AA B5      ld ix,level01missiles
 30+  C804              missiles_init0:
 31+  C804 DD 36 02 00      ld (ix+2),0               ; set the state to zero
 32+  C808 11 05 00         ld de,5
 33+  C80B DD 19            add ix,de
 34+  C80D DD 36 02 00      ld (ix+2),0
 35+  C811 DD 19            add ix,de
 36+  C813 10 EF            djnz missiles_init0
 37+  C815 06 04            ld b,4                  ; reset four falling missiles
 38+  C817 21 F0 C7         ld hl,missiles_falling
 39+  C81A              missiles_init1:
 40+  C81A 36 00            ld (hl),0
 41+  C81C 23               inc hl
 42+  C81D 36 00            ld (hl),0
 43+  C81F 23               inc hl
 44+  C820 36 00            ld (hl),0
 45+  C822 23               inc hl
 46+  C823 10 F5            djnz missiles_init1
 47+  C825 C9               ret
 48+  C826
 49+  C826              ;
 50+  C826              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 51+  C826              ; Processes any already falling missiles
 52+  C826              ;
 53+  C826              missiles_process:
 54+  C826 3A 9C BE         ld a,(player+11)                        ; check if the player was hit by a missile previously
 55+  C829 FE 03            cp 3
 56+  C82B C2 32 C8         jp nz,missiles_process3                 ; if not, continue
 57+  C82E CD 6F C9         call missiles_zonkplayer
 58+  C831 C9               ret
 59+  C832              missiles_process3:
 60+  C832 3A A0 BE         ld a,(player_location)
 61+  C835 FE 01            cp 1
 62+  C837 C2 A5 C8         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 63+  C83A 21 9E BE         ld hl,player+13
 64+  C83D 7E               ld a,(hl)                               ; check if player has collected a diamond
 65+  C83E FE 01            cp 1
 66+  C840 C2 A5 C8         jp nz, missiles_process0                ; don't activate if not
 67+  C843 21 EF C7         ld hl,missiles_count
 68+  C846 7E               ld a,(hl)                   ; get the missiles count
 69+  C847 3C               inc a
 70+  C848 FE 32            cp 50                                   ; have we reached the count yet
 71+  C84A CA 51 C8         jp z,missiles_process2                 ; if not, don't activate a new one
 72+  C84D 77               ld (hl),a                               ; store the updated count, and continue without activating
 73+  C84E C3 A5 C8         jp missiles_process0
 74+  C851              missiles_process2:
 75+  C851 36 00            ld (hl),0                               ; zero the counter
 76+  C853 1E 0C            ld e,12
 77+  C855 CD AC 81         call utilities_randomupper              ; get random number from 0 to 11
 78+  C858 11 0A 00         ld de,10
 79+  C85B CD F7 80         call utilities_multiply                 ; multiple random number by 10
 80+  C85E 54 5D            ld de,hl                                ; this is the offset for the random missile
 81+  C860 DD 21 AA B5      ld ix,level01missiles                   ; load the location of the missile definitions
 82+  C864 DD 19            add ix,de                               ; get to location of missile
 83+  C866 DD 7E 02         ld a,(ix+2)
 84+  C869 FE 00            cp 0
 85+  C86B CA 7B C8         jp z,missiles_process1                  ; if this missile isn't active, activate it
 86+  C86E 11 05 00         ld de,5                                 ; otherwise, check the missile above
 87+  C871 DD 19            add ix,de
 88+  C873 DD 7E 02         ld a,(ix+2)
 89+  C876 FE 00            cp 0
 90+  C878 C2 A5 C8         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 91+  C87B              missiles_process1:                          ; activate a missile
 92+  C87B DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
 93+  C87F DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
 93+  C883 46 01
 94+  C885 78               ld a,b
 95+  C886 ED 5B D1 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
 96+  C88A 93               sub e
 97+  C88B CD 41 AA         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
 98+  C88E C5               push bc
 99+  C88F 3E 0C            ld a,12                                 ; inactive missile sprite
100+  C891 CD 7E AA         call screen_getblock
101+  C894 CD 03 AB         call sprites_drawsprite                 ; draw the sprite over the old one
102+  C897 C1               pop bc
103+  C898 C5               push bc
104+  C899 3E 14            ld a,20                                 ; active missile sprite
105+  C89B CD 7E AA         call screen_getblock
106+  C89E CD 03 AB         call sprites_drawsprite                 ; draw the sprite over the old one
107+  C8A1 C1               pop bc
108+  C8A2 CD 33 C9         call missiles_addmissiletofalling
109+  C8A5              missiles_process0:
110+  C8A5 CD A9 C8         call missiles_fall
111+  C8A8 C9               ret
112+  C8A9
113+  C8A9              ;
114+  C8A9              ; Processes falling missiles
115+  C8A9              ;
116+  C8A9              missiles_fall:
117+  C8A9 06 04            ld b,4              ; number of possible falling missiles
118+  C8AB DD 21 F0 C7      ld ix,missiles_falling
119+  C8AF              missiles_fall0:
120+  C8AF C5               push bc
121+  C8B0 DD 7E 02         ld a,(ix+2)
122+  C8B3 FE 00            cp 0
123+  C8B5 CA 12 C9         jp z,missiles_fall1 ; not falling move to next
124+  C8B8 FE 01            cp 1                ; is this ready to fall
125+  C8BA CA C0 C8         jp z, missiles_fall3
126+  C8BD C3 2C C9         jp missiles_fall4   ; if not, decrease the countdown
127+  C8C0              missiles_fall3:
128+  C8C0 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
128+  C8C4 46 01
129+  C8C6 CD F8 AB         call sprites_scadd  ; get the memory of the coords into de
130+  C8C9 14               inc d               ; add 256 to get next row
131+  C8CA 1A               ld a,(de)           ; get the contents of the next row
132+  C8CB FE 00            cp 0
133+  C8CD C2 25 C9         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
134+  C8D0 3E 14            ld a,20                                 ; active missile sprite
135+  C8D2 CD 7E AA         call screen_getblock
136+  C8D5 CD 03 AB         call sprites_drawsprite                 ; draw the sprite over the old one
137+  C8D8 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
137+  C8DC 46 01
138+  C8DE 0C               inc c               ; move down one pixel
139+  C8DF DD 71 00 DD      ld (ix),bc          ; store the new coords
139+  C8E3 70 01
140+  C8E5 3E 14            ld a,20                                 ; active missile sprite
141+  C8E7 CD 7E AA         call screen_getblock
142+  C8EA CD 03 AB         call sprites_drawsprite                 ; draw the sprite
143+  C8ED DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
143+  C8F1 46 01
144+  C8F3 79               ld a,c              ; get the vertical coord into a
145+  C8F4 E6 07            and 7               ; divisible by 8?
146+  C8F6 FE 00            cp 0
147+  C8F8 C2 12 C9         jp nz,missiles_fall1   ; if not, carry on
148+  C8FB CD 31 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
149+  C8FE 3E 43            ld a,67             ; load magenta
150+  C900 CD 89 AA         call screen_setattr
151+  C903 DD 4E 00 DD      ld bc,(ix)
151+  C907 46 01
152+  C909 CD 31 AA         call screen_getcharcoordsfromscreencoords ; get the attr address into de
153+  C90C 05               dec b               ; look one square above
154+  C90D 3E 46            ld a,70             ; load yellow
155+  C90F CD 89 AA         call screen_setattr
156+  C912              missiles_fall1:         ; hl at state
157+  C912 DD 4E 00 DD      ld bc,(ix)          ; get coords back
157+  C916 46 01
158+  C918 CD 54 C9         call missiles_checkforplayer ; check for player
159+  C91B DD 23            inc ix
160+  C91D DD 23            inc ix
161+  C91F DD 23            inc ix              ; get to next missile
162+  C921 C1               pop bc
163+  C922 10 8B            djnz missiles_fall0
164+  C924 C9               ret
165+  C925              missiles_fall2:
166+  C925 DD 36 02 00      ld (ix+2),0
167+  C929 C3 12 C9         jp missiles_fall1   ; rejoin the loop
168+  C92C              missiles_fall4:
169+  C92C 3D               dec a               ; decrease the countdown
170+  C92D DD 77 02         ld (ix+2),a         ; store back
171+  C930 C3 12 C9         jp missiles_fall1   ; do next missile
172+  C933
173+  C933              ;
174+  C933              ; Adds the missile to the structure that tracks falling missile
175+  C933              ; Inputs:
176+  C933              ; bc - coords of missile, c vert
177+  C933              missiles_addmissiletofalling:
178+  C933 C5               push bc             ; store the coords
179+  C934 11 F0 C7         ld de,missiles_falling
180+  C937 06 04            ld b,4              ; number of possible falling missiles
181+  C939              missiles_addmissiletofalling0:
182+  C939 13               inc de
183+  C93A 13               inc de              ; move three along to get the state
184+  C93B 1A               ld a,(de)           ; load the state
185+  C93C FE 00            cp 0                ; check if this is not falling
186+  C93E C2 4F C9         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
187+  C941 3E 19            ld a,25
188+  C943 12               ld (de),a           ; set the state to pre-falling
189+  C944 1B               dec de              ; move back coords
190+  C945 C1               pop bc              ; get back coords
191+  C946 78               ld a,b
192+  C947 12               ld (de),a           ; store the vertical
193+  C948 1B               dec de
194+  C949 79               ld a,c
195+  C94A 12               ld (de),a           ; store the horizontal
196+  C94B C5               push bc
197+  C94C C3 52 C9         jp missiles_addmissiletofalling2 ; done
198+  C94F              missiles_addmissiletofalling1:
199+  C94F 13               inc de              ; move memory along to next rock
200+  C950 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
201+  C952              missiles_addmissiletofalling2: ; done, return
202+  C952 C1               pop bc              ; to tidy up
203+  C953 C9               ret
204+  C954
205+  C954              ;
206+  C954              ; Checks to see if the missile is hitting a player
207+  C954              ; Inputs:
208+  C954              ; bc - coords of missile we're checking
209+  C954              missiles_checkforplayer:
210+  C954 ED 5B 91 BE      ld de,(player)       ; get the player coords
211+  C958 7B               ld a,e               ; get the vert coord first
212+  C959 91               sub c                ; subtract the missile vertical coord from players
213+  C95A FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
214+  C95C C0               ret nz               ; if not, hasn't hit
215+  C95D 7A               ld a,d               ; get the player horiz coord
216+  C95E 90               sub b                ; subtract missile coord
217+  C95F C6 07            add 7                ; add max distance
218+  C961 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
219+  C963 DA 67 C9         jp c,missiles_checkforplayer0
220+  C966 C9               ret
221+  C967              missiles_checkforplayer0:
222+  C967 ED 43 FC C7      ld (missiles_killermissile),bc; store the coords of the killer missile
223+  C96B CD C0 BF         call player_zonkplayer ; if so, jump out
224+  C96E C9               ret
225+  C96F
226+  C96F              ;
227+  C96F              ; Player has been hit, so draw text over them and mark as dead
228+  C96F              ;
229+  C96F              missiles_zonkplayer:
230+  C96F CD AE BF         call player_killplayer      ; mark as dead
231+  C972 ED 4B 91 BE      ld bc,(player)              ; get player coords
232+  C976 CD 31 AA         call screen_getcharcoordsfromscreencoords
233+  C979 0D               dec c
234+  C97A 0D               dec c
235+  C97B 04               inc b
236+  C97C C5               push bc
237+  C97D 3E 42            ld a,66
238+  C97F CD 89 AA         call screen_setattr
239+  C982 0C               inc c
240+  C983 CD 89 AA         call screen_setattr
241+  C986 0C               inc c
242+  C987 CD 89 AA         call screen_setattr
243+  C98A 0C               inc c
244+  C98B CD 89 AA         call screen_setattr
245+  C98E 0C               inc c
246+  C98F CD 89 AA         call screen_setattr
247+  C992 C1               pop bc
248+  C993 ED 5B D1 A8      ld de,(screen_offset)
249+  C997 78               ld a,b
250+  C998 93               sub e
251+  C999 47               ld b,a                      ; subtract the offset
252+  C99A 04               inc b
253+  C99B 04               inc b                       ; add two for the score rows
254+  C99C ED 43 97 85      ld (string_zonk),bc         ; set coords of string
255+  C9A0 21 97 85         ld hl,string_zonk
256+  C9A3 CD 1F 86         call string_print
257+  C9A6 06 14            ld b,20
258+  C9A8 CD 58 81         call utilities_pauseforframes ; pause
259+  C9AB C9               ret
260+  C9AC
# file closed: game/missiles.asm
157   C9AC                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  C9AC              ;
  2+  C9AC              ; Timer for deciding how fast the trap withdraws
  3+  C9AC              ;
  4+  C9AC              thepit_timer:
  5+  C9AC 00               defb 0
  6+  C9AD
  7+  C9AD              ;
  8+  C9AD              ; Ticks for the trap state. Will count to 3 then reset
  9+  C9AD              ;
 10+  C9AD              thepit_trapcount:
 11+  C9AD 00               defb 0
 12+  C9AE
 13+  C9AE              ;
 14+  C9AE              ; The horizontal coordinate of the current pit trap
 15+  C9AE              ;
 16+  C9AE              thepit_trapcoord:
 17+  C9AE 08               defb 8
 18+  C9AF
 19+  C9AF              ;
 20+  C9AF              ; Initialises the pit
 21+  C9AF              ;
 22+  C9AF              thepit_init:
 23+  C9AF 21 AE C9         ld hl,thepit_trapcoord
 24+  C9B2 36 08            ld (hl),8
 25+  C9B4 21 AD C9         ld hl,thepit_trapcount
 26+  C9B7 36 00            ld (hl),0
 27+  C9B9 C9               ret
 28+  C9BA
 29+  C9BA              ;
 30+  C9BA              ; Performs per frame processing on the pit room
 31+  C9BA              ;
 32+  C9BA              thepit_process:
 33+  C9BA 3A A0 BE         ld a,(player_location)
 34+  C9BD FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 35+  C9BF C2 26 CA         jp nz,thepit_process0
 36+  C9C2 ED 4B 91 BE      ld bc,(player)                  ; get the player's coords to check if about to fall
 37+  C9C6 3E 08            ld a,8
 38+  C9C8 81               add a,c
 39+  C9C9 4F               ld c,a                          ; look at the square underneath
 40+  C9CA CD 31 AA         call screen_getcharcoordsfromscreencoords ; get the cell coords
 41+  C9CD CD BF AA         call screen_ischarempty
 42+  C9D0 FE 01            cp 1                            ; check if this is 1=empty
 43+  C9D2 CA 27 CA         jp z,thepit_process2
 44+  C9D5 3A AC C9         ld a,(thepit_timer)             ; get the timer
 45+  C9D8 3C               inc a
 46+  C9D9 32 AC C9         ld (thepit_timer),a             ; store
 47+  C9DC FE 02            cp 2                           ; have we reached the trigger?
 48+  C9DE C2 26 CA         jp nz, thepit_process0          ; no need to do anything
 49+  C9E1 3E 00            ld a,0
 50+  C9E3 32 AC C9         ld (thepit_timer),a             ; zero the timer and process
 51+  C9E6 3A AD C9         ld a,(thepit_trapcount)         ; get the current count
 52+  C9E9 3C               inc a
 53+  C9EA 32 AD C9         ld (thepit_trapcount),a         ; reset the trap count
 54+  C9ED FE 04            cp 4                            ; do we need to begin another character?
 55+  C9EF C2 0E CA         jp nz,thepit_process1           ; if not, draw as normal
 56+  C9F2 3E 00            ld a,0
 57+  C9F4 32 AD C9         ld (thepit_trapcount),a         ; reset the trap count
 58+  C9F7 3A AE C9         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 59+  C9FA FE 02            cp 2
 60+  C9FC CA 26 CA         jp z,thepit_process0
 61+  C9FF 4F               ld c,a
 62+  CA00 06 0A            ld b,10
 63+  CA02 3E 46            ld a,70
 64+  CA04 CD 89 AA         call screen_setattr             ; set the attr of the empty square to yellow on black
 65+  CA07 3A AE C9         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 66+  CA0A 3D               dec a
 67+  CA0B 32 AE C9         ld (thepit_trapcoord),a         ; store the reduced coord
 68+  CA0E
 69+  CA0E              thepit_process1:                    ; draw the trapdoor in current position
 70+  CA0E 3A AE C9         ld a,(thepit_trapcoord)
 71+  CA11 FE 02            cp 2
 72+  CA13 CA 26 CA         jp z, thepit_process0           ; don't process outside of the pit
 73+  CA16 4F               ld c,a
 74+  CA17 06 0A            ld b,10                         ; vertical coord will always be the same
 75+  CA19 3A AD C9         ld a,(thepit_trapcount)         ; get the trap count
 76+  CA1C 5F               ld e,a                          ; store in e
 77+  CA1D 3E 16            ld a,22                         ; 21 is full trapdoor
 78+  CA1F 83               add a,e
 79+  CA20 CD 7E AA         call screen_getblock
 80+  CA23 CD 5B AA         call screen_showchar            ; show the char
 81+  CA26
 82+  CA26              thepit_process0:
 83+  CA26 C9               ret
 84+  CA27              thepit_process2:
 85+  CA27 CD C6 BF         call player_pitkillplayer
 86+  CA2A C9               ret
 87+  CA2B
# file closed: game/thepit.asm
158   CA2B                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  CA2B
  2+  CA2B              ;
  3+  CA2B              ; Where the monster currently is
  4+  CA2B              ;
  5+  CA2B              monster_currentcoords:
  6+  CA2B 00 00            defb 0,0
  7+  CA2D
  8+  CA2D              ;
  9+  CA2D              ; The start coords of the monster
 10+  CA2D              ;
 11+  CA2D              monster_initcoords:
 12+  CA2D 70 1B            defb 112,27
 13+  CA2F
 14+  CA2F              ;
 15+  CA2F              ; Store the memory location of the current jump position
 16+  CA2F              ;
 17+  CA2F              monster_jumppos:
 18+  CA2F 00 00            defb 0,0
 19+  CA31
 20+  CA31              ;
 21+  CA31              ; The jump table for the monster.
 22+  CA31              ;
 23+  CA31              monster_jumptable:
 24+  CA31 FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  CA35 02 02 02 02
 24+  CA39 02 02 01 01
 24+  CA3D 01 01 01 01
 24+  CA41 FF
 25+  CA42
 26+  CA42              ;
 27+  CA42              ; The vertical direction: 0 up, 1 down
 28+  CA42              ;
 29+  CA42              monster_jumpdirectionvert:
 30+  CA42 00               defb 0
 31+  CA43
 32+  CA43              ;
 33+  CA43              ; The horiz direction: 0 right, 1 left
 34+  CA43              ;
 35+  CA43              monster_jumpdirectionhoriz:
 36+  CA43 00               defb 0
 37+  CA44
 38+  CA44              ;
 39+  CA44              ; Frame offset, 0 or 32
 40+  CA44              ;
 41+  CA44              monster_frameoffset:
 42+  CA44 00               defb 0
 43+  CA45
 44+  CA45              ;
 45+  CA45              ; Monster tick
 46+  CA45              ;
 47+  CA45              monster_tick:
 48+  CA45 00               defb 0
 49+  CA46
 50+  CA46              ;
 51+  CA46              ; Initialises the pit monster
 52+  CA46              ;
 53+  CA46              monster_init:
 54+  CA46 ED 4B 2D CA      ld bc,(monster_initcoords)              ; load the initial coords
 55+  CA4A ED 43 2B CA      ld (monster_currentcoords),bc           ; save in current coords
 56+  CA4E 21 32 CA         ld hl,monster_jumptable+1
 57+  CA51 22 2F CA         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 58+  CA54 3E 00            ld a,0
 59+  CA56 32 42 CA         ld (monster_jumpdirectionvert),a        ; going up
 60+  CA59 32 44 CA         ld (monster_frameoffset),a
 61+  CA5C 32 45 CA         ld (monster_tick),a
 62+  CA5F CD DF CA         call monster_draw                       ; the monster
 63+  CA62 C9               ret
 64+  CA63
 65+  CA63              ;
 66+  CA63              ; Animate the monster
 67+  CA63              ;
 68+  CA63              monster_process:
 69+  CA63 3A 45 CA         ld a,(monster_tick)                     ; check if we should draw this frame
 70+  CA66 FE 01            cp 1
 71+  CA68 CA 70 CA         jp z,monster_process6
 72+  CA6B 3C               inc a
 73+  CA6C 32 45 CA         ld (monster_tick),a                     ; increase the tick and continue
 74+  CA6F C9               ret
 75+  CA70              monster_process6:
 76+  CA70 3E 00            ld a,0
 77+  CA72 32 45 CA         ld (monster_tick),a                     ; zero the tick
 78+  CA75 CD DF CA         call monster_draw                       ; overwrite the old sprite
 79+  CA78 3A 44 CA         ld a,(monster_frameoffset)              ; get the anim frame offset
 80+  CA7B EE 20            xor 32                                  ; flip between 0 and 32
 81+  CA7D 32 44 CA         ld (monster_frameoffset),a              ; store
 82+  CA80 ED 4B 2B CA      ld bc,(monster_currentcoords)           ; get the current coords
 83+  CA84 2A 2F CA         ld hl,(monster_jumppos)                 ; get the position in the jump table
 84+  CA87 56               ld d,(hl)                               ; get the jump modifier
 85+  CA88 3A 42 CA         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 86+  CA8B FE 00            cp 0                                    ; if 0, going up, so dec vert
 87+  CA8D C2 96 CA         jp nz,monster_process0
 88+  CA90 79               ld a,c
 89+  CA91 92               sub d
 90+  CA92 23               inc hl                                  ; move forward a jump pos
 91+  CA93 C3 99 CA         jp monster_process1
 92+  CA96              monster_process0:
 93+  CA96 79               ld a,c                                   ; going down so inc c
 94+  CA97 82               add a,d
 95+  CA98 2B               dec hl                                  ; move back a jump pos
 96+  CA99              monster_process1:
 97+  CA99 4F               ld c,a                                  ; get the vertical coord back
 98+  CA9A 7E               ld a,(hl)                               ; check the next jump pos
 99+  CA9B FE FF            cp 255                                  ; if 255 reverse
100+  CA9D CA A6 CA         jp z,monster_process3
101+  CAA0 22 2F CA         ld (monster_jumppos),hl                 ; store the new pos
102+  CAA3 C3 AE CA         jp monster_process2                     ; keep going
103+  CAA6              monster_process3:
104+  CAA6 3A 42 CA         ld a,(monster_jumpdirectionvert)        ; get the direction
105+  CAA9 EE 01            xor 1                                   ; flip it
106+  CAAB 32 42 CA         ld (monster_jumpdirectionvert),a        ; store it
107+  CAAE              monster_process2:
108+  CAAE 3A 43 CA         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
109+  CAB1 FE 00            cp 0                                    ; is it right?
110+  CAB3 C2 C8 CA         jp nz,monster_process4
111+  CAB6 04               inc b                                   ; 1 pixel right
112+  CAB7 78               ld a,b
113+  CAB8 FE 38            cp 56                                   ; reached the edge of the pit?
114+  CABA C2 D7 CA         jp nz,monster_process5
115+  CABD 3A 43 CA         ld a,(monster_jumpdirectionhoriz)
116+  CAC0 EE 01            xor 1
117+  CAC2 32 43 CA         ld (monster_jumpdirectionhoriz),a       ; flip direction
118+  CAC5 C3 D7 CA         jp monster_process5
119+  CAC8              monster_process4:
120+  CAC8 05               dec b                                   ; 1 pixel left
121+  CAC9 78               ld a,b
122+  CACA FE 18            cp 24                                   ; reached the edge of the pit?
123+  CACC C2 D7 CA         jp nz,monster_process5
124+  CACF 3A 43 CA         ld a,(monster_jumpdirectionhoriz)
125+  CAD2 EE 01            xor 1
126+  CAD4 32 43 CA         ld (monster_jumpdirectionhoriz),a       ; flip direction
127+  CAD7              monster_process5:
128+  CAD7 ED 43 2B CA      ld (monster_currentcoords),bc           ; store the new vertical coords
129+  CADB CD DF CA         call monster_draw                       ; finally, draw the monster
130+  CADE C9               ret
131+  CADF
132+  CADF              ;
133+  CADF              ; Draw the monster at the current location
134+  CADF              ;
135+  CADF              monster_draw:
136+  CADF ED 4B 2B CA      ld bc,(monster_currentcoords)
137+  CAE3 3A 44 CA         ld a,(monster_frameoffset)
138+  CAE6 11 00 00         ld de,0
139+  CAE9 5F               ld e,a
140+  CAEA 21 BC B8         ld hl,monster_sprite                    ; load the first frame
141+  CAED 19               add hl,de
142+  CAEE CD 61 AB         call sprites_draw2by2sprite
143+  CAF1 C9               ret
# file closed: game/monster.asm
159   CAF2                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  CAF2
  2+  CAF2              ;
  3+  CAF2              ; Array of robot states
  4+  CAF2              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  CAF2              robots_robots:
  6+  CAF2 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  CAF6 00 00 00
  7+  CAF9 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  CAFD 00 00 00
  8+  CB00 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  CB04 00 00 00
  9+  CB07 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  CB0B 00 00 00
 10+  CB0E 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  CB12 00 00 00
 11+  CB15
 12+  CB15              robots_initcoords:
 13+  CB15 18 E8            defb 24,232
 14+  CB17
 15+  CB17              ;
 16+  CB17              ; When this reaches zero, spawn a new robot
 17+  CB17              ;
 18+  CB17              robots_spawntimer:
 19+  CB17 FA               defb 250
 20+  CB18
 21+  CB18              ;
 22+  CB18              ; When this reaches max, change the anim frame
 23+  CB18              ;
 24+  CB18              robots_animtimer:
 25+  CB18 00               defb 0
 26+  CB19
 27+  CB19              ;
 28+  CB19              ; When this reaches max, change move the robot
 29+  CB19              ;
 30+  CB19              robots_movetimer:
 31+  CB19 00               defb 0
 32+  CB1A
 33+  CB1A
 34+  CB1A              ;
 35+  CB1A              ; The number of robots active
 36+  CB1A              ;
 37+  CB1A              robots_numberactive:
 38+  CB1A 00               defb 0
 39+  CB1B
 40+  CB1B              ;
 41+  CB1B              ; Tracks which directions a robot can move
 42+  CB1B              ; up,down,left,right
 43+  CB1B              robots_canmovedirections:
 44+  CB1B 00 00 00 00      defb 0,0,0,0
 45+  CB1F
 46+  CB1F              ;
 47+  CB1F              ; The current robot speed
 48+  CB1F              ;
 49+  CB1F              robots_robotspeed:
 50+  CB1F 02               defb 2
 51+  CB20
 52+  CB20              ;
 53+  CB20              ; The current max robots
 54+  CB20              ;
 55+  CB20              robots_robotsmax:
 56+  CB20 02               defb 2
 57+  CB21
 58+  CB21              ;
 59+  CB21              ; Initialises the robots
 60+  CB21              ;
 61+  CB21              robots_init:
 62+  CB21 06 23            ld b,35
 63+  CB23 DD 21 F2 CA      ld ix,robots_robots
 64+  CB27              robots_init0:
 65+  CB27 DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 66+  CB2B DD 23            inc ix
 67+  CB2D 10 F8            djnz robots_init0
 68+  CB2F 3E 00            ld a,0
 69+  CB31 32 1A CB         ld (robots_numberactive),a
 70+  CB34 3E FA            ld a,250
 71+  CB36 32 17 CB         ld (robots_spawntimer),a
 72+  CB39                  ; Self writing code
 73+  CB39                  ; Robot speed
 74+  CB39 3A 1F CB         ld a,(robots_robotspeed)
 75+  CB3C 32 D6 CB         ld (robots_process7+1),a
 76+  CB3F 3C               inc a
 77+  CB40 32 06 CC         ld (robots_process6+1),a
 78+  CB43                  ; Robots max
 79+  CB43 3A 20 CB         ld a,(robots_robotsmax)
 80+  CB46 32 51 CB         ld (robots_spawn+1),a
 81+  CB49 32 A8 CB         ld (robots_process8+1),a
 82+  CB4C 32 C4 CB         ld (robots_process0+1),a
 83+  CB4F C9               ret
 84+  CB50
 85+  CB50              ;
 86+  CB50              ; Spawns a new robot
 87+  CB50              ; Inputs:
 88+  CB50              ; ix - pointer to start of robot array entry
 89+  CB50              ;
 90+  CB50              robots_spawn:
 91+  CB50 06 03            ld b,3                      ;(SELF WRITING CODE)
 92+  CB52 DD 21 F2 CA      ld ix,robots_robots
 93+  CB56              robots_spawn0:
 94+  CB56 DD 7E 02         ld a,(ix+2)                 ; get the state
 95+  CB59 FE 00            cp 0
 96+  CB5B C2 87 CB         jp nz,robots_spawn1         ; if already active, move on
 97+  CB5E ED 4B 15 CB      ld bc,(robots_initcoords)
 98+  CB62 DD 71 00 DD      ld (ix),bc
 98+  CB66 70 01
 99+  CB68 DD 36 02 01      ld (ix+2),1
100+  CB6C DD 36 03 00      ld (ix+3),0
101+  CB70 DD 36 04 00      ld (ix+4),0
102+  CB74 DD 36 05 00      ld (ix+5),0
103+  CB78 DD 36 06 00      ld (ix+6),0
104+  CB7C 3A 1A CB         ld a,(robots_numberactive)
105+  CB7F 3C               inc a
106+  CB80 32 1A CB         ld (robots_numberactive),a  ; increase the number active
107+  CB83 CD 3E CE         call robots_draw            ; draw initial frame
108+  CB86 C9               ret
109+  CB87              robots_spawn1:
110+  CB87 11 07 00         ld de,7
111+  CB8A DD 19            add ix,de
112+  CB8C 10 C8            djnz robots_spawn0
113+  CB8E C9               ret
114+  CB8F              ;
115+  CB8F              ; Kills robot
116+  CB8F              ; Inputs:
117+  CB8F              ; ix - pointer to start of robot array entry
118+  CB8F              ;
119+  CB8F              robots_kill:
120+  CB8F 3A 1A CB         ld a,(robots_numberactive)
121+  CB92 3D               dec a
122+  CB93 32 1A CB         ld (robots_numberactive),a
123+  CB96 DD 36 02 00      ld (ix+2),0                     ; set to inactive
124+  CB9A C5               push bc
125+  CB9B E5               push hl
126+  CB9C 06 01            ld b,1
127+  CB9E CD A7 C5         call scores_addhundreds
128+  CBA1 E1               pop hl
129+  CBA2 C1               pop bc
130+  CBA3 C9               ret
131+  CBA4
132+  CBA4              ;
133+  CBA4              ; Processes the robots
134+  CBA4              ;
135+  CBA4              robots_process:
136+  CBA4 3A 1A CB         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
137+  CBA7              robots_process8:
138+  CBA7 FE 03            cp 3                                    ; 3 is the maximum
139+  CBA9 CA C3 CB         jp z,robots_process0                    ; if already three, nothing to do
140+  CBAC 3A 17 CB         ld a,(robots_spawntimer)                ; now check the spawn timer
141+  CBAF FE 00            cp 0
142+  CBB1 C2 BF CB         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
143+  CBB4 3E FA            ld a,250
144+  CBB6 32 17 CB         ld (robots_spawntimer),a                ; reset the spawn timer
145+  CBB9 CD 50 CB         call robots_spawn                       ; spawn a robot
146+  CBBC C3 C3 CB         jp robots_process0                      ; carry on
147+  CBBF              robots_process1:
148+  CBBF 3D               dec a
149+  CBC0 32 17 CB         ld (robots_spawntimer),a                ; decrease the spawn timer and store
150+  CBC3              robots_process0:
151+  CBC3 06 03            ld b,3                                  ; max number of robots (SELF WRITING CODE)
152+  CBC5 DD 21 F2 CA      ld ix, robots_robots                    ; point ix at the robot array
153+  CBC9              robots_process2:
154+  CBC9 C5               push bc
155+  CBCA DD 7E 02         ld a,(ix+2)                             ; check the state
156+  CBCD FE 00            cp 0
157+  CBCF CA EB CB         jp z,robots_process3                    ; if not active, move on
158+  CBD2 3A 19 CB         ld a,(robots_movetimer)
159+  CBD5              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
160+  CBD5 FE 04            cp 4
161+  CBD7 C2 EB CB         jp nz,robots_process3                   ; can we move this frame
162+  CBDA CD 3E CE         call robots_draw                        ; draw over existing
163+  CBDD CD 10 CC         call robots_move                        ; move the
164+  CBE0 DD 7E 02         ld a,(ix+2)                             ; get the state again
165+  CBE3 FE 00            cp 0
166+  CBE5 CA EB CB         jp z,robots_process3                    ; move to next if this robot has become inactive
167+  CBE8 CD 3E CE         call robots_draw                        ; draw the new robot
168+  CBEB              robots_process3:
169+  CBEB C1               pop bc
170+  CBEC 11 07 00         ld de,7
171+  CBEF DD 19            add ix,de
172+  CBF1 10 D6            djnz robots_process2
173+  CBF3 3A 18 CB         ld a,(robots_animtimer)
174+  CBF6 3C               inc a
175+  CBF7 FE 08            cp 8
176+  CBF9 C2 FE CB         jp nz,robots_process4
177+  CBFC 3E 00            ld a,0                                  ; reset if we reached max
178+  CBFE              robots_process4:
179+  CBFE 32 18 CB         ld (robots_animtimer),a
180+  CC01 3A 19 CB         ld a,(robots_movetimer)                 ; increment the robot move timer
181+  CC04 3C               inc a
182+  CC05              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
183+  CC05 FE 05            cp 5                                    ; there is another reference to this number above
184+  CC07 C2 0C CC         jp nz,robots_process5
185+  CC0A 3E 00            ld a,0
186+  CC0C              robots_process5:
187+  CC0C 32 19 CB         ld (robots_movetimer),a
188+  CC0F
189+  CC0F C9               ret
190+  CC10
191+  CC10
192+  CC10              ;
193+  CC10              ; Moves a robot
194+  CC10              ; Inputs:
195+  CC10              ; ix - points to first byte of robot in array
196+  CC10              robots_move:
197+  CC10 DD 7E 02         ld a,(ix+2)                             ; get the state
198+  CC13 FE 02            cp 2
199+  CC15 CA 46 CC         jp z,robots_move4                       ; don't move if shot, just change the anim
200+  CC18 3A 18 CB         ld a,(robots_animtimer)                 ; get the anim timer
201+  CC1B FE 07            cp 7                                    ; compare with 8
202+  CC1D C2 30 CC         jp nz,robots_move1                       ; if even, don't increment frame
203+  CC20 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
204+  CC23 06 08            ld b,8
205+  CC25 80               add a,b                                 ; add to anim frame
206+  CC26 FE 20            cp 32
207+  CC28 C2 2D CC         jp nz,robots_move0                      ; if not 32, then just store
208+  CC2B 3E 00            ld a,0                                  ; otherwise, reset
209+  CC2D              robots_move0:
210+  CC2D DD 77 04         ld (ix+4),a                             ; store
211+  CC30              robots_move1:
212+  CC30 DD 7E 05         ld a,(ix+5)
213+  CC33 FE 00            cp 0                                    ; are we automoving
214+  CC35 CA 3E CC         jp z,robots_move2                       ; if not, keep directions
215+  CC38 CD 5A CC         call robots_automove
216+  CC3B C3 42 CC         jp robots_move3
217+  CC3E              robots_move2:
218+  CC3E CD 8F CC         call robots_checkdirectionsandmove
219+  CC41 C9               ret
220+  CC42              robots_move3:
221+  CC42 CD 87 CE         call robots_checkforplayer              ; check to see if we collided with a player
222+  CC45 C9               ret
223+  CC46              robots_move4:
224+  CC46 DD 7E 04         ld a,(ix+4)
225+  CC49 FE 48            cp 72
226+  CC4B C2 54 CC         jp nz,robots_move5
227+  CC4E 3E 40            ld a,64
228+  CC50 DD 77 04         ld (ix+4),a
229+  CC53 C9               ret
230+  CC54              robots_move5:
231+  CC54 3E 48            ld a,72
232+  CC56 DD 77 04         ld (ix+4),a
233+  CC59 C9               ret
234+  CC5A
235+  CC5A
236+  CC5A              ;
237+  CC5A              ; Processes automove
238+  CC5A              ; Inputs:
239+  CC5A              ; ix - points to the current robot
240+  CC5A              ; a - number of frames left to move
241+  CC5A              robots_automove:
242+  CC5A 3D               dec a
243+  CC5B DD 77 05         ld (ix+5),a                         ; store the decreased frames
244+  CC5E DD 4E 00 DD      ld bc,(ix)                          ; get coords
244+  CC62 46 01
245+  CC64 DD 7E 06         ld a,(ix+6)                         ; get the direction
246+  CC67 FE 00            cp 0                                ; left
247+  CC69 CA 7A CC         jp z,robots_automove1
248+  CC6C FE 02            cp 2                                ; up
249+  CC6E CA 7E CC         jp z,robots_automove3
250+  CC71 FE 03            cp 3                                ; down
251+  CC73 CA 83 CC         jp z,robots_automove4
252+  CC76 04               inc b                               ; right
253+  CC77 C3 88 CC         jp robots_automove2
254+  CC7A              robots_automove1:
255+  CC7A 05               dec b
256+  CC7B C3 88 CC         jp robots_automove2
257+  CC7E              robots_automove3:
258+  CC7E 0D               dec c
259+  CC7F 0D               dec c
260+  CC80 C3 88 CC         jp robots_automove2
261+  CC83              robots_automove4:
262+  CC83 0C               inc c
263+  CC84 0C               inc c
264+  CC85 C3 88 CC         jp robots_automove2
265+  CC88              robots_automove2:
266+  CC88 DD 71 00 DD      ld (ix),bc
266+  CC8C 70 01
267+  CC8E C9               ret
268+  CC8F
269+  CC8F              ;
270+  CC8F              ; Checks if a robot can move in all directions, then picks one and moves there.
271+  CC8F              ; This looks complicated, but really what it does is:
272+  CC8F              ; 1) Look at the current direction
273+  CC8F              ; 2) Randomly determine which orthoganal direction check first
274+  CC8F              ; 3) If orthogonal can't be moved, keep going in direction we're going
275+  CC8F              ; 4) Otherwise, back the way we came
276+  CC8F              ; Inputs:
277+  CC8F              ; ix - points to the current robot
278+  CC8F              ;
279+  CC8F              robots_checkdirectionsandmove:
280+  CC8F DD 7E 06         ld a,(ix+6)                 ; get the direction
281+  CC92 FE 00            cp 0                        ; left
282+  CC94 C2 BB CC         jp nz,robots_checkdirectionsandmove0
283+  CC97                  ; random check
284+  CC97 CD 80 BE         call game_getcurrentframe
285+  CC9A E6 01            and 1                       ; odd or even
286+  CC9C CA A8 CC         jp z,robots_checkdirectionsandmove3
287+  CC9F CD 41 CD         call robots_checkupthendown ; prefer up over down
288+  CCA2 FE 01            cp 1
289+  CCA4 C8               ret z
290+  CCA5 C3 AE CC         jp robots_checkdirectionsandmove4
291+  CCA8              robots_checkdirectionsandmove3:
292+  CCA8 CD 37 CD         call robots_checkdownthenup ; prefer down over up
293+  CCAB FE 01            cp 1
294+  CCAD C8               ret z
295+  CCAE              robots_checkdirectionsandmove4:
296+  CCAE                  ; check left
297+  CCAE CD C7 CD         call robots_checkleftandmove
298+  CCB1 FE 01            cp 1
299+  CCB3 C8               ret z                       ; if we moved, don't check again
300+  CCB4                  ; check right
301+  CCB4 CD 00 CE         call robots_checkrightandmove
302+  CCB7 FE 01            cp 1
303+  CCB9 C8               ret z                       ; if we moved, don't check again
304+  CCBA                  ; if we're here and haven't moved...
305+  CCBA C9               ret
306+  CCBB              robots_checkdirectionsandmove0
307+  CCBB FE 01            cp 1                        ; right
308+  CCBD C2 E4 CC         jp nz,robots_checkdirectionsandmove1
309+  CCC0                  ; ALREADY MOVING RIGHT
310+  CCC0                  ; random check
311+  CCC0 CD 80 BE         call game_getcurrentframe
312+  CCC3 E6 01            and 1                       ; odd or even
313+  CCC5 CA D1 CC         jp z,robots_checkdirectionsandmove5
314+  CCC8 CD 37 CD         call robots_checkdownthenup ; prefer down over up
315+  CCCB FE 01            cp 1
316+  CCCD C8               ret z
317+  CCCE C3 D7 CC         jp robots_checkdirectionsandmove6
318+  CCD1              robots_checkdirectionsandmove5:
319+  CCD1 CD 41 CD         call robots_checkupthendown ; prefer down over up
320+  CCD4 FE 01            cp 1
321+  CCD6 C8               ret z
322+  CCD7              robots_checkdirectionsandmove6:
323+  CCD7                  ; check right
324+  CCD7 CD 00 CE         call robots_checkrightandmove
325+  CCDA FE 01            cp 1
326+  CCDC C8               ret z                       ; if we moved, don't check again
327+  CCDD                  ; check left
328+  CCDD CD C7 CD         call robots_checkleftandmove
329+  CCE0 FE 01            cp 1
330+  CCE2 C8               ret z                       ; if we moved, don't check again
331+  CCE3                  ; if we're here and haven't moved...
332+  CCE3 C9               ret
333+  CCE4              robots_checkdirectionsandmove1
334+  CCE4 FE 02            cp 2                        ; up
335+  CCE6 C2 0D CD         jp nz,robots_checkdirectionsandmove2
336+  CCE9                  ; ALREADY MOVING UP
337+  CCE9                  ; random check
338+  CCE9 CD 80 BE         call game_getcurrentframe
339+  CCEC E6 01            and 1                       ; odd or even
340+  CCEE CA FA CC         jp z,robots_checkdirectionsandmove7
341+  CCF1 CD 57 CD         call robots_checkleftthenright ; prefer left over right
342+  CCF4 FE 01            cp 1
343+  CCF6 C8               ret z
344+  CCF7 C3 00 CD         jp robots_checkdirectionsandmove8
345+  CCFA              robots_checkdirectionsandmove7:
346+  CCFA CD 4D CD         call robots_checkrightthenleft ; prefer right over left
347+  CCFD FE 01            cp 1
348+  CCFF C8               ret z
349+  CD00              robots_checkdirectionsandmove8:
350+  CD00                  ; check up
351+  CD00 CD 63 CD         call robots_checkupandmove
352+  CD03 FE 01            cp 1
353+  CD05 C8               ret z                       ; if we moved, don't check again
354+  CD06                  ; check down
355+  CD06 CD 99 CD         call robots_checkdownandmove
356+  CD09 FE 01            cp 1
357+  CD0B C8               ret z                       ; if we moved, don't check again
358+  CD0C                  ; if we're here and haven't moved...
359+  CD0C C9               ret
360+  CD0D              robots_checkdirectionsandmove2
361+  CD0D                  ; ALREADY MOVING DOWN
362+  CD0D                  ; random check
363+  CD0D CD 80 BE         call game_getcurrentframe
364+  CD10 E6 01            and 1                       ; odd or even
365+  CD12 CA 1E CD         jp z,robots_checkdirectionsandmove9
366+  CD15 CD 4D CD         call robots_checkrightthenleft ; prefer right over left
367+  CD18 FE 01            cp 1
368+  CD1A C8               ret z
369+  CD1B C3 24 CD         jp robots_checkdirectionsandmove10
370+  CD1E              robots_checkdirectionsandmove9:
371+  CD1E CD 57 CD         call robots_checkleftthenright ; prefer left over right
372+  CD21 FE 01            cp 1
373+  CD23 C8               ret z
374+  CD24              robots_checkdirectionsandmove10:
375+  CD24                  ; check down
376+  CD24 CD 99 CD         call robots_checkdownandmove
377+  CD27 FE 01            cp 1
378+  CD29 C8               ret z                       ; if we moved, don't check again
379+  CD2A                  ; check right first
380+  CD2A CD 00 CE         call robots_checkrightandmove
381+  CD2D FE 01            cp 1
382+  CD2F C8               ret z                       ; if we moved, don't check again
383+  CD30                  ; check up
384+  CD30 CD 63 CD         call robots_checkupandmove
385+  CD33 FE 01            cp 1
386+  CD35 C8               ret z                       ; if we moved, don't check again
387+  CD36                  ; if we're here and haven't moved...
388+  CD36 C9               ret
389+  CD37
390+  CD37              ;
391+  CD37              ; Different orders of checking directions, for pseudo random motion
392+  CD37              ;
393+  CD37              robots_checkdownthenup:
394+  CD37                  ; check down
395+  CD37 CD 99 CD         call robots_checkdownandmove
396+  CD3A FE 01            cp 1
397+  CD3C C8               ret z                       ; if we moved, don't check again
398+  CD3D                  ; check up
399+  CD3D CD 63 CD         call robots_checkupandmove
400+  CD40 C9               ret
401+  CD41
402+  CD41              robots_checkupthendown:
403+  CD41                  ; check up
404+  CD41 CD 63 CD         call robots_checkupandmove
405+  CD44 FE 01            cp 1
406+  CD46 C8               ret z
407+  CD47                  ; check down
408+  CD47 CD 99 CD         call robots_checkdownandmove
409+  CD4A FE 01            cp 1
410+  CD4C C9               ret
411+  CD4D              robots_checkrightthenleft:
412+  CD4D                  ; check right
413+  CD4D CD 00 CE         call robots_checkrightandmove
414+  CD50 FE 01            cp 1
415+  CD52 C8               ret z                       ; if we moved, don't check again
416+  CD53                  ; check left
417+  CD53 CD C7 CD         call robots_checkleftandmove
418+  CD56 C9               ret
419+  CD57
420+  CD57              robots_checkleftthenright:
421+  CD57                  ; check left
422+  CD57 CD C7 CD         call robots_checkleftandmove
423+  CD5A FE 01            cp 1
424+  CD5C C8               ret z
425+  CD5D                  ; check right
426+  CD5D CD 00 CE         call robots_checkrightandmove
427+  CD60 FE 01            cp 1
428+  CD62 C9               ret
429+  CD63
430+  CD63              ;
431+  CD63              ; Checks up for movement
432+  CD63              ; Outputs:
433+  CD63              ; a - 1 if have moved
434+  CD63              robots_checkupandmove:
435+  CD63                  ; check above
436+  CD63 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
436+  CD67 46 01
437+  CD69 79               ld a,c
438+  CD6A FE 28            cp 40
439+  CD6C D8               ret c
440+  CD6D CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
441+  CD70 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
442+  CD72 11 20 00         ld de,32
443+  CD75 ED 52            sbc hl,de                       ; memory location of line above now in hl
444+  CD77 7E               ld a,(hl)                       ; get the contents of the line
445+  CD78 FE 00            cp 0
446+  CD7A C2 96 CD         jp nz,robots_checkupandmove0    ; can't move here so return
447+  CD7D DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
447+  CD81 46 01
448+  CD83 0D               dec c                       ; move up
449+  CD84 0D               dec c
450+  CD85 DD 71 00 DD      ld (ix),bc
450+  CD89 70 01
451+  CD8B DD 36 06 02      ld (ix+6),2
452+  CD8F DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
453+  CD93 3E 01            ld a,1
454+  CD95 C9               ret
455+  CD96              robots_checkupandmove0:
456+  CD96 3E 00            ld a,0
457+  CD98 C9               ret
458+  CD99
459+  CD99              ;
460+  CD99              ; Checks down for movement
461+  CD99              ; Outputs:
462+  CD99              ; a - 1 if have moved
463+  CD99              robots_checkdownandmove:
464+  CD99                  ; check below
465+  CD99 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
465+  CD9D 46 01
466+  CD9F CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
467+  CDA2 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
468+  CDA4 24               inc h                       ; memory location of cell beneath now in hl
469+  CDA5 7E               ld a,(hl)                       ; get the contents of the line
470+  CDA6 FE 00            cp 0
471+  CDA8 C2 C4 CD         jp nz,robots_checkdownandmove0    ; can't move here so return
472+  CDAB DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
472+  CDAF 46 01
473+  CDB1 0C               inc c                       ; move up
474+  CDB2 0C               inc c
475+  CDB3 DD 71 00 DD      ld (ix),bc
475+  CDB7 70 01
476+  CDB9 DD 36 06 03      ld (ix+6),3
477+  CDBD DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
478+  CDC1 3E 01            ld a,1
479+  CDC3 C9               ret
480+  CDC4              robots_checkdownandmove0:
481+  CDC4 3E 00            ld a,0
482+  CDC6 C9               ret
483+  CDC7
484+  CDC7              ;
485+  CDC7              ; Checks left for movement
486+  CDC7              ; Outputs:
487+  CDC7              ; a - 1 if have moved
488+  CDC7              robots_checkleftandmove:
489+  CDC7                  ; check below
490+  CDC7 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
490+  CDCB 46 01
491+  CDCD CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
492+  CDD0 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
493+  CDD2 78               ld a,b
494+  CDD3 06 08            ld b,8
495+  CDD5 90               sub b                           ; move one cell left
496+  CDD6 47               ld b,a
497+  CDD7 2B               dec hl                          ; memory location of cell to the right now in hl
498+  CDD8 CD 2A BC         call movement_spaceisempty       ; check space is empty
499+  CDDB 7B               ld a,e                          ; check space empty flag
500+  CDDC FE 00            cp 0
501+  CDDE CA FD CD         jp z,robots_checkleftandmove0    ; if zero can't move
502+  CDE1 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
502+  CDE5 46 01
503+  CDE7 05               dec b
504+  CDE8 DD 71 00 DD      ld (ix),bc
504+  CDEC 70 01
505+  CDEE DD 36 06 00      ld (ix+6),0
506+  CDF2 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
507+  CDF6 DD 36 03 00      ld (ix+3),0                 ; set to right
508+  CDFA 3E 01            ld a,1
509+  CDFC C9               ret
510+  CDFD              robots_checkleftandmove0:
511+  CDFD 3E 00            ld a,0
512+  CDFF C9               ret
513+  CE00
514+  CE00              ;
515+  CE00              ; Checks right for movement
516+  CE00              ; Outputs:
517+  CE00              ; a - 1 if have moved
518+  CE00              robots_checkrightandmove:
519+  CE00                  ; check below
520+  CE00 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
520+  CE04 46 01
521+  CE06 78               ld a,b
522+  CE07 FE E8            cp 232
523+  CE09 CA 3B CE         jp z,robots_checkrightandmove0  ; can't move if at edge
524+  CE0C CD F8 AB         call sprites_scadd              ; get the memory location of cell into de
525+  CE0F 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
526+  CE11 3E 08            ld a,8
527+  CE13 80               add b                           ; move one cell right
528+  CE14 47               ld b,a
529+  CE15 23               inc hl                          ; memory location of cell to the right now in hl
530+  CE16 CD 2A BC         call movement_spaceisempty       ; check space is empty
531+  CE19 7B               ld a,e                          ; check space empty flag
532+  CE1A FE 00            cp 0
533+  CE1C CA 3B CE         jp z,robots_checkrightandmove0    ; if zero can't move
534+  CE1F DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
534+  CE23 46 01
535+  CE25 04               inc b
536+  CE26 DD 71 00 DD      ld (ix),bc
536+  CE2A 70 01
537+  CE2C DD 36 06 01      ld (ix+6),1
538+  CE30 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
539+  CE34 DD 36 03 01      ld (ix+3),1                 ; set to right
540+  CE38 3E 01            ld a,1
541+  CE3A C9               ret
542+  CE3B              robots_checkrightandmove0:
543+  CE3B 3E 00            ld a,0
544+  CE3D C9               ret
545+  CE3E
546+  CE3E              ;
547+  CE3E              ; Draws a robot
548+  CE3E              ; Inputs:
549+  CE3E              ; ix - points to first byte of robot in array
550+  CE3E              robots_draw:
551+  CE3E DD 4E 00 DD      ld bc,(ix)
551+  CE42 46 01
552+  CE44 21 FC B8         ld hl,robot_sprite                      ; set to the robot sprite
553+  CE47 DD 7E 02         ld a,(ix+2)                             ; get the state
554+  CE4A FE 02            cp 2                                    ; is this dying
555+  CE4C CA 67 CE         jp z,robots_draw1
556+  CE4F              robots_draw3:
557+  CE4F DD 7E 03         ld a,(ix+3)                             ; get the direction
558+  CE52 FE 00            cp 0
559+  CE54 CA 5B CE         jp z,robots_draw0                       ; if left, nothing to do
560+  CE57 11 20 00         ld de,32
561+  CE5A 19               add hl,de                               ; add four frames to sprite
562+  CE5B              robots_draw0:
563+  CE5B DD 7E 04         ld a,(ix+4)                             ; get the anim frame
564+  CE5E 11 00 00         ld de,0
565+  CE61 5F               ld e,a
566+  CE62 19               add hl,de                               ; add to base
567+  CE63 CD 03 AB         call sprites_drawsprite
568+  CE66 C9               ret
569+  CE67              ;
570+  CE67              ; Dying
571+  CE67              ;
572+  CE67              robots_draw1:
573+  CE67 DD 7E 05         ld a,(ix+5)                             ; get anim frames
574+  CE6A FE 00            cp 0                                    ; if zero this is the first time around
575+  CE6C C2 77 CE         jp nz,robots_draw2
576+  CE6F 3E 18            ld a,24
577+  CE71 DD 77 05         ld (ix+5),a                             ; load up the anim frames
578+  CE74 C3 4F CE         jp robots_draw3                         ; return to main loop to draw as normal
579+  CE77              robots_draw2:
580+  CE77 3D               dec a
581+  CE78 DD 77 05         ld (ix+5),a
582+  CE7B FE 00            cp 0                                    ; have we reached the end yet
583+  CE7D C2 83 CE         jp nz, robots_draw4
584+  CE80 CD 8F CB         call robots_kill
585+  CE83              robots_draw4:
586+  CE83 C3 5B CE         jp robots_draw0
587+  CE86 C9               ret
588+  CE87
589+  CE87              ;
590+  CE87              ; Checks to see if the robot is hitting a player
591+  CE87              ; Inputs:
592+  CE87              ; ix - memory location of robot we're checking
593+  CE87              robots_checkforplayer:
594+  CE87 3A 9C BE         ld a,(player+11)     ; get player state
595+  CE8A FE 00            cp 0
596+  CE8C C0               ret nz               ; if already dying, don't kill again
597+  CE8D DD 4E 00 DD      ld bc,(ix)           ; get coords
597+  CE91 46 01
598+  CE93 ED 5B 91 BE      ld de,(player)       ; get the player coords
599+  CE97 7B               ld a,e               ; get the vert coord first
600+  CE98 91               sub c                ; subtract the diamond vertical coord from players
601+  CE99 C6 08            add 8                ; add the max distance
602+  CE9B FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
603+  CE9D D0               ret nc               ; if not, hasn't hit
604+  CE9E 7A               ld a,d               ; get the player horiz coord
605+  CE9F 90               sub b                ; subtract rock coord
606+  CEA0 C6 08            add 8                ; add max distance
607+  CEA2 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
608+  CEA4 D0               ret nc
609+  CEA5 DD 36 02 00      ld (ix+2),0          ; mark as inactive
610+  CEA9 CD CC BF         call player_robotkillplayer ; mark the player as killed
611+  CEAC C9               ret
# file closed: game/robots.asm
160   CEAD                  include "game\bullet.asm"
# file opened: game/bullet.asm
  1+  CEAD              ;
  2+  CEAD              ; Current state: x & y coords (screen), direction (0 left, 1 right), state
  3+  CEAD              ;
  4+  CEAD              bullet_state:
  5+  CEAD 00 00 00 00      defb 0,0,0,0
  6+  CEB1
  7+  CEB1              ;
  8+  CEB1              ; Initialise a the bullet
  9+  CEB1              ;
 10+  CEB1              bullet_init:
 11+  CEB1 DD 21 AD CE      ld ix,bullet_state
 12+  CEB5 DD 36 00 00      ld (ix),0
 13+  CEB9 DD 36 01 00      ld (ix+1),0
 14+  CEBD DD 36 02 00      ld (ix+2),0
 15+  CEC1 DD 36 03 00      ld (ix+3),0
 16+  CEC5 C9               ret
 17+  CEC6
 18+  CEC6              ;
 19+  CEC6              ; Shoots the bullet
 20+  CEC6              ;
 21+  CEC6              bullet_shoot:
 22+  CEC6 DD 21 AD CE      ld ix,bullet_state
 23+  CECA ED 4B 91 BE      ld bc,(player)              ; get the player coords
 24+  CECE 3A 93 BE         ld a,(player+2)             ; get the player direction
 25+  CED1 FE 01            cp 1                        ; going left?
 26+  CED3 CA E1 CE         jp z,bullet_shoot0
 27+  CED6 3E 08            ld a,8
 28+  CED8 80               add a,b                     ; going right so add eight to start coords
 29+  CED9 47               ld b,a
 30+  CEDA DD 36 02 01      ld (ix+2),1                 ; set right
 31+  CEDE C3 EA CE         jp bullet_shoot1
 32+  CEE1              bullet_shoot0:
 33+  CEE1 78               ld a,b
 34+  CEE2 06 08            ld b,8
 35+  CEE4 90               sub b
 36+  CEE5 47               ld b,a                      ; going left so subtract eight to start coords
 37+  CEE6 DD 36 02 00      ld (ix+2),0                 ; set right
 38+  CEEA              bullet_shoot1:
 39+  CEEA DD 71 00 DD      ld (ix),bc        ; store coords
 39+  CEEE 70 01
 40+  CEF0 DD 36 03 01      ld (ix+3),1       ; set state to 1
 41+  CEF4 CD 4A CF         call bullet_draw ; draw the initial frame
 42+  CEF7 C9               ret
 43+  CEF8
 44+  CEF8              ;
 45+  CEF8              ; Performs bullet processing
 46+  CEF8              ;
 47+  CEF8              bullet_process:
 48+  CEF8 3A B0 CE         ld a,(bullet_state+3)       ; get the state
 49+  CEFB FE 00            cp 0
 50+  CEFD C8               ret z                       ; don't draw if this has become inactive
 51+  CEFE CD 4A CF         call bullet_draw            ; delete current frame
 52+  CF01 CD 0E CF         call bullet_move            ; move the bullet
 53+  CF04 3A B0 CE         ld a,(bullet_state+3)       ; get the state
 54+  CF07 FE 00            cp 0
 55+  CF09 C8               ret z                       ; don't draw if this has become inactive
 56+  CF0A CD 4A CF         call bullet_draw            ; draw new frame
 57+  CF0D C9               ret
 58+  CF0E
 59+  CF0E              ;
 60+  CF0E              ; Moves the bullet, checking for collisions
 61+  CF0E              ;
 62+  CF0E              bullet_move:
 63+  CF0E DD 21 AD CE      ld ix,bullet_state
 64+  CF12 DD 4E 00 DD      ld bc,(ix)
 64+  CF16 46 01
 65+  CF18 DD 7E 02         ld a,(ix+2)                 ; get the direction
 66+  CF1B FE 00            cp 0                        ; going left?
 67+  CF1D CA 27 CF         jp z,bullet_move0
 68+  CF20 3E 08            ld a,8
 69+  CF22 80               add b
 70+  CF23 47               ld b,a                      ; add 8 since going right
 71+  CF24 C3 2C CF         jp bullet_move1
 72+  CF27              bullet_move0:
 73+  CF27 78               ld a,b
 74+  CF28 06 08            ld b,8
 75+  CF2A 90               sub b
 76+  CF2B 47               ld b,a                      ; subtract 8 since going left
 77+  CF2C              bullet_move1:
 78+  CF2C DD 71 00 DD      ld (ix),bc                  ; store new coords
 78+  CF30 70 01
 79+  CF32 C5               push bc
 80+  CF33 CD 57 CF         call bullets_checkforrobot
 81+  CF36 C1               pop bc
 82+  CF37 FE 01            cp 1                        ; if we hit a robot, keep moving
 83+  CF39 C8               ret z
 84+  CF3A CD F8 AB         call sprites_scadd          ; get memory loc of this block into de
 85+  CF3D 21 60 00         ld hl,96
 86+  CF40 19               add hl,de
 87+  CF41 7E               ld a,(hl)                   ; get the content
 88+  CF42 FE 00            cp 0
 89+  CF44 C8               ret z                       ; if empty, continue
 90+  CF45 DD 36 03 00      ld (ix+3),0                 ; otherwise, mark bullet as inactive
 91+  CF49 C9               ret
 92+  CF4A
 93+  CF4A              ;
 94+  CF4A              ; Draw the bullet
 95+  CF4A              ;
 96+  CF4A              bullet_draw:
 97+  CF4A ED 4B AD CE      ld bc,(bullet_state)        ; get coords
 98+  CF4E 3E 1B            ld a,27
 99+  CF50 CD 7E AA         call screen_getblock        ; get the block address
100+  CF53 CD 03 AB         call sprites_drawsprite     ; draw the sprite
101+  CF56 C9               ret
102+  CF57
103+  CF57              ;
104+  CF57              ; Checks to see if the robot is hitting a bullet
105+  CF57              ; Outputs:
106+  CF57              ; a = 0 if not robot hit
107+  CF57              ; a = 1 if robot not hit
108+  CF57              bullets_checkforrobot:
109+  CF57 3E 00            ld a,0
110+  CF59 32 AD CF         ld (bullets_tmp),a
111+  CF5C 3A 20 CB         ld a,(robots_robotsmax) ; robots to check
112+  CF5F 47               ld b,a
113+  CF60 FD 21 F2 CA      ld iy,robots_robots   ; start of robot array
114+  CF64              bullets_checkforrobot0:
115+  CF64 C5               push bc
116+  CF65 FD 7E 02         ld a,(iy+2)             ; get the state
117+  CF68 FE 01            cp 1
118+  CF6A C2 A1 CF         jp nz,bullets_checkforrobot1 ; if not active, don't check
119+  CF6D FD 5E 00 FD      ld de,(iy)              ; get robot coords
119+  CF71 56 01
120+  CF73 7A               ld a,d
121+  CF74 E6 F8            and 248                 ; get nearest multiple of 8
122+  CF76 57               ld d,a
123+  CF77 ED 4B AD CE      ld bc,(bullet_state)    ; get bullet coords
124+  CF7B 7A               ld a,d               ; get the player horiz coord
125+  CF7C 90               sub b                ; subtract robot coord
126+  CF7D FE 00            cp 0                ; should be the same
127+  CF7F C2 8B CF         jp nz,bullets_checkforrobot2 ; if not, might have hit, so check the next char along... if matched, check vert
128+  CF82 3E 08            ld a,8
129+  CF84 82               add a,d
130+  CF85 90               sub b                ; check again for the next char along
131+  CF86 FE 00            cp 0
132+  CF88 C2 A1 CF         jp nz,bullets_checkforrobot1 ; if not, haven't hit
133+  CF8B              bullets_checkforrobot2:
134+  CF8B 7B               ld a,e               ; get the vert coord
135+  CF8C 91               sub c                ; subtract the bullet vertical coord from robots
136+  CF8D C6 04            add 4                ; add the max distance
137+  CF8F FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
138+  CF91 D2 A1 CF         jp nc,bullets_checkforrobot1   ; if not, hasn't hit
139+  CF94 FD 36 02 02      ld (iy+2),2             ; mark the robot as killed
140+  CF98 FD 36 05 00      ld (iy+5),0             ; mark the anim frames as zero
141+  CF9C 3E 01            ld a,1
142+  CF9E 32 AD CF         ld (bullets_tmp),a      ; hit the flag to say we killed a robot
143+  CFA1              bullets_checkforrobot1:
144+  CFA1 11 07 00         ld de,7
145+  CFA4 FD 19            add iy,de              ; move to next robot
146+  CFA6 C1               pop bc
147+  CFA7 10 BB            djnz bullets_checkforrobot0
148+  CFA9 3A AD CF         ld a,(bullets_tmp)
149+  CFAC C9               ret
150+  CFAD
151+  CFAD              bullets_tmp:
152+  CFAD 00               defb 0
153+  CFAE
# file closed: game/bullet.asm
161   CFAE
162   CFAE              ;===========================================================================
163   CFAE              ; Stack.
164   CFAE              ;===========================================================================
165   CFAE
166   CFAE              ; Stack: this area is reserved for the stack
167   CFAE              STACK_SIZE: equ 100    ; in words
168   CFAE
169   CFAE              ; Reserve stack space
170   CFAE 00 00            defw 0  ; WPMEM, 2
171   CFB0              stack_bottom:
172   CFB0 00 00 00...      defs    STACK_SIZE*2, 0
173   D078              stack_top:
174   D078 00 00            defw 0  ; WPMEM, 2
175   D07A
176   D07A                     SAVESNA "./dist/ThePit.sna", main
177   D07A                     ;SAVETAP "./dist/ThePit.tap", main
# file closed: main.asm
