# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000                  ;call $0D6B
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 52 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 14+  800C
 15+  800C C9               ret
 16+  800D
 17+  800D              ;
 18+  800D              ;   Start coord
 19+  800D              ;   vert c, horiz b
 20+  800D              init_coord:
 21+  800D 18 30            defb 24,48
 22+  800F
 23+  800F              ;
 24+  800F              ; Number of lives to start
 25+  800F              ;
 26+  800F              init_lives:
 27+  800F 03               defb 3
 28+  8010
 29+  8010              ;
 30+  8010              ; Score to start
 31+  8010              ;
 32+  8010              init_score:
 33+  8010 30 30 30 30      defb '000000'
 33+  8014 30 30
# file closed: init.asm
 21   8016                  include "utilities.asm"
# file opened: utilities.asm
  1+  8016              ; ##########################################################################
  2+  8016              ; Print a character
  3+  8016              ; Inputs:
  4+  8016              ; b - x coord
  5+  8016              ; c - y coord
  6+  8016              ; d - character
  7+  8016              ; e - colour
  8+  8016              ; ##########################################################################
  9+  8016              utilities_print_char:
 10+  8016 7B               ld a,e
 11+  8017 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  801A 3E 16            ld a,22
 13+  801C D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  801D 78               ld a,b              ; Gets the X co-ordinate
 15+  801E 3D               dec a
 16+  801F D7               rst 16
 17+  8020 79               ld a,c              ; and the Y co-ordinate
 18+  8021 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8022 7A               ld a,d              ; ASCII code for udg.
 20+  8023 D7               rst 16              ; draw block.
 21+  8024 C9               ret
 22+  8025
 23+  8025
 24+  8025              ;Inputs:
 25+  8025              ;     DE and A are factors
 26+  8025              ;Outputs:
 27+  8025              ;     A is not changed
 28+  8025              ;     B is 0
 29+  8025              ;     C is not changed
 30+  8025              ;     DE is not changed
 31+  8025              ;     HL is the product
 32+  8025              ;Time:
 33+  8025              ;     342+6x
 34+  8025              ;
 35+  8025              utilities_multiply:
 36+  8025 06 08            ld b,8          ;7           7
 37+  8027 21 00 00         ld hl,0         ;10         10
 38+  802A 29               add hl,hl     ;11*8       88
 39+  802B 07               rlca          ;4*8        32
 40+  802C 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  802E 19                   add hl,de   ;--         --
 42+  802F 10 F9            djnz $-5      ;13*7+8     99
 43+  8031 C9               ret             ;10         10
 44+  8032
 45+  8032              utilities_waitforkey:
 46+  8032 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  8035 36 00            ld (hl),0           ; put null value there.
 48+  8037              utilities_waitforkey0:
 49+  8037 7E               ld a,(hl)           ; new value of LAST K.
 50+  8038 FE 00            cp 0                ; is it still zero?
 51+  803A 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  803C C9               ret                 ; key was pressed.
 53+  803D
 54+  803D              ;
 55+  803D              ; Waits number of frames for keypress. If got, returns 1, if not 0
 56+  803D              ; Inputs:
 57+  803D              ; a - number of frames to waits
 58+  803D              ; Ouputs:
 59+  803D              ; e - 0 not pressed, 1 pressed
 60+  803D              utilities_waitforkey_forframes:
 61+  803D 21 08 5C         ld hl,23560         ; LAST K system variable.
 62+  8040 36 00            ld (hl),0           ; put null value there.
 63+  8042 47               ld b,a              ; number of frames to wait
 64+  8043              utilities_waitforkey_forframes0:
 65+  8043 7E               ld a,(hl)           ; new value of LAST K.
 66+  8044 FE 00            cp 0                ; is it still zero?
 67+  8046 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 68+  8048 1E 01            ld e,1              ; set the pressed flag
 69+  804A C9               ret                 ; key was pressed.
 70+  804B              utilities_waitforkey_forframes1:
 71+  804B 76               halt                ; wait for frame
 72+  804C 76               halt                ; wait for frame
 73+  804D 10 F4            djnz utilities_waitforkey_forframes0 ; loop again
 74+  804F 1E 00            ld e,0              ; nothing pressed in time
 75+  8051 C9               ret
 76+  8052
 77+  8052              ;
 78+  8052              ; Clears the screen
 79+  8052              ; Inputs:
 80+  8052              ; a - attribute colour
 81+  8052              utilities_clearscreen:
 82+  8052 21 00 40         ld hl, 16384        ;pixels
 83+  8055 11 01 40         ld de, 16385        ;pixels + 1
 84+  8058 01 FF 17         ld bc, 6143         ;pixels area length - 1
 85+  805B 36 00            ld (hl), 0          ;set first byte to '0'
 86+  805D ED B0            ldir                ;copy bytes
 87+  805F
 88+  805F 21 00 58         ld hl,22528         ; attr
 89+  8062 11 01 58         ld de,22529         ; attr+1
 90+  8065 01 00 03         ld bc,768
 91+  8068 77               ld (hl),a
 92+  8069 ED B0            ldir
 93+  806B C9               ret
 94+  806C
# file closed: utilities.asm
 22   806C                  include "strings.asm"
# file opened: strings.asm
  1+  806C              string_score1:
  2+  806C 04 00 53 43      defb 4,0,'SCORE1',255
  2+  8070 4F 52 45 31
  2+  8074 FF
  3+  8075              string_scorenumbers1:
  4+  8075 04 01 30 30      defb 4,1,'000000',255
  4+  8079 30 30 30 30
  4+  807D FF
  5+  807E              string_company:
  6+  807E 0E 00 45 4E      defb 14,0,'ENV',255
  6+  8082 56 FF
  7+  8084              string_credits:
  8+  8084 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  8088 41 59 45 52
  8+  808C 20 31 FF
  9+  808F              string_score2:
 10+  808F 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8093 4F 52 45 32
 10+  8097 FF
 11+  8098              string_scorenumbers2:
 12+  8098 16 01 30 30      defb 22,1,'000000',255
 12+  809C 30 30 30 30
 12+  80A0 FF
 13+  80A1              string_titlescreen_copyright:
 14+  80A1 04 16 7F 20      defb 4,22, 127,' 1982 AW ZILEC ELC LTD',255
 14+  80A5 31 39 38 32
 14+  80A9 20 41 57 20
 14+  80AD 5A 49 4C 45
 14+  80B1 43 20 45 4C
 14+  80B5 43 20 4C 54
 14+  80B9 44 FF
 15+  80BB
 16+  80BB
 17+  80BB              string_alttitlescreen_1:
 18+  80BB 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  80BF 45 44 49 54
 18+  80C3 53 20 31 FF
 19+  80C7              string_alttitlescreen_2:
 20+  80C7 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  80CB 20 20 20 20
 20+  80CF 20 20 20 20
 20+  80D3 20 54 48 45
 20+  80D7 20 4F 42 4A
 20+  80DB 45 43 54 FE
 21+  80DF 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  80E3 20 20 20 20
 21+  80E7 20 20 20 20
 21+  80EB 4F 46 20 54
 21+  80EF 48 49 53 20
 21+  80F3 47 41 4D 45
 21+  80F7 FE
 22+  80F8 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  80FC 20 20 20 20
 22+  8100 20 20 20 49
 22+  8104 53 20 54 4F
 22+  8108 20 44 49 47
 22+  810C 20 44 4F 57
 22+  8110 4E FE
 23+  8112 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  8116 20 20 20 20
 23+  811A 20 20 54 4F
 23+  811E 20 54 48 45
 23+  8122 20 42 4F 54
 23+  8126 54 4F 4D 20
 23+  812A 50 49 54 FE
 24+  812E 00 06 20 20      defb 0,6,'               AND',254
 24+  8132 20 20 20 20
 24+  8136 20 20 20 20
 24+  813A 20 20 20 20
 24+  813E 20 41 4E 44
 24+  8142 FE
 25+  8143 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  8147 20 20 20 20
 25+  814B 20 20 43 4F
 25+  814F 4C 4C 45 43
 25+  8153 54 20 41 54
 25+  8157 20 4C 45 41
 25+  815B 53 54 FE
 26+  815E 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  8162 20 20 20 20
 26+  8166 20 20 20 4F
 26+  816A 4E 45 20 4C
 26+  816E 41 52 47 45
 26+  8172 20 4A 45 57
 26+  8176 45 4C FE
 27+  8179 00 09 20 20      defb 0,9,'              THEN',254
 27+  817D 20 20 20 20
 27+  8181 20 20 20 20
 27+  8185 20 20 20 20
 27+  8189 54 48 45 4E
 27+  818D FE
 28+  818E 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  8192 20 20 20 20
 28+  8196 20 20 20 52
 28+  819A 45 54 55 52
 28+  819E 4E 20 54 4F
 28+  81A2 20 53 48 49
 28+  81A6 50 FE
 29+  81A8 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  81AC 20 20 20 20
 29+  81B0 20 20 20 54
 29+  81B4 48 52 55 20
 29+  81B8 55 50 50 45
 29+  81BC 52 20 50 49
 29+  81C0 54 FF
 30+  81C2              string_alttitlescreen_3:
 31+  81C2 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  81C6 20 20 53 49
 31+  81CA 4E 47 4C 45
 31+  81CE 20 42 4F 4E
 31+  81D2 55 53 20 20
 31+  81D6 35 30 30 30
 31+  81DA 20 50 4F 49
 31+  81DE 4E 54 53 FE
 32+  81E2 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  81E6 20 20 20 20
 32+  81EA 43 4F 4C 4C
 32+  81EE 45 43 54 20
 32+  81F2 31 20 4C 41
 32+  81F6 52 47 45 20
 32+  81FA 4A 45 57 45
 32+  81FE 4C FE
 33+  8200 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  8204 20 20 20 20
 33+  8208 20 41 4E 44
 33+  820C 20 52 45 54
 33+  8210 55 52 4E 20
 33+  8214 54 4F 20 53
 33+  8218 48 49 50 FE
 34+  821C 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  8220 20 20 44 4F
 34+  8224 55 42 4C 45
 34+  8228 20 42 4F 4E
 34+  822C 55 53 20 20
 34+  8230 31 30 30 30
 34+  8234 30 20 50 4F
 34+  8238 49 4E 54 53
 34+  823C FE
 35+  823D 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  8241 20 20 43 4F
 35+  8245 4C 4C 45 43
 35+  8249 54 20 41 4C
 35+  824D 4C 20 33 20
 35+  8251 4C 41 52 47
 35+  8255 45 20 4A 45
 35+  8259 57 45 4C 53
 35+  825D FE
 36+  825E 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  8262 20 20 20 20
 36+  8266 20 4F 52 20
 36+  826A 20 20 41 4C
 36+  826E 4C 20 34 20
 36+  8272 53 4D 41 4C
 36+  8276 4C 20 4A 45
 36+  827A 57 45 4C 53
 36+  827E FE
 37+  827F 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  8283 20 20 54 52
 37+  8287 49 50 4C 45
 37+  828B 20 42 4F 4E
 37+  828F 55 53 20 20
 37+  8293 31 35 30 30
 37+  8297 30 20 50 4F
 37+  829B 49 4E 54 53
 37+  829F FE
 38+  82A0 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  82A4 20 20 20 20
 38+  82A8 20 43 4F 4C
 38+  82AC 4C 45 43 54
 38+  82B0 20 41 4C 4C
 38+  82B4 20 37 20 4A
 38+  82B8 45 57 45 4C
 38+  82BC 53 FF
 39+  82BE
 40+  82BE              string_lifescreen_player:
 41+  82BE 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  82C2 4C 41 59 45
 41+  82C6 52 20 31 20
 41+  82CA FF
 42+  82CB              string_lifescreen_lives:
 43+  82CB 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  82CF 4D 45 4E 20
 43+  82D3 4C 45 46 54
 43+  82D7 FF
 44+  82D8
 45+  82D8              ;
 46+  82D8              ; Prints specified string
 47+  82D8              ; Inputs:
 48+  82D8              ; de: pointer to string
 49+  82D8              ; bc: length of string
 50+  82D8              ;
 51+  82D8              ; Print String Data
 52+  82D8              ; First two bytes of string contain X and Y char position, then the string
 53+  82D8              ; Individual strings are terminated with 0xFE
 54+  82D8              ; End of data is terminated with 0xFF
 55+  82D8              ; HL: Address of string
 56+  82D8              ;
 57+  82D8 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
 58+  82D9 23                                   INC HL                          ; Increase HL to the next memory location
 59+  82DA 56                                   LD D,(HL)                       ; Fetch the Y coordinate
 60+  82DB 23                                   INC HL                          ; Increase HL to the next memory location
 61+  82DC CD EF 82                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
 62+  82DF 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
 63+  82E0 23                                   INC HL                          ; Increase HL to the next character
 64+  82E1 FE FE                                CP 0xFE                         ; Compare with 0xFE
 65+  82E3 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
 66+  82E5 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
 67+  82E6 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
 68+  82E7 CD FF 82                             CALL Print_Char                 ; Print the character
 69+  82EA E1                                   POP HL                          ; Retrieve HL back off the stack
 70+  82EB 1C                                   INC E                           ; Go to the next screen address
 71+  82EC 18 F1                                JR string_print_0               ; Loop back to print next character
 72+  82EE C9                                   RET
 73+  82EF
 74+  82EF              ; Get screen address
 75+  82EF              ; D = Y character position
 76+  82EF              ; E = X character position
 77+  82EF              ; Returns address in DE
 78+  82EF              ;
 79+  82EF 7A           string_getcharaddress:       LD A,D
 80+  82F0 E6 07                                AND %00000111
 81+  82F2 1F                                   RRA
 82+  82F3 1F                                   RRA
 83+  82F4 1F                                   RRA
 84+  82F5 1F                                   RRA
 85+  82F6 B3                                   OR E
 86+  82F7 5F                                   LD E,A
 87+  82F8 7A                                   LD A,D
 88+  82F9 E6 18                                AND %00011000
 89+  82FB F6 40                                OR %01000000
 90+  82FD 57                                   LD D,A
 91+  82FE C9                                   RET                             ; Returns screen address in DE
 92+  82FF
 93+  82FF              ; Print a single character out
 94+  82FF              ; A:  Character to print
 95+  82FF              ; DE: Screen address to print character at
 96+  82FF              ;
 97+  82FF 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
 98+  8302 06 00                                LD B,0                          ; Set BC to A
 99+  8304 4F                                   LD C,A
100+  8305 E6 FF                                AND 0xFF                        ; Clear the carry bit
101+  8307 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
102+  8309 CB 10                                RL B
103+  830B CB 11                                RL C
104+  830D CB 10                                RL B
105+  830F CB 11                                RL C
106+  8311 CB 10                                RL B
107+  8313 09                                   ADD HL,BC                       ; Get the character address in HL
108+  8314 0E 08                                LD C,8                          ; Loop counter
109+  8316 D5                                   PUSH DE
110+  8317 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
111+  8318 12                                   LD (DE),A                       ; Stick A onto the screen
112+  8319 14                                   INC D                           ; Goto next line on screen
113+  831A 2C                                   INC L                           ; Goto next byte of character
114+  831B 0D                                   DEC C                           ; Decrease the loop counter
115+  831C 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
116+  831E D1                                   POP DE
117+  831F C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   8320                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  8320              buffer_buffer:
  2+  8320 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A020
  4+  A020              buffer_attr_buffer:
  5+  A020 00 00 00...      defs 928                    ; attrs buffer area
  6+  A3C0
  7+  A3C0              buffer_tmp:
  8+  A3C0 00 00            defb 0,0                    ; temp area
  9+  A3C2
 10+  A3C2              buffer_updatedlines:
 11+  A3C2 FF FF FF...      defs 21,255
 12+  A3D7
 13+  A3D7              buffer_updateall:
 14+  A3D7 00               defb 0
 15+  A3D8
 16+  A3D8              ;
 17+  A3D8              ; Stores a line number in the update list
 18+  A3D8              ; Inputs:
 19+  A3D8              ; a - row number
 20+  A3D8              buffer_marklineforupdate:
 21+  A3D8 5F               ld e,a                          ; store in e
 22+  A3D9 06 15            ld b,21
 23+  A3DB 21 C2 A3         ld hl,buffer_updatedlines
 24+  A3DE              buffer_marklineforupdate0:
 25+  A3DE 7E               ld a,(hl)                       ; get the line stored in updated lines
 26+  A3DF BB               cp e                            ; is this the same as the row number passed in?
 27+  A3E0 C8               ret z                           ; if so, don't need to do anything
 28+  A3E1 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 29+  A3E3 C2 E8 A3         jp nz,buffer_marklineforupdate1 ; if not, move to next
 30+  A3E6 73               ld (hl),e                       ; if it is, this spot is empty, so store the row number
 31+  A3E7 C9               ret                             ; and finish
 32+  A3E8              buffer_marklineforupdate1:
 33+  A3E8 23               inc hl
 34+  A3E9 10 F3            djnz buffer_marklineforupdate0
 35+  A3EB C9               ret
 36+  A3EC
 37+  A3EC              ;
 38+  A3EC              ; Zeroes the updated lines list
 39+  A3EC              ;
 40+  A3EC              buffer_clearlist:
 41+  A3EC 06 15            ld b,21
 42+  A3EE 21 C2 A3         ld hl,buffer_updatedlines
 43+  A3F1              buffer_clearlist0:
 44+  A3F1 36 FF            ld (hl),255
 45+  A3F3 23               inc hl
 46+  A3F4 10 FB            djnz buffer_clearlist0
 47+  A3F6 C9               ret
 48+  A3F7
 49+  A3F7              ;
 50+  A3F7              ; Copies the buffer to the screen. Use stack.
 51+  A3F7              ; Inputs:
 52+  A3F7              ; a - row number to display - 0 is first line
 53+  A3F7              ;
 54+  A3F7              buffer_bufferlinetoscreen:
 55+  A3F7 4F               ld c,a                          ; store a
 56+  A3F8 ED 5B 25 A5      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 57+  A3FC 83               add a,e                       ; add the row number
 58+  A3FD 11 00 01         ld de,256
 59+  A400 CD 25 80         call utilities_multiply
 60+  A403 54 5D            ld de,hl
 61+  A405 21 20 83         ld hl,buffer_buffer
 62+  A408 19               add hl,de                   ; add the offset
 63+  A409 79               ld a,c                      ; get original row back
 64+  A40A ED 73 68 A4      ld (buffer_bufferlinetoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
 65+  A40E D9               exx
 66+  A40F 0E 00            ld c,0                      ; zero horizontal
 67+  A411 47               ld b,a                      ; load the row number into vertical coord
 68+  A412 04               inc b
 69+  A413 04               inc b                       ; move forward 2 to allow for scores
 70+  A414 CD 06 A6         call screen_getcelladdress  ; get the memory into de
 71+  A417 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
 72+  A41A 19               add hl,de
 73+  A41B              buffer_bufferlinetoscreen0:
 74+  A41B D9               exx                         ; hl is now buffer
 75+  A41C 23               inc hl
 76+  A41D 23               inc hl                      ; move hl forward 2 to skip first two blocks
 77+  A41E F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
 78+  A41F F1               pop af
 79+  A420 C1               pop bc
 80+  A421 D1               pop de
 81+  A422 DD E1            pop ix
 82+  A424 D9               exx                         ; hl is now screen
 83+  A425 08               ex af,af'
 84+  A426 F1               pop af
 85+  A427 C1               pop bc
 86+  A428 D1               pop de
 87+  A429 F9               ld sp,hl                    ; sp pointing at screen
 88+  A42A D5               push de
 89+  A42B C5               push bc
 90+  A42C F5               push af
 91+  A42D 08               ex af,af'
 92+  A42E D9               exx                         ; hl is now buffer
 93+  A42F DD E5            push ix
 94+  A431 D5               push de
 95+  A432 C5               push bc
 96+  A433 F5               push af
 97+  A434 1E 0E            ld e,14                    ; do another fourteen for right hand side
 98+  A436 16 00            ld d,0
 99+  A438 19               add hl,de
100+  A439 F9               ld sp,hl                    ; sp pointing at buffer
101+  A43A F1               pop af
102+  A43B C1               pop bc
103+  A43C D1               pop de
104+  A43D DD E1            pop ix
105+  A43F                  ;pop ix
106+  A43F D9               exx                         ; hl is now screen
107+  A440 08               ex af,af'
108+  A441 1E 0E            ld e,14
109+  A443 16 00            ld d,0
110+  A445 19               add hl,de
111+  A446 F1               pop af
112+  A447 C1               pop bc
113+  A448 D1               pop de
114+  A449                  ;pop iy
115+  A449 F9               ld sp,hl                    ; sp pointing at screen
116+  A44A                  ;push iy
117+  A44A D5               push de
118+  A44B C5               push bc
119+  A44C F5               push af
120+  A44D 08               ex af,af'
121+  A44E D9               exx                         ; hl is now buffer
122+  A44F DD E5            push ix
123+  A451 D5               push de
124+  A452 C5               push bc
125+  A453 F5               push af
126+  A454 1E 10            ld e,16
127+  A456 16 00            ld d,0
128+  A458 19               add hl,de
129+  A459 D9               exx                         ; hl is now screen
130+  A45A 1E 0E            ld e,14
131+  A45C 16 00            ld d,0
132+  A45E ED 52            sbc hl,de
133+  A460 24               inc h
134+  A461 7C               ld a,h
135+  A462 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
136+  A464 C2 1B A4         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
137+  A467              buffer_bufferlinetoscreen1:
138+  A467 31 00 00         ld sp,0
139+  A46A D9               exx
140+  A46B C9               ret
141+  A46C
142+  A46C              ;
143+  A46C              ; Copies the buffer to the screen for updated lines. Use stack.
144+  A46C              ; Inputs: none
145+  A46C              ;
146+  A46C              buffer_buffertoscreen:
147+  A46C 3A D7 A3         ld a,(buffer_updateall)      ; get the all update flag
148+  A46F FE 00            cp 0
149+  A471 CA 7D A4         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
150+  A474 CD 9E A4         call buffer_allbuffertoscreen ; otherwise, draw whole screen
151+  A477 21 D7 A3         ld hl,buffer_updateall
152+  A47A 36 00            ld (hl),0                    ; reset flag
153+  A47C C9               ret
154+  A47D              buffer_buffertoscreen2:
155+  A47D 06 15            ld b,21
156+  A47F FD 21 C2 A3      ld iy,buffer_updatedlines    ; the location of the updated lines
157+  A483              buffer_buffertoscreen0:
158+  A483 FD 7E 00         ld a,(iy)
159+  A486 FE FF            cp 255
160+  A488 CA 9A A4         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
161+  A48B C5               push bc
162+  A48C FD E5            push iy
163+  A48E F3               di
164+  A48F CD F7 A3         call buffer_bufferlinetoscreen
165+  A492 FB               ei
166+  A493 FD E1            pop iy
167+  A495 C1               pop bc
168+  A496 FD 23            inc iy
169+  A498 10 E9            djnz buffer_buffertoscreen0
170+  A49A              buffer_buffertoscreen1:
171+  A49A CD B2 A4         call buffer_buffertoattrsfast
172+  A49D C9               ret
173+  A49E
174+  A49E              ;
175+  A49E              ; Copies the buffer to the screen. Use stack.
176+  A49E              ; Inputs: none
177+  A49E              ;
178+  A49E              buffer_allbuffertoscreen:
179+  A49E 06 15            ld b,21
180+  A4A0 3E 00            ld a,0
181+  A4A2              buffer_allbuffertoscreen0:
182+  A4A2 C5               push bc
183+  A4A3 F5               push af
184+  A4A4 F3               di
185+  A4A5 CD F7 A3         call buffer_bufferlinetoscreen
186+  A4A8 FB               ei
187+  A4A9 F1               pop af
188+  A4AA C1               pop bc
189+  A4AB 3C               inc a
190+  A4AC 10 F4            djnz buffer_allbuffertoscreen0
191+  A4AE
192+  A4AE CD B2 A4         call buffer_buffertoattrsfast
193+  A4B1 C9               ret
194+  A4B2
195+  A4B2              ;
196+  A4B2              ; Copies the attrs buffer to screen with the stack
197+  A4B2              ;
198+  A4B2              buffer_buffertoattrsfast:
199+  A4B2 ED 73 21 A5      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
200+  A4B6 3A 25 A5         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
201+  A4B9 11 20 00         ld de,32
202+  A4BC CD 25 80         call utilities_multiply
203+  A4BF 54 5D            ld de,hl
204+  A4C1 21 20 A0         ld hl,buffer_attr_buffer
205+  A4C4 19               add hl,de                       ; add the offset, start of attr buffer now in hl
206+  A4C5 D9               exx
207+  A4C6 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
208+  A4C9 FD 21 C0 A3      ld iy,buffer_tmp
209+  A4CD FD 36 00 15      ld (iy),21              ; number of times to loop
210+  A4D1              buffer_buffertoattrsfast0:
211+  A4D1 D9               exx                         ; hl is now buffer
212+  A4D2 23               inc hl
213+  A4D3 23               inc hl                      ; move hl forward 2 to skip first two blocks
214+  A4D4 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
215+  A4D5 F1               pop af
216+  A4D6 C1               pop bc
217+  A4D7 D1               pop de
218+  A4D8 DD E1            pop ix
219+  A4DA D9               exx                         ; hl is now screen
220+  A4DB 08               ex af,af'
221+  A4DC F1               pop af
222+  A4DD C1               pop bc
223+  A4DE D1               pop de
224+  A4DF F9               ld sp,hl                    ; sp pointing at screen
225+  A4E0 D5               push de
226+  A4E1 C5               push bc
227+  A4E2 F5               push af
228+  A4E3 08               ex af,af'
229+  A4E4 D9               exx                         ; hl is now buffer
230+  A4E5 DD E5            push ix
231+  A4E7 D5               push de
232+  A4E8 C5               push bc
233+  A4E9 F5               push af
234+  A4EA 1E 0E            ld e,14                    ; do another fourteen for right hand side
235+  A4EC 16 00            ld d,0
236+  A4EE 19               add hl,de
237+  A4EF F9               ld sp,hl                    ; sp pointing at buffer
238+  A4F0 F1               pop af
239+  A4F1 C1               pop bc
240+  A4F2 D1               pop de
241+  A4F3 DD E1            pop ix
242+  A4F5 D9               exx                         ; hl is now screen
243+  A4F6 08               ex af,af'
244+  A4F7 1E 0E            ld e,14
245+  A4F9 16 00            ld d,0
246+  A4FB 19               add hl,de
247+  A4FC F1               pop af
248+  A4FD C1               pop bc
249+  A4FE D1               pop de
250+  A4FF F9               ld sp,hl                    ; sp pointing at screen
251+  A500 D5               push de
252+  A501 C5               push bc
253+  A502 F5               push af
254+  A503 08               ex af,af'
255+  A504 D9               exx                         ; hl is now buffer
256+  A505 DD E5            push ix
257+  A507 D5               push de
258+  A508 C5               push bc
259+  A509 F5               push af
260+  A50A 1E 10            ld e,16
261+  A50C 16 00            ld d,0
262+  A50E 19               add hl,de
263+  A50F D9               exx                         ; hl is now screen
264+  A510 11 12 00         ld de,18
265+  A513 19               add hl,de
266+  A514 FD 7E 00         ld a,(iy)
267+  A517 3D               dec a
268+  A518 FE 00            cp 0
269+  A51A FD 77 00         ld (iy),a
270+  A51D C2 D1 A4         jp nz,buffer_buffertoattrsfast0 ; do another row
271+  A520              buffer_buffertoattrsfast1:
272+  A520 31 00 00         ld sp,0
273+  A523 D9               exx
274+  A524 C9               ret
# file closed: screen/buffer.asm
 24   A525                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A525              screen_offset:
  2+  A525 00               defb 0                      ; offset from top of screen in lines
  3+  A526
  4+  A526              screen_tmp:
  5+  A526 00               defb 0                      ; temporary memory
  6+  A527
  7+  A527              screen_setscorecolours:
  8+  A527 21 F0 AD         ld hl,score_colours
  9+  A52A 11 00 58         ld de,22528                     ; attrs here
 10+  A52D 01 40 00         ld bc,64
 11+  A530 ED B0            ldir
 12+  A532 C9               ret
 13+  A533
 14+  A533              screen_sethighscorecolours:
 15+  A533 21 30 AE         ld hl,high_score_colours
 16+  A536 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A539 01 20 00         ld bc,32
 18+  A53C ED B0            ldir
 19+  A53E C9               ret
 20+  A53F
 21+  A53F              ; Draw the screen
 22+  A53F              ; Inputs:
 23+  A53F              ; none
 24+  A53F              ; Notes:
 25+  A53F              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A53F              screen_draw:
 27+  A53F                  ;call clear_screen
 28+  A53F 0E 00            ld c,0                      ; horiz
 29+  A541 06 00            ld b,0                      ; vert, 0 at top
 30+  A543 DD 21 B2 A8      ld ix,level01               ; point ix at level data
 31+  A547 FD 21 20 A0      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A54B              screen_draw0:
 33+  A54B DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A54E C5               push bc                     ; store bc, contains loop count
 35+  A54F CD 8D A6         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A552 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A553 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A556 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A559 CD 82 A6         call screen_getblock        ; get the block data into hl
 40+  A55C CD 68 A6         call screen_showchar        ; show this character here
 41+  A55F C1               pop bc                      ; get the loop counter back
 42+  A560 DD 23            inc ix                      ; increment level location
 43+  A562 FD 23            inc iy                      ; increment attr location
 44+  A564 0C               inc c                       ; increment horiz
 45+  A565 79               ld a,c
 46+  A566 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A568 C2 4B A5         jp nz,screen_draw0          ; if not, loop
 48+  A56B 0E 00            ld c,0                      ; if so, reset horiz
 49+  A56D 04               inc b                       ; increment vertical
 50+  A56E 78               ld a,b
 51+  A56F FE 1D            cp 29                       ; check if at bottom
 52+  A571 C2 4B A5         jp nz,screen_draw0          ; if not, loop
 53+  A574 21 26 A5         ld hl, screen_tmp
 54+  A577 36 09            ld (hl),9                   ; load the block number into memory
 55+  A579 DD 21 52 AC      ld ix,level01rocks          ; rock memory
 56+  A57D CD D6 A5         call screen_initobjects     ; draw rocks
 57+  A580 21 26 A5         ld hl, screen_tmp
 58+  A583 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A585 DD 21 52 AD      ld ix,level01missiles       ; missile memory
 60+  A589 CD D6 A5         call screen_initobjects     ; draw missiles
 61+  A58C 21 26 A5         ld hl, screen_tmp
 62+  A58F 36 08            ld (hl),08                  ; load the block number into memory
 63+  A591 DD 21 CB AD      ld ix,level01diamonds       ; diamond memory
 64+  A595 CD D6 A5         call screen_initobjects     ; draw diamonds
 65+  A598 21 26 A5         ld hl, screen_tmp
 66+  A59B 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A59D DD 21 DB AD      ld ix,level01gems           ; gems memory
 68+  A5A1 CD D6 A5         call screen_initobjects     ; draw gems
 69+  A5A4 CD A8 A5         call screen_setuptext       ; draws text on the screen
 70+  A5A7 C9               ret
 71+  A5A8
 72+  A5A8              ;
 73+  A5A8              ; Sets up text on the screen
 74+  A5A8              ;
 75+  A5A8              screen_setuptext:
 76+  A5A8 CD C1 B7         call scores_showtable
 77+  A5AB CD 33 A5         call screen_sethighscorecolours
 78+  A5AE 21 6C 80         ld hl, string_score1
 79+  A5B1 CD D8 82         call string_print
 80+  A5B4 21 75 80         ld hl, string_scorenumbers1
 81+  A5B7 CD D8 82         call string_print
 82+  A5BA 21 7E 80         ld hl, string_company
 83+  A5BD CD D8 82         call string_print
 84+  A5C0 21 8F 80         ld hl, string_score2
 85+  A5C3 CD D8 82         call string_print
 86+  A5C6 21 98 80         ld hl, string_scorenumbers2
 87+  A5C9 CD D8 82         call string_print
 88+  A5CC 21 84 80         ld hl, string_credits
 89+  A5CF CD D8 82         call string_print
 90+  A5D2 CD 27 A5         call screen_setscorecolours
 91+  A5D5 C9               ret
 92+  A5D6              ;
 93+  A5D6              ; Draw initial object positions
 94+  A5D6              ; Inputs:
 95+  A5D6              ; ix - memory location of objects
 96+  A5D6              ; a - graphic
 97+  A5D6              screen_initobjects:
 98+  A5D6 DD 4E 00         ld c,(ix)                   ; get the horiz coord
 99+  A5D9 79               ld a,c
100+  A5DA FE FF            cp 255
101+  A5DC CA 05 A6         jp z,screen_initobjects2
102+  A5DF DD 23            inc ix                      ; move to next
103+  A5E1 DD 46 00         ld b,(ix)                   ; get the vert coord
104+  A5E4 DD 23            inc ix
105+  A5E6 CD 17 A6         call screen_getcellattradress ; get the memory address of b,c attr into de
106+  A5E9 D5               push de
107+  A5EA 3A 26 A5         ld a,(screen_tmp)                  ; get the block number back
108+  A5ED CD 8D A6         call screen_getattr         ; get the memory location for this cell's attr into hl
109+  A5F0 D1               pop de
110+  A5F1 7E               ld a,(hl)                   ; get the attr value at the address
111+  A5F2 12               ld (de),a                   ; load the attr into memory
112+  A5F3 3A 26 A5         ld a,(screen_tmp)                  ; get the block number back
113+  A5F6 CD 82 A6         call screen_getblock        ; get the block data into hl
114+  A5F9 CD 68 A6         call screen_showchar        ; show this character here
115+  A5FC
116+  A5FC              screen_initobjects1:
117+  A5FC DD 23            inc ix                      ; move past state
118+  A5FE DD 23            inc ix
119+  A600 DD 23            inc ix                      ; move past mem
120+  A602 C3 D6 A5         jp screen_initobjects
121+  A605              screen_initobjects2:
122+  A605 C9               ret
123+  A606
124+  A606
125+  A606              ;
126+  A606              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
127+  A606              ; Inputs:
128+  A606              ; bc: coords
129+  A606              ; Outputs:
130+  A606              ; de: memory location
131+  A606              ;
132+  A606              screen_getcelladdress:
133+  A606 78               ld a,b      ; vertical position.
134+  A607 E6 18            and 24      ; which segment, 0, 1 or 2?
135+  A609 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
136+  A60B 57               ld d,a      ; this is our high byte.
137+  A60C 78               ld a,b      ; what was that vertical position again?
138+  A60D E6 07            and 7       ; which row within segment?
139+  A60F 0F               rrca        ; multiply row by 32.
140+  A610 0F               rrca
141+  A611 0F               rrca
142+  A612 5F               ld e,a      ; low byte.
143+  A613 79               ld a,c      ; add on y coordinate.
144+  A614 83               add a,e     ; mix with low byte.
145+  A615 5F               ld e,a      ; address of screen position in de.
146+  A616 C9               ret
147+  A617
148+  A617              ;
149+  A617              ; Calculate buffer address of attribute for character at (b, c).
150+  A617              ; Inputs:
151+  A617              ; bc: coords
152+  A617              ; Outputs:
153+  A617              ; de: memory location
154+  A617              ;
155+  A617              screen_getcellattradress:
156+  A617 11 20 A0         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
157+  A61A 69               ld l,c      ; x position.
158+  A61B 26 00            ld h,0      ; 0 h
159+  A61D 19               add hl,de
160+  A61E 54 5D            ld de,hl    ; horiz done
161+  A620 78               ld a,b      ; do vert
162+  A621 D5               push de
163+  A622 C5               push bc
164+  A623 11 20 00         ld de,32
165+  A626 CD 25 80         call utilities_multiply
166+  A629 C1               pop bc
167+  A62A D1               pop de
168+  A62B 19               add hl,de
169+  A62C 54 5D            ld de,hl    ; vert done
170+  A62E C9               ret
171+  A62F
172+  A62F              ;
173+  A62F              ; Calculate buffer address of attribute for character at (b, c).
174+  A62F              ; Inputs:
175+  A62F              ; bc: coords
176+  A62F              ; Outputs:
177+  A62F              ; de: memory location
178+  A62F              ;
179+  A62F              screen_getscreenattradress:
180+  A62F 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
181+  A632 69               ld l,c      ; x position.
182+  A633 26 00            ld h,0      ; 0 h
183+  A635 19               add hl,de
184+  A636 54 5D            ld de,hl    ; horiz done
185+  A638 78               ld a,b      ; do vert
186+  A639 D5               push de
187+  A63A C5               push bc
188+  A63B 11 20 00         ld de,32
189+  A63E CD 25 80         call utilities_multiply
190+  A641 C1               pop bc
191+  A642 D1               pop de
192+  A643 19               add hl,de
193+  A644 54 5D            ld de,hl    ; vert done
194+  A646 C9               ret
195+  A647
196+  A647              ;
197+  A647              ; Gets the attr memory location for a screen coord
198+  A647              ; Will overwrite bc
199+  A647              ; Inputs:
200+  A647              ; bc - screen coords
201+  A647              ; Outputs:
202+  A647              ; de - memory location
203+  A647              ; bc - character coords
204+  A647              ;
205+  A647              screen_getattraddressfromscreencoords:
206+  A647 78               ld a,b                          ; get the player block coords of current block
207+  A648 E6 F8            and 248                         ; find closest multiple of eight
208+  A64A 0F               rrca
209+  A64B 0F               rrca
210+  A64C 0F               rrca                ; divide by 8
211+  A64D 47               ld b,a
212+  A64E 79               ld a,c
213+  A64F 48               ld c,b                         ; swap b and c
214+  A650 E6 F8            and 248
215+  A652 0F               rrca
216+  A653 0F               rrca
217+  A654 0F               rrca                ; divide by 8
218+  A655 47               ld b,a
219+  A656 CD 17 A6         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
220+  A659 C9               ret
221+  A65A
222+  A65A              ;
223+  A65A              ; Get buffer address for a character at b,c - b vert
224+  A65A              ; Buffer memory is stored as sequential block
225+  A65A              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
226+  A65A              ; Inputs:
227+  A65A              ; bc - coords
228+  A65A              ; Outputs:
229+  A65A              ; de - memory location of first byte
230+  A65A              screen_getbufferaddress:
231+  A65A 21 20 83         ld hl, buffer_buffer    ; first get screen buffer start
232+  A65D 50               ld d,b                  ; then work out vertical offset
233+  A65E 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
234+  A660 19               add hl,de               ; add to base
235+  A661 59               ld e,c                  ; then add horizontal offset (c)
236+  A662 16 00            ld d,0
237+  A664 19               add hl,de               ; add to base
238+  A665 54 5D            ld de,hl
239+  A667 C9               ret
240+  A668
241+  A668              ;
242+  A668              ; Display character hl at (b, c) to buffer.
243+  A668              ; Stored sequentially
244+  A668              ; Inputs:
245+  A668              ; hl: block address
246+  A668              ; bc: coords
247+  A668              ;
248+  A668              screen_showchar:
249+  A668 3E 00            ld a,0
250+  A66A E5               push hl
251+  A66B CD 5A A6         call screen_getbufferaddress ; get the current screen buffer pointer
252+  A66E E1               pop hl
253+  A66F 06 08            ld b,8              ; number of pixels high.
254+  A671              screen_showchar0:
255+  A671 7E               ld a,(hl)           ; source graphic.
256+  A672 12               ld (de),a           ; transfer to screen.
257+  A673 23               inc hl              ; next piece of data.
258+  A674 E5               push hl             ; store hl
259+  A675 62 6B            ld hl,de            ; put de in hl
260+  A677 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
261+  A679 16 00            ld d,0
262+  A67B 19               add hl,de              ; add de to hl
263+  A67C 54 5D            ld de,hl            ; load back to de
264+  A67E E1               pop hl              ; restore hl
265+  A67F
266+  A67F 10 F0            djnz screen_showchar0 ; repeat
267+  A681 C9               ret
268+  A682
269+  A682
270+  A682              ;
271+  A682              ; Get cell graphic.
272+  A682              ; Inputs:
273+  A682              ; a: block
274+  A682              ; Outputs:
275+  A682              ; hl: memory
276+  A682              ;
277+  A682              screen_getblock:
278+  A682 07               rlca                        ; multiply block number by eight.
279+  A683 07               rlca
280+  A684 07               rlca
281+  A685 5F               ld e,a                      ; displacement to graphic address.
282+  A686 16 00            ld d,0                      ; no high byte.
283+  A688 21 50 AE         ld hl,sprites               ; address of character blocks.
284+  A68B 19               add hl,de                   ; point to block.
285+  A68C C9               ret
286+  A68D
287+  A68D              ;
288+  A68D              ; Get cell attribute.
289+  A68D              ; Inputs:
290+  A68D              ; a: block
291+  A68D              ; Outputs:
292+  A68D              ; hl: memory
293+  A68D              ;
294+  A68D              screen_getattr:
295+  A68D 5F               ld e,a                      ; displacement to attribute address.
296+  A68E 16 00            ld d,0                      ; no high byte.
297+  A690 21 C8 AE         ld hl,sprite_attrs          ; address of block attributes.
298+  A693 19               add hl,de                   ; point to attribute.
299+  A694 C9               ret
300+  A695
# file closed: screen/screen.asm
 25   A695                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A695              ;
  2+  A695              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A695              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A695              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A695              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A695              ; routine takes care of all the shifting itself. This means that sprite
  7+  A695              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A695              ; space they would require in pre-shifted form.
  9+  A695              ; Inputs:
 10+  A695              ; hl - sprite data
 11+  A695              ; bc - screen coords
 12+  A695              ;
 13+  A695              sprites_drawsprite7:
 14+  A695 EE 07            xor 7               ; complement last 3 bits.
 15+  A697 3C               inc a               ; add one for luck!
 16+  A698              sprites_drawsprite3:
 17+  A698 CB 11            rl c                ; ...into middle byte...
 18+  A69A CB 12            rl d                ; ...and finally into left character cell.
 19+  A69C 3D               dec a               ; count shifts we've done.
 20+  A69D 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A69F                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A69F 79               ld a,c              ; left edge of image is currently in e.
 23+  A6A0 4A               ld c,d              ; put right edge there instead.
 24+  A6A1 57               ld d,a              ; and the left edge back into c.
 25+  A6A2 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A6A4              sprites_drawsprite:
 27+  A6A4 ED 43 09 A7      ld (dispx),bc       ; store coords in dispx for now.
 28+  A6A8 E5               push hl
 29+  A6A9 CD E7 A6         call sprites_scadd  ; calculate screen address.
 30+  A6AC E1               pop hl
 31+  A6AD 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A6AF              sprites_drawsprite1:
 33+  A6AF 08               ex af,af'           ; store loop counter.
 34+  A6B0 D5               push de             ; store screen address.
 35+  A6B1 4E               ld c,(hl)           ; first sprite graphic.
 36+  A6B2 23               inc hl              ; increment poiinter to sprite data.
 37+  A6B3 22 0B A7         ld (sprtmp),hl      ; store it for later.
 38+  A6B6 16 00            ld d,0              ; blank right byte for now.
 39+  A6B8 78               ld a,b              ; b holds y position.
 40+  A6B9 E6 07            and 7               ; how are we straddling character cells?
 41+  A6BB 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A6BD FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A6BF 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A6C1 A7               and a               ; oops, carry flag is set so clear it.
 45+  A6C2              sprites_drawsprite2:
 46+  A6C2 CB 19            rr c                ; rotate left byte right...
 47+  A6C4 CB 1A            rr d                ; ...into right byte.
 48+  A6C6 3D               dec a               ; one less shift to do.
 49+  A6C7 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A6C9              sprites_drawsprite0:
 51+  A6C9 E1               pop hl              ; pop screen address from stack.
 52+  A6CA 7E               ld a,(hl)           ; what's there already.
 53+  A6CB A9               xor c               ; merge in image data.
 54+  A6CC 77               ld (hl),a           ; place onto screen.
 55+  A6CD 23               inc hl
 56+  A6CE 7E               ld a,(hl)           ; what's already there.
 57+  A6CF AA               xor d               ; right edge of sprite image data.
 58+  A6D0 77               ld (hl),a           ; plonk it on screen.
 59+  A6D1 3A 09 A7         ld a,(dispx)        ; vertical coordinate.
 60+  A6D4 3C               inc a               ; next line down.
 61+  A6D5 32 09 A7         ld (dispx),a        ; store new position.
 62+  A6D8 2B               dec hl
 63+  A6D9 11 20 00         ld de,32            ; add 32 to get to the next row
 64+  A6DC 19               add hl,de           ; add 32
 65+  A6DD              sprites_drawsprite6:
 66+  A6DD EB               ex de,hl            ; screen address in de.
 67+  A6DE 2A 0B A7         ld hl,(sprtmp)      ; restore graphic address.
 68+  A6E1 08               ex af,af'           ; restore loop counter.
 69+  A6E2 3D               dec a               ; decrement it.
 70+  A6E3 C2 AF A6         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 71+  A6E6 C9               ret                 ; job done.
 72+  A6E7
 73+  A6E7              ;
 74+  A6E7              ; This routine returns a buffer address for (c, b) in de (c vert).
 75+  A6E7              ; For example: 0,0 will be at memory offset 0
 76+  A6E7              ; 1,0 (1 down) will be at memory offset 1
 77+  A6E7              ; 0,7 will be at memory offset 0
 78+  A6E7              ; 9,1 will be at memory offset 8+1
 79+  A6E7              ; 8,0 will be at memory offset 256
 80+  A6E7              ; 9,0 will be at memory offset 257
 81+  A6E7              ; Outputs:
 82+  A6E7              ; de - coords
 83+  A6E7              ;
 84+  A6E7              sprites_scadd:
 85+  A6E7 79               ld a,c               ; calculate vertical offset
 86+  A6E8 E6 F8            and 248             ;  to get nearest multiple of 8
 87+  A6EA 0F               rrca
 88+  A6EB 0F               rrca
 89+  A6EC 0F               rrca                ; divide by 8
 90+  A6ED 67               ld h,a
 91+  A6EE 78               ld a,b               ; calculate horizontal offset
 92+  A6EF E6 F8            and 248             ;  to get nearest multiple of 8
 93+  A6F1 0F               rrca
 94+  A6F2 0F               rrca
 95+  A6F3 0F               rrca                ; divide by 8
 96+  A6F4 6F               ld l,a
 97+  A6F5 C5               push bc             ; store the screen coords
 98+  A6F6 44 4D            ld bc,hl            ; load bc with the character coords
 99+  A6F8 CD 5A A6         call screen_getbufferaddress
100+  A6FB C1               pop bc              ; get back screen coords, de is now memory of character
101+  A6FC 79               ld a,c              ; now add the vertical within the cell
102+  A6FD E6 07            and 7
103+  A6FF 0F               rrca                ; multiply by 32.
104+  A700 0F               rrca
105+  A701 0F               rrca
106+  A702 6F               ld l,a
107+  A703 26 00            ld h,0
108+  A705 19               add hl,de
109+  A706 54 5D            ld de,hl
110+  A708 C9               ret
111+  A709
112+  A709 00           dispx   defb 0           ; general-use coordinates.
113+  A70A 00           dispy   defb 0
114+  A70B 00           sprtmp  defb 0           ; sprite temporary address.
115+  A70C
# file closed: screen/sprites.asm
 26   A70C                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  A70C              ;
  2+  A70C              ; Draws the title screen
  3+  A70C              ;
  4+  A70C              titlescreen_show:
  5+  A70C CD 83 A7         call titlescreen_init
  6+  A70F CD 2D A7         call titlescreen_drawtitle
  7+  A712 3E FA            ld a,250                              ; wait for 200 frames
  8+  A714 CD 3D 80         call utilities_waitforkey_forframes   ; wait for keypress
  9+  A717 7B               ld a,e
 10+  A718 FE 01            cp 1                                  ; was anything pressed?
 11+  A71A C8               ret z                                 ; end titlescreen if so
 12+  A71B
 13+  A71B CD 96 A7         call titlescreen_alt_init             ; otherwise, draw alt screen
 14+  A71E CD 49 A7         call titlescreen_alt_drawtitle
 15+  A721 3E FA            ld a,250                              ; wait for 200 frames
 16+  A723 CD 3D 80         call utilities_waitforkey_forframes   ; wait for keypress
 17+  A726 7B               ld a,e
 18+  A727 FE 01            cp 1                                  ; was anything pressed?
 19+  A729 C2 0C A7         jp nz,titlescreen_show                ; start again if not
 20+  A72C C9               ret
 21+  A72D
 22+  A72D              ;
 23+  A72D              ; Draws the iconic logo
 24+  A72D              ;
 25+  A72D              titlescreen_drawtitle:
 26+  A72D 06 66            ld b,102              ; number of points
 27+  A72F DD 21 A3 A7      ld ix,titlescreen_logo_data
 28+  A733              titlescreen_drawtitle0:
 29+  A733 C5               push bc
 30+  A734 DD 4E 00         ld c,(ix)                   ; got horiz
 31+  A737 DD 23            inc ix
 32+  A739 DD 46 00         ld b,(ix)                   ; got vert
 33+  A73C DD 23            inc ix
 34+  A73E CD 2F A6         call screen_getscreenattradress ; memory in de
 35+  A741 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 36+  A742 3E 13            ld a,19
 37+  A744 12               ld (de),a
 38+  A745 C1               pop bc
 39+  A746 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 40+  A748 C9               ret
 41+  A749
 42+  A749              ;
 43+  A749              ; Draws the alternate title screen
 44+  A749              ;
 45+  A749              titlescreen_alt_drawtitle:
 46+  A749 21 BB 80         ld hl,string_alttitlescreen_1
 47+  A74C CD D8 82         call string_print
 48+  A74F 21 C7 80         ld hl,string_alttitlescreen_2
 49+  A752 CD D8 82         call string_print
 50+  A755 21 C2 81         ld hl,string_alttitlescreen_3
 51+  A758 CD D8 82         call string_print
 52+  A75B 3E 43            ld a,67
 53+  A75D 11 00 58         ld de,22528                         ; top row attrs here
 54+  A760 CD 7C A7         call titlescreen_alt_setcolours
 55+  A763 3E 46            ld a,70
 56+  A765 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 57+  A768 CD 7C A7         call titlescreen_alt_setcolours
 58+  A76B 3E 43            ld a,67
 59+  A76D 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 60+  A770 CD 7C A7         call titlescreen_alt_setcolours
 61+  A773 3E 42            ld a,66
 62+  A775 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 63+  A778 CD 7C A7         call titlescreen_alt_setcolours
 64+  A77B C9               ret
 65+  A77C
 66+  A77C              titlescreen_alt_setcolours:
 67+  A77C 06 20            ld b,32
 68+  A77E              titlescreen_alt_setcolours0:
 69+  A77E 12               ld (de),a
 70+  A77F 13               inc de
 71+  A780 10 FC            djnz titlescreen_alt_setcolours0
 72+  A782 C9               ret
 73+  A783
 74+  A783              ;
 75+  A783              ; Initialises the screen
 76+  A783              ;
 77+  A783              titlescreen_init:
 78+  A783              ; We want a black screen.
 79+  A783                  ;call $0D6B
 80+  A783 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 81+  A785                                      ; bright (64).
 82+  A785 CD 52 80         call utilities_clearscreen
 83+  A788 32 8D 5C         ld (23693),a        ; set our screen colours.
 84+  A78B 3E 01            ld a,1              ; 2 is the code for red.
 85+  A78D D3 FE            out (254),a         ; write to port 254.
 86+  A78F                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 87+  A78F
 88+  A78F 21 A1 80         ld hl,string_titlescreen_copyright
 89+  A792 CD D8 82         call string_print
 90+  A795
 91+  A795 C9               ret
 92+  A796
 93+  A796              ;
 94+  A796              ; Initialises the screen
 95+  A796              ;
 96+  A796              titlescreen_alt_init:
 97+  A796              ; We want a black screen.
 98+  A796                  ;call $0D6B
 99+  A796 3E 47            ld a,71             ; white ink (7) on black paper (0),
100+  A798                                      ; bright (64).
101+  A798 CD 52 80         call utilities_clearscreen
102+  A79B 32 8D 5C         ld (23693),a        ; set our screen colours.
103+  A79E 3E 00            ld a,0              ; 2 is the code for red.
104+  A7A0 D3 FE            out (254),a         ; write to port 254.
105+  A7A2                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
106+  A7A2
107+  A7A2
108+  A7A2 C9               ret
109+  A7A3
110+  A7A3              ;
111+  A7A3              ; Horiz, vert
112+  A7A3              ;
113+  A7A3              titlescreen_logo_data:
114+  A7A3 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
114+  A7A7 0A 00 0C 00
114+  A7AB 0F 00 11 00
114+  A7AF 12 00 13 00
115+  A7B3 09 01 0C 01      defb 9,1,12,1,15,1,17,1
115+  A7B7 0F 01 11 01
116+  A7BB 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
116+  A7BF 0D 02 0E 02
116+  A7C3 0F 02 11 02
116+  A7C7 12 02 13 02
117+  A7CB 09 03 0C 03      defb 9,3,12,3,15,3,17,3
117+  A7CF 0F 03 11 03
118+  A7D3 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
118+  A7D7 0F 04 11 04
118+  A7DB 12 04 13 04
119+  A7DF 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
119+  A7E3 02 06 03 06
119+  A7E7 04 06 05 06
119+  A7EB 06 06 07 06
119+  A7EF 08 06 09 06
119+  A7F3 0A 06 0B 06
120+  A7F7 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
120+  A7FB 12 06 13 06
120+  A7FF 14 06 15 06
120+  A803 16 06 17 06
120+  A807 18 06 19 06
120+  A80B 1A 06 1B 06
121+  A80F 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20
121+  A813 02 09 02 0A
121+  A817 02 0B 02 0C
121+  A81B 02 0D 02 0E
121+  A81F 02 0F 02 10
121+  A823 02 11 02 12
121+  A827 02 13 02 14
122+  A82B 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20
122+  A82F 19 09 19 0A
122+  A833 19 0B 19 0C
122+  A837 19 0D 19 0E
122+  A83B 19 0F 19 10
122+  A83F 19 11 19 12
122+  A843 19 13 19 14
123+  A847 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
123+  A84B 05 0B 06 0B
123+  A84F 07 0B 08 0B
123+  A853 09 0B 0A 0B
123+  A857 0B 0B
124+  A859 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
124+  A85D 0B 09 0B 0A
125+  A861 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19,16,20
125+  A865 10 10 10 11
125+  A869 10 12 10 13
125+  A86D 10 14
126+  A86F
# file closed: screen/titlescreen.asm
 27   A86F                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  A86F              ;
  2+  A86F              ; Draws the life remaining screen
  3+  A86F              ;
  4+  A86F              lifescreen_draw:
  5+  A86F CD A5 A8         call lifescreen_init
  6+  A872
  7+  A872 3A 9F B3         ld a,(game_currentplayer)             ; get the current player
  8+  A875 C6 30            add 48                                ; add 48 to get char
  9+  A877 21 C8 82         ld hl,string_lifescreen_player+10
 10+  A87A 77               ld (hl),a                             ; load this to the string we're about to show
 11+  A87B
 12+  A87B 21 BE 82         ld hl,string_lifescreen_player
 13+  A87E CD D8 82         call string_print
 14+  A881
 15+  A881 3A D0 B3         ld a,(player+9)                       ; get the current player lives
 16+  A884 C6 30            add 48                                ; add 48 to get the character
 17+  A886 21 CD 82         ld hl,string_lifescreen_lives+2
 18+  A889 77               ld (hl),a                             ; load this to the string we're about to show
 19+  A88A
 20+  A88A
 21+  A88A 21 CB 82         ld hl,string_lifescreen_lives
 22+  A88D CD D8 82         call string_print
 23+  A890
 24+  A890 3E 86            ld a,134
 25+  A892 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 26+  A895 CD 9E A8         call lifescreen_alt_setcolours
 27+  A898
 28+  A898 3E 64            ld a,100                              ; wait for 200 frames
 29+  A89A CD 3D 80         call utilities_waitforkey_forframes   ; wait for keypress
 30+  A89D
 31+  A89D C9               ret
 32+  A89E
 33+  A89E              lifescreen_alt_setcolours:
 34+  A89E 06 0A            ld b,10
 35+  A8A0              lifescreen_alt_setcolours0:
 36+  A8A0 12               ld (de),a
 37+  A8A1 13               inc de
 38+  A8A2 10 FC            djnz lifescreen_alt_setcolours0
 39+  A8A4 C9               ret
 40+  A8A5
 41+  A8A5              ;
 42+  A8A5              ; Initialises the screen
 43+  A8A5              ;
 44+  A8A5              lifescreen_init:
 45+  A8A5              ; We want a blue screen.
 46+  A8A5                  ;call $0D6B
 47+  A8A5 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 48+  A8A7                                      ; bright (64).
 49+  A8A7 CD 52 80         call utilities_clearscreen
 50+  A8AA 32 8D 5C         ld (23693),a        ; set our screen colours.
 51+  A8AD 3E 01            ld a,1              ; 1 is the code for blue.
 52+  A8AF D3 FE            out (254),a         ; write to port 254.
 53+  A8B1                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 54+  A8B1
 55+  A8B1 C9               ret
# file closed: screen/lifescreen.asm
 28   A8B2
 29   A8B2                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  A8B2              ; ###############################################################
  2+  A8B2              ; Data for level 1
  3+  A8B2              ; ###############################################################
  4+  A8B2              level01:
  5+  A8B2
  6+  A8B2                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  A8B2
  8+  A8B2 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  A8B6 05 05 05 05
  8+  A8BA 05 05 05 05
  8+  A8BE 05 05 02 01
  8+  A8C2 01 01 03 05
  8+  A8C6 05 05 05 05
  8+  A8CA 05 05 05 05
  8+  A8CE 05 05 00 00
  9+  A8D2 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  A8D6 05 05 05 05
  9+  A8DA 05 05 05 05
  9+  A8DE 02 01 01 01
  9+  A8E2 01 01 01 01
  9+  A8E6 03 05 05 05
  9+  A8EA 05 05 05 05
  9+  A8EE 05 05 00 00
 10+  A8F2 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  A8F6 05 05 05 05
 10+  A8FA 05 05 02 01
 10+  A8FE 01 01 01 01
 10+  A902 01 01 01 01
 10+  A906 01 01 03 05
 10+  A90A 0D 0D 0D 0D
 10+  A90E 0D 0D 00 00
 11+  A912 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  A916 01 01 00 01
 11+  A91A 01 01 01 01
 11+  A91E 01 01 01 01
 11+  A922 01 01 01 01
 11+  A926 01 01 01 03
 11+  A92A 05 05 05 05
 11+  A92E 05 05 00 00
 12+  A932 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  A936 04 04 04 04
 12+  A93A 04 04 01 01
 12+  A93E 01 01 01 01
 12+  A942 01 01 01 01
 12+  A946 01 01 01 01
 12+  A94A 01 01 01 01
 12+  A94E 00 01 00 00
 13+  A952 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  A956 04 04 04 04
 13+  A95A 04 04 04 04
 13+  A95E 01 01 01 01
 13+  A962 01 01 01 01
 13+  A966 01 01 01 01
 13+  A96A 00 00 00 00
 13+  A96E 00 01 00 00
 14+  A972 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  A976 04 01 01 01
 14+  A97A 01 01 04 04
 14+  A97E 04 04 01 01
 14+  A982 01 01 01 01
 14+  A986 01 00 00 00
 14+  A98A 00 01 01 01
 14+  A98E 01 01 00 00
 15+  A992 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  A996 04 04 04 04
 15+  A99A 04 01 04 04
 15+  A99E 04 04 04 04
 15+  A9A2 04 04 00 00
 15+  A9A6 00 00 04 04
 15+  A9AA 04 04 04 04
 15+  A9AE 04 01 00 00
 16+  A9B2 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  A9B6 01 04 01 01
 16+  A9BA 01 01 04 04
 16+  A9BE 04 04 04 04
 16+  A9C2 04 04 00 04
 16+  A9C6 04 04 04 04
 16+  A9CA 04 04 04 04
 16+  A9CE 04 01 00 00
 17+  A9D2 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  A9D6 00 00 00 00
 17+  A9DA 00 04 04 04
 17+  A9DE 04 04 04 04
 17+  A9E2 04 04 00 04
 17+  A9E6 04 04 04 04
 17+  A9EA 04 04 04 04
 17+  A9EE 04 01 00 00
 18+  A9F2 00 00 01 07      defb 00,00,01,07,07,07,07,07,07,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  A9F6 07 07 07 07
 18+  A9FA 07 01 04 04
 18+  A9FE 04 04 04 04
 18+  AA02 04 04 00 04
 18+  AA06 04 04 04 04
 18+  AA0A 04 04 04 04
 18+  AA0E 04 01 00 00
 19+  AA12 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  AA16 00 00 00 00
 19+  AA1A 00 01 04 04
 19+  AA1E 04 04 04 04
 19+  AA22 04 04 00 04
 19+  AA26 04 04 04 04
 19+  AA2A 04 00 00 00
 19+  AA2E 00 01 00 00
 20+  AA32 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  AA36 00 00 00 00
 20+  AA3A 00 01 04 04
 20+  AA3E 04 04 04 04
 20+  AA42 04 04 00 04
 20+  AA46 04 04 04 04
 20+  AA4A 04 00 04 04
 20+  AA4E 00 01 00 00
 21+  AA52 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  AA56 06 06 06 06
 21+  AA5A 06 01 04 04
 21+  AA5E 04 04 04 04
 21+  AA62 04 04 00 04
 21+  AA66 04 04 04 04
 21+  AA6A 04 00 04 04
 21+  AA6E 00 01 00 00
 22+  AA72 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  AA76 06 06 06 06
 22+  AA7A 06 01 04 00
 22+  AA7E 00 00 00 00
 22+  AA82 00 00 00 00
 22+  AA86 00 00 00 00
 22+  AA8A 00 00 04 04
 22+  AA8E 00 01 00 00
 23+  AA92 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  AA96 06 06 06 06
 23+  AA9A 06 01 04 00
 23+  AA9E 04 04 04 04
 23+  AAA2 04 04 00 04
 23+  AAA6 04 04 00 04
 23+  AAAA 04 04 04 04
 23+  AAAE 00 01 00 00
 24+  AAB2 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  AAB6 06 06 06 06
 24+  AABA 06 01 04 00
 24+  AABE 04 04 04 04
 24+  AAC2 04 04 00 04
 24+  AAC6 04 04 00 04
 24+  AACA 04 04 04 04
 24+  AACE 00 01 00 00
 25+  AAD2 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  AAD6 01 01 01 01
 25+  AADA 01 01 04 00
 25+  AADE 04 04 04 04
 25+  AAE2 04 04 00 04
 25+  AAE6 04 04 00 04
 25+  AAEA 04 04 04 04
 25+  AAEE 00 01 00 00
 26+  AAF2 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  AAF6 04 04 04 04
 26+  AAFA 04 04 04 00
 26+  AAFE 04 04 04 04
 26+  AB02 04 04 00 04
 26+  AB06 04 04 00 00
 26+  AB0A 00 00 04 04
 26+  AB0E 04 01 00 00
 27+  AB12 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  AB16 04 04 00 00
 27+  AB1A 00 00 00 00
 27+  AB1E 04 04 04 04
 27+  AB22 04 04 00 04
 27+  AB26 04 04 04 04
 27+  AB2A 04 00 04 04
 27+  AB2E 04 01 00 00
 28+  AB32 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  AB36 04 04 00 04
 28+  AB3A 04 04 04 04
 28+  AB3E 04 04 04 04
 28+  AB42 04 04 00 04
 28+  AB46 04 04 04 04
 28+  AB4A 04 00 04 04
 28+  AB4E 04 01 00 00
 29+  AB52 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  AB56 04 04 00 04
 29+  AB5A 04 04 01 01
 29+  AB5E 01 01 01 01
 29+  AB62 01 01 01 01
 29+  AB66 01 01 01 01
 29+  AB6A 04 00 04 04
 29+  AB6E 04 01 00 00
 30+  AB72 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  AB76 04 04 00 04
 30+  AB7A 04 04 01 00
 30+  AB7E 00 00 00 00
 30+  AB82 00 00 00 00
 30+  AB86 00 00 00 01
 30+  AB8A 04 00 04 04
 30+  AB8E 04 01 00 00
 31+  AB92 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  AB96 04 04 00 04
 31+  AB9A 04 04 01 00
 31+  AB9E 00 00 00 00
 31+  ABA2 00 00 00 00
 31+  ABA6 00 00 00 01
 31+  ABAA 04 00 04 04
 31+  ABAE 04 01 00 00
 32+  ABB2 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  ABB6 04 04 00 04
 32+  ABBA 04 04 01 00
 32+  ABBE 00 00 00 00
 32+  ABC2 00 00 00 00
 32+  ABC6 00 00 00 01
 32+  ABCA 04 00 04 04
 32+  ABCE 04 01 00 00
 33+  ABD2 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  ABD6 04 04 00 04
 33+  ABDA 04 04 04 00
 33+  ABDE 00 00 00 00
 33+  ABE2 00 00 00 00
 33+  ABE6 00 00 00 04
 33+  ABEA 04 04 04 04
 33+  ABEE 04 01 00 00
 34+  ABF2 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  ABF6 04 04 04 04
 34+  ABFA 04 04 01 00
 34+  ABFE 00 00 00 00
 34+  AC02 00 00 00 00
 34+  AC06 00 00 00 01
 34+  AC0A 04 04 04 04
 34+  AC0E 04 01 00 00
 35+  AC12 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  AC16 04 04 04 04
 35+  AC1A 04 04 01 00
 35+  AC1E 00 00 01 00
 35+  AC22 00 00 00 01
 35+  AC26 00 00 00 01
 35+  AC2A 04 04 04 04
 35+  AC2E 04 01 00 00
 36+  AC32 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  AC36 01 01 01 01
 36+  AC3A 01 01 01 01
 36+  AC3E 01 01 01 01
 36+  AC42 01 01 01 01
 36+  AC46 01 01 01 01
 36+  AC4A 01 01 01 01
 36+  AC4E 01 01 00 00
 37+  AC52
 38+  AC52              ; ###############################################################
 39+  AC52              ; Object data: horiz, vert, state, memh, meml
 40+  AC52              ; ###############################################################
 41+  AC52              level01rocks:
 42+  AC52 09 04 00 00      defb 9,4,0,0,0
 42+  AC56 00
 43+  AC57 0C 07 00 00      defb 12,7,0,0,0
 43+  AC5B 00
 44+  AC5C 10 07 00 00      defb 16,7,0,0,0
 44+  AC60 00
 45+  AC61 0B 08 00 00      defb 11,8,0,0,0
 45+  AC65 00
 46+  AC66 0A 0A 00 00      defb 10,10,0,0,0
 46+  AC6A 00
 47+  AC6B 0C 0A 00 00      defb 12,10,0,0,0
 47+  AC6F 00
 48+  AC70 0D 09 00 00      defb 13,9,0,0,0
 48+  AC74 00
 49+  AC75 0E 08 00 00      defb 14,8,0,0,0
 49+  AC79 00
 50+  AC7A 0F 0B 00 00      defb 15,11,0,0,0
 50+  AC7E 00
 51+  AC7F 0B 0C 00 00      defb 11,12,0,0,0
 51+  AC83 00
 52+  AC84 11 0C 00 00      defb 17,12,0,0,0
 52+  AC88 00
 53+  AC89 13 08 00 00      defb 19,8,0,0,0
 53+  AC8D 00
 54+  AC8E 16 09 00 00      defb 22,9,0,0,0
 54+  AC92 00
 55+  AC93 13 0A 00 00      defb 19,10,0,0,0
 55+  AC97 00
 56+  AC98 15 0A 00 00      defb 21,10,0,0,0
 56+  AC9C 00
 57+  AC9D 15 0C 00 00      defb 21,12,0,0,0
 57+  ACA1 00
 58+  ACA2 16 0C 00 00      defb 22,12,0,0,0
 58+  ACA6 00
 59+  ACA7 18 0A 00 00      defb 24,10,0,0,0
 59+  ACAB 00
 60+  ACAC 19 09 00 00      defb 25,9,0,0,0
 60+  ACB0 00
 61+  ACB1 1C 09 00 00      defb 28,9,0,0,0
 61+  ACB5 00
 62+  ACB6 1B 0C 00 00      defb 27,12,0,0,0
 62+  ACBA 00
 63+  ACBB 1A 0D 00 00      defb 26,13,0,0,0
 63+  ACBF 00
 64+  ACC0 19 0E 00 00      defb 25,14,0,0,0
 64+  ACC4 00
 65+  ACC5 19 10 00 00      defb 25,16,0,0,0
 65+  ACC9 00
 66+  ACCA 1A 11 00 00      defb 26,17,0,0,0
 66+  ACCE 00
 67+  ACCF 1B 11 00 00      defb 27,17,0,0,0
 67+  ACD3 00
 68+  ACD4 1C 12 00 00      defb 28,18,0,0,0
 68+  ACD8 00
 69+  ACD9 1A 13 00 00      defb 26,19,0,0,0
 69+  ACDD 00
 70+  ACDE 1B 15 00 00      defb 27,21,0,0,0
 70+  ACE2 00
 71+  ACE3 1A 17 00 00      defb 26,23,0,0,0
 71+  ACE7 00
 72+  ACE8 1B 18 00 00      defb 27,24,0,0,0
 72+  ACEC 00
 73+  ACED 19 18 00 00      defb 25,24,0,0,0
 73+  ACF1 00
 74+  ACF2 18 17 00 00      defb 24,23,0,0,0
 74+  ACF6 00
 75+  ACF7 13 14 00 00      defb 19,20,0,0,0
 75+  ACFB 00
 76+  ACFC 14 12 00 00      defb 20,18,0,0,0
 76+  AD00 00
 77+  AD01 14 10 00 00      defb 20,16,0,0,0
 77+  AD05 00
 78+  AD06 15 10 00 00      defb 21,16,0,0,0
 78+  AD0A 00
 79+  AD0B 16 12 00 00      defb 22,18,0,0,0
 79+  AD0F 00
 80+  AD10 11 14 00 00      defb 17,20,0,0,0
 80+  AD14 00
 81+  AD15 0D 11 00 00      defb 13,17,0,0,0
 81+  AD19 00
 82+  AD1A 0C 13 00 00      defb 12,19,0,0,0
 82+  AD1E 00
 83+  AD1F 0B 13 00 00      defb 11,19,0,0,0
 83+  AD23 00
 84+  AD24 0A 11 00 00      defb 10,17,0,0,0
 84+  AD28 00
 85+  AD29 05 12 00 00      defb 5,18,0,0,0
 85+  AD2D 00
 86+  AD2E 07 16 00 00      defb 7,22,0,0,0
 86+  AD32 00
 87+  AD33 09 17 00 00      defb 9,23,0,0,0
 87+  AD37 00
 88+  AD38 07 18 00 00      defb 7,24,0,0,0
 88+  AD3C 00
 89+  AD3D 05 18 00 00      defb 5,24,0,0,0
 89+  AD41 00
 90+  AD42 06 19 00 00      defb 6,25,0,0,0
 90+  AD46 00
 91+  AD47 08 19 00 00      defb 8,25,0,0,0
 91+  AD4B 00
 92+  AD4C 04 17 00 00      defb 4,23,0,0,0
 92+  AD50 00
 93+  AD51 FF               defb 255
 94+  AD52
 95+  AD52              level01missiles:
 96+  AD52 0B 17 00 00      defb 11,23,0,0,0
 96+  AD56 00
 97+  AD57 0B 16 00 00      defb 11,22,0,0,0
 97+  AD5B 00
 98+  AD5C 0C 17 00 00      defb 12,23,0,0,0
 98+  AD60 00
 99+  AD61 0C 16 00 00      defb 12,22,0,0,0
 99+  AD65 00
100+  AD66 0D 17 00 00      defb 13,23,0,0,0
100+  AD6A 00
101+  AD6B 0D 16 00 00      defb 13,22,0,0,0
101+  AD6F 00
102+  AD70 0E 17 00 00      defb 14,23,0,0,0
102+  AD74 00
103+  AD75 0E 16 00 00      defb 14,22,0,0,0
103+  AD79 00
104+  AD7A 0F 17 00 00      defb 15,23,0,0,0
104+  AD7E 00
105+  AD7F 0F 16 00 00      defb 15,22,0,0,0
105+  AD83 00
106+  AD84 10 17 00 00      defb 16,23,0,0,0
106+  AD88 00
107+  AD89 10 16 00 00      defb 16,22,0,0,0
107+  AD8D 00
108+  AD8E 11 17 00 00      defb 17,23,0,0,0
108+  AD92 00
109+  AD93 11 16 00 00      defb 17,22,0,0,0
109+  AD97 00
110+  AD98 12 17 00 00      defb 18,23,0,0,0
110+  AD9C 00
111+  AD9D 12 16 00 00      defb 18,22,0,0,0
111+  ADA1 00
112+  ADA2 13 17 00 00      defb 19,23,0,0,0
112+  ADA6 00
113+  ADA7 13 16 00 00      defb 19,22,0,0,0
113+  ADAB 00
114+  ADAC 14 17 00 00      defb 20,23,0,0,0
114+  ADB0 00
115+  ADB1 14 16 00 00      defb 20,22,0,0,0
115+  ADB5 00
116+  ADB6 15 17 00 00      defb 21,23,0,0,0
116+  ADBA 00
117+  ADBB 15 16 00 00      defb 21,22,0,0,0
117+  ADBF 00
118+  ADC0 16 17 00 00      defb 22,23,0,0,0
118+  ADC4 00
119+  ADC5 16 16 00 00      defb 22,22,0,0,0
119+  ADC9 00
120+  ADCA FF               defb 255
121+  ADCB
122+  ADCB              level01diamonds:
123+  ADCB 0C 1B 00 00      defb 12,27,0,0,0
123+  ADCF 00
124+  ADD0 10 1B 00 00      defb 16,27,0,0,0
124+  ADD4 00
125+  ADD5 15 1B 00 00      defb 21,27,0,0,0
125+  ADD9 00
126+  ADDA FF               defb 255
127+  ADDB
128+  ADDB              level01gems:
129+  ADDB 12 14 00 00      defb 18,20,0,0,0
129+  ADDF 00
130+  ADE0 06 18 00 00      defb 6,24,0,0,0
130+  ADE4 00
131+  ADE5 19 17 00 00      defb 25,23,0,0,0
131+  ADE9 00
132+  ADEA 1C 11 00 00      defb 28,17,0,0,0
132+  ADEE 00
133+  ADEF FF               defb 255
134+  ADF0              ;
135+  ADF0              ; Score area colours
136+  ADF0              ;
137+  ADF0              score_colours:
138+  ADF0 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
138+  ADF4 47 47 47 47
138+  ADF8 47 47 47 42
138+  ADFC 43 43 43 43
138+  AE00 43 43 43 43
138+  AE04 42 47 47 47
138+  AE08 47 47 47 47
138+  AE0C 47 47 47 47
139+  AE10 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
139+  AE14 47 47 47 47
139+  AE18 47 47 47 46
139+  AE1C 46 46 46 46
139+  AE20 46 46 46 46
139+  AE24 46 47 47 47
139+  AE28 47 47 47 47
139+  AE2C 47 47 47 47
140+  AE30
141+  AE30              high_score_colours:
142+  AE30 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
142+  AE34 42 42 47 47
142+  AE38 47 47 47 47
142+  AE3C 43 43 43 47
142+  AE40 47 47 47 47
142+  AE44 47 46 46 46
142+  AE48 47 47 47 47
142+  AE4C 47 47 00 00
# file closed: leveldata/level01.asm
 30   AE50                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  AE50              ; Tiles graphics.
  2+  AE50              sprites:
  3+  AE50 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  AE54 00 00 00 00
  4+  AE58 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  AE5C FF FF FF FF
  5+  AE60 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  AE64 1F 3F 7F FF
  6+  AE68 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  AE6C F8 FC FE FF
  7+  AE70 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  AE74 55 AA 55 AA
  8+  AE78 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  AE7C 00 00 00 00
  9+  AE80 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  AE84 FF FF FF FF
 10+  AE88 FF FF 00 00      defb    255,255,  0,  0,  0,  0,  0,  0   ; 7, trapdoor
 10+  AE8C 00 00 00 00
 11+  AE90 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  AE94 F1 72 34 18
 12+  AE98 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  AE9C FE FE FF 7E
 13+  AEA0 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  AEA4 FE FF 7E 3C
 14+  AEA8 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  AEAC 00 00 FF FF
 15+  AEB0 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 12, missile
 15+  AEB4 FF 7E 3C 18
 16+  AEB8 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  AEBC 00 00 00 00
 17+  AEC0 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  AEC4 00 3C 5A 34
 18+  AEC8
 19+  AEC8              sprite_attrs:
 20+  AEC8 46               defb    070 ; 0, space
 21+  AEC9 65               defb    101 ; 1, cyan block
 22+  AECA 4D               defb    077 ; 2, slope left
 23+  AECB 4D               defb    077 ; 3, slope right
 24+  AECC 46               defb    070 ; 4, dirt
 25+  AECD 4E               defb    078 ; 5, sky
 26+  AECE 4C               defb    076 ; 6, slime
 27+  AECF 42               defb    066 ; 7, trapdoor
 28+  AED0 46               defb    070 ; 8, diamond
 29+  AED1 42               defb    066 ; 9, rock
 30+  AED2 42               defb    066 ; 10, rock 2
 31+  AED3 49           	defb    073 ; 11, sky, trapdoor
 32+  AED4 43           	defb    067 ; 12, missile
 33+  AED5 4A               defb    074 ; 13, sky, red ink (tank)
 34+  AED6 46               defb    070 ; 14, gem
 35+  AED7
 36+  AED7              player_sprite:
 37+  AED7 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 37+  AEDB 38 3D C3 80
 38+  AEDF 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 38+  AEE3 3C 1C 16 32
 39+  AEE7 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 39+  AEEB 3C 38 68 4C
 40+  AEEF 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 40+  AEF3 1C BC C3 01
 41+  AEF7 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 41+  AEFB 3C 3C 64 0C
 42+  AEFF 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 42+  AF03 3C 3C 26 30
 43+  AF07 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 43+  AF0B 1E 5C FD 5F
 44+  AF0F 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 44+  AF13 4F 8F 19 03
 45+  AF17 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 45+  AF1B F2 F1 98 C0
 46+  AF1F FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 46+  AF23 48 08 14 2A
 47+  AF27
 48+  AF27              ;
 49+  AF27              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 50+  AF27              ;
 51+  AF27              ship_sprite:
 52+  AF27 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 52+  AF2B 03 1F 7F FF
 53+  AF2F 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 53+  AF33 FF FF FF FF
 54+  AF37 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 54+  AF3B FF FF FF FF
 55+  AF3F 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 55+  AF43 C0 F8 FE FF
 56+  AF47 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 56+  AF4B 03 03 02 07
 57+  AF4F 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 57+  AF53 FF 0F 07 83
 58+  AF57 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 58+  AF5B FF 10 20 C1
 59+  AF5F 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 59+  AF63 C0 C0 40 E0
 60+  AF67 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 60+  AF6B 03 03 02 07
 61+  AF6F F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 61+  AF73 FF 08 04 83
 62+  AF77 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 62+  AF7B FF F0 E0 C1
 63+  AF7F CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 63+  AF83 C0 C0 40 E0
 64+  AF87
 65+  AF87              ;
 66+  AF87              ;  First 8 frames are tank, last frame is the gun barrel
 67+  AF87              ;
 68+  AF87              tank_sprite:
 69+  AF87 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 69+  AF8B 7F 00 00 00
 70+  AF8F 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 70+  AF93 FE FF 7F 40
 71+  AF97 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 71+  AF9B 03 FF FF 01
 72+  AF9F 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
 72+  AFA3 E0 C0 00 00
 73+  AFA7 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
 73+  AFAB F7 E1 7F 3F
 74+  AFAF FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
 74+  AFB3 54 16 FF FF
 75+  AFB7 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
 75+  AFBB 9B A8 FF FF
 76+  AFBF FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
 76+  AFC3 9F AF FE FC
 77+  AFC7 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0
 77+  AFCB 1F 00 00 00
# file closed: graphics/graphics.asm
 31   AFCF
 32   AFCF                  include "game\control.asm"
# file opened: game/control.asm
  1+  AFCF              ;
  2+  AFCF              ; Check the keyboard then move
  3+  AFCF              ;
  4+  AFCF              control_keyboard:
  5+  AFCF 3A CC B3         ld a,(player+5)      ; first, check if the player has pixels left to move
  6+  AFD2 FE 00            cp 0
  7+  AFD4 CA DB AF         jp z, control_keyboard5
  8+  AFD7 CD E0 B0         call control_automove
  9+  AFDA C9               ret
 10+  AFDB              control_keyboard5:
 11+  AFDB 3A CD B3         ld a,(player+6)      ; next, check if the player is digging
 12+  AFDE FE 00            cp 0
 13+  AFE0 CA E7 AF         jp z, control_keyboard0
 14+  AFE3 CD 1E B0         call control_dig
 15+  AFE6 C9               ret
 16+  AFE7              control_keyboard0:
 17+  AFE7 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 18+  AFEA ED 78            in a,(c)            ; read keyboard.
 19+  AFEC 47               ld b,a              ; store result in b register.
 20+  AFED CB 18            rr b                ; check outermost key (q).
 21+  AFEF D2 0E B0         jp nc,control_keyboard1
 22+  AFF2 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 23+  AFF5 ED 78            in a,(c)            ; read keyboard.
 24+  AFF7 47               ld b,a              ; store result in b register.
 25+  AFF8 CB 18            rr b                ; check outermost key (a).
 26+  AFFA D2 12 B0         jp nc,control_keyboard2
 27+  AFFD 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 28+  B000 ED 78            in a,(c)            ; read keyboard.
 29+  B002 47               ld b,a              ; store result in b register.
 30+  B003 CB 18            rr b                ; check outermost key (p).
 31+  B005 D2 16 B0         jp nc,control_keyboard3
 32+  B008 CB 18            rr b                ; check next key.
 33+  B00A D2 1A B0         jp nc,control_keyboard4
 34+  B00D C9               ret
 35+  B00E              control_keyboard1:
 36+  B00E CD 29 B1         call control_pl_moveup         ; player up.
 37+  B011 C9               ret
 38+  B012              control_keyboard2:
 39+  B012 CD 58 B1         call control_pl_movedown       ; player down.
 40+  B015 C9               ret
 41+  B016              control_keyboard3:
 42+  B016 CD B5 B1         call control_pl_moveright       ; player left.
 43+  B019 C9               ret
 44+  B01A              control_keyboard4:
 45+  B01A CD 85 B1         call control_pl_moveleft       ; player right.
 46+  B01D C9               ret
 47+  B01E
 48+  B01E              ;
 49+  B01E              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 50+  B01E              ;
 51+  B01E              control_dig:
 52+  B01E ED 4B C7 B3      ld bc,(player)      ; load the current coords into bc
 53+  B022 C5               push bc
 54+  B023 3A C9 B3         ld a,(player+2)     ; get the direction
 55+  B026 FE 01            cp 1                ; left
 56+  B028 CA 40 B0         jp z,control_dig0
 57+  B02B FE 02            cp 2                ; right
 58+  B02D CA 55 B0         jp z,control_dig1
 59+  B030 FE 03            cp 3                ; down
 60+  B032 CA 79 B0         jp z,control_dig5
 61+  B035 FE 00            cp 0                ; up
 62+  B037 CA 69 B0         jp z,control_dig4
 63+  B03A 21 CD B3         ld hl,player+6
 64+  B03D 36 00            ld (hl),0           ; turn off digging
 65+  B03F C9               ret                 ; return
 66+  B040              control_dig0:           ; going left
 67+  B040 CD E7 A6         call sprites_scadd  ; get the current coord
 68+  B043 62 6B            ld hl,de
 69+  B045 2B               dec hl              ; move one left
 70+  B046 C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
 71+  B047 78               ld a,b
 72+  B048 06 08            ld b,8
 73+  B04A 90               sub b
 74+  B04B 47               ld b,a
 75+  B04C 79               ld a,c
 76+  B04D 0E 08            ld c,8
 77+  B04F 91               sub c
 78+  B050 4F               ld c,a
 79+  B051 C5               push bc
 80+  B052 C3 82 B0         jp control_dig2
 81+  B055              control_dig1:
 82+  B055 CD E7 A6         call sprites_scadd  ; get the current coord
 83+  B058 62 6B            ld hl,de
 84+  B05A 23               inc hl              ; move one right
 85+  B05B C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
 86+  B05C 3E 08            ld a,8
 87+  B05E 80               add a,b
 88+  B05F 47               ld b,a
 89+  B060 79               ld a,c
 90+  B061 0E 08            ld c,8
 91+  B063 91               sub c
 92+  B064 4F               ld c,a
 93+  B065 C5               push bc
 94+  B066 C3 82 B0         jp control_dig2
 95+  B069              control_dig4:
 96+  B069 CD E7 A6         call sprites_scadd  ; get the current coord
 97+  B06C 62 6B            ld hl,de
 98+  B06E 11 20 00         ld de,32
 99+  B071 ED 52            sbc hl,de             ; move one up
100+  B073 C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
101+  B074 0D               dec c
102+  B075 C5               push bc
103+  B076 C3 9A B0         jp control_dig6
104+  B079              control_dig5:
105+  B079 CD E7 A6         call sprites_scadd  ; get the current coord
106+  B07C 62 6B            ld hl,de
107+  B07E 24               inc h              ; move one down
108+  B07F                                     ; not bothered about working out bc here, since rock will never fall if digging down
109+  B07F C3 82 B0         jp control_dig2
110+  B082              ; Normal (not up) digging
111+  B082              control_dig2:
112+  B082 3A CF B3         ld a,(player+8)     ; get the number of rows we need to overwrite
113+  B085 47               ld b,a              ; rows to copy over
114+  B086 E5               push hl             ; store the memory location of the first row for later
115+  B087              control_dig3:
116+  B087 CD C9 B0         call control_getpixelrow
117+  B08A 77               ld (hl),a           ; load contents into row
118+  B08B 11 20 00         ld de,32
119+  B08E 19               add hl,de           ; move to next row
120+  B08F 10 F6            djnz control_dig3
121+  B091 E1               pop hl              ; get the original memory location back
122+  B092 11 20 00         ld de,32
123+  B095 ED 52            sbc hl,de           ; move to above row, ready for checking for rock
124+  B097 C3 B0 B0         jp control_dig10
125+  B09A              ; Special case for going up
126+  B09A              control_dig6:
127+  B09A 3A CF B3         ld a,(player+8)     ; get the number of rows we need to overwrite
128+  B09D 47               ld b,a              ; rows to copy over
129+  B09E              control_dig7:
130+  B09E CD C9 B0         call control_getpixelrow
131+  B0A1              control_dig12:
132+  B0A1 77               ld (hl),a           ; load empty into row
133+  B0A2 11 20 00         ld de,32
134+  B0A5 ED 52            sbc hl,de           ; move up to next row
135+  B0A7 0D               dec c               ; decrease c to track rows
136+  B0A8 10 F4            djnz control_dig7
137+  B0AA 79               ld a,c
138+  B0AB D6 07            sub 7
139+  B0AD C1               pop bc
140+  B0AE 4F               ld c,a
141+  B0AF C5               push bc             ; store the decreased c coord
142+  B0B0              control_dig10:
143+  B0B0 DD 21 CE B3      ld ix,player+7
144+  B0B4 DD 7E 00         ld a,(ix)     ; get the dig frame number
145+  B0B7 3D               dec a
146+  B0B8 DD 77 00         ld (ix),a
147+  B0BB                  ; call the check for rocks above the removed dirt
148+  B0BB DD 21 CD B3      ld ix,player+6
149+  B0BF DD 7E 00         ld a,(ix)     ; get the dig state
150+  B0C2 FE 00            cp 0
151+  B0C4 C1               pop bc
152+  B0C5 CC 3B B6         call z, rocks_checkforfalling ; make the check if we're no longer digging
153+  B0C8 C9               ret
154+  B0C9
155+  B0C9              ;
156+  B0C9              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
157+  B0C9              ; Inputs:
158+  B0C9              ; hl - memory of pixel row
159+  B0C9              ; Outputs:
160+  B0C9              ; a - modified row to write
161+  B0C9              ;
162+  B0C9              control_getpixelrow:
163+  B0C9 3A CE B3         ld a,(player+7)     ; get the dig frame number
164+  B0CC FE 00            cp 0                ; is this the last dig
165+  B0CE CA D5 B0         jp z,control_getpixelrow1
166+  B0D1 7E               ld a,(hl)           ; if not, xor with 255 to flip it
167+  B0D2 EE FF            xor 255
168+  B0D4 C9               ret
169+  B0D5              control_getpixelrow1:
170+  B0D5 DD 21 CD B3      ld ix,player+6
171+  B0D9 DD 36 00 00      ld (ix),0           ; turn off digging
172+  B0DD 3E 00            ld a,0              ; if it is, load with empty
173+  B0DF C9               ret
174+  B0E0
175+  B0E0              ;
176+  B0E0              ; Auto move the player until pixels is zero
177+  B0E0              ;
178+  B0E0              control_automove:
179+  B0E0 5F               ld e,a              ; store the number of pixels left to move in e
180+  B0E1 ED 4B C7 B3      ld bc,(player)      ; load the current coords into bc
181+  B0E5 21 C9 B3         ld hl,player+2      ; get the direction
182+  B0E8 7E               ld a,(hl)
183+  B0E9 FE 03            cp 3                ; down
184+  B0EB CA FF B0         jp z,control_automove3  ; don't need to do anything
185+  B0EE FE 00            cp 0                ; going up
186+  B0F0 CA 0B B1         jp z,control_automove2
187+  B0F3 FE 01            cp 1                ; going left?
188+  B0F5 CA 17 B1         jp z,control_automove0
189+  B0F8 78               ld a,b
190+  B0F9 3C               inc a               ; if we're going right, increment a twice for two pixels
191+  B0FA 3C               inc a
192+  B0FB 47               ld b,a
193+  B0FC C3 1B B1         jp control_automove1
194+  B0FF              control_automove3:
195+  B0FF 79               ld a,c
196+  B100 3C               inc a
197+  B101 3C               inc a               ; if we're going down, increment twice
198+  B102 4F               ld c,a
199+  B103 FE 90            cp 144
200+  B105 CC E3 B1         call z, control_scroll_down
201+  B108 C3 1B B1         jp control_automove1
202+  B10B              control_automove2:
203+  B10B 79               ld a,c
204+  B10C 3D               dec a
205+  B10D 3D               dec a               ; if we're going up, decrement twice
206+  B10E 4F               ld c,a
207+  B10F FE 60            cp 96
208+  B111 CC F0 B1         call z, control_scroll_up
209+  B114 C3 1B B1         jp control_automove1
210+  B117              control_automove0:
211+  B117 78               ld a,b
212+  B118 3D               dec a               ; if we're going left, decrement a twice
213+  B119 3D               dec a
214+  B11A 47               ld b,a
215+  B11B              control_automove1:
216+  B11B ED 43 C7 B3      ld (player),bc      ; and back to player
217+  B11F 7B               ld a,e              ; now get the pixel count back
218+  B120 3D               dec a               ; decrease by one
219+  B121 21 CC B3         ld hl,player+5
220+  B124 77               ld (hl),a           ; copy back
221+  B125 CD 40 B4         call player_justmoved
222+  B128 C9               ret
223+  B129
224+  B129              ;
225+  B129              ; Moves the player up
226+  B129              ;
227+  B129              control_pl_moveup:
228+  B129 C5               push bc
229+  B12A ED 4B C7 B3      ld bc,(player)          ; get the current coords, b horiz, c vert
230+  B12E 79               ld a,c                  ; load c into the acc
231+  B12F FE 18            cp 24
232+  B131 CA 51 B1         jp z,control_pl_moveup0 ; are we at the edge of the screen
233+  B134 FE 60            cp 96
234+  B136 CC F0 B1         call z, control_scroll_up
235+  B139 CD 1B B3         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
236+  B13C F5               push af
237+  B13D 7B               ld a,e                  ; put e in a
238+  B13E FE 00            cp 0
239+  B140 CA 50 B1         jp z,control_pl_moveup1 ; don't move if we can't
240+  B143 F1               pop af
241+  B144 D6 01            sub 1                   ; subtract 1
242+  B146 D6 01            sub 1                   ; subtract 1
243+  B148 4F               ld c,a                  ; load back to c
244+  B149 ED 43 C7 B3      ld (player),bc          ; load back to player
245+  B14D C3 51 B1         jp control_pl_moveup0
246+  B150              control_pl_moveup1:
247+  B150 F1               pop af                  ; restore af if needed
248+  B151              control_pl_moveup0:
249+  B151 3E 00            ld a,0
250+  B153 32 C9 B3         ld (player+2),a        ; set direction to up
251+  B156 C1               pop bc
252+  B157 C9               ret
253+  B158              ;
254+  B158              ; Moves the player down
255+  B158              ;
256+  B158              control_pl_movedown:
257+  B158 C5               push bc
258+  B159 ED 4B C7 B3      ld bc,(player)          ; get the current coords, b horiz, c vert
259+  B15D 79               ld a,c                  ; load c into the acc
260+  B15E FE E0            cp 224
261+  B160 CA 7E B1         jp z,control_pl_movedown0 ; are we at the edge of the screen
262+  B163 FE 80            cp 128
263+  B165 CC E3 B1         call z, control_scroll_down
264+  B168 CD F3 B2         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
265+  B16B F5               push af
266+  B16C 7B               ld a,e                  ; put e in a
267+  B16D FE 00            cp 0
268+  B16F CA 7D B1         jp z,control_pl_movedown1 ; don't move if we can't
269+  B172 F1               pop af
270+  B173 3C               inc a                   ; add 1
271+  B174 3C               inc a                   ; add 1
272+  B175 4F               ld c,a                  ; load back to c
273+  B176 ED 43 C7 B3      ld (player),bc          ; load back to player
274+  B17A C3 7E B1         jp control_pl_movedown0
275+  B17D              control_pl_movedown1:
276+  B17D F1               pop af                  ; restore af if needed
277+  B17E              control_pl_movedown0:
278+  B17E 3E 03            ld a,3
279+  B180 32 C9 B3         ld (player+2),a        ; set direction to down
280+  B183 C1               pop bc
281+  B184 C9               ret
282+  B185              ;
283+  B185              ; Moves the player left
284+  B185              ;
285+  B185              control_pl_moveleft:
286+  B185 C5               push bc
287+  B186 ED 4B C7 B3      ld bc,(player)          ; get the current coords, b horiz, c vert
288+  B18A 78               ld a,b                  ; load b into the acc
289+  B18B FE 10            cp 16
290+  B18D CA AE B1         jp z,control_pl_moveleft0 ; are we at the edge of the screen
291+  B190 CD 75 B3         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
292+  B193 F5               push af
293+  B194 7B               ld a,e                  ; put e in a
294+  B195 FE 00            cp 0
295+  B197 CA AD B1         jp z,control_pl_moveleft1 ; don't move if we can't
296+  B19A 21 CC B3         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
297+  B19D 3E 03            ld a,3
298+  B19F 77               ld (hl),a
299+  B1A0 F1               pop af
300+  B1A1 D6 01            sub 1                    ; subtract 2
301+  B1A3 D6 01            sub 1
302+  B1A5 47               ld b,a                  ; load back to c
303+  B1A6 ED 43 C7 B3      ld (player),bc          ; load back to player
304+  B1AA C3 AE B1         jp control_pl_moveleft0
305+  B1AD              control_pl_moveleft1:
306+  B1AD F1               pop af
307+  B1AE              control_pl_moveleft0:
308+  B1AE 3E 01            ld a,1
309+  B1B0 32 C9 B3         ld (player+2),a        ; set direction to left
310+  B1B3 C1               pop bc
311+  B1B4 C9               ret
312+  B1B5              ;
313+  B1B5              ; Moves the player right
314+  B1B5              ;
315+  B1B5              control_pl_moveright:
316+  B1B5 C5               push bc
317+  B1B6 ED 4B C7 B3      ld bc,(player)          ; get the current coords, b horiz, c vert
318+  B1BA 78               ld a,b                  ; load b into the acc
319+  B1BB FE F0            cp 240
320+  B1BD CA DC B1         jp z,control_pl_moveright0 ; are we at the edge of the screen
321+  B1C0 CD 4D B3         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
322+  B1C3 F5               push af
323+  B1C4 7B               ld a,e                  ; put e in a
324+  B1C5 FE 00            cp 0
325+  B1C7 CA DB B1         jp z,control_pl_moveright1 ; don't move if we can't
326+  B1CA 21 CC B3         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
327+  B1CD 3E 03            ld a,3
328+  B1CF 77               ld (hl),a
329+  B1D0 F1               pop af
330+  B1D1 3C               inc a                   ; add 2
331+  B1D2 3C               inc a
332+  B1D3 47               ld b,a                  ; load back to b
333+  B1D4 ED 43 C7 B3      ld (player),bc          ; load back to player
334+  B1D8 C3 DC B1         jp control_pl_moveright0
335+  B1DB              control_pl_moveright1:
336+  B1DB F1               pop af                  ; restore af if needed
337+  B1DC              control_pl_moveright0:
338+  B1DC 3E 02            ld a,2
339+  B1DE 32 C9 B3         ld (player+2),a        ; set direction to right
340+  B1E1 C1               pop bc
341+  B1E2 C9               ret
342+  B1E3
343+  B1E3              ;
344+  B1E3              ; Scrolls the screen down
345+  B1E3              ;
346+  B1E3              control_scroll_down:
347+  B1E3 F5               push af
348+  B1E4 3E 08            ld a,8
349+  B1E6 32 25 A5         ld (screen_offset),a
350+  B1E9 F1               pop af
351+  B1EA 21 D7 A3         ld hl,buffer_updateall
352+  B1ED 36 01            ld (hl),1         ; flag as screen needing update
353+  B1EF C9               ret
354+  B1F0
355+  B1F0              ;
356+  B1F0              ; Scrolls the screen up
357+  B1F0              ;
358+  B1F0              control_scroll_up:
359+  B1F0 F5               push af
360+  B1F1 3E 00            ld a,0
361+  B1F3 32 25 A5         ld (screen_offset),a
362+  B1F6 F1               pop af
363+  B1F7 21 D7 A3         ld hl,buffer_updateall
364+  B1FA 36 01            ld (hl),1         ; flag as screen needing update
365+  B1FC C9               ret
366+  B1FD
367+  B1FD
368+  B1FD
369+  B1FD
# file closed: game/control.asm
 33   B1FD                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  B1FD              ;
  2+  B1FD              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  3+  B1FD              ; Inputs:
  4+  B1FD              ; hl - memory location of top pixel row
  5+  B1FD              ; bc - screen coords, b horiz, c vert
  6+  B1FD              ; Outputs:
  7+  B1FD              ; e - 0 if not empty, 1 if empty
  8+  B1FD              ;
  9+  B1FD              movement_spaceisempty:
 10+  B1FD 3E 08            ld a,8                          ; 8 rows to check
 11+  B1FF              movement_spaceisempty0:
 12+  B1FF 08               ex af,af'                       ; store the loop counter
 13+  B200 7E               ld a,(hl)                       ; get current pixel row
 14+  B201 FE 00            cp 0
 15+  B203 C2 17 B2         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 16+  B206 79               ld a,c                          ; load the vertical coord
 17+  B207 3C               inc a                           ; next row down
 18+  B208 11 20 00         ld de,32
 19+  B20B 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 20+  B20C 4F               ld c,a                          ; copy vert coord back to c
 21+  B20D 08               ex af,af'                       ; get loop counter back
 22+  B20E 3D               dec a                           ; decrease loop counter
 23+  B20F C2 FF B1         jp nz, movement_spaceisempty0
 24+  B212 16 00            ld d,0
 25+  B214 1E 01            ld e,1                          ; got to end, so space is empty
 26+  B216 C9               ret
 27+  B217              movement_spaceisempty1:
 28+  B217 16 00            ld d,0
 29+  B219 1E 00            ld e,0                          ; returning false, ie space not empty
 30+  B21B C9               ret
 31+  B21C
 32+  B21C              ;
 33+  B21C              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
 34+  B21C              ; Inputs:
 35+  B21C              ; hl - memory location of top pixel row
 36+  B21C              ; bc - screen coords, b horiz, c vert
 37+  B21C              ; Outputs:
 38+  B21C              ; e - 0 if not empty, 1 if empty
 39+  B21C              ;
 40+  B21C              movement_linebelowisempty:
 41+  B21C 7E               ld a,(hl)                       ; get current pixel row
 42+  B21D FE 00            cp 0
 43+  B21F C2 27 B2         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
 44+  B222 16 00            ld d,0
 45+  B224 1E 01            ld e,1                          ; got to end, so space is empty
 46+  B226 C9               ret
 47+  B227              movement_linebelowisempty1:
 48+  B227 16 00            ld d,0
 49+  B229 1E 00            ld e,0                          ; returning false, ie space not empty
 50+  B22B C9               ret
 51+  B22C
 52+  B22C              ;
 53+  B22C              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
 54+  B22C              ; Inputs:
 55+  B22C              ; hl - memory location of top pixel row
 56+  B22C              ; bc - screen coords, b horiz, c vert
 57+  B22C              ; Outputs:
 58+  B22C              ; e - 0 if not empty, 1 if empty
 59+  B22C              ;
 60+  B22C              movement_lineaboveisempty:
 61+  B22C 7E               ld a,(hl)                       ; get current pixel row
 62+  B22D FE 00            cp 0
 63+  B22F C2 37 B2         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
 64+  B232 16 00            ld d,0
 65+  B234 1E 01            ld e,1                          ; got to end, so space is empty
 66+  B236 C9               ret
 67+  B237              movement_lineaboveisempty1:
 68+  B237 16 00            ld d,0
 69+  B239 1E 00            ld e,0                          ; returning false, ie space not empty
 70+  B23B C9               ret
 71+  B23C
 72+  B23C              ;
 73+  B23C              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
 74+  B23C              ; Inputs:
 75+  B23C              ; hl - memory location of top pixel row
 76+  B23C              ; bc - screen coords, b horiz, c vert
 77+  B23C              ; Outputs:
 78+  B23C              ; none - puts player into digging mode
 79+  B23C              ;
 80+  B23C              movement_spaceisdiggable:
 81+  B23C 3E 08            ld a,8                          ; 8 rows to check
 82+  B23E              movement_spaceisdiggable0:
 83+  B23E 08               ex af,af'                       ; store the loop counter
 84+  B23F 7E               ld a,(hl)                       ; get current pixel row
 85+  B240 FE 00            cp 0
 86+  B242 CA 52 B2         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
 87+  B245 FE 55            cp 85
 88+  B247 CA 52 B2         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
 89+  B24A FE AA            cp 170
 90+  B24C CA 52 B2         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
 91+  B24F C3 6A B2         jp movement_spaceisdiggable1     ; otherwise, stop checking
 92+  B252              movement_spaceisdiggable2:
 93+  B252 79               ld a,c                          ; load the vertical coord
 94+  B253 3C               inc a                           ; next row down
 95+  B254 11 20 00         ld de,32
 96+  B257 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 97+  B258 4F               ld c,a                          ; copy vert coord back to c
 98+  B259 08               ex af,af'                       ; get loop counter back
 99+  B25A 3D               dec a                           ; decrease loop counter
100+  B25B C2 3E B2         jp nz, movement_spaceisdiggable0
101+  B25E 21 CD B3         ld hl,player+6
102+  B261 36 01            ld (hl),1                       ; set the player into digging mode
103+  B263 23               inc hl
104+  B264 36 05            ld (hl),5                      ; set the number of frame to dig for
105+  B266 23               inc hl
106+  B267 36 08            ld (hl),8                       ; set the number of pixels to dig
107+  B269 C9               ret
108+  B26A              movement_spaceisdiggable1:
109+  B26A 21 CD B3         ld hl,player+6
110+  B26D 36 00            ld (hl),0                       ; set the player out of digging mode
111+  B26F C9               ret
112+  B270
113+  B270              ;
114+  B270              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
115+  B270              ; Inputs:
116+  B270              ; hl - memory location of top pixel row
117+  B270              ; bc - screen coords, b horiz, c vert
118+  B270              ; Outputs:
119+  B270              ; none - puts player into digging mode
120+  B270              ;
121+  B270              movement_spacebelowisdiggable:
122+  B270 7E               ld a,(hl)                       ; get first pixel row
123+  B271 FE 55            cp 85
124+  B273 CA 7E B2         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
125+  B276 FE AA            cp 170
126+  B278 CA 7E B2         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
127+  B27B C3 6A B2         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
128+  B27E              movement_spacebelowisdiggable3:
129+  B27E 3E 08            ld a,8                          ; rows to check
130+  B280 1E 00            ld e,0                          ; count of rows to dig
131+  B282              movement_spacebelowisdiggable0:
132+  B282 08               ex af,af'                       ; store the loop counter
133+  B283 7E               ld a,(hl)                       ; get current pixel row
134+  B284 FE 55            cp 85
135+  B286 CA 91 B2         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
136+  B289 FE AA            cp 170
137+  B28B CA 91 B2         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
138+  B28E C3 A0 B2         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
139+  B291              movement_spacebelowisdiggable4:
140+  B291 1C               inc e                           ; inc count of rows to dig
141+  B292              movement_spacebelowisdiggable2:
142+  B292 79               ld a,c                          ; load the vertical coord
143+  B293 3C               inc a                           ; next row down
144+  B294 D5               push de                         ; need e for later
145+  B295 11 20 00         ld de,32
146+  B298 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
147+  B299 4F               ld c,a                          ; copy vert coord back to c
148+  B29A D1               pop de                          ; get e back
149+  B29B 08               ex af,af'                       ; get loop counter back
150+  B29C 3D               dec a                           ; incease loop counter
151+  B29D C2 82 B2         jp nz, movement_spacebelowisdiggable0
152+  B2A0              movement_spacebelowisdiggable5:
153+  B2A0 21 CD B3         ld hl,player+6
154+  B2A3 36 01            ld (hl),1                       ; set the player into digging mode
155+  B2A5 23               inc hl
156+  B2A6 36 03            ld (hl),3                      ; set the number of frame to dig for
157+  B2A8 23               inc hl
158+  B2A9 73               ld (hl),e                       ; set the number of pixels to dig
159+  B2AA C9               ret
160+  B2AB              movement_spacebelowisdiggable1:
161+  B2AB 21 CD B3         ld hl,player+6
162+  B2AE 36 00            ld (hl),0                       ; set the player out of digging mode
163+  B2B0 C9               ret
164+  B2B1
165+  B2B1              ;
166+  B2B1              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
167+  B2B1              ; Inputs:
168+  B2B1              ; hl - memory location of top pixel row
169+  B2B1              ; bc - screen coords, b horiz, c vert
170+  B2B1              ; Outputs:
171+  B2B1              ; none - puts player into digging mode
172+  B2B1              ;
173+  B2B1              movement_spaceaboveisdiggable:
174+  B2B1 7E               ld a,(hl)                       ; get first pixel row
175+  B2B2 FE 55            cp 85
176+  B2B4 CA BF B2         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
177+  B2B7 FE AA            cp 170
178+  B2B9 CA BF B2         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
179+  B2BC C3 6A B2         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
180+  B2BF              movement_spaceaboveisdiggable3:
181+  B2BF 3E 08            ld a,8                          ; rows to check
182+  B2C1 1E 00            ld e,0                          ; count of rows to dig
183+  B2C3              movement_spaceaboveisdiggable0:
184+  B2C3 08               ex af,af'                       ; store the loop counter
185+  B2C4 7E               ld a,(hl)                       ; get current pixel row
186+  B2C5 FE 55            cp 85
187+  B2C7 CA D2 B2         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
188+  B2CA FE AA            cp 170
189+  B2CC CA D2 B2         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
190+  B2CF C3 E2 B2         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
191+  B2D2              movement_spaceaboveisdiggable4:
192+  B2D2 1C               inc e                           ; inc count of rows to dig
193+  B2D3              movement_spaceaboveisdiggable2:
194+  B2D3 79               ld a,c                          ; load the vertical coord
195+  B2D4 3D               dec a                           ; next row up
196+  B2D5 D5               push de                         ; need e for later
197+  B2D6 11 20 00         ld de,32
198+  B2D9 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
199+  B2DB 4F               ld c,a                          ; copy vert coord back to c
200+  B2DC D1               pop de                          ; get e back
201+  B2DD 08               ex af,af'                       ; get loop counter back
202+  B2DE 3D               dec a                           ; incease loop counter
203+  B2DF C2 C3 B2         jp nz, movement_spaceaboveisdiggable0
204+  B2E2              movement_spaceaboveisdiggable5:
205+  B2E2 21 CD B3         ld hl,player+6
206+  B2E5 36 01            ld (hl),1                       ; set the player into digging mode
207+  B2E7 23               inc hl
208+  B2E8 36 05            ld (hl),5                       ; set the number of frame to dig for
209+  B2EA 23               inc hl
210+  B2EB 73               ld (hl),e                       ; set the number of pixels to dig
211+  B2EC C9               ret
212+  B2ED              movement_spaceaboveisdiggable1:
213+  B2ED 21 CD B3         ld hl,player+6
214+  B2F0 36 00            ld (hl),0                       ; set the player out of digging mode
215+  B2F2 C9               ret
216+  B2F3
217+  B2F3              ;
218+  B2F3              ; Checks if the player can move down
219+  B2F3              ; Inputs:
220+  B2F3              ; bc - player coords, b horiz, c vert
221+  B2F3              ; Outputs:
222+  B2F3              ; de - 1 can move
223+  B2F3              movement_checkcanmove_down:
224+  B2F3 F5               push af
225+  B2F4 C5               push bc
226+  B2F5 CD E7 A6         call sprites_scadd              ; get the memory location of cell into de
227+  B2F8 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
228+  B2FA 24               inc h                       ; memory location of cell beneath now in hl
229+  B2FB CD 1C B2         call movement_linebelowisempty       ; check space is empty
230+  B2FE 7B               ld a,e                          ; check space empty flag
231+  B2FF FE 00            cp 0
232+  B301 CA 0A B3         jp z, movement_checkcanmove_down1 ; can't move
233+  B304 CD 40 B4         call player_justmoved
234+  B307 C1               pop bc
235+  B308 F1               pop af
236+  B309 C9               ret
237+  B30A              movement_checkcanmove_down1:
238+  B30A C1               pop bc
239+  B30B CD E7 A6         call sprites_scadd              ; get the memory location of cell into de
240+  B30E 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
241+  B310 24               inc h
242+  B311 C5               push bc
243+  B312 CD 70 B2         call movement_spacebelowisdiggable    ; can't move here, but can we dig
244+  B315 11 00 00         ld de,0
245+  B318 C1               pop bc
246+  B319 F1               pop af
247+  B31A C9               ret
248+  B31B
249+  B31B              ;
250+  B31B              ; Checks if the player can move up
251+  B31B              ; Inputs:
252+  B31B              ; bc - player coords, b horiz, c vert
253+  B31B              ; Outputs:
254+  B31B              ; de - 1 can move
255+  B31B              movement_checkcanmove_up:
256+  B31B F5               push af
257+  B31C C5               push bc
258+  B31D CD E7 A6         call sprites_scadd              ; get the memory location of cell into de
259+  B320 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
260+  B322 11 20 00         ld de,32
261+  B325 ED 52            sbc hl,de                       ; memory location of line above now in hl
262+  B327 CD 2C B2         call movement_lineaboveisempty       ; check space is empty
263+  B32A 7B               ld a,e                          ; check space empty flag
264+  B32B FE 00            cp 0
265+  B32D CA 38 B3         jp z, movement_checkcanmove_up1 ; can't move
266+  B330 1E 01            ld e,1
267+  B332 CD 40 B4         call player_justmoved
268+  B335 C1               pop bc
269+  B336 F1               pop af
270+  B337 C9               ret
271+  B338              movement_checkcanmove_up1:
272+  B338 C1               pop bc
273+  B339 CD E7 A6         call sprites_scadd              ; get the memory location of cell into de
274+  B33C 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
275+  B33E 11 20 00         ld de,32
276+  B341 ED 52            sbc hl,de                       ; memory location of line above now in hl
277+  B343 C5               push bc
278+  B344 CD B1 B2         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
279+  B347 11 00 00         ld de,0
280+  B34A C1               pop bc
281+  B34B F1               pop af
282+  B34C C9               ret
283+  B34D
284+  B34D              ;
285+  B34D              ; Checks if the player can move right
286+  B34D              ; Inputs:
287+  B34D              ; bc - player coords, b horiz, c vert
288+  B34D              ; Outputs:
289+  B34D              ; de - 1 can move
290+  B34D              movement_checkcanmove_right:
291+  B34D F5               push af
292+  B34E C5               push bc
293+  B34F CD E7 A6         call sprites_scadd              ; get the memory location of cell into de
294+  B352 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
295+  B354 23               inc hl                          ; memory location of cell to the right now in hl
296+  B355 CD FD B1         call movement_spaceisempty       ; check space is empty
297+  B358 7B               ld a,e                          ; check space empty flag
298+  B359 FE 00            cp 0
299+  B35B CA 64 B3         jp z, movement_checkcanmove_right1 ; can't move
300+  B35E CD 40 B4         call player_justmoved
301+  B361 C1               pop bc
302+  B362 F1               pop af
303+  B363 C9               ret
304+  B364              movement_checkcanmove_right1:
305+  B364 C1               pop bc
306+  B365 CD E7 A6         call sprites_scadd              ; get the memory location of cell into de
307+  B368 62 6B            ld hl,de
308+  B36A 23               inc hl                          ; memory location of cell to the right now in hl
309+  B36B C5               push bc
310+  B36C CD 3C B2         call movement_spaceisdiggable    ; can't move here, but can we dig
311+  B36F 11 00 00         ld de,0
312+  B372 C1               pop bc
313+  B373 F1               pop af
314+  B374 C9               ret
315+  B375
316+  B375              ;
317+  B375              ; Checks if the player can move left
318+  B375              ; Inputs:
319+  B375              ; bc - player coords, b horiz, c vert
320+  B375              ; Outputs:
321+  B375              ; de - 1 can move
322+  B375              movement_checkcanmove_left:
323+  B375 F5               push af
324+  B376 C5               push bc
325+  B377 CD E7 A6         call sprites_scadd              ; get the memory location of cell into de
326+  B37A 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
327+  B37C 2B               dec hl                          ; memory location of cell to the right now in hl
328+  B37D CD FD B1         call movement_spaceisempty       ; check space is empty
329+  B380 7B               ld a,e                          ; check space empty flag
330+  B381 FE 00            cp 0
331+  B383 CA 8C B3         jp z, movement_checkcanmove_left1 ; can't move
332+  B386 CD 40 B4         call player_justmoved
333+  B389 C1               pop bc
334+  B38A F1               pop af
335+  B38B C9               ret
336+  B38C              movement_checkcanmove_left1:
337+  B38C C1               pop bc
338+  B38D CD E7 A6         call sprites_scadd              ; get the memory location of cell into de
339+  B390 62 6B            ld hl,de
340+  B392 2B               dec hl                          ; memory location of cell to the right now in hl
341+  B393 C5               push bc
342+  B394 CD 3C B2         call movement_spaceisdiggable    ; can't move here, but can we dig
343+  B397 11 00 00         ld de,0
344+  B39A C1               pop bc
345+  B39B F1               pop af
346+  B39C C9               ret
# file closed: game/movement.asm
 34   B39D                  include "game\game.asm"
# file opened: game/game.asm
  1+  B39D              ;
  2+  B39D              ; The current frame count, incremented each frame
  3+  B39D              ;
  4+  B39D              game_framenumber:
  5+  B39D 00               defb    0
  6+  B39E
  7+  B39E              ;
  8+  B39E              ; The number of players
  9+  B39E              ;
 10+  B39E              game_numberplayers:
 11+  B39E 01               defb 1
 12+  B39F
 13+  B39F              ;
 14+  B39F              ; The current player
 15+  B39F              ;
 16+  B39F              game_currentplayer:
 17+  B39F 01               defb 1
 18+  B3A0
 19+  B3A0              ;
 20+  B3A0              ; The default number of lives
 21+  B3A0              ;
 22+  B3A0              game_numberlives:
 23+  B3A0 03               defb 3
 24+  B3A1
 25+  B3A1              ;
 26+  B3A1              ; Moves to the next player
 27+  B3A1              ;
 28+  B3A1              game_changeplayer:
 29+  B3A1 3A 9F B3         ld a,(game_currentplayer)
 30+  B3A4 FE 01            cp 1
 31+  B3A6 C8               ret z                       ; if just one player, no need to change
 32+  B3A7 3D               dec a                       ; otherwise decrease by one
 33+  B3A8 EE 01            xor 1                       ; xor with one to flip
 34+  B3AA 3C               inc a                       ; increment
 35+  B3AB 21 9F B3         ld hl,game_currentplayer
 36+  B3AE 77               ld (hl),a                   ; store
 37+  B3AF C9               ret
 38+  B3B0
 39+  B3B0              ;
 40+  B3B0              ; Sets the number of players at the start of the game
 41+  B3B0              ; Inputs:
 42+  B3B0              ; a - number of players
 43+  B3B0              game_setnumberofplayers:
 44+  B3B0 21 9E B3         ld hl,game_numberplayers
 45+  B3B3 77               ld (hl),a
 46+  B3B4
 47+  B3B4              ;
 48+  B3B4              ; Increment frame number by 1
 49+  B3B4              ;
 50+  B3B4              game_incrementframe:
 51+  B3B4 3A 9D B3         ld a,(game_framenumber)
 52+  B3B7 FE FF            cp 255
 53+  B3B9 C2 BE B3         jp nz,game_incrementframe0
 54+  B3BC 3E 00            ld a,0
 55+  B3BE              game_incrementframe0:
 56+  B3BE 3C               inc a
 57+  B3BF 32 9D B3         ld (game_framenumber),a
 58+  B3C2 C9               ret
 59+  B3C3
 60+  B3C3              ;
 61+  B3C3              ; Returns current frame
 62+  B3C3              ; Outputs:
 63+  B3C3              ; a - current frame
 64+  B3C3              ;
 65+  B3C3              game_getcurrentframe:
 66+  B3C3 3A 9D B3         ld a,(game_framenumber)
 67+  B3C6 C9               ret
# file closed: game/game.asm
 35   B3C7                  include "game\player.asm"
# file opened: game/player.asm
  1+  B3C7              ;
  2+  B3C7              ;   Data for current player
  3+  B3C7              ;
  4+  B3C7              player:
  5+  B3C7 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  B3C9 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  B3CC 00               defb    0                   ; auto move remaining (+5)
  8+  B3CD 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  B3D0 00               defb    0                   ; lives remaining (+9)
 10+  B3D1 00               defb    0                   ; died this life (+10)
 11+  B3D2
 12+  B3D2              ;
 13+  B3D2              ; Score for the current player
 14+  B3D2              ;
 15+  B3D2              player_score:
 16+  B3D2 30 30 30 30      defb '000000'
 16+  B3D6 30 30
 17+  B3D8              ;
 18+  B3D8              ; Initializes a player at start of game
 19+  B3D8              ; Copy initial coords, copy lives, copy score
 20+  B3D8              ;
 21+  B3D8              player_init_gamestart:
 22+  B3D8 3A A0 B3         ld a,(game_numberlives)
 23+  B3DB 32 F8 B3         ld (player1_lives),a
 24+  B3DE 32 F9 B3         ld (player2_lives),a                        ; set the initial number of lives at game start
 25+  B3E1 C9               ret
 26+  B3E2
 27+  B3E2              ;
 28+  B3E2              ; Initializes a player at start of a life
 29+  B3E2              ; Copy initial coords, copy lives, copy score
 30+  B3E2              ;
 31+  B3E2              player_init_lifestart:
 32+  B3E2 ED 4B 0D 80      ld bc,(init_coord)
 33+  B3E6 ED 43 C7 B3      ld (player),bc
 34+  B3EA 01 D0 B3         ld bc,player+9
 35+  B3ED 3A F8 B3         ld a,(player1_lives)
 36+  B3F0 02               ld (bc),a
 37+  B3F1 01 D1 B3         ld bc,player+10
 38+  B3F4 3E 00            ld a,0
 39+  B3F6 02               ld (bc),a
 40+  B3F7 C9               ret
 41+  B3F8
 42+  B3F8              ;
 43+  B3F8              ; Player lives
 44+  B3F8              ;
 45+  B3F8              player1_lives:
 46+  B3F8 03               defb 3
 47+  B3F9              player2_lives:
 48+  B3F9 03               defb 3
 49+  B3FA
 50+  B3FA              ;
 51+  B3FA              ; Player scores
 52+  B3FA              ;
 53+  B3FA              player1_score:
 54+  B3FA 30 30 30 30      defb '000000'
 54+  B3FE 30 30
 55+  B400              player2_score:
 56+  B400 30 30 30 30      defb '000000'
 56+  B404 30 30
 57+  B406
 58+  B406              ;
 59+  B406              ; Kills a player this life
 60+  B406              ;
 61+  B406              player_killplayer:
 62+  B406 21 D1 B3         ld hl,player+10
 63+  B409 36 01            ld (hl),1
 64+  B40B C9               ret
 65+  B40C
 66+  B40C              ;
 67+  B40C              ; Draws the player at the current position or deletes them
 68+  B40C              ;
 69+  B40C              player_drawplayer:
 70+  B40C 3A C9 B3         ld a,(player+2)             ; get the current direction
 71+  B40F FE 03            cp 3
 72+  B411 C2 16 B4         jp nz,player_drawplayer0
 73+  B414 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
 74+  B416              player_drawplayer0:
 75+  B416 5F               ld e,a                      ; store in e
 76+  B417 3A CD B3         ld a,(player+6)             ; get the dig flag
 77+  B41A FE 01            cp 1
 78+  B41C CA 26 B4         jp z,player_drawplayer1    ; get dig frame
 79+  B41F 3A CA B3         ld a,(player+3)             ; this is normal movement so get the current frame
 80+  B422 83               add a,e
 81+  B423 C3 2B B4         jp player_drawplayer2
 82+  B426              player_drawplayer1
 83+  B426 3A C9 B3         ld a,(player+2)             ; get the current direction again, because want all four
 84+  B429 C6 06            add a,6                     ; add direction to 6 to get frame
 85+  B42B              player_drawplayer2
 86+  B42B 07               rlca
 87+  B42C 07               rlca
 88+  B42D 07               rlca                        ; multiply by eight
 89+  B42E 6F               ld l,a
 90+  B42F 26 00            ld h,0
 91+  B431 11 D7 AE         ld de,player_sprite
 92+  B434 19               add hl,de                   ; load hl with the location of the player sprite data
 93+  B435 ED 4B C7 B3      ld bc,(player)              ; load bc with the start coords
 94+  B439 CD A4 A6         call sprites_drawsprite     ; call the routine to draw the sprite
 95+  B43C CD 6C B4         call player_storeupdatedlines ; log updated rows
 96+  B43F C9               ret
 97+  B440
 98+  B440
 99+  B440              ;
100+  B440              ; Runs after the player just moved. Changes animation frame if required
101+  B440              ;
102+  B440              player_justmoved:
103+  B440 D9               exx
104+  B441 3A CB B3         ld a,(player+4)             ; get the transition count
105+  B444 FE 00            cp 0
106+  B446 CA 4C B4         jp z, player_justmoved2     ; if zero reset and change the frame
107+  B449 C3 66 B4         jp player_justmoved1       ; otherwise decrease and continue
108+  B44C              player_justmoved2:
109+  B44C                  ; reset and change frame in here
110+  B44C 3E 01            ld a,1
111+  B44E 32 CB B3         ld (player+4),a            ; reset back to whatever
112+  B451 3A CA B3         ld a,(player+3)             ; load the frame
113+  B454 FE 03            cp 3                       ; flip between 3 and 0
114+  B456 C2 5E B4         jp nz, player_justmoved4
115+  B459 3E 00            ld a,0
116+  B45B C3 60 B4         jp player_justmoved5
117+  B45E              player_justmoved4:
118+  B45E 3E 03            ld a,3
119+  B460              player_justmoved5:
120+  B460 32 CA B3         ld (player+3),a           ; save back
121+  B463 C3 6A B4         jp player_justmoved3
122+  B466              player_justmoved1:
123+  B466                  ; decrease count
124+  B466 3D               dec a
125+  B467 32 CB B3         ld (player+4),a
126+  B46A              player_justmoved3:
127+  B46A D9               exx;
128+  B46B C9               ret
129+  B46C
130+  B46C              ;
131+  B46C              ; Stores the updated rows associated with the player
132+  B46C              ;
133+  B46C              player_storeupdatedlines:
134+  B46C ED 4B C7 B3      ld bc,(player)          ; get the screen coords into bc
135+  B470 79               ld a,c                  ; get the player block coords of current block
136+  B471 E6 F8            and 248                 ; find closest multiple of eight
137+  B473 0F               rrca
138+  B474 0F               rrca
139+  B475 0F               rrca                    ; divide by 8
140+  B476 ED 5B 25 A5      ld de,(screen_offset)          ; load the screen offset, this is in rows
141+  B47A 93               sub e
142+  B47B F5               push af
143+  B47C CD D8 A3         call buffer_marklineforupdate  ; store current row in updated lines
144+  B47F F1               pop af
145+  B480 3D               dec a
146+  B481 F5               push af
147+  B482 CD D8 A3         call buffer_marklineforupdate  ; store line above
148+  B485 F1               pop af
149+  B486 3C               inc a
150+  B487 3C               inc a
151+  B488 CD D8 A3         call buffer_marklineforupdate  ; store line beneath
152+  B48B C9               ret
# file closed: game/player.asm
 36   B48C                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  B48C              ;
  2+  B48C              ; Ship initial position: vert,horiz
  3+  B48C              ;
  4+  B48C              ship_initpos:
  5+  B48C 00 24            defb 0,36
  6+  B48E              ship_initpos2:
  7+  B48E 00 00            defb 0,0
  8+  B490              ship_frame:
  9+  B490 00               defb 0
 10+  B491              ;
 11+  B491              ; The current memory location
 12+  B491              ;
 13+  B491              ship_current_sprite:
 14+  B491 00 00            defb 0,0
 15+  B493
 16+  B493              ship_current_coords:
 17+  B493 00 00            defb 0,0
 18+  B495
 19+  B495              ;
 20+  B495              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 21+  B495              ;
 22+  B495              ship_land:
 23+  B495 ED 4B 8C B4      ld bc,(ship_initpos)
 24+  B499 ED 43 8E B4      ld (ship_initpos2),bc        ; save the initial position for later use
 25+  B49D 1E 00            ld e,0                      ; store a flag to track first time round
 26+  B49F 06 09            ld b,9                      ; move down 8 pixels
 27+  B4A1              ship_land0:
 28+  B4A1 C5               push bc
 29+  B4A2 7B               ld a,e
 30+  B4A3 D5               push de                     ; store de for next time round
 31+  B4A4 FE 01            cp 1                        ; check first time flag
 32+  B4A6 C2 BB B4         jp nz,ship_land1             ; don't draw over previous one if first time
 33+  B4A9 CD 23 B5         call ship_draw_full         ; delete old one
 34+  B4AC CD F8 B4         call ship_change_frame      ; increment the frame
 35+  B4AF ED 4B 8E B4      ld bc,(ship_initpos2)       ; get the current coords
 36+  B4B3 81 C6 01         add c,1                     ; move down one pixels
 37+  B4B6 4F               ld c,a
 38+  B4B7 ED 43 8E B4      ld (ship_initpos2),bc
 39+  B4BB              ship_land1:
 40+  B4BB CD 23 B5         call ship_draw_full         ; draw the ship
 41+  B4BE CD 0D B5         call ship_draw_screen
 42+  B4C1 D1               pop de
 43+  B4C2 1E 01            ld e,1
 44+  B4C4 C1               pop bc
 45+  B4C5 10 DA            djnz ship_land0             ; repeat for downward movement
 46+  B4C7                  ; done moving down
 47+  B4C7                  ; now move across
 48+  B4C7 CD 0C B4         call player_drawplayer      ; draw player
 49+  B4CA CD 23 B5         call ship_draw_full         ; delete old one
 50+  B4CD 1E 00            ld e,0                      ; store a flag to track first time round
 51+  B4CF 06 14            ld b,20                      ; move back 20 pixels pixels
 52+  B4D1              ship_land3:
 53+  B4D1 C5               push bc
 54+  B4D2 7B               ld a,e
 55+  B4D3 D5               push de                     ; store de for next time round
 56+  B4D4 FE 01            cp 1                        ; check first time flag
 57+  B4D6 C2 EB B4         jp nz,ship_land2             ; don't draw over previous one if first time
 58+  B4D9 CD 23 B5         call ship_draw_full         ; delete old one
 59+  B4DC CD F8 B4         call ship_change_frame      ; increment the frame
 60+  B4DF ED 4B 8E B4      ld bc,(ship_initpos2)       ; get the current coords
 61+  B4E3 78               ld a,b
 62+  B4E4 D6 01            sub 1                       ; move back one pixels
 63+  B4E6 47               ld b,a
 64+  B4E7 ED 43 8E B4      ld (ship_initpos2),bc
 65+  B4EB              ship_land2:
 66+  B4EB CD 23 B5         call ship_draw_full         ; draw the ship
 67+  B4EE CD 0D B5         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 68+  B4F1 D1               pop de
 69+  B4F2 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 70+  B4F4 C1               pop bc
 71+  B4F5 10 DA            djnz ship_land3             ; repeat for vertical movement
 72+  B4F7 C9               ret
 73+  B4F8
 74+  B4F8              ;
 75+  B4F8              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
 76+  B4F8              ;
 77+  B4F8              ship_change_frame:
 78+  B4F8 F5               push af
 79+  B4F9 3A 90 B4         ld a,(ship_frame)
 80+  B4FC FE 00            cp 0
 81+  B4FE CA 06 B5         jp z,ship_change_frame0
 82+  B501 3E 00            ld a,0                      ; flip to 0
 83+  B503 C3 08 B5         jp ship_change_frame1
 84+  B506              ship_change_frame0:
 85+  B506 3E 20            ld a,32                      ; flip to 32
 86+  B508              ship_change_frame1:
 87+  B508 32 90 B4         ld (ship_frame),a            ; save the frame
 88+  B50B F1               pop af
 89+  B50C C9               ret
 90+  B50D
 91+  B50D              ship_draw_screen:
 92+  B50D 3E 00            ld a,0
 93+  B50F CD D8 A3         call buffer_marklineforupdate
 94+  B512 3E 01            ld a,1
 95+  B514 CD D8 A3         call buffer_marklineforupdate
 96+  B517 3E 02            ld a,2
 97+  B519 CD D8 A3         call buffer_marklineforupdate   ; mark the first three rows for update
 98+  B51C 76               halt
 99+  B51D F3               di
100+  B51E CD 6C A4         call buffer_buffertoscreen  ; copy buffer to screen
101+  B521 FB               ei                          ; enable interupts
102+  B522 C9               ret
103+  B523
104+  B523              ship_draw_full:
105+  B523 21 27 AF         ld hl,ship_sprite
106+  B526 ED 4B 8E B4      ld bc,(ship_initpos2)         ; load bc with the start coords
107+  B52A 22 91 B4         ld (ship_current_sprite),hl  ; put into memory
108+  B52D ED 43 93 B4      ld (ship_current_coords),bc  ; put into memory
109+  B531 CD 50 B5         call ship_draw
110+  B534 08               ex af,af'
111+  B535 3A 90 B4         ld a,(ship_frame)            ; get the animation frame
112+  B538 16 00            ld d,0
113+  B53A 5F               ld e,a
114+  B53B 19               add hl,de
115+  B53C 22 91 B4         ld (ship_current_sprite),hl  ; put into memory
116+  B53F 08               ex af,af'
117+  B540 ED 4B 8E B4      ld bc,(ship_initpos2)         ; load bc with the start coords
118+  B544 81 C6 08         add c,8                      ; move one line down
119+  B547 4F               ld c,a
120+  B548 ED 43 93 B4      ld (ship_current_coords),bc  ; put into memory
121+  B54C CD 50 B5         call ship_draw
122+  B54F C9               ret
123+  B550
124+  B550              ;
125+  B550              ; Draw the ship
126+  B550              ; Inputs:
127+  B550              ; None, all in memory
128+  B550              ;
129+  B550              ship_draw:
130+  B550 3E 04            ld a,4                              ; 4 pieces per half
131+  B552              ship_draw0:
132+  B552 F5               push af
133+  B553 2A 91 B4         ld hl,(ship_current_sprite)
134+  B556 ED 4B 93 B4      ld bc,(ship_current_coords)         ; load bc with the start coords
135+  B55A CD A4 A6         call sprites_drawsprite
136+  B55D 2A 91 B4         ld hl,(ship_current_sprite)
137+  B560 ED 4B 93 B4      ld bc,(ship_current_coords)         ; load bc with the start coords
138+  B564 11 08 00         ld de,8
139+  B567 19               add hl,de
140+  B568 80 C6 08         add b,8
141+  B56B 47               ld b,a
142+  B56C 22 91 B4         ld (ship_current_sprite),hl         ; put into memory
143+  B56F ED 43 93 B4      ld (ship_current_coords),bc         ; put into memory
144+  B573 F1               pop af
145+  B574 3D               dec a
146+  B575 FE 00            cp 0
147+  B577 C2 52 B5         jp nz,ship_draw0
148+  B57A
149+  B57A C9               ret
150+  B57B
# file closed: game/ship.asm
 37   B57B                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  B57B              ;
  2+  B57B              ; tank initial position: vert,horiz
  3+  B57B              ;
  4+  B57B              tank_initpos:
  5+  B57B 10 D0            defb 16,208
  6+  B57D              tank_initpos2:
  7+  B57D 00 00            defb 0,0
  8+  B57F              tank_frame:
  9+  B57F 00               defb 0
 10+  B580              tank_anim:
 11+  B580 11               defb 17
 12+  B581              ;
 13+  B581              ; The current memory location
 14+  B581              ;
 15+  B581              tank_current_sprite:
 16+  B581 00 00            defb 0,0
 17+  B583
 18+  B583              tank_current_coords:
 19+  B583 00 00            defb 0,0
 20+  B585
 21+  B585              ;
 22+  B585              ; Initialise the tank
 23+  B585              ;
 24+  B585              tank_init:
 25+  B585 ED 4B 7B B5      ld bc,(tank_initpos)
 26+  B589 ED 43 7D B5      ld (tank_initpos2),bc       ; save the initial position for later use
 27+  B58D C9               ret
 28+  B58E
 29+  B58E              ;
 30+  B58E              ;   Draw and move the tank
 31+  B58E              ;   Start processing at frame 200
 32+  B58E              ;   Don't move if anim is zero
 33+  B58E              ;   Decrement frame if moved
 34+  B58E              ;
 35+  B58E              tank_process:
 36+  B58E 3A 80 B5         ld a,(tank_anim)
 37+  B591 FE 00            cp 0
 38+  B593 C8               ret z                       ; return if we've already moved
 39+  B594 CD C3 B3         call game_getcurrentframe   ; get the current frame number into a
 40+  B597 FE 4B            cp 75
 41+  B599 D8               ret c                       ; return if the frame number is below 100
 42+  B59A CD A5 B5         call tank_move              ; move tank if not
 43+  B59D 3A 80 B5         ld a,(tank_anim)
 44+  B5A0 3D               dec a
 45+  B5A1 32 80 B5         ld (tank_anim),a            ; decrease the anim count
 46+  B5A4 C9               ret
 47+  B5A5
 48+  B5A5              tank_move:
 49+  B5A5 ED 4B 7D B5      ld bc,(tank_initpos2)
 50+  B5A9 C5               push bc
 51+  B5AA 3A 80 B5         ld a,(tank_anim)
 52+  B5AD FE 11            cp 17                       ; check first time flag
 53+  B5AF CA C1 B5         jp z,tank_move1             ; don't draw over previous one if first time
 54+  B5B2 CD C6 B5         call tank_draw_full         ; delete old one
 55+  B5B5 ED 4B 7D B5      ld bc,(tank_initpos2)       ; get the current coords
 56+  B5B9 78               ld a,b
 57+  B5BA D6 01            sub 1                       ; move back one pixels
 58+  B5BC 47               ld b,a
 59+  B5BD ED 43 7D B5      ld (tank_initpos2),bc
 60+  B5C1              tank_move1:
 61+  B5C1 CD C6 B5         call tank_draw_full         ; draw the tank
 62+  B5C4 C1               pop bc
 63+  B5C5 C9               ret
 64+  B5C6
 65+  B5C6              tank_draw_full:
 66+  B5C6 21 87 AF         ld hl,tank_sprite
 67+  B5C9 ED 4B 7D B5      ld bc,(tank_initpos2)         ; load bc with the start coords
 68+  B5CD 22 81 B5         ld (tank_current_sprite),hl  ; put into memory
 69+  B5D0 ED 43 83 B5      ld (tank_current_coords),bc  ; put into memory
 70+  B5D4 CD FD B5         call tank_draw
 71+  B5D7 08               ex af,af'
 72+  B5D8 3A 7F B5         ld a,(tank_frame)            ; get the animation frame
 73+  B5DB 16 00            ld d,0
 74+  B5DD 5F               ld e,a
 75+  B5DE 19               add hl,de
 76+  B5DF 22 81 B5         ld (tank_current_sprite),hl  ; put into memory
 77+  B5E2 08               ex af,af'
 78+  B5E3 ED 4B 7D B5      ld bc,(tank_initpos2)         ; load bc with the start coords
 79+  B5E7 81 C6 08         add c,8                      ; move one line down
 80+  B5EA 4F               ld c,a
 81+  B5EB ED 43 83 B5      ld (tank_current_coords),bc  ; put into memory
 82+  B5EF CD FD B5         call tank_draw
 83+  B5F2 3E 02            ld a,2
 84+  B5F4 CD D8 A3         call buffer_marklineforupdate
 85+  B5F7 3E 03            ld a,3
 86+  B5F9 CD D8 A3         call buffer_marklineforupdate   ; mark the first two rows for update
 87+  B5FC C9               ret
 88+  B5FD
 89+  B5FD              ;
 90+  B5FD              ; Draw the tank
 91+  B5FD              ; Inputs:
 92+  B5FD              ; None, all in memory
 93+  B5FD              ;
 94+  B5FD              tank_draw:
 95+  B5FD 3E 04            ld a,4                              ; 4 pieces per half
 96+  B5FF              tank_draw0:
 97+  B5FF F5               push af
 98+  B600 2A 81 B5         ld hl,(tank_current_sprite)
 99+  B603 ED 4B 83 B5      ld bc,(tank_current_coords)         ; load bc with the start coords
100+  B607 CD A4 A6         call sprites_drawsprite
101+  B60A 2A 81 B5         ld hl,(tank_current_sprite)
102+  B60D ED 4B 83 B5      ld bc,(tank_current_coords)         ; load bc with the start coords
103+  B611 11 08 00         ld de,8
104+  B614 19               add hl,de
105+  B615 80 C6 08         add b,8
106+  B618 47               ld b,a
107+  B619 22 81 B5         ld (tank_current_sprite),hl         ; put into memory
108+  B61C ED 43 83 B5      ld (tank_current_coords),bc         ; put into memory
109+  B620 F1               pop af
110+  B621 3D               dec a
111+  B622 FE 00            cp 0
112+  B624 C2 FF B5         jp nz,tank_draw0
113+  B627
114+  B627 C9               ret
115+  B628
# file closed: game/tank.asm
 38   B628                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  B628              ;
  2+  B628              ; A structure of falling rocks
  3+  B628              ; Assume we'll never have more than 4 falling at any one time
  4+  B628              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  B628              ;
  6+  B628              rocks_falling:
  7+  B628 00 00 00 00      defb 0,0,0,0
  8+  B62C 00 00 00 00      defb 0,0,0,0
  9+  B630 00 00 00 00      defb 0,0,0,0
 10+  B634 00 00 00 00      defb 0,0,0,0
 11+  B638
 12+  B638              rocks_tmp:
 13+  B638 00               defb 0
 14+  B639
 15+  B639              rocks_tmp2:
 16+  B639 00 00            defb 0,0
 17+  B63B
 18+  B63B              ;
 19+  B63B              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 20+  B63B              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 21+  B63B              ; If the pixel row is not the rock bottom, stop checking.
 22+  B63B              ; Inputs:
 23+  B63B              ; hl- memory location
 24+  B63B              ;
 25+  B63B              rocks_checkforfalling:
 26+  B63B 7E               ld a,(hl)           ; get the pixel row in this memory location
 27+  B63C FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 28+  B63E C2 44 B6         jp nz,rocks_checkforfalling2 ; not a rock, stop
 29+  B641 CD 45 B6         call rocks_addrocktofalling ; mark the rock as falling
 30+  B644              rocks_checkforfalling2:
 31+  B644 C9               ret
 32+  B645
 33+  B645              ;
 34+  B645              ; Adds the rock to the structure that tracks falling rocks
 35+  B645              ; Inputs:
 36+  B645              ; hl - memory location of falling rock graphic
 37+  B645              ; bc - coords of rock, c vert
 38+  B645              rocks_addrocktofalling:
 39+  B645 C5               push bc             ; store the coords
 40+  B646 11 28 B6         ld de,rocks_falling
 41+  B649 06 04            ld b,4              ; number of possible falling rocks
 42+  B64B              rocks_addrocktofalling0:
 43+  B64B 13               inc de
 44+  B64C 13               inc de
 45+  B64D 13               inc de              ; move three along to get the state
 46+  B64E 1A               ld a,(de)           ; load the state
 47+  B64F FE 00            cp 0                ; check if this is not falling
 48+  B651 C2 66 B6         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 49+  B654 3E 10            ld a,16             ; load the number of frames to wobble
 50+  B656 12               ld (de),a
 51+  B657 1B               dec de              ; move de back to state
 52+  B658 3E 02            ld a,2
 53+  B65A 12               ld (de),a           ; set the state to wobbling
 54+  B65B 1B               dec de              ; move back coords
 55+  B65C C1               pop bc              ; get back coords
 56+  B65D 78               ld a,b
 57+  B65E 12               ld (de),a           ; store the vertical
 58+  B65F 1B               dec de
 59+  B660 79               ld a,c
 60+  B661 12               ld (de),a           ; store the horizontal
 61+  B662 C5               push bc
 62+  B663 C3 69 B6         jp rocks_addrocktofalling2 ; done
 63+  B666              rocks_addrocktofalling1:
 64+  B666 13               inc de              ; move memory along to next rock
 65+  B667 10 E2            djnz rocks_addrocktofalling0 ; try the next rock
 66+  B669              rocks_addrocktofalling2: ; done, return
 67+  B669 C1               pop bc              ; to tidy up
 68+  B66A C9               ret
 69+  B66B
 70+  B66B              ;
 71+  B66B              ; Processes any falling rocks
 72+  B66B              ;
 73+  B66B              rocks_processrocks:
 74+  B66B DD 21 28 B6      ld ix,rocks_falling
 75+  B66F 06 04            ld b,4              ; the number of rocks to check
 76+  B671              rocks_processrocks0:
 77+  B671 C5               push bc             ; store loop count
 78+  B672 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 78+  B676 46 01
 79+  B678 DD 23            inc ix
 80+  B67A DD 23            inc ix              ; move to the state
 81+  B67C DD 7E 00         ld a,(ix)           ; load the state into a
 82+  B67F FE 00            cp 0
 83+  B681 CA A5 B6         jp z,rocks_processrocks3 ; if not falling, check next
 84+  B684 FE 02            cp 2
 85+  B686 C2 96 B6         jp nz, rocks_processrocks2
 86+  B689                  ; we're wobbling
 87+  B689 DD 23            inc ix              ; get frame number for wobble
 88+  B68B DD 7E 00         ld a,(ix)           ; get wobble frame into a
 89+  B68E CD 5B B7         call rocks_wobble
 90+  B691 DD 23            inc ix              ; increment for next
 91+  B693 C3 A9 B6         jp rocks_processrocks1  ; do next rock
 92+  B696              rocks_processrocks2:
 93+  B696                  ; we're falling
 94+  B696 C5               push bc
 95+  B697 CD C2 B6         call rocks_fall
 96+  B69A C1               pop bc
 97+  B69B CD AD B6         call rocks_storeupdatedlines
 98+  B69E DD 23            inc ix
 99+  B6A0 DD 23            inc ix              ; inc ix to get to next
100+  B6A2 C3 A9 B6         jp rocks_processrocks1
101+  B6A5              rocks_processrocks3:
102+  B6A5 DD 23            inc ix
103+  B6A7 DD 23            inc ix
104+  B6A9              rocks_processrocks1:
105+  B6A9 C1               pop bc              ; get loop count back
106+  B6AA 10 C5            djnz rocks_processrocks0
107+  B6AC C9               ret
108+  B6AD
109+  B6AD              ;
110+  B6AD              ; Stores the updated rows associated with the rock
111+  B6AD              ; Inputs:
112+  B6AD              ; bc - coords
113+  B6AD              ;
114+  B6AD              rocks_storeupdatedlines:
115+  B6AD 79               ld a,c                  ; get the player block coords of current block
116+  B6AE E6 F8            and 248                 ; find closest multiple of eight
117+  B6B0 0F               rrca
118+  B6B1 0F               rrca
119+  B6B2 0F               rrca                    ; divide by 8
120+  B6B3 ED 5B 25 A5      ld de,(screen_offset)          ; load the screen offset, this is in rows
121+  B6B7 93               sub e
122+  B6B8 F5               push af
123+  B6B9 CD D8 A3         call buffer_marklineforupdate  ; store current row in updated lines
124+  B6BC F1               pop af
125+  B6BD 3C               inc a
126+  B6BE CD D8 A3         call buffer_marklineforupdate  ; store line beneath
127+  B6C1 C9               ret
128+  B6C2
129+  B6C2              ;
130+  B6C2              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
131+  B6C2              ; bc - coord of current rock graphic on screen
132+  B6C2              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
133+  B6C2              ;
134+  B6C2              rocks_fall:
135+  B6C2 DD 2B            dec ix
136+  B6C4 DD 2B            dec ix              ; decrease ix back to coords
137+  B6C6 ED 43 39 B6      ld (rocks_tmp2),bc  ; store original coords
138+  B6CA 3E 03            ld a,3              ; move this number of pixels
139+  B6CC              rocks_fall1:
140+  B6CC 08               ex af,af'
141+  B6CD DD 4E 00 DD      ld bc,(ix)          ; get current coords
141+  B6D1 46 01
142+  B6D3 CD E7 A6         call sprites_scadd  ; get the memory of the coords into de
143+  B6D6 14               inc d               ; add 256 to get next row
144+  B6D7 1A               ld a,(de)           ; get the contents of the next row
145+  B6D8 FE 00            cp 0
146+  B6DA C2 33 B7         jp nz,rocks_fall3    ; move the rock if the row is empty
147+  B6DD 0C               inc c               ; increment the vertical
148+  B6DE DD 71 00 DD      ld (ix),bc          ; store the new coords
148+  B6E2 70 01
149+  B6E4 79               ld a,c              ; get the vertical coord into a
150+  B6E5 E6 07            and 7               ; divisible by 8?
151+  B6E7 FE 00            cp 0
152+  B6E9 C2 04 B7         jp nz,rocks_fall4   ; if not, carry on
153+  B6EC CD 47 A6         call screen_getattraddressfromscreencoords ; get the attr address into de
154+  B6EF 62 6B            ld hl,de
155+  B6F1 36 42            ld (hl),66          ; load this square with the yellow colour
156+  B6F3 DD 4E 00 DD      ld bc,(ix)
156+  B6F7 46 01
157+  B6F9 79               ld a,c              ; get vertical
158+  B6FA D6 08            sub 8               ; look up one square
159+  B6FC 4F               ld c,a              ; put a back in c
160+  B6FD CD 47 A6         call screen_getattraddressfromscreencoords ; get the attr address into de
161+  B700 62 6B            ld hl,de
162+  B702 36 46            ld (hl),70          ; load this square with the yellow colour
163+  B704              rocks_fall4:
164+  B704 08               ex af,af'
165+  B705 3D               dec a
166+  B706 FE 00            cp 0
167+  B708 C2 CC B6         jp nz,rocks_fall1   ; do another pixel if needed
168+  B70B              rocks_fall2:
169+  B70B 3E 09            ld a,9              ; rock graphic
170+  B70D ED 4B 39 B6      ld bc,(rocks_tmp2)  ; get the original coords
171+  B711 CD 82 A6         call screen_getblock     ; get the memory into hl
172+  B714 CD A4 A6         call sprites_drawsprite  ; draw the sprite - over the top of the current one
173+  B717 3E 09            ld a,9
174+  B719 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
174+  B71D 46 01
175+  B71F CD 82 A6         call screen_getblock     ; get the memory into hl
176+  B722 CD A4 A6         call sprites_drawsprite  ; draw the sprite - over the top of the current one
177+  B725 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
177+  B729 46 01
178+  B72B CD 48 B7         call rocks_checkforplayer ; check to see if we hit a player
179+  B72E DD 23            inc ix
180+  B730 DD 23            inc ix                  ; get ix back to state
181+  B732 C9               ret
182+  B733              rocks_fall3:
183+  B733 3E 00            ld a,0              ; set the state to fell
184+  B735 DD 77 02         ld (ix+2),a           ; store the falling state
185+  B738 DD 4E 00 DD      ld bc,(ix)          ; get the coords
185+  B73C 46 01
186+  B73E CD 47 A6         call screen_getattraddressfromscreencoords ; get the attr address into de
187+  B741 62 6B            ld hl,de
188+  B743 36 42            ld (hl),66
189+  B745 C3 0B B7         jp rocks_fall2      ; rejoin main loop
190+  B748
191+  B748              ;
192+  B748              ; Checks to see if the rock is hitting a player
193+  B748              ; Inputs:
194+  B748              ; bc - coords of rock we're checking
195+  B748              rocks_checkforplayer:
196+  B748 ED 5B C7 B3      ld de,(player)       ; get the player coords
197+  B74C 7B               ld a,e               ; get the vert coord first
198+  B74D 91               sub c                ; subtract the rock vertical coord from players
199+  B74E FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
200+  B750 C0               ret nz               ; if not, hasn't hit
201+  B751 7A               ld a,d               ; get the player horiz coord
202+  B752 90               sub b                ; subtract rock coord
203+  B753 C6 07            add 7                ; add max distance
204+  B755 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
205+  B757 DC 06 B4         call c, player_killplayer ; if so, jump out
206+  B75A C9               ret
207+  B75B
208+  B75B              ;
209+  B75B              ; Wobbles a rocks
210+  B75B              ; Inputs:
211+  B75B              ; bc - coord of current rock graphic on screen
212+  B75B              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
213+  B75B              ; a - wobble frame
214+  B75B              rocks_wobble:
215+  B75B 3A 38 B6         ld a,(rocks_tmp)    ; get the frame toggle
216+  B75E 1E 09            ld e,9              ; this is the rock frame
217+  B760 83               add a,e             ; add the frame toggle
218+  B761 C5               push bc
219+  B762 CD 82 A6         call screen_getblock     ; get the memory into hl
220+  B765 CD A4 A6         call sprites_drawsprite  ; draw the sprite - over the top of the current one
221+  B768 3A 38 B6         ld a,(rocks_tmp)    ; get the frame toggle against
222+  B76B EE 01            xor 1               ; flip to other state
223+  B76D 32 38 B6         ld (rocks_tmp),a    ; store
224+  B770 1E 09            ld e,9              ; this is the rock frame
225+  B772 83               add a,e             ; add the frame toggle
226+  B773 CD 82 A6         call screen_getblock     ; get the memory into hl
227+  B776 C1               pop bc
228+  B777 CD A4 A6         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
229+  B77A DD 7E 00         ld a,(ix)           ; get the wobble count back
230+  B77D 3D               dec a               ; decrease
231+  B77E DD 77 00         ld (ix),a           ; store
232+  B781 FE 00            cp 0
233+  B783 C0               ret nz              ; if we're not at zero, return
234+  B784 DD 2B            dec ix              ; otherwise look to state location
235+  B786 3E 01            ld a,1              ; set the state to falling
236+  B788 DD 77 00         ld (ix),a           ; store the falling state
237+  B78B DD 23            inc ix              ; set ix back to location of wobble count, and we're done
238+  B78D C9               ret
239+  B78E
# file closed: game/rocks.asm
 39   B78E                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  B78E              ;
  2+  B78E              ; The score of the current player
  3+  B78E              ;
  4+  B78E              scores_current:
  5+  B78E 30 30 30 30      defb '000000'
  5+  B792 30 30
  6+  B794
  7+  B794              ;
  8+  B794              ; The current high score table
  9+  B794              ;
 10+  B794              scores_table:
 11+  B794 03 17 47 41      defb 3,23,'GAM',255
 11+  B798 4D FF
 12+  B79A 06 17 30 30      defb 6,23,'00000 ',255
 12+  B79E 30 30 30 20
 12+  B7A2 FF
 13+  B7A3 0C 17 47 41      defb 12,23,'GAM',255
 13+  B7A7 4D FF
 14+  B7A9 0F 17 30 30      defb 15,23,'00000 ',255
 14+  B7AD 30 30 30 20
 14+  B7B1 FF
 15+  B7B2 15 17 47 41      defb 21,23,'GAM',255
 15+  B7B6 4D FF
 16+  B7B8 18 17 30 30      defb 24,23,'00000 ',255
 16+  B7BC 30 30 30 20
 16+  B7C0 FF
 17+  B7C1
 18+  B7C1              ;
 19+  B7C1              ; Displays the high score table at the bottom of the screen
 20+  B7C1              ;
 21+  B7C1              scores_showtable:
 22+  B7C1 21 94 B7         ld hl, scores_table
 23+  B7C4 CD D8 82         call string_print
 24+  B7C7 21 9A B7         ld hl, scores_table+6
 25+  B7CA CD D8 82         call string_print
 26+  B7CD 21 A3 B7         ld hl, scores_table+15
 27+  B7D0 CD D8 82         call string_print
 28+  B7D3 21 A9 B7         ld hl, scores_table+21
 29+  B7D6 CD D8 82         call string_print
 30+  B7D9 21 B2 B7         ld hl, scores_table+30
 31+  B7DC CD D8 82         call string_print
 32+  B7DF 21 B8 B7         ld hl, scores_table+36
 33+  B7E2 CD D8 82         call string_print
 34+  B7E5 C9               ret
# file closed: game/scores.asm
 40   B7E6                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  B7E6              ;
  2+  B7E6              ; Changes the attribute of gem and diamond cells based on the frame count
  3+  B7E6              ; Inputs:
  4+  B7E6              ; hl - memory location of gem type
  5+  B7E6              diamonds_twinkle_type:
  6+  B7E6 CD C3 B3         call game_getcurrentframe       ; get current frame number
  7+  B7E9 E6 07            and 7                           ; want a number from 0-7
  8+  B7EB C6 40            add 64                          ; add to 60 to get attr colour
  9+  B7ED              diamonds_twinkle_type0:
 10+  B7ED 4E               ld c,(hl)                      ; get coords into bc
 11+  B7EE 08               ex af, af'
 12+  B7EF 79               ld a,c                          ; load c into add
 13+  B7F0 FE FF            cp 255                          ; is this the end?
 14+  B7F2 CA 09 B8         jp z,diamonds_twinkle_type1           ; step out if so
 15+  B7F5 23               inc hl
 16+  B7F6 23               inc hl
 17+  B7F7 7E               ld a,(hl)                       ; check the state, don't process if collection
 18+  B7F8 FE 01            cp 1
 19+  B7FA CA 09 B8         jp z,diamonds_twinkle_type1           ; step out if so
 20+  B7FD 23               inc hl
 21+  B7FE 08               ex af,af'
 22+  B7FF 5E 23 56 2B      ld de,(hl)                      ; get the memory location into de
 23+  B803 12               ld (de),a                       ; set the value of attr
 24+  B804 23               inc hl
 25+  B805 23               inc hl                          ; move to next diamond
 26+  B806 C3 ED B7         jp diamonds_twinkle_type0
 27+  B809              diamonds_twinkle_type1:
 28+  B809 C9               ret
 29+  B80A
 30+  B80A              ;
 31+  B80A              ; Initialise diamonds and gems
 32+  B80A              ;
 33+  B80A              diamonds_twinkle
 34+  B80A 21 CB AD         ld hl, level01diamonds
 35+  B80D CD E6 B7         call diamonds_twinkle_type
 36+  B810 21 DB AD         ld hl, level01gems
 37+  B813 CD E6 B7         call diamonds_twinkle_type
 38+  B816 C9               ret
 39+  B817
 40+  B817              ;
 41+  B817              ; Initialise diamonds and gems
 42+  B817              ;
 43+  B817              diamonds_init:
 44+  B817 21 CB AD         ld hl, level01diamonds
 45+  B81A CD 24 B8         call diamonds_init_type
 46+  B81D 21 DB AD         ld hl, level01gems
 47+  B820 CD 24 B8         call diamonds_init_type
 48+  B823 C9               ret
 49+  B824
 50+  B824              ;
 51+  B824              ; Initialise diamonds or gems, get memory addresses
 52+  B824              ; Inputs:
 53+  B824              ; hl - memory location
 54+  B824              diamonds_init_type:
 55+  B824 4E               ld c,(hl)                      ; get coords into c
 56+  B825 79               ld a,c                          ; load c into add
 57+  B826 FE FF            cp 255                          ; is this the end?
 58+  B828 CA 3D B8         jp z,diamonds_init_type1             ; step out if so
 59+  B82B 23               inc hl
 60+  B82C 46               ld b,(hl)                       ; get coords into b
 61+  B82D E5               push hl
 62+  B82E CD 17 A6         call screen_getcellattradress ; get memory of attr for this diamond into de
 63+  B831 E1               pop hl
 64+  B832 23               inc hl                          ; move to state
 65+  B833 23               inc hl                          ; move to memory
 66+  B834 73 23 72 2B      ld (hl),de                      ; store the memory location
 67+  B838 23               inc hl                          ; move to next diamond
 68+  B839 23               inc hl
 69+  B83A C3 24 B8         jp diamonds_init_type
 70+  B83D              diamonds_init_type1:
 71+  B83D C9               ret
# file closed: game/diamonds.asm
 41   B83E
 42   B83E              ;===========================================================================
 43   B83E              ; main routine - the code execution starts here.
 44   B83E              ; Sets up the new interrupt routine, the memory
 45   B83E              ; banks and jumps to the start loop.
 46   B83E              ;===========================================================================
 47   B83E              main:
 48   B83E
 49   B83E                  ; Setup stack
 50   B83E 31 67 B9         ld sp,stack_top
 51   B841
 52   B841                  ; Draw the title screen
 53   B841 CD 0C A7         call titlescreen_show
 54   B844
 55   B844 CD D8 B3         call player_init_gamestart
 56   B847
 57   B847              main_lifestart:
 58   B847 21 25 A5         ld hl,screen_offset
 59   B84A 36 00            ld (hl),0
 60   B84C 21 26 A5         ld hl,screen_tmp
 61   B84F 36 00            ld (hl),0
 62   B851 21 C0 A3         ld hl,buffer_tmp
 63   B854 36 00            ld (hl),0
 64   B856 23               inc hl
 65   B857 36 00            ld (hl),0
 66   B859
 67   B859 CD E2 B3         call player_init_lifestart
 68   B85C
 69   B85C CD 6F A8         call lifescreen_draw        ; show the lives remaining screen
 70   B85F
 71   B85F CD 00 80         call init_start
 72   B862 CD 3F A5         call screen_draw
 73   B865
 74   B865 CD 9E A4         call buffer_allbuffertoscreen
 75   B868
 76   B868 CD 95 B4         call ship_land              ; land the ship
 77   B86B CD 85 B5         call tank_init
 78   B86E CD 17 B8         call diamonds_init
 79   B871
 80   B871              mloop:
 81   B871 76               halt
 82   B872 CD 81 B8         call main_loop_processing
 83   B875
 84   B875 21 D1 B3         ld hl,player+10
 85   B878 7E               ld a,(hl)                   ; check if the player died this frame
 86   B879 FE 01            cp 1
 87   B87B CA 47 B8         jp z,main_lifestart
 88   B87E
 89   B87E C3 71 B8         jp mloop
 90   B881
 91   B881              main_loop_processing:
 92   B881 CD 6C A4         call buffer_buffertoscreen  ; copy buffer to screen
 93   B884 CD EC A3         call buffer_clearlist       ; zero the updated lines list
 94   B887 CD 0C B4         call player_drawplayer      ; delete player
 95   B88A CD CF AF         call control_keyboard       ; check keyboard
 96   B88D CD 0C B4         call player_drawplayer      ; draw player
 97   B890 CD 8E B5         call tank_process           ; prcoess the tank
 98   B893 CD 6B B6         call rocks_processrocks     ; process falling rocks
 99   B896 CD 0A B8         call diamonds_twinkle       ; make the diamonds twinkle
100   B899
101   B899 CD B4 B3         call game_incrementframe    ; increment the game frame
102   B89C
103   B89C C9               ret
104   B89D
105   B89D              ;===========================================================================
106   B89D              ; Stack.
107   B89D              ;===========================================================================
108   B89D
109   B89D              ; Stack: this area is reserved for the stack
110   B89D              STACK_SIZE: equ 100    ; in words
111   B89D
112   B89D              ; Reserve stack space
113   B89D 00 00            defw 0  ; WPMEM, 2
114   B89F              stack_bottom:
115   B89F 00 00 00...      defs    STACK_SIZE*2, 0
116   B967              stack_top:
117   B967 00 00            defw 0  ; WPMEM, 2
118   B969
119   B969                     SAVESNA "ThePit.sna", main
# file closed: main.asm
