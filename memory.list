# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 67 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 15 A7         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 16 A7         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 AD A5         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD 5A B9         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8051 C9               ret                 ; key was pressed.
 53+  8052
 54+  8052              ;
 55+  8052              ; Waits number of frames for keypress. If got, returns 1, if not 0
 56+  8052              ; Inputs:
 57+  8052              ; a - number of frames to waits
 58+  8052              ; Ouputs:
 59+  8052              ; e - 0 not pressed, 1 pressed
 60+  8052              utilities_waitforkey_forframes:
 61+  8052 21 08 5C         ld hl,23560         ; LAST K system variable.
 62+  8055 36 00            ld (hl),0           ; put null value there.
 63+  8057 47               ld b,a              ; number of frames to wait
 64+  8058              utilities_waitforkey_forframes0:
 65+  8058 7E               ld a,(hl)           ; new value of LAST K.
 66+  8059 FE 00            cp 0                ; is it still zero?
 67+  805B 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 68+  805D 1E 01            ld e,1              ; set the pressed flag
 69+  805F C9               ret                 ; key was pressed.
 70+  8060              utilities_waitforkey_forframes1:
 71+  8060 76               halt                ; wait for frame
 72+  8061 76               halt                ; wait for frame
 73+  8062 10 F4            djnz utilities_waitforkey_forframes0 ; loop again
 74+  8064 1E 00            ld e,0              ; nothing pressed in time
 75+  8066 C9               ret
 76+  8067
 77+  8067              ;
 78+  8067              ; Clears the screen
 79+  8067              ; Inputs:
 80+  8067              ; a - attribute colour
 81+  8067              utilities_clearscreen:
 82+  8067 76               halt
 83+  8068 21 00 58         ld hl,22528         ; attr
 84+  806B 11 01 58         ld de,22529         ; attr+1
 85+  806E 01 FF 02         ld bc,767
 86+  8071 77               ld (hl),a
 87+  8072 ED B0            ldir
 88+  8074
 89+  8074 21 00 40         ld hl, 16384        ;pixels
 90+  8077 11 01 40         ld de, 16385        ;pixels + 1
 91+  807A 01 FF 17         ld bc, 6143         ;pixels area length - 1
 92+  807D 36 00            ld (hl), 0          ;set first byte to '0'
 93+  807F ED B0            ldir                ;copy bytes
 94+  8081
 95+  8081 C9               ret
 96+  8082
 97+  8082              ;
 98+  8082              ; Wait for a number of frames
 99+  8082              ; Inputs:
100+  8082              ; b - number of frames
101+  8082              utilities_pauseforframes:
102+  8082 76               halt
103+  8083 10 FD            djnz utilities_pauseforframes
104+  8085 C9               ret
105+  8086
106+  8086              utilities_readkey:
107+  8086 21 A6 80         LD HL,utilties_keymap              ; Point HL at the keyboard list
108+  8089 16 08            LD D,8                                  ; This is the number of ports (rows) to check
109+  808B 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
110+  808D              utilities_readkey_0:
111+  808D 46               LD B,(HL)                               ; Get the keyboard port address from table
112+  808E 23               INC HL                                  ; Increment to list of keys
113+  808F ED 78            IN A,(C)                                ; Read the row of keys in
114+  8091 E6 1F            AND $1F                                     ; We are only interested in the first five bits
115+  8093 1E 05            LD E,5                                  ; This is the number of keys in the row
116+  8095              utilities_readkey_1:
117+  8095 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
118+  8097 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
119+  8099 23               INC HL                                  ; Go to next table address
120+  809A 1D               DEC E                                   ; Decrement key loop counter
121+  809B 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
122+  809D 15               DEC D                                   ; Decrement row loop counter
123+  809E 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
124+  80A0 A7               AND A                                   ; Clear A (no key found)
125+  80A1 C3 86 80         jp utilities_readkey
126+  80A4              utilities_readkey_2:
127+  80A4 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
128+  80A5 C9               RET
129+  80A6
130+  80A6              utilties_keymap:
131+  80A6 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
131+  80AA 43 56
132+  80AC FD 41 53 44      defb $FD,"A","S","D","F","G"
132+  80B0 46 47
133+  80B2 FB 51 57 45      defb $FB,"Q","W","E","R","T"
133+  80B6 52 54
134+  80B8 F7 31 32 33      defb $F7,"1","2","3","4","5"
134+  80BC 34 35
135+  80BE EF 30 39 38      defb $EF,"0","9","8","7","6"
135+  80C2 37 36
136+  80C4 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
136+  80C8 55 59
137+  80CA BF 23 4C 4B      defb $BF,"#","L","K","J","H"
137+  80CE 4A 48
138+  80D0 7F 20 23 4D      defb $7F," ","#","M","N","B"
138+  80D4 4E 42
139+  80D6
140+  80D6
141+  80D6              ;
142+  80D6              ; Generates a randomish number in the range 0 to e
143+  80D6              ; Inputs:
144+  80D6              ; e - upper value
145+  80D6              ; Outputs:
146+  80D6              ; a - random number
147+  80D6              utilities_randomupper
148+  80D6 3A 30 B9         ld a,(game_framenumber)
149+  80D9 6F               ld l,a
150+  80DA 26 00            ld h,0
151+  80DC 16 00            ld d,0
152+  80DE 42 4B            ld bc,de
153+  80E0              utilities_randomupper0:
154+  80E0 B7               or a
155+  80E1 ED 42            sbc hl,bc
156+  80E3 F2 E0 80         jp p,utilities_randomupper0
157+  80E6 09               add hl,bc
158+  80E7 01 00 00         ld bc,0
159+  80EA 09               add hl,bc
160+  80EB 7D               ld a,l
161+  80EC C9               ret
# file closed: utilities.asm
 22   80ED                  include "strings.asm"
# file opened: strings.asm
  1+  80ED              string_score1:
  2+  80ED 04 00 53 43      defb 4,0,'SCORE1',255
  2+  80F1 4F 52 45 31
  2+  80F5 FF
  3+  80F6              string_scorenumbers1:
  4+  80F6 04 01 30 30      defb 4,1,'000000',255
  4+  80FA 30 30 30 30
  4+  80FE FF
  5+  80FF              string_company:
  6+  80FF 0E 00 45 4E      defb 14,0,'ENV',255
  6+  8103 56 FF
  7+  8105              string_credits:
  8+  8105 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  8109 41 59 45 52
  8+  810D 20 31 FF
  9+  8110              string_score2:
 10+  8110 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8114 4F 52 45 32
 10+  8118 FF
 11+  8119              string_scorenumbers2:
 12+  8119 16 01 30 30      defb 22,1,'000000',255
 12+  811D 30 30 30 30
 12+  8121 FF
 13+  8122              string_titlescreen_copyright:
 14+  8122 04 16 7F 20      defb 4,22, 127,' 1982 AW ZILEC ELC LTD',255
 14+  8126 31 39 38 32
 14+  812A 20 41 57 20
 14+  812E 5A 49 4C 45
 14+  8132 43 20 45 4C
 14+  8136 43 20 4C 54
 14+  813A 44 FF
 15+  813C
 16+  813C
 17+  813C              string_alttitlescreen_1:
 18+  813C 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  8140 45 44 49 54
 18+  8144 53 20 31 FF
 19+  8148              string_alttitlescreen_2:
 20+  8148 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  814C 20 20 20 20
 20+  8150 20 20 20 20
 20+  8154 20 54 48 45
 20+  8158 20 4F 42 4A
 20+  815C 45 43 54 FE
 21+  8160 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  8164 20 20 20 20
 21+  8168 20 20 20 20
 21+  816C 4F 46 20 54
 21+  8170 48 49 53 20
 21+  8174 47 41 4D 45
 21+  8178 FE
 22+  8179 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  817D 20 20 20 20
 22+  8181 20 20 20 49
 22+  8185 53 20 54 4F
 22+  8189 20 44 49 47
 22+  818D 20 44 4F 57
 22+  8191 4E FE
 23+  8193 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  8197 20 20 20 20
 23+  819B 20 20 54 4F
 23+  819F 20 54 48 45
 23+  81A3 20 42 4F 54
 23+  81A7 54 4F 4D 20
 23+  81AB 50 49 54 FE
 24+  81AF 00 06 20 20      defb 0,6,'               AND',254
 24+  81B3 20 20 20 20
 24+  81B7 20 20 20 20
 24+  81BB 20 20 20 20
 24+  81BF 20 41 4E 44
 24+  81C3 FE
 25+  81C4 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  81C8 20 20 20 20
 25+  81CC 20 20 43 4F
 25+  81D0 4C 4C 45 43
 25+  81D4 54 20 41 54
 25+  81D8 20 4C 45 41
 25+  81DC 53 54 FE
 26+  81DF 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  81E3 20 20 20 20
 26+  81E7 20 20 20 4F
 26+  81EB 4E 45 20 4C
 26+  81EF 41 52 47 45
 26+  81F3 20 4A 45 57
 26+  81F7 45 4C FE
 27+  81FA 00 09 20 20      defb 0,9,'              THEN',254
 27+  81FE 20 20 20 20
 27+  8202 20 20 20 20
 27+  8206 20 20 20 20
 27+  820A 54 48 45 4E
 27+  820E FE
 28+  820F 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  8213 20 20 20 20
 28+  8217 20 20 20 52
 28+  821B 45 54 55 52
 28+  821F 4E 20 54 4F
 28+  8223 20 53 48 49
 28+  8227 50 FE
 29+  8229 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  822D 20 20 20 20
 29+  8231 20 20 20 54
 29+  8235 48 52 55 20
 29+  8239 55 50 50 45
 29+  823D 52 20 50 49
 29+  8241 54 FF
 30+  8243              string_alttitlescreen_3:
 31+  8243 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  8247 20 20 53 49
 31+  824B 4E 47 4C 45
 31+  824F 20 42 4F 4E
 31+  8253 55 53 20 20
 31+  8257 35 30 30 30
 31+  825B 20 50 4F 49
 31+  825F 4E 54 53 FE
 32+  8263 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  8267 20 20 20 20
 32+  826B 43 4F 4C 4C
 32+  826F 45 43 54 20
 32+  8273 31 20 4C 41
 32+  8277 52 47 45 20
 32+  827B 4A 45 57 45
 32+  827F 4C FE
 33+  8281 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  8285 20 20 20 20
 33+  8289 20 41 4E 44
 33+  828D 20 52 45 54
 33+  8291 55 52 4E 20
 33+  8295 54 4F 20 53
 33+  8299 48 49 50 FE
 34+  829D 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  82A1 20 20 44 4F
 34+  82A5 55 42 4C 45
 34+  82A9 20 42 4F 4E
 34+  82AD 55 53 20 20
 34+  82B1 31 30 30 30
 34+  82B5 30 20 50 4F
 34+  82B9 49 4E 54 53
 34+  82BD FE
 35+  82BE 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  82C2 20 20 43 4F
 35+  82C6 4C 4C 45 43
 35+  82CA 54 20 41 4C
 35+  82CE 4C 20 33 20
 35+  82D2 4C 41 52 47
 35+  82D6 45 20 4A 45
 35+  82DA 57 45 4C 53
 35+  82DE FE
 36+  82DF 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  82E3 20 20 20 20
 36+  82E7 20 4F 52 20
 36+  82EB 20 20 41 4C
 36+  82EF 4C 20 34 20
 36+  82F3 53 4D 41 4C
 36+  82F7 4C 20 4A 45
 36+  82FB 57 45 4C 53
 36+  82FF FE
 37+  8300 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  8304 20 20 54 52
 37+  8308 49 50 4C 45
 37+  830C 20 42 4F 4E
 37+  8310 55 53 20 20
 37+  8314 31 35 30 30
 37+  8318 30 20 50 4F
 37+  831C 49 4E 54 53
 37+  8320 FE
 38+  8321 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  8325 20 20 20 20
 38+  8329 20 43 4F 4C
 38+  832D 4C 45 43 54
 38+  8331 20 41 4C 4C
 38+  8335 20 37 20 4A
 38+  8339 45 57 45 4C
 38+  833D 53 FF
 39+  833F
 40+  833F              string_lifescreen_player:
 41+  833F 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  8343 4C 41 59 45
 41+  8347 52 20 31 20
 41+  834B FF
 42+  834C              string_lifescreen_lives:
 43+  834C 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  8350 4D 45 4E 20
 43+  8354 4C 45 46 54
 43+  8358 FF
 44+  8359              string_lifescreen_lastman:
 45+  8359 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  835D 53 54 20 4D
 45+  8361 41 4E FF
 46+  8364
 47+  8364              string_gameoverscreen_gameover:
 48+  8364 0C 06 47 41      defb 12,6,'GAME OVER',255
 48+  8368 4D 45 20 4F
 48+  836C 56 45 52 FF
 49+  8370              string_gameoverscreen_copyright:
 50+  8370 05 12 7F 20      defb 5,18,127,' 1982 AW ZILEC ELC LTD',255
 50+  8374 31 39 38 32
 50+  8378 20 41 57 20
 50+  837C 5A 49 4C 45
 50+  8380 43 20 45 4C
 50+  8384 43 20 4C 54
 50+  8388 44 FF
 51+  838A              string_gameoverscreen_bestscores:
 52+  838A 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  838E 53 54 20 53
 52+  8392 43 4F 52 45
 52+  8396 53 20 54 4F
 52+  839A 44 41 59 FF
 53+  839E              string_gameover_credits:
 54+  839E 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  83A2 45 44 49 54
 54+  83A6 53 20 30 FF
 55+  83AA
 56+  83AA              string_highscore_congratulations:
 57+  83AA 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 57+  83AE 4E 47 52 41
 57+  83B2 54 55 4C 41
 57+  83B6 54 49 4F 4E
 57+  83BA 53 FF
 58+  83BC              string_highscore_player1:
 59+  83BC 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 59+  83C0 41 59 45 52
 59+  83C4 20 31 FF
 60+  83C7              string_highscore_player2:
 61+  83C7 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 61+  83CB 41 59 45 52
 61+  83CF 20 32 FF
 62+  83D2              string_highscore_youhaveearned:
 63+  83D2 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 63+  83D6 55 20 48 41
 63+  83DA 56 45 20 45
 63+  83DE 41 52 4E 45
 63+  83E2 44 FF
 64+  83E4              string_highscore_place1:
 65+  83E4 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 65+  83E8 45 20 47 52
 65+  83EC 45 41 54 45
 65+  83F0 53 54 20 53
 65+  83F4 43 4F 52 45
 65+  83F8 FF
 66+  83F9              string_highscore_place2:
 67+  83F9 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 67+  83FD 45 20 32 4E
 67+  8401 44 20 42 45
 67+  8405 53 54 20 53
 67+  8409 43 4F 52 45
 67+  840D FF
 68+  840E              string_highscore_place3:
 69+  840E 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 69+  8412 45 20 33 52
 69+  8416 44 20 42 45
 69+  841A 53 54 20 53
 69+  841E 43 4F 52 45
 69+  8422 FF
 70+  8423              string_highscore_pleaseenter
 71+  8423 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 71+  8427 43 4F 52 44
 71+  842B 20 59 4F 55
 71+  842F 52 20 49 4E
 71+  8433 49 54 49 41
 71+  8437 4C 53 20 42
 71+  843B 45 4C 4F 57
 71+  843F FF
 72+  8440
 73+  8440              string_endlevel_youhaveearned:
 74+  8440 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 74+  8444 55 20 48 41
 74+  8448 56 45 20 45
 74+  844C 41 52 4E 45
 74+  8450 44 FF
 75+  8452              string_endlevel_bonus1:
 76+  8452 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 76+  8456 4E 47 4C 45
 76+  845A 20 42 4F 4E
 76+  845E 55 53 FF
 77+  8461              string_endlevel_bonus2:
 78+  8461 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 78+  8465 55 42 4C 45
 78+  8469 20 42 4F 4E
 78+  846D 55 53 FF
 79+  8470              string_endlevel_bonus3:
 80+  8470 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 80+  8474 49 50 4C 45
 80+  8478 20 42 4F 4E
 80+  847C 55 53 FF
 81+  847F              string_endlevel_points1:
 82+  847F 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 82+  8483 30 30 20 50
 82+  8487 4F 49 4E 54
 82+  848B 53 FF
 83+  848D              string_endlevel_points2:
 84+  848D 09 0F 31 30      defb 9,15,'10000 POINTS',255
 84+  8491 30 30 30 20
 84+  8495 50 4F 49 4E
 84+  8499 54 53 FF
 85+  849C              string_endlevel_points3:
 86+  849C 09 0F 31 35      defb 9,15,'15000 POINTS',255
 86+  84A0 30 30 30 20
 86+  84A4 50 4F 49 4E
 86+  84A8 54 53 FF
 87+  84AB              string_endlevel_anothergo:
 88+  84AB 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 88+  84AF 56 45 20 41
 88+  84B3 4E 4F 54 48
 88+  84B7 45 52 20 47
 88+  84BB 4F FF
 89+  84BD
 90+  84BD              string_zonk:
 91+  84BD 00 00 5A 4F      defb 0,0,'ZONK!',255
 91+  84C1 4E 4B 21 FF
 92+  84C5              ;
 93+  84C5              ; Prints specified string
 94+  84C5              ; Inputs:
 95+  84C5              ; de: pointer to string
 96+  84C5              ; bc: length of string
 97+  84C5              ;
 98+  84C5              ; Print String Data
 99+  84C5              ; First two bytes of string contain X and Y char position, then the string
100+  84C5              ; Individual strings are terminated with 0xFE
101+  84C5              ; End of data is terminated with 0xFF
102+  84C5              ; HL: Address of string
103+  84C5              ;
104+  84C5 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
105+  84C6 23                                   INC HL                          ; Increase HL to the next memory location
106+  84C7 56                                   LD D,(HL)                       ; Fetch the Y coordinate
107+  84C8 23                                   INC HL                          ; Increase HL to the next memory location
108+  84C9 CD DC 84                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
109+  84CC 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
110+  84CD 23                                   INC HL                          ; Increase HL to the next character
111+  84CE FE FE                                CP 0xFE                         ; Compare with 0xFE
112+  84D0 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
113+  84D2 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
114+  84D3 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
115+  84D4 CD EC 84                             CALL Print_Char                 ; Print the character
116+  84D7 E1                                   POP HL                          ; Retrieve HL back off the stack
117+  84D8 1C                                   INC E                           ; Go to the next screen address
118+  84D9 18 F1                                JR string_print_0               ; Loop back to print next character
119+  84DB C9                                   RET
120+  84DC
121+  84DC              ; Get screen address
122+  84DC              ; D = Y character position
123+  84DC              ; E = X character position
124+  84DC              ; Returns address in DE
125+  84DC              ;
126+  84DC 7A           string_getcharaddress:       LD A,D
127+  84DD E6 07                                AND %00000111
128+  84DF 1F                                   RRA
129+  84E0 1F                                   RRA
130+  84E1 1F                                   RRA
131+  84E2 1F                                   RRA
132+  84E3 B3                                   OR E
133+  84E4 5F                                   LD E,A
134+  84E5 7A                                   LD A,D
135+  84E6 E6 18                                AND %00011000
136+  84E8 F6 40                                OR %01000000
137+  84EA 57                                   LD D,A
138+  84EB C9                                   RET                             ; Returns screen address in DE
139+  84EC
140+  84EC              ; Print a single character out
141+  84EC              ; A:  Character to print
142+  84EC              ; DE: Screen address to print character at
143+  84EC              ;
144+  84EC 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
145+  84EF 06 00                                LD B,0                          ; Set BC to A
146+  84F1 4F                                   LD C,A
147+  84F2 E6 FF                                AND 0xFF                        ; Clear the carry bit
148+  84F4 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
149+  84F6 CB 10                                RL B
150+  84F8 CB 11                                RL C
151+  84FA CB 10                                RL B
152+  84FC CB 11                                RL C
153+  84FE CB 10                                RL B
154+  8500 09                                   ADD HL,BC                       ; Get the character address in HL
155+  8501 0E 08                                LD C,8                          ; Loop counter
156+  8503 D5                                   PUSH DE
157+  8504 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
158+  8505 12                                   LD (DE),A                       ; Stick A onto the screen
159+  8506 14                                   INC D                           ; Goto next line on screen
160+  8507 2C                                   INC L                           ; Goto next byte of character
161+  8508 0D                                   DEC C                           ; Decrease the loop counter
162+  8509 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
163+  850B D1                                   POP DE
164+  850C C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   850D                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  850D              buffer_buffer:
  2+  850D 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A20D
  4+  A20D              buffer_attr_buffer:
  5+  A20D 00 00 00...      defs 928                    ; attrs buffer area
  6+  A5AD
  7+  A5AD              buffer_tmp:
  8+  A5AD 00 00            defb 0,0                    ; temp area
  9+  A5AF
 10+  A5AF              buffer_updatedlines:
 11+  A5AF FF FF FF...      defs 21,255
 12+  A5C4
 13+  A5C4              buffer_updateall:
 14+  A5C4 00               defb 0
 15+  A5C5
 16+  A5C5              ;
 17+  A5C5              ; Stores a line number in the update list
 18+  A5C5              ; Inputs:
 19+  A5C5              ; a - row number
 20+  A5C5              buffer_marklineforupdate:
 21+  A5C5 FE 15            cp 21
 22+  A5C7 D0               ret nc                          ; dont store lines that we shouldn't draw
 23+  A5C8 5F               ld e,a                          ; store in e
 24+  A5C9 06 15            ld b,21
 25+  A5CB 21 AF A5         ld hl,buffer_updatedlines
 26+  A5CE              buffer_marklineforupdate0:
 27+  A5CE 7E               ld a,(hl)                       ; get the line stored in updated lines
 28+  A5CF BB               cp e                            ; is this the same as the row number passed in?
 29+  A5D0 C8               ret z                           ; if so, don't need to do anything
 30+  A5D1 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 31+  A5D3 C2 D8 A5         jp nz,buffer_marklineforupdate1 ; if not, move to next
 32+  A5D6 73               ld (hl),e                       ; if it is, this spot is empty, so store the row number
 33+  A5D7 C9               ret                             ; and finish
 34+  A5D8              buffer_marklineforupdate1:
 35+  A5D8 23               inc hl
 36+  A5D9 10 F3            djnz buffer_marklineforupdate0
 37+  A5DB C9               ret
 38+  A5DC
 39+  A5DC              ;
 40+  A5DC              ; Zeroes the updated lines list
 41+  A5DC              ;
 42+  A5DC              buffer_clearlist:
 43+  A5DC 06 15            ld b,21
 44+  A5DE 21 AF A5         ld hl,buffer_updatedlines
 45+  A5E1              buffer_clearlist0:
 46+  A5E1 36 FF            ld (hl),255
 47+  A5E3 23               inc hl
 48+  A5E4 10 FB            djnz buffer_clearlist0
 49+  A5E6 C9               ret
 50+  A5E7
 51+  A5E7              ;
 52+  A5E7              ; Copies the buffer to the screen. Use stack.
 53+  A5E7              ; Inputs:
 54+  A5E7              ; a - row number to display - 0 is first line
 55+  A5E7              ;
 56+  A5E7              buffer_bufferlinetoscreen:
 57+  A5E7 4F               ld c,a                          ; store a
 58+  A5E8 ED 5B 15 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 59+  A5EC 83               add a,e                       ; add the row number
 60+  A5ED 11 00 01         ld de,256
 61+  A5F0 CD 3A 80         call utilities_multiply
 62+  A5F3 54 5D            ld de,hl
 63+  A5F5 21 0D 85         ld hl,buffer_buffer
 64+  A5F8 19               add hl,de                   ; add the offset
 65+  A5F9 79               ld a,c                      ; get original row back
 66+  A5FA ED 73 58 A6      ld (buffer_bufferlinetoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
 67+  A5FE D9               exx
 68+  A5FF 0E 00            ld c,0                      ; zero horizontal
 69+  A601 47               ld b,a                      ; load the row number into vertical coord
 70+  A602 04               inc b
 71+  A603 04               inc b                       ; move forward 2 to allow for scores
 72+  A604 CD FF A7         call screen_getcelladdress  ; get the memory into de
 73+  A607 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
 74+  A60A 19               add hl,de
 75+  A60B              buffer_bufferlinetoscreen0:
 76+  A60B D9               exx                         ; hl is now buffer
 77+  A60C 23               inc hl
 78+  A60D 23               inc hl                      ; move hl forward 2 to skip first two blocks
 79+  A60E F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
 80+  A60F F1               pop af
 81+  A610 C1               pop bc
 82+  A611 D1               pop de
 83+  A612 DD E1            pop ix
 84+  A614 D9               exx                         ; hl is now screen
 85+  A615 08               ex af,af'
 86+  A616 F1               pop af
 87+  A617 C1               pop bc
 88+  A618 D1               pop de
 89+  A619 F9               ld sp,hl                    ; sp pointing at screen
 90+  A61A D5               push de
 91+  A61B C5               push bc
 92+  A61C F5               push af
 93+  A61D 08               ex af,af'
 94+  A61E D9               exx                         ; hl is now buffer
 95+  A61F DD E5            push ix
 96+  A621 D5               push de
 97+  A622 C5               push bc
 98+  A623 F5               push af
 99+  A624 1E 0E            ld e,14                    ; do another fourteen for right hand side
100+  A626 16 00            ld d,0
101+  A628 19               add hl,de
102+  A629 F9               ld sp,hl                    ; sp pointing at buffer
103+  A62A F1               pop af
104+  A62B C1               pop bc
105+  A62C D1               pop de
106+  A62D DD E1            pop ix
107+  A62F                  ;pop ix
108+  A62F D9               exx                         ; hl is now screen
109+  A630 08               ex af,af'
110+  A631 1E 0E            ld e,14
111+  A633 16 00            ld d,0
112+  A635 19               add hl,de
113+  A636 F1               pop af
114+  A637 C1               pop bc
115+  A638 D1               pop de
116+  A639                  ;pop iy
117+  A639 F9               ld sp,hl                    ; sp pointing at screen
118+  A63A                  ;push iy
119+  A63A D5               push de
120+  A63B C5               push bc
121+  A63C F5               push af
122+  A63D 08               ex af,af'
123+  A63E D9               exx                         ; hl is now buffer
124+  A63F DD E5            push ix
125+  A641 D5               push de
126+  A642 C5               push bc
127+  A643 F5               push af
128+  A644 1E 10            ld e,16
129+  A646 16 00            ld d,0
130+  A648 19               add hl,de
131+  A649 D9               exx                         ; hl is now screen
132+  A64A 1E 0E            ld e,14
133+  A64C 16 00            ld d,0
134+  A64E ED 52            sbc hl,de
135+  A650 24               inc h
136+  A651 7C               ld a,h
137+  A652 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
138+  A654 C2 0B A6         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
139+  A657              buffer_bufferlinetoscreen1:
140+  A657 31 00 00         ld sp,0
141+  A65A D9               exx
142+  A65B C9               ret
143+  A65C
144+  A65C              ;
145+  A65C              ; Copies the buffer to the screen for updated lines. Use stack.
146+  A65C              ; Inputs: none
147+  A65C              ;
148+  A65C              buffer_buffertoscreen:
149+  A65C 3A C4 A5         ld a,(buffer_updateall)      ; get the all update flag
150+  A65F FE 00            cp 0
151+  A661 CA 6D A6         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
152+  A664 CD 8E A6         call buffer_allbuffertoscreen ; otherwise, draw whole screen
153+  A667 21 C4 A5         ld hl,buffer_updateall
154+  A66A 36 00            ld (hl),0                    ; reset flag
155+  A66C C9               ret
156+  A66D              buffer_buffertoscreen2:
157+  A66D 06 15            ld b,21
158+  A66F FD 21 AF A5      ld iy,buffer_updatedlines    ; the location of the updated lines
159+  A673              buffer_buffertoscreen0:
160+  A673 FD 7E 00         ld a,(iy)
161+  A676 FE FF            cp 255
162+  A678 CA 8A A6         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
163+  A67B C5               push bc
164+  A67C FD E5            push iy
165+  A67E F3               di
166+  A67F CD E7 A5         call buffer_bufferlinetoscreen
167+  A682 FB               ei
168+  A683 FD E1            pop iy
169+  A685 C1               pop bc
170+  A686 FD 23            inc iy
171+  A688 10 E9            djnz buffer_buffertoscreen0
172+  A68A              buffer_buffertoscreen1:
173+  A68A CD A2 A6         call buffer_buffertoattrsfast
174+  A68D C9               ret
175+  A68E
176+  A68E              ;
177+  A68E              ; Copies the buffer to the screen. Use stack.
178+  A68E              ; Inputs: none
179+  A68E              ;
180+  A68E              buffer_allbuffertoscreen:
181+  A68E 06 15            ld b,21
182+  A690 3E 00            ld a,0
183+  A692              buffer_allbuffertoscreen0:
184+  A692 C5               push bc
185+  A693 F5               push af
186+  A694 F3               di
187+  A695 CD E7 A5         call buffer_bufferlinetoscreen
188+  A698 FB               ei
189+  A699 F1               pop af
190+  A69A C1               pop bc
191+  A69B 3C               inc a
192+  A69C 10 F4            djnz buffer_allbuffertoscreen0
193+  A69E
194+  A69E CD A2 A6         call buffer_buffertoattrsfast
195+  A6A1 C9               ret
196+  A6A2
197+  A6A2              ;
198+  A6A2              ; Copies the attrs buffer to screen with the stack
199+  A6A2              ;
200+  A6A2              buffer_buffertoattrsfast:
201+  A6A2 ED 73 11 A7      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
202+  A6A6 3A 15 A7         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
203+  A6A9 11 20 00         ld de,32
204+  A6AC CD 3A 80         call utilities_multiply
205+  A6AF 54 5D            ld de,hl
206+  A6B1 21 0D A2         ld hl,buffer_attr_buffer
207+  A6B4 19               add hl,de                       ; add the offset, start of attr buffer now in hl
208+  A6B5 D9               exx
209+  A6B6 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
210+  A6B9 FD 21 AD A5      ld iy,buffer_tmp
211+  A6BD FD 36 00 15      ld (iy),21              ; number of times to loop
212+  A6C1              buffer_buffertoattrsfast0:
213+  A6C1 D9               exx                         ; hl is now buffer
214+  A6C2 23               inc hl
215+  A6C3 23               inc hl                      ; move hl forward 2 to skip first two blocks
216+  A6C4 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
217+  A6C5 F1               pop af
218+  A6C6 C1               pop bc
219+  A6C7 D1               pop de
220+  A6C8 DD E1            pop ix
221+  A6CA D9               exx                         ; hl is now screen
222+  A6CB 08               ex af,af'
223+  A6CC F1               pop af
224+  A6CD C1               pop bc
225+  A6CE D1               pop de
226+  A6CF F9               ld sp,hl                    ; sp pointing at screen
227+  A6D0 D5               push de
228+  A6D1 C5               push bc
229+  A6D2 F5               push af
230+  A6D3 08               ex af,af'
231+  A6D4 D9               exx                         ; hl is now buffer
232+  A6D5 DD E5            push ix
233+  A6D7 D5               push de
234+  A6D8 C5               push bc
235+  A6D9 F5               push af
236+  A6DA 1E 0E            ld e,14                    ; do another fourteen for right hand side
237+  A6DC 16 00            ld d,0
238+  A6DE 19               add hl,de
239+  A6DF F9               ld sp,hl                    ; sp pointing at buffer
240+  A6E0 F1               pop af
241+  A6E1 C1               pop bc
242+  A6E2 D1               pop de
243+  A6E3 DD E1            pop ix
244+  A6E5 D9               exx                         ; hl is now screen
245+  A6E6 08               ex af,af'
246+  A6E7 1E 0E            ld e,14
247+  A6E9 16 00            ld d,0
248+  A6EB 19               add hl,de
249+  A6EC F1               pop af
250+  A6ED C1               pop bc
251+  A6EE D1               pop de
252+  A6EF F9               ld sp,hl                    ; sp pointing at screen
253+  A6F0 D5               push de
254+  A6F1 C5               push bc
255+  A6F2 F5               push af
256+  A6F3 08               ex af,af'
257+  A6F4 D9               exx                         ; hl is now buffer
258+  A6F5 DD E5            push ix
259+  A6F7 D5               push de
260+  A6F8 C5               push bc
261+  A6F9 F5               push af
262+  A6FA 1E 10            ld e,16
263+  A6FC 16 00            ld d,0
264+  A6FE 19               add hl,de
265+  A6FF D9               exx                         ; hl is now screen
266+  A700 11 12 00         ld de,18
267+  A703 19               add hl,de
268+  A704 FD 7E 00         ld a,(iy)
269+  A707 3D               dec a
270+  A708 FE 00            cp 0
271+  A70A FD 77 00         ld (iy),a
272+  A70D C2 C1 A6         jp nz,buffer_buffertoattrsfast0 ; do another row
273+  A710              buffer_buffertoattrsfast1:
274+  A710 31 00 00         ld sp,0
275+  A713 D9               exx
276+  A714 C9               ret
# file closed: screen/buffer.asm
 24   A715                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A715              screen_offset:
  2+  A715 00               defb 0                      ; offset from top of screen in lines
  3+  A716
  4+  A716              screen_tmp:
  5+  A716 00 00            defb 0,0                      ; temporary memory
  6+  A718
  7+  A718              screen_setscorecolours:
  8+  A718 21 8B B2         ld hl,score_colours
  9+  A71B 11 00 58         ld de,22528                     ; attrs here
 10+  A71E 01 40 00         ld bc,64
 11+  A721 ED B0            ldir
 12+  A723 C9               ret
 13+  A724
 14+  A724              screen_sethighscorecolours:
 15+  A724 21 CB B2         ld hl,high_score_colours
 16+  A727 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A72A 01 20 00         ld bc,32
 18+  A72D ED B0            ldir
 19+  A72F C9               ret
 20+  A730
 21+  A730              ; Draw the screen
 22+  A730              ; Inputs:
 23+  A730              ; none
 24+  A730              ; Notes:
 25+  A730              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A730              screen_draw:
 27+  A730                  ;call clear_screen
 28+  A730 0E 00            ld c,0                      ; horiz
 29+  A732 06 00            ld b,0                      ; vert, 0 at top
 30+  A734 DD 21 4D AD      ld ix,level01               ; point ix at level data
 31+  A738 FD 21 0D A2      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A73C              screen_draw0:
 33+  A73C DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A73F C5               push bc                     ; store bc, contains loop count
 35+  A740 CD A2 A8         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A743 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A744 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A747 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A74A CD 97 A8         call screen_getblock        ; get the block data into hl
 40+  A74D CD 7D A8         call screen_showchar        ; show this character here
 41+  A750 C1               pop bc                      ; get the loop counter back
 42+  A751 DD 23            inc ix                      ; increment level location
 43+  A753 FD 23            inc iy                      ; increment attr location
 44+  A755 0C               inc c                       ; increment horiz
 45+  A756 79               ld a,c
 46+  A757 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A759 C2 3C A7         jp nz,screen_draw0          ; if not, loop
 48+  A75C 0E 00            ld c,0                      ; if so, reset horiz
 49+  A75E 04               inc b                       ; increment vertical
 50+  A75F 78               ld a,b
 51+  A760 FE 1D            cp 29                       ; check if at bottom
 52+  A762 C2 3C A7         jp nz,screen_draw0          ; if not, loop
 53+  A765 21 16 A7         ld hl, screen_tmp
 54+  A768 36 09            ld (hl),9                   ; load the block number into memory
 55+  A76A DD 21 ED B0      ld ix,level01rocks          ; rock memory
 56+  A76E CD CF A7         call screen_initobjects     ; draw rocks
 57+  A771 21 16 A7         ld hl, screen_tmp
 58+  A774 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A776 DD 21 ED B1      ld ix,level01missiles       ; missile memory
 60+  A77A CD CF A7         call screen_initobjects     ; draw missiles
 61+  A77D 21 16 A7         ld hl, screen_tmp
 62+  A780 36 08            ld (hl),08                  ; load the block number into memory
 63+  A782 DD 21 66 B2      ld ix,level01diamonds       ; diamond memory
 64+  A786 CD CF A7         call screen_initobjects     ; draw diamonds
 65+  A789 21 16 A7         ld hl, screen_tmp
 66+  A78C 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A78E DD 21 76 B2      ld ix,level01gems           ; gems memory
 68+  A792 CD CF A7         call screen_initobjects     ; draw gems
 69+  A795 CD 9C A7         call screen_setuptext       ; draws text on the screen
 70+  A798 CD 44 C0         call scores_printscores     ; print the current scores
 71+  A79B C9               ret
 72+  A79C
 73+  A79C              ;
 74+  A79C              ; Sets up text on the screen
 75+  A79C              ;
 76+  A79C              screen_setuptext:
 77+  A79C CD 66 C0         call scores_showtable
 78+  A79F CD 24 A7         call screen_sethighscorecolours
 79+  A7A2 21 ED 80         ld hl, string_score1
 80+  A7A5 CD C5 84         call string_print
 81+  A7A8 21 F6 80         ld hl, string_scorenumbers1
 82+  A7AB CD C5 84         call string_print
 83+  A7AE 21 FF 80         ld hl, string_company
 84+  A7B1 CD C5 84         call string_print
 85+  A7B4 21 10 81         ld hl, string_score2
 86+  A7B7 CD C5 84         call string_print
 87+  A7BA 21 19 81         ld hl, string_scorenumbers2
 88+  A7BD CD C5 84         call string_print
 89+  A7C0 21 05 81         ld hl, string_credits
 90+  A7C3 CD C5 84         call string_print
 91+  A7C6 CD 18 A7         call screen_setscorecolours
 92+  A7C9 C9               ret
 93+  A7CA
 94+  A7CA              ;
 95+  A7CA              ; Sets a line of colours
 96+  A7CA              ; Inputs:
 97+  A7CA              ; a - colour to set
 98+  A7CA              ; b - number to set
 99+  A7CA              ; de - start memory location
100+  A7CA              ;
101+  A7CA              screen_setcolours:
102+  A7CA 12               ld (de),a
103+  A7CB 13               inc de
104+  A7CC 10 FC            djnz screen_setcolours
105+  A7CE C9               ret
106+  A7CF
107+  A7CF              ;
108+  A7CF              ; Draw initial object positions
109+  A7CF              ; Inputs:
110+  A7CF              ; ix - memory location of objects
111+  A7CF              ; a - graphic
112+  A7CF              screen_initobjects:
113+  A7CF DD 4E 00         ld c,(ix)                   ; get the horiz coord
114+  A7D2 79               ld a,c
115+  A7D3 FE FF            cp 255
116+  A7D5 CA FE A7         jp z,screen_initobjects2
117+  A7D8 DD 23            inc ix                      ; move to next
118+  A7DA DD 46 00         ld b,(ix)                   ; get the vert coord
119+  A7DD DD 23            inc ix
120+  A7DF CD 10 A8         call screen_getcellattradress ; get the memory address of b,c attr into de
121+  A7E2 D5               push de
122+  A7E3 3A 16 A7         ld a,(screen_tmp)                  ; get the block number back
123+  A7E6 CD A2 A8         call screen_getattr         ; get the memory location for this cell's attr into hl
124+  A7E9 D1               pop de
125+  A7EA 7E               ld a,(hl)                   ; get the attr value at the address
126+  A7EB 12               ld (de),a                   ; load the attr into memory
127+  A7EC 3A 16 A7         ld a,(screen_tmp)                  ; get the block number back
128+  A7EF CD 97 A8         call screen_getblock        ; get the block data into hl
129+  A7F2 CD 7D A8         call screen_showchar        ; show this character here
130+  A7F5
131+  A7F5              screen_initobjects1:
132+  A7F5 DD 23            inc ix                      ; move past state
133+  A7F7 DD 23            inc ix
134+  A7F9 DD 23            inc ix                      ; move past mem
135+  A7FB C3 CF A7         jp screen_initobjects
136+  A7FE              screen_initobjects2:
137+  A7FE C9               ret
138+  A7FF
139+  A7FF
140+  A7FF              ;
141+  A7FF              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
142+  A7FF              ; Inputs:
143+  A7FF              ; bc: coords
144+  A7FF              ; Outputs:
145+  A7FF              ; de: memory location
146+  A7FF              ;
147+  A7FF              screen_getcelladdress:
148+  A7FF 78               ld a,b      ; vertical position.
149+  A800 E6 18            and 24      ; which segment, 0, 1 or 2?
150+  A802 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
151+  A804 57               ld d,a      ; this is our high byte.
152+  A805 78               ld a,b      ; what was that vertical position again?
153+  A806 E6 07            and 7       ; which row within segment?
154+  A808 0F               rrca        ; multiply row by 32.
155+  A809 0F               rrca
156+  A80A 0F               rrca
157+  A80B 5F               ld e,a      ; low byte.
158+  A80C 79               ld a,c      ; add on y coordinate.
159+  A80D 83               add a,e     ; mix with low byte.
160+  A80E 5F               ld e,a      ; address of screen position in de.
161+  A80F C9               ret
162+  A810
163+  A810              ;
164+  A810              ; Calculate buffer address of attribute for character at (b, c).
165+  A810              ; Inputs:
166+  A810              ; bc: coords
167+  A810              ; Outputs:
168+  A810              ; de: memory location
169+  A810              ;
170+  A810              screen_getcellattradress:
171+  A810 11 0D A2         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
172+  A813 69               ld l,c      ; x position.
173+  A814 26 00            ld h,0      ; 0 h
174+  A816 19               add hl,de
175+  A817 54 5D            ld de,hl    ; horiz done
176+  A819 78               ld a,b      ; do vert
177+  A81A D5               push de
178+  A81B C5               push bc
179+  A81C 11 20 00         ld de,32
180+  A81F CD 3A 80         call utilities_multiply
181+  A822 C1               pop bc
182+  A823 D1               pop de
183+  A824 19               add hl,de
184+  A825 54 5D            ld de,hl    ; vert done
185+  A827 C9               ret
186+  A828
187+  A828              ;
188+  A828              ; Calculate buffer address of attribute for character at (b, c).
189+  A828              ; Inputs:
190+  A828              ; bc: coords
191+  A828              ; Outputs:
192+  A828              ; de: memory location
193+  A828              ;
194+  A828              screen_getscreenattradress:
195+  A828 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
196+  A82B 69               ld l,c      ; x position.
197+  A82C 26 00            ld h,0      ; 0 h
198+  A82E 19               add hl,de
199+  A82F 54 5D            ld de,hl    ; horiz done
200+  A831 78               ld a,b      ; do vert
201+  A832 D5               push de
202+  A833 C5               push bc
203+  A834 11 20 00         ld de,32
204+  A837 CD 3A 80         call utilities_multiply
205+  A83A C1               pop bc
206+  A83B D1               pop de
207+  A83C 19               add hl,de
208+  A83D 54 5D            ld de,hl    ; vert done
209+  A83F C9               ret
210+  A840
211+  A840              ;
212+  A840              ; Gets the attr memory location for a screen coord
213+  A840              ; Will overwrite bc
214+  A840              ; Inputs:
215+  A840              ; bc - screen coords
216+  A840              ; Outputs:
217+  A840              ; de - memory location
218+  A840              ; bc - character coords
219+  A840              ;
220+  A840              screen_getattraddressfromscreencoords:
221+  A840 78               ld a,b                          ; get the player block coords of current block
222+  A841 E6 F8            and 248                         ; find closest multiple of eight
223+  A843 0F               rrca
224+  A844 0F               rrca
225+  A845 0F               rrca                ; divide by 8
226+  A846 47               ld b,a
227+  A847 79               ld a,c
228+  A848 48               ld c,b                         ; swap b and c
229+  A849 E6 F8            and 248
230+  A84B 0F               rrca
231+  A84C 0F               rrca
232+  A84D 0F               rrca                ; divide by 8
233+  A84E 47               ld b,a
234+  A84F CD 10 A8         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
235+  A852 C9               ret
236+  A853
237+  A853
238+  A853              ; Gets the nearest cell coords for a screen coord
239+  A853              ; Will overwrite bc
240+  A853              ; Inputs:
241+  A853              ; bc - screen coords
242+  A853              ; Outputs:
243+  A853              ; bc - character coords
244+  A853              ;
245+  A853              screen_getcharcoordsfromscreencoords:
246+  A853 78               ld a,b                          ; get the player block coords of current block
247+  A854 E6 F8            and 248                         ; find closest multiple of eight
248+  A856 0F               rrca
249+  A857 0F               rrca
250+  A858 0F               rrca                ; divide by 8
251+  A859 47               ld b,a
252+  A85A 79               ld a,c
253+  A85B 48               ld c,b                         ; swap b and c
254+  A85C E6 F8            and 248
255+  A85E 0F               rrca
256+  A85F 0F               rrca
257+  A860 0F               rrca                ; divide by 8
258+  A861 47               ld b,a
259+  A862 C9               ret
260+  A863
261+  A863              ; Gets the screen coords for a cell coord
262+  A863              ; Will overwrite bc
263+  A863              ; Inputs:
264+  A863              ; bc - char coords
265+  A863              ; Outputs:
266+  A863              ; bc - screen coords
267+  A863              ;
268+  A863              screen_getscreencoordsfromcharcoords:
269+  A863 78               ld a,b                          ; get the player block coords of current block
270+  A864 07               rlca
271+  A865 07               rlca
272+  A866 07               rlca                ; multiply by 8
273+  A867 47               ld b,a
274+  A868 79               ld a,c
275+  A869 48               ld c,b                         ; swap b and c
276+  A86A 07               rlca
277+  A86B 07               rlca
278+  A86C 07               rlca                ; divide by 8
279+  A86D 47               ld b,a
280+  A86E C9               ret
281+  A86F
282+  A86F              ;
283+  A86F              ; Get buffer address for a character at b,c - b vert
284+  A86F              ; Buffer memory is stored as sequential block
285+  A86F              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
286+  A86F              ; Inputs:
287+  A86F              ; bc - coords
288+  A86F              ; Outputs:
289+  A86F              ; de - memory location of first byte
290+  A86F              screen_getbufferaddress:
291+  A86F 21 0D 85         ld hl, buffer_buffer    ; first get screen buffer start
292+  A872 50               ld d,b                  ; then work out vertical offset
293+  A873 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
294+  A875 19               add hl,de               ; add to base
295+  A876 59               ld e,c                  ; then add horizontal offset (c)
296+  A877 16 00            ld d,0
297+  A879 19               add hl,de               ; add to base
298+  A87A 54 5D            ld de,hl
299+  A87C C9               ret
300+  A87D
301+  A87D              ;
302+  A87D              ; Display character hl at (b, c) to buffer.
303+  A87D              ; Stored sequentially
304+  A87D              ; Inputs:
305+  A87D              ; hl: block address
306+  A87D              ; bc: coords
307+  A87D              ;
308+  A87D              screen_showchar:
309+  A87D 3E 00            ld a,0
310+  A87F E5               push hl
311+  A880 CD 6F A8         call screen_getbufferaddress ; get the current screen buffer pointer
312+  A883 E1               pop hl
313+  A884 06 08            ld b,8              ; number of pixels high.
314+  A886              screen_showchar0:
315+  A886 7E               ld a,(hl)           ; source graphic.
316+  A887 12               ld (de),a           ; transfer to screen.
317+  A888 23               inc hl              ; next piece of data.
318+  A889 E5               push hl             ; store hl
319+  A88A 62 6B            ld hl,de            ; put de in hl
320+  A88C 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
321+  A88E 16 00            ld d,0
322+  A890 19               add hl,de              ; add de to hl
323+  A891 54 5D            ld de,hl            ; load back to de
324+  A893 E1               pop hl              ; restore hl
325+  A894
326+  A894 10 F0            djnz screen_showchar0 ; repeat
327+  A896 C9               ret
328+  A897
329+  A897
330+  A897              ;
331+  A897              ; Get cell graphic.
332+  A897              ; Inputs:
333+  A897              ; a: block
334+  A897              ; Outputs:
335+  A897              ; hl: memory
336+  A897              ;
337+  A897              screen_getblock:
338+  A897 07               rlca                        ; multiply block number by eight.
339+  A898 07               rlca
340+  A899 07               rlca
341+  A89A 5F               ld e,a                      ; displacement to graphic address.
342+  A89B 16 00            ld d,0                      ; no high byte.
343+  A89D 21 EB B2         ld hl,sprites               ; address of character blocks.
344+  A8A0 19               add hl,de                   ; point to block.
345+  A8A1 C9               ret
346+  A8A2
347+  A8A2              ;
348+  A8A2              ; Get cell attribute.
349+  A8A2              ; Inputs:
350+  A8A2              ; a: block
351+  A8A2              ; Outputs:
352+  A8A2              ; hl: memory
353+  A8A2              ;
354+  A8A2              screen_getattr:
355+  A8A2 5F               ld e,a                      ; displacement to attribute address.
356+  A8A3 16 00            ld d,0                      ; no high byte.
357+  A8A5 21 BB B3         ld hl,sprite_attrs          ; address of block attributes.
358+  A8A8 19               add hl,de                   ; point to attribute.
359+  A8A9 C9               ret
360+  A8AA
361+  A8AA              ;
362+  A8AA              ; Checks whether a character block has anything in it
363+  A8AA              ; Inputs:
364+  A8AA              ; bc - char coords
365+  A8AA              ; Outputs:
366+  A8AA              ; a - 1, empty
367+  A8AA              screen_ischarempty:
368+  A8AA CD 6F A8         call screen_getbufferaddress ; get the current screen buffer pointer
369+  A8AD 06 08            ld b,8                      ; check 8 rows
370+  A8AF              screen_ischarempty2:
371+  A8AF 1A               ld a,(de)                   ; check line
372+  A8B0 FE 00            cp 0
373+  A8B2 C2 C0 A8         jp nz,screen_ischarempty1   ; if not zero, jump out with false
374+  A8B5 21 20 00         ld hl,32
375+  A8B8 19               add hl,de
376+  A8B9 54 5D            ld de,hl                    ; move to next row
377+  A8BB 10 F2            djnz screen_ischarempty2
378+  A8BD              screen_ischarempty0:
379+  A8BD 3E 01            ld a,1
380+  A8BF C9               ret
381+  A8C0              screen_ischarempty1:
382+  A8C0 3E 00            ld a,0
383+  A8C2 C9               ret
384+  A8C3
385+  A8C3              ;
386+  A8C3              ; Copies a block from one place to another directly underneath, leaves the original empty
387+  A8C3              ; Inputs:
388+  A8C3              ; bc - coords of block to copy from
389+  A8C3              screen_copyblockdown
390+  A8C3 CD 6F A8         call screen_getbufferaddress ; get the current screen buffer pointer for source
391+  A8C6 06 08            ld b,8                      ; copy 8 rows
392+  A8C8              screen_copyblock0:
393+  A8C8 1A               ld a,(de)                    ; get what we're copying
394+  A8C9 08               ex af,af'
395+  A8CA 3E 00            ld a,0
396+  A8CC 12               ld (de),a                    ; replace with empty
397+  A8CD 08               ex af,af'
398+  A8CE 14               inc d                        ; add 256 to get to the next row
399+  A8CF 12               ld (de),a                    ; copy to the next row
400+  A8D0 15               dec d
401+  A8D1 21 20 00         ld hl,32
402+  A8D4 19               add hl,de                       ; return back to source, next row down
403+  A8D5 54 5D            ld de,hl
404+  A8D7 10 EF            djnz screen_copyblock0
405+  A8D9 C9               ret
406+  A8DA
407+  A8DA              ;
408+  A8DA              ; Returns the first byte of a character. Useful for figuring out what's there
409+  A8DA              ; Inputs:
410+  A8DA              ; bc - coords
411+  A8DA              ; Outputs:
412+  A8DA              ; a - first byte
413+  A8DA              ;
414+  A8DA              screen_getcharfirstbyte:
415+  A8DA CD 6F A8         call screen_getbufferaddress ; get the current screen buffer pointer for source
416+  A8DD 1A               ld a,(de)
417+  A8DE C9               ret
418+  A8DF
# file closed: screen/screen.asm
 25   A8DF                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A8DF              ;
  2+  A8DF              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A8DF              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A8DF              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A8DF              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A8DF              ; routine takes care of all the shifting itself. This means that sprite
  7+  A8DF              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A8DF              ; space they would require in pre-shifted form.
  9+  A8DF              ; Inputs:
 10+  A8DF              ; hl - sprite data
 11+  A8DF              ; bc - screen coords
 12+  A8DF              ;
 13+  A8DF              sprites_drawsprite7:
 14+  A8DF EE 07            xor 7               ; complement last 3 bits.
 15+  A8E1 3C               inc a               ; add one for luck!
 16+  A8E2              sprites_drawsprite3:
 17+  A8E2 CB 11            rl c                ; ...into middle byte...
 18+  A8E4 CB 12            rl d                ; ...and finally into left character cell.
 19+  A8E6 3D               dec a               ; count shifts we've done.
 20+  A8E7 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A8E9                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A8E9 79               ld a,c              ; left edge of image is currently in e.
 23+  A8EA 4A               ld c,d              ; put right edge there instead.
 24+  A8EB 57               ld d,a              ; and the left edge back into c.
 25+  A8EC 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A8EE              sprites_drawsprite:
 27+  A8EE ED 43 53 A9      ld (dispx),bc       ; store coords in dispx for now.
 28+  A8F2 E5               push hl
 29+  A8F3 CD 31 A9         call sprites_scadd  ; calculate screen address.
 30+  A8F6 E1               pop hl
 31+  A8F7 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A8F9              sprites_drawsprite1:
 33+  A8F9 08               ex af,af'           ; store loop counter.
 34+  A8FA D5               push de             ; store screen address.
 35+  A8FB 4E               ld c,(hl)           ; first sprite graphic.
 36+  A8FC 23               inc hl              ; increment poiinter to sprite data.
 37+  A8FD 22 55 A9         ld (sprtmp),hl      ; store it for later.
 38+  A900 16 00            ld d,0              ; blank right byte for now.
 39+  A902 78               ld a,b              ; b holds y position.
 40+  A903 E6 07            and 7               ; how are we straddling character cells?
 41+  A905 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A907 FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A909 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A90B A7               and a               ; oops, carry flag is set so clear it.
 45+  A90C              sprites_drawsprite2:
 46+  A90C CB 19            rr c                ; rotate left byte right...
 47+  A90E CB 1A            rr d                ; ...into right byte.
 48+  A910 3D               dec a               ; one less shift to do.
 49+  A911 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A913              sprites_drawsprite0:
 51+  A913 E1               pop hl              ; pop screen address from stack.
 52+  A914 7E               ld a,(hl)           ; what's there already.
 53+  A915 A9               xor c               ; merge in image data.
 54+  A916 77               ld (hl),a           ; place onto screen.
 55+  A917 23               inc hl
 56+  A918 7E               ld a,(hl)           ; what's already there.
 57+  A919 AA               xor d               ; right edge of sprite image data.
 58+  A91A 77               ld (hl),a           ; plonk it on screen.
 59+  A91B 3A 53 A9         ld a,(dispx)        ; vertical coordinate.
 60+  A91E 3C               inc a               ; next line down.
 61+  A91F 32 53 A9         ld (dispx),a        ; store new position.
 62+  A922 2B               dec hl
 63+  A923 11 20 00         ld de,32            ; add 32 to get to the next row
 64+  A926 19               add hl,de           ; add 32
 65+  A927              sprites_drawsprite6:
 66+  A927 EB               ex de,hl            ; screen address in de.
 67+  A928 2A 55 A9         ld hl,(sprtmp)      ; restore graphic address.
 68+  A92B 08               ex af,af'           ; restore loop counter.
 69+  A92C 3D               dec a               ; decrement it.
 70+  A92D C2 F9 A8         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 71+  A930 C9               ret                 ; job done.
 72+  A931
 73+  A931              ;
 74+  A931              ; This routine returns a buffer address for (c, b) in de (c vert).
 75+  A931              ; For example: 0,0 will be at memory offset 0
 76+  A931              ; 1,0 (1 down) will be at memory offset 1
 77+  A931              ; 0,7 will be at memory offset 0
 78+  A931              ; 9,1 will be at memory offset 8+1
 79+  A931              ; 8,0 will be at memory offset 256
 80+  A931              ; 9,0 will be at memory offset 257
 81+  A931              ; Outputs:
 82+  A931              ; de - coords
 83+  A931              ;
 84+  A931              sprites_scadd:
 85+  A931 79               ld a,c               ; calculate vertical offset
 86+  A932 E6 F8            and 248             ;  to get nearest multiple of 8
 87+  A934 0F               rrca
 88+  A935 0F               rrca
 89+  A936 0F               rrca                ; divide by 8
 90+  A937 67               ld h,a
 91+  A938 78               ld a,b               ; calculate horizontal offset
 92+  A939 E6 F8            and 248             ;  to get nearest multiple of 8
 93+  A93B 0F               rrca
 94+  A93C 0F               rrca
 95+  A93D 0F               rrca                ; divide by 8
 96+  A93E 6F               ld l,a
 97+  A93F C5               push bc             ; store the screen coords
 98+  A940 44 4D            ld bc,hl            ; load bc with the character coords
 99+  A942 CD 6F A8         call screen_getbufferaddress
100+  A945 C1               pop bc              ; get back screen coords, de is now memory of character
101+  A946 79               ld a,c              ; now add the vertical within the cell
102+  A947 E6 07            and 7
103+  A949 0F               rrca                ; multiply by 32.
104+  A94A 0F               rrca
105+  A94B 0F               rrca
106+  A94C 6F               ld l,a
107+  A94D 26 00            ld h,0
108+  A94F 19               add hl,de
109+  A950 54 5D            ld de,hl
110+  A952 C9               ret
111+  A953
112+  A953 00           dispx   defb 0           ; general-use coordinates.
113+  A954 00           dispy   defb 0
114+  A955 00 00        sprtmp  defb 0,0           ; sprite temporary address.
115+  A957
# file closed: screen/sprites.asm
 26   A957                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  A957              ;
  2+  A957              ; Draws the title screen
  3+  A957              ;
  4+  A957              titlescreen_show:
  5+  A957 CD CF A9         call titlescreen_init
  6+  A95A CD 78 A9         call titlescreen_drawtitle
  7+  A95D 3E FA            ld a,250                              ; wait for 200 frames
  8+  A95F CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
  9+  A962 7B               ld a,e
 10+  A963 FE 01            cp 1                                  ; was anything pressed?
 11+  A965 C8               ret z                                 ; end titlescreen if so
 12+  A966
 13+  A966 CD E2 A9         call titlescreen_alt_init             ; otherwise, draw alt screen
 14+  A969 CD 94 A9         call titlescreen_alt_drawtitle
 15+  A96C 3E FA            ld a,250                              ; wait for 200 frames
 16+  A96E CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 17+  A971 7B               ld a,e
 18+  A972 FE 01            cp 1                                  ; was anything pressed?
 19+  A974 C2 57 A9         jp nz,titlescreen_show                ; start again if not
 20+  A977 C9               ret
 21+  A978
 22+  A978              ;
 23+  A978              ; Draws the iconic logo
 24+  A978              ;
 25+  A978              titlescreen_drawtitle:
 26+  A978 06 66            ld b,102              ; number of points
 27+  A97A DD 21 EF A9      ld ix,titlescreen_logo_data
 28+  A97E              titlescreen_drawtitle0:
 29+  A97E C5               push bc
 30+  A97F DD 4E 00         ld c,(ix)                   ; got horiz
 31+  A982 DD 23            inc ix
 32+  A984 DD 46 00         ld b,(ix)                   ; got vert
 33+  A987 DD 23            inc ix
 34+  A989 CD 28 A8         call screen_getscreenattradress ; memory in de
 35+  A98C 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 36+  A98D 3E 13            ld a,19
 37+  A98F 12               ld (de),a
 38+  A990 C1               pop bc
 39+  A991 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 40+  A993 C9               ret
 41+  A994
 42+  A994              ;
 43+  A994              ; Draws the alternate title screen
 44+  A994              ;
 45+  A994              titlescreen_alt_drawtitle:
 46+  A994 21 3C 81         ld hl,string_alttitlescreen_1
 47+  A997 CD C5 84         call string_print
 48+  A99A 21 48 81         ld hl,string_alttitlescreen_2
 49+  A99D CD C5 84         call string_print
 50+  A9A0 21 43 82         ld hl,string_alttitlescreen_3
 51+  A9A3 CD C5 84         call string_print
 52+  A9A6 06 20            ld b,32
 53+  A9A8 3E 43            ld a,67
 54+  A9AA 11 00 58         ld de,22528                         ; top row attrs here
 55+  A9AD CD CA A7         call screen_setcolours
 56+  A9B0 06 20            ld b,32
 57+  A9B2 3E 46            ld a,70
 58+  A9B4 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 59+  A9B7 CD CA A7         call screen_setcolours
 60+  A9BA 06 20            ld b,32
 61+  A9BC 3E 43            ld a,67
 62+  A9BE 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 63+  A9C1 CD CA A7         call screen_setcolours
 64+  A9C4 06 20            ld b,32
 65+  A9C6 3E 42            ld a,66
 66+  A9C8 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 67+  A9CB CD CA A7         call screen_setcolours
 68+  A9CE C9               ret
 69+  A9CF
 70+  A9CF              ;
 71+  A9CF              ; Initialises the screen
 72+  A9CF              ;
 73+  A9CF              titlescreen_init:
 74+  A9CF              ; We want a black screen.
 75+  A9CF 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 76+  A9D1                                      ; bright (64).
 77+  A9D1 CD 67 80         call utilities_clearscreen
 78+  A9D4 32 8D 5C         ld (23693),a        ; set our screen colours.
 79+  A9D7 3E 01            ld a,1              ; 2 is the code for red.
 80+  A9D9 D3 FE            out (254),a         ; write to port 254.
 81+  A9DB
 82+  A9DB 21 22 81         ld hl,string_titlescreen_copyright
 83+  A9DE CD C5 84         call string_print
 84+  A9E1
 85+  A9E1 C9               ret
 86+  A9E2
 87+  A9E2              ;
 88+  A9E2              ; Initialises the screen
 89+  A9E2              ;
 90+  A9E2              titlescreen_alt_init:
 91+  A9E2              ; We want a black screen.
 92+  A9E2 3E 47            ld a,71             ; white ink (7) on black paper (0),
 93+  A9E4                                      ; bright (64).
 94+  A9E4 CD 67 80         call utilities_clearscreen
 95+  A9E7 32 8D 5C         ld (23693),a        ; set our screen colours.
 96+  A9EA 3E 00            ld a,0              ; 2 is the code for red.
 97+  A9EC D3 FE            out (254),a         ; write to port 254.
 98+  A9EE
 99+  A9EE C9               ret
100+  A9EF
101+  A9EF              ;
102+  A9EF              ; Horiz, vert
103+  A9EF              ;
104+  A9EF              titlescreen_logo_data:
105+  A9EF 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
105+  A9F3 0A 00 0C 00
105+  A9F7 0F 00 11 00
105+  A9FB 12 00 13 00
106+  A9FF 09 01 0C 01      defb 9,1,12,1,15,1,17,1
106+  AA03 0F 01 11 01
107+  AA07 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
107+  AA0B 0D 02 0E 02
107+  AA0F 0F 02 11 02
107+  AA13 12 02 13 02
108+  AA17 09 03 0C 03      defb 9,3,12,3,15,3,17,3
108+  AA1B 0F 03 11 03
109+  AA1F 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
109+  AA23 0F 04 11 04
109+  AA27 12 04 13 04
110+  AA2B 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
110+  AA2F 02 06 03 06
110+  AA33 04 06 05 06
110+  AA37 06 06 07 06
110+  AA3B 08 06 09 06
110+  AA3F 0A 06 0B 06
111+  AA43 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
111+  AA47 12 06 13 06
111+  AA4B 14 06 15 06
111+  AA4F 16 06 17 06
111+  AA53 18 06 19 06
111+  AA57 1A 06 1B 06
112+  AA5B 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20
112+  AA5F 02 09 02 0A
112+  AA63 02 0B 02 0C
112+  AA67 02 0D 02 0E
112+  AA6B 02 0F 02 10
112+  AA6F 02 11 02 12
112+  AA73 02 13 02 14
113+  AA77 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20
113+  AA7B 19 09 19 0A
113+  AA7F 19 0B 19 0C
113+  AA83 19 0D 19 0E
113+  AA87 19 0F 19 10
113+  AA8B 19 11 19 12
113+  AA8F 19 13 19 14
114+  AA93 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
114+  AA97 05 0B 06 0B
114+  AA9B 07 0B 08 0B
114+  AA9F 09 0B 0A 0B
114+  AAA3 0B 0B
115+  AAA5 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
115+  AAA9 0B 09 0B 0A
116+  AAAD 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19,16,20
116+  AAB1 10 10 10 11
116+  AAB5 10 12 10 13
116+  AAB9 10 14
117+  AABB
# file closed: screen/titlescreen.asm
 27   AABB                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  AABB              ;
  2+  AABB              ; Draws the life remaining screen
  3+  AABB              ;
  4+  AABB              lifescreen_draw:
  5+  AABB CD 01 AB         call lifescreen_init
  6+  AABE
  7+  AABE 3A 32 B9         ld a,(game_currentplayer)             ; get the current player
  8+  AAC1 C6 30            add 48                                ; add 48 to get char
  9+  AAC3 21 49 83         ld hl,string_lifescreen_player+10
 10+  AAC6 77               ld (hl),a                             ; load this to the string we're about to show
 11+  AAC7
 12+  AAC7 21 3F 83         ld hl,string_lifescreen_player
 13+  AACA CD C5 84         call string_print
 14+  AACD
 15+  AACD 3A 69 B9         ld a,(player+9)                       ; get the current player lives
 16+  AAD0 C6 30            add 48                                ; add 48 to get the character
 17+  AAD2 FE 31            cp 49
 18+  AAD4 C2 E7 AA         jp nz,lifescreen_draw0
 19+  AAD7 21 59 83         ld hl,string_lifescreen_lastman
 20+  AADA
 21+  AADA 06 08            ld b,8
 22+  AADC 3E 0A            ld a,10                                ; set red
 23+  AADE 11 6C 58         ld de,22528+108                        ; attrs here
 24+  AAE1 CD CA A7         call screen_setcolours
 25+  AAE4
 26+  AAE4 C3 EE AA         jp lifescreen_draw1
 27+  AAE7              lifescreen_draw0:
 28+  AAE7 21 4E 83         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  AAEA 77               ld (hl),a                             ; load this to the string we're about to show
 30+  AAEB 21 4C 83         ld hl,string_lifescreen_lives
 31+  AAEE              lifescreen_draw1:
 32+  AAEE CD C5 84         call string_print
 33+  AAF1
 34+  AAF1 3E 86            ld a,134
 35+  AAF3 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AAF6 06 0A            ld b,10
 37+  AAF8 CD CA A7         call screen_setcolours
 38+  AAFB
 39+  AAFB 3E 64            ld a,100                              ; wait for 200 frames
 40+  AAFD CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 41+  AB00
 42+  AB00 C9               ret
 43+  AB01
 44+  AB01              ;
 45+  AB01              ; Initialises the screen
 46+  AB01              ;
 47+  AB01              lifescreen_init:
 48+  AB01              ; We want a blue screen.
 49+  AB01                  ;call $0D6B
 50+  AB01 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 51+  AB03                                      ; bright (64).
 52+  AB03 CD 67 80         call utilities_clearscreen
 53+  AB06 32 8D 5C         ld (23693),a        ; set our screen colours.
 54+  AB09 3E 01            ld a,1              ; 1 is the code for blue.
 55+  AB0B D3 FE            out (254),a         ; write to port 254.
 56+  AB0D                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 57+  AB0D
 58+  AB0D C9               ret
# file closed: screen/lifescreen.asm
 28   AB0E                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AB0E              ;
  2+  AB0E              ; Draws the game over screen
  3+  AB0E              ;
  4+  AB0E              gameover_draw:
  5+  AB0E CD 7A C0         call scores_processhighscores
  6+  AB11
  7+  AB11              gameover_draw0:
  8+  AB11 CD 51 AB         call gameover_enterhighscores
  9+  AB14
 10+  AB14 CD EF AB         call gameover_init
 11+  AB17
 12+  AB17 21 64 83         ld hl,string_gameoverscreen_gameover
 13+  AB1A CD C5 84         call string_print
 14+  AB1D
 15+  AB1D 21 70 83         ld hl,string_gameoverscreen_copyright
 16+  AB20 CD C5 84         call string_print
 17+  AB23
 18+  AB23 CD 34 AB         call gameover_commontext
 19+  AB26
 20+  AB26 06 0B            ld b,11
 21+  AB28 3E 42            ld a,66
 22+  AB2A 11 2B 58         ld de,22528+43                         ; attrs here
 23+  AB2D CD CA A7         call screen_setcolours
 24+  AB30 CD 47 80         call utilities_waitforkey   ; wait for keypress
 25+  AB33
 26+  AB33 C9               ret
 27+  AB34
 28+  AB34              ;
 29+  AB34              ; Draws text shared by the game over and high score screens
 30+  AB34              ;
 31+  AB34              gameover_commontext:
 32+  AB34 CD 9C A7         call screen_setuptext       ; show scores
 33+  AB37 CD 44 C0         call scores_printscores     ; print the current scores
 34+  AB3A
 35+  AB3A 21 9E 83         ld hl,string_gameover_credits
 36+  AB3D CD C5 84         call string_print
 37+  AB40
 38+  AB40 21 8A 83         ld hl,string_gameoverscreen_bestscores
 39+  AB43 CD C5 84         call string_print
 40+  AB46
 41+  AB46 06 20            ld b,32
 42+  AB48 3E 45            ld a,69
 43+  AB4A 11 C0 5A         ld de,22528+704                         ; attrs here
 44+  AB4D CD CA A7         call screen_setcolours
 45+  AB50
 46+  AB50 C9               ret
 47+  AB51
 48+  AB51              ;
 49+  AB51              ; If required, enter highscore
 50+  AB51              ;
 51+  AB51              gameover_enterhighscores:
 52+  AB51                  ; check if we need to enter initial
 53+  AB51 3A 79 C0         ld a,(scores_highscoretmp)
 54+  AB54 FE 00            cp 0
 55+  AB56 C8               ret z
 56+  AB57 CD 85 AB         call gameover_enterhighscores_init
 57+  AB5A 3A 79 C0         ld a,(scores_highscoretmp)
 58+  AB5D 3D               dec a
 59+  AB5E 3D               dec a
 60+  AB5F 3D               dec a                                   ; get high score location back to position of name
 61+  AB60 16 00            ld d,0
 62+  AB62 5F               ld e,a
 63+  AB63 21 00 C0         ld hl,scores_table
 64+  AB66 19               add hl,de                               ; load memory into hl
 65+  AB67 08               ex af,af'
 66+  AB68 06 0F            ld b,15
 67+  AB6A CD 82 80         call utilities_pauseforframes           ; pause for a little bit
 68+  AB6D 06 03            ld b,3                                  ; collect three chars
 69+  AB6F              gameover_draw2:
 70+  AB6F C5               push bc
 71+  AB70 E5               push hl
 72+  AB71 CD 86 80         call utilities_readkey               ; get key into a
 73+  AB74 E1               pop hl
 74+  AB75 77               ld (hl),a
 75+  AB76 23               inc hl
 76+  AB77 E5               push hl
 77+  AB78 CD 66 C0         call scores_showtable
 78+  AB7B E1               pop hl
 79+  AB7C 06 0F            ld b,15
 80+  AB7E CD 82 80         call utilities_pauseforframes
 81+  AB81 C1               pop bc
 82+  AB82 10 EB            djnz gameover_draw2
 83+  AB84 C9               ret
 84+  AB85
 85+  AB85              ;
 86+  AB85              ; Displays the screen text for high score entry
 87+  AB85              ;
 88+  AB85              gameover_enterhighscores_init:
 89+  AB85
 90+  AB85 CD EF AB         call gameover_init
 91+  AB88 CD 34 AB         call gameover_commontext
 92+  AB8B
 93+  AB8B 21 AA 83         ld hl,string_highscore_congratulations
 94+  AB8E CD C5 84         call string_print
 95+  AB91
 96+  AB91 3A 32 B9         ld a,(game_currentplayer)
 97+  AB94 FE 01            cp 1
 98+  AB96 21 BC 83         ld hl,string_highscore_player1
 99+  AB99 C3 9F AB         jp gameover_enterhighscores_init1
100+  AB9C              gameover_enterhighscores_init0:
101+  AB9C 21 C7 83         ld hl,string_highscore_player2
102+  AB9F              gameover_enterhighscores_init1:
103+  AB9F CD C5 84         call string_print
104+  ABA2 06 60            ld b,96
105+  ABA4 3E 43            ld a,67
106+  ABA6 11 A0 58         ld de,22528+160                         ; attrs here
107+  ABA9 CD CA A7         call screen_setcolours
108+  ABAC
109+  ABAC 21 D2 83         ld hl,string_highscore_youhaveearned
110+  ABAF CD C5 84         call string_print
111+  ABB2
112+  ABB2 3A 79 C0         ld a,(scores_highscoretmp)
113+  ABB5 FE 05            cp 5
114+  ABB7 CA C5 AB         jp z, gameover_enterhighscores_init2    ; first place
115+  ABBA FE 11            cp 17
116+  ABBC CA CB AB         jp z, gameover_enterhighscores_init3    ; 2nd place
117+  ABBF 21 0E 84         ld hl,string_highscore_place3           ; 3rd place
118+  ABC2 C3 D1 AB         jp gameover_enterhighscores_init4
119+  ABC5              gameover_enterhighscores_init2
120+  ABC5 21 E4 83         ld hl,string_highscore_place1
121+  ABC8 C3 D1 AB         jp gameover_enterhighscores_init4
122+  ABCB              gameover_enterhighscores_init3
123+  ABCB 21 F9 83         ld hl,string_highscore_place2
124+  ABCE C3 D1 AB         jp gameover_enterhighscores_init4
125+  ABD1              gameover_enterhighscores_init4
126+  ABD1 CD C5 84         call string_print
127+  ABD4
128+  ABD4 06 60            ld b,96
129+  ABD6 3E 42            ld a,66
130+  ABD8 11 40 59         ld de,22528+320                         ; attrs here
131+  ABDB CD CA A7         call screen_setcolours
132+  ABDE
133+  ABDE 21 23 84         ld hl,string_highscore_pleaseenter
134+  ABE1 CD C5 84         call string_print
135+  ABE4
136+  ABE4 06 60            ld b,96
137+  ABE6 3E 46            ld a,70
138+  ABE8 11 E0 59         ld de,22528+480                         ; attrs here
139+  ABEB CD CA A7         call screen_setcolours
140+  ABEE C9               ret
141+  ABEF
142+  ABEF              ;
143+  ABEF              ; Initialises the screen
144+  ABEF              ;
145+  ABEF              gameover_init:
146+  ABEF              ; We want a black screen.
147+  ABEF 3E 47            ld a,71             ; white ink (7) on black paper (0),
148+  ABF1                                      ; bright (64).
149+  ABF1 CD 67 80         call utilities_clearscreen
150+  ABF4 32 8D 5C         ld (23693),a        ; set our screen colours.
151+  ABF7 3E 00            ld a,0              ; 2 is the code for red.
152+  ABF9 D3 FE            out (254),a         ; write to port 254.
153+  ABFB C9               ret
# file closed: screen/gameover.asm
 29   ABFC                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  ABFC              ;
  2+  ABFC              ; Draws the level transition screen
  3+  ABFC              ;
  4+  ABFC              endlevel_draw:
  5+  ABFC CD F2 AC         call endlevel_init
  6+  ABFF CD DB AC         call endlevel_commontext
  7+  AC02
  8+  AC02 21 AA 83         ld hl,string_highscore_congratulations
  9+  AC05 CD C5 84         call string_print
 10+  AC08
 11+  AC08 3A 32 B9         ld a,(game_currentplayer)
 12+  AC0B FE 01            cp 1
 13+  AC0D 21 BC 83         ld hl,string_highscore_player1
 14+  AC10 C3 16 AC         jp endlevel_init1
 15+  AC13              endlevel_init0:
 16+  AC13 21 C7 83         ld hl,string_highscore_player2
 17+  AC16              endlevel_init1:
 18+  AC16 CD C5 84         call string_print
 19+  AC19
 20+  AC19 21 40 84         ld hl,string_endlevel_youhaveearned
 21+  AC1C CD C5 84         call string_print
 22+  AC1F
 23+  AC1F CD 7A AC         call endlevel_workoutbonus
 24+  AC22 D5               push de
 25+  AC23 08               ex af,af'                               ; store the a value for later
 26+  AC24 CD C5 84         call string_print
 27+  AC27 D1               pop de
 28+  AC28 62 6B            ld hl,de                                ; get the points text into de
 29+  AC2A CD C5 84         call string_print
 30+  AC2D
 31+  AC2D 21 AB 84         ld hl, string_endlevel_anothergo
 32+  AC30 CD C5 84         call string_print
 33+  AC33
 34+  AC33 06 20            ld b,32
 35+  AC35 3E 63            ld a,99
 36+  AC37 11 60 59         ld de,22528+352                         ; attrs here
 37+  AC3A CD CA A7         call screen_setcolours
 38+  AC3D
 39+  AC3D 06 20            ld b,32
 40+  AC3F 3E 65            ld a,101
 41+  AC41 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AC44 CD CA A7         call screen_setcolours
 43+  AC47
 44+  AC47 06 20            ld b,32
 45+  AC49 3E 63            ld a,99
 46+  AC4B 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AC4E CD CA A7         call screen_setcolours
 48+  AC51
 49+  AC51 06 20            ld b,32
 50+  AC53 3E 62            ld a,98
 51+  AC55 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AC58 CD CA A7         call screen_setcolours
 53+  AC5B
 54+  AC5B 08               ex af,af'                               ; get back a value with bonus type
 55+  AC5C 06 14            ld b,20
 56+  AC5E CD 82 80         call utilities_pauseforframes
 57+  AC61
 58+  AC61 47               ld b,a                      ; put the bonus count in b
 59+  AC62              endlevel_init2:
 60+  AC62 C5               push bc
 61+  AC63 06 01            ld b,1
 62+  AC65 CD 24 C0         call scores_addthousands
 63+  AC68 CD 10 BA         call player_recordcurrentscore
 64+  AC6B CD 44 C0         call scores_printscores     ; print the current scores
 65+  AC6E 06 0A            ld b,10
 66+  AC70 CD 82 80         call utilities_pauseforframes
 67+  AC73 C1               pop bc
 68+  AC74 10 EC            djnz endlevel_init2
 69+  AC76
 70+  AC76 CD 47 80         call utilities_waitforkey   ; wait for keypress
 71+  AC79
 72+  AC79 C9               ret
 73+  AC7A
 74+  AC7A              ;
 75+  AC7A              ; Works out the bonus
 76+  AC7A              ; Outputs:
 77+  AC7A              ; a = 15 (all seven)
 78+  AC7A              ; a = 10 (3 large or 4 small)
 79+  AC7A              ; a = 5 (1 large diamond)
 80+  AC7A              ; hl - pointer to bonus text
 81+  AC7A              ; de - pointer to points text
 82+  AC7A              ;
 83+  AC7A              endlevel_workoutbonus:
 84+  AC7A 21 68 B2         ld hl,level01diamonds+2     ; location of state of first diamond
 85+  AC7D 06 03            ld b,3                      ; number to check
 86+  AC7F 16 00            ld d,0                      ; zero diamond count
 87+  AC81              endlevel_workoutbonus0:
 88+  AC81 7E               ld a,(hl)                   ; get state
 89+  AC82 FE 01            cp 1
 90+  AC84 C2 88 AC         jp nz,endlevel_workoutbonus1 ; if not, move on
 91+  AC87 14               inc d                       ; increment diamond count
 92+  AC88              endlevel_workoutbonus1:
 93+  AC88 23               inc hl
 94+  AC89 23               inc hl
 95+  AC8A 23               inc hl
 96+  AC8B 23               inc hl
 97+  AC8C 23               inc hl                      ; get to next state
 98+  AC8D 10 F2            djnz endlevel_workoutbonus0
 99+  AC8F
100+  AC8F 21 78 B2         ld hl,level01gems+2     ; location of state of first gem
101+  AC92 06 04            ld b,4                      ; number to check
102+  AC94 1E 00            ld e,0                      ; zero gem count
103+  AC96              endlevel_workoutbonus2:
104+  AC96 7E               ld a,(hl)                   ; get state
105+  AC97 FE 01            cp 1
106+  AC99 C2 9D AC         jp nz,endlevel_workoutbonus3 ; if not, move on
107+  AC9C 1C               inc e                       ; increment diamond count
108+  AC9D              endlevel_workoutbonus3:
109+  AC9D 23               inc hl
110+  AC9E 23               inc hl
111+  AC9F 23               inc hl
112+  ACA0 23               inc hl
113+  ACA1 23               inc hl                     ; get to next state
114+  ACA2 10 F2            djnz endlevel_workoutbonus2
115+  ACA4
116+  ACA4 7A               ld a,d
117+  ACA5 83               add e
118+  ACA6 FE 07            cp 7                        ; check for max bonus
119+  ACA8 C2 B4 AC         jp nz,endlevel_workoutbonus4 ;
120+  ACAB 3E 0F            ld a,15
121+  ACAD 21 70 84         ld hl, string_endlevel_bonus3
122+  ACB0 11 9C 84         ld de, string_endlevel_points3
123+  ACB3 C9               ret                         ; return with bonus of 15
124+  ACB4              endlevel_workoutbonus4:
125+  ACB4 7A               ld a,d                      ; check for for diamonds
126+  ACB5 FE 03            cp 3
127+  ACB7 C2 C3 AC         jp nz,endlevel_workoutbonus5
128+  ACBA 3E 0A            ld a,10
129+  ACBC 21 61 84         ld hl, string_endlevel_bonus2
130+  ACBF 11 8D 84         ld de, string_endlevel_points2
131+  ACC2 C9               ret                         ; return with bonus of ten
132+  ACC3              endlevel_workoutbonus5:
133+  ACC3 7B               ld a,e                      ; check for four gems
134+  ACC4 FE 04            cp 4
135+  ACC6 C2 D2 AC         jp nz,endlevel_workoutbonus6
136+  ACC9 3E 0A            ld a,10
137+  ACCB 21 61 84         ld hl, string_endlevel_bonus2
138+  ACCE 11 8D 84         ld de, string_endlevel_points2
139+  ACD1 C9               ret                         ; return with bonus of 10
140+  ACD2              endlevel_workoutbonus6:
141+  ACD2 3E 05            ld a,5                      ; otherwise, bonus is 5
142+  ACD4 21 52 84         ld hl, string_endlevel_bonus1
143+  ACD7 11 7F 84         ld de, string_endlevel_points1
144+  ACDA C9               ret
145+  ACDB
146+  ACDB              ;
147+  ACDB              ; Draws text shared by the game over and high score screens
148+  ACDB              ;
149+  ACDB              endlevel_commontext:
150+  ACDB CD 9C A7         call screen_setuptext       ; show scores
151+  ACDE CD 44 C0         call scores_printscores     ; print the current scores
152+  ACE1
153+  ACE1 21 8A 83         ld hl,string_gameoverscreen_bestscores
154+  ACE4 CD C5 84         call string_print
155+  ACE7
156+  ACE7 06 20            ld b,32
157+  ACE9 3E 45            ld a,69
158+  ACEB 11 C0 5A         ld de,22528+704                         ; attrs here
159+  ACEE CD CA A7         call screen_setcolours
160+  ACF1
161+  ACF1 C9               ret
162+  ACF2
163+  ACF2              ;
164+  ACF2              ; Initialises the screen
165+  ACF2              ;
166+  ACF2              endlevel_init:
167+  ACF2              ; We want a green screen.
168+  ACF2 3E 61            ld a,97             ; white ink (7) on black paper (0),
169+  ACF4                                      ; bright (64).
170+  ACF4 CD 67 80         call utilities_clearscreen
171+  ACF7 32 8D 5C         ld (23693),a        ; set our screen colours.
172+  ACFA 3E 00            ld a,0              ; 2 is the code for red.
173+  ACFC D3 FE            out (254),a         ; write to port 254.
174+  ACFE C9               ret
# file closed: screen/endlevel.asm
 30   ACFF
 31   ACFF                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  ACFF              sound_gemcollected:
  2+  ACFF 21 C8 00         ld hl,200 ; pitch.
  3+  AD02 11 3E 00         ld de,62 ; duration.
  4+  AD05 CD B5 03         call 949 ; ROM beeper routine.
  5+  AD08 C9               ret
  6+  AD09
  7+  AD09              sound_pitchbend:
  8+  AD09 21 F4 01         ld hl,500 ; starting pitch.
  9+  AD0C 06 FA            ld b,250 ; length of pitch bend.
 10+  AD0E              sound_pitchbend0:
 11+  AD0E C5                push bc
 12+  AD0F E5               push hl ; store pitch.
 13+  AD10 11 01 00         ld de,1 ; very short duration.
 14+  AD13 CD B5 03         call 949 ; ROM beeper routine.
 15+  AD16 E1               pop hl ; restore pitch.
 16+  AD17 23               inc hl ; pitch going up.
 17+  AD18 C1               pop bc
 18+  AD19 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  AD1B C9               ret
 20+  AD1C
 21+  AD1C              sound_rockfell:
 22+  AD1C 08               ex af,af'
 23+  AD1D 1E 32            ld e,50 ; repeat 250 times.
 24+  AD1F 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  AD22 D5           sound_rockfell2 push de
 26+  AD23 06 20            ld b,32 ; length of step.
 27+  AD25 C5           sound_rockfell0 push bc
 28+  AD26 7E               ld a,(hl) ; next "random" number.
 29+  AD27 23               inc hl ; pointer.
 30+  AD28 E6 F8            and 248 ; we want a black border.
 31+  AD2A D3 FE            out (254),a ; write to speaker.
 32+  AD2C 7B               ld a,e ; as e gets smaller...
 33+  AD2D 2F               cpl ; ...we increase the delay.
 34+  AD2E 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  AD2F 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  AD31 C1               pop bc
 37+  AD32 10 F1            djnz sound_rockfell0 ; next step.
 38+  AD34 D1               pop de
 39+  AD35 7B               ld a,e
 40+  AD36 D6 18            sub 24 ; size of step.
 41+  AD38 FE 1E            cp 30 ; end of range.
 42+  AD3A CA 4B AD         jp z,sound_rockfell5
 43+  AD3D DA 4B AD         jp c, sound_rockfell5
 44+  AD40 5F               ld e,a
 45+  AD41 2F               cpl
 46+  AD42 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  AD44 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  AD46 3D               dec a
 49+  AD47 20 F9            jr nz,sound_rockfell3
 50+  AD49 18 D7            jr sound_rockfell2
 51+  AD4B              sound_rockfell5
 52+  AD4B 08               ex af,af'
 53+  AD4C C9               ret
 54+  AD4D
# file closed: sound/sound.asm
 32   AD4D
 33   AD4D                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  AD4D              ; ###############################################################
  2+  AD4D              ; Data for level 1
  3+  AD4D              ; ###############################################################
  4+  AD4D              level01:
  5+  AD4D
  6+  AD4D                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  AD4D
  8+  AD4D 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  AD51 05 05 05 05
  8+  AD55 05 05 05 05
  8+  AD59 05 05 02 01
  8+  AD5D 01 01 03 05
  8+  AD61 05 05 05 05
  8+  AD65 05 05 05 05
  8+  AD69 05 05 00 00
  9+  AD6D 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  AD71 05 05 05 05
  9+  AD75 05 05 05 05
  9+  AD79 02 01 01 01
  9+  AD7D 01 01 01 01
  9+  AD81 03 05 05 05
  9+  AD85 05 05 05 05
  9+  AD89 05 05 00 00
 10+  AD8D 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  AD91 05 05 05 05
 10+  AD95 05 05 02 01
 10+  AD99 01 01 01 01
 10+  AD9D 01 01 01 01
 10+  ADA1 01 01 03 05
 10+  ADA5 0D 0D 0D 0D
 10+  ADA9 0D 0D 00 00
 11+  ADAD 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  ADB1 01 01 00 01
 11+  ADB5 01 01 01 01
 11+  ADB9 01 01 01 01
 11+  ADBD 01 01 01 01
 11+  ADC1 01 01 01 03
 11+  ADC5 05 05 05 05
 11+  ADC9 05 05 00 00
 12+  ADCD 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  ADD1 04 04 04 04
 12+  ADD5 04 04 01 01
 12+  ADD9 01 01 01 01
 12+  ADDD 01 01 01 01
 12+  ADE1 01 01 01 01
 12+  ADE5 01 01 01 01
 12+  ADE9 00 01 00 00
 13+  ADED 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  ADF1 04 04 04 04
 13+  ADF5 04 04 04 04
 13+  ADF9 01 01 01 01
 13+  ADFD 01 01 01 01
 13+  AE01 01 01 01 01
 13+  AE05 00 00 00 00
 13+  AE09 00 01 00 00
 14+  AE0D 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  AE11 04 01 01 01
 14+  AE15 01 01 04 04
 14+  AE19 04 04 01 01
 14+  AE1D 01 01 01 01
 14+  AE21 01 00 00 00
 14+  AE25 00 01 01 01
 14+  AE29 01 01 00 00
 15+  AE2D 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  AE31 04 04 04 04
 15+  AE35 04 01 04 04
 15+  AE39 04 04 04 04
 15+  AE3D 04 04 00 00
 15+  AE41 00 00 04 04
 15+  AE45 04 04 04 04
 15+  AE49 04 01 00 00
 16+  AE4D 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  AE51 01 04 01 01
 16+  AE55 01 01 04 04
 16+  AE59 04 04 04 04
 16+  AE5D 04 04 00 04
 16+  AE61 04 04 04 04
 16+  AE65 04 04 04 04
 16+  AE69 04 01 00 00
 17+  AE6D 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  AE71 00 00 00 00
 17+  AE75 00 04 04 04
 17+  AE79 04 04 04 04
 17+  AE7D 04 04 00 04
 17+  AE81 04 04 04 04
 17+  AE85 04 04 04 04
 17+  AE89 04 01 00 00
 18+  AE8D 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  AE91 15 15 15 15
 18+  AE95 15 01 04 04
 18+  AE99 04 04 04 04
 18+  AE9D 04 04 00 04
 18+  AEA1 04 04 04 04
 18+  AEA5 04 04 04 04
 18+  AEA9 04 01 00 00
 19+  AEAD 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  AEB1 00 00 00 00
 19+  AEB5 00 01 04 04
 19+  AEB9 04 04 04 04
 19+  AEBD 04 04 00 04
 19+  AEC1 04 04 04 04
 19+  AEC5 04 00 00 00
 19+  AEC9 00 01 00 00
 20+  AECD 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  AED1 00 00 00 00
 20+  AED5 00 01 04 04
 20+  AED9 04 04 04 04
 20+  AEDD 04 04 00 04
 20+  AEE1 04 04 04 04
 20+  AEE5 04 00 04 04
 20+  AEE9 00 01 00 00
 21+  AEED 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  AEF1 06 06 06 06
 21+  AEF5 06 01 04 04
 21+  AEF9 04 04 04 04
 21+  AEFD 04 04 00 04
 21+  AF01 04 04 04 04
 21+  AF05 04 00 04 04
 21+  AF09 00 01 00 00
 22+  AF0D 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  AF11 06 06 06 06
 22+  AF15 06 01 04 00
 22+  AF19 00 00 00 00
 22+  AF1D 00 00 00 00
 22+  AF21 00 00 00 00
 22+  AF25 00 00 04 04
 22+  AF29 00 01 00 00
 23+  AF2D 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  AF31 06 06 06 06
 23+  AF35 06 01 04 00
 23+  AF39 04 04 04 04
 23+  AF3D 04 04 00 04
 23+  AF41 04 04 00 04
 23+  AF45 04 04 04 04
 23+  AF49 00 01 00 00
 24+  AF4D 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  AF51 06 06 06 06
 24+  AF55 06 01 04 00
 24+  AF59 04 04 04 04
 24+  AF5D 04 04 00 04
 24+  AF61 04 04 00 04
 24+  AF65 04 04 04 04
 24+  AF69 00 01 00 00
 25+  AF6D 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  AF71 01 01 01 01
 25+  AF75 01 01 04 00
 25+  AF79 04 04 04 04
 25+  AF7D 04 04 00 04
 25+  AF81 04 04 00 04
 25+  AF85 04 04 04 04
 25+  AF89 00 01 00 00
 26+  AF8D 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  AF91 04 04 04 04
 26+  AF95 04 04 04 00
 26+  AF99 04 04 04 04
 26+  AF9D 04 04 00 04
 26+  AFA1 04 04 00 00
 26+  AFA5 00 00 04 04
 26+  AFA9 04 01 00 00
 27+  AFAD 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  AFB1 04 04 00 00
 27+  AFB5 00 00 00 00
 27+  AFB9 04 04 04 04
 27+  AFBD 04 04 00 04
 27+  AFC1 04 04 04 04
 27+  AFC5 04 00 04 04
 27+  AFC9 04 01 00 00
 28+  AFCD 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  AFD1 04 04 00 04
 28+  AFD5 04 04 04 04
 28+  AFD9 04 04 04 04
 28+  AFDD 04 04 00 04
 28+  AFE1 04 04 04 04
 28+  AFE5 04 00 04 04
 28+  AFE9 04 01 00 00
 29+  AFED 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  AFF1 04 04 00 04
 29+  AFF5 04 04 01 01
 29+  AFF9 01 01 01 01
 29+  AFFD 01 01 01 01
 29+  B001 01 01 01 01
 29+  B005 04 00 04 04
 29+  B009 04 01 00 00
 30+  B00D 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B011 04 04 00 04
 30+  B015 04 04 01 00
 30+  B019 00 00 00 00
 30+  B01D 00 00 00 00
 30+  B021 00 00 00 01
 30+  B025 04 00 04 04
 30+  B029 04 01 00 00
 31+  B02D 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B031 04 04 00 04
 31+  B035 04 04 01 00
 31+  B039 00 00 00 00
 31+  B03D 00 00 00 00
 31+  B041 00 00 00 01
 31+  B045 04 00 04 04
 31+  B049 04 01 00 00
 32+  B04D 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B051 04 04 00 04
 32+  B055 04 04 01 00
 32+  B059 00 00 00 00
 32+  B05D 00 00 00 00
 32+  B061 00 00 00 01
 32+  B065 04 00 04 04
 32+  B069 04 01 00 00
 33+  B06D 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B071 04 04 00 04
 33+  B075 04 04 04 00
 33+  B079 00 00 00 00
 33+  B07D 00 00 00 00
 33+  B081 00 00 00 04
 33+  B085 04 04 04 04
 33+  B089 04 01 00 00
 34+  B08D 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B091 04 04 04 04
 34+  B095 04 04 01 00
 34+  B099 00 00 00 00
 34+  B09D 00 00 00 00
 34+  B0A1 00 00 00 01
 34+  B0A5 04 04 04 04
 34+  B0A9 04 01 00 00
 35+  B0AD 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B0B1 04 04 04 04
 35+  B0B5 04 04 01 00
 35+  B0B9 00 00 01 00
 35+  B0BD 00 00 00 01
 35+  B0C1 00 00 00 01
 35+  B0C5 04 04 04 04
 35+  B0C9 04 01 00 00
 36+  B0CD 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B0D1 01 01 01 01
 36+  B0D5 01 01 01 01
 36+  B0D9 01 01 01 01
 36+  B0DD 01 01 01 01
 36+  B0E1 01 01 01 01
 36+  B0E5 01 01 01 01
 36+  B0E9 01 01 00 00
 37+  B0ED
 38+  B0ED              ; ###############################################################
 39+  B0ED              ; Object data: horiz, vert, state, memh, meml
 40+  B0ED              ; ###############################################################
 41+  B0ED              level01rocks:
 42+  B0ED 09 04 00 00      defb 9,4,0,0,0
 42+  B0F1 00
 43+  B0F2 0C 07 00 00      defb 12,7,0,0,0
 43+  B0F6 00
 44+  B0F7 10 07 00 00      defb 16,7,0,0,0
 44+  B0FB 00
 45+  B0FC 0B 08 00 00      defb 11,8,0,0,0
 45+  B100 00
 46+  B101 0A 0A 00 00      defb 10,10,0,0,0
 46+  B105 00
 47+  B106 0C 0A 00 00      defb 12,10,0,0,0
 47+  B10A 00
 48+  B10B 0D 09 00 00      defb 13,9,0,0,0
 48+  B10F 00
 49+  B110 0E 08 00 00      defb 14,8,0,0,0
 49+  B114 00
 50+  B115 0F 0B 00 00      defb 15,11,0,0,0
 50+  B119 00
 51+  B11A 0B 0C 00 00      defb 11,12,0,0,0
 51+  B11E 00
 52+  B11F 11 0C 00 00      defb 17,12,0,0,0
 52+  B123 00
 53+  B124 13 08 00 00      defb 19,8,0,0,0
 53+  B128 00
 54+  B129 16 09 00 00      defb 22,9,0,0,0
 54+  B12D 00
 55+  B12E 13 0A 00 00      defb 19,10,0,0,0
 55+  B132 00
 56+  B133 15 0A 00 00      defb 21,10,0,0,0
 56+  B137 00
 57+  B138 15 0C 00 00      defb 21,12,0,0,0
 57+  B13C 00
 58+  B13D 16 0C 00 00      defb 22,12,0,0,0
 58+  B141 00
 59+  B142 18 0A 00 00      defb 24,10,0,0,0
 59+  B146 00
 60+  B147 19 09 00 00      defb 25,9,0,0,0
 60+  B14B 00
 61+  B14C 1C 09 00 00      defb 28,9,0,0,0
 61+  B150 00
 62+  B151 1B 0C 00 00      defb 27,12,0,0,0
 62+  B155 00
 63+  B156 1A 0D 00 00      defb 26,13,0,0,0
 63+  B15A 00
 64+  B15B 19 0E 00 00      defb 25,14,0,0,0
 64+  B15F 00
 65+  B160 19 10 00 00      defb 25,16,0,0,0
 65+  B164 00
 66+  B165 1A 11 00 00      defb 26,17,0,0,0
 66+  B169 00
 67+  B16A 1B 11 00 00      defb 27,17,0,0,0
 67+  B16E 00
 68+  B16F 1C 12 00 00      defb 28,18,0,0,0
 68+  B173 00
 69+  B174 1A 13 00 00      defb 26,19,0,0,0
 69+  B178 00
 70+  B179 1B 15 00 00      defb 27,21,0,0,0
 70+  B17D 00
 71+  B17E 1A 17 00 00      defb 26,23,0,0,0
 71+  B182 00
 72+  B183 1B 18 00 00      defb 27,24,0,0,0
 72+  B187 00
 73+  B188 19 18 00 00      defb 25,24,0,0,0
 73+  B18C 00
 74+  B18D 18 17 00 00      defb 24,23,0,0,0
 74+  B191 00
 75+  B192 13 14 00 00      defb 19,20,0,0,0
 75+  B196 00
 76+  B197 14 12 00 00      defb 20,18,0,0,0
 76+  B19B 00
 77+  B19C 14 10 00 00      defb 20,16,0,0,0
 77+  B1A0 00
 78+  B1A1 15 10 00 00      defb 21,16,0,0,0
 78+  B1A5 00
 79+  B1A6 16 12 00 00      defb 22,18,0,0,0
 79+  B1AA 00
 80+  B1AB 11 14 00 00      defb 17,20,0,0,0
 80+  B1AF 00
 81+  B1B0 0D 11 00 00      defb 13,17,0,0,0
 81+  B1B4 00
 82+  B1B5 0C 13 00 00      defb 12,19,0,0,0
 82+  B1B9 00
 83+  B1BA 0B 13 00 00      defb 11,19,0,0,0
 83+  B1BE 00
 84+  B1BF 0A 11 00 00      defb 10,17,0,0,0
 84+  B1C3 00
 85+  B1C4 05 12 00 00      defb 5,18,0,0,0
 85+  B1C8 00
 86+  B1C9 07 16 00 00      defb 7,22,0,0,0
 86+  B1CD 00
 87+  B1CE 09 17 00 00      defb 9,23,0,0,0
 87+  B1D2 00
 88+  B1D3 07 18 00 00      defb 7,24,0,0,0
 88+  B1D7 00
 89+  B1D8 05 18 00 00      defb 5,24,0,0,0
 89+  B1DC 00
 90+  B1DD 06 19 00 00      defb 6,25,0,0,0
 90+  B1E1 00
 91+  B1E2 08 19 00 00      defb 8,25,0,0,0
 91+  B1E6 00
 92+  B1E7 04 17 00 00      defb 4,23,0,0,0
 92+  B1EB 00
 93+  B1EC FF               defb 255
 94+  B1ED
 95+  B1ED              level01missiles:
 96+  B1ED 0B 17 00 00      defb 11,23,0,0,0
 96+  B1F1 00
 97+  B1F2 0B 16 00 00      defb 11,22,0,0,0
 97+  B1F6 00
 98+  B1F7 0C 17 00 00      defb 12,23,0,0,0
 98+  B1FB 00
 99+  B1FC 0C 16 00 00      defb 12,22,0,0,0
 99+  B200 00
100+  B201 0D 17 00 00      defb 13,23,0,0,0
100+  B205 00
101+  B206 0D 16 00 00      defb 13,22,0,0,0
101+  B20A 00
102+  B20B 0E 17 00 00      defb 14,23,0,0,0
102+  B20F 00
103+  B210 0E 16 00 00      defb 14,22,0,0,0
103+  B214 00
104+  B215 0F 17 00 00      defb 15,23,0,0,0
104+  B219 00
105+  B21A 0F 16 00 00      defb 15,22,0,0,0
105+  B21E 00
106+  B21F 10 17 00 00      defb 16,23,0,0,0
106+  B223 00
107+  B224 10 16 00 00      defb 16,22,0,0,0
107+  B228 00
108+  B229 11 17 00 00      defb 17,23,0,0,0
108+  B22D 00
109+  B22E 11 16 00 00      defb 17,22,0,0,0
109+  B232 00
110+  B233 12 17 00 00      defb 18,23,0,0,0
110+  B237 00
111+  B238 12 16 00 00      defb 18,22,0,0,0
111+  B23C 00
112+  B23D 13 17 00 00      defb 19,23,0,0,0
112+  B241 00
113+  B242 13 16 00 00      defb 19,22,0,0,0
113+  B246 00
114+  B247 14 17 00 00      defb 20,23,0,0,0
114+  B24B 00
115+  B24C 14 16 00 00      defb 20,22,0,0,0
115+  B250 00
116+  B251 15 17 00 00      defb 21,23,0,0,0
116+  B255 00
117+  B256 15 16 00 00      defb 21,22,0,0,0
117+  B25A 00
118+  B25B 16 17 00 00      defb 22,23,0,0,0
118+  B25F 00
119+  B260 16 16 00 00      defb 22,22,0,0,0
119+  B264 00
120+  B265 FF               defb 255
121+  B266
122+  B266              ;
123+  B266              ; Diamonds: x,y,state,mem1+mem2
124+  B266              ;
125+  B266              level01diamonds:
126+  B266 0C 1B 00 00      defb 12,27,0,0,0
126+  B26A 00
127+  B26B 10 1B 00 00      defb 16,27,0,0,0
127+  B26F 00
128+  B270 15 1B 00 00      defb 21,27,0,0,0
128+  B274 00
129+  B275 FF               defb 255
130+  B276
131+  B276              level01gems:
132+  B276 12 14 00 00      defb 18,20,0,0,0
132+  B27A 00
133+  B27B 06 18 00 00      defb 6,24,0,0,0
133+  B27F 00
134+  B280 19 17 00 00      defb 25,23,0,0,0
134+  B284 00
135+  B285 1C 11 00 00      defb 28,17,0,0,0
135+  B289 00
136+  B28A FF               defb 255
137+  B28B              ;
138+  B28B              ; Score area colours
139+  B28B              ;
140+  B28B              score_colours:
141+  B28B 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  B28F 47 47 47 47
141+  B293 47 47 47 42
141+  B297 43 43 43 43
141+  B29B 43 43 43 43
141+  B29F 42 47 47 47
141+  B2A3 47 47 47 47
141+  B2A7 47 47 47 47
142+  B2AB 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  B2AF 47 47 47 47
142+  B2B3 47 47 47 46
142+  B2B7 46 46 46 46
142+  B2BB 46 46 46 46
142+  B2BF 46 47 47 47
142+  B2C3 47 47 47 47
142+  B2C7 47 47 47 47
143+  B2CB
144+  B2CB              high_score_colours:
145+  B2CB 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  B2CF 42 42 47 47
145+  B2D3 47 47 47 47
145+  B2D7 43 43 43 47
145+  B2DB 47 47 47 47
145+  B2DF 47 46 46 46
145+  B2E3 47 47 47 47
145+  B2E7 47 47 00 00
# file closed: leveldata/level01.asm
 34   B2EB                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B2EB              ; Tiles graphics.
  2+  B2EB              sprites:
  3+  B2EB 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B2EF 00 00 00 00
  4+  B2F3 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B2F7 FF FF FF FF
  5+  B2FB 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B2FF 1F 3F 7F FF
  6+  B303 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B307 F8 FC FE FF
  7+  B30B 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B30F 55 AA 55 AA
  8+  B313 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B317 00 00 00 00
  9+  B31B FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  B31F FF FF FF FF
 10+  B323 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  B327 00 00 00 00
 11+  B32B 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B32F F1 72 34 18
 12+  B333 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B337 FE FE FF 7E
 13+  B33B 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B33F FE FF 7E 3C
 14+  B343 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B347 00 00 FF FF
 15+  B34B 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  B34F FF 42 24 18
 16+  B353 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B357 00 00 00 00
 17+  B35B 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B35F 00 3C 5A 34
 18+  B363 FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  B367 FD FE FD FE
 19+  B36B F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  B36F F4 F8 F4 F8
 20+  B373 D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  B377 D0 E0 D0 E0
 21+  B37B 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  B37F 40 80 40 80
 22+  B383 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  B387 ED 00 00 00
 23+  B38B 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  B38F FF 7E 3C 18
 24+  B393 FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  B397 00 00 00 00
 25+  B39B FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  B39F 00 00 00 00
 26+  B3A3 F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  B3A7 00 00 00 00
 27+  B3AB C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  B3AF 00 00 00 00
 28+  B3B3 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  B3B7 00 00 00 00
 29+  B3BB
 30+  B3BB
 31+  B3BB              sprite_attrs:
 32+  B3BB 46               defb    070 ; 0, space
 33+  B3BC 4D               defb    077 ; 1, cyan block
 34+  B3BD 4D               defb    077 ; 2, slope left
 35+  B3BE 4D               defb    077 ; 3, slope right
 36+  B3BF 46               defb    070 ; 4, dirt
 37+  B3C0 4E               defb    078 ; 5, sky
 38+  B3C1 4C               defb    076 ; 6, slime
 39+  B3C2 42               defb    066 ; 7, trapdoor
 40+  B3C3 46               defb    070 ; 8, diamond
 41+  B3C4 42               defb    066 ; 9, rock
 42+  B3C5 42               defb    066 ; 10, rock 2
 43+  B3C6 49           	defb    073 ; 11, sky, trapdoor
 44+  B3C7 43           	defb    067 ; 12, missile
 45+  B3C8 4A               defb    074 ; 13, sky, red ink (tank)
 46+  B3C9 46               defb    070 ; 14, gem
 47+  B3CA 4D               defb    077 ; 15, damaged mountain
 48+  B3CB 4D               defb    077 ; 16, damaged mountain 2
 49+  B3CC 4D               defb    077 ; 17, damaged mountain 3
 50+  B3CD 4D               defb    077 ; 18, damaged mountain 4
 51+  B3CE 00           	defb 	000 ; 19, tank missile (not used
 52+  B3CF 43           	defb    067 ; 20, missile active
 53+  B3D0 42           	defb	066	; 21, the pit 1
 54+  B3D1 42           	defb	066	; 22, the pit 2
 55+  B3D2 42           	defb	066	; 23, the pit 3
 56+  B3D3 42           	defb	066	; 24, the pit 4
 57+  B3D4 42           	defb	066	; 25, the pit 5
 58+  B3D5
 59+  B3D5
 60+  B3D5              player_sprite:
 61+  B3D5 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 61+  B3D9 38 3D C3 80
 62+  B3DD 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 62+  B3E1 3C 1C 16 32
 63+  B3E5 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 63+  B3E9 3C 38 68 4C
 64+  B3ED 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 64+  B3F1 1C BC C3 01
 65+  B3F5 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 65+  B3F9 3C 3C 64 0C
 66+  B3FD 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 66+  B401 3C 3C 26 30
 67+  B405 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 67+  B409 1E 5C FD 5F
 68+  B40D 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 68+  B411 4F 8F 19 03
 69+  B415 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 69+  B419 F2 F1 98 C0
 70+  B41D FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 70+  B421 48 08 14 2A
 71+  B425 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 71+  B429 38 78 44 C3
 72+  B42D 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 72+  B431 1C 1E 22 C3
 73+  B435
 74+  B435              ;
 75+  B435              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 76+  B435              ;
 77+  B435              ship_sprite:
 78+  B435 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 78+  B439 03 1F 7F FF
 79+  B43D 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 79+  B441 FF FF FF FF
 80+  B445 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 80+  B449 FF FF FF FF
 81+  B44D 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 81+  B451 C0 F8 FE FF
 82+  B455 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 82+  B459 03 03 02 07
 83+  B45D 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 83+  B461 FF 0F 07 83
 84+  B465 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 84+  B469 FF 10 20 C1
 85+  B46D 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 85+  B471 C0 C0 40 E0
 86+  B475 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 86+  B479 03 03 02 07
 87+  B47D F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 87+  B481 FF 08 04 83
 88+  B485 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 88+  B489 FF F0 E0 C1
 89+  B48D CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 89+  B491 C0 C0 40 E0
 90+  B495
 91+  B495              ;
 92+  B495              ;  First 8 frames are tank, last frame is the gun barrel
 93+  B495              ;
 94+  B495              tank_sprite:
 95+  B495 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 95+  B499 7F 00 00 00
 96+  B49D 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 96+  B4A1 FE FF 7F 40
 97+  B4A5 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 97+  B4A9 03 FF FF 01
 98+  B4AD 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
 98+  B4B1 E0 C0 00 00
 99+  B4B5 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
 99+  B4B9 F7 E1 7F 3F
100+  B4BD FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
100+  B4C1 54 16 FF FF
101+  B4C5 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
101+  B4C9 9B A8 FF FF
102+  B4CD FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
102+  B4D1 9F AF FE FC
103+  B4D5 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
103+  B4D9 1F 00 00 00
# file closed: graphics/graphics.asm
 35   B4DD
 36   B4DD                  include "game\control.asm"
# file opened: game/control.asm
  1+  B4DD              ;
  2+  B4DD              ; Check the keyboard then move
  3+  B4DD              ;
  4+  B4DD              control_keyboard:
  5+  B4DD 3A 6B B9         ld a,(player+11)    ; first, check if player is dying
  6+  B4E0 FE 00            cp 0
  7+  B4E2 C0               ret nz               ; if so, can't move
  8+  B4E3 3A 65 B9         ld a,(player+5)      ; next, check if the player has pixels left to move
  9+  B4E6 FE 00            cp 0
 10+  B4E8 CA EF B4         jp z, control_keyboard5
 11+  B4EB CD F4 B5         call control_automove
 12+  B4EE C9               ret
 13+  B4EF              control_keyboard5:
 14+  B4EF 3A 66 B9         ld a,(player+6)      ; next, check if the player is digging
 15+  B4F2 FE 00            cp 0
 16+  B4F4 CA FB B4         jp z, control_keyboard0
 17+  B4F7 CD 32 B5         call control_dig
 18+  B4FA C9               ret
 19+  B4FB              control_keyboard0:
 20+  B4FB 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 21+  B4FE ED 78            in a,(c)            ; read keyboard.
 22+  B500 47               ld b,a              ; store result in b register.
 23+  B501 CB 18            rr b                ; check outermost key (q).
 24+  B503 D2 22 B5         jp nc,control_keyboard1
 25+  B506 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 26+  B509 ED 78            in a,(c)            ; read keyboard.
 27+  B50B 47               ld b,a              ; store result in b register.
 28+  B50C CB 18            rr b                ; check outermost key (a).
 29+  B50E D2 26 B5         jp nc,control_keyboard2
 30+  B511 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 31+  B514 ED 78            in a,(c)            ; read keyboard.
 32+  B516 47               ld b,a              ; store result in b register.
 33+  B517 CB 18            rr b                ; check outermost key (p).
 34+  B519 D2 2A B5         jp nc,control_keyboard3
 35+  B51C CB 18            rr b                ; check next key.
 36+  B51E D2 2E B5         jp nc,control_keyboard4
 37+  B521 C9               ret
 38+  B522              control_keyboard1:
 39+  B522 CD 3D B6         call control_pl_moveup         ; player up.
 40+  B525 C9               ret
 41+  B526              control_keyboard2:
 42+  B526 CD 6C B6         call control_pl_movedown       ; player down.
 43+  B529 C9               ret
 44+  B52A              control_keyboard3:
 45+  B52A CD C9 B6         call control_pl_moveright       ; player left.
 46+  B52D C9               ret
 47+  B52E              control_keyboard4:
 48+  B52E CD 99 B6         call control_pl_moveleft       ; player right.
 49+  B531 C9               ret
 50+  B532
 51+  B532              ;
 52+  B532              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 53+  B532              ;
 54+  B532              control_dig:
 55+  B532 ED 4B 60 B9      ld bc,(player)      ; load the current coords into bc
 56+  B536 C5               push bc
 57+  B537 3A 62 B9         ld a,(player+2)     ; get the direction
 58+  B53A FE 01            cp 1                ; left
 59+  B53C CA 54 B5         jp z,control_dig0
 60+  B53F FE 02            cp 2                ; right
 61+  B541 CA 69 B5         jp z,control_dig1
 62+  B544 FE 03            cp 3                ; down
 63+  B546 CA 8D B5         jp z,control_dig5
 64+  B549 FE 00            cp 0                ; up
 65+  B54B CA 7D B5         jp z,control_dig4
 66+  B54E 21 66 B9         ld hl,player+6
 67+  B551 36 00            ld (hl),0           ; turn off digging
 68+  B553 C9               ret                 ; return
 69+  B554              control_dig0:           ; going left
 70+  B554 CD 31 A9         call sprites_scadd  ; get the current coord
 71+  B557 62 6B            ld hl,de
 72+  B559 2B               dec hl              ; move one left
 73+  B55A C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
 74+  B55B 78               ld a,b
 75+  B55C 06 08            ld b,8
 76+  B55E 90               sub b
 77+  B55F 47               ld b,a
 78+  B560 79               ld a,c
 79+  B561 0E 08            ld c,8
 80+  B563 91               sub c
 81+  B564 4F               ld c,a
 82+  B565 C5               push bc
 83+  B566 C3 96 B5         jp control_dig2
 84+  B569              control_dig1:
 85+  B569 CD 31 A9         call sprites_scadd  ; get the current coord
 86+  B56C 62 6B            ld hl,de
 87+  B56E 23               inc hl              ; move one right
 88+  B56F C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
 89+  B570 3E 08            ld a,8
 90+  B572 80               add a,b
 91+  B573 47               ld b,a
 92+  B574 79               ld a,c
 93+  B575 0E 08            ld c,8
 94+  B577 91               sub c
 95+  B578 4F               ld c,a
 96+  B579 C5               push bc
 97+  B57A C3 96 B5         jp control_dig2
 98+  B57D              control_dig4:
 99+  B57D CD 31 A9         call sprites_scadd  ; get the current coord
100+  B580 62 6B            ld hl,de
101+  B582 11 20 00         ld de,32
102+  B585 ED 52            sbc hl,de             ; move one up
103+  B587 C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
104+  B588 0D               dec c
105+  B589 C5               push bc
106+  B58A C3 AE B5         jp control_dig6
107+  B58D              control_dig5:
108+  B58D CD 31 A9         call sprites_scadd  ; get the current coord
109+  B590 62 6B            ld hl,de
110+  B592 24               inc h              ; move one down
111+  B593                                     ; not bothered about working out bc here, since rock will never fall if digging down
112+  B593 C3 96 B5         jp control_dig2
113+  B596              ; Normal (not up) digging
114+  B596              control_dig2:
115+  B596 3A 68 B9         ld a,(player+8)     ; get the number of rows we need to overwrite
116+  B599 47               ld b,a              ; rows to copy over
117+  B59A E5               push hl             ; store the memory location of the first row for later
118+  B59B              control_dig3:
119+  B59B CD DD B5         call control_getpixelrow
120+  B59E 77               ld (hl),a           ; load contents into row
121+  B59F 11 20 00         ld de,32
122+  B5A2 19               add hl,de           ; move to next row
123+  B5A3 10 F6            djnz control_dig3
124+  B5A5 E1               pop hl              ; get the original memory location back
125+  B5A6 11 20 00         ld de,32
126+  B5A9 ED 52            sbc hl,de           ; move to above row, ready for checking for rock
127+  B5AB C3 C4 B5         jp control_dig10
128+  B5AE              ; Special case for going up
129+  B5AE              control_dig6:
130+  B5AE 3A 68 B9         ld a,(player+8)     ; get the number of rows we need to overwrite
131+  B5B1 47               ld b,a              ; rows to copy over
132+  B5B2              control_dig7:
133+  B5B2 CD DD B5         call control_getpixelrow
134+  B5B5              control_dig12:
135+  B5B5 77               ld (hl),a           ; load empty into row
136+  B5B6 11 20 00         ld de,32
137+  B5B9 ED 52            sbc hl,de           ; move up to next row
138+  B5BB 0D               dec c               ; decrease c to track rows
139+  B5BC 10 F4            djnz control_dig7
140+  B5BE 79               ld a,c
141+  B5BF D6 07            sub 7
142+  B5C1 C1               pop bc
143+  B5C2 4F               ld c,a
144+  B5C3 C5               push bc             ; store the decreased c coord
145+  B5C4              control_dig10:
146+  B5C4 DD 21 67 B9      ld ix,player+7
147+  B5C8 DD 7E 00         ld a,(ix)     ; get the dig frame number
148+  B5CB 3D               dec a
149+  B5CC DD 77 00         ld (ix),a
150+  B5CF                  ; call the check for rocks above the removed dirt
151+  B5CF DD 21 66 B9      ld ix,player+6
152+  B5D3 DD 7E 00         ld a,(ix)     ; get the dig state
153+  B5D6 FE 00            cp 0
154+  B5D8 C1               pop bc
155+  B5D9 CC 86 BE         call z, rocks_checkforfalling ; make the check if we're no longer digging
156+  B5DC C9               ret
157+  B5DD
158+  B5DD              ;
159+  B5DD              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
160+  B5DD              ; Inputs:
161+  B5DD              ; hl - memory of pixel row
162+  B5DD              ; Outputs:
163+  B5DD              ; a - modified row to write
164+  B5DD              ;
165+  B5DD              control_getpixelrow:
166+  B5DD 3A 67 B9         ld a,(player+7)     ; get the dig frame number
167+  B5E0 FE 00            cp 0                ; is this the last dig
168+  B5E2 CA E9 B5         jp z,control_getpixelrow1
169+  B5E5 7E               ld a,(hl)           ; if not, xor with 255 to flip it
170+  B5E6 EE FF            xor 255
171+  B5E8 C9               ret
172+  B5E9              control_getpixelrow1:
173+  B5E9 DD 21 66 B9      ld ix,player+6
174+  B5ED DD 36 00 00      ld (ix),0           ; turn off digging
175+  B5F1 3E 00            ld a,0              ; if it is, load with empty
176+  B5F3 C9               ret
177+  B5F4
178+  B5F4              ;
179+  B5F4              ; Auto move the player until pixels is zero
180+  B5F4              ;
181+  B5F4              control_automove:
182+  B5F4 5F               ld e,a              ; store the number of pixels left to move in e
183+  B5F5 ED 4B 60 B9      ld bc,(player)      ; load the current coords into bc
184+  B5F9 21 62 B9         ld hl,player+2      ; get the direction
185+  B5FC 7E               ld a,(hl)
186+  B5FD FE 03            cp 3                ; down
187+  B5FF CA 13 B6         jp z,control_automove3  ; don't need to do anything
188+  B602 FE 00            cp 0                ; going up
189+  B604 CA 1F B6         jp z,control_automove2
190+  B607 FE 01            cp 1                ; going left?
191+  B609 CA 2B B6         jp z,control_automove0
192+  B60C 78               ld a,b
193+  B60D 3C               inc a               ; if we're going right, increment a twice for two pixels
194+  B60E 3C               inc a
195+  B60F 47               ld b,a
196+  B610 C3 2F B6         jp control_automove1
197+  B613              control_automove3:
198+  B613 79               ld a,c
199+  B614 3C               inc a
200+  B615 3C               inc a               ; if we're going down, increment twice
201+  B616 4F               ld c,a
202+  B617 FE 90            cp 144
203+  B619 CC F7 B6         call z, control_scroll_down
204+  B61C C3 2F B6         jp control_automove1
205+  B61F              control_automove2:
206+  B61F 79               ld a,c
207+  B620 3D               dec a
208+  B621 3D               dec a               ; if we're going up, decrement twice
209+  B622 4F               ld c,a
210+  B623 FE 60            cp 96
211+  B625 CC 04 B7         call z, control_scroll_up
212+  B628 C3 2F B6         jp control_automove1
213+  B62B              control_automove0:
214+  B62B 78               ld a,b
215+  B62C 3D               dec a               ; if we're going left, decrement a twice
216+  B62D 3D               dec a
217+  B62E 47               ld b,a
218+  B62F              control_automove1:
219+  B62F ED 43 60 B9      ld (player),bc      ; and back to player
220+  B633 7B               ld a,e              ; now get the pixel count back
221+  B634 3D               dec a               ; decrease by one
222+  B635 21 65 B9         ld hl,player+5
223+  B638 77               ld (hl),a           ; copy back
224+  B639 CD EA BA         call player_justmoved
225+  B63C C9               ret
226+  B63D
227+  B63D              ;
228+  B63D              ; Moves the player up
229+  B63D              ;
230+  B63D              control_pl_moveup:
231+  B63D C5               push bc
232+  B63E ED 4B 60 B9      ld bc,(player)          ; get the current coords, b horiz, c vert
233+  B642 79               ld a,c                  ; load c into the acc
234+  B643 FE 18            cp 24
235+  B645 CA 65 B6         jp z,control_pl_moveup0 ; are we at the edge of the screen
236+  B648 FE 60            cp 96
237+  B64A CC 04 B7         call z, control_scroll_up
238+  B64D CD A4 B8         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
239+  B650 F5               push af
240+  B651 7B               ld a,e                  ; put e in a
241+  B652 FE 00            cp 0
242+  B654 CA 64 B6         jp z,control_pl_moveup1 ; don't move if we can't
243+  B657 F1               pop af
244+  B658 D6 01            sub 1                   ; subtract 1
245+  B65A D6 01            sub 1                   ; subtract 1
246+  B65C 4F               ld c,a                  ; load back to c
247+  B65D ED 43 60 B9      ld (player),bc          ; load back to player
248+  B661 C3 65 B6         jp control_pl_moveup0
249+  B664              control_pl_moveup1:
250+  B664 F1               pop af                  ; restore af if needed
251+  B665              control_pl_moveup0:
252+  B665 3E 00            ld a,0
253+  B667 32 62 B9         ld (player+2),a        ; set direction to up
254+  B66A C1               pop bc
255+  B66B C9               ret
256+  B66C              ;
257+  B66C              ; Moves the player down
258+  B66C              ;
259+  B66C              control_pl_movedown:
260+  B66C C5               push bc
261+  B66D ED 4B 60 B9      ld bc,(player)          ; get the current coords, b horiz, c vert
262+  B671 79               ld a,c                  ; load c into the acc
263+  B672 FE E0            cp 224
264+  B674 CA 92 B6         jp z,control_pl_movedown0 ; are we at the edge of the screen
265+  B677 FE 80            cp 128
266+  B679 CC F7 B6         call z, control_scroll_down
267+  B67C CD 78 B8         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
268+  B67F F5               push af
269+  B680 7B               ld a,e                  ; put e in a
270+  B681 FE 00            cp 0
271+  B683 CA 91 B6         jp z,control_pl_movedown1 ; don't move if we can't
272+  B686 F1               pop af
273+  B687 3C               inc a                   ; add 1
274+  B688 3C               inc a                   ; add 1
275+  B689 4F               ld c,a                  ; load back to c
276+  B68A ED 43 60 B9      ld (player),bc          ; load back to player
277+  B68E C3 92 B6         jp control_pl_movedown0
278+  B691              control_pl_movedown1:
279+  B691 F1               pop af                  ; restore af if needed
280+  B692              control_pl_movedown0:
281+  B692 3E 03            ld a,3
282+  B694 32 62 B9         ld (player+2),a        ; set direction to down
283+  B697 C1               pop bc
284+  B698 C9               ret
285+  B699              ;
286+  B699              ; Moves the player left
287+  B699              ;
288+  B699              control_pl_moveleft:
289+  B699 C5               push bc
290+  B69A ED 4B 60 B9      ld bc,(player)          ; get the current coords, b horiz, c vert
291+  B69E 78               ld a,b                  ; load b into the acc
292+  B69F FE 10            cp 16
293+  B6A1 CA C2 B6         jp z,control_pl_moveleft0 ; are we at the edge of the screen
294+  B6A4 CD 03 B9         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
295+  B6A7 F5               push af
296+  B6A8 7B               ld a,e                  ; put e in a
297+  B6A9 FE 00            cp 0
298+  B6AB CA C1 B6         jp z,control_pl_moveleft1 ; don't move if we can't
299+  B6AE 21 65 B9         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
300+  B6B1 3E 03            ld a,3
301+  B6B3 77               ld (hl),a
302+  B6B4 F1               pop af
303+  B6B5 D6 01            sub 1                    ; subtract 2
304+  B6B7 D6 01            sub 1
305+  B6B9 47               ld b,a                  ; load back to c
306+  B6BA ED 43 60 B9      ld (player),bc          ; load back to player
307+  B6BE C3 C2 B6         jp control_pl_moveleft0
308+  B6C1              control_pl_moveleft1:
309+  B6C1 F1               pop af
310+  B6C2              control_pl_moveleft0:
311+  B6C2 3E 01            ld a,1
312+  B6C4 32 62 B9         ld (player+2),a        ; set direction to left
313+  B6C7 C1               pop bc
314+  B6C8 C9               ret
315+  B6C9              ;
316+  B6C9              ; Moves the player right
317+  B6C9              ;
318+  B6C9              control_pl_moveright:
319+  B6C9 C5               push bc
320+  B6CA ED 4B 60 B9      ld bc,(player)          ; get the current coords, b horiz, c vert
321+  B6CE 78               ld a,b                  ; load b into the acc
322+  B6CF FE F0            cp 240
323+  B6D1 CA F0 B6         jp z,control_pl_moveright0 ; are we at the edge of the screen
324+  B6D4 CD D7 B8         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
325+  B6D7 F5               push af
326+  B6D8 7B               ld a,e                  ; put e in a
327+  B6D9 FE 00            cp 0
328+  B6DB CA EF B6         jp z,control_pl_moveright1 ; don't move if we can't
329+  B6DE 21 65 B9         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
330+  B6E1 3E 03            ld a,3
331+  B6E3 77               ld (hl),a
332+  B6E4 F1               pop af
333+  B6E5 3C               inc a                   ; add 2
334+  B6E6 3C               inc a
335+  B6E7 47               ld b,a                  ; load back to b
336+  B6E8 ED 43 60 B9      ld (player),bc          ; load back to player
337+  B6EC C3 F0 B6         jp control_pl_moveright0
338+  B6EF              control_pl_moveright1:
339+  B6EF F1               pop af                  ; restore af if needed
340+  B6F0              control_pl_moveright0:
341+  B6F0 3E 02            ld a,2
342+  B6F2 32 62 B9         ld (player+2),a        ; set direction to right
343+  B6F5 C1               pop bc
344+  B6F6 C9               ret
345+  B6F7
346+  B6F7              ;
347+  B6F7              ; Scrolls the screen down
348+  B6F7              ;
349+  B6F7              control_scroll_down:
350+  B6F7 F5               push af
351+  B6F8 3E 08            ld a,8
352+  B6FA 32 15 A7         ld (screen_offset),a
353+  B6FD F1               pop af
354+  B6FE 21 C4 A5         ld hl,buffer_updateall
355+  B701 36 01            ld (hl),1         ; flag as screen needing update
356+  B703 C9               ret
357+  B704
358+  B704              ;
359+  B704              ; Scrolls the screen up
360+  B704              ;
361+  B704              control_scroll_up:
362+  B704 F5               push af
363+  B705 3E 00            ld a,0
364+  B707 32 15 A7         ld (screen_offset),a
365+  B70A F1               pop af
366+  B70B 21 C4 A5         ld hl,buffer_updateall
367+  B70E 36 01            ld (hl),1         ; flag as screen needing update
368+  B710 C9               ret
369+  B711
370+  B711
371+  B711
372+  B711
# file closed: game/control.asm
 37   B711                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  B711              ;
  2+  B711              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  3+  B711              ; Inputs:
  4+  B711              ; hl - memory location of top pixel row
  5+  B711              ; bc - screen coords, b horiz, c vert
  6+  B711              ; Outputs:
  7+  B711              ; e - 0 if not empty, 1 if empty
  8+  B711              ;
  9+  B711              movement_spaceisempty:
 10+  B711 C5               push bc
 11+  B712 E5               push hl
 12+  B713 CD 3B B7         call movement_spaceisgem        ; check if space is a gem
 13+  B716 E1               pop hl
 14+  B717 C1               pop bc
 15+  B718 7B               ld a,e
 16+  B719 FE 01            cp 1
 17+  B71B C8               ret z                           ; if e is 1, space is a gem so can move here, return
 18+  B71C 3E 08            ld a,8                          ; 8 rows to check
 19+  B71E              movement_spaceisempty0:
 20+  B71E 08               ex af,af'                       ; store the loop counter
 21+  B71F 7E               ld a,(hl)                       ; get current pixel row
 22+  B720 FE 00            cp 0
 23+  B722 C2 36 B7         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 24+  B725 79               ld a,c                          ; load the vertical coord
 25+  B726 3C               inc a                           ; next row down
 26+  B727 11 20 00         ld de,32
 27+  B72A 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 28+  B72B 4F               ld c,a                          ; copy vert coord back to c
 29+  B72C 08               ex af,af'                       ; get loop counter back
 30+  B72D 3D               dec a                           ; decrease loop counter
 31+  B72E C2 1E B7         jp nz, movement_spaceisempty0
 32+  B731 16 00            ld d,0
 33+  B733 1E 01            ld e,1                          ; got to end, so space is empty
 34+  B735 C9               ret
 35+  B736              movement_spaceisempty1:
 36+  B736 16 00            ld d,0
 37+  B738 1E 00            ld e,0                          ; returning false, ie space not empty
 38+  B73A C9               ret
 39+  B73B
 40+  B73B              ;
 41+  B73B              ; Check if a space contains a gem
 42+  B73B              ; Inputs:
 43+  B73B              ; bc - screen coords
 44+  B73B              ; Outputs:
 45+  B73B              ; e = 1 if gem
 46+  B73B              movement_spaceisgem:
 47+  B73B CD 53 A8         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 48+  B73E 21 66 B2         ld hl,level01diamonds           ; check diamonds first
 49+  B741              movement_spaceisgem0:
 50+  B741 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 51+  B745 7B               ld a,e                          ; check for end of data
 52+  B746 FE FF            cp 255
 53+  B748 CA 63 B7         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 54+  B74B 23               inc hl
 55+  B74C 23               inc hl                          ; move to state
 56+  B74D 7E               ld a,(hl)
 57+  B74E 23               inc hl
 58+  B74F 23               inc hl
 59+  B750 23               inc hl                          ; get to next
 60+  B751 FE 01            cp 1                            ; check if collected
 61+  B753 CA 41 B7         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 62+  B756 7B               ld a,e                          ; load e again
 63+  B757 B9               cp c                            ; otherwise, compare c with e
 64+  B758 C2 41 B7         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 65+  B75B 7A               ld a,d                          ; get d coord
 66+  B75C B8               cp b                            ; compare b with d
 67+  B75D C2 41 B7         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 68+  B760 1E 01            ld e,1                          ; otherwise, exit with e = 1
 69+  B762 C9               ret
 70+  B763              movement_spaceisgem1:
 71+  B763 21 76 B2         ld hl,level01gems              ; check gems
 72+  B766              movement_spaceisgem2:
 73+  B766 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 74+  B76A 7B               ld a,e                          ; check for end of data
 75+  B76B FE FF            cp 255
 76+  B76D CA 88 B7         jp z,movement_spaceisgem3       ; if yes, done with gems
 77+  B770 23               inc hl
 78+  B771 23               inc hl                          ; move to state
 79+  B772 7E               ld a,(hl)
 80+  B773 23               inc hl
 81+  B774 23               inc hl
 82+  B775 23               inc hl                          ; get to next
 83+  B776 FE 01            cp 1                            ; check if collected
 84+  B778 CA 66 B7         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 85+  B77B 7B               ld a,e                          ; load e again
 86+  B77C B9               cp c                            ; otherwise, compare c with e
 87+  B77D C2 66 B7         jp nz,movement_spaceisgem2      ; if different, move to next gem
 88+  B780 7A               ld a,d                          ; get d coord
 89+  B781 B8               cp b                            ; compare b with d
 90+  B782 C2 66 B7         jp nz,movement_spaceisgem2      ; if different, move to next gem
 91+  B785 1E 01            ld e,1                          ; otherwise, exit with e = 1
 92+  B787 C9               ret
 93+  B788              movement_spaceisgem3:
 94+  B788 1E 00            ld e,0                          ; nothing found, return e = 0
 95+  B78A C9               ret
 96+  B78B
 97+  B78B              ;
 98+  B78B              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
 99+  B78B              ; Inputs:
100+  B78B              ; hl - memory location of top pixel row
101+  B78B              ; bc - screen coords, b horiz, c vert
102+  B78B              ; Outputs:
103+  B78B              ; e - 0 if not empty, 1 if empty
104+  B78B              ;
105+  B78B              movement_linebelowisempty:
106+  B78B C5               push bc
107+  B78C E5               push hl
108+  B78D CD 3B B7         call movement_spaceisgem        ; check if space is a gem
109+  B790 E1               pop hl
110+  B791 C1               pop bc
111+  B792 7B               ld a,e
112+  B793 FE 01            cp 1
113+  B795 C8               ret z                           ; if e is 1, space is a gem so can move here, return
114+  B796 7E               ld a,(hl)                       ; get current pixel row
115+  B797 FE 00            cp 0
116+  B799 C2 A1 B7         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
117+  B79C 16 00            ld d,0
118+  B79E 1E 01            ld e,1                          ; got to end, so space is empty
119+  B7A0 C9               ret
120+  B7A1              movement_linebelowisempty1:
121+  B7A1 16 00            ld d,0
122+  B7A3 1E 00            ld e,0                          ; returning false, ie space not empty
123+  B7A5 C9               ret
124+  B7A6
125+  B7A6              ;
126+  B7A6              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
127+  B7A6              ; Inputs:
128+  B7A6              ; hl - memory location of top pixel row
129+  B7A6              ; bc - screen coords, b horiz, c vert
130+  B7A6              ; Outputs:
131+  B7A6              ; e - 0 if not empty, 1 if empty
132+  B7A6              ;
133+  B7A6              movement_lineaboveisempty:
134+  B7A6 C5               push bc
135+  B7A7 E5               push hl
136+  B7A8 CD 3B B7         call movement_spaceisgem        ; check if space is a gem
137+  B7AB E1               pop hl
138+  B7AC C1               pop bc
139+  B7AD 7B               ld a,e
140+  B7AE FE 01            cp 1
141+  B7B0 C8               ret z
142+  B7B1 7E               ld a,(hl)                       ; get current pixel row
143+  B7B2 FE 00            cp 0
144+  B7B4 C2 BC B7         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
145+  B7B7 16 00            ld d,0
146+  B7B9 1E 01            ld e,1                          ; got to end, so space is empty
147+  B7BB C9               ret
148+  B7BC              movement_lineaboveisempty1:
149+  B7BC 16 00            ld d,0
150+  B7BE 1E 00            ld e,0                          ; returning false, ie space not empty
151+  B7C0 C9               ret
152+  B7C1
153+  B7C1              ;
154+  B7C1              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
155+  B7C1              ; Inputs:
156+  B7C1              ; hl - memory location of top pixel row
157+  B7C1              ; bc - screen coords, b horiz, c vert
158+  B7C1              ; Outputs:
159+  B7C1              ; none - puts player into digging mode
160+  B7C1              ;
161+  B7C1              movement_spaceisdiggable:
162+  B7C1 3E 08            ld a,8                          ; 8 rows to check
163+  B7C3              movement_spaceisdiggable0:
164+  B7C3 08               ex af,af'                       ; store the loop counter
165+  B7C4 7E               ld a,(hl)                       ; get current pixel row
166+  B7C5 FE 00            cp 0
167+  B7C7 CA D7 B7         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
168+  B7CA FE 55            cp 85
169+  B7CC CA D7 B7         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
170+  B7CF FE AA            cp 170
171+  B7D1 CA D7 B7         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
172+  B7D4 C3 EF B7         jp movement_spaceisdiggable1     ; otherwise, stop checking
173+  B7D7              movement_spaceisdiggable2:
174+  B7D7 79               ld a,c                          ; load the vertical coord
175+  B7D8 3C               inc a                           ; next row down
176+  B7D9 11 20 00         ld de,32
177+  B7DC 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
178+  B7DD 4F               ld c,a                          ; copy vert coord back to c
179+  B7DE 08               ex af,af'                       ; get loop counter back
180+  B7DF 3D               dec a                           ; decrease loop counter
181+  B7E0 C2 C3 B7         jp nz, movement_spaceisdiggable0
182+  B7E3 21 66 B9         ld hl,player+6
183+  B7E6 36 01            ld (hl),1                       ; set the player into digging mode
184+  B7E8 23               inc hl
185+  B7E9 36 05            ld (hl),5                      ; set the number of frame to dig for
186+  B7EB 23               inc hl
187+  B7EC 36 08            ld (hl),8                       ; set the number of pixels to dig
188+  B7EE C9               ret
189+  B7EF              movement_spaceisdiggable1:
190+  B7EF 21 66 B9         ld hl,player+6
191+  B7F2 36 00            ld (hl),0                       ; set the player out of digging mode
192+  B7F4 C9               ret
193+  B7F5
194+  B7F5              ;
195+  B7F5              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
196+  B7F5              ; Inputs:
197+  B7F5              ; hl - memory location of top pixel row
198+  B7F5              ; bc - screen coords, b horiz, c vert
199+  B7F5              ; Outputs:
200+  B7F5              ; none - puts player into digging mode
201+  B7F5              ;
202+  B7F5              movement_spacebelowisdiggable:
203+  B7F5 7E               ld a,(hl)                       ; get first pixel row
204+  B7F6 FE 55            cp 85
205+  B7F8 CA 03 B8         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
206+  B7FB FE AA            cp 170
207+  B7FD CA 03 B8         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
208+  B800 C3 EF B7         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
209+  B803              movement_spacebelowisdiggable3:
210+  B803 3E 08            ld a,8                          ; rows to check
211+  B805 1E 00            ld e,0                          ; count of rows to dig
212+  B807              movement_spacebelowisdiggable0:
213+  B807 08               ex af,af'                       ; store the loop counter
214+  B808 7E               ld a,(hl)                       ; get current pixel row
215+  B809 FE 55            cp 85
216+  B80B CA 16 B8         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
217+  B80E FE AA            cp 170
218+  B810 CA 16 B8         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
219+  B813 C3 25 B8         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
220+  B816              movement_spacebelowisdiggable4:
221+  B816 1C               inc e                           ; inc count of rows to dig
222+  B817              movement_spacebelowisdiggable2:
223+  B817 79               ld a,c                          ; load the vertical coord
224+  B818 3C               inc a                           ; next row down
225+  B819 D5               push de                         ; need e for later
226+  B81A 11 20 00         ld de,32
227+  B81D 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
228+  B81E 4F               ld c,a                          ; copy vert coord back to c
229+  B81F D1               pop de                          ; get e back
230+  B820 08               ex af,af'                       ; get loop counter back
231+  B821 3D               dec a                           ; incease loop counter
232+  B822 C2 07 B8         jp nz, movement_spacebelowisdiggable0
233+  B825              movement_spacebelowisdiggable5:
234+  B825 21 66 B9         ld hl,player+6
235+  B828 36 01            ld (hl),1                       ; set the player into digging mode
236+  B82A 23               inc hl
237+  B82B 36 03            ld (hl),3                      ; set the number of frame to dig for
238+  B82D 23               inc hl
239+  B82E 73               ld (hl),e                       ; set the number of pixels to dig
240+  B82F C9               ret
241+  B830              movement_spacebelowisdiggable1:
242+  B830 21 66 B9         ld hl,player+6
243+  B833 36 00            ld (hl),0                       ; set the player out of digging mode
244+  B835 C9               ret
245+  B836
246+  B836              ;
247+  B836              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
248+  B836              ; Inputs:
249+  B836              ; hl - memory location of top pixel row
250+  B836              ; bc - screen coords, b horiz, c vert
251+  B836              ; Outputs:
252+  B836              ; none - puts player into digging mode
253+  B836              ;
254+  B836              movement_spaceaboveisdiggable:
255+  B836 7E               ld a,(hl)                       ; get first pixel row
256+  B837 FE 55            cp 85
257+  B839 CA 44 B8         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
258+  B83C FE AA            cp 170
259+  B83E CA 44 B8         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
260+  B841 C3 EF B7         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
261+  B844              movement_spaceaboveisdiggable3:
262+  B844 3E 08            ld a,8                          ; rows to check
263+  B846 1E 00            ld e,0                          ; count of rows to dig
264+  B848              movement_spaceaboveisdiggable0:
265+  B848 08               ex af,af'                       ; store the loop counter
266+  B849 7E               ld a,(hl)                       ; get current pixel row
267+  B84A FE 55            cp 85
268+  B84C CA 57 B8         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
269+  B84F FE AA            cp 170
270+  B851 CA 57 B8         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
271+  B854 C3 67 B8         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
272+  B857              movement_spaceaboveisdiggable4:
273+  B857 1C               inc e                           ; inc count of rows to dig
274+  B858              movement_spaceaboveisdiggable2:
275+  B858 79               ld a,c                          ; load the vertical coord
276+  B859 3D               dec a                           ; next row up
277+  B85A D5               push de                         ; need e for later
278+  B85B 11 20 00         ld de,32
279+  B85E ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
280+  B860 4F               ld c,a                          ; copy vert coord back to c
281+  B861 D1               pop de                          ; get e back
282+  B862 08               ex af,af'                       ; get loop counter back
283+  B863 3D               dec a                           ; incease loop counter
284+  B864 C2 48 B8         jp nz, movement_spaceaboveisdiggable0
285+  B867              movement_spaceaboveisdiggable5:
286+  B867 21 66 B9         ld hl,player+6
287+  B86A 36 01            ld (hl),1                       ; set the player into digging mode
288+  B86C 23               inc hl
289+  B86D 36 05            ld (hl),5                       ; set the number of frame to dig for
290+  B86F 23               inc hl
291+  B870 73               ld (hl),e                       ; set the number of pixels to dig
292+  B871 C9               ret
293+  B872              movement_spaceaboveisdiggable1:
294+  B872 21 66 B9         ld hl,player+6
295+  B875 36 00            ld (hl),0                       ; set the player out of digging mode
296+  B877 C9               ret
297+  B878
298+  B878              ;
299+  B878              ; Checks if the player can move down
300+  B878              ; Inputs:
301+  B878              ; bc - player coords, b horiz, c vert
302+  B878              ; Outputs:
303+  B878              ; de - 1 can move
304+  B878              movement_checkcanmove_down:
305+  B878 F5               push af
306+  B879 C5               push bc
307+  B87A CD 31 A9         call sprites_scadd              ; get the memory location of cell into de
308+  B87D 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
309+  B87F 24               inc h                       ; memory location of cell beneath now in hl
310+  B880 3E 08            ld a,8                       ; look below
311+  B882 81               add c
312+  B883 4F               ld c,a
313+  B884 CD 8B B7         call movement_linebelowisempty       ; check space is empty
314+  B887 7B               ld a,e                          ; check space empty flag
315+  B888 FE 00            cp 0
316+  B88A CA 93 B8         jp z, movement_checkcanmove_down1 ; can't move
317+  B88D CD EA BA         call player_justmoved
318+  B890 C1               pop bc
319+  B891 F1               pop af
320+  B892 C9               ret
321+  B893              movement_checkcanmove_down1:
322+  B893 C1               pop bc
323+  B894 CD 31 A9         call sprites_scadd              ; get the memory location of cell into de
324+  B897 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
325+  B899 24               inc h
326+  B89A C5               push bc
327+  B89B CD F5 B7         call movement_spacebelowisdiggable    ; can't move here, but can we dig
328+  B89E 11 00 00         ld de,0
329+  B8A1 C1               pop bc
330+  B8A2 F1               pop af
331+  B8A3 C9               ret
332+  B8A4
333+  B8A4              ;
334+  B8A4              ; Checks if the player can move up
335+  B8A4              ; Inputs:
336+  B8A4              ; bc - player coords, b horiz, c vert
337+  B8A4              ; Outputs:
338+  B8A4              ; de - 1 can move
339+  B8A4              movement_checkcanmove_up:
340+  B8A4 F5               push af
341+  B8A5 C5               push bc
342+  B8A6 CD 31 A9         call sprites_scadd              ; get the memory location of cell into de
343+  B8A9 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
344+  B8AB 11 20 00         ld de,32
345+  B8AE ED 52            sbc hl,de                       ; memory location of line above now in hl
346+  B8B0 0D               dec c                           ; look above
347+  B8B1 CD A6 B7         call movement_lineaboveisempty       ; check space is empty
348+  B8B4 7B               ld a,e                          ; check space empty flag
349+  B8B5 FE 00            cp 0
350+  B8B7 CA C2 B8         jp z, movement_checkcanmove_up1 ; can't move
351+  B8BA 1E 01            ld e,1
352+  B8BC CD EA BA         call player_justmoved
353+  B8BF C1               pop bc
354+  B8C0 F1               pop af
355+  B8C1 C9               ret
356+  B8C2              movement_checkcanmove_up1:
357+  B8C2 C1               pop bc
358+  B8C3 CD 31 A9         call sprites_scadd              ; get the memory location of cell into de
359+  B8C6 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
360+  B8C8 11 20 00         ld de,32
361+  B8CB ED 52            sbc hl,de                       ; memory location of line above now in hl
362+  B8CD C5               push bc
363+  B8CE CD 36 B8         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
364+  B8D1 11 00 00         ld de,0
365+  B8D4 C1               pop bc
366+  B8D5 F1               pop af
367+  B8D6 C9               ret
368+  B8D7
369+  B8D7              ;
370+  B8D7              ; Checks if the player can move right
371+  B8D7              ; Inputs:
372+  B8D7              ; bc - player coords, b horiz, c vert
373+  B8D7              ; Outputs:
374+  B8D7              ; de - 1 can move
375+  B8D7              movement_checkcanmove_right:
376+  B8D7 F5               push af
377+  B8D8 C5               push bc
378+  B8D9 CD 31 A9         call sprites_scadd              ; get the memory location of cell into de
379+  B8DC 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
380+  B8DE 3E 08            ld a,8
381+  B8E0 80               add b                           ; move one cell right
382+  B8E1 47               ld b,a
383+  B8E2 23               inc hl                          ; memory location of cell to the right now in hl
384+  B8E3 CD 11 B7         call movement_spaceisempty       ; check space is empty
385+  B8E6 7B               ld a,e                          ; check space empty flag
386+  B8E7 FE 00            cp 0
387+  B8E9 CA F2 B8         jp z, movement_checkcanmove_right1 ; can't move
388+  B8EC CD EA BA         call player_justmoved
389+  B8EF C1               pop bc
390+  B8F0 F1               pop af
391+  B8F1 C9               ret
392+  B8F2              movement_checkcanmove_right1:
393+  B8F2 C1               pop bc
394+  B8F3 CD 31 A9         call sprites_scadd              ; get the memory location of cell into de
395+  B8F6 62 6B            ld hl,de
396+  B8F8 23               inc hl                          ; memory location of cell to the right now in hl
397+  B8F9 C5               push bc
398+  B8FA CD C1 B7         call movement_spaceisdiggable    ; can't move here, but can we dig
399+  B8FD 11 00 00         ld de,0
400+  B900 C1               pop bc
401+  B901 F1               pop af
402+  B902 C9               ret
403+  B903
404+  B903              ;
405+  B903              ; Checks if the player can move left
406+  B903              ; Inputs:
407+  B903              ; bc - player coords, b horiz, c vert
408+  B903              ; Outputs:
409+  B903              ; de - 1 can move
410+  B903              movement_checkcanmove_left:
411+  B903 F5               push af
412+  B904 C5               push bc
413+  B905 CD 31 A9         call sprites_scadd              ; get the memory location of cell into de
414+  B908 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
415+  B90A 78               ld a,b
416+  B90B 06 08            ld b,8
417+  B90D 90               sub b                           ; move one cell left
418+  B90E 47               ld b,a
419+  B90F 2B               dec hl                          ; memory location of cell to the right now in hl
420+  B910 CD 11 B7         call movement_spaceisempty       ; check space is empty
421+  B913 7B               ld a,e                          ; check space empty flag
422+  B914 FE 00            cp 0
423+  B916 CA 1F B9         jp z, movement_checkcanmove_left1 ; can't move
424+  B919 CD EA BA         call player_justmoved
425+  B91C C1               pop bc
426+  B91D F1               pop af
427+  B91E C9               ret
428+  B91F              movement_checkcanmove_left1:
429+  B91F C1               pop bc
430+  B920 CD 31 A9         call sprites_scadd              ; get the memory location of cell into de
431+  B923 62 6B            ld hl,de
432+  B925 2B               dec hl                          ; memory location of cell to the right now in hl
433+  B926 C5               push bc
434+  B927 CD C1 B7         call movement_spaceisdiggable    ; can't move here, but can we dig
435+  B92A 11 00 00         ld de,0
436+  B92D C1               pop bc
437+  B92E F1               pop af
438+  B92F C9               ret
# file closed: game/movement.asm
 38   B930                  include "game\game.asm"
# file opened: game/game.asm
  1+  B930              ;
  2+  B930              ; The current frame count, incremented each frame
  3+  B930              ;
  4+  B930              game_framenumber:
  5+  B930 00               defb    0
  6+  B931
  7+  B931              ;
  8+  B931              ; The number of players
  9+  B931              ;
 10+  B931              game_numberplayers:
 11+  B931 01               defb 1
 12+  B932
 13+  B932              ;
 14+  B932              ; The current player
 15+  B932              ;
 16+  B932              game_currentplayer:
 17+  B932 01               defb 1
 18+  B933
 19+  B933              ;
 20+  B933              ; The default number of lives
 21+  B933              ;
 22+  B933              game_numberlives:
 23+  B933 04               defb 4
 24+  B934
 25+  B934              ;
 26+  B934              ; Moves to the next player
 27+  B934              ;
 28+  B934              game_changeplayer:
 29+  B934 3A 32 B9         ld a,(game_currentplayer)
 30+  B937 FE 01            cp 1
 31+  B939 C8               ret z                       ; if just one player, no need to change
 32+  B93A 3D               dec a                       ; otherwise decrease by one
 33+  B93B EE 01            xor 1                       ; xor with one to flip
 34+  B93D 3C               inc a                       ; increment
 35+  B93E 21 32 B9         ld hl,game_currentplayer
 36+  B941 77               ld (hl),a                   ; store
 37+  B942 C9               ret
 38+  B943
 39+  B943              ;
 40+  B943              ; Sets the number of players at the start of the game
 41+  B943              ; Inputs:
 42+  B943              ; a - number of players
 43+  B943              game_setnumberofplayers:
 44+  B943 21 31 B9         ld hl,game_numberplayers
 45+  B946 77               ld (hl),a
 46+  B947
 47+  B947              ;
 48+  B947              ; Increment frame number by 1
 49+  B947              ;
 50+  B947              game_incrementframe:
 51+  B947 3A 30 B9         ld a,(game_framenumber)
 52+  B94A FE FF            cp 255
 53+  B94C C2 51 B9         jp nz,game_incrementframe0
 54+  B94F 3E 00            ld a,0
 55+  B951              game_incrementframe0:
 56+  B951 3C               inc a
 57+  B952 32 30 B9         ld (game_framenumber),a
 58+  B955 C9               ret
 59+  B956
 60+  B956              ;
 61+  B956              ; Returns current frame
 62+  B956              ; Outputs:
 63+  B956              ; a - current frame
 64+  B956              ;
 65+  B956              game_getcurrentframe:
 66+  B956 3A 30 B9         ld a,(game_framenumber)
 67+  B959 C9               ret
 68+  B95A
 69+  B95A              ;
 70+  B95A              ; Resets current frame
 71+  B95A              ;
 72+  B95A              game_resetcurrentframe:
 73+  B95A 21 30 B9         ld hl,game_framenumber
 74+  B95D 36 00            ld (hl),0
 75+  B95F C9               ret
# file closed: game/game.asm
 39   B960                  include "game\player.asm"
# file opened: game/player.asm
  1+  B960              ;
  2+  B960              ;   Data for current player
  3+  B960              ;
  4+  B960              player:
  5+  B960 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  B962 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  B965 00               defb    0                   ; auto move remaining (+5)
  8+  B966 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  B969 00               defb    0                   ; lives remaining (+9)
 10+  B96A 00               defb    0                   ; died this life (+10)
 11+  B96B 00 00            defb    0,0                 ; crushed (+11), frames (+12)
 12+  B96D 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  B96E
 14+  B96E              player_location:
 15+  B96E 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 16+  B96F
 17+  B96F              ;
 18+  B96F              ; Works out which part of the screen the player is in
 19+  B96F              ; Pit is between 3,9 and 8,9
 20+  B96F              ; Diamond cavern is between 11,22 and 22,28
 21+  B96F              ;
 22+  B96F              player_getlocation:
 23+  B96F ED 4B 60 B9      ld bc,(player)              ; get screen coords
 24+  B973 CD 53 A8         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 25+  B976 78               ld a,b                      ; check for pit first
 26+  B977 FE 09            cp 9                        ; if not on this row, not in the pit
 27+  B979 C2 88 B9         jp nz,player_getlocation0
 28+  B97C 79               ld a,c                      ; check horizontal
 29+  B97D FE 08            cp 8
 30+  B97F D2 88 B9         jp nc, player_getlocation0  ; if more than 8, not in the pit
 31+  B982 21 6E B9         ld hl,player_location
 32+  B985 36 02            ld (hl),2                   ; load location with 2, the pit
 33+  B987 C9               ret                         ; done
 34+  B988              player_getlocation0:            ; check for diamond cavern
 35+  B988 78               ld a,b                      ; first check vertical
 36+  B989 FE 16            cp 22                       ; if above row 22, then not in cavern
 37+  B98B DA 9F B9         jp c,player_getlocation1
 38+  B98E 79               ld a,c                      ; get the horizontal next
 39+  B98F FE 0B            cp 11
 40+  B991 DA 9F B9         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 41+  B994 FE 16            cp 22
 42+  B996 D2 9F B9         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 43+  B999 21 6E B9         ld hl,player_location
 44+  B99C 36 01            ld (hl),1                   ; load location with 1, the cavern
 45+  B99E C9               ret
 46+  B99F              player_getlocation1:
 47+  B99F 21 6E B9         ld hl,player_location
 48+  B9A2 36 00            ld (hl),0                   ; load location with 2, the pit
 49+  B9A4 C9               ret                         ; done
 50+  B9A5
 51+  B9A5
 52+  B9A5              ;
 53+  B9A5              ; Initializes a player at start of game
 54+  B9A5              ; Copy initial coords, copy lives, copy score
 55+  B9A5              ;
 56+  B9A5              player_init_gamestart:
 57+  B9A5 3A 33 B9         ld a,(game_numberlives)
 58+  B9A8 32 34 BA         ld (player1_lives),a
 59+  B9AB 32 35 BA         ld (player2_lives),a                        ; set the initial number of lives at game start
 60+  B9AE
 61+  B9AE 21 38 BA         ld hl,player1_score+2
 62+  B9B1 06 06            ld b,6
 63+  B9B3              player_init_gamestart0:
 64+  B9B3 36 30            ld (hl),48
 65+  B9B5 23               inc hl
 66+  B9B6 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 67+  B9B8 21 41 BA         ld hl,player2_score+2
 68+  B9BB 06 06            ld b,6
 69+  B9BD              player_init_gamestart1:
 70+  B9BD 36 30            ld (hl),48
 71+  B9BF 23               inc hl
 72+  B9C0 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 73+  B9C2 C9               ret
 74+  B9C3
 75+  B9C3              ;
 76+  B9C3              ; Initializes a player at start of a life
 77+  B9C3              ; Copy initial coords, copy lives, copy score
 78+  B9C3              ;
 79+  B9C3              player_init_lifestart:
 80+  B9C3 21 65 B9         ld hl,player+5
 81+  B9C6 06 09            ld b,9                      ; initialise 9 properties
 82+  B9C8              player_init_lifestart2:
 83+  B9C8 36 00            ld (hl),0
 84+  B9CA 23               inc hl
 85+  B9CB 10 FB            djnz player_init_lifestart2
 86+  B9CD
 87+  B9CD 21 62 B9         ld hl,player+2              ; initialise some properties
 88+  B9D0 36 02            ld (hl),2
 89+  B9D2 23               inc hl
 90+  B9D3 36 00            ld (hl),0
 91+  B9D5 23               inc hl
 92+  B9D6 36 01            ld (hl),1
 93+  B9D8
 94+  B9D8 ED 4B 22 80      ld bc,(init_coord)
 95+  B9DC ED 43 60 B9      ld (player),bc
 96+  B9E0 01 69 B9         ld bc,player+9
 97+  B9E3 3A 34 BA         ld a,(player1_lives)
 98+  B9E6 02               ld (bc),a
 99+  B9E7
100+  B9E7 CD B3 C1         call diamonds_init      ; initialise gems
101+  B9EA
102+  B9EA 01 06 00         ld bc,6
103+  B9ED 11 F6 BF         ld de,scores_current+2
104+  B9F0 3A 32 B9         ld a,(game_currentplayer)
105+  B9F3 FE 01            cp 1
106+  B9F5 C2 FE B9         jp nz,player_init_lifestart0
107+  B9F8 21 38 BA         ld hl,player1_score+2
108+  B9FB C3 01 BA         jp player_init_lifestart1
109+  B9FE              player_init_lifestart0:
110+  B9FE 21 41 BA         ld hl,player2_score+2
111+  BA01              player_init_lifestart1:
112+  BA01 ED B0            ldir
113+  BA03 C9               ret
114+  BA04
115+  BA04              ;
116+  BA04              ; Finalises a player at end of a life
117+  BA04              ; Copy lives, copy score
118+  BA04              ;
119+  BA04              player_lifeend:
120+  BA04 01 69 B9         ld bc,player+9
121+  BA07 0A               ld a,(bc)
122+  BA08 01 34 BA         ld bc,player1_lives
123+  BA0B 02               ld (bc),a
124+  BA0C CD 10 BA         call player_recordcurrentscore
125+  BA0F C9               ret
126+  BA10
127+  BA10              ;
128+  BA10              ; Copies the current score in the current
129+  BA10              ;
130+  BA10              player_recordcurrentscore:
131+  BA10 01 06 00         ld bc,6                  ; copy current score back to correct player
132+  BA13 21 F6 BF         ld hl,scores_current+2
133+  BA16 3A 32 B9         ld a,(game_currentplayer)
134+  BA19 FE 01            cp 1
135+  BA1B C2 24 BA         jp nz,player_lifeend0
136+  BA1E 11 38 BA         ld de,player1_score+2
137+  BA21 C3 27 BA         jp player_lifeend1
138+  BA24              player_lifeend0:
139+  BA24 11 41 BA         ld de,player2_score+2
140+  BA27              player_lifeend1:
141+  BA27 ED B0            ldir
142+  BA29 C9               ret
143+  BA2A
144+  BA2A              ;
145+  BA2A              ; Player just died, subtract a life
146+  BA2A              ;
147+  BA2A              player_died:
148+  BA2A 01 69 B9         ld bc,player+9
149+  BA2D 0A               ld a,(bc)
150+  BA2E 3D               dec a
151+  BA2F 02               ld (bc),a
152+  BA30 CD 04 BA         call player_lifeend
153+  BA33 C9               ret
154+  BA34
155+  BA34              ;
156+  BA34              ; Player lives
157+  BA34              ;
158+  BA34              player1_lives:
159+  BA34 03               defb 3
160+  BA35              player2_lives:
161+  BA35 03               defb 3
162+  BA36
163+  BA36              ;
164+  BA36              ; Player scores
165+  BA36              ;
166+  BA36              player1_score:
167+  BA36 04 01 30 30      defb 4,1,'000000',255
167+  BA3A 30 30 30 30
167+  BA3E FF
168+  BA3F              player2_score:
169+  BA3F 16 01 30 30      defb 22,1,'000000',255
169+  BA43 30 30 30 30
169+  BA47 FF
170+  BA48
171+  BA48              ;
172+  BA48              ; Kills a player this life
173+  BA48              ;
174+  BA48              player_killplayer:
175+  BA48 21 6A B9         ld hl,player+10
176+  BA4B 36 01            ld (hl),1
177+  BA4D C9               ret
178+  BA4E
179+  BA4E              ;
180+  BA4E              ; Crush a player this life
181+  BA4E              ;
182+  BA4E              player_crushplayer:
183+  BA4E 21 6B B9         ld hl,player+11             ; mark as crushed
184+  BA51 36 01            ld (hl),1
185+  BA53 C9               ret
186+  BA54
187+  BA54              player_tankkillplayer
188+  BA54 21 6B B9         ld hl,player+11             ; mark as tanked
189+  BA57 36 02            ld (hl),2
190+  BA59 C9               ret
191+  BA5A
192+  BA5A              player_zonkplayer
193+  BA5A 21 6B B9         ld hl,player+11             ; mark as zonked (missile)
194+  BA5D 36 03            ld (hl),3
195+  BA5F C9               ret
196+  BA60
197+  BA60              ;
198+  BA60              ; Draws the player at the current position or deletes them
199+  BA60              ;
200+  BA60              player_drawplayer:
201+  BA60 3A 62 B9         ld a,(player+2)             ; get the current direction
202+  BA63 FE 03            cp 3
203+  BA65 C2 6A BA         jp nz,player_drawplayer0
204+  BA68 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
205+  BA6A              player_drawplayer0:
206+  BA6A 5F               ld e,a                      ; store in e
207+  BA6B 3A 6B B9         ld a,(player+11)             ; get the dying flag
208+  BA6E FE 01            cp 1
209+  BA70 CA 82 BA         jp z,player_drawplayer3     ; if it's one, we're being crushed
210+  BA73              player_drawplayer4:
211+  BA73 3A 66 B9         ld a,(player+6)             ; get the dig flag
212+  BA76 FE 01            cp 1
213+  BA78 CA D0 BA         jp z,player_drawplayer1    ; get dig frame
214+  BA7B 3A 63 B9         ld a,(player+3)             ; this is normal movement so get the current frame
215+  BA7E 83               add a,e
216+  BA7F C3 D5 BA         jp player_drawplayer2
217+  BA82              player_drawplayer3:
218+  BA82 21 6C B9         ld hl,player+12
219+  BA85 7E               ld a,(hl)                  ; crushing, so get the current anim flag
220+  BA86 FE 00            cp 0
221+  BA88 C2 91 BA         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
222+  BA8B 3E 64            ld a,100
223+  BA8D 77               ld (hl),a                   ; otherwise, load up the anim frames
224+  BA8E C3 73 BA         jp player_drawplayer4       ; and return to the main loop to remove the current frame
225+  BA91              player_drawplayer5:
226+  BA91 3D               dec a
227+  BA92 77               ld (hl),a
228+  BA93 FE 00            cp 0
229+  BA95 CC 48 BA         call z,player_killplayer     ; final animation, so kill the player
230+  BA98 FE 0A            cp 10                         ; play the sound
231+  BA9A CC 1C AD         call z, sound_rockfell
232+  BA9D FE 14            cp 20                        ; check if we should move the rock
233+  BA9F C2 B3 BA         jp nz,player_drawplayer8
234+  BAA2 D9               exx
235+  BAA3 08               ex af,af'
236+  BAA4 ED 4B 84 BE      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
237+  BAA8 21 33 B3         ld hl,sprites+72
238+  BAAB CD EE A8         call sprites_drawsprite     ; draw a rock over current
239+  BAAE 08               ex af,af'
240+  BAAF D9               exx
241+  BAB0 C3 C9 BA         jp player_drawplayer6       ; continue drawing player
242+  BAB3              player_drawplayer8:
243+  BAB3 FE 14            cp 20
244+  BAB5 D2 C9 BA         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
245+  BAB8 ED 4B 60 B9      ld bc,(player)
246+  BABC CD 40 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
247+  BABF 62 6B            ld hl,de
248+  BAC1 36 42            ld (hl),66
249+  BAC3 21 33 B3         ld hl,sprites+72            ; otherwise, player is rock
250+  BAC6 C3 DF BA         jp player_drawplayer7
251+  BAC9              player_drawplayer6:
252+  BAC9 E6 01            and 1                       ; check for odd
253+  BACB C6 0A            add 10                      ; add 10, to get either 10 or 11
254+  BACD C3 D5 BA         jp player_drawplayer2
255+  BAD0              player_drawplayer1:
256+  BAD0 3A 62 B9         ld a,(player+2)             ; digging, get the current direction again, because want all four
257+  BAD3 C6 06            add a,6                     ; add direction to 6 to get frame
258+  BAD5              player_drawplayer2:
259+  BAD5 07               rlca
260+  BAD6 07               rlca
261+  BAD7 07               rlca                        ; multiply by eight
262+  BAD8 6F               ld l,a
263+  BAD9 26 00            ld h,0
264+  BADB 11 D5 B3         ld de,player_sprite
265+  BADE 19               add hl,de                   ; load hl with the location of the player sprite data
266+  BADF              player_drawplayer7:
267+  BADF ED 4B 60 B9      ld bc,(player)              ; load bc with the start coords
268+  BAE3 CD EE A8         call sprites_drawsprite     ; call the routine to draw the sprite
269+  BAE6 CD 16 BB         call player_storeupdatedlines ; log updated rows
270+  BAE9 C9               ret
271+  BAEA
272+  BAEA
273+  BAEA              ;
274+  BAEA              ; Runs after the player just moved. Changes animation frame if required
275+  BAEA              ;
276+  BAEA              player_justmoved:
277+  BAEA D9               exx
278+  BAEB 3A 64 B9         ld a,(player+4)             ; get the transition count
279+  BAEE FE 00            cp 0
280+  BAF0 CA F6 BA         jp z, player_justmoved2     ; if zero reset and change the frame
281+  BAF3 C3 10 BB         jp player_justmoved1       ; otherwise decrease and continue
282+  BAF6              player_justmoved2:
283+  BAF6                  ; reset and change frame in here
284+  BAF6 3E 01            ld a,1
285+  BAF8 32 64 B9         ld (player+4),a            ; reset back to whatever
286+  BAFB 3A 63 B9         ld a,(player+3)             ; load the frame
287+  BAFE FE 03            cp 3                       ; flip between 3 and 0
288+  BB00 C2 08 BB         jp nz, player_justmoved4
289+  BB03 3E 00            ld a,0
290+  BB05 C3 0A BB         jp player_justmoved5
291+  BB08              player_justmoved4:
292+  BB08 3E 03            ld a,3
293+  BB0A              player_justmoved5:
294+  BB0A 32 63 B9         ld (player+3),a           ; save back
295+  BB0D C3 14 BB         jp player_justmoved3
296+  BB10              player_justmoved1:
297+  BB10                  ; decrease count
298+  BB10 3D               dec a
299+  BB11 32 64 B9         ld (player+4),a
300+  BB14              player_justmoved3:
301+  BB14 D9               exx;
302+  BB15 C9               ret
303+  BB16
304+  BB16              ;
305+  BB16              ; Stores the updated rows associated with the player
306+  BB16              ;
307+  BB16              player_storeupdatedlines:
308+  BB16 ED 4B 60 B9      ld bc,(player)          ; get the screen coords into bc
309+  BB1A 79               ld a,c                  ; get the player block coords of current block
310+  BB1B E6 F8            and 248                 ; find closest multiple of eight
311+  BB1D 0F               rrca
312+  BB1E 0F               rrca
313+  BB1F 0F               rrca                    ; divide by 8
314+  BB20 ED 5B 15 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
315+  BB24 93               sub e
316+  BB25 F5               push af
317+  BB26 CD C5 A5         call buffer_marklineforupdate  ; store current row in updated lines
318+  BB29 F1               pop af
319+  BB2A 3D               dec a
320+  BB2B F5               push af
321+  BB2C CD C5 A5         call buffer_marklineforupdate  ; store line above
322+  BB2F F1               pop af
323+  BB30 3C               inc a
324+  BB31 3C               inc a
325+  BB32 CD C5 A5         call buffer_marklineforupdate  ; store line beneath
326+  BB35 C9               ret
327+  BB36
328+  BB36              ;
329+  BB36              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
330+  BB36              ; Outputs:
331+  BB36              ; a - 1 for completed level
332+  BB36              player_checkforexit:
333+  BB36 ED 4B 60 B9      ld bc,(player)                 ; get player coords
334+  BB3A ED 5B 22 80      ld de,(init_coord)             ; get start coords
335+  BB3E 78               ld a,b
336+  BB3F BA               cp d                         ; compare horiz
337+  BB40 C2 4B BB         jp nz,player_checkforexit1
338+  BB43 79               ld a,c
339+  BB44 BB               cp e                        ; compare vert
340+  BB45 C2 4B BB         jp nz,player_checkforexit1
341+  BB48              player_checkforexit0:
342+  BB48 3E 01            ld a,1                       ; hasn't completed
343+  BB4A C9               ret
344+  BB4B              player_checkforexit1:
345+  BB4B 3E 00            ld a,0                       ; has completed
346+  BB4D C9               ret
# file closed: game/player.asm
 40   BB4E                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  BB4E              ;
  2+  BB4E              ; Ship initial position: vert,horiz
  3+  BB4E              ;
  4+  BB4E              ship_initpos:
  5+  BB4E 00 24            defb 0,36
  6+  BB50              ship_initpos2:
  7+  BB50 00 00            defb 0,0
  8+  BB52              ship_frame:
  9+  BB52 00               defb 0
 10+  BB53              ;
 11+  BB53              ; The current memory location
 12+  BB53              ;
 13+  BB53              ship_current_sprite:
 14+  BB53 00 00            defb 0,0
 15+  BB55
 16+  BB55              ship_current_coords:
 17+  BB55 00 00            defb 0,0
 18+  BB57
 19+  BB57              ship_process:
 20+  BB57 3A 6B B9         ld a,(player+11)
 21+  BB5A FE 02            cp 2                        ; has the player been killed by tank?
 22+  BB5C C0               ret nz                      ; do nothing if not
 23+  BB5D CD 04 B7         call control_scroll_up           ; make sure the screen is on the top screen
 24+  BB60 CD CF BB         call ship_takeoff           ; bye bye
 25+  BB63 CD 48 BA         call player_killplayer      ; killed
 26+  BB66 06 32            ld b,50
 27+  BB68 CD 82 80         call utilities_pauseforframes
 28+  BB6B C9               ret
 29+  BB6C
 30+  BB6C              ;
 31+  BB6C              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  BB6C              ;
 33+  BB6C              ship_land:
 34+  BB6C ED 4B 4E BB      ld bc,(ship_initpos)
 35+  BB70 ED 43 50 BB      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  BB74 1E 00            ld e,0                      ; store a flag to track first time round
 37+  BB76 06 09            ld b,9                      ; move down 8 pixels
 38+  BB78              ship_land0:
 39+  BB78 C5               push bc
 40+  BB79 7B               ld a,e
 41+  BB7A D5               push de                     ; store de for next time round
 42+  BB7B FE 01            cp 1                        ; check first time flag
 43+  BB7D C2 92 BB         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  BB80 CD 26 BC         call ship_draw_full         ; delete old one
 45+  BB83 CD FB BB         call ship_change_frame      ; increment the frame
 46+  BB86 ED 4B 50 BB      ld bc,(ship_initpos2)       ; get the current coords
 47+  BB8A 81 C6 01         add c,1                     ; move down one pixels
 48+  BB8D 4F               ld c,a
 49+  BB8E ED 43 50 BB      ld (ship_initpos2),bc
 50+  BB92              ship_land1:
 51+  BB92 CD 26 BC         call ship_draw_full         ; draw the ship
 52+  BB95 CD 10 BC         call ship_draw_screen
 53+  BB98 D1               pop de
 54+  BB99 1E 01            ld e,1
 55+  BB9B C1               pop bc
 56+  BB9C 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  BB9E                  ; done moving down
 58+  BB9E                  ; now move across
 59+  BB9E CD 60 BA         call player_drawplayer      ; draw player
 60+  BBA1 CD 26 BC         call ship_draw_full         ; delete old one
 61+  BBA4 1E 00            ld e,0                      ; store a flag to track first time round
 62+  BBA6 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  BBA8              ship_land3:
 64+  BBA8 C5               push bc
 65+  BBA9 7B               ld a,e
 66+  BBAA D5               push de                     ; store de for next time round
 67+  BBAB FE 01            cp 1                        ; check first time flag
 68+  BBAD C2 C2 BB         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  BBB0 CD 26 BC         call ship_draw_full         ; delete old one
 70+  BBB3 CD FB BB         call ship_change_frame      ; increment the frame
 71+  BBB6 ED 4B 50 BB      ld bc,(ship_initpos2)       ; get the current coords
 72+  BBBA 78               ld a,b
 73+  BBBB D6 01            sub 1                       ; move back one pixels
 74+  BBBD 47               ld b,a
 75+  BBBE ED 43 50 BB      ld (ship_initpos2),bc
 76+  BBC2              ship_land2:
 77+  BBC2 CD 26 BC         call ship_draw_full         ; draw the ship
 78+  BBC5 CD 10 BC         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  BBC8 D1               pop de
 80+  BBC9 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  BBCB C1               pop bc
 82+  BBCC 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  BBCE C9               ret
 84+  BBCF
 85+  BBCF              ;
 86+  BBCF              ;   Take off the ship
 87+  BBCF              ;
 88+  BBCF              ship_takeoff:
 89+  BBCF 1E 01            ld e,1                      ; store a flag to track first time round
 90+  BBD1 06 08            ld b,8                      ; move up 8 pixels
 91+  BBD3              ship_takeoff0:
 92+  BBD3 C5               push bc
 93+  BBD4 7B               ld a,e
 94+  BBD5 D5               push de                     ; store de for next time round
 95+  BBD6 FE 01            cp 1                        ; check first time flag
 96+  BBD8 C2 EE BB         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  BBDB ED 4B 50 BB      ld bc,(ship_initpos2)       ; get the current coords
 98+  BBDF CD 26 BC         call ship_draw_full         ; delete old one
 99+  BBE2 CD FB BB         call ship_change_frame      ; increment the frame
100+  BBE5 ED 4B 50 BB      ld bc,(ship_initpos2)       ; get the current coords
101+  BBE9 0D               dec c                       ; move up one pixels
102+  BBEA ED 43 50 BB      ld (ship_initpos2),bc
103+  BBEE              ship_takeoff1:
104+  BBEE CD 26 BC         call ship_draw_full         ; draw the ship
105+  BBF1 CD 10 BC         call ship_draw_screen
106+  BBF4 D1               pop de
107+  BBF5 1E 01            ld e,1
108+  BBF7 C1               pop bc
109+  BBF8 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  BBFA                  ; done moving up
111+  BBFA C9               ret
112+  BBFB
113+  BBFB              ;
114+  BBFB              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  BBFB              ;
116+  BBFB              ship_change_frame:
117+  BBFB F5               push af
118+  BBFC 3A 52 BB         ld a,(ship_frame)
119+  BBFF FE 00            cp 0
120+  BC01 CA 09 BC         jp z,ship_change_frame0
121+  BC04 3E 00            ld a,0                      ; flip to 0
122+  BC06 C3 0B BC         jp ship_change_frame1
123+  BC09              ship_change_frame0:
124+  BC09 3E 20            ld a,32                      ; flip to 32
125+  BC0B              ship_change_frame1:
126+  BC0B 32 52 BB         ld (ship_frame),a            ; save the frame
127+  BC0E F1               pop af
128+  BC0F C9               ret
129+  BC10
130+  BC10              ship_draw_screen:
131+  BC10 3E 00            ld a,0
132+  BC12 CD C5 A5         call buffer_marklineforupdate
133+  BC15 3E 01            ld a,1
134+  BC17 CD C5 A5         call buffer_marklineforupdate
135+  BC1A 3E 02            ld a,2
136+  BC1C CD C5 A5         call buffer_marklineforupdate   ; mark the first three rows for update
137+  BC1F 76               halt
138+  BC20 F3               di
139+  BC21 CD 5C A6         call buffer_buffertoscreen  ; copy buffer to screen
140+  BC24 FB               ei                          ; enable interupts
141+  BC25 C9               ret
142+  BC26
143+  BC26              ship_draw_full:
144+  BC26 21 35 B4         ld hl,ship_sprite
145+  BC29 ED 4B 50 BB      ld bc,(ship_initpos2)         ; load bc with the start coords
146+  BC2D 22 53 BB         ld (ship_current_sprite),hl  ; put into memory
147+  BC30 ED 43 55 BB      ld (ship_current_coords),bc  ; put into memory
148+  BC34 CD 53 BC         call ship_draw
149+  BC37 08               ex af,af'
150+  BC38 3A 52 BB         ld a,(ship_frame)            ; get the animation frame
151+  BC3B 16 00            ld d,0
152+  BC3D 5F               ld e,a
153+  BC3E 19               add hl,de
154+  BC3F 22 53 BB         ld (ship_current_sprite),hl  ; put into memory
155+  BC42 08               ex af,af'
156+  BC43 ED 4B 50 BB      ld bc,(ship_initpos2)         ; load bc with the start coords
157+  BC47 81 C6 08         add c,8                      ; move one line down
158+  BC4A 4F               ld c,a
159+  BC4B ED 43 55 BB      ld (ship_current_coords),bc  ; put into memory
160+  BC4F CD 53 BC         call ship_draw
161+  BC52 C9               ret
162+  BC53
163+  BC53              ;
164+  BC53              ; Draw the ship
165+  BC53              ; Inputs:
166+  BC53              ; None, all in memory
167+  BC53              ;
168+  BC53              ship_draw:
169+  BC53 3E 04            ld a,4                              ; 4 pieces per half
170+  BC55              ship_draw0:
171+  BC55 F5               push af
172+  BC56 2A 53 BB         ld hl,(ship_current_sprite)
173+  BC59 ED 4B 55 BB      ld bc,(ship_current_coords)         ; load bc with the start coords
174+  BC5D CD EE A8         call sprites_drawsprite
175+  BC60 2A 53 BB         ld hl,(ship_current_sprite)
176+  BC63 ED 4B 55 BB      ld bc,(ship_current_coords)         ; load bc with the start coords
177+  BC67 11 08 00         ld de,8
178+  BC6A 19               add hl,de
179+  BC6B 80 C6 08         add b,8
180+  BC6E 47               ld b,a
181+  BC6F 22 53 BB         ld (ship_current_sprite),hl         ; put into memory
182+  BC72 ED 43 55 BB      ld (ship_current_coords),bc         ; put into memory
183+  BC76 F1               pop af
184+  BC77 3D               dec a
185+  BC78 FE 00            cp 0
186+  BC7A C2 55 BC         jp nz,ship_draw0
187+  BC7D
188+  BC7D C9               ret
189+  BC7E
# file closed: game/ship.asm
 41   BC7E                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  BC7E              ;
  2+  BC7E              ; tank initial position: vert,horiz
  3+  BC7E              ;
  4+  BC7E              tank_initpos:
  5+  BC7E 10 D0            defb 16,208
  6+  BC80              tank_initpos2:
  7+  BC80 00 00            defb 0,0
  8+  BC82              tank_frame:
  9+  BC82 00               defb 0
 10+  BC83              tank_anim:
 11+  BC83 11               defb 17
 12+  BC84
 13+  BC84              ;
 14+  BC84              ; The damage countdown
 15+  BC84              ;
 16+  BC84              tank_currentdamage:
 17+  BC84 F0               defb 240
 18+  BC85
 19+  BC85              ;
 20+  BC85              ; The damage coordinate
 21+  BC85              ;
 22+  BC85              tank_currentdamagecoord:
 23+  BC85 16 02            defb 22,2
 24+  BC87
 25+  BC87              ;
 26+  BC87              ; Controls when the tank shoots
 27+  BC87              ;
 28+  BC87              tank_count:
 29+  BC87 00               defb 0
 30+  BC88
 31+  BC88              ;
 32+  BC88              ; Holds the block number of the current damage sprite
 33+  BC88              ;
 34+  BC88              tank_damageframe:
 35+  BC88 00               defb 0
 36+  BC89
 37+  BC89              ;
 38+  BC89              ; The current memory location
 39+  BC89              ;
 40+  BC89              tank_current_sprite:
 41+  BC89 00 00            defb 0,0
 42+  BC8B
 43+  BC8B              tank_current_coords:
 44+  BC8B 00 00            defb 0,0
 45+  BC8D
 46+  BC8D              ;
 47+  BC8D              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  BC8D              ;
 49+  BC8D              tank_missile_displayed:
 50+  BC8D 00               defb 0
 51+  BC8E
 52+  BC8E              ;
 53+  BC8E              ; Initialise the tank
 54+  BC8E              ;
 55+  BC8E              tank_init:
 56+  BC8E ED 4B 7E BC      ld bc,(tank_initpos)
 57+  BC92 ED 43 80 BC      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  BC96 21 82 BC         ld hl,tank_frame
 59+  BC99 36 00            ld (hl),0
 60+  BC9B 21 83 BC         ld hl,tank_anim
 61+  BC9E 36 11            ld (hl),17
 62+  BCA0 21 88 BC         ld hl,tank_damageframe              ; reset tank
 63+  BCA3 36 00            ld (hl),0
 64+  BCA5 21 87 BC         ld hl,tank_count
 65+  BCA8 36 00            ld (hl),0
 66+  BCAA 21 84 BC         ld hl,tank_currentdamage
 67+  BCAD 36 F0            ld (hl),240
 68+  BCAF 21 85 BC         ld hl,tank_currentdamagecoord
 69+  BCB2 36 16            ld (hl),22
 70+  BCB4 23               inc hl
 71+  BCB5 36 02            ld (hl),2
 72+  BCB7 21 8D BC         ld hl,tank_missile_displayed
 73+  BCBA 36 00            ld (hl),0
 74+  BCBC
 75+  BCBC C9               ret
 76+  BCBD
 77+  BCBD              ;
 78+  BCBD              ;   Draw and move the tank
 79+  BCBD              ;   Start processing at frame 200
 80+  BCBD              ;   Don't move if anim is zero
 81+  BCBD              ;   Decrement frame if moved
 82+  BCBD              ;
 83+  BCBD              tank_process:
 84+  BCBD 3A 83 BC         ld a,(tank_anim)
 85+  BCC0 FE 00            cp 0
 86+  BCC2 C2 C9 BC         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  BCC5 CD DA BC         call tank_fire
 88+  BCC8 C9               ret
 89+  BCC9              tank_process0:
 90+  BCC9 CD 56 B9         call game_getcurrentframe   ; get the current frame number into a
 91+  BCCC FE 4B            cp 75
 92+  BCCE D8               ret c                       ; return if the frame number is below 100
 93+  BCCF CD EE BD         call tank_move              ; move tank if not
 94+  BCD2 3A 83 BC         ld a,(tank_anim)
 95+  BCD5 3D               dec a
 96+  BCD6 32 83 BC         ld (tank_anim),a            ; decrease the anim count
 97+  BCD9 C9               ret
 98+  BCDA
 99+  BCDA              ;
100+  BCDA              ; Fires the tank
101+  BCDA              ;
102+  BCDA              tank_fire:
103+  BCDA 3A 87 BC         ld a,(tank_count)            ; if not, don't do anything
104+  BCDD 3C               inc a                        ; increment
105+  BCDE FE 19            cp 25                        ; have we reached fifty
106+  BCE0 C2 E5 BC         jp nz,tank_fire0
107+  BCE3 3E 00            ld a,0                       ; reset if reached fifty
108+  BCE5              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  BCE5 32 87 BC         ld (tank_count),a            ; store tank count
110+  BCE8 FE 00            cp 0
111+  BCEA CA 01 BD         jp z,tank_fire7              ; If this is zero, fire
112+  BCED 3A 8D BC         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  BCF0 FE 00            cp 0
114+  BCF2 C8               ret z                       ; don't do anything if not
115+  BCF3 CD A8 BD         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  BCF6 3E 00            ld a,0                       ; reset the flag
117+  BCF8 32 8D BC         ld (tank_missile_displayed),a
118+  BCFB 3E 02            ld a,2
119+  BCFD CD C5 A5         call buffer_marklineforupdate
120+  BD00 C9               ret                        ; only shoot if we're on 0
121+  BD01              tank_fire7:
122+  BD01 3A 84 BC         ld a,(tank_currentdamage)    ; get the damage countdown
123+  BD04 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
124+  BD06 C2 3C BD         jp nz,tank_fire1            ; not, so just do a normal frame
125+  BD09 ED 4B 85 BC      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
126+  BD0D 79               ld a,c
127+  BD0E FE 0A            cp 10
128+  BD10 C2 17 BD         jp nz, tank_fire6
129+  BD13 CD E0 BD         call tank_killedbytank      ; we're through, so the player has died. Kill them.
130+  BD16 C9               ret                         ; return if we're through the mountain
131+  BD17              tank_fire6:
132+  BD17 3E 0F            ld a,15
133+  BD19 32 88 BC         ld (tank_damageframe),a     ; reset the damage frame
134+  BD1C 21 EB B2         ld hl,sprites               ; location of the empty block
135+  BD1F CD 7D A8         call screen_showchar        ; show this character here
136+  BD22 ED 4B 85 BC      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
137+  BD26 05               dec b                       ; look one above
138+  BD27 CD AA A8         call screen_ischarempty     ; check if it is empty
139+  BD2A ED 4B 85 BC      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
140+  BD2E FE 01            cp 1
141+  BD30 C2 73 BD         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
142+  BD33 ED 4B 85 BC      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
143+  BD37 0D               dec c
144+  BD38 ED 43 85 BC      ld (tank_currentdamagecoord),bc ; store the coord
145+  BD3C              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
146+  BD3C ED 4B 85 BC      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  BD40 3A 84 BC         ld a,(tank_currentdamage)    ; get the damage countdown
148+  BD43 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
149+  BD45 C2 50 BD         jp nz, tank_fire5
150+  BD48 CD DA A8         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
151+  BD4B FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
152+  BD4D C2 91 BD         jp nz,tank_fire3            ; if it's a slope, handle this differently
153+  BD50              tank_fire5:
154+  BD50 3A 88 BC         ld a,(tank_damageframe)
155+  BD53 CD 97 A8         call screen_getblock        ; get the block data into hl
156+  BD56 CD 7D A8         call screen_showchar        ; show this character here
157+  BD59 3A 88 BC         ld a,(tank_damageframe)
158+  BD5C 3C               inc a
159+  BD5D 32 88 BC         ld (tank_damageframe),a     ; increment the damage block and store
160+  BD60 3A 84 BC         ld a,(tank_currentdamage)    ; get the damage countdown
161+  BD63 3D               dec a
162+  BD64 3D               dec a
163+  BD65 32 84 BC         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
164+  BD68 3A 8D BC         ld a,(tank_missile_displayed) ; is the missile displaying?
165+  BD6B FE 00            cp 0
166+  BD6D CC A8 BD         call z, tank_missilegraphic
167+  BD70 C3 9A BD         jp tank_fire4
168+  BD73              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
169+  BD73 05               dec b
170+  BD74 C5               push bc
171+  BD75 CD C3 A8         call screen_copyblockdown       ; copy the block down
172+  BD78 ED 4B 85 BC      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
173+  BD7C C1               pop bc                      ; get the coord we just checked back
174+  BD7D 78               ld a,b
175+  BD7E FE 00            cp 0
176+  BD80 CA 3C BD         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
177+  BD83 C5               push bc
178+  BD84 05               dec b
179+  BD85 CD AA A8         call screen_ischarempty     ; check if it is empty
180+  BD88 C1               pop bc
181+  BD89 FE 01            cp 1                        ; if empty
182+  BD8B C2 73 BD         jp nz, tank_fire2            ; copy another one down
183+  BD8E C3 3C BD         jp tank_fire1               ; otherwise, return to main thread
184+  BD91              tank_fire3:                      ; dealing with slopes
185+  BD91 3A 84 BC         ld a,(tank_currentdamage)    ; get the damage countdown
186+  BD94 06 08            ld b,8
187+  BD96 90               sub b                        ; special case for slopes
188+  BD97 32 84 BC         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
189+  BD9A              tank_fire4:                     ; TIDY UP
190+  BD9A CD C5 A5         call buffer_marklineforupdate
191+  BD9D 3E 01            ld a,1
192+  BD9F CD C5 A5         call buffer_marklineforupdate
193+  BDA2 3E 02            ld a,2
194+  BDA4 CD C5 A5         call buffer_marklineforupdate
195+  BDA7 C9               ret
196+  BDA8
197+  BDA8              ;
198+  BDA8              ; Displays or hides the missile graphic, and changes the gun
199+  BDA8              ;
200+  BDA8              tank_missilegraphic:
201+  BDA8 3A 8D BC         ld a,(tank_missile_displayed)
202+  BDAB FE 00            cp 0
203+  BDAD C2 B5 BD         jp nz,tank_missilegraphic0
204+  BDB0 3E 13            ld a,19
205+  BDB2 C3 B7 BD         jp tank_missilegraphic1
206+  BDB5              tank_missilegraphic0:
207+  BDB5 3E 00            ld a,0
208+  BDB7              tank_missilegraphic1:
209+  BDB7 32 8D BC         ld (tank_missile_displayed),a ; store the flipped graphic
210+  BDBA ED 4B 85 BC      ld bc,(tank_currentdamagecoord)
211+  BDBE 0C               inc c
212+  BDBF 0C               inc c                   ; print the graphic 2 spaces right
213+  BDC0 CD 97 A8         call screen_getblock        ; get the block data into hl
214+  BDC3 CD 7D A8         call screen_showchar        ; show this character here
215+  BDC6 06 02            ld b,2
216+  BDC8 0E 18            ld c,24                     ; set gunbarrel coords
217+  BDCA 11 00 00         ld de,0
218+  BDCD 21 95 B4         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
219+  BDD0 3A 8D BC         ld a,(tank_missile_displayed)
220+  BDD3 FE 00            cp 0
221+  BDD5 CA DB BD         jp z,tank_missilegraphic2
222+  BDD8 11 40 00         ld de,64
223+  BDDB              tank_missilegraphic2:
224+  BDDB 19               add hl,de                   ; work out missile graphic
225+  BDDC CD 7D A8         call screen_showchar        ; show this character here
226+  BDDF C9               ret
227+  BDE0
228+  BDE0              ;
229+  BDE0              ; Deal with the player being killed by the tank
230+  BDE0              ;
231+  BDE0              tank_killedbytank:
232+  BDE0 ED 4B 85 BC      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
233+  BDE4 21 EB B2         ld hl,sprites                   ; empty sprite
234+  BDE7 CD 7D A8         call screen_showchar            ; hide the last piece of dirt
235+  BDEA CD 54 BA         call player_tankkillplayer
236+  BDED C9               ret
237+  BDEE
238+  BDEE              tank_move:
239+  BDEE ED 4B 80 BC      ld bc,(tank_initpos2)
240+  BDF2 C5               push bc
241+  BDF3 3A 83 BC         ld a,(tank_anim)
242+  BDF6 FE 11            cp 17                       ; check first time flag
243+  BDF8 CA 0A BE         jp z,tank_move1             ; don't draw over previous one if first time
244+  BDFB CD 0F BE         call tank_draw_full         ; delete old one
245+  BDFE ED 4B 80 BC      ld bc,(tank_initpos2)       ; get the current coords
246+  BE02 78               ld a,b
247+  BE03 D6 01            sub 1                       ; move back one pixels
248+  BE05 47               ld b,a
249+  BE06 ED 43 80 BC      ld (tank_initpos2),bc
250+  BE0A              tank_move1:
251+  BE0A CD 0F BE         call tank_draw_full         ; draw the tank
252+  BE0D C1               pop bc
253+  BE0E C9               ret
254+  BE0F
255+  BE0F              tank_draw_full:
256+  BE0F 21 95 B4         ld hl,tank_sprite
257+  BE12 ED 4B 80 BC      ld bc,(tank_initpos2)         ; load bc with the start coords
258+  BE16 22 89 BC         ld (tank_current_sprite),hl  ; put into memory
259+  BE19 ED 43 8B BC      ld (tank_current_coords),bc  ; put into memory
260+  BE1D CD 46 BE         call tank_draw
261+  BE20 08               ex af,af'
262+  BE21 3A 82 BC         ld a,(tank_frame)            ; get the animation frame
263+  BE24 16 00            ld d,0
264+  BE26 5F               ld e,a
265+  BE27 19               add hl,de
266+  BE28 22 89 BC         ld (tank_current_sprite),hl  ; put into memory
267+  BE2B 08               ex af,af'
268+  BE2C ED 4B 80 BC      ld bc,(tank_initpos2)         ; load bc with the start coords
269+  BE30 81 C6 08         add c,8                      ; move one line down
270+  BE33 4F               ld c,a
271+  BE34 ED 43 8B BC      ld (tank_current_coords),bc  ; put into memory
272+  BE38 CD 46 BE         call tank_draw
273+  BE3B 3E 02            ld a,2
274+  BE3D CD C5 A5         call buffer_marklineforupdate
275+  BE40 3E 03            ld a,3
276+  BE42 CD C5 A5         call buffer_marklineforupdate   ; mark the first two rows for update
277+  BE45 C9               ret
278+  BE46
279+  BE46              ;
280+  BE46              ; Draw the tank
281+  BE46              ; Inputs:
282+  BE46              ; None, all in memory
283+  BE46              ;
284+  BE46              tank_draw:
285+  BE46 3E 04            ld a,4                              ; 4 pieces per half
286+  BE48              tank_draw0:
287+  BE48 F5               push af
288+  BE49 2A 89 BC         ld hl,(tank_current_sprite)
289+  BE4C ED 4B 8B BC      ld bc,(tank_current_coords)         ; load bc with the start coords
290+  BE50 CD EE A8         call sprites_drawsprite
291+  BE53 2A 89 BC         ld hl,(tank_current_sprite)
292+  BE56 ED 4B 8B BC      ld bc,(tank_current_coords)         ; load bc with the start coords
293+  BE5A 11 08 00         ld de,8
294+  BE5D 19               add hl,de
295+  BE5E 80 C6 08         add b,8
296+  BE61 47               ld b,a
297+  BE62 22 89 BC         ld (tank_current_sprite),hl         ; put into memory
298+  BE65 ED 43 8B BC      ld (tank_current_coords),bc         ; put into memory
299+  BE69 F1               pop af
300+  BE6A 3D               dec a
301+  BE6B FE 00            cp 0
302+  BE6D C2 48 BE         jp nz,tank_draw0
303+  BE70
304+  BE70 C9               ret
305+  BE71
# file closed: game/tank.asm
 42   BE71                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  BE71              ;
  2+  BE71              ; A structure of falling rocks
  3+  BE71              ; Assume we'll never have more than 4 falling at any one time
  4+  BE71              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  BE71              ;
  6+  BE71              rocks_falling:
  7+  BE71 00 00 00 00      defb 0,0,0,0
  8+  BE75 00 00 00 00      defb 0,0,0,0
  9+  BE79 00 00 00 00      defb 0,0,0,0
 10+  BE7D 00 00 00 00      defb 0,0,0,0
 11+  BE81
 12+  BE81              rocks_tmp:
 13+  BE81 00               defb 0
 14+  BE82
 15+  BE82              rocks_tmp2:
 16+  BE82 00 00            defb 0,0
 17+  BE84
 18+  BE84              ;
 19+  BE84              ; Coords of the rock that killed us
 20+  BE84              ;
 21+  BE84              rocks_killerrock:
 22+  BE84 00 00            defb 0,0
 23+  BE86
 24+  BE86              ;
 25+  BE86              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 26+  BE86              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 27+  BE86              ; If the pixel row is not the rock bottom, stop checking.
 28+  BE86              ; Inputs:
 29+  BE86              ; hl- memory location
 30+  BE86              ;
 31+  BE86              rocks_checkforfalling:
 32+  BE86 7E               ld a,(hl)           ; get the pixel row in this memory location
 33+  BE87 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 34+  BE89 C2 8F BE         jp nz,rocks_checkforfalling2 ; not a rock, stop
 35+  BE8C CD 90 BE         call rocks_addrocktofalling ; mark the rock as falling
 36+  BE8F              rocks_checkforfalling2:
 37+  BE8F C9               ret
 38+  BE90
 39+  BE90              ;
 40+  BE90              ; Adds the rock to the structure that tracks falling rocks
 41+  BE90              ; Inputs:
 42+  BE90              ; hl - memory location of falling rock graphic
 43+  BE90              ; bc - coords of rock, c vert
 44+  BE90              rocks_addrocktofalling:
 45+  BE90 C5               push bc             ; store the coords
 46+  BE91 11 71 BE         ld de,rocks_falling
 47+  BE94 06 04            ld b,4              ; number of possible falling rocks
 48+  BE96              rocks_addrocktofalling0:
 49+  BE96 13               inc de
 50+  BE97                  ;inc de
 51+  BE97 13               inc de              ; move three along to get the state
 52+  BE98 1A               ld a,(de)           ; load the state
 53+  BE99 FE 00            cp 0                ; check if this is not falling
 54+  BE9B C2 B1 BE         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 55+  BE9E 13               inc de              ; move to frame
 56+  BE9F 3E 10            ld a,16             ; load the number of frames to wobble
 57+  BEA1 12               ld (de),a
 58+  BEA2 1B               dec de              ; move de back to state
 59+  BEA3 3E 02            ld a,2
 60+  BEA5 12               ld (de),a           ; set the state to wobbling
 61+  BEA6 1B               dec de              ; move back coords
 62+  BEA7 C1               pop bc              ; get back coords
 63+  BEA8 78               ld a,b
 64+  BEA9 12               ld (de),a           ; store the vertical
 65+  BEAA 1B               dec de
 66+  BEAB 79               ld a,c
 67+  BEAC 12               ld (de),a           ; store the horizontal
 68+  BEAD C5               push bc
 69+  BEAE C3 B5 BE         jp rocks_addrocktofalling2 ; done
 70+  BEB1              rocks_addrocktofalling1:
 71+  BEB1 13               inc de
 72+  BEB2 13               inc de              ; move memory along to next rock
 73+  BEB3 10 E1            djnz rocks_addrocktofalling0 ; try the next rock
 74+  BEB5              rocks_addrocktofalling2: ; done, return
 75+  BEB5 C1               pop bc              ; to tidy up
 76+  BEB6 C9               ret
 77+  BEB7
 78+  BEB7              ;
 79+  BEB7              ; Processes any falling rocks
 80+  BEB7              ;
 81+  BEB7              rocks_processrocks:
 82+  BEB7 DD 21 71 BE      ld ix,rocks_falling
 83+  BEBB 06 04            ld b,4              ; the number of rocks to check
 84+  BEBD              rocks_processrocks0:
 85+  BEBD C5               push bc             ; store loop count
 86+  BEBE DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 86+  BEC2 46 01
 87+  BEC4 DD 23            inc ix
 88+  BEC6 DD 23            inc ix              ; move to the state
 89+  BEC8 DD 7E 00         ld a,(ix)           ; load the state into a
 90+  BECB FE 00            cp 0
 91+  BECD CA F1 BE         jp z,rocks_processrocks3 ; if not falling, check next
 92+  BED0 FE 02            cp 2
 93+  BED2 C2 E2 BE         jp nz, rocks_processrocks2
 94+  BED5                  ; we're wobbling
 95+  BED5 DD 23            inc ix              ; get frame number for wobble
 96+  BED7 DD 7E 00         ld a,(ix)           ; get wobble frame into a
 97+  BEDA CD C2 BF         call rocks_wobble
 98+  BEDD DD 23            inc ix              ; increment for next
 99+  BEDF C3 F5 BE         jp rocks_processrocks1  ; do next rock
100+  BEE2              rocks_processrocks2:
101+  BEE2                  ; we're falling
102+  BEE2 C5               push bc
103+  BEE3 CD 0E BF         call rocks_fall
104+  BEE6 C1               pop bc
105+  BEE7 CD F9 BE         call rocks_storeupdatedlines
106+  BEEA DD 23            inc ix
107+  BEEC DD 23            inc ix              ; inc ix to get to next
108+  BEEE C3 F5 BE         jp rocks_processrocks1
109+  BEF1              rocks_processrocks3:
110+  BEF1 DD 23            inc ix
111+  BEF3 DD 23            inc ix
112+  BEF5              rocks_processrocks1:
113+  BEF5 C1               pop bc              ; get loop count back
114+  BEF6 10 C5            djnz rocks_processrocks0
115+  BEF8 C9               ret
116+  BEF9
117+  BEF9              ;
118+  BEF9              ; Stores the updated rows associated with the rock
119+  BEF9              ; Inputs:
120+  BEF9              ; bc - coords
121+  BEF9              ;
122+  BEF9              rocks_storeupdatedlines:
123+  BEF9 79               ld a,c                  ; get the rock block coords of current block
124+  BEFA E6 F8            and 248                 ; find closest multiple of eight
125+  BEFC 0F               rrca
126+  BEFD 0F               rrca
127+  BEFE 0F               rrca                    ; divide by 8
128+  BEFF ED 5B 15 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
129+  BF03 93               sub e
130+  BF04 F5               push af
131+  BF05 CD C5 A5         call buffer_marklineforupdate  ; store current row in updated lines
132+  BF08 F1               pop af
133+  BF09 3C               inc a
134+  BF0A CD C5 A5         call buffer_marklineforupdate  ; store line beneath
135+  BF0D C9               ret
136+  BF0E
137+  BF0E              ;
138+  BF0E              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
139+  BF0E              ; bc - coord of current rock graphic on screen
140+  BF0E              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
141+  BF0E              ;
142+  BF0E              rocks_fall:
143+  BF0E DD 2B            dec ix
144+  BF10 DD 2B            dec ix              ; decrease ix back to coords
145+  BF12 ED 43 82 BE      ld (rocks_tmp2),bc  ; store original coords
146+  BF16 3E 03            ld a,3              ; move this number of pixels
147+  BF18              rocks_fall1:
148+  BF18 08               ex af,af'
149+  BF19 DD 4E 00 DD      ld bc,(ix)          ; get current coords
149+  BF1D 46 01
150+  BF1F CD 31 A9         call sprites_scadd  ; get the memory of the coords into de
151+  BF22 14               inc d               ; add 256 to get next row
152+  BF23 1A               ld a,(de)           ; get the contents of the next row
153+  BF24 FE 00            cp 0
154+  BF26 C2 82 BF         jp nz,rocks_fall3    ; move the rock if the row is empty
155+  BF29 0C               inc c               ; increment the vertical
156+  BF2A DD 71 00 DD      ld (ix),bc          ; store the new coords
156+  BF2E 70 01
157+  BF30 79               ld a,c              ; get the vertical coord into a
158+  BF31 E6 07            and 7               ; divisible by 8?
159+  BF33 FE 00            cp 0
160+  BF35 C2 50 BF         jp nz,rocks_fall4   ; if not, carry on
161+  BF38 CD 40 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
162+  BF3B 62 6B            ld hl,de
163+  BF3D 36 42            ld (hl),66          ; load this square with the yellow colour
164+  BF3F DD 4E 00 DD      ld bc,(ix)
164+  BF43 46 01
165+  BF45 79               ld a,c              ; get vertical
166+  BF46 D6 08            sub 8               ; look up one square
167+  BF48 4F               ld c,a              ; put a back in c
168+  BF49 CD 40 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
169+  BF4C 62 6B            ld hl,de
170+  BF4E 36 46            ld (hl),70          ; load this square with the yellow colour
171+  BF50              rocks_fall4:
172+  BF50 08               ex af,af'
173+  BF51 3D               dec a
174+  BF52 FE 00            cp 0
175+  BF54 C2 18 BF         jp nz,rocks_fall1   ; do another pixel if needed
176+  BF57              rocks_fall2:
177+  BF57 3E 09            ld a,9              ; rock graphic
178+  BF59 ED 4B 82 BE      ld bc,(rocks_tmp2)  ; get the original coords
179+  BF5D CD 97 A8         call screen_getblock     ; get the memory into hl
180+  BF60 CD EE A8         call sprites_drawsprite  ; draw the sprite - over the top of the current one
181+  BF63 3E 09            ld a,9
182+  BF65 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
182+  BF69 46 01
183+  BF6B CD 97 A8         call screen_getblock     ; get the memory into hl
184+  BF6E CD EE A8         call sprites_drawsprite  ; draw the sprite - over the top of the current one
185+  BF71 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
185+  BF75 46 01
186+  BF77 CD A7 BF         call rocks_checkforplayer ; check to see if we hit a player
187+  BF7A DD 23            inc ix
188+  BF7C DD 23            inc ix                  ; get ix back to state
189+  BF7E CD 97 BF         call rocks_makesound
190+  BF81 C9               ret
191+  BF82              rocks_fall3:
192+  BF82 3E 00            ld a,0              ; set the state to fell
193+  BF84 DD 77 02         ld (ix+2),a           ; store the falling state
194+  BF87 DD 4E 00 DD      ld bc,(ix)          ; get the coords
194+  BF8B 46 01
195+  BF8D CD 40 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
196+  BF90 62 6B            ld hl,de
197+  BF92 36 42            ld (hl),66
198+  BF94 C3 57 BF         jp rocks_fall2      ; rejoin main loop
199+  BF97
200+  BF97              ;
201+  BF97              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
202+  BF97              ;
203+  BF97              rocks_makesound:
204+  BF97 DD 7E 00         ld a,(ix)           ; get the state
205+  BF9A FE 00            cp 0
206+  BF9C C0               ret nz              ; if we haven't fallen, don't do anything
207+  BF9D 21 6B B9         ld hl,player+11
208+  BFA0 7E               ld a,(hl)
209+  BFA1 FE 01            cp 1
210+  BFA3 C4 1C AD         call nz, sound_rockfell ; only make sound if didn't kill player
211+  BFA6 C9               ret
212+  BFA7
213+  BFA7              ;
214+  BFA7              ; Checks to see if the rock is hitting a player
215+  BFA7              ; Inputs:
216+  BFA7              ; bc - coords of rock we're checking
217+  BFA7              rocks_checkforplayer:
218+  BFA7 ED 5B 60 B9      ld de,(player)       ; get the player coords
219+  BFAB 7B               ld a,e               ; get the vert coord first
220+  BFAC 91               sub c                ; subtract the rock vertical coord from players
221+  BFAD FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
222+  BFAF C0               ret nz               ; if not, hasn't hit
223+  BFB0 7A               ld a,d               ; get the player horiz coord
224+  BFB1 90               sub b                ; subtract rock coord
225+  BFB2 C6 07            add 7                ; add max distance
226+  BFB4 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
227+  BFB6 DA BA BF         jp c,rocks_checkforplayer0
228+  BFB9 C9               ret
229+  BFBA              rocks_checkforplayer0:
230+  BFBA ED 43 84 BE      ld (rocks_killerrock),bc; store the coords of the killer rock
231+  BFBE CD 4E BA         call player_crushplayer ; if so, jump out
232+  BFC1 C9               ret
233+  BFC2
234+  BFC2              ;
235+  BFC2              ; Wobbles a rocks
236+  BFC2              ; Inputs:
237+  BFC2              ; bc - coord of current rock graphic on screen
238+  BFC2              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
239+  BFC2              ; a - wobble frame
240+  BFC2              rocks_wobble:
241+  BFC2 DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
242+  BFC5 E6 01            and 1               ; is it odd or even, gets 1 or 0
243+  BFC7 1E 09            ld e,9              ; this is the rock frame
244+  BFC9 83               add a,e             ; add the frame toggle
245+  BFCA C5               push bc
246+  BFCB CD 97 A8         call screen_getblock     ; get the memory into hl
247+  BFCE CD EE A8         call sprites_drawsprite  ; draw the sprite - over the top of the current one
248+  BFD1
249+  BFD1 DD 7E 00         ld a,(ix)           ; get the frame toggle again
250+  BFD4 3D               dec a               ; decrease
251+  BFD5 DD 77 00         ld (ix),a           ; store
252+  BFD8
253+  BFD8 E6 01            and 1
254+  BFDA 1E 09            ld e,9              ; this is the rock frame
255+  BFDC 83               add a,e             ; add the frame toggle
256+  BFDD CD 97 A8         call screen_getblock     ; get the memory into hl
257+  BFE0
258+  BFE0 C1               pop bc
259+  BFE1 CD EE A8         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
260+  BFE4
261+  BFE4 DD 7E 00         ld a,(ix)           ; get the wobble count back
262+  BFE7 FE 00            cp 0
263+  BFE9 C0               ret nz              ; if we're not at zero, return
264+  BFEA DD 2B            dec ix              ; otherwise look to state location
265+  BFEC 3E 01            ld a,1              ; set the state to falling
266+  BFEE DD 77 00         ld (ix),a           ; store the falling state
267+  BFF1 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
268+  BFF3 C9               ret
269+  BFF4
# file closed: game/rocks.asm
 43   BFF4                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  BFF4              ;
  2+  BFF4              ; The score of the current player
  3+  BFF4              ;
  4+  BFF4              scores_current:
  5+  BFF4 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  BFF8 30 30 30 30
  5+  BFFC FF
  6+  BFFD
  7+  BFFD              scores_defaultname:
  8+  BFFD 2D 2D 2D         defb '---'
  9+  C000
 10+  C000              ;
 11+  C000              ; The current high score table
 12+  C000              ;
 13+  C000              scores_table:
 14+  C000 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  C004 4D 30 30 30
 14+  C008 30 30 30 FF
 15+  C00C 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  C010 4D 30 30 30
 15+  C014 30 30 30 FF
 16+  C018 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  C01C 4D 30 30 30
 16+  C020 30 30 30 FF
 17+  C024
 18+  C024              ;
 19+  C024              ; Add thousands to the score
 20+  C024              ; Inputs:
 21+  C024              ; b - number to add
 22+  C024              ;
 23+  C024              scores_addthousands:
 24+  C024 21 F8 BF         ld hl,scores_current+4
 25+  C027 CD 51 C0         call scores_update
 26+  C02A C9               ret
 27+  C02B
 28+  C02B              ;
 29+  C02B              ; Prints the score to screen
 30+  C02B              ;
 31+  C02B              scores_printscore:
 32+  C02B 3A 32 B9         ld a,(game_currentplayer)   ; get current player
 33+  C02E 21 F4 BF         ld hl,scores_current
 34+  C031 FE 01            cp 1
 35+  C033 C2 3B C0         jp nz, score_printscore0    ; if not player 1
 36+  C036 36 04            ld (hl),4       ; set position for player 1
 37+  C038 C3 3D C0         jp score_printscore1
 38+  C03B              score_printscore0:
 39+  C03B 36 16            ld (hl),22       ; set position for player 2
 40+  C03D              score_printscore1:
 41+  C03D 21 F4 BF         ld hl,scores_current
 42+  C040 CD C5 84         call string_print
 43+  C043 C9               ret
 44+  C044
 45+  C044              ;
 46+  C044              ; Prints both scores to screen
 47+  C044              ;
 48+  C044              scores_printscores:
 49+  C044 21 36 BA         ld hl,player1_score
 50+  C047 CD C5 84         call string_print
 51+  C04A 21 3F BA         ld hl,player2_score
 52+  C04D CD C5 84         call string_print
 53+  C050 C9               ret
 54+  C051
 55+  C051              ;
 56+  C051              ; Updates the current score.
 57+  C051              ; Inputs:
 58+  C051              ; hl - memory location of the score column
 59+  C051              ; b - number to add
 60+  C051              ;
 61+  C051              scores_update:
 62+  C051 7E               ld a,(hl)           ; current value of digit.
 63+  C052 80               add a,b             ; add points to this digit.
 64+  C053 77               ld (hl),a           ; place new digit back in string.
 65+  C054 FE 3A            cp 58               ; more than ASCII value '9'?
 66+  C056 D8               ret c               ; no - relax.
 67+  C057 D6 0A            sub 10              ; subtract 10.
 68+  C059 77               ld (hl),a           ; put new character back in string.
 69+  C05A              scores_update0:
 70+  C05A 2B               dec hl              ; previous character in string.
 71+  C05B 34               inc (hl)            ; up this by one.
 72+  C05C 7E               ld a,(hl)           ; what's the new value?
 73+  C05D FE 3A            cp 58               ; gone past ASCII nine?
 74+  C05F D8               ret c               ; no, scoring done.
 75+  C060 D6 0A            sub 10              ; down by ten.
 76+  C062 77               ld (hl),a           ; put it back
 77+  C063 C3 5A C0         jp scores_update0   ; go round again.
 78+  C066
 79+  C066
 80+  C066              ;
 81+  C066              ; Displays the high score table at the bottom of the screen
 82+  C066              ;
 83+  C066              scores_showtable:
 84+  C066 21 00 C0         ld hl, scores_table
 85+  C069 CD C5 84         call string_print
 86+  C06C 21 0C C0         ld hl, scores_table+12
 87+  C06F CD C5 84         call string_print
 88+  C072 21 18 C0         ld hl, scores_table+24
 89+  C075 CD C5 84         call string_print
 90+  C078 C9               ret
 91+  C079
 92+  C079              ;
 93+  C079              ; Place to store the current position we're checking
 94+  C079              ;
 95+  C079              scores_highscoretmp:
 96+  C079 00               defb 0
 97+  C07A
 98+  C07A              ;
 99+  C07A              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
100+  C07A              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
101+  C07A              ;
102+  C07A              scores_processhighscores:
103+  C07A 21 79 C0         ld hl,scores_highscoretmp
104+  C07D 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
105+  C07F 3E 1D            ld a,29
106+  C081              scores_processhighscores3:
107+  C081 21 00 C0         ld hl,scores_table          ; position of first score column
108+  C084 5F               ld e,a
109+  C085 16 00            ld d,0
110+  C087 19               add hl,de
111+  C088 08               ex af,af'                   ; store a for later
112+  C089 11 F6 BF         ld de,scores_current+2      ; position of current score column
113+  C08C 06 06            ld b,6                      ; times to loop
114+  C08E              scores_processhighscores0:
115+  C08E 7E               ld a,(hl)
116+  C08F 4F               ld c,a                      ; get first score column
117+  C090 1A               ld a,(de)                   ; get first current column
118+  C091 B9               cp c                        ; compare current with first
119+  C092 DA A3 C0         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
120+  C095 23               inc hl
121+  C096 13               inc de                      ; move to next column
122+  C097 10 F5            djnz scores_processhighscores0 ; loop
123+  C099 08               ex af,af'                     ; still here, so must be bigger
124+  C09A 32 79 C0         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
125+  C09D 0E 0C            ld c,12
126+  C09F 91               sub c
127+  C0A0 D2 81 C0         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
128+  C0A3              scores_processhighscores4
129+  C0A3 CD A7 C0         call scores_updatehighscores
130+  C0A6 C9               ret
131+  C0A7
132+  C0A7              ;
133+  C0A7              ; Update score table
134+  C0A7              ;
135+  C0A7              scores_updatehighscores:
136+  C0A7 3A 79 C0         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
137+  C0AA FE 00            cp 0
138+  C0AC C8               ret z                       ; if this is 0, didn't get a high score
139+  C0AD FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
140+  C0AF CA E2 C0         jp z, scores_updatehighscores3
141+  C0B2                                              ; copy old score over one below, if not first
142+  C0B2 21 00 C0         ld hl,scores_table
143+  C0B5 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
144+  C0B8 19               add hl,de                   ; position of first column
145+  C0B9 2B               dec hl
146+  C0BA 2B               dec hl
147+  C0BB 2B               dec hl
148+  C0BC E5               push hl
149+  C0BD 11 0C 00         ld de,12
150+  C0C0 19               add hl,de                   ; get position of next score
151+  C0C1 54 5D            ld de,hl
152+  C0C3 E1               pop hl                      ; get hl back
153+  C0C4 01 09 00         ld bc,9
154+  C0C7 ED B0            ldir
155+  C0C9 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
156+  C0CB CA E2 C0         jp z,scores_updatehighscores3
157+  C0CE 21 00 C0         ld hl,scores_table
158+  C0D1 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
159+  C0D4 19               add hl,de                   ; position of first column
160+  C0D5 E5               push hl
161+  C0D6 11 0C 00         ld de,12
162+  C0D9 19               add hl,de                   ; get position of next score
163+  C0DA 54 5D            ld de,hl
164+  C0DC E1               pop hl                      ; get hl back
165+  C0DD 01 09 00         ld bc,9
166+  C0E0 ED B0            ldir
167+  C0E2              scores_updatehighscores3:
168+  C0E2 06 06            ld b,6                      ; now overwrite
169+  C0E4 21 00 C0         ld hl,scores_table
170+  C0E7 16 00            ld d,0
171+  C0E9 5F               ld e,a
172+  C0EA 19               add hl,de                   ; position of first column
173+  C0EB 08               ex af,af'
174+  C0EC 11 F6 BF         ld de,scores_current+2      ; position of current score column
175+  C0EF              scores_updatehighscores2:
176+  C0EF 1A               ld a,(de)
177+  C0F0 77               ld (hl),a
178+  C0F1 23               inc hl
179+  C0F2 13               inc de
180+  C0F3 10 FA            djnz scores_updatehighscores2
181+  C0F5 11 09 00         ld de,9
182+  C0F8 ED 52            sbc hl,de
183+  C0FA 54 5D            ld de,hl                    ; get back to start of entry
184+  C0FC 21 FD BF         ld hl,scores_defaultname    ; still need to overwrite the name
185+  C0FF 01 03 00         ld bc,3                      ; 3 chars to copy
186+  C102 ED B0            ldir
187+  C104 C9               ret
# file closed: game/scores.asm
 44   C105                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  C105              diamonds_tmp:
  2+  C105 00               defb 0
  3+  C106
  4+  C106              ;
  5+  C106              ; Holds the number of thousands for the current gem type
  6+  C106              ;
  7+  C106              diamonds_score:
  8+  C106 00               defb 0
  9+  C107
 10+  C107              ;
 11+  C107              ; Changes the attribute of gem and diamond cells based on the frame count
 12+  C107              ; Inputs:
 13+  C107              ; hl - memory location of gem type
 14+  C107              diamonds_twinkle_type:
 15+  C107 CD 56 B9         call game_getcurrentframe       ; get current frame number
 16+  C10A E6 07            and 7                           ; want a number from 0-7
 17+  C10C C6 40            add 64                          ; add to 60 to get attr colour
 18+  C10E              diamonds_twinkle_type0:
 19+  C10E 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 20+  C112 08               ex af, af'
 21+  C113 79               ld a,c                          ; load c into a
 22+  C114 FE FF            cp 255                          ; is this the end?
 23+  C116 CA 33 C1         jp z,diamonds_twinkle_type1           ; step out if so
 24+  C119 23               inc hl
 25+  C11A 23               inc hl
 26+  C11B 7E               ld a,(hl)                       ; check the state, don't process if collected
 27+  C11C FE 01            cp 1
 28+  C11E CA 34 C1         jp z,diamonds_twinkle_type2           ; step out if so
 29+  C121 CD 73 C1         call diamonds_checkforplayer    ; check to see if we've collided with player
 30+  C124 DC 3B C1         call c,diamonds_collect     ; we collided
 31+  C127 23               inc hl
 32+  C128 08               ex af,af'
 33+  C129 5E 23 56 2B      ld de,(hl)                      ; get the memory location into de
 34+  C12D 12               ld (de),a                       ; set the value of attr
 35+  C12E 23               inc hl
 36+  C12F 23               inc hl                          ; move to next diamond
 37+  C130 C3 0E C1         jp diamonds_twinkle_type0
 38+  C133              diamonds_twinkle_type1:
 39+  C133 C9               ret
 40+  C134              diamonds_twinkle_type2:
 41+  C134 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 42+  C135 23               inc hl
 43+  C136 23               inc hl
 44+  C137 08               ex af,af'
 45+  C138 C3 0E C1         jp diamonds_twinkle_type0       ; rejoin main loop
 46+  C13B
 47+  C13B              ;
 48+  C13B              ; Collect the diamond we collided with
 49+  C13B              ; Inputs:
 50+  C13B              ; hl - memory location of current diamond, currently on state
 51+  C13B              ; Output:
 52+  C13B              ; a - 70 - for yellow on black
 53+  C13B              diamonds_collect:
 54+  C13B 36 01            ld (hl),1                       ; collected
 55+  C13D E5               push hl
 56+  C13E 2B               dec hl
 57+  C13F 2B               dec hl
 58+  C140 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 59+  C144 CD 63 A8         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 60+  C147 ED 5B 05 C1      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 61+  C14B 16 00            ld d,0
 62+  C14D 21 EB B2         ld hl,sprites
 63+  C150 19               add hl,de
 64+  C151 CD EE A8         call sprites_drawsprite     ; call the routine to draw the sprite
 65+  C154 E1               pop hl
 66+  C155 08               ex af,af'
 67+  C156 3E 46            ld a,70
 68+  C158 08               ex af,af'                       ; make sure a is in the af we'll use for the attr
 69+  C159 D9               exx
 70+  C15A 3A 06 C1         ld a,(diamonds_score)
 71+  C15D 47               ld b,a
 72+  C15E CD 24 C0         call scores_addthousands
 73+  C161 3A 05 C1         ld a,(diamonds_tmp)
 74+  C164 FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 75+  C166 C2 6E C1         jp nz,diamonds_collect0
 76+  C169 21 6D B9         ld hl,player+13
 77+  C16C 36 01            ld (hl),1                   ; mark the player as able to complete the level
 78+  C16E              diamonds_collect0:
 79+  C16E CD FF AC         call sound_gemcollected
 80+  C171 D9               exx
 81+  C172 C9               ret
 82+  C173
 83+  C173              ;
 84+  C173              ; Checks to see if the gem is hitting a player
 85+  C173              ; Inputs:
 86+  C173              ; bc - coords of diamond we're checking
 87+  C173              diamonds_checkforplayer:
 88+  C173 78               ld a,b               ; multiply b by 8
 89+  C174 07               rlca
 90+  C175 07               rlca
 91+  C176 07               rlca
 92+  C177 47               ld b,a
 93+  C178 ED 5B 60 B9      ld de,(player)       ; get the player coords
 94+  C17C 7B               ld a,e               ; get the vert coord first
 95+  C17D 90               sub b                ; subtract the diamond vertical coord from players
 96+  C17E C6 04            add 4                ; add the max distance
 97+  C180 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
 98+  C182 D0               ret nc               ; if not, hasn't hit
 99+  C183 79               ld a,c               ; multiply c by 8
100+  C184 07               rlca
101+  C185 07               rlca
102+  C186 07               rlca
103+  C187 4F               ld c,a
104+  C188 7A               ld a,d               ; get the player horiz coord
105+  C189 91               sub c                ; subtract rock coord
106+  C18A C6 04            add 4                ; add max distance
107+  C18C FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
108+  C18E D0               ret nc
109+  C18F 3E 00            ld a,0
110+  C191 C9               ret
111+  C192
112+  C192
113+  C192              ;
114+  C192              ; Initialise diamonds and gems
115+  C192              ;
116+  C192              diamonds_twinkle
117+  C192 21 06 C1         ld hl,diamonds_score
118+  C195 36 02            ld (hl),2         ; store the score we'll add
119+  C197 21 05 C1         ld hl,diamonds_tmp
120+  C19A 36 40            ld (hl),64         ; store the location the diamond sprite
121+  C19C 21 66 B2         ld hl, level01diamonds
122+  C19F CD 07 C1         call diamonds_twinkle_type
123+  C1A2 21 06 C1         ld hl,diamonds_score
124+  C1A5 36 01            ld (hl),1         ; store the score we'll add
125+  C1A7 21 05 C1         ld hl,diamonds_tmp
126+  C1AA 36 70            ld (hl),112         ; store the location the gem sprite
127+  C1AC 21 76 B2         ld hl, level01gems
128+  C1AF CD 07 C1         call diamonds_twinkle_type
129+  C1B2 C9               ret
130+  C1B3
131+  C1B3              ;
132+  C1B3              ; Initialise diamonds and gems
133+  C1B3              ;
134+  C1B3              diamonds_init:
135+  C1B3 21 66 B2         ld hl, level01diamonds
136+  C1B6 CD C0 C1         call diamonds_init_type
137+  C1B9 21 76 B2         ld hl, level01gems
138+  C1BC CD C0 C1         call diamonds_init_type
139+  C1BF C9               ret
140+  C1C0
141+  C1C0              ;
142+  C1C0              ; Initialise diamonds or gems, get memory addresses
143+  C1C0              ; Inputs:
144+  C1C0              ; hl - memory location
145+  C1C0              diamonds_init_type:
146+  C1C0 4E               ld c,(hl)                      ; get coords into c
147+  C1C1 79               ld a,c                          ; load c into add
148+  C1C2 FE FF            cp 255                          ; is this the end?
149+  C1C4 CA DB C1         jp z,diamonds_init_type1             ; step out if so
150+  C1C7 23               inc hl
151+  C1C8 46               ld b,(hl)                       ; get coords into b
152+  C1C9 E5               push hl
153+  C1CA CD 10 A8         call screen_getcellattradress ; get memory of attr for this diamond into de
154+  C1CD E1               pop hl
155+  C1CE 23               inc hl                          ; move to state
156+  C1CF 36 00            ld (hl),0
157+  C1D1 23               inc hl                          ; move to memory
158+  C1D2 73 23 72 2B      ld (hl),de                      ; store the memory location
159+  C1D6 23               inc hl                          ; move to next diamond
160+  C1D7 23               inc hl
161+  C1D8 C3 C0 C1         jp diamonds_init_type
162+  C1DB              diamonds_init_type1:
163+  C1DB C9               ret
# file closed: game/diamonds.asm
 45   C1DC                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  C1DC              ;
  2+  C1DC              ; Controls when missiles fall
  3+  C1DC              ;
  4+  C1DC              missiles_count:
  5+  C1DC 00               defb 0
  6+  C1DD
  7+  C1DD              ;
  8+  C1DD              ; A structure of falling missiles
  9+  C1DD              ; Assume we'll never have more than 4 falling at any one time
 10+  C1DD              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  C1DD              ;
 12+  C1DD              missiles_falling:
 13+  C1DD 00 00 00         defb 0,0,0
 14+  C1E0 00 00 00         defb 0,0,0
 15+  C1E3 00 00 00         defb 0,0,0
 16+  C1E6 00 00 00         defb 0,0,0
 17+  C1E9
 18+  C1E9              ;
 19+  C1E9              ; The coords of the missile that killed us
 20+  C1E9              ;
 21+  C1E9              missiles_killermissile:
 22+  C1E9 00 00            defb 0,0
 23+  C1EB
 24+  C1EB              ;
 25+  C1EB              ; Zeroes the state of each missile
 26+  C1EB              ;
 27+  C1EB              missiles_init:
 28+  C1EB 06 0C            ld b,12
 29+  C1ED DD 21 ED B1      ld ix,level01missiles
 30+  C1F1              missiles_init0:
 31+  C1F1 DD 36 02 00      ld (ix+2),0               ; set the state to zero
 32+  C1F5 11 05 00         ld de,5
 33+  C1F8 DD 19            add ix,de
 34+  C1FA DD 36 02 00      ld (ix+2),0
 35+  C1FE DD 19            add ix,de
 36+  C200 10 EF            djnz missiles_init0
 37+  C202 06 04            ld b,4                  ; reset four falling missiles
 38+  C204 21 DD C1         ld hl,missiles_falling
 39+  C207              missiles_init1:
 40+  C207 36 00            ld (hl),0
 41+  C209 23               inc hl
 42+  C20A 36 00            ld (hl),0
 43+  C20C 23               inc hl
 44+  C20D 36 00            ld (hl),0
 45+  C20F 23               inc hl
 46+  C210 10 F5            djnz missiles_init1
 47+  C212 C9               ret
 48+  C213
 49+  C213              ;
 50+  C213              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 51+  C213              ; Processes any already falling missiles
 52+  C213              ;
 53+  C213              missiles_process:
 54+  C213 3A 6B B9         ld a,(player+11)                        ; check if the player was hit by a missile previously
 55+  C216 FE 03            cp 3
 56+  C218 C2 1F C2         jp nz,missiles_process3                 ; if not, continue
 57+  C21B CD 80 C3         call missiles_zonkplayer
 58+  C21E C9               ret
 59+  C21F              missiles_process3:
 60+  C21F 3A 6E B9         ld a,(player_location)
 61+  C222 FE 01            cp 1
 62+  C224 C2 97 C2         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 63+  C227 21 6D B9         ld hl,player+13
 64+  C22A 7E               ld a,(hl)                               ; check if player has collected a diamond
 65+  C22B FE 01            cp 1
 66+  C22D C2 97 C2         jp nz, missiles_process0                ; don't activate if not
 67+  C230 21 DC C1         ld hl,missiles_count
 68+  C233 7E               ld a,(hl)                   ; get the missiles count
 69+  C234 3C               inc a
 70+  C235 FE 32            cp 50                                   ; have we reached the count yet
 71+  C237 CA 3E C2         jp z,missiles_process2                 ; if not, don't activate a new one
 72+  C23A 77               ld (hl),a                               ; store the updated count, and continue without activating
 73+  C23B C3 97 C2         jp missiles_process0
 74+  C23E              missiles_process2:
 75+  C23E 36 00            ld (hl),0                               ; zero the counter
 76+  C240 1E 0C            ld e,12
 77+  C242 CD D6 80         call utilities_randomupper              ; get random number from 0 to 11
 78+  C245 11 0A 00         ld de,10
 79+  C248 CD 3A 80         call utilities_multiply                 ; multiple random number by 10
 80+  C24B 54 5D            ld de,hl                                ; this is the offset for the random missile
 81+  C24D DD 21 ED B1      ld ix,level01missiles                   ; load the location of the missile definitions
 82+  C251 DD 19            add ix,de                               ; get to location of missile
 83+  C253 DD 7E 02         ld a,(ix+2)
 84+  C256 FE 00            cp 0
 85+  C258 CA 68 C2         jp z,missiles_process1                  ; if this missile isn't active, activate it
 86+  C25B 11 05 00         ld de,5                                 ; otherwise, check the missile above
 87+  C25E DD 19            add ix,de
 88+  C260 DD 7E 02         ld a,(ix+2)
 89+  C263 FE 00            cp 0
 90+  C265 C2 97 C2         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 91+  C268              missiles_process1:                          ; activate a missile
 92+  C268 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
 93+  C26C DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
 93+  C270 46 01
 94+  C272 78               ld a,b
 95+  C273 ED 5B 15 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
 96+  C277 93               sub e
 97+  C278 C5               push bc
 98+  C279 CD C5 A5         call buffer_marklineforupdate
 99+  C27C C1               pop bc
100+  C27D CD 63 A8         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
101+  C280 C5               push bc
102+  C281 3E 0C            ld a,12                                 ; inactive missile sprite
103+  C283 CD 97 A8         call screen_getblock
104+  C286 CD EE A8         call sprites_drawsprite                 ; draw the sprite over the old one
105+  C289 C1               pop bc
106+  C28A C5               push bc
107+  C28B 3E 14            ld a,20                                 ; active missile sprite
108+  C28D CD 97 A8         call screen_getblock
109+  C290 CD EE A8         call sprites_drawsprite                 ; draw the sprite over the old one
110+  C293 C1               pop bc
111+  C294 CD 44 C3         call missiles_addmissiletofalling
112+  C297              missiles_process0:
113+  C297 CD 9B C2         call missiles_fall
114+  C29A C9               ret
115+  C29B
116+  C29B              ;
117+  C29B              ; Processes falling missiles
118+  C29B              ;
119+  C29B              missiles_fall:
120+  C29B 06 04            ld b,4              ; number of possible falling missiles
121+  C29D DD 21 DD C1      ld ix,missiles_falling
122+  C2A1              missiles_fall0:
123+  C2A1 C5               push bc
124+  C2A2 DD 7E 02         ld a,(ix+2)
125+  C2A5 FE 00            cp 0
126+  C2A7 CA 0E C3         jp z,missiles_fall1 ; not falling move to next
127+  C2AA FE 01            cp 1                ; is this ready to fall
128+  C2AC CA B2 C2         jp z, missiles_fall3
129+  C2AF C3 28 C3         jp missiles_fall4   ; if not, decrease the countdown
130+  C2B2              missiles_fall3:
131+  C2B2 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
131+  C2B6 46 01
132+  C2B8 CD 31 A9         call sprites_scadd  ; get the memory of the coords into de
133+  C2BB 14               inc d               ; add 256 to get next row
134+  C2BC 1A               ld a,(de)           ; get the contents of the next row
135+  C2BD FE 00            cp 0
136+  C2BF C2 21 C3         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
137+  C2C2 3E 14            ld a,20                                 ; active missile sprite
138+  C2C4 CD 97 A8         call screen_getblock
139+  C2C7 CD EE A8         call sprites_drawsprite                 ; draw the sprite over the old one
140+  C2CA DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
140+  C2CE 46 01
141+  C2D0 CD 2F C3         call missiles_storeupdatedlines
142+  C2D3 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
142+  C2D7 46 01
143+  C2D9 0C               inc c               ; move down one pixel
144+  C2DA DD 71 00 DD      ld (ix),bc          ; store the new coords
144+  C2DE 70 01
145+  C2E0 3E 14            ld a,20                                 ; active missile sprite
146+  C2E2 CD 97 A8         call screen_getblock
147+  C2E5 CD EE A8         call sprites_drawsprite                 ; draw the sprite
148+  C2E8 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
148+  C2EC 46 01
149+  C2EE 79               ld a,c              ; get the vertical coord into a
150+  C2EF E6 07            and 7               ; divisible by 8?
151+  C2F1 FE 00            cp 0
152+  C2F3 C2 0E C3         jp nz,missiles_fall1   ; if not, carry on
153+  C2F6 CD 40 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
154+  C2F9 62 6B            ld hl,de
155+  C2FB 36 43            ld (hl),67          ; load this square with the magenta colour
156+  C2FD DD 4E 00 DD      ld bc,(ix)
156+  C301 46 01
157+  C303 79               ld a,c              ; get vertical
158+  C304 D6 08            sub 8               ; look up one square
159+  C306 4F               ld c,a              ; put a back in c
160+  C307 CD 40 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
161+  C30A 62 6B            ld hl,de
162+  C30C 36 46            ld (hl),70          ; load this square with the yellow colour
163+  C30E              missiles_fall1:         ; hl at state
164+  C30E DD 4E 00 DD      ld bc,(ix)          ; get coords back
164+  C312 46 01
165+  C314 CD 65 C3         call missiles_checkforplayer ; check for player
166+  C317 DD 23            inc ix
167+  C319 DD 23            inc ix
168+  C31B DD 23            inc ix              ; get to next missile
169+  C31D C1               pop bc
170+  C31E 10 81            djnz missiles_fall0
171+  C320 C9               ret
172+  C321              missiles_fall2:
173+  C321 DD 36 02 00      ld (ix+2),0
174+  C325 C3 0E C3         jp missiles_fall1   ; rejoin the loop
175+  C328              missiles_fall4:
176+  C328 3D               dec a               ; decrease the countdown
177+  C329 DD 77 02         ld (ix+2),a         ; store back
178+  C32C C3 0E C3         jp missiles_fall1   ; do next missile
179+  C32F
180+  C32F              ;
181+  C32F              ; Stores the updated rows associated with the missiles
182+  C32F              ; Inputs:
183+  C32F              ; bc - coords
184+  C32F              ;
185+  C32F              missiles_storeupdatedlines:
186+  C32F 79               ld a,c                  ; get the missile block coords of current block
187+  C330 E6 F8            and 248                 ; find closest multiple of eight
188+  C332 0F               rrca
189+  C333 0F               rrca
190+  C334 0F               rrca                    ; divide by 8
191+  C335 ED 5B 15 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
192+  C339 93               sub e
193+  C33A F5               push af
194+  C33B CD C5 A5         call buffer_marklineforupdate  ; store current row in updated lines
195+  C33E F1               pop af
196+  C33F 3C               inc a
197+  C340 CD C5 A5         call buffer_marklineforupdate  ; store line beneath
198+  C343 C9               ret
199+  C344
200+  C344              ;
201+  C344              ; Adds the missile to the structure that tracks falling missile
202+  C344              ; Inputs:
203+  C344              ; bc - coords of missile, c vert
204+  C344              missiles_addmissiletofalling:
205+  C344 C5               push bc             ; store the coords
206+  C345 11 DD C1         ld de,missiles_falling
207+  C348 06 04            ld b,4              ; number of possible falling missiles
208+  C34A              missiles_addmissiletofalling0:
209+  C34A 13               inc de
210+  C34B 13               inc de              ; move three along to get the state
211+  C34C 1A               ld a,(de)           ; load the state
212+  C34D FE 00            cp 0                ; check if this is not falling
213+  C34F C2 60 C3         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
214+  C352 3E 19            ld a,25
215+  C354 12               ld (de),a           ; set the state to pre-falling
216+  C355 1B               dec de              ; move back coords
217+  C356 C1               pop bc              ; get back coords
218+  C357 78               ld a,b
219+  C358 12               ld (de),a           ; store the vertical
220+  C359 1B               dec de
221+  C35A 79               ld a,c
222+  C35B 12               ld (de),a           ; store the horizontal
223+  C35C C5               push bc
224+  C35D C3 63 C3         jp missiles_addmissiletofalling2 ; done
225+  C360              missiles_addmissiletofalling1:
226+  C360 13               inc de              ; move memory along to next rock
227+  C361 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
228+  C363              missiles_addmissiletofalling2: ; done, return
229+  C363 C1               pop bc              ; to tidy up
230+  C364 C9               ret
231+  C365
232+  C365              ;
233+  C365              ; Checks to see if the missile is hitting a player
234+  C365              ; Inputs:
235+  C365              ; bc - coords of missile we're checking
236+  C365              missiles_checkforplayer:
237+  C365 ED 5B 60 B9      ld de,(player)       ; get the player coords
238+  C369 7B               ld a,e               ; get the vert coord first
239+  C36A 91               sub c                ; subtract the missile vertical coord from players
240+  C36B FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
241+  C36D C0               ret nz               ; if not, hasn't hit
242+  C36E 7A               ld a,d               ; get the player horiz coord
243+  C36F 90               sub b                ; subtract missile coord
244+  C370 C6 07            add 7                ; add max distance
245+  C372 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
246+  C374 DA 78 C3         jp c,missiles_checkforplayer0
247+  C377 C9               ret
248+  C378              missiles_checkforplayer0:
249+  C378 ED 43 E9 C1      ld (missiles_killermissile),bc; store the coords of the killer missile
250+  C37C CD 5A BA         call player_zonkplayer ; if so, jump out
251+  C37F C9               ret
252+  C380
253+  C380              ;
254+  C380              ; Player has been hit, so draw text over them and mark as dead
255+  C380              ;
256+  C380              missiles_zonkplayer:
257+  C380 CD 48 BA         call player_killplayer      ; mark as dead
258+  C383 ED 4B 60 B9      ld bc,(player)              ; get player coords
259+  C387 CD 53 A8         call screen_getcharcoordsfromscreencoords ; get char coords
260+  C38A 0D               dec c
261+  C38B 0D               dec c
262+  C38C C5               push bc
263+  C38D CD 10 A8         call screen_getcellattradress ; attrs here
264+  C390 06 05            ld b,5
265+  C392 3E 42            ld a,66
266+  C394 CD CA A7         call screen_setcolours
267+  C397 CD 5C A6         call buffer_buffertoscreen  ; copy buffer to screen
268+  C39A C1               pop bc
269+  C39B ED 5B 15 A7      ld de,(screen_offset)
270+  C39F 78               ld a,b
271+  C3A0 93               sub e
272+  C3A1 47               ld b,a                      ; subtract the offset
273+  C3A2 04               inc b
274+  C3A3 04               inc b                       ; add two for the score rows
275+  C3A4 ED 43 BD 84      ld (string_zonk),bc         ; set coords of string
276+  C3A8 21 BD 84         ld hl,string_zonk
277+  C3AB CD C5 84         call string_print
278+  C3AE 06 14            ld b,20
279+  C3B0 CD 82 80         call utilities_pauseforframes ; pause
280+  C3B3 C9               ret
281+  C3B4
# file closed: game/missiles.asm
 46   C3B4                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  C3B4              ;
  2+  C3B4              ; Timer for deciding how fast the trap withdraws
  3+  C3B4              ;
  4+  C3B4              thepit_timer:
  5+  C3B4 00               defb 0
  6+  C3B5
  7+  C3B5              ;
  8+  C3B5              ; Ticks for the trap state. Will count to 3 then reset
  9+  C3B5              ;
 10+  C3B5              thepit_trapcount:
 11+  C3B5 00               defb 0
 12+  C3B6
 13+  C3B6              ;
 14+  C3B6              ; The horizontal coordinate of the current pit trap
 15+  C3B6              ;
 16+  C3B6              thepit_trapcoord:
 17+  C3B6 08               defb 8
 18+  C3B7
 19+  C3B7              ;
 20+  C3B7              ; Initialises the pit
 21+  C3B7              ;
 22+  C3B7              thepit_init:
 23+  C3B7 21 B6 C3         ld hl,thepit_trapcoord
 24+  C3BA 36 08            ld (hl),8
 25+  C3BC 21 B5 C3         ld hl,thepit_trapcount
 26+  C3BF 36 00            ld (hl),0
 27+  C3C1 C9               ret
 28+  C3C2
 29+  C3C2              ;
 30+  C3C2              ; Performs per frame processing on the pit room
 31+  C3C2              ;
 32+  C3C2              thepit_process:
 33+  C3C2 3A 6E B9         ld a,(player_location)
 34+  C3C5 FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 35+  C3C7 C2 0B C4         jp nz,thepit_process0
 36+  C3CA 3A B4 C3         ld a,(thepit_timer)             ; get the timer
 37+  C3CD 3C               inc a
 38+  C3CE 32 B4 C3         ld (thepit_timer),a             ; store
 39+  C3D1 FE 02            cp 2                           ; have we reached the trigger?
 40+  C3D3 C2 0B C4         jp nz, thepit_process0          ; no need to do anything
 41+  C3D6 3E 00            ld a,0
 42+  C3D8 32 B4 C3         ld (thepit_timer),a             ; zero the timer and process
 43+  C3DB 3A B5 C3         ld a,(thepit_trapcount)         ; get the current count
 44+  C3DE 3C               inc a
 45+  C3DF 32 B5 C3         ld (thepit_trapcount),a         ; reset the trap count
 46+  C3E2 FE 04            cp 4                            ; do we need to begin another character?
 47+  C3E4 C2 F3 C3         jp nz,thepit_process1           ; if not, draw as normal
 48+  C3E7 3E 00            ld a,0
 49+  C3E9 32 B5 C3         ld (thepit_trapcount),a         ; reset the trap count
 50+  C3EC 3A B6 C3         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 51+  C3EF 3D               dec a
 52+  C3F0 32 B6 C3         ld (thepit_trapcoord),a         ; store the reduced coord
 53+  C3F3
 54+  C3F3              thepit_process1:                    ; draw the trapdoor in current position
 55+  C3F3 3A B6 C3         ld a,(thepit_trapcoord)
 56+  C3F6 FE 02            cp 2
 57+  C3F8 CA 0B C4         jp z, thepit_process0           ; don't process outside of the pit
 58+  C3FB 4F               ld c,a
 59+  C3FC 06 0A            ld b,10                         ; vertical coord will always be the same
 60+  C3FE 3A B5 C3         ld a,(thepit_trapcount)         ; get the trap count
 61+  C401 5F               ld e,a                          ; store in e
 62+  C402 3E 16            ld a,22                         ; 21 is full trapdoor
 63+  C404 83               add a,e
 64+  C405 CD 97 A8         call screen_getblock
 65+  C408 CD 7D A8         call screen_showchar            ; show the char
 66+  C40B
 67+  C40B              thepit_process0:
 68+  C40B C9               ret
 69+  C40C
# file closed: game/thepit.asm
 47   C40C
 48   C40C              ;===========================================================================
 49   C40C              ; main routine - the code execution starts here.
 50   C40C              ; Sets up the new interrupt routine, the memory
 51   C40C              ; banks and jumps to the start loop.
 52   C40C              ;===========================================================================
 53   C40C              main:
 54   C40C
 55   C40C                  ; Draw the title screen
 56   C40C              main_titlescreen:
 57   C40C CD 57 A9         call titlescreen_show
 58   C40F CD A5 B9         call player_init_gamestart
 59   C412
 60   C412              main_lifestart:
 61   C412
 62   C412 CD C3 B9         call player_init_lifestart
 63   C415
 64   C415 CD BB AA         call lifescreen_draw        ; show the lives remaining screen
 65   C418
 66   C418 CD 00 80         call init_start
 67   C41B CD 30 A7         call screen_draw
 68   C41E CD 8E A6         call buffer_allbuffertoscreen
 69   C421 CD EB C1         call missiles_init
 70   C424 CD 6C BB         call ship_land              ; land the ship
 71   C427 CD 8E BC         call tank_init
 72   C42A CD B3 C1         call diamonds_init
 73   C42D CD B7 C3         call thepit_init
 74   C430
 75   C430              mloop:
 76   C430 76               halt
 77   C431 CD 65 C4         call main_loop_processing
 78   C434
 79   C434                  ;
 80   C434                  ; Check if the player died
 81   C434                  ;
 82   C434 21 6A B9         ld hl,player+10
 83   C437 7E               ld a,(hl)                   ; check if the player died this frame
 84   C438 FE 01            cp 1
 85   C43A C2 51 C4         jp nz,mloop0
 86   C43D CD 2A BA         call player_died        ; do end of life housekeeping
 87   C440 06 28            ld b,40
 88   C442 CD 82 80         call utilities_pauseforframes
 89   C445 21 69 B9         ld hl,player+9        ; check lives remaining
 90   C448 7E               ld a,(hl)
 91   C449 FE 00            cp 0
 92   C44B CA 90 C4         jp z,main_gameover   ; leave the loop if we're done
 93   C44E C3 12 C4         jp main_lifestart    ; otherwise, start a new life
 94   C451              mloop0:
 95   C451                  ;
 96   C451                  ; Check if the player completed the level
 97   C451                  ;
 98   C451 21 6D B9         ld hl,player+13
 99   C454 7E               ld a,(hl)
100   C455 FE 01            cp 1
101   C457 C2 30 C4         jp nz,mloop
102   C45A CD 36 BB         call player_checkforexit
103   C45D FE 01            cp 1                        ; look at return, if 1, level has been completed
104   C45F CA 96 C4         jp z,main_endlevel          ; jump to level transition screen
105   C462 C3 30 C4         jp mloop                ; start the loop again
106   C465
107   C465
108   C465              main_loop_processing:
109   C465
110   C465 CD 5C A6         call buffer_buffertoscreen  ; copy buffer to screen
111   C468 CD DC A5         call buffer_clearlist       ; zero the updated lines list
112   C46B CD 6F B9         call player_getlocation     ; figure out where the player is
113   C46E CD 60 BA         call player_drawplayer      ; delete player
114   C471 CD DD B4         call control_keyboard       ; check keyboard
115   C474 CD 60 BA         call player_drawplayer      ; draw player
116   C477 CD BD BC         call tank_process           ; prcoess the tank
117   C47A CD 57 BB         call ship_process           ; proces the ship
118   C47D CD B7 BE         call rocks_processrocks     ; process falling rocks
119   C480 CD C2 C3         call thepit_process         ; process the pit trap
120   C483 CD 13 C2         call missiles_process       ; process missiles
121   C486 CD 92 C1         call diamonds_twinkle       ; make the diamonds twinkle
122   C489 CD 2B C0         call scores_printscore      ; update the score on screen
123   C48C CD 47 B9         call game_incrementframe    ; increment the game frame
124   C48F
125   C48F C9               ret
126   C490
127   C490              main_gameover:
128   C490 CD 0E AB         call gameover_draw          ; show the game over screen
129   C493 C3 0C C4         jp main_titlescreen         ; go back to title
130   C496
131   C496              main_endlevel:
132   C496 CD 10 BA         call player_recordcurrentscore
133   C499 CD FC AB         call endlevel_draw          ; show the end level screen
134   C49C C3 12 C4         jp main_lifestart           ; start a new life
135   C49F
136   C49F              ;===========================================================================
137   C49F              ; Stack.
138   C49F              ;===========================================================================
139   C49F
140   C49F              ; Stack: this area is reserved for the stack
141   C49F              STACK_SIZE: equ 100    ; in words
142   C49F
143   C49F              ; Reserve stack space
144   C49F 00 00            defw 0  ; WPMEM, 2
145   C4A1              stack_bottom:
146   C4A1 00 00 00...      defs    STACK_SIZE*2, 0
147   C569              stack_top:
148   C569 00 00            defw 0  ; WPMEM, 2
149   C56B
150   C56B                     SAVESNA "ThePit.sna", main
# file closed: main.asm
