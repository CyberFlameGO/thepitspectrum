# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000 CD 6B 0D         call $0D6B
  7+  8003 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8005                                      ; bright (64).
  9+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 10+  8008 AF               xor a               ; quick way to load accumulator with zero.
 11+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 12+  800C CD AF 0D         call 3503           ; ROM routine - clears screen, opens chan 2.
 13+  800F
 14+  800F C9               ret
 15+  8010
 16+  8010              ;
 17+  8010              ;   Start coord
 18+  8010              ;   vert c, horiz b
 19+  8010              start_coord:
 20+  8010 18 30            defb 24,48
 21+  8012
# file closed: init.asm
 21   8012                  include "utilities.asm"
# file opened: utilities.asm
  1+  8012              ; ##########################################################################
  2+  8012              ; Print a character
  3+  8012              ; Inputs:
  4+  8012              ; b - x coord
  5+  8012              ; c - y coord
  6+  8012              ; d - character
  7+  8012              ; e - colour
  8+  8012              ; ##########################################################################
  9+  8012              utilities_print_char:
 10+  8012 7B               ld a,e
 11+  8013 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  8016 3E 16            ld a,22
 13+  8018 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8019 78               ld a,b              ; Gets the X co-ordinate
 15+  801A 3D               dec a
 16+  801B D7               rst 16
 17+  801C 79               ld a,c              ; and the Y co-ordinate
 18+  801D D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  801E 7A               ld a,d              ; ASCII code for udg.
 20+  801F D7               rst 16              ; draw block.
 21+  8020 C9               ret
 22+  8021
 23+  8021
 24+  8021              ;Inputs:
 25+  8021              ;     DE and A are factors
 26+  8021              ;Outputs:
 27+  8021              ;     A is not changed
 28+  8021              ;     B is 0
 29+  8021              ;     C is not changed
 30+  8021              ;     DE is not changed
 31+  8021              ;     HL is the product
 32+  8021              ;Time:
 33+  8021              ;     342+6x
 34+  8021              ;
 35+  8021              utilities_multiply:
 36+  8021 06 08            ld b,8          ;7           7
 37+  8023 21 00 00         ld hl,0         ;10         10
 38+  8026 29               add hl,hl     ;11*8       88
 39+  8027 07               rlca          ;4*8        32
 40+  8028 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  802A 19                   add hl,de   ;--         --
 42+  802B 10 F9            djnz $-5      ;13*7+8     99
 43+  802D C9               ret             ;10         10
 44+  802E
 45+  802E              utilities_waitforkey:
 46+  802E 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  8031 36 00            ld (hl),0           ; put null value there.
 48+  8033              utilities_waitforkey0:
 49+  8033 7E               ld a,(hl)           ; new value of LAST K.
 50+  8034 FE 00            cp 0                ; is it still zero?
 51+  8036 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8038 C9               ret                 ; key was pressed.
 53+  8039
 54+  8039              ;
 55+  8039              ; Waits number of frames for keypress. If got, returns 1, if not 0
 56+  8039              ; Inputs:
 57+  8039              ; a - number of frames to waits
 58+  8039              ; Ouputs:
 59+  8039              ; e - 0 not pressed, 1 pressed
 60+  8039              utilities_waitforkey_forframes:
 61+  8039 21 08 5C         ld hl,23560         ; LAST K system variable.
 62+  803C 36 00            ld (hl),0           ; put null value there.
 63+  803E 47               ld b,a              ; number of frames to wait
 64+  803F              utilities_waitforkey_forframes0:
 65+  803F 7E               ld a,(hl)           ; new value of LAST K.
 66+  8040 FE 00            cp 0                ; is it still zero?
 67+  8042 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 68+  8044 1E 01            ld e,1              ; set the pressed flag
 69+  8046 C9               ret                 ; key was pressed.
 70+  8047              utilities_waitforkey_forframes1:
 71+  8047 76               halt                ; wait for frame
 72+  8048 76               halt                ; wait for frame
 73+  8049 10 F4            djnz utilities_waitforkey_forframes0 ; loop again
 74+  804B 1E 00            ld e,0              ; nothing pressed in time
 75+  804D C9               ret
 76+  804E
 77+  804E
# file closed: utilities.asm
 22   804E                  include "strings.asm"
# file opened: strings.asm
  1+  804E              string_score1:
  2+  804E 04 00 53 43      defb 4,0,'SCORE1',255
  2+  8052 4F 52 45 31
  2+  8056 FF
  3+  8057              string_scorenumbers1:
  4+  8057 04 01 30 30      defb 4,1,'000000',255
  4+  805B 30 30 30 30
  4+  805F FF
  5+  8060              string_company:
  6+  8060 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  8064 4E 54 55 52
  6+  8068 49 FF
  7+  806A              string_credits:
  8+  806A 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  806E 41 59 45 52
  8+  8072 20 31 FF
  9+  8075              string_score2:
 10+  8075 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8079 4F 52 45 32
 10+  807D FF
 11+  807E              string_scorenumbers2:
 12+  807E 16 01 30 30      defb 22,1,'000000',255
 12+  8082 30 30 30 30
 12+  8086 FF
 13+  8087              string_titlescreen_copyright:
 14+  8087 04 16 7F 20      defb 4,22, 127,' 1982 AW ZILEC ELC LTD',255
 14+  808B 31 39 38 32
 14+  808F 20 41 57 20
 14+  8093 5A 49 4C 45
 14+  8097 43 20 45 4C
 14+  809B 43 20 4C 54
 14+  809F 44 FF
 15+  80A1
 16+  80A1
 17+  80A1              string_alttitlescreen_1:
 18+  80A1 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  80A5 45 44 49 54
 18+  80A9 53 20 31 FF
 19+  80AD              string_alttitlescreen_2:
 20+  80AD 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  80B1 20 20 20 20
 20+  80B5 20 20 20 20
 20+  80B9 20 54 48 45
 20+  80BD 20 4F 42 4A
 20+  80C1 45 43 54 FE
 21+  80C5 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  80C9 20 20 20 20
 21+  80CD 20 20 20 20
 21+  80D1 4F 46 20 54
 21+  80D5 48 49 53 20
 21+  80D9 47 41 4D 45
 21+  80DD FE
 22+  80DE 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  80E2 20 20 20 20
 22+  80E6 20 20 20 49
 22+  80EA 53 20 54 4F
 22+  80EE 20 44 49 47
 22+  80F2 20 44 4F 57
 22+  80F6 4E FE
 23+  80F8 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  80FC 20 20 20 20
 23+  8100 20 20 54 4F
 23+  8104 20 54 48 45
 23+  8108 20 42 4F 54
 23+  810C 54 4F 4D 20
 23+  8110 50 49 54 FE
 24+  8114 00 06 20 20      defb 0,6,'               AND',254
 24+  8118 20 20 20 20
 24+  811C 20 20 20 20
 24+  8120 20 20 20 20
 24+  8124 20 41 4E 44
 24+  8128 FE
 25+  8129 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  812D 20 20 20 20
 25+  8131 20 20 43 4F
 25+  8135 4C 4C 45 43
 25+  8139 54 20 41 54
 25+  813D 20 4C 45 41
 25+  8141 53 54 FE
 26+  8144 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  8148 20 20 20 20
 26+  814C 20 20 20 4F
 26+  8150 4E 45 20 4C
 26+  8154 41 52 47 45
 26+  8158 20 4A 45 57
 26+  815C 45 4C FE
 27+  815F 00 09 20 20      defb 0,9,'              THEN',254
 27+  8163 20 20 20 20
 27+  8167 20 20 20 20
 27+  816B 20 20 20 20
 27+  816F 54 48 45 4E
 27+  8173 FE
 28+  8174 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  8178 20 20 20 20
 28+  817C 20 20 20 52
 28+  8180 45 54 55 52
 28+  8184 4E 20 54 4F
 28+  8188 20 53 48 49
 28+  818C 50 FE
 29+  818E 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  8192 20 20 20 20
 29+  8196 20 20 20 54
 29+  819A 48 52 55 20
 29+  819E 55 50 50 45
 29+  81A2 52 20 50 49
 29+  81A6 54 FF
 30+  81A8              string_alttitlescreen_3:
 31+  81A8 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  81AC 20 20 53 49
 31+  81B0 4E 47 4C 45
 31+  81B4 20 42 4F 4E
 31+  81B8 55 53 20 20
 31+  81BC 35 30 30 30
 31+  81C0 20 50 4F 49
 31+  81C4 4E 54 53 FE
 32+  81C8 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  81CC 20 20 20 20
 32+  81D0 43 4F 4C 4C
 32+  81D4 45 43 54 20
 32+  81D8 31 20 4C 41
 32+  81DC 52 47 45 20
 32+  81E0 4A 45 57 45
 32+  81E4 4C FE
 33+  81E6 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  81EA 20 20 20 20
 33+  81EE 20 41 4E 44
 33+  81F2 20 52 45 54
 33+  81F6 55 52 4E 20
 33+  81FA 54 4F 20 53
 33+  81FE 48 49 50 FE
 34+  8202 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  8206 20 20 44 4F
 34+  820A 55 42 4C 45
 34+  820E 20 42 4F 4E
 34+  8212 55 53 20 20
 34+  8216 31 30 30 30
 34+  821A 30 20 50 4F
 34+  821E 49 4E 54 53
 34+  8222 FE
 35+  8223 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  8227 20 20 43 4F
 35+  822B 4C 4C 45 43
 35+  822F 54 20 41 4C
 35+  8233 4C 20 33 20
 35+  8237 4C 41 52 47
 35+  823B 45 20 4A 45
 35+  823F 57 45 4C 53
 35+  8243 FE
 36+  8244 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  8248 20 20 20 20
 36+  824C 20 4F 52 20
 36+  8250 20 20 41 4C
 36+  8254 4C 20 34 20
 36+  8258 53 4D 41 4C
 36+  825C 4C 20 4A 45
 36+  8260 57 45 4C 53
 36+  8264 FE
 37+  8265 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  8269 20 20 54 52
 37+  826D 49 50 4C 45
 37+  8271 20 42 4F 4E
 37+  8275 55 53 20 20
 37+  8279 31 35 30 30
 37+  827D 30 20 50 4F
 37+  8281 49 4E 54 53
 37+  8285 FE
 38+  8286 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  828A 20 20 20 20
 38+  828E 20 43 4F 4C
 38+  8292 4C 45 43 54
 38+  8296 20 41 4C 4C
 38+  829A 20 37 20 4A
 38+  829E 45 57 45 4C
 38+  82A2 53 FF
 39+  82A4
 40+  82A4              ;
 41+  82A4              ; Prints specified string
 42+  82A4              ; Inputs:
 43+  82A4              ; de: pointer to string
 44+  82A4              ; bc: length of string
 45+  82A4              ;
 46+  82A4              ; Print String Data
 47+  82A4              ; First two bytes of string contain X and Y char position, then the string
 48+  82A4              ; Individual strings are terminated with 0xFE
 49+  82A4              ; End of data is terminated with 0xFF
 50+  82A4              ; HL: Address of string
 51+  82A4              ;
 52+  82A4 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
 53+  82A5 23                                   INC HL                          ; Increase HL to the next memory location
 54+  82A6 56                                   LD D,(HL)                       ; Fetch the Y coordinate
 55+  82A7 23                                   INC HL                          ; Increase HL to the next memory location
 56+  82A8 CD BB 82                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
 57+  82AB 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
 58+  82AC 23                                   INC HL                          ; Increase HL to the next character
 59+  82AD FE FE                                CP 0xFE                         ; Compare with 0xFE
 60+  82AF 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
 61+  82B1 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
 62+  82B2 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
 63+  82B3 CD CB 82                             CALL Print_Char                 ; Print the character
 64+  82B6 E1                                   POP HL                          ; Retrieve HL back off the stack
 65+  82B7 1C                                   INC E                           ; Go to the next screen address
 66+  82B8 18 F1                                JR string_print_0               ; Loop back to print next character
 67+  82BA C9                                   RET
 68+  82BB
 69+  82BB              ; Get screen address
 70+  82BB              ; D = Y character position
 71+  82BB              ; E = X character position
 72+  82BB              ; Returns address in DE
 73+  82BB              ;
 74+  82BB 7A           string_getcharaddress:       LD A,D
 75+  82BC E6 07                                AND %00000111
 76+  82BE 1F                                   RRA
 77+  82BF 1F                                   RRA
 78+  82C0 1F                                   RRA
 79+  82C1 1F                                   RRA
 80+  82C2 B3                                   OR E
 81+  82C3 5F                                   LD E,A
 82+  82C4 7A                                   LD A,D
 83+  82C5 E6 18                                AND %00011000
 84+  82C7 F6 40                                OR %01000000
 85+  82C9 57                                   LD D,A
 86+  82CA C9                                   RET                             ; Returns screen address in DE
 87+  82CB
 88+  82CB              ; Print a single character out
 89+  82CB              ; A:  Character to print
 90+  82CB              ; DE: Screen address to print character at
 91+  82CB              ;
 92+  82CB 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
 93+  82CE 06 00                                LD B,0                          ; Set BC to A
 94+  82D0 4F                                   LD C,A
 95+  82D1 E6 FF                                AND 0xFF                        ; Clear the carry bit
 96+  82D3 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
 97+  82D5 CB 10                                RL B
 98+  82D7 CB 11                                RL C
 99+  82D9 CB 10                                RL B
100+  82DB CB 11                                RL C
101+  82DD CB 10                                RL B
102+  82DF 09                                   ADD HL,BC                       ; Get the character address in HL
103+  82E0 0E 08                                LD C,8                          ; Loop counter
104+  82E2 D5                                   PUSH DE
105+  82E3 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
106+  82E4 12                                   LD (DE),A                       ; Stick A onto the screen
107+  82E5 14                                   INC D                           ; Goto next line on screen
108+  82E6 2C                                   INC L                           ; Goto next byte of character
109+  82E7 0D                                   DEC C                           ; Decrease the loop counter
110+  82E8 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
111+  82EA D1                                   POP DE
112+  82EB C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   82EC                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  82EC              screen_buffer:
  2+  82EC 00 00 00...      defs 7424                   ; area reserved for screen
  3+  9FEC
  4+  9FEC              screen_attr_buffer:
  5+  9FEC 00 00 00...      defs 928                    ; attrs buffer area
  6+  A38C
  7+  A38C              screen_offset:
  8+  A38C 00               defb 0                      ; offset from top of screen in lines
  9+  A38D
 10+  A38D              screen_tmp:
 11+  A38D 00               defb 0                      ; temporary memory
 12+  A38E
 13+  A38E              ;
 14+  A38E              ; Copies the buffer to the screen. Use stack.
 15+  A38E              ; Inputs: none
 16+  A38E              ;
 17+  A38E              screen_buffertoscreen:
 18+  A38E 3A 8C A3         ld a,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 19+  A391 11 00 01         ld de,256
 20+  A394 CD 21 80         call utilities_multiply
 21+  A397 54 5D            ld de,hl
 22+  A399 21 EC 82         ld hl,screen_buffer
 23+  A39C 19               add hl,de                   ; add the offset
 24+  A39D ED 73 11 A4      ld (screen_buffertoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
 25+  A3A1 D9               exx
 26+  A3A2 21 50 40         ld hl,16384+80              ; where the actual screen is, but as we're using the stack it's the right hand side of the buffer (16+32+32)
 27+  A3A5              screen_buffertoscreen0:
 28+  A3A5 D9               exx                         ; hl is now buffer
 29+  A3A6 23               inc hl
 30+  A3A7 23               inc hl                      ; move hl forward 2 to skip first two blocks
 31+  A3A8 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
 32+  A3A9 F1               pop af
 33+  A3AA C1               pop bc
 34+  A3AB D1               pop de
 35+  A3AC DD E1            pop ix
 36+  A3AE D9               exx                         ; hl is now screen
 37+  A3AF 08               ex af,af'
 38+  A3B0 F1               pop af
 39+  A3B1 C1               pop bc
 40+  A3B2 D1               pop de
 41+  A3B3 F9               ld sp,hl                    ; sp pointing at screen
 42+  A3B4 D5               push de
 43+  A3B5 C5               push bc
 44+  A3B6 F5               push af
 45+  A3B7 08               ex af,af'
 46+  A3B8 D9               exx                         ; hl is now buffer
 47+  A3B9 DD E5            push ix
 48+  A3BB D5               push de
 49+  A3BC C5               push bc
 50+  A3BD F5               push af
 51+  A3BE 1E 0E            ld e,14                    ; do another fourteen for right hand side
 52+  A3C0 16 00            ld d,0
 53+  A3C2 19               add hl,de
 54+  A3C3 F9               ld sp,hl                    ; sp pointing at buffer
 55+  A3C4 F1               pop af
 56+  A3C5 C1               pop bc
 57+  A3C6 D1               pop de
 58+  A3C7 DD E1            pop ix
 59+  A3C9                  ;pop ix
 60+  A3C9 D9               exx                         ; hl is now screen
 61+  A3CA 08               ex af,af'
 62+  A3CB 1E 0E            ld e,14
 63+  A3CD 16 00            ld d,0
 64+  A3CF 19               add hl,de
 65+  A3D0 F1               pop af
 66+  A3D1 C1               pop bc
 67+  A3D2 D1               pop de
 68+  A3D3                  ;pop iy
 69+  A3D3 F9               ld sp,hl                    ; sp pointing at screen
 70+  A3D4                  ;push iy
 71+  A3D4 D5               push de
 72+  A3D5 C5               push bc
 73+  A3D6 F5               push af
 74+  A3D7 08               ex af,af'
 75+  A3D8 D9               exx                         ; hl is now buffer
 76+  A3D9 DD E5            push ix
 77+  A3DB D5               push de
 78+  A3DC C5               push bc
 79+  A3DD F5               push af
 80+  A3DE 1E 10            ld e,16
 81+  A3E0 16 00            ld d,0
 82+  A3E2 19               add hl,de
 83+  A3E3 D9               exx                         ; hl is now screen
 84+  A3E4 1E 0E            ld e,14
 85+  A3E6 16 00            ld d,0
 86+  A3E8 ED 52            sbc hl,de
 87+  A3EA 24               inc h
 88+  A3EB 7C               ld a,h
 89+  A3EC E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
 90+  A3EE C2 A5 A3         jp nz,screen_buffertoscreen0 ; next line in cell
 91+  A3F1 7C               ld a,h
 92+  A3F2 D6 08            sub 8
 93+  A3F4 67               ld h,a
 94+  A3F5                                              ; check h for the bottom segment
 95+  A3F5 FE 50            cp 80                       ; 80 is the bottom segment
 96+  A3F7 C2 00 A4         jp nz, screen_buffertoscreen2 ; no need to check if not
 97+  A3FA 7D               ld a,l                      ; check if a is 144
 98+  A3FB FE D0            cp 208                      ; means we're at the bottom row which we leave blank for high score_colours
 99+  A3FD CA 10 A4         jp z,screen_buffertoscreen1 ; if so, end
100+  A400              screen_buffertoscreen2:
101+  A400 7D               ld a,l
102+  A401 C6 20            add a,32
103+  A403 6F               ld l,a
104+  A404 D2 A5 A3         jp nc,screen_buffertoscreen0
105+  A407 7C               ld a,h
106+  A408 C6 08            add a,8
107+  A40A 67               ld h,a
108+  A40B FE 58            cp 0x58                     ; 88 in dec
109+  A40D C2 A5 A3         jp nz,screen_buffertoscreen0
110+  A410              screen_buffertoscreen1:
111+  A410 31 00 00         ld sp,0
112+  A413 D9               exx
113+  A414 CD 18 A4         call screen_buffertoattrs
114+  A417 C9               ret
115+  A418
116+  A418              screen_buffertoattrs:
117+  A418 3A 8C A3         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
118+  A41B 11 20 00         ld de,32
119+  A41E CD 21 80         call utilities_multiply
120+  A421 54 5D            ld de,hl
121+  A423 21 EC 9F         ld hl,screen_attr_buffer
122+  A426 19               add hl,de                       ; add the offset
123+  A427 11 40 58         ld de,22528+64                  ; add 32x2 to the attr memory address to account for the top two rows
124+  A42A 01 A0 02         ld bc,672
125+  A42D ED B0            ldir
126+  A42F C9               ret
127+  A430
128+  A430              screen_setscorecolours:
129+  A430 21 E5 AB         ld hl,score_colours
130+  A433 11 00 58         ld de,22528                     ; attrs here
131+  A436 01 40 00         ld bc,64
132+  A439 ED B0            ldir
133+  A43B C9               ret
134+  A43C
135+  A43C              screen_sethighscorecolours:
136+  A43C 21 25 AC         ld hl,high_score_colours
137+  A43F 11 E0 5A         ld de,22528+736                 ; attrs here
138+  A442 01 20 00         ld bc,32
139+  A445 ED B0            ldir
140+  A447 C9               ret
141+  A448
142+  A448              ; Draw the screen
143+  A448              ; Inputs:
144+  A448              ; none
145+  A448              ; Notes:
146+  A448              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
147+  A448              screen_draw:
148+  A448                  ;call clear_screen
149+  A448 0E 00            ld c,0                      ; horiz
150+  A44A 06 00            ld b,0                      ; vert, 0 at top
151+  A44C DD 21 62 A7      ld ix,level01               ; point ix at level data
152+  A450 FD 21 EC 9F      ld iy,screen_attr_buffer    ; point iy at attr data
153+  A454              screen_draw0:
154+  A454 DD 7E 00         ld a,(ix)                   ; load the block number
155+  A457 C5               push bc                     ; store bc, contains loop count
156+  A458 CD 7A A5         call screen_getattr         ; get the memory location for this cell's attr into hl
157+  A45B 7E               ld a,(hl)                   ; get the attr value at the address
158+  A45C FD 77 00         ld (iy),a                   ; load the attr into memory
159+  A45F DD 7E 00         ld a,(ix)                   ; load the block number
160+  A462 CD 6F A5         call screen_getblock        ; get the block data into hl
161+  A465 CD 55 A5         call screen_showchar        ; show this character here
162+  A468 C1               pop bc                      ; get the loop counter back
163+  A469 DD 23            inc ix                      ; increment level location
164+  A46B FD 23            inc iy                      ; increment attr location
165+  A46D 0C               inc c                       ; increment horiz
166+  A46E 79               ld a,c
167+  A46F FE 20            cp 32                       ; check if horiz has reach edge of screen
168+  A471 C2 54 A4         jp nz,screen_draw0          ; if not, loop
169+  A474 0E 00            ld c,0                      ; if so, reset horiz
170+  A476 04               inc b                       ; increment vertical
171+  A477 78               ld a,b
172+  A478 FE 1D            cp 29                       ; check if at bottom
173+  A47A C2 54 A4         jp nz,screen_draw0          ; if not, loop
174+  A47D 21 8D A3         ld hl, screen_tmp
175+  A480 36 09            ld (hl),9                   ; load the block number into memory
176+  A482 DD 21 02 AB      ld ix,level01rocks          ; rock memory
177+  A486 CD C7 A4         call screen_initobjects     ; draw rocks
178+  A489 21 8D A3         ld hl, screen_tmp
179+  A48C 36 0C            ld (hl),12                  ; load the block number into memory
180+  A48E DD 21 9C AB      ld ix,level01missiles       ; missile memory
181+  A492 CD C7 A4         call screen_initobjects     ; draw missiles
182+  A495 CD 99 A4         call screen_setuptext       ; draws text on the screen
183+  A498 C9               ret
184+  A499
185+  A499              ;
186+  A499              ; Sets up text on the screen
187+  A499              ;
188+  A499              screen_setuptext:
189+  A499 CD D1 B4         call scores_showtable
190+  A49C CD 3C A4         call screen_sethighscorecolours
191+  A49F 21 4E 80         ld hl, string_score1
192+  A4A2 CD A4 82         call string_print
193+  A4A5 21 57 80         ld hl, string_scorenumbers1
194+  A4A8 CD A4 82         call string_print
195+  A4AB 21 60 80         ld hl, string_company
196+  A4AE CD A4 82         call string_print
197+  A4B1 21 75 80         ld hl, string_score2
198+  A4B4 CD A4 82         call string_print
199+  A4B7 21 7E 80         ld hl, string_scorenumbers2
200+  A4BA CD A4 82         call string_print
201+  A4BD 21 6A 80         ld hl, string_credits
202+  A4C0 CD A4 82         call string_print
203+  A4C3 CD 30 A4         call screen_setscorecolours
204+  A4C6 C9               ret
205+  A4C7              ;
206+  A4C7              ; Draw initial object positions
207+  A4C7              ; Inputs:
208+  A4C7              ; ix - memory location of objects
209+  A4C7              ; a - graphic
210+  A4C7              screen_initobjects:
211+  A4C7 DD 4E 00         ld c,(ix)                   ; get the horiz coord
212+  A4CA 79               ld a,c
213+  A4CB FE FF            cp 255
214+  A4CD CA F2 A4         jp z,screen_initobjects2
215+  A4D0 DD 23            inc ix                      ; move to next
216+  A4D2 DD 46 00         ld b,(ix)                   ; get the vert coord
217+  A4D5 DD 23            inc ix
218+  A4D7 CD 04 A5         call screen_getcellattradress ; get the memory address of b,c attr into de
219+  A4DA D5               push de
220+  A4DB 3A 8D A3         ld a,(screen_tmp)                  ; get the block number back
221+  A4DE CD 7A A5         call screen_getattr         ; get the memory location for this cell's attr into hl
222+  A4E1 D1               pop de
223+  A4E2 7E               ld a,(hl)                   ; get the attr value at the address
224+  A4E3 12               ld (de),a                   ; load the attr into memory
225+  A4E4 3A 8D A3         ld a,(screen_tmp)                  ; get the block number back
226+  A4E7 CD 6F A5         call screen_getblock        ; get the block data into hl
227+  A4EA CD 55 A5         call screen_showchar        ; show this character here
228+  A4ED
229+  A4ED              screen_initobjects1:
230+  A4ED DD 23            inc ix                      ; move past state
231+  A4EF C3 C7 A4         jp screen_initobjects
232+  A4F2              screen_initobjects2:
233+  A4F2 C9               ret
234+  A4F3
235+  A4F3
236+  A4F3              ;
237+  A4F3              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
238+  A4F3              ; Inputs:
239+  A4F3              ; bc: coords
240+  A4F3              ; Outputs:
241+  A4F3              ; de: memory location
242+  A4F3              ;
243+  A4F3              screen_getcelladdress:
244+  A4F3 78               ld a,b      ; vertical position.
245+  A4F4 E6 18            and 24      ; which segment, 0, 1 or 2?
246+  A4F6 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
247+  A4F8 57               ld d,a      ; this is our high byte.
248+  A4F9 78               ld a,b      ; what was that vertical position again?
249+  A4FA E6 07            and 7       ; which row within segment?
250+  A4FC 0F               rrca        ; multiply row by 32.
251+  A4FD 0F               rrca
252+  A4FE 0F               rrca
253+  A4FF 5F               ld e,a      ; low byte.
254+  A500 79               ld a,c      ; add on y coordinate.
255+  A501 83               add a,e     ; mix with low byte.
256+  A502 5F               ld e,a      ; address of screen position in de.
257+  A503 C9               ret
258+  A504
259+  A504              ;
260+  A504              ; Calculate buffer address of attribute for character at (b, c).
261+  A504              ; Inputs:
262+  A504              ; bc: coords
263+  A504              ; Outputs:
264+  A504              ; de: memory location
265+  A504              ;
266+  A504              screen_getcellattradress:
267+  A504 11 EC 9F         ld de,screen_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
268+  A507 69               ld l,c      ; x position.
269+  A508 26 00            ld h,0      ; 0 h
270+  A50A 19               add hl,de
271+  A50B 54 5D            ld de,hl    ; horiz done
272+  A50D 78               ld a,b      ; do vert
273+  A50E D5               push de
274+  A50F C5               push bc
275+  A510 11 20 00         ld de,32
276+  A513 CD 21 80         call utilities_multiply
277+  A516 C1               pop bc
278+  A517 D1               pop de
279+  A518 19               add hl,de
280+  A519 54 5D            ld de,hl    ; vert done
281+  A51B C9               ret
282+  A51C
283+  A51C              ;
284+  A51C              ; Calculate buffer address of attribute for character at (b, c).
285+  A51C              ; Inputs:
286+  A51C              ; bc: coords
287+  A51C              ; Outputs:
288+  A51C              ; de: memory location
289+  A51C              ;
290+  A51C              screen_getscreenattradress:
291+  A51C 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
292+  A51F 69               ld l,c      ; x position.
293+  A520 26 00            ld h,0      ; 0 h
294+  A522 19               add hl,de
295+  A523 54 5D            ld de,hl    ; horiz done
296+  A525 78               ld a,b      ; do vert
297+  A526 D5               push de
298+  A527 C5               push bc
299+  A528 11 20 00         ld de,32
300+  A52B CD 21 80         call utilities_multiply
301+  A52E C1               pop bc
302+  A52F D1               pop de
303+  A530 19               add hl,de
304+  A531 54 5D            ld de,hl    ; vert done
305+  A533 C9               ret
306+  A534
307+  A534              ;
308+  A534              ; Gets the attr memory location for a screen coord
309+  A534              ; Will overwrite bc
310+  A534              ; Inputs:
311+  A534              ; bc - screen coords
312+  A534              ; Outputs:
313+  A534              ; de - memory location
314+  A534              ; bc - character coords
315+  A534              ;
316+  A534              screen_getattraddressfromscreencoords:
317+  A534 78               ld a,b                          ; get the player block coords of current block
318+  A535 E6 F8            and 248                         ; find closest multiple of eight
319+  A537 0F               rrca
320+  A538 0F               rrca
321+  A539 0F               rrca                ; divide by 8
322+  A53A 47               ld b,a
323+  A53B 79               ld a,c
324+  A53C 48               ld c,b                         ; swap b and c
325+  A53D E6 F8            and 248
326+  A53F 0F               rrca
327+  A540 0F               rrca
328+  A541 0F               rrca                ; divide by 8
329+  A542 47               ld b,a
330+  A543 CD 04 A5         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
331+  A546 C9               ret
332+  A547
333+  A547              ;
334+  A547              ; Get buffer address for a character at b,c - b vert
335+  A547              ; Buffer memory is stored as sequential block
336+  A547              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
337+  A547              ; Inputs:
338+  A547              ; bc - coords
339+  A547              ; Outputs:
340+  A547              ; de - memory location of first byte
341+  A547              screen_getbufferaddress:
342+  A547 21 EC 82         ld hl, screen_buffer    ; first get screen buffer start
343+  A54A 50               ld d,b                  ; then work out vertical offset
344+  A54B 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
345+  A54D 19               add hl,de               ; add to base
346+  A54E 59               ld e,c                  ; then add horizontal offset (c)
347+  A54F 16 00            ld d,0
348+  A551 19               add hl,de               ; add to base
349+  A552 54 5D            ld de,hl
350+  A554 C9               ret
351+  A555
352+  A555              ;
353+  A555              ; Display character hl at (b, c) to buffer.
354+  A555              ; Stored sequentially
355+  A555              ; Inputs:
356+  A555              ; hl: block address
357+  A555              ; bc: coords
358+  A555              ;
359+  A555              screen_showchar:
360+  A555 3E 00            ld a,0
361+  A557 E5               push hl
362+  A558 CD 47 A5         call screen_getbufferaddress ; get the current screen buffer pointer
363+  A55B E1               pop hl
364+  A55C 06 08            ld b,8              ; number of pixels high.
365+  A55E              screen_showchar0:
366+  A55E 7E               ld a,(hl)           ; source graphic.
367+  A55F 12               ld (de),a           ; transfer to screen.
368+  A560 23               inc hl              ; next piece of data.
369+  A561 E5               push hl             ; store hl
370+  A562 62 6B            ld hl,de            ; put de in hl
371+  A564 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
372+  A566 16 00            ld d,0
373+  A568 19               add hl,de              ; add de to hl
374+  A569 54 5D            ld de,hl            ; load back to de
375+  A56B E1               pop hl              ; restore hl
376+  A56C
377+  A56C 10 F0            djnz screen_showchar0 ; repeat
378+  A56E C9               ret
379+  A56F
380+  A56F
381+  A56F              ;
382+  A56F              ; Get cell graphic.
383+  A56F              ; Inputs:
384+  A56F              ; a: block
385+  A56F              ; Outputs:
386+  A56F              ; hl: memory
387+  A56F              ;
388+  A56F              screen_getblock:
389+  A56F 07               rlca                        ; multiply block number by eight.
390+  A570 07               rlca
391+  A571 07               rlca
392+  A572 5F               ld e,a                      ; displacement to graphic address.
393+  A573 16 00            ld d,0                      ; no high byte.
394+  A575 21 45 AC         ld hl,sprites               ; address of character blocks.
395+  A578 19               add hl,de                   ; point to block.
396+  A579 C9               ret
397+  A57A
398+  A57A              ;
399+  A57A              ; Get cell attribute.
400+  A57A              ; Inputs:
401+  A57A              ; a: block
402+  A57A              ; Outputs:
403+  A57A              ; hl: memory
404+  A57A              ;
405+  A57A              screen_getattr:
406+  A57A 5F               ld e,a                      ; displacement to attribute address.
407+  A57B 16 00            ld d,0                      ; no high byte.
408+  A57D 21 B5 AC         ld hl,sprite_attrs          ; address of block attributes.
409+  A580 19               add hl,de                   ; point to attribute.
410+  A581 C9               ret
411+  A582
# file closed: screen/screen.asm
 24   A582                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A582              ;
  2+  A582              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A582              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A582              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A582              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A582              ; routine takes care of all the shifting itself. This means that sprite
  7+  A582              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A582              ; space they would require in pre-shifted form.
  9+  A582              ; Inputs:
 10+  A582              ; hl - sprite data
 11+  A582              ; bc - screen coords
 12+  A582              ;
 13+  A582              sprites_drawsprite7:
 14+  A582 EE 07            xor 7               ; complement last 3 bits.
 15+  A584 3C               inc a               ; add one for luck!
 16+  A585              sprites_drawsprite3:
 17+  A585 CB 11            rl c                ; ...into middle byte...
 18+  A587 CB 12            rl d                ; ...and finally into left character cell.
 19+  A589 3D               dec a               ; count shifts we've done.
 20+  A58A 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A58C                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A58C 79               ld a,c              ; left edge of image is currently in e.
 23+  A58D 4A               ld c,d              ; put right edge there instead.
 24+  A58E 57               ld d,a              ; and the left edge back into c.
 25+  A58F 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A591              sprites_drawsprite:
 27+  A591 ED 43 F6 A5      ld (dispx),bc       ; store coords in dispx for now.
 28+  A595 E5               push hl
 29+  A596 CD D4 A5         call sprites_scadd  ; calculate screen address.
 30+  A599 E1               pop hl
 31+  A59A 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A59C              sprites_drawsprite1:
 33+  A59C 08               ex af,af'           ; store loop counter.
 34+  A59D D5               push de             ; store screen address.
 35+  A59E 4E               ld c,(hl)           ; first sprite graphic.
 36+  A59F 23               inc hl              ; increment poiinter to sprite data.
 37+  A5A0 22 F8 A5         ld (sprtmp),hl      ; store it for later.
 38+  A5A3 16 00            ld d,0              ; blank right byte for now.
 39+  A5A5 78               ld a,b              ; b holds y position.
 40+  A5A6 E6 07            and 7               ; how are we straddling character cells?
 41+  A5A8 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A5AA FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A5AC 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A5AE A7               and a               ; oops, carry flag is set so clear it.
 45+  A5AF              sprites_drawsprite2:
 46+  A5AF CB 19            rr c                ; rotate left byte right...
 47+  A5B1 CB 1A            rr d                ; ...into right byte.
 48+  A5B3 3D               dec a               ; one less shift to do.
 49+  A5B4 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A5B6              sprites_drawsprite0:
 51+  A5B6 E1               pop hl              ; pop screen address from stack.
 52+  A5B7 7E               ld a,(hl)           ; what's there already.
 53+  A5B8 A9               xor c               ; merge in image data.
 54+  A5B9 77               ld (hl),a           ; place onto screen.
 55+  A5BA 23               inc hl
 56+  A5BB 7E               ld a,(hl)           ; what's already there.
 57+  A5BC AA               xor d               ; right edge of sprite image data.
 58+  A5BD 77               ld (hl),a           ; plonk it on screen.
 59+  A5BE 3A F6 A5         ld a,(dispx)        ; vertical coordinate.
 60+  A5C1 3C               inc a               ; next line down.
 61+  A5C2 32 F6 A5         ld (dispx),a        ; store new position.
 62+  A5C5 2B               dec hl
 63+  A5C6 11 20 00         ld de,32            ; add 32 to get to the next row
 64+  A5C9 19               add hl,de           ; add 32
 65+  A5CA              sprites_drawsprite6:
 66+  A5CA EB               ex de,hl            ; screen address in de.
 67+  A5CB 2A F8 A5         ld hl,(sprtmp)      ; restore graphic address.
 68+  A5CE 08               ex af,af'           ; restore loop counter.
 69+  A5CF 3D               dec a               ; decrement it.
 70+  A5D0 C2 9C A5         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 71+  A5D3 C9               ret                 ; job done.
 72+  A5D4
 73+  A5D4              ;
 74+  A5D4              ; This routine returns a buffer address for (c, b) in de (c vert).
 75+  A5D4              ; For example: 0,0 will be at memory offset 0
 76+  A5D4              ; 1,0 (1 down) will be at memory offset 1
 77+  A5D4              ; 0,7 will be at memory offset 0
 78+  A5D4              ; 9,1 will be at memory offset 8+1
 79+  A5D4              ; 8,0 will be at memory offset 256
 80+  A5D4              ; 9,0 will be at memory offset 257
 81+  A5D4              ; Outputs:
 82+  A5D4              ; de - coords
 83+  A5D4              ;
 84+  A5D4              sprites_scadd:
 85+  A5D4 79               ld a,c               ; calculate vertical offset
 86+  A5D5 E6 F8            and 248             ;  to get nearest multiple of 8
 87+  A5D7 0F               rrca
 88+  A5D8 0F               rrca
 89+  A5D9 0F               rrca                ; divide by 8
 90+  A5DA 67               ld h,a
 91+  A5DB 78               ld a,b               ; calculate horizontal offset
 92+  A5DC E6 F8            and 248             ;  to get nearest multiple of 8
 93+  A5DE 0F               rrca
 94+  A5DF 0F               rrca
 95+  A5E0 0F               rrca                ; divide by 8
 96+  A5E1 6F               ld l,a
 97+  A5E2 C5               push bc             ; store the screen coords
 98+  A5E3 44 4D            ld bc,hl            ; load bc with the character coords
 99+  A5E5 CD 47 A5         call screen_getbufferaddress
100+  A5E8 C1               pop bc              ; get back screen coords, de is now memory of character
101+  A5E9 79               ld a,c              ; now add the vertical within the cell
102+  A5EA E6 07            and 7
103+  A5EC 0F               rrca                ; multiply by 32.
104+  A5ED 0F               rrca
105+  A5EE 0F               rrca
106+  A5EF 6F               ld l,a
107+  A5F0 26 00            ld h,0
108+  A5F2 19               add hl,de
109+  A5F3 54 5D            ld de,hl
110+  A5F5 C9               ret
111+  A5F6
112+  A5F6 00           dispx   defb 0           ; general-use coordinates.
113+  A5F7 00           dispy   defb 0
114+  A5F8 00           sprtmp  defb 0           ; sprite temporary address.
115+  A5F9
# file closed: screen/sprites.asm
 25   A5F9                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  A5F9              ;
  2+  A5F9              ; Draws the title screen
  3+  A5F9              ;
  4+  A5F9              titlescreen_show:
  5+  A5F9 CD 70 A6         call titlescreen_init
  6+  A5FC CD 1A A6         call titlescreen_drawtitle
  7+  A5FF 3E FA            ld a,250                              ; wait for 200 frames
  8+  A601 CD 39 80         call utilities_waitforkey_forframes   ; wait for keypress
  9+  A604 7B               ld a,e
 10+  A605 FE 01            cp 1                                  ; was anything pressed?
 11+  A607 C8               ret z                                 ; end titlescreen if so
 12+  A608
 13+  A608 CD 86 A6         call titlescreen_alt_init             ; otherwise, draw alt screen
 14+  A60B CD 36 A6         call titlescreen_alt_drawtitle
 15+  A60E 3E FA            ld a,250                              ; wait for 200 frames
 16+  A610 CD 39 80         call utilities_waitforkey_forframes   ; wait for keypress
 17+  A613 7B               ld a,e
 18+  A614 FE 01            cp 1                                  ; was anything pressed?
 19+  A616 C2 F9 A5         jp nz,titlescreen_show                ; start again if not
 20+  A619 C9               ret
 21+  A61A
 22+  A61A              ;
 23+  A61A              ; Draws the iconic logo
 24+  A61A              ;
 25+  A61A              titlescreen_drawtitle:
 26+  A61A 06 66            ld b,102              ; number of points
 27+  A61C DD 21 96 A6      ld ix,titlescreen_logo_data
 28+  A620              titlescreen_drawtitle0:
 29+  A620 C5               push bc
 30+  A621 DD 4E 00         ld c,(ix)                   ; got horiz
 31+  A624 DD 23            inc ix
 32+  A626 DD 46 00         ld b,(ix)                   ; got vert
 33+  A629 DD 23            inc ix
 34+  A62B CD 1C A5         call screen_getscreenattradress ; memory in de
 35+  A62E 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 36+  A62F 3E 13            ld a,19
 37+  A631 12               ld (de),a
 38+  A632 C1               pop bc
 39+  A633 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 40+  A635 C9               ret
 41+  A636
 42+  A636              ;
 43+  A636              ; Draws the alternate title screen
 44+  A636              ;
 45+  A636              titlescreen_alt_drawtitle:
 46+  A636 21 A1 80         ld hl,string_alttitlescreen_1
 47+  A639 CD A4 82         call string_print
 48+  A63C 21 AD 80         ld hl,string_alttitlescreen_2
 49+  A63F CD A4 82         call string_print
 50+  A642 21 A8 81         ld hl,string_alttitlescreen_3
 51+  A645 CD A4 82         call string_print
 52+  A648 3E 43            ld a,67
 53+  A64A 11 00 58         ld de,22528                         ; top row attrs here
 54+  A64D CD 69 A6         call titlescreen_alt_setcolours
 55+  A650 3E 46            ld a,70
 56+  A652 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 57+  A655 CD 69 A6         call titlescreen_alt_setcolours
 58+  A658 3E 43            ld a,67
 59+  A65A 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 60+  A65D CD 69 A6         call titlescreen_alt_setcolours
 61+  A660 3E 42            ld a,66
 62+  A662 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 63+  A665 CD 69 A6         call titlescreen_alt_setcolours
 64+  A668 C9               ret
 65+  A669
 66+  A669              titlescreen_alt_setcolours:
 67+  A669 06 20            ld b,32
 68+  A66B              titlescreen_alt_setcolours0:
 69+  A66B 12               ld (de),a
 70+  A66C 13               inc de
 71+  A66D 10 FC            djnz titlescreen_alt_setcolours0
 72+  A66F C9               ret
 73+  A670
 74+  A670              ;
 75+  A670              ; Initialises the screen
 76+  A670              ;
 77+  A670              titlescreen_init:
 78+  A670              ; We want a black screen.
 79+  A670 CD 6B 0D         call $0D6B
 80+  A673 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 81+  A675                                      ; bright (64).
 82+  A675 32 8D 5C         ld (23693),a        ; set our screen colours.
 83+  A678 3E 01            ld a,1              ; 2 is the code for red.
 84+  A67A D3 FE            out (254),a         ; write to port 254.
 85+  A67C CD AF 0D         call 3503           ; ROM routine - clears screen, opens chan 2.
 86+  A67F
 87+  A67F 21 87 80         ld hl,string_titlescreen_copyright
 88+  A682 CD A4 82         call string_print
 89+  A685
 90+  A685 C9               ret
 91+  A686
 92+  A686              ;
 93+  A686              ; Initialises the screen
 94+  A686              ;
 95+  A686              titlescreen_alt_init:
 96+  A686              ; We want a black screen.
 97+  A686 CD 6B 0D         call $0D6B
 98+  A689 3E 47            ld a,71             ; white ink (7) on black paper (0),
 99+  A68B                                      ; bright (64).
100+  A68B 32 8D 5C         ld (23693),a        ; set our screen colours.
101+  A68E 3E 00            ld a,0              ; 2 is the code for red.
102+  A690 D3 FE            out (254),a         ; write to port 254.
103+  A692 CD AF 0D         call 3503           ; ROM routine - clears screen, opens chan 2.
104+  A695
105+  A695 C9               ret
106+  A696
107+  A696              ;
108+  A696              ; Horiz, vert
109+  A696              ;
110+  A696              titlescreen_logo_data:
111+  A696 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
111+  A69A 0A 00 0C 00
111+  A69E 0F 00 11 00
111+  A6A2 12 00 13 00
112+  A6A6 09 01 0C 01      defb 9,1,12,1,15,1,17,1
112+  A6AA 0F 01 11 01
113+  A6AE 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
113+  A6B2 0D 02 0E 02
113+  A6B6 0F 02 11 02
113+  A6BA 12 02 13 02
114+  A6BE 09 03 0C 03      defb 9,3,12,3,15,3,17,3
114+  A6C2 0F 03 11 03
115+  A6C6 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
115+  A6CA 0F 04 11 04
115+  A6CE 12 04 13 04
116+  A6D2 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
116+  A6D6 02 06 03 06
116+  A6DA 04 06 05 06
116+  A6DE 06 06 07 06
116+  A6E2 08 06 09 06
116+  A6E6 0A 06 0B 06
117+  A6EA 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
117+  A6EE 12 06 13 06
117+  A6F2 14 06 15 06
117+  A6F6 16 06 17 06
117+  A6FA 18 06 19 06
117+  A6FE 1A 06 1B 06
118+  A702 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20
118+  A706 02 09 02 0A
118+  A70A 02 0B 02 0C
118+  A70E 02 0D 02 0E
118+  A712 02 0F 02 10
118+  A716 02 11 02 12
118+  A71A 02 13 02 14
119+  A71E 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20
119+  A722 19 09 19 0A
119+  A726 19 0B 19 0C
119+  A72A 19 0D 19 0E
119+  A72E 19 0F 19 10
119+  A732 19 11 19 12
119+  A736 19 13 19 14
120+  A73A 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
120+  A73E 05 0B 06 0B
120+  A742 07 0B 08 0B
120+  A746 09 0B 0A 0B
120+  A74A 0B 0B
121+  A74C 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
121+  A750 0B 09 0B 0A
122+  A754 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19,16,20
122+  A758 10 10 10 11
122+  A75C 10 12 10 13
122+  A760 10 14
123+  A762
# file closed: screen/titlescreen.asm
 26   A762
 27   A762                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  A762              ; ###############################################################
  2+  A762              ; Data for level 1
  3+  A762              ; ###############################################################
  4+  A762              level01:
  5+  A762
  6+  A762 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  6+  A766 05 05 05 05
  6+  A76A 05 05 05 05
  6+  A76E 05 05 02 01
  6+  A772 01 01 03 05
  6+  A776 05 05 05 05
  6+  A77A 05 05 05 05
  6+  A77E 05 05 00 00
  7+  A782 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  7+  A786 05 05 05 05
  7+  A78A 05 05 05 05
  7+  A78E 02 01 01 01
  7+  A792 01 01 01 01
  7+  A796 03 05 05 05
  7+  A79A 05 05 05 05
  7+  A79E 05 05 00 00
  8+  A7A2 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
  8+  A7A6 05 05 05 05
  8+  A7AA 05 05 02 01
  8+  A7AE 01 01 01 01
  8+  A7B2 01 01 01 01
  8+  A7B6 01 01 03 05
  8+  A7BA 0D 0D 0D 0D
  8+  A7BE 0D 0D 00 00
  9+  A7C2 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
  9+  A7C6 01 01 00 01
  9+  A7CA 01 01 01 01
  9+  A7CE 01 01 01 01
  9+  A7D2 01 01 01 01
  9+  A7D6 01 01 01 03
  9+  A7DA 05 05 05 05
  9+  A7DE 05 05 00 00
 10+  A7E2 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 10+  A7E6 04 04 04 04
 10+  A7EA 04 04 01 01
 10+  A7EE 01 01 01 01
 10+  A7F2 01 01 01 01
 10+  A7F6 01 01 01 01
 10+  A7FA 01 01 01 01
 10+  A7FE 00 01 00 00
 11+  A802 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 11+  A806 04 04 04 04
 11+  A80A 04 04 04 04
 11+  A80E 01 01 01 01
 11+  A812 01 01 01 01
 11+  A816 01 01 01 01
 11+  A81A 00 00 00 00
 11+  A81E 00 01 00 00
 12+  A822 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 12+  A826 04 01 01 01
 12+  A82A 01 01 04 04
 12+  A82E 04 04 01 01
 12+  A832 01 01 01 01
 12+  A836 01 00 00 00
 12+  A83A 00 01 01 01
 12+  A83E 01 01 00 00
 13+  A842 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 13+  A846 04 04 04 04
 13+  A84A 04 01 04 04
 13+  A84E 04 04 04 04
 13+  A852 04 04 00 00
 13+  A856 00 00 04 04
 13+  A85A 04 04 04 04
 13+  A85E 04 01 00 00
 14+  A862 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 14+  A866 01 04 01 01
 14+  A86A 01 01 04 04
 14+  A86E 04 04 04 04
 14+  A872 04 04 00 04
 14+  A876 04 04 04 04
 14+  A87A 04 04 04 04
 14+  A87E 04 01 00 00
 15+  A882 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 15+  A886 00 00 00 00
 15+  A88A 00 04 04 04
 15+  A88E 04 04 04 04
 15+  A892 04 04 00 04
 15+  A896 04 04 04 04
 15+  A89A 04 04 04 04
 15+  A89E 04 01 00 00
 16+  A8A2 00 00 01 07      defb 00,00,01,07,07,07,07,07,07,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  A8A6 07 07 07 07
 16+  A8AA 07 01 04 04
 16+  A8AE 04 04 04 04
 16+  A8B2 04 04 00 04
 16+  A8B6 04 04 04 04
 16+  A8BA 04 04 04 04
 16+  A8BE 04 01 00 00
 17+  A8C2 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 17+  A8C6 00 00 00 00
 17+  A8CA 00 01 04 04
 17+  A8CE 04 04 04 04
 17+  A8D2 04 04 00 04
 17+  A8D6 04 04 04 04
 17+  A8DA 04 00 00 00
 17+  A8DE 00 01 00 00
 18+  A8E2 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 18+  A8E6 00 00 00 00
 18+  A8EA 00 01 04 04
 18+  A8EE 04 04 04 04
 18+  A8F2 04 04 00 04
 18+  A8F6 04 04 04 04
 18+  A8FA 04 00 04 04
 18+  A8FE 00 01 00 00
 19+  A902 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 19+  A906 06 06 06 06
 19+  A90A 06 01 04 04
 19+  A90E 04 04 04 04
 19+  A912 04 04 00 04
 19+  A916 04 04 04 04
 19+  A91A 04 00 04 04
 19+  A91E 00 01 00 00
 20+  A922 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 20+  A926 06 06 06 06
 20+  A92A 06 01 04 00
 20+  A92E 00 00 00 00
 20+  A932 00 00 00 00
 20+  A936 00 00 00 00
 20+  A93A 00 00 04 04
 20+  A93E 00 01 00 00
 21+  A942 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 21+  A946 06 06 06 06
 21+  A94A 06 01 04 00
 21+  A94E 04 04 04 04
 21+  A952 04 04 00 04
 21+  A956 04 04 00 04
 21+  A95A 04 04 04 04
 21+  A95E 00 01 00 00
 22+  A962 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 22+  A966 06 06 06 06
 22+  A96A 06 01 04 00
 22+  A96E 04 04 04 04
 22+  A972 04 04 00 04
 22+  A976 04 04 00 04
 22+  A97A 04 04 04 04
 22+  A97E 00 01 00 00
 23+  A982 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  A986 01 01 01 01
 23+  A98A 01 01 04 00
 23+  A98E 04 04 04 04
 23+  A992 04 04 00 04
 23+  A996 04 04 00 04
 23+  A99A 04 04 04 04
 23+  A99E 00 01 00 00
 24+  A9A2 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 24+  A9A6 04 04 04 04
 24+  A9AA 04 04 04 00
 24+  A9AE 04 04 04 04
 24+  A9B2 04 04 00 04
 24+  A9B6 04 04 00 00
 24+  A9BA 00 00 04 04
 24+  A9BE 04 01 00 00
 25+  A9C2 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 25+  A9C6 04 04 00 00
 25+  A9CA 00 00 00 00
 25+  A9CE 04 04 04 04
 25+  A9D2 04 04 00 04
 25+  A9D6 04 04 04 04
 25+  A9DA 04 00 04 04
 25+  A9DE 04 01 00 00
 26+  A9E2 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 26+  A9E6 04 04 00 04
 26+  A9EA 04 04 04 04
 26+  A9EE 04 04 04 04
 26+  A9F2 04 04 00 04
 26+  A9F6 04 04 04 04
 26+  A9FA 04 00 04 04
 26+  A9FE 04 01 00 00
 27+  AA02 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 27+  AA06 04 04 00 04
 27+  AA0A 04 04 01 01
 27+  AA0E 01 01 01 01
 27+  AA12 01 01 01 01
 27+  AA16 01 01 01 01
 27+  AA1A 04 00 04 04
 27+  AA1E 04 01 00 00
 28+  AA22 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 28+  AA26 04 04 00 04
 28+  AA2A 04 04 01 00
 28+  AA2E 00 00 00 00
 28+  AA32 00 00 00 00
 28+  AA36 00 00 00 01
 28+  AA3A 04 00 04 04
 28+  AA3E 04 01 00 00
 29+  AA42 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 29+  AA46 04 04 00 04
 29+  AA4A 04 04 01 00
 29+  AA4E 00 00 00 00
 29+  AA52 00 00 00 00
 29+  AA56 00 00 00 01
 29+  AA5A 04 00 04 04
 29+  AA5E 04 01 00 00
 30+  AA62 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  AA66 04 04 00 04
 30+  AA6A 04 04 01 00
 30+  AA6E 00 00 00 00
 30+  AA72 00 00 00 00
 30+  AA76 00 00 00 01
 30+  AA7A 04 00 04 04
 30+  AA7E 04 01 00 00
 31+  AA82 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 31+  AA86 04 04 00 04
 31+  AA8A 04 04 04 00
 31+  AA8E 00 00 00 00
 31+  AA92 00 00 00 00
 31+  AA96 00 00 00 04
 31+  AA9A 04 04 04 04
 31+  AA9E 04 01 00 00
 32+  AAA2 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 32+  AAA6 04 04 04 04
 32+  AAAA 04 04 01 00
 32+  AAAE 00 00 00 00
 32+  AAB2 00 00 00 00
 32+  AAB6 00 00 00 01
 32+  AABA 04 04 04 04
 32+  AABE 04 01 00 00
 33+  AAC2 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,08,00,01,00,08,00,00,01,00,08,00,01,04,04,04,04,04,01,00,00
 33+  AAC6 04 04 04 04
 33+  AACA 04 04 01 00
 33+  AACE 08 00 01 00
 33+  AAD2 08 00 00 01
 33+  AAD6 00 08 00 01
 33+  AADA 04 04 04 04
 33+  AADE 04 01 00 00
 34+  AAE2 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 34+  AAE6 01 01 01 01
 34+  AAEA 01 01 01 01
 34+  AAEE 01 01 01 01
 34+  AAF2 01 01 01 01
 34+  AAF6 01 01 01 01
 34+  AAFA 01 01 01 01
 34+  AAFE 01 01 00 00
 35+  AB02
 36+  AB02              ; ###############################################################
 37+  AB02              ; Rock data: horiz, vert, state
 38+  AB02              ; ###############################################################
 39+  AB02              level01rocks:
 40+  AB02 09 04 00         defb 9,4,0
 41+  AB05 0C 07 00         defb 12,7,0
 42+  AB08 10 07 00         defb 16,7,0
 43+  AB0B 0B 08 00         defb 11,8,0
 44+  AB0E 0A 0A 00         defb 10,10,0
 45+  AB11 0C 0A 00         defb 12,10,0
 46+  AB14 0D 09 00         defb 13,9,0
 47+  AB17 0E 08 00         defb 14,8,0
 48+  AB1A 0F 0B 00         defb 15,11,0
 49+  AB1D 0B 0C 00         defb 11,12,0
 50+  AB20 11 0C 00         defb 17,12,0
 51+  AB23 13 08 00         defb 19,8,0
 52+  AB26 16 09 00         defb 22,9,0
 53+  AB29 13 0A 00         defb 19,10,0
 54+  AB2C 15 0A 00         defb 21,10,0
 55+  AB2F 15 0C 00         defb 21,12,0
 56+  AB32 16 0C 00         defb 22,12,0
 57+  AB35 18 0A 00         defb 24,10,0
 58+  AB38 19 09 00         defb 25,9,0
 59+  AB3B 1C 09 00         defb 28,9,0
 60+  AB3E 1B 0C 00         defb 27,12,0
 61+  AB41 1A 0D 00         defb 26,13,0
 62+  AB44 19 0E 00         defb 25,14,0
 63+  AB47 19 10 00         defb 25,16,0
 64+  AB4A 1A 11 00         defb 26,17,0
 65+  AB4D 1B 11 00         defb 27,17,0
 66+  AB50 1C 12 00         defb 28,18,0
 67+  AB53 1A 13 00         defb 26,19,0
 68+  AB56 1B 15 00         defb 27,21,0
 69+  AB59 1A 17 00         defb 26,23,0
 70+  AB5C 1B 18 00         defb 27,24,0
 71+  AB5F 19 18 00         defb 25,24,0
 72+  AB62 18 17 00         defb 24,23,0
 73+  AB65 13 14 00         defb 19,20,0
 74+  AB68 14 12 00         defb 20,18,0
 75+  AB6B 14 10 00         defb 20,16,0
 76+  AB6E 15 10 00         defb 21,16,0
 77+  AB71 16 12 00         defb 22,18,0
 78+  AB74 11 14 00         defb 17,20,0
 79+  AB77 0D 11 00         defb 13,17,0
 80+  AB7A 0C 13 00         defb 12,19,0
 81+  AB7D 0B 13 00         defb 11,19,0
 82+  AB80 0A 11 00         defb 10,17,0
 83+  AB83 05 12 00         defb 5,18,0
 84+  AB86 07 16 00         defb 7,22,0
 85+  AB89 09 17 00         defb 9,23,0
 86+  AB8C 07 18 00         defb 7,24,0
 87+  AB8F 05 18 00         defb 5,24,0
 88+  AB92 06 19 00         defb 6,25,0
 89+  AB95 08 19 00         defb 8,25,0
 90+  AB98 04 17 00         defb 4,23,0
 91+  AB9B FF               defb 255
 92+  AB9C
 93+  AB9C              level01missiles:
 94+  AB9C 0B 17 00         defb 11,23,0
 95+  AB9F 0B 16 00         defb 11,22,0
 96+  ABA2 0C 17 00         defb 12,23,0
 97+  ABA5 0C 16 00         defb 12,22,0
 98+  ABA8 0D 17 00         defb 13,23,0
 99+  ABAB 0D 16 00         defb 13,22,0
100+  ABAE 0E 17 00         defb 14,23,0
101+  ABB1 0E 16 00         defb 14,22,0
102+  ABB4 0F 17 00         defb 15,23,0
103+  ABB7 0F 16 00         defb 15,22,0
104+  ABBA 10 17 00         defb 16,23,0
105+  ABBD 10 16 00         defb 16,22,0
106+  ABC0 11 17 00         defb 17,23,0
107+  ABC3 11 16 00         defb 17,22,0
108+  ABC6 12 17 00         defb 18,23,0
109+  ABC9 12 16 00         defb 18,22,0
110+  ABCC 13 17 00         defb 19,23,0
111+  ABCF 13 16 00         defb 19,22,0
112+  ABD2 14 17 00         defb 20,23,0
113+  ABD5 14 16 00         defb 20,22,0
114+  ABD8 15 17 00         defb 21,23,0
115+  ABDB 15 16 00         defb 21,22,0
116+  ABDE 16 17 00         defb 22,23,0
117+  ABE1 16 16 00         defb 22,22,0
118+  ABE4 FF               defb 255
119+  ABE5
120+  ABE5              ;
121+  ABE5              ; Score area colours
122+  ABE5              ;
123+  ABE5              score_colours:
124+  ABE5 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
124+  ABE9 47 47 47 47
124+  ABED 47 47 47 42
124+  ABF1 43 43 43 43
124+  ABF5 43 43 43 43
124+  ABF9 42 47 47 47
124+  ABFD 47 47 47 47
124+  AC01 47 47 47 47
125+  AC05 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
125+  AC09 47 47 47 47
125+  AC0D 47 47 47 46
125+  AC11 46 46 46 46
125+  AC15 46 46 46 46
125+  AC19 46 47 47 47
125+  AC1D 47 47 47 47
125+  AC21 47 47 47 47
126+  AC25
127+  AC25              high_score_colours:
128+  AC25 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
128+  AC29 42 42 47 47
128+  AC2D 47 47 47 47
128+  AC31 43 43 43 47
128+  AC35 47 47 47 47
128+  AC39 47 46 46 46
128+  AC3D 47 47 47 47
128+  AC41 47 47 00 00
# file closed: leveldata/level01.asm
 28   AC45                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  AC45              ; Tiles graphics.
  2+  AC45              sprites:
  3+  AC45 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  AC49 00 00 00 00
  4+  AC4D FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  AC51 FF FF FF FF
  5+  AC55 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  AC59 1F 3F 7F FF
  6+  AC5D 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  AC61 F8 FC FE FF
  7+  AC65 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  AC69 55 AA 55 AA
  8+  AC6D 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  AC71 00 00 00 00
  9+  AC75 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  AC79 FF FF FF FF
 10+  AC7D FF FF 00 00      defb    255,255,  0,  0,  0,  0,  0,  0   ; 7, trapdoor
 10+  AC81 00 00 00 00
 11+  AC85 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, gem
 11+  AC89 F1 72 34 18
 12+  AC8D 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  AC91 FE FE FF 7E
 13+  AC95 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  AC99 FE FF 7E 3C
 14+  AC9D 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  ACA1 00 00 FF FF
 15+  ACA5 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 12, missile
 15+  ACA9 FF 7E 3C 18
 16+  ACAD 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  ACB1 00 00 00 00
 17+  ACB5
 18+  ACB5              sprite_attrs:
 19+  ACB5 46               defb    070 ; 0, space
 20+  ACB6 65               defb    101 ; 1, cyan block
 21+  ACB7 4D               defb    077 ; 2, slope left
 22+  ACB8 4D               defb    077 ; 3, slope right
 23+  ACB9 46               defb    070 ; 4, dirt
 24+  ACBA 4E               defb    078 ; 5, sky
 25+  ACBB 4C               defb    076 ; 6, slime
 26+  ACBC 42               defb    066 ; 7, trapdoor
 27+  ACBD 46               defb    070 ; 8, gem
 28+  ACBE 42               defb    066 ; 9, rock
 29+  ACBF 42               defb    066 ; 10, rock 2
 30+  ACC0 49           	defb    073 ; 11, sky, trapdoor
 31+  ACC1 43           	defb    067 ; 12, missile
 32+  ACC2 4A               defb    074 ; 13, sky, red ink (tank)
 33+  ACC3
 34+  ACC3              player_sprite:
 35+  ACC3 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 35+  ACC7 38 3D C3 80
 36+  ACCB 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 36+  ACCF 3C 1C 16 32
 37+  ACD3 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 37+  ACD7 3C 38 68 4C
 38+  ACDB 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 38+  ACDF 1C BC C3 01
 39+  ACE3 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 39+  ACE7 3C 3C 64 0C
 40+  ACEB 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 40+  ACEF 3C 3C 26 30
 41+  ACF3 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 41+  ACF7 1E 5C FD 5F
 42+  ACFB 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 42+  ACFF 4F 8F 19 03
 43+  AD03 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 43+  AD07 F2 F1 98 C0
 44+  AD0B FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 44+  AD0F 48 08 14 2A
 45+  AD13
 46+  AD13              ;
 47+  AD13              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 48+  AD13              ;
 49+  AD13              ship_sprite:
 50+  AD13 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 50+  AD17 03 1F 7F FF
 51+  AD1B 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 51+  AD1F FF FF FF FF
 52+  AD23 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 52+  AD27 FF FF FF FF
 53+  AD2B 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 53+  AD2F C0 F8 FE FF
 54+  AD33 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 54+  AD37 03 03 02 07
 55+  AD3B 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 55+  AD3F FF 0F 07 83
 56+  AD43 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 56+  AD47 FF 10 20 C1
 57+  AD4B 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 57+  AD4F C0 C0 40 E0
 58+  AD53 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 58+  AD57 03 03 02 07
 59+  AD5B F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 59+  AD5F FF 08 04 83
 60+  AD63 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 60+  AD67 FF F0 E0 C1
 61+  AD6B CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 61+  AD6F C0 C0 40 E0
 62+  AD73
 63+  AD73              ;
 64+  AD73              ;  First 8 frames are tank, last frame is the gun barrel
 65+  AD73              ;
 66+  AD73              tank_sprite:
 67+  AD73 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 67+  AD77 7F 00 00 00
 68+  AD7B 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 68+  AD7F FE FF 7F 40
 69+  AD83 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 69+  AD87 03 FF FF 01
 70+  AD8B 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
 70+  AD8F E0 C0 00 00
 71+  AD93 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
 71+  AD97 F7 E1 7F 3F
 72+  AD9B FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
 72+  AD9F 54 16 FF FF
 73+  ADA3 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
 73+  ADA7 9B A8 FF FF
 74+  ADAB FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
 74+  ADAF 9F AF FE FC
 75+  ADB3 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0
 75+  ADB7 1F 00 00 00
# file closed: graphics/graphics.asm
 29   ADBB
 30   ADBB                  include "game\control.asm"
# file opened: game/control.asm
  1+  ADBB              ;
  2+  ADBB              ; Check the keyboard then move
  3+  ADBB              ;
  4+  ADBB              control_keyboard:
  5+  ADBB 3A 81 B1         ld a,(player+5)      ; first, check if the player has pixels left to move
  6+  ADBE FE 00            cp 0
  7+  ADC0 CA C7 AD         jp z, control_keyboard1
  8+  ADC3 CD BC AE         call control_automove
  9+  ADC6 C9               ret
 10+  ADC7              control_keyboard1:
 11+  ADC7 3A 82 B1         ld a,(player+6)      ; next, check if the player is digging
 12+  ADCA FE 00            cp 0
 13+  ADCC CA D3 AD         jp z, control_keyboard0
 14+  ADCF CD FA AD         call control_dig
 15+  ADD2 C9               ret
 16+  ADD3              control_keyboard0:
 17+  ADD3 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 18+  ADD6 ED 78            in a,(c)            ; read keyboard.
 19+  ADD8 47               ld b,a              ; store result in b register.
 20+  ADD9 CB 18            rr b                ; check outermost key (q).
 21+  ADDB D4 05 AF         call nc,control_pl_moveup         ; player up.
 22+  ADDE 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 23+  ADE1 ED 78            in a,(c)            ; read keyboard.
 24+  ADE3 47               ld b,a              ; store result in b register.
 25+  ADE4 CB 18            rr b                ; check outermost key (a).
 26+  ADE6 D4 34 AF         call nc,control_pl_movedown       ; player down.
 27+  ADE9 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 28+  ADEC ED 78            in a,(c)            ; read keyboard.
 29+  ADEE 47               ld b,a              ; store result in b register.
 30+  ADEF CB 18            rr b                ; check outermost key (p).
 31+  ADF1 D4 91 AF         call nc,control_pl_moveright       ; player left.
 32+  ADF4 CB 18            rr b                ; check next key.
 33+  ADF6 D4 61 AF         call nc,control_pl_moveleft       ; player right.
 34+  ADF9 C9               ret
 35+  ADFA
 36+  ADFA              ;
 37+  ADFA              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 38+  ADFA              ;
 39+  ADFA              control_dig:
 40+  ADFA ED 4B 7C B1      ld bc,(player)      ; load the current coords into bc
 41+  ADFE C5               push bc
 42+  ADFF 3A 7E B1         ld a,(player+2)     ; get the direction
 43+  AE02 FE 01            cp 1                ; left
 44+  AE04 CA 1C AE         jp z,control_dig0
 45+  AE07 FE 02            cp 2                ; right
 46+  AE09 CA 31 AE         jp z,control_dig1
 47+  AE0C FE 03            cp 3                ; down
 48+  AE0E CA 55 AE         jp z,control_dig5
 49+  AE11 FE 00            cp 0                ; up
 50+  AE13 CA 45 AE         jp z,control_dig4
 51+  AE16 21 82 B1         ld hl,player+6
 52+  AE19 36 00            ld (hl),0           ; turn off digging
 53+  AE1B C9               ret                 ; return
 54+  AE1C              control_dig0:           ; going left
 55+  AE1C CD D4 A5         call sprites_scadd  ; get the current coord
 56+  AE1F 62 6B            ld hl,de
 57+  AE21 2B               dec hl              ; move one left
 58+  AE22 C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
 59+  AE23 78               ld a,b
 60+  AE24 06 08            ld b,8
 61+  AE26 90               sub b
 62+  AE27 47               ld b,a
 63+  AE28 79               ld a,c
 64+  AE29 0E 08            ld c,8
 65+  AE2B 91               sub c
 66+  AE2C 4F               ld c,a
 67+  AE2D C5               push bc
 68+  AE2E C3 5E AE         jp control_dig2
 69+  AE31              control_dig1:
 70+  AE31 CD D4 A5         call sprites_scadd  ; get the current coord
 71+  AE34 62 6B            ld hl,de
 72+  AE36 23               inc hl              ; move one right
 73+  AE37 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
 74+  AE38 3E 08            ld a,8
 75+  AE3A 80               add a,b
 76+  AE3B 47               ld b,a
 77+  AE3C 79               ld a,c
 78+  AE3D 0E 08            ld c,8
 79+  AE3F 91               sub c
 80+  AE40 4F               ld c,a
 81+  AE41 C5               push bc
 82+  AE42 C3 5E AE         jp control_dig2
 83+  AE45              control_dig4:
 84+  AE45 CD D4 A5         call sprites_scadd  ; get the current coord
 85+  AE48 62 6B            ld hl,de
 86+  AE4A 11 20 00         ld de,32
 87+  AE4D ED 52            sbc hl,de             ; move one up
 88+  AE4F C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
 89+  AE50 0D               dec c
 90+  AE51 C5               push bc
 91+  AE52 C3 76 AE         jp control_dig6
 92+  AE55              control_dig5:
 93+  AE55 CD D4 A5         call sprites_scadd  ; get the current coord
 94+  AE58 62 6B            ld hl,de
 95+  AE5A 24               inc h              ; move one down
 96+  AE5B                                     ; not bothered about working out bc here, since rock will never fall if digging down
 97+  AE5B C3 5E AE         jp control_dig2
 98+  AE5E              ; Normal (not up) digging
 99+  AE5E              control_dig2:
100+  AE5E 3A 84 B1         ld a,(player+8)     ; get the number of rows we need to overwrite
101+  AE61 47               ld b,a              ; rows to copy over
102+  AE62 E5               push hl             ; store the memory location of the first row for later
103+  AE63              control_dig3:
104+  AE63 CD A5 AE         call control_getpixelrow
105+  AE66 77               ld (hl),a           ; load contents into row
106+  AE67 11 20 00         ld de,32
107+  AE6A 19               add hl,de           ; move to next row
108+  AE6B 10 F6            djnz control_dig3
109+  AE6D E1               pop hl              ; get the original memory location back
110+  AE6E 11 20 00         ld de,32
111+  AE71 ED 52            sbc hl,de           ; move to above row, ready for checking for rock
112+  AE73 C3 8C AE         jp control_dig10
113+  AE76              ; Special case for going up
114+  AE76              control_dig6:
115+  AE76 3A 84 B1         ld a,(player+8)     ; get the number of rows we need to overwrite
116+  AE79 47               ld b,a              ; rows to copy over
117+  AE7A              control_dig7:
118+  AE7A CD A5 AE         call control_getpixelrow
119+  AE7D              control_dig12:
120+  AE7D 77               ld (hl),a           ; load empty into row
121+  AE7E 11 20 00         ld de,32
122+  AE81 ED 52            sbc hl,de           ; move up to next row
123+  AE83 0D               dec c               ; decrease c to track rows
124+  AE84 10 F4            djnz control_dig7
125+  AE86 79               ld a,c
126+  AE87 D6 07            sub 7
127+  AE89 C1               pop bc
128+  AE8A 4F               ld c,a
129+  AE8B C5               push bc             ; store the decreased c coord
130+  AE8C              control_dig10:
131+  AE8C DD 21 83 B1      ld ix,player+7
132+  AE90 DD 7E 00         ld a,(ix)     ; get the dig frame number
133+  AE93 3D               dec a
134+  AE94 DD 77 00         ld (ix),a
135+  AE97                  ; call the check for rocks above the removed dirt
136+  AE97 DD 21 82 B1      ld ix,player+6
137+  AE9B DD 7E 00         ld a,(ix)     ; get the dig state
138+  AE9E FE 00            cp 0
139+  AEA0 C1               pop bc
140+  AEA1 CC 81 B3         call z, rocks_checkforfalling ; make the check if we're no longer digging
141+  AEA4 C9               ret
142+  AEA5
143+  AEA5              ;
144+  AEA5              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
145+  AEA5              ; Inputs:
146+  AEA5              ; hl - memory of pixel row
147+  AEA5              ; Outputs:
148+  AEA5              ; a - modified row to write
149+  AEA5              ;
150+  AEA5              control_getpixelrow:
151+  AEA5 3A 83 B1         ld a,(player+7)     ; get the dig frame number
152+  AEA8 FE 00            cp 0                ; is this the last dig
153+  AEAA CA B1 AE         jp z,control_getpixelrow1
154+  AEAD 7E               ld a,(hl)           ; if not, xor with 255 to flip it
155+  AEAE EE FF            xor 255
156+  AEB0 C9               ret
157+  AEB1              control_getpixelrow1:
158+  AEB1 DD 21 82 B1      ld ix,player+6
159+  AEB5 DD 36 00 00      ld (ix),0           ; turn off digging
160+  AEB9 3E 00            ld a,0              ; if it is, load with empty
161+  AEBB C9               ret
162+  AEBC
163+  AEBC              ;
164+  AEBC              ; Auto move the player until pixels is zero
165+  AEBC              ;
166+  AEBC              control_automove:
167+  AEBC 5F               ld e,a              ; store the number of pixels left to move in e
168+  AEBD ED 4B 7C B1      ld bc,(player)      ; load the current coords into bc
169+  AEC1 21 7E B1         ld hl,player+2      ; get the direction
170+  AEC4 7E               ld a,(hl)
171+  AEC5 FE 03            cp 3                ; down
172+  AEC7 CA DB AE         jp z,control_automove3  ; don't need to do anything
173+  AECA FE 00            cp 0                ; going up
174+  AECC CA E7 AE         jp z,control_automove2
175+  AECF FE 01            cp 1                ; going left?
176+  AED1 CA F3 AE         jp z,control_automove0
177+  AED4 78               ld a,b
178+  AED5 3C               inc a               ; if we're going right, increment a twice for two pixels
179+  AED6 3C               inc a
180+  AED7 47               ld b,a
181+  AED8 C3 F7 AE         jp control_automove1
182+  AEDB              control_automove3:
183+  AEDB 79               ld a,c
184+  AEDC 3C               inc a
185+  AEDD 3C               inc a               ; if we're going down, increment twice
186+  AEDE 4F               ld c,a
187+  AEDF FE 90            cp 144
188+  AEE1 CC BF AF         call z, control_scroll_down
189+  AEE4 C3 F7 AE         jp control_automove1
190+  AEE7              control_automove2:
191+  AEE7 79               ld a,c
192+  AEE8 3D               dec a
193+  AEE9 3D               dec a               ; if we're going up, decrement twice
194+  AEEA 4F               ld c,a
195+  AEEB FE 60            cp 96
196+  AEED CC C7 AF         call z, control_scroll_up
197+  AEF0 C3 F7 AE         jp control_automove1
198+  AEF3              control_automove0:
199+  AEF3 78               ld a,b
200+  AEF4 3D               dec a               ; if we're going left, decrement a twice
201+  AEF5 3D               dec a
202+  AEF6 47               ld b,a
203+  AEF7              control_automove1:
204+  AEF7 ED 43 7C B1      ld (player),bc      ; and back to player
205+  AEFB 7B               ld a,e              ; now get the pixel count back
206+  AEFC 3D               dec a               ; decrease by one
207+  AEFD 21 81 B1         ld hl,player+5
208+  AF00 77               ld (hl),a           ; copy back
209+  AF01 CD BF B1         call player_justmoved
210+  AF04 C9               ret
211+  AF05
212+  AF05              ;
213+  AF05              ; Moves the player up
214+  AF05              ;
215+  AF05              control_pl_moveup:
216+  AF05 C5               push bc
217+  AF06 ED 4B 7C B1      ld bc,(player)          ; get the current coords, b horiz, c vert
218+  AF0A 79               ld a,c                  ; load c into the acc
219+  AF0B FE 18            cp 24
220+  AF0D CA 2D AF         jp z,control_pl_moveup0 ; are we at the edge of the screen
221+  AF10 FE 60            cp 96
222+  AF12 DC C7 AF         call c, control_scroll_up
223+  AF15 CD ED B0         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
224+  AF18 F5               push af
225+  AF19 7B               ld a,e                  ; put e in a
226+  AF1A FE 00            cp 0
227+  AF1C CA 2C AF         jp z,control_pl_moveup1 ; don't move if we can't
228+  AF1F F1               pop af
229+  AF20 D6 01            sub 1                   ; subtract 1
230+  AF22 D6 01            sub 1                   ; subtract 1
231+  AF24 4F               ld c,a                  ; load back to c
232+  AF25 ED 43 7C B1      ld (player),bc          ; load back to player
233+  AF29 C3 2D AF         jp control_pl_moveup0
234+  AF2C              control_pl_moveup1:
235+  AF2C F1               pop af                  ; restore af if needed
236+  AF2D              control_pl_moveup0:
237+  AF2D 3E 00            ld a,0
238+  AF2F 32 7E B1         ld (player+2),a        ; set direction to up
239+  AF32 C1               pop bc
240+  AF33 C9               ret
241+  AF34              ;
242+  AF34              ; Moves the player down
243+  AF34              ;
244+  AF34              control_pl_movedown:
245+  AF34 C5               push bc
246+  AF35 ED 4B 7C B1      ld bc,(player)          ; get the current coords, b horiz, c vert
247+  AF39 79               ld a,c                  ; load c into the acc
248+  AF3A FE E0            cp 224
249+  AF3C CA 5A AF         jp z,control_pl_movedown0 ; are we at the edge of the screen
250+  AF3F FE 80            cp 128
251+  AF41 D4 BF AF         call nc, control_scroll_down
252+  AF44 CD C5 B0         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
253+  AF47 F5               push af
254+  AF48 7B               ld a,e                  ; put e in a
255+  AF49 FE 00            cp 0
256+  AF4B CA 59 AF         jp z,control_pl_movedown1 ; don't move if we can't
257+  AF4E F1               pop af
258+  AF4F 3C               inc a                   ; add 1
259+  AF50 3C               inc a                   ; add 1
260+  AF51 4F               ld c,a                  ; load back to c
261+  AF52 ED 43 7C B1      ld (player),bc          ; load back to player
262+  AF56 C3 5A AF         jp control_pl_movedown0
263+  AF59              control_pl_movedown1:
264+  AF59 F1               pop af                  ; restore af if needed
265+  AF5A              control_pl_movedown0:
266+  AF5A 3E 03            ld a,3
267+  AF5C 32 7E B1         ld (player+2),a        ; set direction to down
268+  AF5F C1               pop bc
269+  AF60 C9               ret
270+  AF61              ;
271+  AF61              ; Moves the player left
272+  AF61              ;
273+  AF61              control_pl_moveleft:
274+  AF61 C5               push bc
275+  AF62 ED 4B 7C B1      ld bc,(player)          ; get the current coords, b horiz, c vert
276+  AF66 78               ld a,b                  ; load b into the acc
277+  AF67 FE 10            cp 16
278+  AF69 CA 8A AF         jp z,control_pl_moveleft0 ; are we at the edge of the screen
279+  AF6C CD 47 B1         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
280+  AF6F F5               push af
281+  AF70 7B               ld a,e                  ; put e in a
282+  AF71 FE 00            cp 0
283+  AF73 CA 89 AF         jp z,control_pl_moveleft1 ; don't move if we can't
284+  AF76 21 81 B1         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
285+  AF79 3E 03            ld a,3
286+  AF7B 77               ld (hl),a
287+  AF7C F1               pop af
288+  AF7D D6 01            sub 1                    ; subtract 2
289+  AF7F D6 01            sub 1
290+  AF81 47               ld b,a                  ; load back to c
291+  AF82 ED 43 7C B1      ld (player),bc          ; load back to player
292+  AF86 C3 8A AF         jp control_pl_moveleft0
293+  AF89              control_pl_moveleft1:
294+  AF89 F1               pop af
295+  AF8A              control_pl_moveleft0:
296+  AF8A 3E 01            ld a,1
297+  AF8C 32 7E B1         ld (player+2),a        ; set direction to left
298+  AF8F C1               pop bc
299+  AF90 C9               ret
300+  AF91              ;
301+  AF91              ; Moves the player right
302+  AF91              ;
303+  AF91              control_pl_moveright:
304+  AF91 C5               push bc
305+  AF92 ED 4B 7C B1      ld bc,(player)          ; get the current coords, b horiz, c vert
306+  AF96 78               ld a,b                  ; load b into the acc
307+  AF97 FE F0            cp 240
308+  AF99 CA B8 AF         jp z,control_pl_moveright0 ; are we at the edge of the screen
309+  AF9C CD 1F B1         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
310+  AF9F F5               push af
311+  AFA0 7B               ld a,e                  ; put e in a
312+  AFA1 FE 00            cp 0
313+  AFA3 CA B7 AF         jp z,control_pl_moveright1 ; don't move if we can't
314+  AFA6 21 81 B1         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
315+  AFA9 3E 03            ld a,3
316+  AFAB 77               ld (hl),a
317+  AFAC F1               pop af
318+  AFAD 3C               inc a                   ; add 2
319+  AFAE 3C               inc a
320+  AFAF 47               ld b,a                  ; load back to b
321+  AFB0 ED 43 7C B1      ld (player),bc          ; load back to player
322+  AFB4 C3 B8 AF         jp control_pl_moveright0
323+  AFB7              control_pl_moveright1:
324+  AFB7 F1               pop af                  ; restore af if needed
325+  AFB8              control_pl_moveright0:
326+  AFB8 3E 02            ld a,2
327+  AFBA 32 7E B1         ld (player+2),a        ; set direction to right
328+  AFBD C1               pop bc
329+  AFBE C9               ret
330+  AFBF
331+  AFBF              ;
332+  AFBF              ; Scrolls the screen down
333+  AFBF              ;
334+  AFBF              control_scroll_down:
335+  AFBF F5               push af
336+  AFC0 3E 08            ld a,8
337+  AFC2 32 8C A3         ld (screen_offset),a
338+  AFC5 F1               pop af
339+  AFC6 C9               ret
340+  AFC7
341+  AFC7              ;
342+  AFC7              ; Scrolls the screen up
343+  AFC7              ;
344+  AFC7              control_scroll_up:
345+  AFC7 F5               push af
346+  AFC8 3E 00            ld a,0
347+  AFCA 32 8C A3         ld (screen_offset),a
348+  AFCD F1               pop af
349+  AFCE C9               ret
350+  AFCF
351+  AFCF
352+  AFCF
353+  AFCF
# file closed: game/control.asm
 31   AFCF                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  AFCF              ;
  2+  AFCF              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  3+  AFCF              ; Inputs:
  4+  AFCF              ; hl - memory location of top pixel row
  5+  AFCF              ; bc - screen coords, b horiz, c vert
  6+  AFCF              ; Outputs:
  7+  AFCF              ; e - 0 if not empty, 1 if empty
  8+  AFCF              ;
  9+  AFCF              movement_spaceisempty:
 10+  AFCF 3E 08            ld a,8                          ; 8 rows to check
 11+  AFD1              movement_spaceisempty0:
 12+  AFD1 08               ex af,af'                       ; store the loop counter
 13+  AFD2 7E               ld a,(hl)                       ; get current pixel row
 14+  AFD3 FE 00            cp 0
 15+  AFD5 C2 E9 AF         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 16+  AFD8 79               ld a,c                          ; load the vertical coord
 17+  AFD9 3C               inc a                           ; next row down
 18+  AFDA 11 20 00         ld de,32
 19+  AFDD 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 20+  AFDE 4F               ld c,a                          ; copy vert coord back to c
 21+  AFDF 08               ex af,af'                       ; get loop counter back
 22+  AFE0 3D               dec a                           ; decrease loop counter
 23+  AFE1 C2 D1 AF         jp nz, movement_spaceisempty0
 24+  AFE4 16 00            ld d,0
 25+  AFE6 1E 01            ld e,1                          ; got to end, so space is empty
 26+  AFE8 C9               ret
 27+  AFE9              movement_spaceisempty1:
 28+  AFE9 16 00            ld d,0
 29+  AFEB 1E 00            ld e,0                          ; returning false, ie space not empty
 30+  AFED C9               ret
 31+  AFEE
 32+  AFEE              ;
 33+  AFEE              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
 34+  AFEE              ; Inputs:
 35+  AFEE              ; hl - memory location of top pixel row
 36+  AFEE              ; bc - screen coords, b horiz, c vert
 37+  AFEE              ; Outputs:
 38+  AFEE              ; e - 0 if not empty, 1 if empty
 39+  AFEE              ;
 40+  AFEE              movement_linebelowisempty:
 41+  AFEE 7E               ld a,(hl)                       ; get current pixel row
 42+  AFEF FE 00            cp 0
 43+  AFF1 C2 F9 AF         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
 44+  AFF4 16 00            ld d,0
 45+  AFF6 1E 01            ld e,1                          ; got to end, so space is empty
 46+  AFF8 C9               ret
 47+  AFF9              movement_linebelowisempty1:
 48+  AFF9 16 00            ld d,0
 49+  AFFB 1E 00            ld e,0                          ; returning false, ie space not empty
 50+  AFFD C9               ret
 51+  AFFE
 52+  AFFE              ;
 53+  AFFE              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
 54+  AFFE              ; Inputs:
 55+  AFFE              ; hl - memory location of top pixel row
 56+  AFFE              ; bc - screen coords, b horiz, c vert
 57+  AFFE              ; Outputs:
 58+  AFFE              ; e - 0 if not empty, 1 if empty
 59+  AFFE              ;
 60+  AFFE              movement_lineaboveisempty:
 61+  AFFE 7E               ld a,(hl)                       ; get current pixel row
 62+  AFFF FE 00            cp 0
 63+  B001 C2 09 B0         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
 64+  B004 16 00            ld d,0
 65+  B006 1E 01            ld e,1                          ; got to end, so space is empty
 66+  B008 C9               ret
 67+  B009              movement_lineaboveisempty1:
 68+  B009 16 00            ld d,0
 69+  B00B 1E 00            ld e,0                          ; returning false, ie space not empty
 70+  B00D C9               ret
 71+  B00E
 72+  B00E              ;
 73+  B00E              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
 74+  B00E              ; Inputs:
 75+  B00E              ; hl - memory location of top pixel row
 76+  B00E              ; bc - screen coords, b horiz, c vert
 77+  B00E              ; Outputs:
 78+  B00E              ; none - puts player into digging mode
 79+  B00E              ;
 80+  B00E              movement_spaceisdiggable:
 81+  B00E 3E 08            ld a,8                          ; 8 rows to check
 82+  B010              movement_spaceisdiggable0:
 83+  B010 08               ex af,af'                       ; store the loop counter
 84+  B011 7E               ld a,(hl)                       ; get current pixel row
 85+  B012 FE 00            cp 0
 86+  B014 CA 24 B0         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
 87+  B017 FE 55            cp 85
 88+  B019 CA 24 B0         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
 89+  B01C FE AA            cp 170
 90+  B01E CA 24 B0         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
 91+  B021 C3 3C B0         jp movement_spaceisdiggable1     ; otherwise, stop checking
 92+  B024              movement_spaceisdiggable2:
 93+  B024 79               ld a,c                          ; load the vertical coord
 94+  B025 3C               inc a                           ; next row down
 95+  B026 11 20 00         ld de,32
 96+  B029 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 97+  B02A 4F               ld c,a                          ; copy vert coord back to c
 98+  B02B 08               ex af,af'                       ; get loop counter back
 99+  B02C 3D               dec a                           ; decrease loop counter
100+  B02D C2 10 B0         jp nz, movement_spaceisdiggable0
101+  B030 21 82 B1         ld hl,player+6
102+  B033 36 01            ld (hl),1                       ; set the player into digging mode
103+  B035 23               inc hl
104+  B036 36 05            ld (hl),5                      ; set the number of frame to dig for
105+  B038 23               inc hl
106+  B039 36 08            ld (hl),8                       ; set the number of pixels to dig
107+  B03B C9               ret
108+  B03C              movement_spaceisdiggable1:
109+  B03C 21 82 B1         ld hl,player+6
110+  B03F 36 00            ld (hl),0                       ; set the player out of digging mode
111+  B041 C9               ret
112+  B042
113+  B042              ;
114+  B042              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
115+  B042              ; Inputs:
116+  B042              ; hl - memory location of top pixel row
117+  B042              ; bc - screen coords, b horiz, c vert
118+  B042              ; Outputs:
119+  B042              ; none - puts player into digging mode
120+  B042              ;
121+  B042              movement_spacebelowisdiggable:
122+  B042 7E               ld a,(hl)                       ; get first pixel row
123+  B043 FE 55            cp 85
124+  B045 CA 50 B0         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
125+  B048 FE AA            cp 170
126+  B04A CA 50 B0         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
127+  B04D C3 3C B0         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
128+  B050              movement_spacebelowisdiggable3:
129+  B050 3E 08            ld a,8                          ; rows to check
130+  B052 1E 00            ld e,0                          ; count of rows to dig
131+  B054              movement_spacebelowisdiggable0:
132+  B054 08               ex af,af'                       ; store the loop counter
133+  B055 7E               ld a,(hl)                       ; get current pixel row
134+  B056 FE 55            cp 85
135+  B058 CA 63 B0         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
136+  B05B FE AA            cp 170
137+  B05D CA 63 B0         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
138+  B060 C3 72 B0         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
139+  B063              movement_spacebelowisdiggable4:
140+  B063 1C               inc e                           ; inc count of rows to dig
141+  B064              movement_spacebelowisdiggable2:
142+  B064 79               ld a,c                          ; load the vertical coord
143+  B065 3C               inc a                           ; next row down
144+  B066 D5               push de                         ; need e for later
145+  B067 11 20 00         ld de,32
146+  B06A 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
147+  B06B 4F               ld c,a                          ; copy vert coord back to c
148+  B06C D1               pop de                          ; get e back
149+  B06D 08               ex af,af'                       ; get loop counter back
150+  B06E 3D               dec a                           ; incease loop counter
151+  B06F C2 54 B0         jp nz, movement_spacebelowisdiggable0
152+  B072              movement_spacebelowisdiggable5:
153+  B072 21 82 B1         ld hl,player+6
154+  B075 36 01            ld (hl),1                       ; set the player into digging mode
155+  B077 23               inc hl
156+  B078 36 03            ld (hl),3                      ; set the number of frame to dig for
157+  B07A 23               inc hl
158+  B07B 73               ld (hl),e                       ; set the number of pixels to dig
159+  B07C C9               ret
160+  B07D              movement_spacebelowisdiggable1:
161+  B07D 21 82 B1         ld hl,player+6
162+  B080 36 00            ld (hl),0                       ; set the player out of digging mode
163+  B082 C9               ret
164+  B083
165+  B083              ;
166+  B083              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
167+  B083              ; Inputs:
168+  B083              ; hl - memory location of top pixel row
169+  B083              ; bc - screen coords, b horiz, c vert
170+  B083              ; Outputs:
171+  B083              ; none - puts player into digging mode
172+  B083              ;
173+  B083              movement_spaceaboveisdiggable:
174+  B083 7E               ld a,(hl)                       ; get first pixel row
175+  B084 FE 55            cp 85
176+  B086 CA 91 B0         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
177+  B089 FE AA            cp 170
178+  B08B CA 91 B0         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
179+  B08E C3 3C B0         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
180+  B091              movement_spaceaboveisdiggable3:
181+  B091 3E 08            ld a,8                          ; rows to check
182+  B093 1E 00            ld e,0                          ; count of rows to dig
183+  B095              movement_spaceaboveisdiggable0:
184+  B095 08               ex af,af'                       ; store the loop counter
185+  B096 7E               ld a,(hl)                       ; get current pixel row
186+  B097 FE 55            cp 85
187+  B099 CA A4 B0         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
188+  B09C FE AA            cp 170
189+  B09E CA A4 B0         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
190+  B0A1 C3 B4 B0         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
191+  B0A4              movement_spaceaboveisdiggable4:
192+  B0A4 1C               inc e                           ; inc count of rows to dig
193+  B0A5              movement_spaceaboveisdiggable2:
194+  B0A5 79               ld a,c                          ; load the vertical coord
195+  B0A6 3D               dec a                           ; next row up
196+  B0A7 D5               push de                         ; need e for later
197+  B0A8 11 20 00         ld de,32
198+  B0AB ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
199+  B0AD 4F               ld c,a                          ; copy vert coord back to c
200+  B0AE D1               pop de                          ; get e back
201+  B0AF 08               ex af,af'                       ; get loop counter back
202+  B0B0 3D               dec a                           ; incease loop counter
203+  B0B1 C2 95 B0         jp nz, movement_spaceaboveisdiggable0
204+  B0B4              movement_spaceaboveisdiggable5:
205+  B0B4 21 82 B1         ld hl,player+6
206+  B0B7 36 01            ld (hl),1                       ; set the player into digging mode
207+  B0B9 23               inc hl
208+  B0BA 36 05            ld (hl),5                       ; set the number of frame to dig for
209+  B0BC 23               inc hl
210+  B0BD 73               ld (hl),e                       ; set the number of pixels to dig
211+  B0BE C9               ret
212+  B0BF              movement_spaceaboveisdiggable1:
213+  B0BF 21 82 B1         ld hl,player+6
214+  B0C2 36 00            ld (hl),0                       ; set the player out of digging mode
215+  B0C4 C9               ret
216+  B0C5
217+  B0C5              ;
218+  B0C5              ; Checks if the player can move down
219+  B0C5              ; Inputs:
220+  B0C5              ; bc - player coords, b horiz, c vert
221+  B0C5              ; Outputs:
222+  B0C5              ; de - 1 can move
223+  B0C5              movement_checkcanmove_down:
224+  B0C5 F5               push af
225+  B0C6 C5               push bc
226+  B0C7 CD D4 A5         call sprites_scadd              ; get the memory location of cell into de
227+  B0CA 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
228+  B0CC 24               inc h                       ; memory location of cell beneath now in hl
229+  B0CD CD EE AF         call movement_linebelowisempty       ; check space is empty
230+  B0D0 7B               ld a,e                          ; check space empty flag
231+  B0D1 FE 00            cp 0
232+  B0D3 CA DC B0         jp z, movement_checkcanmove_down1 ; can't move
233+  B0D6 CD BF B1         call player_justmoved
234+  B0D9 C1               pop bc
235+  B0DA F1               pop af
236+  B0DB C9               ret
237+  B0DC              movement_checkcanmove_down1:
238+  B0DC C1               pop bc
239+  B0DD CD D4 A5         call sprites_scadd              ; get the memory location of cell into de
240+  B0E0 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
241+  B0E2 24               inc h
242+  B0E3 C5               push bc
243+  B0E4 CD 42 B0         call movement_spacebelowisdiggable    ; can't move here, but can we dig
244+  B0E7 11 00 00         ld de,0
245+  B0EA C1               pop bc
246+  B0EB F1               pop af
247+  B0EC C9               ret
248+  B0ED
249+  B0ED              ;
250+  B0ED              ; Checks if the player can move up
251+  B0ED              ; Inputs:
252+  B0ED              ; bc - player coords, b horiz, c vert
253+  B0ED              ; Outputs:
254+  B0ED              ; de - 1 can move
255+  B0ED              movement_checkcanmove_up:
256+  B0ED F5               push af
257+  B0EE C5               push bc
258+  B0EF CD D4 A5         call sprites_scadd              ; get the memory location of cell into de
259+  B0F2 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
260+  B0F4 11 20 00         ld de,32
261+  B0F7 ED 52            sbc hl,de                       ; memory location of line above now in hl
262+  B0F9 CD FE AF         call movement_lineaboveisempty       ; check space is empty
263+  B0FC 7B               ld a,e                          ; check space empty flag
264+  B0FD FE 00            cp 0
265+  B0FF CA 0A B1         jp z, movement_checkcanmove_up1 ; can't move
266+  B102 1E 01            ld e,1
267+  B104 CD BF B1         call player_justmoved
268+  B107 C1               pop bc
269+  B108 F1               pop af
270+  B109 C9               ret
271+  B10A              movement_checkcanmove_up1:
272+  B10A C1               pop bc
273+  B10B CD D4 A5         call sprites_scadd              ; get the memory location of cell into de
274+  B10E 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
275+  B110 11 20 00         ld de,32
276+  B113 ED 52            sbc hl,de                       ; memory location of line above now in hl
277+  B115 C5               push bc
278+  B116 CD 83 B0         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
279+  B119 11 00 00         ld de,0
280+  B11C C1               pop bc
281+  B11D F1               pop af
282+  B11E C9               ret
283+  B11F
284+  B11F              ;
285+  B11F              ; Checks if the player can move right
286+  B11F              ; Inputs:
287+  B11F              ; bc - player coords, b horiz, c vert
288+  B11F              ; Outputs:
289+  B11F              ; de - 1 can move
290+  B11F              movement_checkcanmove_right:
291+  B11F F5               push af
292+  B120 C5               push bc
293+  B121 CD D4 A5         call sprites_scadd              ; get the memory location of cell into de
294+  B124 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
295+  B126 23               inc hl                          ; memory location of cell to the right now in hl
296+  B127 CD CF AF         call movement_spaceisempty       ; check space is empty
297+  B12A 7B               ld a,e                          ; check space empty flag
298+  B12B FE 00            cp 0
299+  B12D CA 36 B1         jp z, movement_checkcanmove_right1 ; can't move
300+  B130 CD BF B1         call player_justmoved
301+  B133 C1               pop bc
302+  B134 F1               pop af
303+  B135 C9               ret
304+  B136              movement_checkcanmove_right1:
305+  B136 C1               pop bc
306+  B137 CD D4 A5         call sprites_scadd              ; get the memory location of cell into de
307+  B13A 62 6B            ld hl,de
308+  B13C 23               inc hl                          ; memory location of cell to the right now in hl
309+  B13D C5               push bc
310+  B13E CD 0E B0         call movement_spaceisdiggable    ; can't move here, but can we dig
311+  B141 11 00 00         ld de,0
312+  B144 C1               pop bc
313+  B145 F1               pop af
314+  B146 C9               ret
315+  B147
316+  B147              ;
317+  B147              ; Checks if the player can move left
318+  B147              ; Inputs:
319+  B147              ; bc - player coords, b horiz, c vert
320+  B147              ; Outputs:
321+  B147              ; de - 1 can move
322+  B147              movement_checkcanmove_left:
323+  B147 F5               push af
324+  B148 C5               push bc
325+  B149 CD D4 A5         call sprites_scadd              ; get the memory location of cell into de
326+  B14C 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
327+  B14E 2B               dec hl                          ; memory location of cell to the right now in hl
328+  B14F CD CF AF         call movement_spaceisempty       ; check space is empty
329+  B152 7B               ld a,e                          ; check space empty flag
330+  B153 FE 00            cp 0
331+  B155 CA 5E B1         jp z, movement_checkcanmove_left1 ; can't move
332+  B158 CD BF B1         call player_justmoved
333+  B15B C1               pop bc
334+  B15C F1               pop af
335+  B15D C9               ret
336+  B15E              movement_checkcanmove_left1:
337+  B15E C1               pop bc
338+  B15F CD D4 A5         call sprites_scadd              ; get the memory location of cell into de
339+  B162 62 6B            ld hl,de
340+  B164 2B               dec hl                          ; memory location of cell to the right now in hl
341+  B165 C5               push bc
342+  B166 CD 0E B0         call movement_spaceisdiggable    ; can't move here, but can we dig
343+  B169 11 00 00         ld de,0
344+  B16C C1               pop bc
345+  B16D F1               pop af
346+  B16E C9               ret
# file closed: game/movement.asm
 32   B16F                  include "game\game.asm"
# file opened: game/game.asm
  1+  B16F              ;
  2+  B16F              ; The current frame count, incremented each frame
  3+  B16F              ;
  4+  B16F              game_framenumber:
  5+  B16F 00               defb    0
  6+  B170
  7+  B170              ;
  8+  B170              ; Increment frame number by 1
  9+  B170              ;
 10+  B170              game_incrementframe:
 11+  B170 3A 6F B1         ld a,(game_framenumber)
 12+  B173 3C               inc a
 13+  B174 32 6F B1         ld (game_framenumber),a
 14+  B177 C9               ret
 15+  B178
 16+  B178              ;
 17+  B178              ; Returns current frame
 18+  B178              ; Outputs:
 19+  B178              ; a - current frame
 20+  B178              ;
 21+  B178              game_getcurrentframe:
 22+  B178 3A 6F B1         ld a,(game_framenumber)
 23+  B17B C9               ret
# file closed: game/game.asm
 33   B17C                  include "game\player.asm"
# file opened: game/player.asm
  1+  B17C              ;
  2+  B17C              ;   Data for current player
  3+  B17C              ;   horiz,vert,dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count,move remaining, is digging (0 no), digging count, pixels to dig
  4+  B17C              player:
  5+  B17C 00 00 02 00      defb    0,0,2,0,1,0,0,0,0
  5+  B180 01 00 00 00
  5+  B184 00
  6+  B185              ;
  7+  B185              ; Initializes a player
  8+  B185              ;
  9+  B185              player_init:
 10+  B185 ED 4B 10 80      ld bc,(start_coord)
 11+  B189 ED 43 7C B1      ld (player),bc
 12+  B18D C9               ret
 13+  B18E
 14+  B18E              ;
 15+  B18E              ; Draws the player at the current position or deletes them
 16+  B18E              ;
 17+  B18E              player_drawplayer:
 18+  B18E 3A 7E B1         ld a,(player+2)             ; get the current direction
 19+  B191 FE 03            cp 3
 20+  B193 C2 98 B1         jp nz,player_drawplayer0
 21+  B196 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
 22+  B198              player_drawplayer0:
 23+  B198 5F               ld e,a                      ; store in e
 24+  B199 3A 82 B1         ld a,(player+6)             ; get the dig flag
 25+  B19C FE 01            cp 1
 26+  B19E CA A8 B1         jp z,player_drawplayer1    ; get dig frame
 27+  B1A1 3A 7F B1         ld a,(player+3)             ; this is normal movement so get the current frame
 28+  B1A4 83               add a,e
 29+  B1A5 C3 AD B1         jp player_drawplayer2
 30+  B1A8              player_drawplayer1
 31+  B1A8 3A 7E B1         ld a,(player+2)             ; get the current direction again, because want all four
 32+  B1AB C6 06            add a,6                     ; add direction to 6 to get frame
 33+  B1AD              player_drawplayer2
 34+  B1AD 07               rlca
 35+  B1AE 07               rlca
 36+  B1AF 07               rlca                        ; multiply by eight
 37+  B1B0 6F               ld l,a
 38+  B1B1 26 00            ld h,0
 39+  B1B3 11 C3 AC         ld de,player_sprite
 40+  B1B6 19               add hl,de                   ; load hl with the location of the player sprite data
 41+  B1B7 ED 4B 7C B1      ld bc,(player)              ; load bc with the start coords
 42+  B1BB CD 91 A5         call sprites_drawsprite     ; call the routine to draw the sprite
 43+  B1BE C9               ret
 44+  B1BF
 45+  B1BF
 46+  B1BF              ;
 47+  B1BF              ; Runs after the player just moved. Changes animation frame if required
 48+  B1BF              ;
 49+  B1BF              player_justmoved:
 50+  B1BF D9               exx
 51+  B1C0 3A 80 B1         ld a,(player+4)             ; get the transition count
 52+  B1C3 FE 00            cp 0
 53+  B1C5 CA CB B1         jp z, player_justmoved2     ; if zero reset and change the frame
 54+  B1C8 C3 E5 B1         jp player_justmoved1       ; otherwise decrease and continue
 55+  B1CB              player_justmoved2:
 56+  B1CB                  ; reset and change frame in here
 57+  B1CB 3E 01            ld a,1
 58+  B1CD 32 80 B1         ld (player+4),a            ; reset back to whatever
 59+  B1D0 3A 7F B1         ld a,(player+3)             ; load the frame
 60+  B1D3 FE 03            cp 3                       ; flip between 3 and 0
 61+  B1D5 C2 DD B1         jp nz, player_justmoved4
 62+  B1D8 3E 00            ld a,0
 63+  B1DA C3 DF B1         jp player_justmoved5
 64+  B1DD              player_justmoved4:
 65+  B1DD 3E 03            ld a,3
 66+  B1DF              player_justmoved5:
 67+  B1DF 32 7F B1         ld (player+3),a           ; save back
 68+  B1E2 C3 E9 B1         jp player_justmoved3
 69+  B1E5              player_justmoved1:
 70+  B1E5                  ; decrease count
 71+  B1E5 3D               dec a
 72+  B1E6 32 80 B1         ld (player+4),a
 73+  B1E9              player_justmoved3:
 74+  B1E9 D9               exx;
 75+  B1EA C9               ret
# file closed: game/player.asm
 34   B1EB                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  B1EB              ;
  2+  B1EB              ; Ship initial position: vert,horiz
  3+  B1EB              ;
  4+  B1EB              ship_initpos:
  5+  B1EB 00 24            defb 0,36
  6+  B1ED              ship_initpos2:
  7+  B1ED 00 00            defb 0,0
  8+  B1EF              ship_frame:
  9+  B1EF 00               defb 0
 10+  B1F0              ;
 11+  B1F0              ; The current memory location
 12+  B1F0              ;
 13+  B1F0              ship_current_sprite:
 14+  B1F0 00 00            defb 0,0
 15+  B1F2
 16+  B1F2              ship_current_coords:
 17+  B1F2 00 00            defb 0,0
 18+  B1F4
 19+  B1F4              ;
 20+  B1F4              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 21+  B1F4              ;
 22+  B1F4              ship_land:
 23+  B1F4 ED 4B EB B1      ld bc,(ship_initpos)
 24+  B1F8 ED 43 ED B1      ld (ship_initpos2),bc        ; save the initial position for later use
 25+  B1FC 1E 00            ld e,0                      ; store a flag to track first time round
 26+  B1FE 06 09            ld b,9                      ; move down 8 pixels
 27+  B200              ship_land0:
 28+  B200 C5               push bc
 29+  B201 7B               ld a,e
 30+  B202 D5               push de                     ; store de for next time round
 31+  B203 FE 01            cp 1                        ; check first time flag
 32+  B205 C2 1A B2         jp nz,ship_land1             ; don't draw over previous one if first time
 33+  B208 CD 73 B2         call ship_draw_full         ; delete old one
 34+  B20B CD 57 B2         call ship_change_frame      ; increment the frame
 35+  B20E ED 4B ED B1      ld bc,(ship_initpos2)       ; get the current coords
 36+  B212 81 C6 01         add c,1                     ; move down one pixels
 37+  B215 4F               ld c,a
 38+  B216 ED 43 ED B1      ld (ship_initpos2),bc
 39+  B21A              ship_land1:
 40+  B21A CD 73 B2         call ship_draw_full         ; draw the ship
 41+  B21D CD 6C B2         call ship_draw_screen
 42+  B220 D1               pop de
 43+  B221 1E 01            ld e,1
 44+  B223 C1               pop bc
 45+  B224 10 DA            djnz ship_land0             ; repeat for downward movement
 46+  B226                  ; done moving down
 47+  B226                  ; now move across
 48+  B226 CD 8E B1         call player_drawplayer      ; draw player
 49+  B229 CD 73 B2         call ship_draw_full         ; delete old one
 50+  B22C 1E 00            ld e,0                      ; store a flag to track first time round
 51+  B22E 06 14            ld b,20                      ; move back 20 pixels pixels
 52+  B230              ship_land3:
 53+  B230 C5               push bc
 54+  B231 7B               ld a,e
 55+  B232 D5               push de                     ; store de for next time round
 56+  B233 FE 01            cp 1                        ; check first time flag
 57+  B235 C2 4A B2         jp nz,ship_land2             ; don't draw over previous one if first time
 58+  B238 CD 73 B2         call ship_draw_full         ; delete old one
 59+  B23B CD 57 B2         call ship_change_frame      ; increment the frame
 60+  B23E ED 4B ED B1      ld bc,(ship_initpos2)       ; get the current coords
 61+  B242 78               ld a,b
 62+  B243 D6 01            sub 1                       ; move back one pixels
 63+  B245 47               ld b,a
 64+  B246 ED 43 ED B1      ld (ship_initpos2),bc
 65+  B24A              ship_land2:
 66+  B24A CD 73 B2         call ship_draw_full         ; draw the ship
 67+  B24D CD 6C B2         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 68+  B250 D1               pop de
 69+  B251 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 70+  B253 C1               pop bc
 71+  B254 10 DA            djnz ship_land3             ; repeat for vertical movement
 72+  B256 C9               ret
 73+  B257
 74+  B257              ;
 75+  B257              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
 76+  B257              ;
 77+  B257              ship_change_frame:
 78+  B257 F5               push af
 79+  B258 3A EF B1         ld a,(ship_frame)
 80+  B25B FE 00            cp 0
 81+  B25D CA 65 B2         jp z,ship_change_frame0
 82+  B260 3E 00            ld a,0                      ; flip to 0
 83+  B262 C3 67 B2         jp ship_change_frame1
 84+  B265              ship_change_frame0:
 85+  B265 3E 20            ld a,32                      ; flip to 32
 86+  B267              ship_change_frame1:
 87+  B267 32 EF B1         ld (ship_frame),a            ; save the frame
 88+  B26A F1               pop af
 89+  B26B C9               ret
 90+  B26C
 91+  B26C              ship_draw_screen:
 92+  B26C 76               halt
 93+  B26D F3               di
 94+  B26E CD 8E A3         call screen_buffertoscreen  ; copy buffer to screen
 95+  B271 FB               ei                          ; enable interupts
 96+  B272 C9               ret
 97+  B273
 98+  B273              ship_draw_full:
 99+  B273 21 13 AD         ld hl,ship_sprite
100+  B276 ED 4B ED B1      ld bc,(ship_initpos2)         ; load bc with the start coords
101+  B27A 22 F0 B1         ld (ship_current_sprite),hl  ; put into memory
102+  B27D ED 43 F2 B1      ld (ship_current_coords),bc  ; put into memory
103+  B281 CD A0 B2         call ship_draw
104+  B284 08               ex af,af'
105+  B285 3A EF B1         ld a,(ship_frame)            ; get the animation frame
106+  B288 16 00            ld d,0
107+  B28A 5F               ld e,a
108+  B28B 19               add hl,de
109+  B28C 22 F0 B1         ld (ship_current_sprite),hl  ; put into memory
110+  B28F 08               ex af,af'
111+  B290 ED 4B ED B1      ld bc,(ship_initpos2)         ; load bc with the start coords
112+  B294 81 C6 08         add c,8                      ; move one line down
113+  B297 4F               ld c,a
114+  B298 ED 43 F2 B1      ld (ship_current_coords),bc  ; put into memory
115+  B29C CD A0 B2         call ship_draw
116+  B29F C9               ret
117+  B2A0
118+  B2A0              ;
119+  B2A0              ; Draw the ship
120+  B2A0              ; Inputs:
121+  B2A0              ; None, all in memory
122+  B2A0              ;
123+  B2A0              ship_draw:
124+  B2A0 3E 04            ld a,4                              ; 4 pieces per half
125+  B2A2              ship_draw0:
126+  B2A2 F5               push af
127+  B2A3 2A F0 B1         ld hl,(ship_current_sprite)
128+  B2A6 ED 4B F2 B1      ld bc,(ship_current_coords)         ; load bc with the start coords
129+  B2AA CD 91 A5         call sprites_drawsprite
130+  B2AD 2A F0 B1         ld hl,(ship_current_sprite)
131+  B2B0 ED 4B F2 B1      ld bc,(ship_current_coords)         ; load bc with the start coords
132+  B2B4 11 08 00         ld de,8
133+  B2B7 19               add hl,de
134+  B2B8 80 C6 08         add b,8
135+  B2BB 47               ld b,a
136+  B2BC 22 F0 B1         ld (ship_current_sprite),hl         ; put into memory
137+  B2BF ED 43 F2 B1      ld (ship_current_coords),bc         ; put into memory
138+  B2C3 F1               pop af
139+  B2C4 3D               dec a
140+  B2C5 FE 00            cp 0
141+  B2C7 C2 A2 B2         jp nz,ship_draw0
142+  B2CA
143+  B2CA C9               ret
144+  B2CB
# file closed: game/ship.asm
 35   B2CB                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  B2CB              ;
  2+  B2CB              ; tank initial position: vert,horiz
  3+  B2CB              ;
  4+  B2CB              tank_initpos:
  5+  B2CB 10 D0            defb 16,208
  6+  B2CD              tank_initpos2:
  7+  B2CD 00 00            defb 0,0
  8+  B2CF              tank_frame:
  9+  B2CF 00               defb 0
 10+  B2D0              tank_anim:
 11+  B2D0 11               defb 17
 12+  B2D1              ;
 13+  B2D1              ; The current memory location
 14+  B2D1              ;
 15+  B2D1              tank_current_sprite:
 16+  B2D1 00 00            defb 0,0
 17+  B2D3
 18+  B2D3              tank_current_coords:
 19+  B2D3 00 00            defb 0,0
 20+  B2D5
 21+  B2D5              ;
 22+  B2D5              ; Initialise the tank
 23+  B2D5              ;
 24+  B2D5              tank_init:
 25+  B2D5 ED 4B CB B2      ld bc,(tank_initpos)
 26+  B2D9 ED 43 CD B2      ld (tank_initpos2),bc       ; save the initial position for later use
 27+  B2DD C9               ret
 28+  B2DE
 29+  B2DE              ;
 30+  B2DE              ;   Draw and move the tank
 31+  B2DE              ;   Start processing at frame 200
 32+  B2DE              ;   Don't move if anim is zero
 33+  B2DE              ;   Decrement frame if moved
 34+  B2DE              ;
 35+  B2DE              tank_process:
 36+  B2DE 3A D0 B2         ld a,(tank_anim)
 37+  B2E1 FE 00            cp 0
 38+  B2E3 C8               ret z                       ; return if we've already moved
 39+  B2E4 CD 78 B1         call game_getcurrentframe   ; get the current frame number into a
 40+  B2E7 FE 4B            cp 75
 41+  B2E9 D8               ret c                       ; return if the frame number is below 100
 42+  B2EA CD F5 B2         call tank_move              ; move tank if not
 43+  B2ED 3A D0 B2         ld a,(tank_anim)
 44+  B2F0 3D               dec a
 45+  B2F1 32 D0 B2         ld (tank_anim),a            ; decrease the anim count
 46+  B2F4 C9               ret
 47+  B2F5
 48+  B2F5              tank_move:
 49+  B2F5 ED 4B CD B2      ld bc,(tank_initpos2)
 50+  B2F9 C5               push bc
 51+  B2FA 3A D0 B2         ld a,(tank_anim)
 52+  B2FD FE 11            cp 17                       ; check first time flag
 53+  B2FF CA 11 B3         jp z,tank_move1             ; don't draw over previous one if first time
 54+  B302 CD 16 B3         call tank_draw_full         ; delete old one
 55+  B305 ED 4B CD B2      ld bc,(tank_initpos2)       ; get the current coords
 56+  B309 78               ld a,b
 57+  B30A D6 01            sub 1                       ; move back one pixels
 58+  B30C 47               ld b,a
 59+  B30D ED 43 CD B2      ld (tank_initpos2),bc
 60+  B311              tank_move1:
 61+  B311 CD 16 B3         call tank_draw_full         ; draw the tank
 62+  B314 C1               pop bc
 63+  B315 C9               ret
 64+  B316
 65+  B316              tank_draw_full:
 66+  B316 21 73 AD         ld hl,tank_sprite
 67+  B319 ED 4B CD B2      ld bc,(tank_initpos2)         ; load bc with the start coords
 68+  B31D 22 D1 B2         ld (tank_current_sprite),hl  ; put into memory
 69+  B320 ED 43 D3 B2      ld (tank_current_coords),bc  ; put into memory
 70+  B324 CD 43 B3         call tank_draw
 71+  B327 08               ex af,af'
 72+  B328 3A CF B2         ld a,(tank_frame)            ; get the animation frame
 73+  B32B 16 00            ld d,0
 74+  B32D 5F               ld e,a
 75+  B32E 19               add hl,de
 76+  B32F 22 D1 B2         ld (tank_current_sprite),hl  ; put into memory
 77+  B332 08               ex af,af'
 78+  B333 ED 4B CD B2      ld bc,(tank_initpos2)         ; load bc with the start coords
 79+  B337 81 C6 08         add c,8                      ; move one line down
 80+  B33A 4F               ld c,a
 81+  B33B ED 43 D3 B2      ld (tank_current_coords),bc  ; put into memory
 82+  B33F CD 43 B3         call tank_draw
 83+  B342 C9               ret
 84+  B343
 85+  B343              ;
 86+  B343              ; Draw the tank
 87+  B343              ; Inputs:
 88+  B343              ; None, all in memory
 89+  B343              ;
 90+  B343              tank_draw:
 91+  B343 3E 04            ld a,4                              ; 4 pieces per half
 92+  B345              tank_draw0:
 93+  B345 F5               push af
 94+  B346 2A D1 B2         ld hl,(tank_current_sprite)
 95+  B349 ED 4B D3 B2      ld bc,(tank_current_coords)         ; load bc with the start coords
 96+  B34D CD 91 A5         call sprites_drawsprite
 97+  B350 2A D1 B2         ld hl,(tank_current_sprite)
 98+  B353 ED 4B D3 B2      ld bc,(tank_current_coords)         ; load bc with the start coords
 99+  B357 11 08 00         ld de,8
100+  B35A 19               add hl,de
101+  B35B 80 C6 08         add b,8
102+  B35E 47               ld b,a
103+  B35F 22 D1 B2         ld (tank_current_sprite),hl         ; put into memory
104+  B362 ED 43 D3 B2      ld (tank_current_coords),bc         ; put into memory
105+  B366 F1               pop af
106+  B367 3D               dec a
107+  B368 FE 00            cp 0
108+  B36A C2 45 B3         jp nz,tank_draw0
109+  B36D
110+  B36D C9               ret
111+  B36E
# file closed: game/tank.asm
 36   B36E                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  B36E              ;
  2+  B36E              ; A structure of falling rocks
  3+  B36E              ; Assume we'll never have more than 4 falling at any one time
  4+  B36E              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  B36E              ;
  6+  B36E              rocks_falling:
  7+  B36E 00 00 00 00      defb 0,0,0,0
  8+  B372 00 00 00 00      defb 0,0,0,0
  9+  B376 00 00 00 00      defb 0,0,0,0
 10+  B37A 00 00 00 00      defb 0,0,0,0
 11+  B37E
 12+  B37E              rocks_tmp:
 13+  B37E 00               defb 0
 14+  B37F
 15+  B37F              rocks_tmp2:
 16+  B37F 00 00            defb 0,0
 17+  B381
 18+  B381              ;
 19+  B381              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 20+  B381              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 21+  B381              ; If the pixel row is not the rock bottom, stop checking.
 22+  B381              ; Inputs:
 23+  B381              ; hl- memory location
 24+  B381              ;
 25+  B381              rocks_checkforfalling:
 26+  B381 7E               ld a,(hl)           ; get the pixel row in this memory location
 27+  B382 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 28+  B384 C2 8A B3         jp nz,rocks_checkforfalling2 ; not a rock, stop
 29+  B387 CD 8B B3         call rocks_addrocktofalling ; mark the rock as falling
 30+  B38A              rocks_checkforfalling2:
 31+  B38A C9               ret
 32+  B38B
 33+  B38B              ;
 34+  B38B              ; Adds the rock to the structure that tracks falling rocks
 35+  B38B              ; Inputs:
 36+  B38B              ; hl - memory location of falling rock graphic
 37+  B38B              ; bc - coords of rock, c vert
 38+  B38B              rocks_addrocktofalling:
 39+  B38B C5               push bc             ; store the coords
 40+  B38C 11 6E B3         ld de,rocks_falling
 41+  B38F 06 04            ld b,4              ; number of possible falling rocks
 42+  B391              rocks_addrocktofalling0:
 43+  B391 13               inc de
 44+  B392 13               inc de
 45+  B393 13               inc de              ; move three along to get the state
 46+  B394 1A               ld a,(de)           ; load the state
 47+  B395 FE 00            cp 0                ; check if this is not falling
 48+  B397 C2 AC B3         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 49+  B39A 3E 10            ld a,16             ; load the number of frames to wobble
 50+  B39C 12               ld (de),a
 51+  B39D 1B               dec de              ; move de back to state
 52+  B39E 3E 02            ld a,2
 53+  B3A0 12               ld (de),a           ; set the state to wobbling
 54+  B3A1 1B               dec de              ; move back coords
 55+  B3A2 C1               pop bc              ; get back coords
 56+  B3A3 78               ld a,b
 57+  B3A4 12               ld (de),a           ; store the vertical
 58+  B3A5 1B               dec de
 59+  B3A6 79               ld a,c
 60+  B3A7 12               ld (de),a           ; store the horizontal
 61+  B3A8 C5               push bc
 62+  B3A9 C3 AF B3         jp rocks_addrocktofalling2 ; done
 63+  B3AC              rocks_addrocktofalling1:
 64+  B3AC 13               inc de              ; move memory along to next rock
 65+  B3AD 10 E2            djnz rocks_addrocktofalling0 ; try the next rock
 66+  B3AF              rocks_addrocktofalling2: ; done, return
 67+  B3AF C1               pop bc              ; to tidy up
 68+  B3B0 C9               ret
 69+  B3B1
 70+  B3B1              ;
 71+  B3B1              ; Processes any falling rocks
 72+  B3B1              ;
 73+  B3B1              rocks_processrocks:
 74+  B3B1 DD 21 6E B3      ld ix,rocks_falling
 75+  B3B5 06 04            ld b,4              ; the number of rocks to check
 76+  B3B7              rocks_processrocks0:
 77+  B3B7 C5               push bc             ; store loop count
 78+  B3B8 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 78+  B3BC 46 01
 79+  B3BE DD 23            inc ix
 80+  B3C0 DD 23            inc ix              ; move to the state
 81+  B3C2 DD 7E 00         ld a,(ix)           ; load the state into a
 82+  B3C5 FE 00            cp 0
 83+  B3C7 CA E6 B3         jp z,rocks_processrocks3 ; if not falling, check next
 84+  B3CA FE 02            cp 2
 85+  B3CC C2 DC B3         jp nz, rocks_processrocks2
 86+  B3CF                  ; we're wobbling
 87+  B3CF DD 23            inc ix              ; get frame number for wobble
 88+  B3D1 DD 7E 00         ld a,(ix)           ; get wobble frame into a
 89+  B3D4 CD 6B B4         call rocks_wobble
 90+  B3D7 DD 23            inc ix              ; increment for next
 91+  B3D9 C3 EA B3         jp rocks_processrocks1  ; do next rock
 92+  B3DC              rocks_processrocks2:
 93+  B3DC                  ; we're falling
 94+  B3DC CD EE B3         call rocks_fall
 95+  B3DF DD 23            inc ix
 96+  B3E1 DD 23            inc ix              ; inc ix to get to next
 97+  B3E3 C3 EA B3         jp rocks_processrocks1
 98+  B3E6              rocks_processrocks3:
 99+  B3E6 DD 23            inc ix
100+  B3E8 DD 23            inc ix
101+  B3EA              rocks_processrocks1:
102+  B3EA C1               pop bc              ; get loop count back
103+  B3EB 10 CA            djnz rocks_processrocks0
104+  B3ED C9               ret
105+  B3EE
106+  B3EE              ;
107+  B3EE              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
108+  B3EE              ; bc - coord of current rock graphic on screen
109+  B3EE              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
110+  B3EE              ;
111+  B3EE              rocks_fall:
112+  B3EE DD 2B            dec ix
113+  B3F0 DD 2B            dec ix              ; decrease ix back to coords
114+  B3F2 ED 43 7F B3      ld (rocks_tmp2),bc  ; store original coords
115+  B3F6 3E 03            ld a,3              ; move this number of pixels
116+  B3F8              rocks_fall1:
117+  B3F8 08               ex af,af'
118+  B3F9 DD 4E 00 DD      ld bc,(ix)          ; get current coords
118+  B3FD 46 01
119+  B3FF CD D4 A5         call sprites_scadd  ; get the memory of the coords into de
120+  B402 14               inc d               ; add 256 to get next row
121+  B403 1A               ld a,(de)           ; get the contents of the next row
122+  B404 FE 00            cp 0
123+  B406 C2 56 B4         jp nz,rocks_fall3    ; move the rock if the row is empty
124+  B409 0C               inc c               ; increment the vertical
125+  B40A DD 71 00 DD      ld (ix),bc          ; store the new coords
125+  B40E 70 01
126+  B410 79               ld a,c              ; get the vertical coord into a
127+  B411 E6 07            and 7               ; divisible by 8?
128+  B413 FE 00            cp 0
129+  B415 C2 30 B4         jp nz,rocks_fall4   ; if not, carry on
130+  B418 CD 34 A5         call screen_getattraddressfromscreencoords ; get the attr address into de
131+  B41B 62 6B            ld hl,de
132+  B41D 36 42            ld (hl),66          ; load this square with the yellow colour
133+  B41F DD 4E 00 DD      ld bc,(ix)
133+  B423 46 01
134+  B425 79               ld a,c              ; get vertical
135+  B426 D6 08            sub 8               ; look up one square
136+  B428 4F               ld c,a              ; put a back in c
137+  B429 CD 34 A5         call screen_getattraddressfromscreencoords ; get the attr address into de
138+  B42C 62 6B            ld hl,de
139+  B42E 36 46            ld (hl),70          ; load this square with the yellow colour
140+  B430              rocks_fall4:
141+  B430 08               ex af,af'
142+  B431 3D               dec a
143+  B432 FE 00            cp 0
144+  B434 C2 F8 B3         jp nz,rocks_fall1   ; do another pixel if needed
145+  B437              rocks_fall2:
146+  B437 3E 09            ld a,9              ; rock graphic
147+  B439 ED 4B 7F B3      ld bc,(rocks_tmp2)  ; get the original coords
148+  B43D CD 6F A5         call screen_getblock     ; get the memory into hl
149+  B440 CD 91 A5         call sprites_drawsprite  ; draw the sprite - over the top of the current one
150+  B443 3E 09            ld a,9
151+  B445 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
151+  B449 46 01
152+  B44B CD 6F A5         call screen_getblock     ; get the memory into hl
153+  B44E CD 91 A5         call sprites_drawsprite  ; draw the sprite - over the top of the current one
154+  B451 DD 23            inc ix
155+  B453 DD 23            inc ix                  ; get ix back to state
156+  B455 C9               ret
157+  B456              rocks_fall3:
158+  B456 3E 00            ld a,0              ; set the state to fell
159+  B458 DD 77 02         ld (ix+2),a           ; store the falling state
160+  B45B DD 4E 00 DD      ld bc,(ix)          ; get the coords
160+  B45F 46 01
161+  B461 CD 34 A5         call screen_getattraddressfromscreencoords ; get the attr address into de
162+  B464 62 6B            ld hl,de
163+  B466 36 42            ld (hl),66
164+  B468 C3 37 B4         jp rocks_fall2      ; rejoin main loop
165+  B46B
166+  B46B              ;
167+  B46B              ; Wobbles a rocks
168+  B46B              ; Inputs:
169+  B46B              ; bc - coord of current rock graphic on screen
170+  B46B              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
171+  B46B              ; a - wobble frame
172+  B46B              rocks_wobble:
173+  B46B 3A 7E B3         ld a,(rocks_tmp)    ; get the frame toggle
174+  B46E 1E 09            ld e,9              ; this is the rock frame
175+  B470 83               add a,e             ; add the frame toggle
176+  B471 C5               push bc
177+  B472 CD 6F A5         call screen_getblock     ; get the memory into hl
178+  B475 CD 91 A5         call sprites_drawsprite  ; draw the sprite - over the top of the current one
179+  B478 3A 7E B3         ld a,(rocks_tmp)    ; get the frame toggle against
180+  B47B EE 01            xor 1               ; flip to other state
181+  B47D 32 7E B3         ld (rocks_tmp),a    ; store
182+  B480 1E 09            ld e,9              ; this is the rock frame
183+  B482 83               add a,e             ; add the frame toggle
184+  B483 CD 6F A5         call screen_getblock     ; get the memory into hl
185+  B486 C1               pop bc
186+  B487 CD 91 A5         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
187+  B48A DD 7E 00         ld a,(ix)           ; get the wobble count back
188+  B48D 3D               dec a               ; decrease
189+  B48E DD 77 00         ld (ix),a           ; store
190+  B491 FE 00            cp 0
191+  B493 C0               ret nz              ; if we're not at zero, return
192+  B494 DD 2B            dec ix              ; otherwise look to state location
193+  B496 3E 01            ld a,1              ; set the state to falling
194+  B498 DD 77 00         ld (ix),a           ; store the falling state
195+  B49B DD 23            inc ix              ; set ix back to location of wobble count, and we're done
196+  B49D C9               ret
197+  B49E
# file closed: game/rocks.asm
 37   B49E                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  B49E              ;
  2+  B49E              ; The score of the current player
  3+  B49E              ;
  4+  B49E              scores_current:
  5+  B49E 30 30 30 30      defb '000000'
  5+  B4A2 30 30
  6+  B4A4
  7+  B4A4              ;
  8+  B4A4              ; The current high score table
  9+  B4A4              ;
 10+  B4A4              scores_table:
 11+  B4A4 03 17 47 41      defb 3,23,'GAM',255
 11+  B4A8 4D FF
 12+  B4AA 06 17 30 30      defb 6,23,'00000 ',255
 12+  B4AE 30 30 30 20
 12+  B4B2 FF
 13+  B4B3 0C 17 47 41      defb 12,23,'GAM',255
 13+  B4B7 4D FF
 14+  B4B9 0F 17 30 30      defb 15,23,'00000 ',255
 14+  B4BD 30 30 30 20
 14+  B4C1 FF
 15+  B4C2 15 17 47 41      defb 21,23,'GAM',255
 15+  B4C6 4D FF
 16+  B4C8 18 17 30 30      defb 24,23,'00000 ',255
 16+  B4CC 30 30 30 20
 16+  B4D0 FF
 17+  B4D1
 18+  B4D1              ;
 19+  B4D1              ; Displays the high score table at the bottom of the screen
 20+  B4D1              ;
 21+  B4D1              scores_showtable:
 22+  B4D1 21 A4 B4         ld hl, scores_table
 23+  B4D4 CD A4 82         call string_print
 24+  B4D7 21 AA B4         ld hl, scores_table+6
 25+  B4DA CD A4 82         call string_print
 26+  B4DD 21 B3 B4         ld hl, scores_table+15
 27+  B4E0 CD A4 82         call string_print
 28+  B4E3 21 B9 B4         ld hl, scores_table+21
 29+  B4E6 CD A4 82         call string_print
 30+  B4E9 21 C2 B4         ld hl, scores_table+30
 31+  B4EC CD A4 82         call string_print
 32+  B4EF 21 C8 B4         ld hl, scores_table+36
 33+  B4F2 CD A4 82         call string_print
 34+  B4F5 C9               ret
# file closed: game/scores.asm
 38   B4F6
 39   B4F6              ;===========================================================================
 40   B4F6              ; main routine - the code execution starts here.
 41   B4F6              ; Sets up the new interrupt routine, the memory
 42   B4F6              ; banks and jumps to the start loop.
 43   B4F6              ;===========================================================================
 44   B4F6              main:
 45   B4F6
 46   B4F6                  ; Setup stack
 47   B4F6 31 F4 B5         ld sp,stack_top
 48   B4F9
 49   B4F9                  ; Draw the title screen
 50   B4F9 CD F9 A5         call titlescreen_show
 51   B4FC
 52   B4FC CD 00 80         call init_start
 53   B4FF CD 48 A4         call screen_draw
 54   B502 CD 85 B1         call player_init
 55   B505 CD F4 B1         call ship_land              ; land the ship
 56   B508 CD D5 B2         call tank_init
 57   B50B
 58   B50B              mloop:
 59   B50B 76               halt
 60   B50C CD 12 B5         call main_loop_processing
 61   B50F C3 0B B5         jp mloop
 62   B512
 63   B512              main_loop_processing:
 64   B512 F3               di
 65   B513 CD 8E A3         call screen_buffertoscreen  ; copy buffer to screen
 66   B516 FB               ei                          ; enable interupts
 67   B517
 68   B517 CD 8E B1         call player_drawplayer      ; delete player
 69   B51A CD BB AD         call control_keyboard       ; check keyboard
 70   B51D CD 8E B1         call player_drawplayer      ; draw player
 71   B520 CD DE B2         call tank_process           ; prcoess the tank
 72   B523 CD B1 B3         call rocks_processrocks     ; process falling rocks
 73   B526
 74   B526 CD 70 B1         call game_incrementframe    ; increment the game frame
 75   B529
 76   B529 C9               ret
 77   B52A
 78   B52A              ;===========================================================================
 79   B52A              ; Stack.
 80   B52A              ;===========================================================================
 81   B52A
 82   B52A              ; Stack: this area is reserved for the stack
 83   B52A              STACK_SIZE: equ 100    ; in words
 84   B52A
 85   B52A              ; Reserve stack space
 86   B52A 00 00            defw 0  ; WPMEM, 2
 87   B52C              stack_bottom:
 88   B52C 00 00 00...      defs    STACK_SIZE*2, 0
 89   B5F4              stack_top:
 90   B5F4 00 00            defw 0  ; WPMEM, 2
 91   B5F6
 92   B5F6                     SAVESNA "ThePit.sna", main
# file closed: main.asm
