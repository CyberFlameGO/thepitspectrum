# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 7E 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 06 A8         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 07 A8         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 3C A6         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD 6D BD         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 20 0A            jr nz,utilities_waitforkey1           ; yes, so no key pressed.
 52+  8051 01 1F 00         ld bc,31                        ; Kempston joystick port.
 53+  8054 ED 78            in a,(c)                        ; read input.
 54+  8056 E6 10            and 16
 55+  8058 CA 4C 80         jp z,utilities_waitforkey0
 56+  805B              utilities_waitforkey1:
 57+  805B C9               ret                 ; key was pressed.
 58+  805C
 59+  805C              ;
 60+  805C              ; Waits number of frames for keypress. If got, returns 1, if not 0
 61+  805C              ; Inputs:
 62+  805C              ; a - number of frames to waits
 63+  805C              ; Ouputs:
 64+  805C              ; e - 0 not pressed, 1 pressed
 65+  805C              utilities_waitforkey_forframes:
 66+  805C 21 08 5C         ld hl,23560         ; LAST K system variable.
 67+  805F 36 00            ld (hl),0           ; put null value there.
 68+  8061 47               ld b,a              ; number of frames to wait
 69+  8062              utilities_waitforkey_forframes0:
 70+  8062 7E               ld a,(hl)           ; new value of LAST K.
 71+  8063 FE 00            cp 0                ; is it still zero?
 72+  8065 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 73+  8067 1E 01            ld e,1              ; set the pressed flag
 74+  8069 C9               ret                 ; key was pressed.
 75+  806A              utilities_waitforkey_forframes1:
 76+  806A 01 1F 00         ld bc,31                        ; Kempston joystick port.
 77+  806D ED 78            in a,(c)                        ; read input.
 78+  806F E6 10            and 16
 79+  8071 CA 77 80         jp z,utilities_waitforkey_forframes2
 80+  8074 1E 01            ld e,1              ; set the pressed flag
 81+  8076 C9               ret                 ; key was pressed.
 82+  8077              utilities_waitforkey_forframes2:
 83+  8077 76               halt                ; wait for frame
 84+  8078 76               halt                ; wait for frame
 85+  8079 10 E7            djnz utilities_waitforkey_forframes0 ; loop again
 86+  807B 1E 00            ld e,0              ; nothing pressed in time
 87+  807D C9               ret
 88+  807E
 89+  807E              ;
 90+  807E              ; Clears the screen
 91+  807E              ; Inputs:
 92+  807E              ; a - attribute colour
 93+  807E              utilities_clearscreen:
 94+  807E 76               halt
 95+  807F 21 00 58         ld hl,22528         ; attr
 96+  8082 11 01 58         ld de,22529         ; attr+1
 97+  8085 01 FF 02         ld bc,767
 98+  8088 77               ld (hl),a
 99+  8089 ED B0            ldir
100+  808B
101+  808B 21 00 40         ld hl, 16384        ;pixels
102+  808E 11 01 40         ld de, 16385        ;pixels + 1
103+  8091 01 FF 17         ld bc, 6143         ;pixels area length - 1
104+  8094 36 00            ld (hl), 0          ;set first byte to '0'
105+  8096 ED B0            ldir                ;copy bytes
106+  8098
107+  8098 C9               ret
108+  8099
109+  8099              ;
110+  8099              ; Wait for a number of frames
111+  8099              ; Inputs:
112+  8099              ; b - number of frames
113+  8099              utilities_pauseforframes:
114+  8099 76               halt
115+  809A 10 FD            djnz utilities_pauseforframes
116+  809C C9               ret
117+  809D
118+  809D              utilities_readkey:
119+  809D 21 BD 80         LD HL,utilties_keymap              ; Point HL at the keyboard list
120+  80A0 16 08            LD D,8                                  ; This is the number of ports (rows) to check
121+  80A2 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
122+  80A4              utilities_readkey_0:
123+  80A4 46               LD B,(HL)                               ; Get the keyboard port address from table
124+  80A5 23               INC HL                                  ; Increment to list of keys
125+  80A6 ED 78            IN A,(C)                                ; Read the row of keys in
126+  80A8 E6 1F            AND $1F                                     ; We are only interested in the first five bits
127+  80AA 1E 05            LD E,5                                  ; This is the number of keys in the row
128+  80AC              utilities_readkey_1:
129+  80AC CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
130+  80AE 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
131+  80B0 23               INC HL                                  ; Go to next table address
132+  80B1 1D               DEC E                                   ; Decrement key loop counter
133+  80B2 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
134+  80B4 15               DEC D                                   ; Decrement row loop counter
135+  80B5 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
136+  80B7 A7               AND A                                   ; Clear A (no key found)
137+  80B8 C3 9D 80         jp utilities_readkey
138+  80BB              utilities_readkey_2:
139+  80BB 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
140+  80BC C9               RET
141+  80BD
142+  80BD              utilties_keymap:
143+  80BD FE 23 5A 58      defb $FE,"#","Z","X","C","V"
143+  80C1 43 56
144+  80C3 FD 41 53 44      defb $FD,"A","S","D","F","G"
144+  80C7 46 47
145+  80C9 FB 51 57 45      defb $FB,"Q","W","E","R","T"
145+  80CD 52 54
146+  80CF F7 31 32 33      defb $F7,"1","2","3","4","5"
146+  80D3 34 35
147+  80D5 EF 30 39 38      defb $EF,"0","9","8","7","6"
147+  80D9 37 36
148+  80DB DF 50 4F 49      defb $DF,"P","O","I","U","Y"
148+  80DF 55 59
149+  80E1 BF 23 4C 4B      defb $BF,"#","L","K","J","H"
149+  80E5 4A 48
150+  80E7 7F 20 23 4D      defb $7F," ","#","M","N","B"
150+  80EB 4E 42
151+  80ED
152+  80ED
153+  80ED              ;
154+  80ED              ; Generates a randomish number in the range 0 to e
155+  80ED              ; Inputs:
156+  80ED              ; e - upper value
157+  80ED              ; Outputs:
158+  80ED              ; a - random number
159+  80ED              utilities_randomupper
160+  80ED 3A 41 BD         ld a,(game_framenumber)
161+  80F0 6F               ld l,a
162+  80F1 26 00            ld h,0
163+  80F3 16 00            ld d,0
164+  80F5 42 4B            ld bc,de
165+  80F7              utilities_randomupper0:
166+  80F7 B7               or a
167+  80F8 ED 42            sbc hl,bc
168+  80FA F2 F7 80         jp p,utilities_randomupper0
169+  80FD 09               add hl,bc
170+  80FE 01 00 00         ld bc,0
171+  8101 09               add hl,bc
172+  8102 7D               ld a,l
173+  8103 C9               ret
# file closed: utilities.asm
 22   8104                  include "strings.asm"
# file opened: strings.asm
  1+  8104              string_score1:
  2+  8104 04 00 53 43      defb 4,0,'SCORE1',255
  2+  8108 4F 52 45 31
  2+  810C FF
  3+  810D              string_scorenumbers1:
  4+  810D 04 01 30 30      defb 4,1,'000000',255
  4+  8111 30 30 30 30
  4+  8115 FF
  5+  8116              string_company:
  6+  8116 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  811A 4E 54 55 52
  6+  811E 49 FF
  7+  8120              string_credits:
  8+  8120 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  8124 41 59 45 52
  8+  8128 20 31 FF
  9+  812B              string_score2:
 10+  812B 16 00 53 43      defb 22,0,'SCORE2',255
 10+  812F 4F 52 45 32
 10+  8133 FF
 11+  8134              string_scorenumbers2:
 12+  8134 16 01 30 30      defb 22,1,'000000',255
 12+  8138 30 30 30 30
 12+  813C FF
 13+  813D              string_titlescreen_copyright:
 14+  813D 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 14+  8141 39 38 32 20
 14+  8145 20 43 45 4E
 14+  8149 54 55 52 49
 14+  814D 20 49 4E 43
 14+  8151 FF
 15+  8152
 16+  8152
 17+  8152              string_alttitlescreen_1:
 18+  8152 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  8156 45 44 49 54
 18+  815A 53 20 31 FF
 19+  815E              string_alttitlescreen_2:
 20+  815E 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  8162 20 20 20 20
 20+  8166 20 20 20 20
 20+  816A 20 54 48 45
 20+  816E 20 4F 42 4A
 20+  8172 45 43 54 FE
 21+  8176 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  817A 20 20 20 20
 21+  817E 20 20 20 20
 21+  8182 4F 46 20 54
 21+  8186 48 49 53 20
 21+  818A 47 41 4D 45
 21+  818E FE
 22+  818F 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  8193 20 20 20 20
 22+  8197 20 20 20 49
 22+  819B 53 20 54 4F
 22+  819F 20 44 49 47
 22+  81A3 20 44 4F 57
 22+  81A7 4E FE
 23+  81A9 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  81AD 20 20 20 20
 23+  81B1 20 20 54 4F
 23+  81B5 20 54 48 45
 23+  81B9 20 42 4F 54
 23+  81BD 54 4F 4D 20
 23+  81C1 50 49 54 FE
 24+  81C5 00 06 20 20      defb 0,6,'               AND',254
 24+  81C9 20 20 20 20
 24+  81CD 20 20 20 20
 24+  81D1 20 20 20 20
 24+  81D5 20 41 4E 44
 24+  81D9 FE
 25+  81DA 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  81DE 20 20 20 20
 25+  81E2 20 20 43 4F
 25+  81E6 4C 4C 45 43
 25+  81EA 54 20 41 54
 25+  81EE 20 4C 45 41
 25+  81F2 53 54 FE
 26+  81F5 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  81F9 20 20 20 20
 26+  81FD 20 20 20 4F
 26+  8201 4E 45 20 4C
 26+  8205 41 52 47 45
 26+  8209 20 4A 45 57
 26+  820D 45 4C FE
 27+  8210 00 09 20 20      defb 0,9,'              THEN',254
 27+  8214 20 20 20 20
 27+  8218 20 20 20 20
 27+  821C 20 20 20 20
 27+  8220 54 48 45 4E
 27+  8224 FE
 28+  8225 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  8229 20 20 20 20
 28+  822D 20 20 20 52
 28+  8231 45 54 55 52
 28+  8235 4E 20 54 4F
 28+  8239 20 53 48 49
 28+  823D 50 FE
 29+  823F 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  8243 20 20 20 20
 29+  8247 20 20 20 54
 29+  824B 48 52 55 20
 29+  824F 55 50 50 45
 29+  8253 52 20 50 49
 29+  8257 54 FF
 30+  8259              string_alttitlescreen_3:
 31+  8259 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  825D 20 20 53 49
 31+  8261 4E 47 4C 45
 31+  8265 20 42 4F 4E
 31+  8269 55 53 20 20
 31+  826D 35 30 30 30
 31+  8271 20 50 4F 49
 31+  8275 4E 54 53 FE
 32+  8279 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  827D 20 20 20 20
 32+  8281 43 4F 4C 4C
 32+  8285 45 43 54 20
 32+  8289 31 20 4C 41
 32+  828D 52 47 45 20
 32+  8291 4A 45 57 45
 32+  8295 4C FE
 33+  8297 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  829B 20 20 20 20
 33+  829F 20 41 4E 44
 33+  82A3 20 52 45 54
 33+  82A7 55 52 4E 20
 33+  82AB 54 4F 20 53
 33+  82AF 48 49 50 FE
 34+  82B3 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  82B7 20 20 44 4F
 34+  82BB 55 42 4C 45
 34+  82BF 20 42 4F 4E
 34+  82C3 55 53 20 20
 34+  82C7 31 30 30 30
 34+  82CB 30 20 50 4F
 34+  82CF 49 4E 54 53
 34+  82D3 FE
 35+  82D4 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  82D8 20 20 43 4F
 35+  82DC 4C 4C 45 43
 35+  82E0 54 20 41 4C
 35+  82E4 4C 20 33 20
 35+  82E8 4C 41 52 47
 35+  82EC 45 20 4A 45
 35+  82F0 57 45 4C 53
 35+  82F4 FE
 36+  82F5 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  82F9 20 20 20 20
 36+  82FD 20 4F 52 20
 36+  8301 20 20 41 4C
 36+  8305 4C 20 34 20
 36+  8309 53 4D 41 4C
 36+  830D 4C 20 4A 45
 36+  8311 57 45 4C 53
 36+  8315 FE
 37+  8316 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  831A 20 20 54 52
 37+  831E 49 50 4C 45
 37+  8322 20 42 4F 4E
 37+  8326 55 53 20 20
 37+  832A 31 35 30 30
 37+  832E 30 20 50 4F
 37+  8332 49 4E 54 53
 37+  8336 FE
 38+  8337 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  833B 20 20 20 20
 38+  833F 20 43 4F 4C
 38+  8343 4C 45 43 54
 38+  8347 20 41 4C 4C
 38+  834B 20 37 20 4A
 38+  834F 45 57 45 4C
 38+  8353 53 FF
 39+  8355
 40+  8355              string_lifescreen_player:
 41+  8355 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  8359 4C 41 59 45
 41+  835D 52 20 31 20
 41+  8361 FF
 42+  8362              string_lifescreen_lives:
 43+  8362 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  8366 4D 45 4E 20
 43+  836A 4C 45 46 54
 43+  836E FF
 44+  836F              string_lifescreen_lastman:
 45+  836F 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  8373 53 54 20 4D
 45+  8377 41 4E FF
 46+  837A
 47+  837A              string_gameoverscreen_gameover:
 48+  837A 0B 06 47 41      defb 11,6,'GAME OVER',255
 48+  837E 4D 45 20 4F
 48+  8382 56 45 52 FF
 49+  8386              string_gameoverscreen_copyright:
 50+  8386 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 50+  838A 39 38 32 20
 50+  838E 43 45 4E 54
 50+  8392 55 52 49 20
 50+  8396 49 4E 43 FF
 51+  839A              string_gameoverscreen_bestscores:
 52+  839A 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  839E 53 54 20 53
 52+  83A2 43 4F 52 45
 52+  83A6 53 20 54 4F
 52+  83AA 44 41 59 FF
 53+  83AE              string_gameover_credits:
 54+  83AE 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  83B2 45 44 49 54
 54+  83B6 53 20 30 FF
 55+  83BA
 56+  83BA              string_highscore_congratulations:
 57+  83BA 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 57+  83BE 4E 47 52 41
 57+  83C2 54 55 4C 41
 57+  83C6 54 49 4F 4E
 57+  83CA 53 FF
 58+  83CC              string_highscore_player1:
 59+  83CC 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 59+  83D0 41 59 45 52
 59+  83D4 20 31 FF
 60+  83D7              string_highscore_player2:
 61+  83D7 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 61+  83DB 41 59 45 52
 61+  83DF 20 32 FF
 62+  83E2              string_highscore_youhaveearned:
 63+  83E2 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 63+  83E6 55 20 48 41
 63+  83EA 56 45 20 45
 63+  83EE 41 52 4E 45
 63+  83F2 44 FF
 64+  83F4              string_highscore_place1:
 65+  83F4 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 65+  83F8 45 20 47 52
 65+  83FC 45 41 54 45
 65+  8400 53 54 20 53
 65+  8404 43 4F 52 45
 65+  8408 FF
 66+  8409              string_highscore_place2:
 67+  8409 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 67+  840D 45 20 32 4E
 67+  8411 44 20 42 45
 67+  8415 53 54 20 53
 67+  8419 43 4F 52 45
 67+  841D FF
 68+  841E              string_highscore_place3:
 69+  841E 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 69+  8422 45 20 33 52
 69+  8426 44 20 42 45
 69+  842A 53 54 20 53
 69+  842E 43 4F 52 45
 69+  8432 FF
 70+  8433              string_highscore_pleaseenter
 71+  8433 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 71+  8437 43 4F 52 44
 71+  843B 20 59 4F 55
 71+  843F 52 20 49 4E
 71+  8443 49 54 49 41
 71+  8447 4C 53 20 42
 71+  844B 45 4C 4F 57
 71+  844F FF
 72+  8450
 73+  8450              string_endlevel_youhaveearned:
 74+  8450 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 74+  8454 55 20 48 41
 74+  8458 56 45 20 45
 74+  845C 41 52 4E 45
 74+  8460 44 FF
 75+  8462              string_endlevel_bonus1:
 76+  8462 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 76+  8466 4E 47 4C 45
 76+  846A 20 42 4F 4E
 76+  846E 55 53 FF
 77+  8471              string_endlevel_bonus2:
 78+  8471 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 78+  8475 55 42 4C 45
 78+  8479 20 42 4F 4E
 78+  847D 55 53 FF
 79+  8480              string_endlevel_bonus3:
 80+  8480 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 80+  8484 49 50 4C 45
 80+  8488 20 42 4F 4E
 80+  848C 55 53 FF
 81+  848F              string_endlevel_points1:
 82+  848F 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 82+  8493 30 30 20 50
 82+  8497 4F 49 4E 54
 82+  849B 53 FF
 83+  849D              string_endlevel_points2:
 84+  849D 09 0F 31 30      defb 9,15,'10000 POINTS',255
 84+  84A1 30 30 30 20
 84+  84A5 50 4F 49 4E
 84+  84A9 54 53 FF
 85+  84AC              string_endlevel_points3:
 86+  84AC 09 0F 31 35      defb 9,15,'15000 POINTS',255
 86+  84B0 30 30 30 20
 86+  84B4 50 4F 49 4E
 86+  84B8 54 53 FF
 87+  84BB              string_endlevel_anothergo:
 88+  84BB 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 88+  84BF 56 45 20 41
 88+  84C3 4E 4F 54 48
 88+  84C7 45 52 20 47
 88+  84CB 4F FF
 89+  84CD
 90+  84CD              string_zonk:
 91+  84CD 00 00 5A 4F      defb 0,0,'ZONK!',255
 91+  84D1 4E 4B 21 FF
 92+  84D5
 93+  84D5
 94+  84D5              string_options_title:
 95+  84D5 0D 03 54 48      defb 13,3,'THE PIT',255
 95+  84D9 45 20 50 49
 95+  84DD 54 FF
 96+  84DF              string_options_1player:
 97+  84DF 0A 06 31 2E      defb 10,6,'1. ONE PLAYER',255
 97+  84E3 20 4F 4E 45
 97+  84E7 20 50 4C 41
 97+  84EB 59 45 52 FF
 98+  84EF              string_options_2player:
 99+  84EF 0A 07 32 2E      defb 10,7,'2. TWO PLAYER',255
 99+  84F3 20 54 57 4F
 99+  84F7 20 50 4C 41
 99+  84FB 59 45 52 FF
100+  84FF              string_options_keyboard:
101+  84FF 0A 08 33 2E      defb 10,8,'3. KEYBOARD',255
101+  8503 20 4B 45 59
101+  8507 42 4F 41 52
101+  850B 44 FF
102+  850D              string_options_joystick:
103+  850D 0A 09 34 2E      defb 10,9,'4. KEMPSTON',255
103+  8511 20 4B 45 4D
103+  8515 50 53 54 4F
103+  8519 4E FF
104+  851B              string_options_start:
105+  851B 0A 0A 35 2E      defb 10,10,'5. START',255
105+  851F 20 53 54 41
105+  8523 52 54 FF
106+  8526              string_options_vanity:
107+  8526 08 16 53 70      defb 8,22,'Spectrum Conversion',254
107+  852A 65 63 74 72
107+  852E 75 6D 20 43
107+  8532 6F 6E 76 65
107+  8536 72 73 69 6F
107+  853A 6E FE
108+  853C 07 17 62 79      defb 7,23,'by Dave Tansley, 2020',255
108+  8540 20 44 61 76
108+  8544 65 20 54 61
108+  8548 6E 73 6C 65
108+  854C 79 2C 20 32
108+  8550 30 32 30 FF
109+  8554
110+  8554              ;
111+  8554              ; Prints specified string
112+  8554              ; Inputs:
113+  8554              ; de: pointer to string
114+  8554              ; bc: length of string
115+  8554              ;
116+  8554              ; Print String Data
117+  8554              ; First two bytes of string contain X and Y char position, then the string
118+  8554              ; Individual strings are terminated with 0xFE
119+  8554              ; End of data is terminated with 0xFF
120+  8554              ; HL: Address of string
121+  8554              ;
122+  8554 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
123+  8555 23                                   INC HL                          ; Increase HL to the next memory location
124+  8556 56                                   LD D,(HL)                       ; Fetch the Y coordinate
125+  8557 23                                   INC HL                          ; Increase HL to the next memory location
126+  8558 CD 6B 85                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
127+  855B 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
128+  855C 23                                   INC HL                          ; Increase HL to the next character
129+  855D FE FE                                CP 0xFE                         ; Compare with 0xFE
130+  855F 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
131+  8561 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
132+  8562 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
133+  8563 CD 7B 85                             CALL Print_Char                 ; Print the character
134+  8566 E1                                   POP HL                          ; Retrieve HL back off the stack
135+  8567 1C                                   INC E                           ; Go to the next screen address
136+  8568 18 F1                                JR string_print_0               ; Loop back to print next character
137+  856A C9                                   RET
138+  856B
139+  856B              ; Get screen address
140+  856B              ; D = Y character position
141+  856B              ; E = X character position
142+  856B              ; Returns address in DE
143+  856B              ;
144+  856B 7A           string_getcharaddress:       LD A,D
145+  856C E6 07                                AND %00000111
146+  856E 1F                                   RRA
147+  856F 1F                                   RRA
148+  8570 1F                                   RRA
149+  8571 1F                                   RRA
150+  8572 B3                                   OR E
151+  8573 5F                                   LD E,A
152+  8574 7A                                   LD A,D
153+  8575 E6 18                                AND %00011000
154+  8577 F6 40                                OR %01000000
155+  8579 57                                   LD D,A
156+  857A C9                                   RET                             ; Returns screen address in DE
157+  857B
158+  857B              ; Print a single character out
159+  857B              ; A:  Character to print
160+  857B              ; DE: Screen address to print character at
161+  857B              ;
162+  857B 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
163+  857E 06 00                                LD B,0                          ; Set BC to A
164+  8580 4F                                   LD C,A
165+  8581 E6 FF                                AND 0xFF                        ; Clear the carry bit
166+  8583 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
167+  8585 CB 10                                RL B
168+  8587 CB 11                                RL C
169+  8589 CB 10                                RL B
170+  858B CB 11                                RL C
171+  858D CB 10                                RL B
172+  858F 09                                   ADD HL,BC                       ; Get the character address in HL
173+  8590 0E 08                                LD C,8                          ; Loop counter
174+  8592 D5                                   PUSH DE
175+  8593 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
176+  8594 12                                   LD (DE),A                       ; Stick A onto the screen
177+  8595 14                                   INC D                           ; Goto next line on screen
178+  8596 2C                                   INC L                           ; Goto next byte of character
179+  8597 0D                                   DEC C                           ; Decrease the loop counter
180+  8598 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
181+  859A D1                                   POP DE
182+  859B C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   859C                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  859C              buffer_buffer:
  2+  859C 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A29C
  4+  A29C              buffer_attr_buffer:
  5+  A29C 00 00 00...      defs 928                    ; attrs buffer area
  6+  A63C
  7+  A63C              buffer_tmp:
  8+  A63C 00 00            defb 0,0                    ; temp area
  9+  A63E
 10+  A63E              ;
 11+  A63E              ; This list stores lines to be updated by the buffer.
 12+  A63E              ; This is done by half line. Lines are encded with.
 13+  A63E              ; 00hlllll
 14+  A63E              ; Where h is the half of the screen (0 or 1), lllll is the line number
 15+  A63E              buffer_updatedlines:
 16+  A63E FF FF FF...      defs 21,255
 17+  A653
 18+  A653              buffer_updateall:
 19+  A653 00               defb 0
 20+  A654
 21+  A654              ;
 22+  A654              ; Stores a line number in the update list
 23+  A654              ; Inputs:
 24+  A654              ; a - row number
 25+  A654              buffer_marklineforupdate:
 26+  A654 FE 15            cp 21
 27+  A656 D0               ret nc                          ; dont store lines that we shouldn't draw
 28+  A657 5F               ld e,a                          ; store in e
 29+  A658 ED 4B 41 AB      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 30+  A65C 79               ld a,c                          ; get the horiz coord
 31+  A65D FE 0F            cp 15
 32+  A65F CA 76 A6         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 33+  A662 FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 34+  A664 CA 76 A6         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 35+  A667 DA 72 A6         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 36+  A66A 78               ld a,b                          ; get the vertical
 37+  A66B 3E 20            ld a,32                         ; set the 6th bit by adding 32
 38+  A66D 83               add a,e
 39+  A66E 5F               ld e,a                          ; store this value
 40+  A66F C3 7D A6         jp buffer_marklineforupdate2
 41+  A672              buffer_marklineforupdate4:
 42+  A672 78               ld a,b
 43+  A673 C3 7D A6         jp buffer_marklineforupdate2    ; just get the vertical
 44+  A676              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 45+  A676 CD 81 A6         call buffer_storelineforupdate  ; call store update for e
 46+  A679 3E 20            ld a,32
 47+  A67B 83               add a,e
 48+  A67C 5F               ld e,a
 49+  A67D              buffer_marklineforupdate2:
 50+  A67D CD 81 A6         call buffer_storelineforupdate  ; call store update for e
 51+  A680 C9               ret
 52+  A681
 53+  A681
 54+  A681              ;
 55+  A681              ; Stores the calculated line and half if needed
 56+  A681              ; Inputs:
 57+  A681              ; e - half/row
 58+  A681              ;
 59+  A681              buffer_storelineforupdate:
 60+  A681 06 15            ld b,21
 61+  A683 21 3E A6         ld hl,buffer_updatedlines
 62+  A686              buffer_storelineforupdate0:
 63+  A686 7E               ld a,(hl)                       ; get the line stored in updated lines
 64+  A687 BB               cp e                            ; is this the same as the row number passed in?
 65+  A688 C8               ret z                           ; if so, don't need to do anything
 66+  A689 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 67+  A68B C2 90 A6         jp nz,buffer_storelineforupdate1 ; if not, move to next
 68+  A68E 73               ld (hl),e
 69+  A68F C9               ret
 70+  A690              buffer_storelineforupdate1:
 71+  A690 23               inc hl
 72+  A691 10 F3            djnz buffer_storelineforupdate0
 73+  A693 C9               ret
 74+  A694
 75+  A694              ;
 76+  A694              ; Zeroes the updated lines list
 77+  A694              ;
 78+  A694              buffer_clearlist:
 79+  A694 06 15            ld b,21
 80+  A696 21 3E A6         ld hl,buffer_updatedlines
 81+  A699              buffer_clearlist0:
 82+  A699 36 FF            ld (hl),255
 83+  A69B 23               inc hl
 84+  A69C 10 FB            djnz buffer_clearlist0
 85+  A69E C9               ret
 86+  A69F
 87+  A69F              ;
 88+  A69F              ; Which half are we displaying? 0 left 1 right
 89+  A69F              ;
 90+  A69F              buffer_bufferhalf:
 91+  A69F 00               defb 0
 92+  A6A0
 93+  A6A0              ;
 94+  A6A0              ; Copies the buffer to the screen. Use stack.
 95+  A6A0              ; Inputs:
 96+  A6A0              ; hl - half/line number to display - 0 is first half, 0 is first line
 97+  A6A0              ;
 98+  A6A0              buffer_bufferlinetoscreen:
 99+  A6A0 7C               ld a,h
100+  A6A1 32 9F A6         ld (buffer_bufferhalf),a        ; store the half
101+  A6A4 7D               ld a,l
102+  A6A5 4F               ld c,a                          ; store a
103+  A6A6 ED 5B 06 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
104+  A6AA 83               add a,e                       ; add the row number
105+  A6AB 11 00 01         ld de,256
106+  A6AE CD 3A 80         call utilities_multiply
107+  A6B1 54 5D            ld de,hl
108+  A6B3 21 9C 85         ld hl,buffer_buffer
109+  A6B6 19               add hl,de                   ; add the offset
110+  A6B7 79               ld a,c                      ; get original row back
111+  A6B8 ED 73 2B A7      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
112+  A6BC D9               exx
113+  A6BD 0E 00            ld c,0                      ; zero horizontal
114+  A6BF 47               ld b,a                      ; load the row number into vertical coord
115+  A6C0 04               inc b
116+  A6C1 04               inc b                       ; move forward 2 to allow for scores
117+  A6C2 CD F0 A8         call screen_getcelladdress  ; get the memory into de
118+  A6C5 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
119+  A6C8 19               add hl,de
120+  A6C9 3A 9F A6         ld a,(buffer_bufferhalf)    ; get the half
121+  A6CC FE 01            cp 1
122+  A6CE CA FB A6         jp z,buffer_bufferlinetoscreen4
123+  A6D1              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
124+  A6D1 D9               exx                         ; hl is now buffer
125+  A6D2 23               inc hl
126+  A6D3 23               inc hl                      ; move hl forward 2 to skip first two blocks
127+  A6D4 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
128+  A6D5 F1               pop af
129+  A6D6 C1               pop bc
130+  A6D7 D1               pop de
131+  A6D8 DD E1            pop ix
132+  A6DA D9               exx                         ; hl is now screen
133+  A6DB 08               ex af,af'
134+  A6DC F1               pop af
135+  A6DD C1               pop bc
136+  A6DE D1               pop de
137+  A6DF F9               ld sp,hl                    ; sp pointing at screen
138+  A6E0 D5               push de
139+  A6E1 C5               push bc
140+  A6E2 F5               push af
141+  A6E3 08               ex af,af'
142+  A6E4 D9               exx                         ; hl is now buffer
143+  A6E5 DD E5            push ix
144+  A6E7 D5               push de
145+  A6E8 C5               push bc
146+  A6E9 F5               push af
147+  A6EA 11 1E 00         ld de,30                    ; add thirty to get to next line
148+  A6ED 19               add hl,de
149+  A6EE F9               ld sp,hl                    ; sp pointing at buffer
150+  A6EF D9               exx                         ; hl is now screen
151+  A6F0 08               ex af,af'
152+  A6F1 24               inc h
153+  A6F2 7C               ld a,h
154+  A6F3 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
155+  A6F5 C2 D1 A6         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
156+  A6F8              buffer_bufferlinetoscreen1:
157+  A6F8 C3 2A A7         jp buffer_bufferlinetoscreen3
158+  A6FB              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
159+  A6FB D9               exx                         ; hl is buffer
160+  A6FC 11 10 00         ld de,16
161+  A6FF 19               add hl,de                   ; move halfway across
162+  A700 D9               exx                         ; hl is screen
163+  A701 11 0E 00         ld de,14
164+  A704 19               add hl,de
165+  A705              buffer_bufferlinetoscreen2:
166+  A705 D9               exx                         ; hl is now buffer
167+  A706 F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
168+  A707 F1               pop af
169+  A708 C1               pop bc
170+  A709 D1               pop de
171+  A70A DD E1            pop ix
172+  A70C D9               exx                         ; hl is now screen
173+  A70D 08               ex af,af'
174+  A70E F1               pop af
175+  A70F C1               pop bc
176+  A710 D1               pop de
177+  A711 F9               ld sp,hl                    ; sp pointing at screen
178+  A712 D5               push de
179+  A713 C5               push bc
180+  A714 F5               push af
181+  A715 08               ex af,af'
182+  A716 D9               exx                         ; hl is now buffer
183+  A717 DD E5            push ix
184+  A719 D5               push de
185+  A71A C5               push bc
186+  A71B F5               push af
187+  A71C 11 20 00         ld de,32                    ; add thirty two to get to next line
188+  A71F 19               add hl,de
189+  A720 F9               ld sp,hl                    ; sp pointing at buffer
190+  A721 D9               exx                         ; hl is now screen
191+  A722 08               ex af,af'
192+  A723 24               inc h
193+  A724 7C               ld a,h
194+  A725 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
195+  A727 C2 05 A7         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
196+  A72A              buffer_bufferlinetoscreen3:
197+  A72A 31 00 00         ld sp,0
198+  A72D D9               exx
199+  A72E C9               ret
200+  A72F
201+  A72F              ;
202+  A72F              ; Copies the buffer to the screen for updated lines. Use stack.
203+  A72F              ; Inputs: none
204+  A72F              ;
205+  A72F              buffer_buffertoscreen:
206+  A72F 3A 53 A6         ld a,(buffer_updateall)      ; get the all update flag
207+  A732 FE 00            cp 0
208+  A734 CA 40 A7         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
209+  A737 CD 70 A7         call buffer_allbuffertoscreen ; otherwise, draw whole screen
210+  A73A 21 53 A6         ld hl,buffer_updateall
211+  A73D 36 00            ld (hl),0                    ; reset flag
212+  A73F C9               ret
213+  A740              buffer_buffertoscreen2:
214+  A740 06 15            ld b,21
215+  A742 FD 21 3E A6      ld iy,buffer_updatedlines    ; the location of the updated lines
216+  A746              buffer_buffertoscreen0:
217+  A746 FD 7E 00         ld a,(iy)
218+  A749 FE FF            cp 255
219+  A74B CA 6F A7         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
220+  A74E 6F               ld l,a
221+  A74F 26 00            ld h,0
222+  A751 E6 20            and 32                      ; and with 32 to see if 6th bit is set
223+  A753 FE 20            cp 32                       ; if so, second half of screen
224+  A755 C2 60 A7         jp nz,buffer_buffertoscreen3
225+  A758 26 01            ld h,1                      ; store half in h
226+  A75A FD 7E 00         ld a,(iy)
227+  A75D D6 20            sub 32                      ; remove 32
228+  A75F 6F               ld l,a                      ; stor in line number
229+  A760              buffer_buffertoscreen3:
230+  A760 C5               push bc
231+  A761 FD E5            push iy
232+  A763 F3               di
233+  A764 CD A0 A6         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
234+  A767 FB               ei
235+  A768 FD E1            pop iy
236+  A76A C1               pop bc
237+  A76B FD 23            inc iy
238+  A76D 10 D7            djnz buffer_buffertoscreen0
239+  A76F              buffer_buffertoscreen1:
240+  A76F                  ;call buffer_buffertoattrsfast
241+  A76F C9               ret
242+  A770
243+  A770              ;
244+  A770              ; Copies the buffer to the screen. Use stack.
245+  A770              ; Inputs: none
246+  A770              ;
247+  A770              buffer_allbuffertoscreen:
248+  A770 06 15            ld b,21
249+  A772 3E 00            ld a,0
250+  A774              buffer_allbuffertoscreen0:
251+  A774 C5               push bc
252+  A775 F5               push af
253+  A776 F3               di
254+  A777 26 00            ld h,0
255+  A779 6F               ld l,a
256+  A77A CD A0 A6         call buffer_bufferlinetoscreen
257+  A77D FB               ei
258+  A77E F1               pop af
259+  A77F F5               push af
260+  A780 F3               di
261+  A781 26 01            ld h,1
262+  A783 6F               ld l,a
263+  A784 CD A0 A6         call buffer_bufferlinetoscreen
264+  A787 FB               ei
265+  A788 F1               pop af
266+  A789 C1               pop bc
267+  A78A 3C               inc a
268+  A78B 10 E7            djnz buffer_allbuffertoscreen0
269+  A78D F3               di
270+  A78E CD 93 A7         call buffer_buffertoattrsfast
271+  A791 FB               ei
272+  A792 C9               ret
273+  A793
274+  A793              ;
275+  A793              ; Copies the attrs buffer to screen with the stack
276+  A793              ;
277+  A793              buffer_buffertoattrsfast:
278+  A793 ED 73 02 A8      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
279+  A797 3A 06 A8         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
280+  A79A 11 20 00         ld de,32
281+  A79D CD 3A 80         call utilities_multiply
282+  A7A0 54 5D            ld de,hl
283+  A7A2 21 9C A2         ld hl,buffer_attr_buffer
284+  A7A5 19               add hl,de                       ; add the offset, start of attr buffer now in hl
285+  A7A6 D9               exx
286+  A7A7 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
287+  A7AA FD 21 3C A6      ld iy,buffer_tmp
288+  A7AE FD 36 00 15      ld (iy),21              ; number of times to loop
289+  A7B2              buffer_buffertoattrsfast0:
290+  A7B2 D9               exx                         ; hl is now buffer
291+  A7B3 23               inc hl
292+  A7B4 23               inc hl                      ; move hl forward 2 to skip first two blocks
293+  A7B5 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
294+  A7B6 F1               pop af
295+  A7B7 C1               pop bc
296+  A7B8 D1               pop de
297+  A7B9 DD E1            pop ix
298+  A7BB D9               exx                         ; hl is now screen
299+  A7BC 08               ex af,af'
300+  A7BD F1               pop af
301+  A7BE C1               pop bc
302+  A7BF D1               pop de
303+  A7C0 F9               ld sp,hl                    ; sp pointing at screen
304+  A7C1 D5               push de
305+  A7C2 C5               push bc
306+  A7C3 F5               push af
307+  A7C4 08               ex af,af'
308+  A7C5 D9               exx                         ; hl is now buffer
309+  A7C6 DD E5            push ix
310+  A7C8 D5               push de
311+  A7C9 C5               push bc
312+  A7CA F5               push af
313+  A7CB 1E 0E            ld e,14                    ; do another fourteen for right hand side
314+  A7CD 16 00            ld d,0
315+  A7CF 19               add hl,de
316+  A7D0 F9               ld sp,hl                    ; sp pointing at buffer
317+  A7D1 F1               pop af
318+  A7D2 C1               pop bc
319+  A7D3 D1               pop de
320+  A7D4 DD E1            pop ix
321+  A7D6 D9               exx                         ; hl is now screen
322+  A7D7 08               ex af,af'
323+  A7D8 1E 0E            ld e,14
324+  A7DA 16 00            ld d,0
325+  A7DC 19               add hl,de
326+  A7DD F1               pop af
327+  A7DE C1               pop bc
328+  A7DF D1               pop de
329+  A7E0 F9               ld sp,hl                    ; sp pointing at screen
330+  A7E1 D5               push de
331+  A7E2 C5               push bc
332+  A7E3 F5               push af
333+  A7E4 08               ex af,af'
334+  A7E5 D9               exx                         ; hl is now buffer
335+  A7E6 DD E5            push ix
336+  A7E8 D5               push de
337+  A7E9 C5               push bc
338+  A7EA F5               push af
339+  A7EB 1E 10            ld e,16
340+  A7ED 16 00            ld d,0
341+  A7EF 19               add hl,de
342+  A7F0 D9               exx                         ; hl is now screen
343+  A7F1 11 12 00         ld de,18
344+  A7F4 19               add hl,de
345+  A7F5 FD 7E 00         ld a,(iy)
346+  A7F8 3D               dec a
347+  A7F9 FE 00            cp 0
348+  A7FB FD 77 00         ld (iy),a
349+  A7FE C2 B2 A7         jp nz,buffer_buffertoattrsfast0 ; do another row
350+  A801              buffer_buffertoattrsfast1:
351+  A801 31 00 00         ld sp,0
352+  A804 D9               exx
353+  A805 C9               ret
# file closed: screen/buffer.asm
 24   A806                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A806              screen_offset:
  2+  A806 00               defb 0                      ; offset from top of screen in lines
  3+  A807
  4+  A807              screen_tmp:
  5+  A807 00 00            defb 0,0                      ; temporary memory
  6+  A809
  7+  A809              screen_setscorecolours:
  8+  A809 21 37 B5         ld hl,score_colours
  9+  A80C 11 00 58         ld de,22528                     ; attrs here
 10+  A80F 01 40 00         ld bc,64
 11+  A812 ED B0            ldir
 12+  A814 C9               ret
 13+  A815
 14+  A815              screen_sethighscorecolours:
 15+  A815 21 77 B5         ld hl,high_score_colours
 16+  A818 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A81B 01 20 00         ld bc,32
 18+  A81E ED B0            ldir
 19+  A820 C9               ret
 20+  A821
 21+  A821              ; Draw the screen
 22+  A821              ; Inputs:
 23+  A821              ; none
 24+  A821              ; Notes:
 25+  A821              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A821              screen_draw:
 27+  A821                  ;call clear_screen
 28+  A821 0E 00            ld c,0                      ; horiz
 29+  A823 06 00            ld b,0                      ; vert, 0 at top
 30+  A825 DD 21 F9 AF      ld ix,level01               ; point ix at level data
 31+  A829 FD 21 9C A2      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A82D              screen_draw0:
 33+  A82D DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A830 C5               push bc                     ; store bc, contains loop count
 35+  A831 CD DE A9         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A834 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A835 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A838 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A83B CD A5 A9         call screen_getblock        ; get the block data into hl
 40+  A83E CD 82 A9         call screen_showchar        ; show this character here
 41+  A841 C1               pop bc                      ; get the loop counter back
 42+  A842 DD 23            inc ix                      ; increment level location
 43+  A844 FD 23            inc iy                      ; increment attr location
 44+  A846 0C               inc c                       ; increment horiz
 45+  A847 79               ld a,c
 46+  A848 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A84A C2 2D A8         jp nz,screen_draw0          ; if not, loop
 48+  A84D 0E 00            ld c,0                      ; if so, reset horiz
 49+  A84F 04               inc b                       ; increment vertical
 50+  A850 78               ld a,b
 51+  A851 FE 1D            cp 29                       ; check if at bottom
 52+  A853 C2 2D A8         jp nz,screen_draw0          ; if not, loop
 53+  A856 21 07 A8         ld hl, screen_tmp
 54+  A859 36 09            ld (hl),9                   ; load the block number into memory
 55+  A85B DD 21 99 B3      ld ix,level01rocks          ; rock memory
 56+  A85F CD C0 A8         call screen_initobjects     ; draw rocks
 57+  A862 21 07 A8         ld hl, screen_tmp
 58+  A865 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A867 DD 21 99 B4      ld ix,level01missiles       ; missile memory
 60+  A86B CD C0 A8         call screen_initobjects     ; draw missiles
 61+  A86E 21 07 A8         ld hl, screen_tmp
 62+  A871 36 08            ld (hl),08                  ; load the block number into memory
 63+  A873 DD 21 12 B5      ld ix,level01diamonds       ; diamond memory
 64+  A877 CD C0 A8         call screen_initobjects     ; draw diamonds
 65+  A87A 21 07 A8         ld hl, screen_tmp
 66+  A87D 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A87F DD 21 22 B5      ld ix,level01gems           ; gems memory
 68+  A883 CD C0 A8         call screen_initobjects     ; draw gems
 69+  A886 CD 8D A8         call screen_setuptext       ; draws text on the screen
 70+  A889 CD 9E C4         call scores_printscores     ; print the current scores
 71+  A88C C9               ret
 72+  A88D
 73+  A88D              ;
 74+  A88D              ; Sets up text on the screen
 75+  A88D              ;
 76+  A88D              screen_setuptext:
 77+  A88D CD C0 C4         call scores_showtable
 78+  A890 CD 15 A8         call screen_sethighscorecolours
 79+  A893 21 04 81         ld hl, string_score1
 80+  A896 CD 54 85         call string_print
 81+  A899 21 0D 81         ld hl, string_scorenumbers1
 82+  A89C CD 54 85         call string_print
 83+  A89F 21 16 81         ld hl, string_company
 84+  A8A2 CD 54 85         call string_print
 85+  A8A5 21 2B 81         ld hl, string_score2
 86+  A8A8 CD 54 85         call string_print
 87+  A8AB 21 34 81         ld hl, string_scorenumbers2
 88+  A8AE CD 54 85         call string_print
 89+  A8B1 21 20 81         ld hl, string_credits
 90+  A8B4 CD 54 85         call string_print
 91+  A8B7 CD 09 A8         call screen_setscorecolours
 92+  A8BA C9               ret
 93+  A8BB
 94+  A8BB              ;
 95+  A8BB              ; Sets a line of colours
 96+  A8BB              ; Inputs:
 97+  A8BB              ; a - colour to set
 98+  A8BB              ; b - number to set
 99+  A8BB              ; de - start memory location
100+  A8BB              ;
101+  A8BB              screen_setcolours:
102+  A8BB 12               ld (de),a
103+  A8BC 13               inc de
104+  A8BD 10 FC            djnz screen_setcolours
105+  A8BF C9               ret
106+  A8C0
107+  A8C0              ;
108+  A8C0              ; Draw initial object positions
109+  A8C0              ; Inputs:
110+  A8C0              ; ix - memory location of objects
111+  A8C0              ; a - graphic
112+  A8C0              screen_initobjects:
113+  A8C0 DD 4E 00         ld c,(ix)                   ; get the horiz coord
114+  A8C3 79               ld a,c
115+  A8C4 FE FF            cp 255
116+  A8C6 CA EF A8         jp z,screen_initobjects2
117+  A8C9 DD 23            inc ix                      ; move to next
118+  A8CB DD 46 00         ld b,(ix)                   ; get the vert coord
119+  A8CE DD 23            inc ix
120+  A8D0 CD 01 A9         call screen_getcellattradress ; get the memory address of b,c attr into de
121+  A8D3 D5               push de
122+  A8D4 3A 07 A8         ld a,(screen_tmp)                  ; get the block number back
123+  A8D7 CD DE A9         call screen_getattr         ; get the memory location for this cell's attr into hl
124+  A8DA D1               pop de
125+  A8DB 7E               ld a,(hl)                   ; get the attr value at the address
126+  A8DC 12               ld (de),a                   ; load the attr into memory
127+  A8DD 3A 07 A8         ld a,(screen_tmp)                  ; get the block number back
128+  A8E0 CD A5 A9         call screen_getblock        ; get the block data into hl
129+  A8E3 CD 82 A9         call screen_showchar        ; show this character here
130+  A8E6
131+  A8E6              screen_initobjects1:
132+  A8E6 DD 23            inc ix                      ; move past state
133+  A8E8 DD 23            inc ix
134+  A8EA DD 23            inc ix                      ; move past mem
135+  A8EC C3 C0 A8         jp screen_initobjects
136+  A8EF              screen_initobjects2:
137+  A8EF C9               ret
138+  A8F0
139+  A8F0
140+  A8F0              ;
141+  A8F0              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
142+  A8F0              ; Inputs:
143+  A8F0              ; bc: coords
144+  A8F0              ; Outputs:
145+  A8F0              ; de: memory location
146+  A8F0              ;
147+  A8F0              screen_getcelladdress:
148+  A8F0 78               ld a,b      ; vertical position.
149+  A8F1 E6 18            and 24      ; which segment, 0, 1 or 2?
150+  A8F3 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
151+  A8F5 57               ld d,a      ; this is our high byte.
152+  A8F6 78               ld a,b      ; what was that vertical position again?
153+  A8F7 E6 07            and 7       ; which row within segment?
154+  A8F9 0F               rrca        ; multiply row by 32.
155+  A8FA 0F               rrca
156+  A8FB 0F               rrca
157+  A8FC 5F               ld e,a      ; low byte.
158+  A8FD 79               ld a,c      ; add on y coordinate.
159+  A8FE 83               add a,e     ; mix with low byte.
160+  A8FF 5F               ld e,a      ; address of screen position in de.
161+  A900 C9               ret
162+  A901
163+  A901              ;
164+  A901              ; Calculate buffer address of attribute for character at (b, c).
165+  A901              ; Inputs:
166+  A901              ; bc: coords
167+  A901              ; Outputs:
168+  A901              ; de: memory location
169+  A901              ;
170+  A901              screen_getcellattradress:
171+  A901 11 9C A2         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
172+  A904 69               ld l,c      ; x position.
173+  A905 26 00            ld h,0      ; 0 h
174+  A907 19               add hl,de
175+  A908 54 5D            ld de,hl    ; horiz done
176+  A90A 78               ld a,b      ; do vert
177+  A90B D5               push de
178+  A90C C5               push bc
179+  A90D 11 20 00         ld de,32
180+  A910 CD 3A 80         call utilities_multiply
181+  A913 C1               pop bc
182+  A914 D1               pop de
183+  A915 19               add hl,de
184+  A916 54 5D            ld de,hl    ; vert done
185+  A918 C9               ret
186+  A919
187+  A919              ;
188+  A919              ; Calculate buffer address offset of attribute for character at (b, c).
189+  A919              ; Inputs:
190+  A919              ; bc: coords
191+  A919              ; Outputs:
192+  A919              ; de: memory location
193+  A919              ;
194+  A919              screen_getcellattroffset:
195+  A919 69               ld l,c      ; x position.
196+  A91A 26 00            ld h,0      ; 0 h
197+  A91C 54 5D            ld de,hl    ; horiz done
198+  A91E 78               ld a,b      ; do vert
199+  A91F D5               push de
200+  A920 C5               push bc
201+  A921 11 20 00         ld de,32
202+  A924 CD 3A 80         call utilities_multiply
203+  A927 C1               pop bc
204+  A928 D1               pop de
205+  A929 19               add hl,de
206+  A92A 54 5D            ld de,hl    ; vert done
207+  A92C C9               ret
208+  A92D
209+  A92D              ;
210+  A92D              ; Calculate buffer address of attribute for character at (b, c).
211+  A92D              ; Inputs:
212+  A92D              ; bc: coords
213+  A92D              ; Outputs:
214+  A92D              ; de: memory location
215+  A92D              ;
216+  A92D              screen_getscreenattradress:
217+  A92D 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
218+  A930 69               ld l,c      ; x position.
219+  A931 26 00            ld h,0      ; 0 h
220+  A933 19               add hl,de
221+  A934 54 5D            ld de,hl    ; horiz done
222+  A936 78               ld a,b      ; do vert
223+  A937 D5               push de
224+  A938 C5               push bc
225+  A939 11 20 00         ld de,32
226+  A93C CD 3A 80         call utilities_multiply
227+  A93F C1               pop bc
228+  A940 D1               pop de
229+  A941 19               add hl,de
230+  A942 54 5D            ld de,hl    ; vert done
231+  A944 C9               ret
232+  A945
233+  A945              ;
234+  A945              ; Gets the attr memory location for a screen coord
235+  A945              ; Will overwrite bc
236+  A945              ; Inputs:
237+  A945              ; bc - screen coords
238+  A945              ; Outputs:
239+  A945              ; de - memory location
240+  A945              ; bc - character coords
241+  A945              ;
242+  A945              screen_getattraddressfromscreencoords:
243+  A945 78               ld a,b                          ; get the player block coords of current block
244+  A946 E6 F8            and 248                         ; find closest multiple of eight
245+  A948 0F               rrca
246+  A949 0F               rrca
247+  A94A 0F               rrca                ; divide by 8
248+  A94B 47               ld b,a
249+  A94C 79               ld a,c
250+  A94D 48               ld c,b                         ; swap b and c
251+  A94E E6 F8            and 248
252+  A950 0F               rrca
253+  A951 0F               rrca
254+  A952 0F               rrca                ; divide by 8
255+  A953 47               ld b,a
256+  A954 CD 01 A9         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
257+  A957 C9               ret
258+  A958
259+  A958
260+  A958              ; Gets the nearest cell coords for a screen coord
261+  A958              ; Will overwrite bc
262+  A958              ; Inputs:
263+  A958              ; bc - screen coords
264+  A958              ; Outputs:
265+  A958              ; bc - character coords
266+  A958              ;
267+  A958              screen_getcharcoordsfromscreencoords:
268+  A958 78               ld a,b                          ; get the player block coords of current block
269+  A959 E6 F8            and 248                         ; find closest multiple of eight
270+  A95B 0F               rrca
271+  A95C 0F               rrca
272+  A95D 0F               rrca                ; divide by 8
273+  A95E 47               ld b,a
274+  A95F 79               ld a,c
275+  A960 48               ld c,b                         ; swap b and c
276+  A961 E6 F8            and 248
277+  A963 0F               rrca
278+  A964 0F               rrca
279+  A965 0F               rrca                ; divide by 8
280+  A966 47               ld b,a
281+  A967 C9               ret
282+  A968
283+  A968              ; Gets the screen coords for a cell coord
284+  A968              ; Will overwrite bc
285+  A968              ; Inputs:
286+  A968              ; bc - char coords
287+  A968              ; Outputs:
288+  A968              ; bc - screen coords
289+  A968              ;
290+  A968              screen_getscreencoordsfromcharcoords:
291+  A968 78               ld a,b                          ; get the player block coords of current block
292+  A969 07               rlca
293+  A96A 07               rlca
294+  A96B 07               rlca                ; multiply by 8
295+  A96C 47               ld b,a
296+  A96D 79               ld a,c
297+  A96E 48               ld c,b                         ; swap b and c
298+  A96F 07               rlca
299+  A970 07               rlca
300+  A971 07               rlca                ; divide by 8
301+  A972 47               ld b,a
302+  A973 C9               ret
303+  A974
304+  A974              ;
305+  A974              ; Get buffer address for a character at b,c - b vert
306+  A974              ; Buffer memory is stored as sequential block
307+  A974              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
308+  A974              ; Inputs:
309+  A974              ; bc - coords
310+  A974              ; Outputs:
311+  A974              ; de - memory location of first byte
312+  A974              screen_getbufferaddress:
313+  A974 21 9C 85         ld hl, buffer_buffer    ; first get screen buffer start
314+  A977 50               ld d,b                  ; then work out vertical offset
315+  A978 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
316+  A97A 19               add hl,de               ; add to base
317+  A97B 59               ld e,c                  ; then add horizontal offset (c)
318+  A97C 16 00            ld d,0
319+  A97E 19               add hl,de               ; add to base
320+  A97F 54 5D            ld de,hl
321+  A981 C9               ret
322+  A982
323+  A982              ;
324+  A982              ; Display character hl at (b, c) to buffer.
325+  A982              ; Stored sequentially
326+  A982              ; Inputs:
327+  A982              ; hl: block address
328+  A982              ; bc: coords
329+  A982              ;
330+  A982              screen_showchar:
331+  A982 ED 43 41 AB      ld (origcoords),bc   ; store char coords
332+  A986 3E 00            ld a,0
333+  A988 E5               push hl
334+  A989 CD 74 A9         call screen_getbufferaddress ; get the current screen buffer pointer
335+  A98C E1               pop hl
336+  A98D 06 08            ld b,8              ; number of pixels high.
337+  A98F              screen_showchar0:
338+  A98F 7E               ld a,(hl)           ; source graphic.
339+  A990 12               ld (de),a           ; transfer to screen.
340+  A991 23               inc hl              ; next piece of data.
341+  A992 E5               push hl             ; store hl
342+  A993 62 6B            ld hl,de            ; put de in hl
343+  A995 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
344+  A997 16 00            ld d,0
345+  A999 19               add hl,de              ; add de to hl
346+  A99A 54 5D            ld de,hl            ; load back to de
347+  A99C E1               pop hl              ; restore hl
348+  A99D
349+  A99D 10 F0            djnz screen_showchar0 ; repeat
350+  A99F 2E 01            ld l,1
351+  A9A1 CD F2 AA         call sprites_marklinesforupdatechar
352+  A9A4
353+  A9A4 C9               ret
354+  A9A5
355+  A9A5
356+  A9A5              ;
357+  A9A5              ; Get cell graphic.
358+  A9A5              ; Inputs:
359+  A9A5              ; a: block
360+  A9A5              ; Outputs:
361+  A9A5              ; hl: memory
362+  A9A5              ;
363+  A9A5              screen_getblock:
364+  A9A5 07               rlca                        ; multiply block number by eight.
365+  A9A6 07               rlca
366+  A9A7 07               rlca
367+  A9A8 5F               ld e,a                      ; displacement to graphic address.
368+  A9A9 16 00            ld d,0                      ; no high byte.
369+  A9AB 21 97 B5         ld hl,sprites               ; address of character blocks.
370+  A9AE 19               add hl,de                   ; point to block.
371+  A9AF C9               ret
372+  A9B0
373+  A9B0              ;
374+  A9B0              ; Set a the attr of a coord
375+  A9B0              ; Inputs:
376+  A9B0              ; bc - char coords
377+  A9B0              ; a - attr
378+  A9B0              ;
379+  A9B0              screen_setattr:
380+  A9B0 DD E5            push ix
381+  A9B2 C5               push bc
382+  A9B3 08               ex af, af'
383+  A9B4 CD 19 A9         call screen_getcellattroffset   ; get offset into de
384+  A9B7 21 9C A2         ld hl,buffer_attr_buffer
385+  A9BA 19               add hl,de                       ; get the memory location
386+  A9BB 08               ex af, af'                      ; get attr back
387+  A9BC 77               ld (hl),a                         ; set the attr
388+  A9BD 08               ex af, af'                      ; get attr back
389+  A9BE ED 5B 06 A8      ld de,(screen_offset)           ; get the offset
390+  A9C2 78               ld a,b                          ; get the vertical
391+  A9C3 93               sub e                           ; subtract the offset
392+  A9C4 DA DA A9         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
393+  A9C7 FE 15            cp 21
394+  A9C9 D2 DA A9         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
395+  A9CC 47               ld b,a                          ; put the coord back in b
396+  A9CD CD 2D A9         call screen_getscreenattradress ; screen attr address in de
397+  A9D0 21 40 00         ld hl,64                        ; attr memory + two rows for scores
398+  A9D3 19               add hl,de
399+  A9D4 08               ex af, af'                      ; get attr back
400+  A9D5 77               ld (hl),a
401+  A9D6 C1               pop bc
402+  A9D7 DD E1            pop ix
403+  A9D9 C9               ret
404+  A9DA              screen_setattr0:
405+  A9DA C1               pop bc
406+  A9DB DD E1            pop ix
407+  A9DD C9               ret
408+  A9DE
409+  A9DE              ;
410+  A9DE              ; Get cell attribute.
411+  A9DE              ; Inputs:
412+  A9DE              ; a: block
413+  A9DE              ; Outputs:
414+  A9DE              ; hl: memory
415+  A9DE              ;
416+  A9DE              screen_getattr:
417+  A9DE 5F               ld e,a                      ; displacement to attribute address.
418+  A9DF 16 00            ld d,0                      ; no high byte.
419+  A9E1 21 77 B6         ld hl,sprite_attrs          ; address of block attributes.
420+  A9E4 19               add hl,de                   ; point to attribute.
421+  A9E5 C9               ret
422+  A9E6
423+  A9E6              ;
424+  A9E6              ; Checks whether a character block has anything in it
425+  A9E6              ; Inputs:
426+  A9E6              ; bc - char coords
427+  A9E6              ; Outputs:
428+  A9E6              ; a - 1, empty
429+  A9E6              screen_ischarempty:
430+  A9E6 CD 74 A9         call screen_getbufferaddress ; get the current screen buffer pointer
431+  A9E9 06 08            ld b,8                      ; check 8 rows
432+  A9EB              screen_ischarempty2:
433+  A9EB 1A               ld a,(de)                   ; check line
434+  A9EC FE 00            cp 0
435+  A9EE C2 FC A9         jp nz,screen_ischarempty1   ; if not zero, jump out with false
436+  A9F1 21 20 00         ld hl,32
437+  A9F4 19               add hl,de
438+  A9F5 54 5D            ld de,hl                    ; move to next row
439+  A9F7 10 F2            djnz screen_ischarempty2
440+  A9F9              screen_ischarempty0:
441+  A9F9 3E 01            ld a,1
442+  A9FB C9               ret
443+  A9FC              screen_ischarempty1:
444+  A9FC 3E 00            ld a,0
445+  A9FE C9               ret
446+  A9FF
447+  A9FF              ;
448+  A9FF              ; Copies a block from one place to another directly underneath, leaves the original empty
449+  A9FF              ; Inputs:
450+  A9FF              ; bc - coords of block to copy from
451+  A9FF              screen_copyblockdown
452+  A9FF CD 74 A9         call screen_getbufferaddress ; get the current screen buffer pointer for source
453+  AA02 06 08            ld b,8                      ; copy 8 rows
454+  AA04              screen_copyblock0:
455+  AA04 1A               ld a,(de)                    ; get what we're copying
456+  AA05 08               ex af,af'
457+  AA06 3E 00            ld a,0
458+  AA08 12               ld (de),a                    ; replace with empty
459+  AA09 08               ex af,af'
460+  AA0A 14               inc d                        ; add 256 to get to the next row
461+  AA0B 12               ld (de),a                    ; copy to the next row
462+  AA0C 15               dec d
463+  AA0D 21 20 00         ld hl,32
464+  AA10 19               add hl,de                       ; return back to source, next row down
465+  AA11 54 5D            ld de,hl
466+  AA13 10 EF            djnz screen_copyblock0
467+  AA15 C9               ret
468+  AA16
469+  AA16              ;
470+  AA16              ; Returns the first byte of a character. Useful for figuring out what's there
471+  AA16              ; Inputs:
472+  AA16              ; bc - coords
473+  AA16              ; Outputs:
474+  AA16              ; a - first byte
475+  AA16              ;
476+  AA16              screen_getcharfirstbyte:
477+  AA16 CD 74 A9         call screen_getbufferaddress ; get the current screen buffer pointer for source
478+  AA19 1A               ld a,(de)
479+  AA1A C9               ret
480+  AA1B
# file closed: screen/screen.asm
 25   AA1B                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  AA1B              ;
  2+  AA1B              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  AA1B              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  AA1B              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  AA1B              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  AA1B              ; routine takes care of all the shifting itself. This means that sprite
  7+  AA1B              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  AA1B              ; space they would require in pre-shifted form.
  9+  AA1B              ; Inputs:
 10+  AA1B              ; hl - sprite data
 11+  AA1B              ; bc - screen coords
 12+  AA1B              ;
 13+  AA1B              sprites_drawsprite7:
 14+  AA1B EE 07            xor 7               ; complement last 3 bits.
 15+  AA1D 3C               inc a               ; add one for luck!
 16+  AA1E              sprites_drawsprite3:
 17+  AA1E CB 11            rl c                ; ...into middle byte...
 18+  AA20 CB 12            rl d                ; ...and finally into left character cell.
 19+  AA22 3D               dec a               ; count shifts we've done.
 20+  AA23 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  AA25                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  AA25 79               ld a,c              ; left edge of image is currently in e.
 23+  AA26 4A               ld c,d              ; put right edge there instead.
 24+  AA27 57               ld d,a              ; and the left edge back into c.
 25+  AA28 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  AA2A              sprites_drawsprite:
 27+  AA2A ED 43 41 AB      ld (origcoords),bc  ; store coords
 28+  AA2E ED 43 43 AB      ld (dispx),bc       ; store coords in dispx for now.
 29+  AA32 E5               push hl
 30+  AA33 CD 1F AB         call sprites_scadd  ; calculate screen address.
 31+  AA36 E1               pop hl
 32+  AA37 3E 08            ld a,8              ; height of sprite in pixels.
 33+  AA39              sprites_drawsprite1:
 34+  AA39 08               ex af,af'           ; store loop counter.
 35+  AA3A D5               push de             ; store screen address.
 36+  AA3B 4E               ld c,(hl)           ; first sprite graphic.
 37+  AA3C 23               inc hl              ; increment poiinter to sprite data.
 38+  AA3D 22 45 AB         ld (sprtmp),hl      ; store it for later.
 39+  AA40 16 00            ld d,0              ; blank right byte for now.
 40+  AA42 78               ld a,b              ; b holds y position.
 41+  AA43 E6 07            and 7               ; how are we straddling character cells?
 42+  AA45 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  AA47 FE 05            cp 5                ; 5 or more right shifts needed?
 44+  AA49 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  AA4B A7               and a               ; oops, carry flag is set so clear it.
 46+  AA4C              sprites_drawsprite2:
 47+  AA4C CB 19            rr c                ; rotate left byte right...
 48+  AA4E CB 1A            rr d                ; ...into right byte.
 49+  AA50 3D               dec a               ; one less shift to do.
 50+  AA51 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  AA53              sprites_drawsprite0:
 52+  AA53 E1               pop hl              ; pop screen address from stack.
 53+  AA54 7E               ld a,(hl)           ; what's there already.
 54+  AA55 A9               xor c               ; merge in image data.
 55+  AA56 77               ld (hl),a           ; place onto screen.
 56+  AA57 23               inc hl
 57+  AA58 7E               ld a,(hl)           ; what's already there.
 58+  AA59 AA               xor d               ; right edge of sprite image data.
 59+  AA5A 77               ld (hl),a           ; plonk it on screen.
 60+  AA5B 3A 43 AB         ld a,(dispx)        ; vertical coordinate.
 61+  AA5E 3C               inc a               ; next line down.
 62+  AA5F 32 43 AB         ld (dispx),a        ; store new position.
 63+  AA62 2B               dec hl
 64+  AA63 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  AA66 19               add hl,de           ; add 32
 66+  AA67              sprites_drawsprite6:
 67+  AA67 EB               ex de,hl            ; screen address in de.
 68+  AA68 2A 45 AB         ld hl,(sprtmp)      ; restore graphic address.
 69+  AA6B 08               ex af,af'           ; restore loop counter.
 70+  AA6C 3D               dec a               ; decrement it.
 71+  AA6D C2 39 AA         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  AA70 2E 02            ld l,2
 73+  AA72 CD E1 AA         call sprites_marklinesforupdatescreen
 74+  AA75 C9               ret                 ; job done.
 75+  AA76
 76+  AA76              ; Inputs:
 77+  AA76              ; hl - sprite data
 78+  AA76              ; bc - screen coords
 79+  AA76              ;
 80+  AA76              sprites_draw2by2sprite7
 81+  AA76 EE 07            xor 7               ; complement last 3 bits.
 82+  AA78 3C               inc a               ; add one for luck!
 83+  AA79              sprites_draw2by2sprite3
 84+  AA79 CB 12            rl d                ; rotate left...
 85+  AA7B CB 11            rl c                ; ...into middle byte...
 86+  AA7D CB 13            rl e                ; ...and finally into left character cell.
 87+  AA7F 3D               dec a               ; count shifts we've done.
 88+  AA80 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  AA82                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  AA82 7B               ld a,e              ; left edge of image is currently in e.
 91+  AA83 5A               ld e,d              ; put right edge there instead.
 92+  AA84 51               ld d,c              ; middle bit goes in d.
 93+  AA85 4F               ld c,a              ; and the left edge back into c.
 94+  AA86 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  AA88              sprites_draw2by2sprite
 96+  AA88 ED 43 41 AB      ld (origcoords),bc  ; store coords
 97+  AA8C ED 43 43 AB      ld (dispx),bc       ; store coords in dispx for now.
 98+  AA90 79               ld a,c
 99+  AA91 32 47 AB         ld (sprtmp0),a         ; store vertical.
100+  AA94 E5               push hl
101+  AA95 CD 1F AB         call sprites_scadd          ; calculate screen address.
102+  AA98 E1               pop hl
103+  AA99 3E 10            ld a,16             ; height of sprite in pixels.
104+  AA9B              sprites_draw2by2sprite1
105+  AA9B 08               ex af,af'           ; store loop counter.
106+  AA9C D5               push de             ; store screen address.
107+  AA9D 4E               ld c,(hl)           ; first sprite graphic.
108+  AA9E 23               inc hl              ; increment poiinter to sprite data.
109+  AA9F 56               ld d,(hl)           ; next bit of sprite image.
110+  AAA0 23               inc hl              ; point to next row of sprite data.
111+  AAA1 22 45 AB         ld (sprtmp),hl        ; store in tmp0 for later.
112+  AAA4 1E 00            ld e,0              ; blank right byte for now.
113+  AAA6 78               ld a,b              ; b holds y position.
114+  AAA7 E6 07            and 7               ; how are we straddling character cells?
115+  AAA9 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  AAAB FE 05            cp 5                ; 5 or more right shifts needed?
117+  AAAD 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  AAAF A7               and a               ; oops, carry flag is set so clear it.
119+  AAB0              sprites_draw2by2sprite2
120+  AAB0 CB 19            rr c                ; rotate left byte right...
121+  AAB2 CB 1A            rr d                ; ...through middle byte...
122+  AAB4 CB 1B            rr e                ; ...into right byte.
123+  AAB6 3D               dec a               ; one less shift to do.
124+  AAB7 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  AAB9              sprites_draw2by2sprite0
126+  AAB9 E1               pop hl              ; pop screen address from stack.
127+  AABA 7E               ld a,(hl)           ; what's there already.
128+  AABB A9               xor c               ; merge in image data.
129+  AABC 77               ld (hl),a           ; place onto screen.
130+  AABD 23               inc hl               ; next character cell to right please.
131+  AABE 7E               ld a,(hl)           ; what's there already.
132+  AABF AA               xor d               ; merge with middle bit of image.
133+  AAC0 77               ld (hl),a           ; put back onto screen.
134+  AAC1 23               inc hl              ; next bit of screen area.
135+  AAC2 7E               ld a,(hl)           ; what's already there.
136+  AAC3 AB               xor e               ; right edge of sprite image data.
137+  AAC4 77               ld (hl),a           ; plonk it on screen.
138+  AAC5 3A 47 AB         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  AAC8 3C               inc a               ; next line down.
140+  AAC9 32 47 AB         ld (sprtmp0),a         ; store new position.
141+  AACC 2B               dec hl
142+  AACD 2B               dec hl
143+  AACE 11 20 00         ld de,32            ; add 32 to get to the next row
144+  AAD1 19               add hl,de           ; add 32
145+  AAD2              sprites_draw2by2sprite6
146+  AAD2 EB               ex de,hl            ; screen address in de.
147+  AAD3 2A 45 AB         ld hl,(sprtmp)        ; restore graphic address.
148+  AAD6 08               ex af,af'           ; restore loop counter.
149+  AAD7 3D               dec a               ; decrement it.
150+  AAD8 C2 9B AA         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  AADB 2E 03            ld l,3
152+  AADD CD E1 AA         call sprites_marklinesforupdatescreen
153+  AAE0 C9               ret                 ; job done.
154+  AAE1
155+  AAE1              ;
156+  AAE1              ; Marks lines for update with screen coords
157+  AAE1              ; Inputs:
158+  AAE1              ; l - number to update
159+  AAE1              ;
160+  AAE1              sprites_marklinesforupdatescreen:
161+  AAE1 F5               push af
162+  AAE2 ED 4B 41 AB      ld bc,(origcoords)
163+  AAE6 CD 58 A9         call screen_getcharcoordsfromscreencoords
164+  AAE9 ED 43 41 AB      ld (origcoords),bc
165+  AAED CD FC AA         call sprites_marklinesforupdate
166+  AAF0 F1               pop af
167+  AAF1 C9               ret
168+  AAF2
169+  AAF2              ;
170+  AAF2              ; Marks lines for update with char coords
171+  AAF2              ; Inputs:
172+  AAF2              ; l - number to update
173+  AAF2              ;
174+  AAF2              sprites_marklinesforupdatechar:
175+  AAF2 F5               push af
176+  AAF3 ED 43 41 AB      ld (origcoords),bc
177+  AAF7 CD FC AA         call sprites_marklinesforupdate
178+  AAFA F1               pop af
179+  AAFB C9               ret
180+  AAFC
181+  AAFC              ;
182+  AAFC              ; Marks lines for update
183+  AAFC              ; Inputs:
184+  AAFC              ; l - number to update
185+  AAFC              ;
186+  AAFC              sprites_marklinesforupdate:
187+  AAFC ED 4B 41 AB      ld bc,(origcoords)
188+  AB00 ED 5B 06 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
189+  AB04 78               ld a,b
190+  AB05 93               sub e
191+  AB06 47               ld b,a
192+  AB07 7D               ld a,l                          ; get loop counter
193+  AB08              sprites_marklinesforupdate0:
194+  AB08 C5               push bc
195+  AB09 08               ex af,af'                     ; store loop counter
196+  AB0A 78               ld a,b
197+  AB0B CD 54 A6         call buffer_marklineforupdate ; mark this line for update
198+  AB0E ED 4B 41 AB      ld bc,(origcoords)            ; move the coords for the next line
199+  AB12 04               inc b
200+  AB13 ED 43 41 AB      ld (origcoords),bc
201+  AB17 C1               pop bc
202+  AB18 04               inc b
203+  AB19 08               ex af,af'                     ; restore loop counter
204+  AB1A 3D               dec a
205+  AB1B C2 08 AB         jp nz,sprites_marklinesforupdate0
206+  AB1E C9               ret
207+  AB1F
208+  AB1F              ;
209+  AB1F              ; This routine returns a buffer address for (c, b) in de (c vert).
210+  AB1F              ; For example: 0,0 will be at memory offset 0
211+  AB1F              ; 1,0 (1 down) will be at memory offset 1
212+  AB1F              ; 0,7 will be at memory offset 0
213+  AB1F              ; 9,1 will be at memory offset 8+1
214+  AB1F              ; 8,0 will be at memory offset 256
215+  AB1F              ; 9,0 will be at memory offset 257
216+  AB1F              ; Outputs:
217+  AB1F              ; de - coords
218+  AB1F              ;
219+  AB1F              sprites_scadd:
220+  AB1F 79               ld a,c               ; calculate vertical offset
221+  AB20 E6 F8            and 248             ;  to get nearest multiple of 8
222+  AB22 0F               rrca
223+  AB23 0F               rrca
224+  AB24 0F               rrca                ; divide by 8
225+  AB25 67               ld h,a
226+  AB26 78               ld a,b               ; calculate horizontal offset
227+  AB27 E6 F8            and 248             ;  to get nearest multiple of 8
228+  AB29 0F               rrca
229+  AB2A 0F               rrca
230+  AB2B 0F               rrca                ; divide by 8
231+  AB2C 6F               ld l,a
232+  AB2D C5               push bc             ; store the screen coords
233+  AB2E 44 4D            ld bc,hl            ; load bc with the character coords
234+  AB30 CD 74 A9         call screen_getbufferaddress
235+  AB33 C1               pop bc              ; get back screen coords, de is now memory of character
236+  AB34 79               ld a,c              ; now add the vertical within the cell
237+  AB35 E6 07            and 7
238+  AB37 0F               rrca                ; multiply by 32.
239+  AB38 0F               rrca
240+  AB39 0F               rrca
241+  AB3A 6F               ld l,a
242+  AB3B 26 00            ld h,0
243+  AB3D 19               add hl,de
244+  AB3E 54 5D            ld de,hl
245+  AB40 C9               ret
246+  AB41
247+  AB41 00 00        origcoords   defb 0,0           ; general-use coordinates.
248+  AB43
249+  AB43 00           dispx   defb 0           ; general-use coordinates.
250+  AB44 00           dispy   defb 0
251+  AB45 00 00        sprtmp  defb 0,0           ; sprite temporary address.
252+  AB47 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
253+  AB49
# file closed: screen/sprites.asm
 26   AB49                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AB49              ;
  2+  AB49              ; Draws the title screen
  3+  AB49              ;
  4+  AB49              titlescreen_show:
  5+  AB49 CD CB AB         call titlescreen_init
  6+  AB4C CD 74 AB         call titlescreen_drawtitle
  7+  AB4F 06 32            ld b,50
  8+  AB51 CD 99 80         call utilities_pauseforframes         ; pause for a second
  9+  AB54
 10+  AB54 3E FA            ld a,250                              ; wait for 200 frames
 11+  AB56 CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 12+  AB59 7B               ld a,e
 13+  AB5A FE 01            cp 1                                  ; was anything pressed?
 14+  AB5C C8               ret z                                 ; end titlescreen if so
 15+  AB5D
 16+  AB5D CD DE AB         call titlescreen_alt_init             ; otherwise, draw alt screen
 17+  AB60 CD 90 AB         call titlescreen_alt_drawtitle
 18+  AB63 06 32            ld b,50
 19+  AB65 CD 99 80         call utilities_pauseforframes         ; pause for a second
 20+  AB68
 21+  AB68 3E FA            ld a,250                              ; wait for 200 frames
 22+  AB6A CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 23+  AB6D 7B               ld a,e
 24+  AB6E FE 01            cp 1                                  ; was anything pressed?
 25+  AB70 C2 49 AB         jp nz,titlescreen_show                ; start again if not
 26+  AB73 C9               ret
 27+  AB74
 28+  AB74              ;
 29+  AB74              ; Draws the iconic logo
 30+  AB74              ;
 31+  AB74              titlescreen_drawtitle:
 32+  AB74 06 67            ld b,103              ; number of points
 33+  AB76 DD 21 EB AB      ld ix,titlescreen_logo_data
 34+  AB7A              titlescreen_drawtitle0:
 35+  AB7A C5               push bc
 36+  AB7B DD 4E 00         ld c,(ix)                   ; got horiz
 37+  AB7E DD 23            inc ix
 38+  AB80 DD 46 00         ld b,(ix)                   ; got vert
 39+  AB83 DD 23            inc ix
 40+  AB85 CD 2D A9         call screen_getscreenattradress ; memory in de
 41+  AB88 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 42+  AB89 3E 13            ld a,19
 43+  AB8B 12               ld (de),a
 44+  AB8C C1               pop bc
 45+  AB8D 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 46+  AB8F C9               ret
 47+  AB90
 48+  AB90              ;
 49+  AB90              ; Draws the alternate title screen
 50+  AB90              ;
 51+  AB90              titlescreen_alt_drawtitle:
 52+  AB90 21 52 81         ld hl,string_alttitlescreen_1
 53+  AB93 CD 54 85         call string_print
 54+  AB96 21 5E 81         ld hl,string_alttitlescreen_2
 55+  AB99 CD 54 85         call string_print
 56+  AB9C 21 59 82         ld hl,string_alttitlescreen_3
 57+  AB9F CD 54 85         call string_print
 58+  ABA2 06 20            ld b,32
 59+  ABA4 3E 43            ld a,67
 60+  ABA6 11 00 58         ld de,22528                         ; top row attrs here
 61+  ABA9 CD BB A8         call screen_setcolours
 62+  ABAC 06 20            ld b,32
 63+  ABAE 3E 46            ld a,70
 64+  ABB0 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 65+  ABB3 CD BB A8         call screen_setcolours
 66+  ABB6 06 20            ld b,32
 67+  ABB8 3E 43            ld a,67
 68+  ABBA 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 69+  ABBD CD BB A8         call screen_setcolours
 70+  ABC0 06 20            ld b,32
 71+  ABC2 3E 42            ld a,66
 72+  ABC4 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 73+  ABC7 CD BB A8         call screen_setcolours
 74+  ABCA C9               ret
 75+  ABCB
 76+  ABCB              ;
 77+  ABCB              ; Initialises the screen
 78+  ABCB              ;
 79+  ABCB              titlescreen_init:
 80+  ABCB              ; We want a black screen.
 81+  ABCB 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 82+  ABCD                                      ; bright (64).
 83+  ABCD CD 7E 80         call utilities_clearscreen
 84+  ABD0 32 8D 5C         ld (23693),a        ; set our screen colours.
 85+  ABD3 3E 01            ld a,1              ; 2 is the code for red.
 86+  ABD5 D3 FE            out (254),a         ; write to port 254.
 87+  ABD7
 88+  ABD7 21 3D 81         ld hl,string_titlescreen_copyright
 89+  ABDA CD 54 85         call string_print
 90+  ABDD
 91+  ABDD C9               ret
 92+  ABDE
 93+  ABDE              ;
 94+  ABDE              ; Initialises the screen
 95+  ABDE              ;
 96+  ABDE              titlescreen_alt_init:
 97+  ABDE              ; We want a black screen.
 98+  ABDE 3E 47            ld a,71             ; white ink (7) on black paper (0),
 99+  ABE0                                      ; bright (64).
100+  ABE0 CD 7E 80         call utilities_clearscreen
101+  ABE3 32 8D 5C         ld (23693),a        ; set our screen colours.
102+  ABE6 3E 00            ld a,0              ; 2 is the code for red.
103+  ABE8 D3 FE            out (254),a         ; write to port 254.
104+  ABEA
105+  ABEA C9               ret
106+  ABEB
107+  ABEB              ;
108+  ABEB              ; Horiz, vert
109+  ABEB              ;
110+  ABEB              titlescreen_logo_data:
111+  ABEB 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
111+  ABEF 0A 00 0C 00
111+  ABF3 0F 00 11 00
111+  ABF7 12 00 13 00
112+  ABFB 09 01 0C 01      defb 9,1,12,1,15,1,17,1
112+  ABFF 0F 01 11 01
113+  AC03 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
113+  AC07 0D 02 0E 02
113+  AC0B 0F 02 11 02
113+  AC0F 12 02 13 02
114+  AC13 09 03 0C 03      defb 9,3,12,3,15,3,17,3
114+  AC17 0F 03 11 03
115+  AC1B 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
115+  AC1F 0F 04 11 04
115+  AC23 12 04 13 04
116+  AC27 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
116+  AC2B 02 06 03 06
116+  AC2F 04 06 05 06
116+  AC33 06 06 07 06
116+  AC37 08 06 09 06
116+  AC3B 0A 06 0B 06
117+  AC3F 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
117+  AC43 12 06 13 06
117+  AC47 14 06 15 06
117+  AC4B 16 06 17 06
117+  AC4F 18 06 19 06
117+  AC53 1A 06 1B 06
118+  AC57 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
118+  AC5B 02 09 02 0A
118+  AC5F 02 0B 02 0C
118+  AC63 02 0D 02 0E
118+  AC67 02 0F 02 10
118+  AC6B 02 11 02 12
118+  AC6F 02 13 02 14
118+  AC73 02 15
119+  AC75 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
119+  AC79 19 09 19 0A
119+  AC7D 19 0B 19 0C
119+  AC81 19 0D 19 0E
119+  AC85 19 0F 19 10
119+  AC89 19 11 19 12
119+  AC8D 19 13 19 14
119+  AC91 19 15
120+  AC93 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
120+  AC97 05 0B 06 0B
120+  AC9B 07 0B 08 0B
120+  AC9F 09 0B 0A 0B
120+  ACA3 0B 0B
121+  ACA5 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
121+  ACA9 0B 09 0B 0A
122+  ACAD 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
122+  ACB1 10 10 10 11
122+  ACB5 10 12 10 13
123+  ACB9
# file closed: screen/titlescreen.asm
 27   ACB9                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ACB9              ;
  2+  ACB9              ; Draws the life remaining screen
  3+  ACB9              ;
  4+  ACB9              lifescreen_draw:
  5+  ACB9 CD 04 AD         call lifescreen_init
  6+  ACBC
  7+  ACBC 3A 43 BD         ld a,(game_currentplayer)             ; get the current player
  8+  ACBF C6 30            add 48                                ; add 48 to get char
  9+  ACC1 21 5F 83         ld hl,string_lifescreen_player+10
 10+  ACC4 77               ld (hl),a                             ; load this to the string we're about to show
 11+  ACC5
 12+  ACC5 21 55 83         ld hl,string_lifescreen_player
 13+  ACC8 CD 54 85         call string_print
 14+  ACCB
 15+  ACCB 3A 83 BD         ld a,(player+9)                       ; get the current player lives
 16+  ACCE C6 30            add 48                                ; add 48 to get the character
 17+  ACD0 FE 31            cp 49
 18+  ACD2 C2 E5 AC         jp nz,lifescreen_draw0
 19+  ACD5 21 6F 83         ld hl,string_lifescreen_lastman
 20+  ACD8
 21+  ACD8 06 08            ld b,8
 22+  ACDA 3E 0A            ld a,10                                ; set red
 23+  ACDC 11 6C 58         ld de,22528+108                        ; attrs here
 24+  ACDF CD BB A8         call screen_setcolours
 25+  ACE2
 26+  ACE2 C3 EC AC         jp lifescreen_draw1
 27+  ACE5              lifescreen_draw0:
 28+  ACE5 21 64 83         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  ACE8 77               ld (hl),a                             ; load this to the string we're about to show
 30+  ACE9 21 62 83         ld hl,string_lifescreen_lives
 31+  ACEC              lifescreen_draw1:
 32+  ACEC CD 54 85         call string_print
 33+  ACEF
 34+  ACEF 3E 86            ld a,134
 35+  ACF1 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  ACF4 06 0A            ld b,10
 37+  ACF6 CD BB A8         call screen_setcolours
 38+  ACF9
 39+  ACF9 06 32            ld b,50
 40+  ACFB CD 99 80         call utilities_pauseforframes         ; pause for a second
 41+  ACFE
 42+  ACFE 3E 64            ld a,100                              ; wait for 200 frames
 43+  AD00 CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 44+  AD03
 45+  AD03 C9               ret
 46+  AD04
 47+  AD04              ;
 48+  AD04              ; Initialises the screen
 49+  AD04              ;
 50+  AD04              lifescreen_init:
 51+  AD04              ; We want a blue screen.
 52+  AD04                  ;call $0D6B
 53+  AD04 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 54+  AD06                                      ; bright (64).
 55+  AD06 CD 7E 80         call utilities_clearscreen
 56+  AD09 32 8D 5C         ld (23693),a        ; set our screen colours.
 57+  AD0C 3E 01            ld a,1              ; 1 is the code for blue.
 58+  AD0E D3 FE            out (254),a         ; write to port 254.
 59+  AD10                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 60+  AD10
 61+  AD10 C9               ret
# file closed: screen/lifescreen.asm
 28   AD11                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AD11              ;
  2+  AD11              ; Draws the game over screen
  3+  AD11              ;
  4+  AD11              gameover_draw:
  5+  AD11 CD D4 C4         call scores_processhighscores
  6+  AD14
  7+  AD14              gameover_draw0:
  8+  AD14 CD 54 AD         call gameover_enterhighscores
  9+  AD17
 10+  AD17 CD F2 AD         call gameover_init
 11+  AD1A
 12+  AD1A 21 7A 83         ld hl,string_gameoverscreen_gameover
 13+  AD1D CD 54 85         call string_print
 14+  AD20
 15+  AD20 21 86 83         ld hl,string_gameoverscreen_copyright
 16+  AD23 CD 54 85         call string_print
 17+  AD26
 18+  AD26 CD 37 AD         call gameover_commontext
 19+  AD29
 20+  AD29 06 0B            ld b,11
 21+  AD2B 3E 42            ld a,66
 22+  AD2D 11 2B 58         ld de,22528+43                         ; attrs here
 23+  AD30 CD BB A8         call screen_setcolours
 24+  AD33 CD 47 80         call utilities_waitforkey   ; wait for keypress
 25+  AD36
 26+  AD36 C9               ret
 27+  AD37
 28+  AD37              ;
 29+  AD37              ; Draws text shared by the game over and high score screens
 30+  AD37              ;
 31+  AD37              gameover_commontext:
 32+  AD37 CD 8D A8         call screen_setuptext       ; show scores
 33+  AD3A CD 9E C4         call scores_printscores     ; print the current scores
 34+  AD3D
 35+  AD3D 21 AE 83         ld hl,string_gameover_credits
 36+  AD40 CD 54 85         call string_print
 37+  AD43
 38+  AD43 21 9A 83         ld hl,string_gameoverscreen_bestscores
 39+  AD46 CD 54 85         call string_print
 40+  AD49
 41+  AD49 06 20            ld b,32
 42+  AD4B 3E 45            ld a,69
 43+  AD4D 11 C0 5A         ld de,22528+704                         ; attrs here
 44+  AD50 CD BB A8         call screen_setcolours
 45+  AD53
 46+  AD53 C9               ret
 47+  AD54
 48+  AD54              ;
 49+  AD54              ; If required, enter highscore
 50+  AD54              ;
 51+  AD54              gameover_enterhighscores:
 52+  AD54                  ; check if we need to enter initial
 53+  AD54 3A D3 C4         ld a,(scores_highscoretmp)
 54+  AD57 FE 00            cp 0
 55+  AD59 C8               ret z
 56+  AD5A CD 88 AD         call gameover_enterhighscores_init
 57+  AD5D 3A D3 C4         ld a,(scores_highscoretmp)
 58+  AD60 3D               dec a
 59+  AD61 3D               dec a
 60+  AD62 3D               dec a                                   ; get high score location back to position of name
 61+  AD63 16 00            ld d,0
 62+  AD65 5F               ld e,a
 63+  AD66 21 53 C4         ld hl,scores_table
 64+  AD69 19               add hl,de                               ; load memory into hl
 65+  AD6A 08               ex af,af'
 66+  AD6B 06 0F            ld b,15
 67+  AD6D CD 99 80         call utilities_pauseforframes           ; pause for a little bit
 68+  AD70 06 03            ld b,3                                  ; collect three chars
 69+  AD72              gameover_draw2:
 70+  AD72 C5               push bc
 71+  AD73 E5               push hl
 72+  AD74 CD 9D 80         call utilities_readkey               ; get key into a
 73+  AD77 E1               pop hl
 74+  AD78 77               ld (hl),a
 75+  AD79 23               inc hl
 76+  AD7A E5               push hl
 77+  AD7B CD C0 C4         call scores_showtable
 78+  AD7E E1               pop hl
 79+  AD7F 06 0F            ld b,15
 80+  AD81 CD 99 80         call utilities_pauseforframes
 81+  AD84 C1               pop bc
 82+  AD85 10 EB            djnz gameover_draw2
 83+  AD87 C9               ret
 84+  AD88
 85+  AD88              ;
 86+  AD88              ; Displays the screen text for high score entry
 87+  AD88              ;
 88+  AD88              gameover_enterhighscores_init:
 89+  AD88
 90+  AD88 CD F2 AD         call gameover_init
 91+  AD8B CD 37 AD         call gameover_commontext
 92+  AD8E
 93+  AD8E 21 BA 83         ld hl,string_highscore_congratulations
 94+  AD91 CD 54 85         call string_print
 95+  AD94
 96+  AD94 3A 43 BD         ld a,(game_currentplayer)
 97+  AD97 FE 01            cp 1
 98+  AD99 21 CC 83         ld hl,string_highscore_player1
 99+  AD9C C3 A2 AD         jp gameover_enterhighscores_init1
100+  AD9F              gameover_enterhighscores_init0:
101+  AD9F 21 D7 83         ld hl,string_highscore_player2
102+  ADA2              gameover_enterhighscores_init1:
103+  ADA2 CD 54 85         call string_print
104+  ADA5 06 60            ld b,96
105+  ADA7 3E 43            ld a,67
106+  ADA9 11 A0 58         ld de,22528+160                         ; attrs here
107+  ADAC CD BB A8         call screen_setcolours
108+  ADAF
109+  ADAF 21 E2 83         ld hl,string_highscore_youhaveearned
110+  ADB2 CD 54 85         call string_print
111+  ADB5
112+  ADB5 3A D3 C4         ld a,(scores_highscoretmp)
113+  ADB8 FE 05            cp 5
114+  ADBA CA C8 AD         jp z, gameover_enterhighscores_init2    ; first place
115+  ADBD FE 11            cp 17
116+  ADBF CA CE AD         jp z, gameover_enterhighscores_init3    ; 2nd place
117+  ADC2 21 1E 84         ld hl,string_highscore_place3           ; 3rd place
118+  ADC5 C3 D4 AD         jp gameover_enterhighscores_init4
119+  ADC8              gameover_enterhighscores_init2
120+  ADC8 21 F4 83         ld hl,string_highscore_place1
121+  ADCB C3 D4 AD         jp gameover_enterhighscores_init4
122+  ADCE              gameover_enterhighscores_init3
123+  ADCE 21 09 84         ld hl,string_highscore_place2
124+  ADD1 C3 D4 AD         jp gameover_enterhighscores_init4
125+  ADD4              gameover_enterhighscores_init4
126+  ADD4 CD 54 85         call string_print
127+  ADD7
128+  ADD7 06 60            ld b,96
129+  ADD9 3E 42            ld a,66
130+  ADDB 11 40 59         ld de,22528+320                         ; attrs here
131+  ADDE CD BB A8         call screen_setcolours
132+  ADE1
133+  ADE1 21 33 84         ld hl,string_highscore_pleaseenter
134+  ADE4 CD 54 85         call string_print
135+  ADE7
136+  ADE7 06 60            ld b,96
137+  ADE9 3E 46            ld a,70
138+  ADEB 11 E0 59         ld de,22528+480                         ; attrs here
139+  ADEE CD BB A8         call screen_setcolours
140+  ADF1 C9               ret
141+  ADF2
142+  ADF2              ;
143+  ADF2              ; Initialises the screen
144+  ADF2              ;
145+  ADF2              gameover_init:
146+  ADF2              ; We want a black screen.
147+  ADF2 3E 47            ld a,71             ; white ink (7) on black paper (0),
148+  ADF4                                      ; bright (64).
149+  ADF4 CD 7E 80         call utilities_clearscreen
150+  ADF7 32 8D 5C         ld (23693),a        ; set our screen colours.
151+  ADFA 3E 00            ld a,0              ; 2 is the code for red.
152+  ADFC D3 FE            out (254),a         ; write to port 254.
153+  ADFE C9               ret
# file closed: screen/gameover.asm
 29   ADFF                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  ADFF              ;
  2+  ADFF              ; Draws the level transition screen
  3+  ADFF              ;
  4+  ADFF              endlevel_draw:
  5+  ADFF CD F5 AE         call endlevel_init
  6+  AE02 CD DE AE         call endlevel_commontext
  7+  AE05
  8+  AE05 21 BA 83         ld hl,string_highscore_congratulations
  9+  AE08 CD 54 85         call string_print
 10+  AE0B
 11+  AE0B 3A 43 BD         ld a,(game_currentplayer)
 12+  AE0E FE 01            cp 1
 13+  AE10 21 CC 83         ld hl,string_highscore_player1
 14+  AE13 C3 19 AE         jp endlevel_init1
 15+  AE16              endlevel_init0:
 16+  AE16 21 D7 83         ld hl,string_highscore_player2
 17+  AE19              endlevel_init1:
 18+  AE19 CD 54 85         call string_print
 19+  AE1C
 20+  AE1C 21 50 84         ld hl,string_endlevel_youhaveearned
 21+  AE1F CD 54 85         call string_print
 22+  AE22
 23+  AE22 CD 7D AE         call endlevel_workoutbonus
 24+  AE25 D5               push de
 25+  AE26 08               ex af,af'                               ; store the a value for later
 26+  AE27 CD 54 85         call string_print
 27+  AE2A D1               pop de
 28+  AE2B 62 6B            ld hl,de                                ; get the points text into de
 29+  AE2D CD 54 85         call string_print
 30+  AE30
 31+  AE30 21 BB 84         ld hl, string_endlevel_anothergo
 32+  AE33 CD 54 85         call string_print
 33+  AE36
 34+  AE36 06 20            ld b,32
 35+  AE38 3E 23            ld a,35
 36+  AE3A 11 60 59         ld de,22528+352                         ; attrs here
 37+  AE3D CD BB A8         call screen_setcolours
 38+  AE40
 39+  AE40 06 20            ld b,32
 40+  AE42 3E 25            ld a,37
 41+  AE44 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AE47 CD BB A8         call screen_setcolours
 43+  AE4A
 44+  AE4A 06 20            ld b,32
 45+  AE4C 3E 23            ld a,35
 46+  AE4E 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AE51 CD BB A8         call screen_setcolours
 48+  AE54
 49+  AE54 06 20            ld b,32
 50+  AE56 3E 22            ld a,34
 51+  AE58 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AE5B CD BB A8         call screen_setcolours
 53+  AE5E
 54+  AE5E 08               ex af,af'                               ; get back a value with bonus type
 55+  AE5F 06 14            ld b,20
 56+  AE61 CD 99 80         call utilities_pauseforframes
 57+  AE64
 58+  AE64 47               ld b,a                      ; put the bonus count in b
 59+  AE65              endlevel_init2:
 60+  AE65 C5               push bc
 61+  AE66 06 01            ld b,1
 62+  AE68 CD 77 C4         call scores_addthousands
 63+  AE6B CD 9E C4         call scores_printscores     ; print the current scores
 64+  AE6E 06 0A            ld b,10
 65+  AE70 CD 99 80         call utilities_pauseforframes
 66+  AE73 C1               pop bc
 67+  AE74 10 EF            djnz endlevel_init2
 68+  AE76 CD 73 BD         call game_increasedifficulty ; move the difficulty up a level
 69+  AE79 CD 47 80         call utilities_waitforkey   ; wait for keypress
 70+  AE7C
 71+  AE7C C9               ret
 72+  AE7D
 73+  AE7D              ;
 74+  AE7D              ; Works out the bonus
 75+  AE7D              ; Outputs:
 76+  AE7D              ; a = 15 (all seven)
 77+  AE7D              ; a = 10 (3 large or 4 small)
 78+  AE7D              ; a = 5 (1 large diamond)
 79+  AE7D              ; hl - pointer to bonus text
 80+  AE7D              ; de - pointer to points text
 81+  AE7D              ;
 82+  AE7D              endlevel_workoutbonus:
 83+  AE7D 21 14 B5         ld hl,level01diamonds+2     ; location of state of first diamond
 84+  AE80 06 03            ld b,3                      ; number to check
 85+  AE82 16 00            ld d,0                      ; zero diamond count
 86+  AE84              endlevel_workoutbonus0:
 87+  AE84 7E               ld a,(hl)                   ; get state
 88+  AE85 FE 01            cp 1
 89+  AE87 C2 8B AE         jp nz,endlevel_workoutbonus1 ; if not, move on
 90+  AE8A 14               inc d                       ; increment diamond count
 91+  AE8B              endlevel_workoutbonus1:
 92+  AE8B 23               inc hl
 93+  AE8C 23               inc hl
 94+  AE8D 23               inc hl
 95+  AE8E 23               inc hl
 96+  AE8F 23               inc hl                      ; get to next state
 97+  AE90 10 F2            djnz endlevel_workoutbonus0
 98+  AE92
 99+  AE92 21 24 B5         ld hl,level01gems+2     ; location of state of first gem
100+  AE95 06 04            ld b,4                      ; number to check
101+  AE97 1E 00            ld e,0                      ; zero gem count
102+  AE99              endlevel_workoutbonus2:
103+  AE99 7E               ld a,(hl)                   ; get state
104+  AE9A FE 01            cp 1
105+  AE9C C2 A0 AE         jp nz,endlevel_workoutbonus3 ; if not, move on
106+  AE9F 1C               inc e                       ; increment diamond count
107+  AEA0              endlevel_workoutbonus3:
108+  AEA0 23               inc hl
109+  AEA1 23               inc hl
110+  AEA2 23               inc hl
111+  AEA3 23               inc hl
112+  AEA4 23               inc hl                     ; get to next state
113+  AEA5 10 F2            djnz endlevel_workoutbonus2
114+  AEA7
115+  AEA7 7A               ld a,d
116+  AEA8 83               add e
117+  AEA9 FE 07            cp 7                        ; check for max bonus
118+  AEAB C2 B7 AE         jp nz,endlevel_workoutbonus4 ;
119+  AEAE 3E 0F            ld a,15
120+  AEB0 21 80 84         ld hl, string_endlevel_bonus3
121+  AEB3 11 AC 84         ld de, string_endlevel_points3
122+  AEB6 C9               ret                         ; return with bonus of 15
123+  AEB7              endlevel_workoutbonus4:
124+  AEB7 7A               ld a,d                      ; check for for diamonds
125+  AEB8 FE 03            cp 3
126+  AEBA C2 C6 AE         jp nz,endlevel_workoutbonus5
127+  AEBD 3E 0A            ld a,10
128+  AEBF 21 71 84         ld hl, string_endlevel_bonus2
129+  AEC2 11 9D 84         ld de, string_endlevel_points2
130+  AEC5 C9               ret                         ; return with bonus of ten
131+  AEC6              endlevel_workoutbonus5:
132+  AEC6 7B               ld a,e                      ; check for four gems
133+  AEC7 FE 04            cp 4
134+  AEC9 C2 D5 AE         jp nz,endlevel_workoutbonus6
135+  AECC 3E 0A            ld a,10
136+  AECE 21 71 84         ld hl, string_endlevel_bonus2
137+  AED1 11 9D 84         ld de, string_endlevel_points2
138+  AED4 C9               ret                         ; return with bonus of 10
139+  AED5              endlevel_workoutbonus6:
140+  AED5 3E 05            ld a,5                      ; otherwise, bonus is 5
141+  AED7 21 62 84         ld hl, string_endlevel_bonus1
142+  AEDA 11 8F 84         ld de, string_endlevel_points1
143+  AEDD C9               ret
144+  AEDE
145+  AEDE              ;
146+  AEDE              ; Draws text shared by the game over and high score screens
147+  AEDE              ;
148+  AEDE              endlevel_commontext:
149+  AEDE CD 8D A8         call screen_setuptext       ; show scores
150+  AEE1 CD 9E C4         call scores_printscores     ; print the current scores
151+  AEE4
152+  AEE4 21 9A 83         ld hl,string_gameoverscreen_bestscores
153+  AEE7 CD 54 85         call string_print
154+  AEEA
155+  AEEA 06 20            ld b,32
156+  AEEC 3E 45            ld a,69
157+  AEEE 11 C0 5A         ld de,22528+704                         ; attrs here
158+  AEF1 CD BB A8         call screen_setcolours
159+  AEF4
160+  AEF4 C9               ret
161+  AEF5
162+  AEF5              ;
163+  AEF5              ; Initialises the screen
164+  AEF5              ;
165+  AEF5              endlevel_init:
166+  AEF5              ; We want a green screen.
167+  AEF5 3E 21            ld a,33             ; white ink (7) on black paper (0),
168+  AEF7                                      ; bright (64).
169+  AEF7 CD 7E 80         call utilities_clearscreen
170+  AEFA 32 8D 5C         ld (23693),a        ; set our screen colours.
171+  AEFD 3E 00            ld a,0              ; 2 is the code for red.
172+  AEFF D3 FE            out (254),a         ; write to port 254.
173+  AF01 C9               ret
# file closed: screen/endlevel.asm
 30   AF02                  include "screen\options.asm"
# file opened: screen/options.asm
  1+  AF02              ;
  2+  AF02              ; Show the options screen
  3+  AF02              ;
  4+  AF02              options_show:
  5+  AF02 CD 9D AF         call options_init
  6+  AF05
  7+  AF05 21 D5 84         ld hl,string_options_title
  8+  AF08 CD 54 85         call string_print
  9+  AF0B 21 DF 84         ld hl,string_options_1player
 10+  AF0E CD 54 85         call string_print
 11+  AF11 21 EF 84         ld hl,string_options_2player
 12+  AF14 CD 54 85         call string_print
 13+  AF17 21 FF 84         ld hl,string_options_keyboard
 14+  AF1A CD 54 85         call string_print
 15+  AF1D 21 0D 85         ld hl,string_options_joystick
 16+  AF20 CD 54 85         call string_print
 17+  AF23 21 1B 85         ld hl,string_options_start
 18+  AF26 CD 54 85         call string_print
 19+  AF29 21 26 85         ld hl,string_options_vanity
 20+  AF2C CD 54 85         call string_print
 21+  AF2F
 22+  AF2F 3A 42 BD         ld a,(game_numberplayers)
 23+  AF32 FE 01            cp 1
 24+  AF34 C2 3D AF         jp nz,options_show0
 25+  AF37 11 CA 58         ld de,22528+202                         ; top row attrs here
 26+  AF3A C3 40 AF         jp options_show1
 27+  AF3D              options_show0:
 28+  AF3D 11 EA 58         ld de,22528+234                         ; top row attrs here
 29+  AF40              options_show1:
 30+  AF40 06 0D            ld b,13
 31+  AF42 3E C7            ld a,199
 32+  AF44 CD BB A8         call screen_setcolours                  ; highlight current player
 33+  AF47
 34+  AF47 3A 46 BD         ld a,(game_control)
 35+  AF4A FE 00            cp 0
 36+  AF4C C2 55 AF         jp nz,options_show6
 37+  AF4F 11 0A 59         ld de,22528+266                         ; top row attrs here
 38+  AF52 C3 58 AF         jp options_show7
 39+  AF55              options_show6:
 40+  AF55 11 2A 59         ld de,22528+298                         ; top row attrs here
 41+  AF58              options_show7:
 42+  AF58 06 0D            ld b,13
 43+  AF5A 3E C7            ld a,199
 44+  AF5C CD BB A8         call screen_setcolours                  ; highlight current control
 45+  AF5F              options_show8:
 46+  AF5F CD 9D 80         call utilities_readkey
 47+  AF62 FE 31            cp 49                                   ; was 1 pressed
 48+  AF64 C2 6F AF         jp nz,options_show2
 49+  AF67 21 42 BD         ld hl,game_numberplayers
 50+  AF6A 36 01            ld (hl),1
 51+  AF6C C3 02 AF         jp options_show
 52+  AF6F              options_show2:
 53+  AF6F FE 32            cp 50                                   ; was 2 pressed
 54+  AF71 C2 7C AF         jp nz,options_show3
 55+  AF74 21 42 BD         ld hl,game_numberplayers
 56+  AF77 36 02            ld (hl),2
 57+  AF79 C3 02 AF         jp options_show
 58+  AF7C              options_show3:
 59+  AF7C FE 33            cp 51                                   ; was 3 pressed
 60+  AF7E C2 89 AF         jp nz,options_show4
 61+  AF81 21 46 BD         ld hl,game_control
 62+  AF84 36 00            ld (hl),0
 63+  AF86 C3 02 AF         jp options_show
 64+  AF89              options_show4:
 65+  AF89 FE 34            cp 52                                   ; was 4 pressed
 66+  AF8B C2 96 AF         jp nz,options_show5
 67+  AF8E 21 46 BD         ld hl,game_control
 68+  AF91 36 01            ld (hl),1
 69+  AF93 C3 02 AF         jp options_show
 70+  AF96              options_show5:
 71+  AF96 FE 35            cp 53                                   ; was 5 pressed
 72+  AF98 C8               ret z                                   ; exit if so
 73+  AF99 C3 5F AF         jp options_show8                         ; otherwise, jump to top
 74+  AF9C C9               ret
 75+  AF9D
 76+  AF9D              ;
 77+  AF9D              ; Initialise the options screen
 78+  AF9D              ;
 79+  AF9D              options_init:
 80+  AF9D 3E 47            ld a,71             ; white ink (7) on black paper (0),
 81+  AF9F                                      ; bright (64).
 82+  AF9F CD 7E 80         call utilities_clearscreen
 83+  AFA2 32 8D 5C         ld (23693),a        ; set our screen colours.
 84+  AFA5 3E 00            ld a,0              ; 2 is the code for red.
 85+  AFA7 D3 FE            out (254),a         ; write to port 254.
 86+  AFA9
 87+  AFA9 C9               ret
 88+  AFAA C9               ret
# file closed: screen/options.asm
 31   AFAB
 32   AFAB                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  AFAB              sound_gemcollected:
  2+  AFAB 21 C8 00         ld hl,200 ; pitch.
  3+  AFAE 11 3E 00         ld de,62 ; duration.
  4+  AFB1 CD B5 03         call 949 ; ROM beeper routine.
  5+  AFB4 C9               ret
  6+  AFB5
  7+  AFB5              sound_pitchbend:
  8+  AFB5 21 F4 01         ld hl,500 ; starting pitch.
  9+  AFB8 06 FA            ld b,250 ; length of pitch bend.
 10+  AFBA              sound_pitchbend0:
 11+  AFBA C5                push bc
 12+  AFBB E5               push hl ; store pitch.
 13+  AFBC 11 01 00         ld de,1 ; very short duration.
 14+  AFBF CD B5 03         call 949 ; ROM beeper routine.
 15+  AFC2 E1               pop hl ; restore pitch.
 16+  AFC3 23               inc hl ; pitch going up.
 17+  AFC4 C1               pop bc
 18+  AFC5 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  AFC7 C9               ret
 20+  AFC8
 21+  AFC8              sound_rockfell:
 22+  AFC8 08               ex af,af'
 23+  AFC9 1E 32            ld e,50 ; repeat 250 times.
 24+  AFCB 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  AFCE D5           sound_rockfell2 push de
 26+  AFCF 06 20            ld b,32 ; length of step.
 27+  AFD1 C5           sound_rockfell0 push bc
 28+  AFD2 7E               ld a,(hl) ; next "random" number.
 29+  AFD3 23               inc hl ; pointer.
 30+  AFD4 E6 F8            and 248 ; we want a black border.
 31+  AFD6 D3 FE            out (254),a ; write to speaker.
 32+  AFD8 7B               ld a,e ; as e gets smaller...
 33+  AFD9 2F               cpl ; ...we increase the delay.
 34+  AFDA 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  AFDB 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  AFDD C1               pop bc
 37+  AFDE 10 F1            djnz sound_rockfell0 ; next step.
 38+  AFE0 D1               pop de
 39+  AFE1 7B               ld a,e
 40+  AFE2 D6 18            sub 24 ; size of step.
 41+  AFE4 FE 1E            cp 30 ; end of range.
 42+  AFE6 CA F7 AF         jp z,sound_rockfell5
 43+  AFE9 DA F7 AF         jp c, sound_rockfell5
 44+  AFEC 5F               ld e,a
 45+  AFED 2F               cpl
 46+  AFEE 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  AFF0 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  AFF2 3D               dec a
 49+  AFF3 20 F9            jr nz,sound_rockfell3
 50+  AFF5 18 D7            jr sound_rockfell2
 51+  AFF7              sound_rockfell5
 52+  AFF7 08               ex af,af'
 53+  AFF8 C9               ret
 54+  AFF9
# file closed: sound/sound.asm
 33   AFF9
 34   AFF9                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  AFF9              ; ###############################################################
  2+  AFF9              ; Data for level 1
  3+  AFF9              ; ###############################################################
  4+  AFF9              level01:
  5+  AFF9
  6+  AFF9                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  AFF9
  8+  AFF9 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  AFFD 05 05 05 05
  8+  B001 05 05 05 05
  8+  B005 05 05 02 01
  8+  B009 01 01 03 05
  8+  B00D 05 05 05 05
  8+  B011 05 05 05 05
  8+  B015 05 05 00 00
  9+  B019 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  B01D 05 05 05 05
  9+  B021 05 05 05 05
  9+  B025 02 01 01 01
  9+  B029 01 01 01 01
  9+  B02D 03 05 05 05
  9+  B031 05 05 05 05
  9+  B035 05 05 00 00
 10+  B039 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  B03D 05 05 05 05
 10+  B041 05 05 02 01
 10+  B045 01 01 01 01
 10+  B049 01 01 01 01
 10+  B04D 01 01 03 05
 10+  B051 0D 0D 0D 0D
 10+  B055 0D 0D 00 00
 11+  B059 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  B05D 01 01 00 01
 11+  B061 01 01 01 01
 11+  B065 01 01 01 01
 11+  B069 01 01 01 01
 11+  B06D 01 01 01 03
 11+  B071 05 05 05 05
 11+  B075 05 05 00 00
 12+  B079 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  B07D 04 04 04 04
 12+  B081 04 04 01 01
 12+  B085 01 01 01 01
 12+  B089 01 01 01 01
 12+  B08D 01 01 01 01
 12+  B091 01 01 01 01
 12+  B095 00 01 00 00
 13+  B099 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  B09D 04 04 04 04
 13+  B0A1 04 04 04 04
 13+  B0A5 01 01 01 01
 13+  B0A9 01 01 01 01
 13+  B0AD 01 01 01 01
 13+  B0B1 00 00 00 00
 13+  B0B5 00 01 00 00
 14+  B0B9 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  B0BD 04 01 01 01
 14+  B0C1 01 01 04 04
 14+  B0C5 04 04 01 01
 14+  B0C9 01 01 01 01
 14+  B0CD 01 00 00 00
 14+  B0D1 00 01 01 01
 14+  B0D5 01 01 00 00
 15+  B0D9 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  B0DD 04 04 04 04
 15+  B0E1 04 01 04 04
 15+  B0E5 04 04 04 04
 15+  B0E9 04 04 00 00
 15+  B0ED 00 00 04 04
 15+  B0F1 04 04 04 04
 15+  B0F5 04 01 00 00
 16+  B0F9 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  B0FD 01 04 01 01
 16+  B101 01 01 04 04
 16+  B105 04 04 04 04
 16+  B109 04 04 00 04
 16+  B10D 04 04 04 04
 16+  B111 04 04 04 04
 16+  B115 04 01 00 00
 17+  B119 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  B11D 00 00 00 00
 17+  B121 00 04 04 04
 17+  B125 04 04 04 04
 17+  B129 04 04 00 04
 17+  B12D 04 04 04 04
 17+  B131 04 04 04 04
 17+  B135 04 01 00 00
 18+  B139 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  B13D 15 15 15 15
 18+  B141 15 01 04 04
 18+  B145 04 04 04 04
 18+  B149 04 04 00 04
 18+  B14D 04 04 04 04
 18+  B151 04 04 04 04
 18+  B155 04 01 00 00
 19+  B159 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B15D 00 00 00 00
 19+  B161 00 01 04 04
 19+  B165 04 04 04 04
 19+  B169 04 04 00 04
 19+  B16D 04 04 04 04
 19+  B171 04 00 00 00
 19+  B175 00 01 00 00
 20+  B179 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B17D 00 00 00 00
 20+  B181 00 01 04 04
 20+  B185 04 04 04 04
 20+  B189 04 04 00 04
 20+  B18D 04 04 04 04
 20+  B191 04 00 04 04
 20+  B195 00 01 00 00
 21+  B199 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B19D 06 06 06 06
 21+  B1A1 06 01 04 04
 21+  B1A5 04 04 04 04
 21+  B1A9 04 04 00 04
 21+  B1AD 04 04 04 04
 21+  B1B1 04 00 04 04
 21+  B1B5 00 01 00 00
 22+  B1B9 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B1BD 1A 1A 1A 1A
 22+  B1C1 1A 01 04 00
 22+  B1C5 00 00 00 00
 22+  B1C9 00 00 00 00
 22+  B1CD 00 00 00 00
 22+  B1D1 00 00 04 04
 22+  B1D5 00 01 00 00
 23+  B1D9 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B1DD 1A 1A 1A 1A
 23+  B1E1 1A 01 04 00
 23+  B1E5 04 04 04 04
 23+  B1E9 04 04 00 04
 23+  B1ED 04 04 00 04
 23+  B1F1 04 04 04 04
 23+  B1F5 00 01 00 00
 24+  B1F9 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B1FD 1A 1A 1A 1A
 24+  B201 1A 01 04 00
 24+  B205 04 04 04 04
 24+  B209 04 04 00 04
 24+  B20D 04 04 00 04
 24+  B211 04 04 04 04
 24+  B215 00 01 00 00
 25+  B219 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B21D 01 01 01 01
 25+  B221 01 01 04 00
 25+  B225 04 04 04 04
 25+  B229 04 04 00 04
 25+  B22D 04 04 00 04
 25+  B231 04 04 04 04
 25+  B235 00 01 00 00
 26+  B239 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B23D 04 04 04 04
 26+  B241 04 04 04 00
 26+  B245 04 04 04 04
 26+  B249 04 04 00 04
 26+  B24D 04 04 00 00
 26+  B251 00 00 04 04
 26+  B255 04 01 00 00
 27+  B259 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B25D 04 04 00 00
 27+  B261 00 00 00 00
 27+  B265 04 04 04 04
 27+  B269 04 04 00 04
 27+  B26D 04 04 04 04
 27+  B271 04 00 04 04
 27+  B275 04 01 00 00
 28+  B279 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B27D 04 04 00 04
 28+  B281 04 04 04 04
 28+  B285 04 04 04 04
 28+  B289 04 04 00 04
 28+  B28D 04 04 04 04
 28+  B291 04 00 04 04
 28+  B295 04 01 00 00
 29+  B299 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B29D 04 04 00 04
 29+  B2A1 04 04 01 01
 29+  B2A5 01 01 01 01
 29+  B2A9 01 01 01 01
 29+  B2AD 01 01 01 01
 29+  B2B1 04 00 04 04
 29+  B2B5 04 01 00 00
 30+  B2B9 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B2BD 04 04 00 04
 30+  B2C1 04 04 01 00
 30+  B2C5 00 00 00 00
 30+  B2C9 00 00 00 00
 30+  B2CD 00 00 00 01
 30+  B2D1 04 00 04 04
 30+  B2D5 04 01 00 00
 31+  B2D9 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B2DD 04 04 00 04
 31+  B2E1 04 04 01 00
 31+  B2E5 00 00 00 00
 31+  B2E9 00 00 00 00
 31+  B2ED 00 00 00 01
 31+  B2F1 04 00 04 04
 31+  B2F5 04 01 00 00
 32+  B2F9 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B2FD 04 04 00 04
 32+  B301 04 04 01 00
 32+  B305 00 00 00 00
 32+  B309 00 00 00 00
 32+  B30D 00 00 00 01
 32+  B311 04 00 04 04
 32+  B315 04 01 00 00
 33+  B319 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B31D 04 04 00 04
 33+  B321 04 04 04 00
 33+  B325 00 00 00 00
 33+  B329 00 00 00 00
 33+  B32D 00 00 00 04
 33+  B331 04 04 04 04
 33+  B335 04 01 00 00
 34+  B339 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B33D 04 04 04 04
 34+  B341 04 04 01 00
 34+  B345 00 00 00 00
 34+  B349 00 00 00 00
 34+  B34D 00 00 00 01
 34+  B351 04 04 04 04
 34+  B355 04 01 00 00
 35+  B359 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B35D 04 04 04 04
 35+  B361 04 04 01 00
 35+  B365 00 00 01 00
 35+  B369 00 00 00 01
 35+  B36D 00 00 00 01
 35+  B371 04 04 04 04
 35+  B375 04 01 00 00
 36+  B379 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B37D 01 01 01 01
 36+  B381 01 01 01 01
 36+  B385 01 01 01 01
 36+  B389 01 01 01 01
 36+  B38D 01 01 01 01
 36+  B391 01 01 01 01
 36+  B395 01 01 00 00
 37+  B399
 38+  B399              ; ###############################################################
 39+  B399              ; Object data: horiz, vert, state, memh, meml
 40+  B399              ; ###############################################################
 41+  B399              level01rocks:
 42+  B399 09 04 00 00      defb 9,4,0,0,0
 42+  B39D 00
 43+  B39E 0C 07 00 00      defb 12,7,0,0,0
 43+  B3A2 00
 44+  B3A3 10 07 00 00      defb 16,7,0,0,0
 44+  B3A7 00
 45+  B3A8 0B 08 00 00      defb 11,8,0,0,0
 45+  B3AC 00
 46+  B3AD 0A 0A 00 00      defb 10,10,0,0,0
 46+  B3B1 00
 47+  B3B2 0C 0A 00 00      defb 12,10,0,0,0
 47+  B3B6 00
 48+  B3B7 0D 09 00 00      defb 13,9,0,0,0
 48+  B3BB 00
 49+  B3BC 0E 08 00 00      defb 14,8,0,0,0
 49+  B3C0 00
 50+  B3C1 0F 0B 00 00      defb 15,11,0,0,0
 50+  B3C5 00
 51+  B3C6 0B 0C 00 00      defb 11,12,0,0,0
 51+  B3CA 00
 52+  B3CB 11 0C 00 00      defb 17,12,0,0,0
 52+  B3CF 00
 53+  B3D0 13 08 00 00      defb 19,8,0,0,0
 53+  B3D4 00
 54+  B3D5 16 09 00 00      defb 22,9,0,0,0
 54+  B3D9 00
 55+  B3DA 13 0A 00 00      defb 19,10,0,0,0
 55+  B3DE 00
 56+  B3DF 15 0A 00 00      defb 21,10,0,0,0
 56+  B3E3 00
 57+  B3E4 15 0C 00 00      defb 21,12,0,0,0
 57+  B3E8 00
 58+  B3E9 16 0C 00 00      defb 22,12,0,0,0
 58+  B3ED 00
 59+  B3EE 18 0A 00 00      defb 24,10,0,0,0
 59+  B3F2 00
 60+  B3F3 19 09 00 00      defb 25,9,0,0,0
 60+  B3F7 00
 61+  B3F8 1C 09 00 00      defb 28,9,0,0,0
 61+  B3FC 00
 62+  B3FD 1B 0C 00 00      defb 27,12,0,0,0
 62+  B401 00
 63+  B402 1A 0D 00 00      defb 26,13,0,0,0
 63+  B406 00
 64+  B407 19 0E 00 00      defb 25,14,0,0,0
 64+  B40B 00
 65+  B40C 19 10 00 00      defb 25,16,0,0,0
 65+  B410 00
 66+  B411 1A 11 00 00      defb 26,17,0,0,0
 66+  B415 00
 67+  B416 1B 11 00 00      defb 27,17,0,0,0
 67+  B41A 00
 68+  B41B 1C 12 00 00      defb 28,18,0,0,0
 68+  B41F 00
 69+  B420 1A 13 00 00      defb 26,19,0,0,0
 69+  B424 00
 70+  B425 1B 15 00 00      defb 27,21,0,0,0
 70+  B429 00
 71+  B42A 1A 17 00 00      defb 26,23,0,0,0
 71+  B42E 00
 72+  B42F 1B 18 00 00      defb 27,24,0,0,0
 72+  B433 00
 73+  B434 19 18 00 00      defb 25,24,0,0,0
 73+  B438 00
 74+  B439 18 17 00 00      defb 24,23,0,0,0
 74+  B43D 00
 75+  B43E 13 14 00 00      defb 19,20,0,0,0
 75+  B442 00
 76+  B443 14 12 00 00      defb 20,18,0,0,0
 76+  B447 00
 77+  B448 14 10 00 00      defb 20,16,0,0,0
 77+  B44C 00
 78+  B44D 15 10 00 00      defb 21,16,0,0,0
 78+  B451 00
 79+  B452 16 12 00 00      defb 22,18,0,0,0
 79+  B456 00
 80+  B457 11 14 00 00      defb 17,20,0,0,0
 80+  B45B 00
 81+  B45C 0D 11 00 00      defb 13,17,0,0,0
 81+  B460 00
 82+  B461 0C 13 00 00      defb 12,19,0,0,0
 82+  B465 00
 83+  B466 0B 13 00 00      defb 11,19,0,0,0
 83+  B46A 00
 84+  B46B 0A 11 00 00      defb 10,17,0,0,0
 84+  B46F 00
 85+  B470 05 12 00 00      defb 5,18,0,0,0
 85+  B474 00
 86+  B475 07 16 00 00      defb 7,22,0,0,0
 86+  B479 00
 87+  B47A 09 16 00 00      defb 9,22,0,0,0
 87+  B47E 00
 88+  B47F 07 18 00 00      defb 7,24,0,0,0
 88+  B483 00
 89+  B484 05 18 00 00      defb 5,24,0,0,0
 89+  B488 00
 90+  B489 06 19 00 00      defb 6,25,0,0,0
 90+  B48D 00
 91+  B48E 08 19 00 00      defb 8,25,0,0,0
 91+  B492 00
 92+  B493 04 17 00 00      defb 4,23,0,0,0
 92+  B497 00
 93+  B498 FF               defb 255
 94+  B499
 95+  B499              level01missiles:
 96+  B499 0B 17 00 00      defb 11,23,0,0,0
 96+  B49D 00
 97+  B49E 0B 16 00 00      defb 11,22,0,0,0
 97+  B4A2 00
 98+  B4A3 0C 17 00 00      defb 12,23,0,0,0
 98+  B4A7 00
 99+  B4A8 0C 16 00 00      defb 12,22,0,0,0
 99+  B4AC 00
100+  B4AD 0D 17 00 00      defb 13,23,0,0,0
100+  B4B1 00
101+  B4B2 0D 16 00 00      defb 13,22,0,0,0
101+  B4B6 00
102+  B4B7 0E 17 00 00      defb 14,23,0,0,0
102+  B4BB 00
103+  B4BC 0E 16 00 00      defb 14,22,0,0,0
103+  B4C0 00
104+  B4C1 0F 17 00 00      defb 15,23,0,0,0
104+  B4C5 00
105+  B4C6 0F 16 00 00      defb 15,22,0,0,0
105+  B4CA 00
106+  B4CB 10 17 00 00      defb 16,23,0,0,0
106+  B4CF 00
107+  B4D0 10 16 00 00      defb 16,22,0,0,0
107+  B4D4 00
108+  B4D5 11 17 00 00      defb 17,23,0,0,0
108+  B4D9 00
109+  B4DA 11 16 00 00      defb 17,22,0,0,0
109+  B4DE 00
110+  B4DF 12 17 00 00      defb 18,23,0,0,0
110+  B4E3 00
111+  B4E4 12 16 00 00      defb 18,22,0,0,0
111+  B4E8 00
112+  B4E9 13 17 00 00      defb 19,23,0,0,0
112+  B4ED 00
113+  B4EE 13 16 00 00      defb 19,22,0,0,0
113+  B4F2 00
114+  B4F3 14 17 00 00      defb 20,23,0,0,0
114+  B4F7 00
115+  B4F8 14 16 00 00      defb 20,22,0,0,0
115+  B4FC 00
116+  B4FD 15 17 00 00      defb 21,23,0,0,0
116+  B501 00
117+  B502 15 16 00 00      defb 21,22,0,0,0
117+  B506 00
118+  B507 16 17 00 00      defb 22,23,0,0,0
118+  B50B 00
119+  B50C 16 16 00 00      defb 22,22,0,0,0
119+  B510 00
120+  B511 FF               defb 255
121+  B512
122+  B512              ;
123+  B512              ; Diamonds: x,y,state,mem1+mem2
124+  B512              ;
125+  B512              level01diamonds:
126+  B512 0C 1B 00 00      defb 12,27,0,0,0
126+  B516 00
127+  B517 10 1B 00 00      defb 16,27,0,0,0
127+  B51B 00
128+  B51C 15 1B 00 00      defb 21,27,0,0,0
128+  B520 00
129+  B521 FF               defb 255
130+  B522
131+  B522              level01gems:
132+  B522 12 14 00 00      defb 18,20,0,0,0
132+  B526 00
133+  B527 06 18 00 00      defb 6,24,0,0,0
133+  B52B 00
134+  B52C 19 17 00 00      defb 25,23,0,0,0
134+  B530 00
135+  B531 1C 11 00 00      defb 28,17,0,0,0
135+  B535 00
136+  B536 FF               defb 255
137+  B537              ;
138+  B537              ; Score area colours
139+  B537              ;
140+  B537              score_colours:
141+  B537 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  B53B 47 47 47 47
141+  B53F 47 47 47 42
141+  B543 43 43 43 43
141+  B547 43 43 43 43
141+  B54B 42 47 47 47
141+  B54F 47 47 47 47
141+  B553 47 47 47 47
142+  B557 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  B55B 47 47 47 47
142+  B55F 47 47 47 46
142+  B563 46 46 46 46
142+  B567 46 46 46 46
142+  B56B 46 47 47 47
142+  B56F 47 47 47 47
142+  B573 47 47 47 47
143+  B577
144+  B577              high_score_colours:
145+  B577 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  B57B 42 42 47 47
145+  B57F 47 47 47 47
145+  B583 43 43 43 47
145+  B587 47 47 47 47
145+  B58B 47 46 46 46
145+  B58F 47 47 47 47
145+  B593 47 47 00 00
# file closed: leveldata/level01.asm
 35   B597                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B597              ; Tiles graphics.
  2+  B597              sprites:
  3+  B597 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B59B 00 00 00 00
  4+  B59F FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B5A3 FF FF FF FF
  5+  B5A7 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B5AB 1F 3F 7F FF
  6+  B5AF 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B5B3 F8 FC FE FF
  7+  B5B7 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B5BB 55 AA 55 AA
  8+  B5BF 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B5C3 00 00 00 00
  9+  B5C7 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  B5CB FF FF FF FF
 10+  B5CF 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  B5D3 00 00 00 00
 11+  B5D7 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B5DB F1 72 34 18
 12+  B5DF 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B5E3 FE FE FF 7E
 13+  B5E7 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B5EB FE FF 7E 3C
 14+  B5EF 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B5F3 00 00 FF FF
 15+  B5F7 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  B5FB FF 42 24 18
 16+  B5FF 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B603 00 00 00 00
 17+  B607 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B60B 00 3C 5A 34
 18+  B60F FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  B613 FD FE FD FE
 19+  B617 F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  B61B F4 F8 F4 F8
 20+  B61F D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  B623 D0 E0 D0 E0
 21+  B627 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  B62B 40 80 40 80
 22+  B62F 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  B633 ED 00 00 00
 23+  B637 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  B63B FF 7E 3C 18
 24+  B63F FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  B643 00 00 00 00
 25+  B647 FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  B64B 00 00 00 00
 26+  B64F F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  B653 00 00 00 00
 27+  B657 C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  B65B 00 00 00 00
 28+  B65F 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  B663 00 00 00 00
 29+  B667 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  B66B FF FF FF FF
 30+  B66F 00 00 00 66  	defb    0,  0,  0,102,  0,  0,  0,  0     ; 27, bullet
 30+  B673 00 00 00 00
 31+  B677
 32+  B677
 33+  B677              sprite_attrs:
 34+  B677 46               defb    070 ; 0, space
 35+  B678 4D               defb    077 ; 1, cyan block
 36+  B679 4D               defb    077 ; 2, slope left
 37+  B67A 4D               defb    077 ; 3, slope right
 38+  B67B 46               defb    070 ; 4, dirt
 39+  B67C 4E               defb    078 ; 5, sky
 40+  B67D 4C               defb    076 ; 6, slime
 41+  B67E 42               defb    066 ; 7, trapdoor
 42+  B67F 46               defb    070 ; 8, diamond
 43+  B680 42               defb    066 ; 9, rock
 44+  B681 42               defb    066 ; 10, rock 2
 45+  B682 49           	defb    073 ; 11, sky, trapdoor
 46+  B683 43           	defb    067 ; 12, missile
 47+  B684 4A               defb    074 ; 13, sky, red ink (tank)
 48+  B685 46               defb    070 ; 14, gem
 49+  B686 4D               defb    077 ; 15, damaged mountain
 50+  B687 4D               defb    077 ; 16, damaged mountain 2
 51+  B688 4D               defb    077 ; 17, damaged mountain 3
 52+  B689 4D               defb    077 ; 18, damaged mountain 4
 53+  B68A 00           	defb 	000 ; 19, tank missile (not used
 54+  B68B 43           	defb    067 ; 20, missile active
 55+  B68C 42           	defb	066	; 21, the pit 1
 56+  B68D 42           	defb	066	; 22, the pit 2
 57+  B68E 42           	defb	066	; 23, the pit 3
 58+  B68F 42           	defb	066	; 24, the pit 4
 59+  B690 42           	defb	066	; 25, the pit 5
 60+  B691 64           	defb    100 ; 26, slime, green on green
 61+  B692 46           	defb 	070 ; 27, bullet
 62+  B693
 63+  B693
 64+  B693              player_sprite:
 65+  B693 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 65+  B697 38 3D C3 80
 66+  B69B 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 66+  B69F 3C 1C 16 32
 67+  B6A3 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 67+  B6A7 3C 38 68 4C
 68+  B6AB 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 68+  B6AF 1C BC C3 01
 69+  B6B3 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 69+  B6B7 3C 3C 64 0C
 70+  B6BB 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 70+  B6BF 3C 3C 26 30
 71+  B6C3 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 71+  B6C7 1E 5C FD 5F
 72+  B6CB 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 72+  B6CF 4F 8F 19 03
 73+  B6D3 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 73+  B6D7 F2 F1 98 C0
 74+  B6DB FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 74+  B6DF 48 08 14 2A
 75+  B6E3 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 75+  B6E7 38 78 44 C3
 76+  B6EB 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 76+  B6EF 1C 1E 22 C3
 77+  B6F3 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 77+  B6F7 6F 45 E1 9B
 78+  B6FB 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 78+  B6FF F6 A2 87 D9
 79+  B703
 80+  B703              ;
 81+  B703              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 82+  B703              ;
 83+  B703              ship_sprite:
 84+  B703 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 84+  B707 03 1F 7F FF
 85+  B70B 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 85+  B70F FF FF FF FF
 86+  B713 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 86+  B717 FF FF FF FF
 87+  B71B 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 87+  B71F C0 F8 FE FF
 88+  B723 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 88+  B727 03 03 02 07
 89+  B72B 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 89+  B72F FF 0F 07 83
 90+  B733 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 90+  B737 FF 10 20 C1
 91+  B73B 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 91+  B73F C0 C0 40 E0
 92+  B743 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 92+  B747 03 03 02 07
 93+  B74B F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 93+  B74F FF 08 04 83
 94+  B753 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 94+  B757 FF F0 E0 C1
 95+  B75B CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 95+  B75F C0 C0 40 E0
 96+  B763
 97+  B763              ;
 98+  B763              ;  First 8 frames are tank, last frame is the gun barrel
 99+  B763              ;
100+  B763              tank_sprite:
101+  B763 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
101+  B767 7F 00 00 00
102+  B76B 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
102+  B76F FE FF 7F 40
103+  B773 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
103+  B777 03 FF FF 01
104+  B77B 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
104+  B77F E0 C0 00 00
105+  B783 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
105+  B787 F7 E1 7F 3F
106+  B78B FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
106+  B78F 54 16 FF FF
107+  B793 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
107+  B797 9B A8 FF FF
108+  B79B FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
108+  B79F 9F AF FE FC
109+  B7A3 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
109+  B7A7 1F 00 00 00
110+  B7AB
111+  B7AB              monster_sprite:
112+  B7AB 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  B7AF 0B D0 16 68
113+  B7B3 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
113+  B7B7 35 AC 7F FE
114+  B7BB FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
114+  B7BF 8F F1 8F F1
115+  B7C3 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
115+  B7C7 18 18 00 00
116+  B7CB 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
116+  B7CF 0B D0 16 68
117+  B7D3 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
117+  B7D7 F5 AF FF FF
118+  B7DB BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
118+  B7DF 0F F0 0F F0
119+  B7E3 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
119+  B7E7 00 00 00 00
120+  B7EB
121+  B7EB              robot_sprite:
122+  B7EB 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
122+  B7EF CE 12 22 66
123+  B7F3 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
123+  B7F7 4E 12 24 6C
124+  B7FB 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
124+  B7FF 4E 32 63 03
125+  B803 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
125+  B807 CE 0A 09 1B
126+  B80B 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
126+  B80F 73 48 44 66
127+  B813 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
127+  B817 72 48 24 36
128+  B81B 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
128+  B81F 72 4C C6 C0
129+  B823 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
129+  B827 73 50 90 D8
130+  B82B 38 A9 BA 7C  	defb     56,169,186,124, 56, 42, 38, 96     ; dead 1
130+  B82F 38 2A 26 60
131+  B833 1C 95 5D 3E  	defb	 28,149, 93, 62, 28, 84,100,  6		; dead 2
131+  B837 1C 54 64 06
# file closed: graphics/graphics.asm
 36   B83B
 37   B83B                  include "game\control.asm"
# file opened: game/control.asm
  1+  B83B              ;
  2+  B83B              ; Check the preferred input method then move
  3+  B83B              ;
  4+  B83B              control_input:
  5+  B83B 3A 85 BD         ld a,(player+11)    ; first, check if player is dying
  6+  B83E FE 04            cp 4                ; is the player falling
  7+  B840 CC 0A B9         call z, control_fall
  8+  B843 FE 05            cp 5                ; is the player fighting
  9+  B845 CC F7 B8         call z, control_fight
 10+  B848 3A 85 BD         ld a,(player+11)    ; first, check if player is dying
 11+  B84B FE 00            cp 0
 12+  B84D C0               ret nz               ; if so, can't move
 13+  B84E 3A 7F BD         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  B851 FE 00            cp 0
 15+  B853 CA 5A B8         jp z, control_input0
 16+  B856 CD E8 B9         call control_automove
 17+  B859 C9               ret
 18+  B85A              control_input0:
 19+  B85A 3A 80 BD         ld a,(player+6)      ; next, check if the player is digging
 20+  B85D FE 00            cp 0
 21+  B85F CA 66 B8         jp z, control_input1
 22+  B862 CD 26 B9         call control_dig
 23+  B865 C9               ret
 24+  B866              control_input1:
 25+  B866 3A 46 BD         ld a,(game_control)
 26+  B869 FE 00            cp 0                ; is this keyboard
 27+  B86B C2 72 B8         jp nz,control_input2
 28+  B86E CD 76 B8         call control_keyboard
 29+  B871 C9               ret
 30+  B872              control_input2:
 31+  B872                  ; do joystick
 32+  B872 CD BC B8         call control_joystick
 33+  B875 C9               ret
 34+  B876
 35+  B876              ;
 36+  B876              ; Check the keyboard
 37+  B876              ;
 38+  B876              control_keyboard:
 39+  B876 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 40+  B879 ED 78            in a,(c)            ; read keyboard.
 41+  B87B 47               ld b,a              ; store result in b register.
 42+  B87C CB 18            rr b                ; check outermost key (q).
 43+  B87E D2 A8 B8         jp nc,control_keyboard1
 44+  B881 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 45+  B884 ED 78            in a,(c)            ; read keyboard.
 46+  B886 47               ld b,a              ; store result in b register.
 47+  B887 CB 18            rr b                ; check outermost key (a).
 48+  B889 D2 AC B8         jp nc,control_keyboard2
 49+  B88C 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 50+  B88F ED 78            in a,(c)            ; read keyboard.
 51+  B891 47               ld b,a              ; store result in b register.
 52+  B892 CB 18            rr b                ; check outermost key (p).
 53+  B894 D2 B0 B8         jp nc,control_keyboard3
 54+  B897 CB 18            rr b                ; check next key.
 55+  B899 D2 B4 B8         jp nc,control_keyboard4
 56+  B89C 01 FE 7F         ld bc,32766         ; port for keyboard row b-space.
 57+  B89F ED 78            in a,(c)            ; read keyboard.
 58+  B8A1 47               ld b,a              ; store result in b register.
 59+  B8A2 CB 18            rr b                ; check outermost key (space).
 60+  B8A4 D2 B8 B8         jp nc,control_keyboard5
 61+  B8A7 C9               ret
 62+  B8A8              control_keyboard1:
 63+  B8A8 CD 31 BA         call control_pl_moveup         ; player up.
 64+  B8AB C9               ret
 65+  B8AC              control_keyboard2:
 66+  B8AC CD 60 BA         call control_pl_movedown       ; player down.
 67+  B8AF C9               ret
 68+  B8B0              control_keyboard3:
 69+  B8B0 CD BD BA         call control_pl_moveright       ; player left.
 70+  B8B3 C9               ret
 71+  B8B4              control_keyboard4:
 72+  B8B4 CD 8D BA         call control_pl_moveleft       ; player right.
 73+  B8B7 C9               ret
 74+  B8B8              control_keyboard5:
 75+  B8B8 CD EB BA         call control_pl_fire       ; player fire.
 76+  B8BB C9               ret
 77+  B8BC
 78+  B8BC              ;
 79+  B8BC              ; Check the joystick
 80+  B8BC              ;
 81+  B8BC              control_joystick:
 82+  B8BC 01 1F 00         ld bc,31                        ; Kempston joystick port.
 83+  B8BF ED 78            in a,(c)                        ; read input.
 84+  B8C1 E6 02            and 2                           ; check "left" bit.
 85+  B8C3 C2 EB B8         jp nz,control_joystick3       ; move left.
 86+  B8C6 ED 78            in a,(c)                        ; read input.
 87+  B8C8 E6 01            and 1                           ; test "right" bit.
 88+  B8CA C2 EF B8         jp nz,control_joystick4       ; move right.
 89+  B8CD ED 78            in a,(c)                        ; read input.
 90+  B8CF E6 08            and 8                           ; check "up" bit.
 91+  B8D1 C2 E3 B8         jp nz,control_joystick1       ; move up.
 92+  B8D4 ED 78            in a,(c)                        ; read input.
 93+  B8D6 E6 04            and 4                           ; check "down" bit.
 94+  B8D8 C2 E7 B8         jp nz,control_joystick2       ; move down.
 95+  B8DB ED 78            in a,(c)                        ; read input.
 96+  B8DD E6 10            and 16                          ; try the fire bit.
 97+  B8DF C2 F3 B8         jp nz,control_joystick5       ; fire pressed.
 98+  B8E2 C9               ret
 99+  B8E3              control_joystick1:
100+  B8E3 CD 31 BA         call control_pl_moveup         ; player up.
101+  B8E6 C9               ret
102+  B8E7              control_joystick2:
103+  B8E7 CD 60 BA         call control_pl_movedown       ; player down.
104+  B8EA C9               ret
105+  B8EB              control_joystick3:
106+  B8EB CD 8D BA         call control_pl_moveleft       ; player left.
107+  B8EE C9               ret
108+  B8EF              control_joystick4:
109+  B8EF CD BD BA         call control_pl_moveright       ; player right.
110+  B8F2 C9               ret
111+  B8F3              control_joystick5:
112+  B8F3 CD EB BA         call control_pl_fire
113+  B8F6 C9               ret
114+  B8F7
115+  B8F7              ;
116+  B8F7              ; Fights the player - just flips the players anim frame
117+  B8F7              ;
118+  B8F7              control_fight:
119+  B8F7 3A 7D BD         ld a,(player+3)             ; load the frame
120+  B8FA FE 0C            cp 12                       ; flip between 12 and 13
121+  B8FC CA 04 B9         jp z,control_fight0
122+  B8FF 3E 0C            ld a,12
123+  B901 C3 06 B9         jp control_fight1
124+  B904              control_fight0:
125+  B904 3E 0D            ld a,13
126+  B906              control_fight1:
127+  B906 32 7D BD         ld (player+3),a           ; save back
128+  B909 C9               ret
129+  B90A
130+  B90A              ;
131+  B90A              ; Falls the player
132+  B90A              ;
133+  B90A              control_fall:
134+  B90A ED 4B 7A BD      ld bc,(player)              ; get coords
135+  B90E 0C               inc c
136+  B90F ED 43 7A BD      ld (player),bc
137+  B913 3A 7D BD         ld a,(player+3)             ; load the frame
138+  B916 FE 03            cp 3                       ; flip between 3 and 0
139+  B918 C2 20 B9         jp nz, control_fall0
140+  B91B 3E 00            ld a,0
141+  B91D C3 22 B9         jp control_fall1
142+  B920              control_fall0:
143+  B920 3E 03            ld a,3
144+  B922              control_fall1:
145+  B922 32 7D BD         ld (player+3),a           ; save back
146+  B925 C9               ret
147+  B926
148+  B926              ;
149+  B926              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
150+  B926              ;
151+  B926              control_dig:
152+  B926 ED 4B 7A BD      ld bc,(player)      ; load the current coords into bc
153+  B92A C5               push bc
154+  B92B 3A 7C BD         ld a,(player+2)     ; get the direction
155+  B92E FE 01            cp 1                ; left
156+  B930 CA 48 B9         jp z,control_dig0
157+  B933 FE 02            cp 2                ; right
158+  B935 CA 5D B9         jp z,control_dig1
159+  B938 FE 03            cp 3                ; down
160+  B93A CA 81 B9         jp z,control_dig5
161+  B93D FE 00            cp 0                ; up
162+  B93F CA 71 B9         jp z,control_dig4
163+  B942 21 80 BD         ld hl,player+6
164+  B945 36 00            ld (hl),0           ; turn off digging
165+  B947 C9               ret                 ; return
166+  B948              control_dig0:           ; going left
167+  B948 CD 1F AB         call sprites_scadd  ; get the current coord
168+  B94B 62 6B            ld hl,de
169+  B94D 2B               dec hl              ; move one left
170+  B94E C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
171+  B94F 78               ld a,b
172+  B950 06 08            ld b,8
173+  B952 90               sub b
174+  B953 47               ld b,a
175+  B954 79               ld a,c
176+  B955 0E 08            ld c,8
177+  B957 91               sub c
178+  B958 4F               ld c,a
179+  B959 C5               push bc
180+  B95A C3 8A B9         jp control_dig2
181+  B95D              control_dig1:
182+  B95D CD 1F AB         call sprites_scadd  ; get the current coord
183+  B960 62 6B            ld hl,de
184+  B962 23               inc hl              ; move one right
185+  B963 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
186+  B964 3E 08            ld a,8
187+  B966 80               add a,b
188+  B967 47               ld b,a
189+  B968 79               ld a,c
190+  B969 0E 08            ld c,8
191+  B96B 91               sub c
192+  B96C 4F               ld c,a
193+  B96D C5               push bc
194+  B96E C3 8A B9         jp control_dig2
195+  B971              control_dig4:
196+  B971 CD 1F AB         call sprites_scadd  ; get the current coord
197+  B974 62 6B            ld hl,de
198+  B976 11 20 00         ld de,32
199+  B979 ED 52            sbc hl,de             ; move one up
200+  B97B C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
201+  B97C 0D               dec c
202+  B97D C5               push bc
203+  B97E C3 A2 B9         jp control_dig6
204+  B981              control_dig5:
205+  B981 CD 1F AB         call sprites_scadd  ; get the current coord
206+  B984 62 6B            ld hl,de
207+  B986 24               inc h              ; move one down
208+  B987                                     ; not bothered about working out bc here, since rock will never fall if digging down
209+  B987 C3 8A B9         jp control_dig2
210+  B98A              ; Normal (not up) digging
211+  B98A              control_dig2:
212+  B98A 3A 82 BD         ld a,(player+8)     ; get the number of rows we need to overwrite
213+  B98D 47               ld b,a              ; rows to copy over
214+  B98E E5               push hl             ; store the memory location of the first row for later
215+  B98F              control_dig3:
216+  B98F CD D1 B9         call control_getpixelrow
217+  B992 77               ld (hl),a           ; load contents into row
218+  B993 11 20 00         ld de,32
219+  B996 19               add hl,de           ; move to next row
220+  B997 10 F6            djnz control_dig3
221+  B999 E1               pop hl              ; get the original memory location back
222+  B99A 11 20 00         ld de,32
223+  B99D ED 52            sbc hl,de           ; move to above row, ready for checking for rock
224+  B99F C3 B8 B9         jp control_dig10
225+  B9A2              ; Special case for going up
226+  B9A2              control_dig6:
227+  B9A2 3A 82 BD         ld a,(player+8)     ; get the number of rows we need to overwrite
228+  B9A5 47               ld b,a              ; rows to copy over
229+  B9A6              control_dig7:
230+  B9A6 CD D1 B9         call control_getpixelrow
231+  B9A9              control_dig12:
232+  B9A9 77               ld (hl),a           ; load empty into row
233+  B9AA 11 20 00         ld de,32
234+  B9AD ED 52            sbc hl,de           ; move up to next row
235+  B9AF 0D               dec c               ; decrease c to track rows
236+  B9B0 10 F4            djnz control_dig7
237+  B9B2 79               ld a,c
238+  B9B3 D6 07            sub 7
239+  B9B5 C1               pop bc
240+  B9B6 4F               ld c,a
241+  B9B7 C5               push bc             ; store the decreased c coord
242+  B9B8              control_dig10:
243+  B9B8 DD 21 81 BD      ld ix,player+7
244+  B9BC DD 7E 00         ld a,(ix)     ; get the dig frame number
245+  B9BF 3D               dec a
246+  B9C0 DD 77 00         ld (ix),a
247+  B9C3                  ; call the check for rocks above the removed dirt
248+  B9C3 DD 21 80 BD      ld ix,player+6
249+  B9C7 DD 7E 00         ld a,(ix)     ; get the dig state
250+  B9CA FE 00            cp 0
251+  B9CC C1               pop bc
252+  B9CD CC E9 C2         call z, rocks_checkforfalling ; make the check if we're no longer digging
253+  B9D0 C9               ret
254+  B9D1
255+  B9D1              ;
256+  B9D1              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
257+  B9D1              ; Inputs:
258+  B9D1              ; hl - memory of pixel row
259+  B9D1              ; Outputs:
260+  B9D1              ; a - modified row to write
261+  B9D1              ;
262+  B9D1              control_getpixelrow:
263+  B9D1 3A 81 BD         ld a,(player+7)     ; get the dig frame number
264+  B9D4 FE 00            cp 0                ; is this the last dig
265+  B9D6 CA DD B9         jp z,control_getpixelrow1
266+  B9D9 7E               ld a,(hl)           ; if not, xor with 255 to flip it
267+  B9DA EE FF            xor 255
268+  B9DC C9               ret
269+  B9DD              control_getpixelrow1:
270+  B9DD DD 21 80 BD      ld ix,player+6
271+  B9E1 DD 36 00 00      ld (ix),0           ; turn off digging
272+  B9E5 3E 00            ld a,0              ; if it is, load with empty
273+  B9E7 C9               ret
274+  B9E8
275+  B9E8              ;
276+  B9E8              ; Auto move the player until pixels is zero
277+  B9E8              ;
278+  B9E8              control_automove:
279+  B9E8 5F               ld e,a              ; store the number of pixels left to move in e
280+  B9E9 ED 4B 7A BD      ld bc,(player)      ; load the current coords into bc
281+  B9ED 21 7C BD         ld hl,player+2      ; get the direction
282+  B9F0 7E               ld a,(hl)
283+  B9F1 FE 03            cp 3                ; down
284+  B9F3 CA 07 BA         jp z,control_automove3  ; don't need to do anything
285+  B9F6 FE 00            cp 0                ; going up
286+  B9F8 CA 13 BA         jp z,control_automove2
287+  B9FB FE 01            cp 1                ; going left?
288+  B9FD CA 1F BA         jp z,control_automove0
289+  BA00 78               ld a,b
290+  BA01 3C               inc a               ; if we're going right, increment a twice for two pixels
291+  BA02 3C               inc a
292+  BA03 47               ld b,a
293+  BA04 C3 23 BA         jp control_automove1
294+  BA07              control_automove3:
295+  BA07 79               ld a,c
296+  BA08 3C               inc a
297+  BA09 3C               inc a               ; if we're going down, increment twice
298+  BA0A 4F               ld c,a
299+  BA0B FE 90            cp 144
300+  BA0D CC 01 BB         call z, control_scroll_down
301+  BA10 C3 23 BA         jp control_automove1
302+  BA13              control_automove2:
303+  BA13 79               ld a,c
304+  BA14 3D               dec a
305+  BA15 3D               dec a               ; if we're going up, decrement twice
306+  BA16 4F               ld c,a
307+  BA17 FE 60            cp 96
308+  BA19 CC 0E BB         call z, control_scroll_up
309+  BA1C C3 23 BA         jp control_automove1
310+  BA1F              control_automove0:
311+  BA1F 78               ld a,b
312+  BA20 3D               dec a               ; if we're going left, decrement a twice
313+  BA21 3D               dec a
314+  BA22 47               ld b,a
315+  BA23              control_automove1:
316+  BA23 ED 43 7A BD      ld (player),bc      ; and back to player
317+  BA27 7B               ld a,e              ; now get the pixel count back
318+  BA28 3D               dec a               ; decrease by one
319+  BA29 21 7F BD         ld hl,player+5
320+  BA2C 77               ld (hl),a           ; copy back
321+  BA2D CD 73 BF         call player_justmoved
322+  BA30 C9               ret
323+  BA31
324+  BA31              ;
325+  BA31              ; Moves the player up
326+  BA31              ;
327+  BA31              control_pl_moveup:
328+  BA31 C5               push bc
329+  BA32 ED 4B 7A BD      ld bc,(player)          ; get the current coords, b horiz, c vert
330+  BA36 79               ld a,c                  ; load c into the acc
331+  BA37 FE 18            cp 24
332+  BA39 CA 59 BA         jp z,control_pl_moveup0 ; are we at the edge of the screen
333+  BA3C FE 60            cp 96
334+  BA3E CC 0E BB         call z, control_scroll_up
335+  BA41 CD B5 BC         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
336+  BA44 F5               push af
337+  BA45 7B               ld a,e                  ; put e in a
338+  BA46 FE 00            cp 0
339+  BA48 CA 58 BA         jp z,control_pl_moveup1 ; don't move if we can't
340+  BA4B F1               pop af
341+  BA4C D6 01            sub 1                   ; subtract 1
342+  BA4E D6 01            sub 1                   ; subtract 1
343+  BA50 4F               ld c,a                  ; load back to c
344+  BA51 ED 43 7A BD      ld (player),bc          ; load back to player
345+  BA55 C3 59 BA         jp control_pl_moveup0
346+  BA58              control_pl_moveup1:
347+  BA58 F1               pop af                  ; restore af if needed
348+  BA59              control_pl_moveup0:
349+  BA59 3E 00            ld a,0
350+  BA5B 32 7C BD         ld (player+2),a        ; set direction to up
351+  BA5E C1               pop bc
352+  BA5F C9               ret
353+  BA60              ;
354+  BA60              ; Moves the player down
355+  BA60              ;
356+  BA60              control_pl_movedown:
357+  BA60 C5               push bc
358+  BA61 ED 4B 7A BD      ld bc,(player)          ; get the current coords, b horiz, c vert
359+  BA65 79               ld a,c                  ; load c into the acc
360+  BA66 FE E0            cp 224
361+  BA68 CA 86 BA         jp z,control_pl_movedown0 ; are we at the edge of the screen
362+  BA6B FE 80            cp 128
363+  BA6D CC 01 BB         call z, control_scroll_down
364+  BA70 CD 89 BC         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
365+  BA73 F5               push af
366+  BA74 7B               ld a,e                  ; put e in a
367+  BA75 FE 00            cp 0
368+  BA77 CA 85 BA         jp z,control_pl_movedown1 ; don't move if we can't
369+  BA7A F1               pop af
370+  BA7B 3C               inc a                   ; add 1
371+  BA7C 3C               inc a                   ; add 1
372+  BA7D 4F               ld c,a                  ; load back to c
373+  BA7E ED 43 7A BD      ld (player),bc          ; load back to player
374+  BA82 C3 86 BA         jp control_pl_movedown0
375+  BA85              control_pl_movedown1:
376+  BA85 F1               pop af                  ; restore af if needed
377+  BA86              control_pl_movedown0:
378+  BA86 3E 03            ld a,3
379+  BA88 32 7C BD         ld (player+2),a        ; set direction to down
380+  BA8B C1               pop bc
381+  BA8C C9               ret
382+  BA8D              ;
383+  BA8D              ; Moves the player left
384+  BA8D              ;
385+  BA8D              control_pl_moveleft:
386+  BA8D C5               push bc
387+  BA8E ED 4B 7A BD      ld bc,(player)          ; get the current coords, b horiz, c vert
388+  BA92 78               ld a,b                  ; load b into the acc
389+  BA93 FE 10            cp 16
390+  BA95 CA B6 BA         jp z,control_pl_moveleft0 ; are we at the edge of the screen
391+  BA98 CD 14 BD         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
392+  BA9B F5               push af
393+  BA9C 7B               ld a,e                  ; put e in a
394+  BA9D FE 00            cp 0
395+  BA9F CA B5 BA         jp z,control_pl_moveleft1 ; don't move if we can't
396+  BAA2 21 7F BD         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
397+  BAA5 3E 03            ld a,3
398+  BAA7 77               ld (hl),a
399+  BAA8 F1               pop af
400+  BAA9 D6 01            sub 1                    ; subtract 2
401+  BAAB D6 01            sub 1
402+  BAAD 47               ld b,a                  ; load back to c
403+  BAAE ED 43 7A BD      ld (player),bc          ; load back to player
404+  BAB2 C3 B6 BA         jp control_pl_moveleft0
405+  BAB5              control_pl_moveleft1:
406+  BAB5 F1               pop af
407+  BAB6              control_pl_moveleft0:
408+  BAB6 3E 01            ld a,1
409+  BAB8 32 7C BD         ld (player+2),a        ; set direction to left
410+  BABB C1               pop bc
411+  BABC C9               ret
412+  BABD              ;
413+  BABD              ; Moves the player right
414+  BABD              ;
415+  BABD              control_pl_moveright:
416+  BABD C5               push bc
417+  BABE ED 4B 7A BD      ld bc,(player)          ; get the current coords, b horiz, c vert
418+  BAC2 78               ld a,b                  ; load b into the acc
419+  BAC3 FE F0            cp 240
420+  BAC5 CA E4 BA         jp z,control_pl_moveright0 ; are we at the edge of the screen
421+  BAC8 CD E8 BC         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
422+  BACB F5               push af
423+  BACC 7B               ld a,e                  ; put e in a
424+  BACD FE 00            cp 0
425+  BACF CA E3 BA         jp z,control_pl_moveright1 ; don't move if we can't
426+  BAD2 21 7F BD         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
427+  BAD5 3E 03            ld a,3
428+  BAD7 77               ld (hl),a
429+  BAD8 F1               pop af
430+  BAD9 3C               inc a                   ; add 2
431+  BADA 3C               inc a
432+  BADB 47               ld b,a                  ; load back to b
433+  BADC ED 43 7A BD      ld (player),bc          ; load back to player
434+  BAE0 C3 E4 BA         jp control_pl_moveright0
435+  BAE3              control_pl_moveright1:
436+  BAE3 F1               pop af                  ; restore af if needed
437+  BAE4              control_pl_moveright0:
438+  BAE4 3E 02            ld a,2
439+  BAE6 32 7C BD         ld (player+2),a        ; set direction to right
440+  BAE9 C1               pop bc
441+  BAEA C9               ret
442+  BAEB
443+  BAEB              ;
444+  BAEB              ; Player fires
445+  BAEB              ;
446+  BAEB              control_pl_fire:
447+  BAEB 3A 7C BD         ld a,(player+2)         ; get player direction
448+  BAEE FE 00            cp 0
449+  BAF0 C8               ret z
450+  BAF1 FE 03            cp 3
451+  BAF3 C8               ret z                   ; if up or down, don't fire
452+  BAF4 3A F7 CC         ld a,(bullet_state+3)       ; get the state
453+  BAF7 FE 01            cp 1
454+  BAF9 C8               ret z                   ; if currently firing, don't fire
455+  BAFA CD F8 CC         call bullet_init        ; initialise the bullet
456+  BAFD CD 0D CD         call bullet_shoot       ; shoot the bullet
457+  BB00 C9               ret
458+  BB01
459+  BB01              ;
460+  BB01              ; Scrolls the screen down
461+  BB01              ;
462+  BB01              control_scroll_down:
463+  BB01 F5               push af
464+  BB02 3E 08            ld a,8
465+  BB04 32 06 A8         ld (screen_offset),a
466+  BB07 F1               pop af
467+  BB08 21 53 A6         ld hl,buffer_updateall
468+  BB0B 36 01            ld (hl),1         ; flag as screen needing update
469+  BB0D C9               ret
470+  BB0E
471+  BB0E              ;
472+  BB0E              ; Scrolls the screen up
473+  BB0E              ;
474+  BB0E              control_scroll_up:
475+  BB0E F5               push af
476+  BB0F 3E 00            ld a,0
477+  BB11 32 06 A8         ld (screen_offset),a
478+  BB14 F1               pop af
479+  BB15 21 53 A6         ld hl,buffer_updateall
480+  BB18 36 01            ld (hl),1         ; flag as screen needing update
481+  BB1A C9               ret
482+  BB1B
483+  BB1B
484+  BB1B
485+  BB1B
# file closed: game/control.asm
 38   BB1B                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  BB1B              ;
  2+  BB1B              ; The number of frames to dig for
  3+  BB1B              ;
  4+  BB1B              movement_numberdigframes:
  5+  BB1B 0A               defb 10
  6+  BB1C
  7+  BB1C              ;
  8+  BB1C              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  BB1C              ; Inputs:
 10+  BB1C              ; hl - memory location of top pixel row
 11+  BB1C              ; bc - screen coords, b horiz, c vert
 12+  BB1C              ; Outputs:
 13+  BB1C              ; e - 0 if not empty, 1 if empty
 14+  BB1C              ;
 15+  BB1C              movement_spaceisempty:
 16+  BB1C C5               push bc
 17+  BB1D E5               push hl
 18+  BB1E CD 46 BB         call movement_spaceisgem        ; check if space is a gem
 19+  BB21 E1               pop hl
 20+  BB22 C1               pop bc
 21+  BB23 7B               ld a,e
 22+  BB24 FE 01            cp 1
 23+  BB26 C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  BB27 3E 08            ld a,8                          ; 8 rows to check
 25+  BB29              movement_spaceisempty0:
 26+  BB29 08               ex af,af'                       ; store the loop counter
 27+  BB2A 7E               ld a,(hl)                       ; get current pixel row
 28+  BB2B FE 00            cp 0
 29+  BB2D C2 41 BB         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  BB30 79               ld a,c                          ; load the vertical coord
 31+  BB31 3C               inc a                           ; next row down
 32+  BB32 11 20 00         ld de,32
 33+  BB35 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  BB36 4F               ld c,a                          ; copy vert coord back to c
 35+  BB37 08               ex af,af'                       ; get loop counter back
 36+  BB38 3D               dec a                           ; decrease loop counter
 37+  BB39 C2 29 BB         jp nz, movement_spaceisempty0
 38+  BB3C 16 00            ld d,0
 39+  BB3E 1E 01            ld e,1                          ; got to end, so space is empty
 40+  BB40 C9               ret
 41+  BB41              movement_spaceisempty1:
 42+  BB41 16 00            ld d,0
 43+  BB43 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  BB45 C9               ret
 45+  BB46
 46+  BB46              ;
 47+  BB46              ; Check if a space contains a gem
 48+  BB46              ; Inputs:
 49+  BB46              ; bc - screen coords
 50+  BB46              ; Outputs:
 51+  BB46              ; e = 1 if gem
 52+  BB46              movement_spaceisgem:
 53+  BB46 CD 58 A9         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  BB49 21 12 B5         ld hl,level01diamonds           ; check diamonds first
 55+  BB4C              movement_spaceisgem0:
 56+  BB4C 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  BB50 7B               ld a,e                          ; check for end of data
 58+  BB51 FE FF            cp 255
 59+  BB53 CA 6E BB         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  BB56 23               inc hl
 61+  BB57 23               inc hl                          ; move to state
 62+  BB58 7E               ld a,(hl)
 63+  BB59 23               inc hl
 64+  BB5A 23               inc hl
 65+  BB5B 23               inc hl                          ; get to next
 66+  BB5C FE 01            cp 1                            ; check if collected
 67+  BB5E CA 4C BB         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  BB61 7B               ld a,e                          ; load e again
 69+  BB62 B9               cp c                            ; otherwise, compare c with e
 70+  BB63 C2 4C BB         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  BB66 7A               ld a,d                          ; get d coord
 72+  BB67 B8               cp b                            ; compare b with d
 73+  BB68 C2 4C BB         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  BB6B 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  BB6D C9               ret
 76+  BB6E              movement_spaceisgem1:
 77+  BB6E 21 22 B5         ld hl,level01gems              ; check gems
 78+  BB71              movement_spaceisgem2:
 79+  BB71 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  BB75 7B               ld a,e                          ; check for end of data
 81+  BB76 FE FF            cp 255
 82+  BB78 CA 93 BB         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  BB7B 23               inc hl
 84+  BB7C 23               inc hl                          ; move to state
 85+  BB7D 7E               ld a,(hl)
 86+  BB7E 23               inc hl
 87+  BB7F 23               inc hl
 88+  BB80 23               inc hl                          ; get to next
 89+  BB81 FE 01            cp 1                            ; check if collected
 90+  BB83 CA 71 BB         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  BB86 7B               ld a,e                          ; load e again
 92+  BB87 B9               cp c                            ; otherwise, compare c with e
 93+  BB88 C2 71 BB         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  BB8B 7A               ld a,d                          ; get d coord
 95+  BB8C B8               cp b                            ; compare b with d
 96+  BB8D C2 71 BB         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  BB90 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  BB92 C9               ret
 99+  BB93              movement_spaceisgem3:
100+  BB93 1E 00            ld e,0                          ; nothing found, return e = 0
101+  BB95 C9               ret
102+  BB96
103+  BB96              ;
104+  BB96              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  BB96              ; Inputs:
106+  BB96              ; hl - memory location of top pixel row
107+  BB96              ; bc - screen coords, b horiz, c vert
108+  BB96              ; Outputs:
109+  BB96              ; e - 0 if not empty, 1 if empty
110+  BB96              ;
111+  BB96              movement_linebelowisempty:
112+  BB96 C5               push bc
113+  BB97 E5               push hl
114+  BB98 CD 46 BB         call movement_spaceisgem        ; check if space is a gem
115+  BB9B E1               pop hl
116+  BB9C C1               pop bc
117+  BB9D 7B               ld a,e
118+  BB9E FE 01            cp 1
119+  BBA0 C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  BBA1 7E               ld a,(hl)                       ; get current pixel row
121+  BBA2 FE 00            cp 0
122+  BBA4 C2 AC BB         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  BBA7 16 00            ld d,0
124+  BBA9 1E 01            ld e,1                          ; got to end, so space is empty
125+  BBAB C9               ret
126+  BBAC              movement_linebelowisempty1:
127+  BBAC 16 00            ld d,0
128+  BBAE 1E 00            ld e,0                          ; returning false, ie space not empty
129+  BBB0 C9               ret
130+  BBB1
131+  BBB1              ;
132+  BBB1              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  BBB1              ; Inputs:
134+  BBB1              ; hl - memory location of top pixel row
135+  BBB1              ; bc - screen coords, b horiz, c vert
136+  BBB1              ; Outputs:
137+  BBB1              ; e - 0 if not empty, 1 if empty
138+  BBB1              ;
139+  BBB1              movement_lineaboveisempty:
140+  BBB1 C5               push bc
141+  BBB2 E5               push hl
142+  BBB3 CD 46 BB         call movement_spaceisgem        ; check if space is a gem
143+  BBB6 E1               pop hl
144+  BBB7 C1               pop bc
145+  BBB8 7B               ld a,e
146+  BBB9 FE 01            cp 1
147+  BBBB C8               ret z
148+  BBBC 7E               ld a,(hl)                       ; get current pixel row
149+  BBBD FE 00            cp 0
150+  BBBF C2 C7 BB         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  BBC2 16 00            ld d,0
152+  BBC4 1E 01            ld e,1                          ; got to end, so space is empty
153+  BBC6 C9               ret
154+  BBC7              movement_lineaboveisempty1:
155+  BBC7 16 00            ld d,0
156+  BBC9 1E 00            ld e,0                          ; returning false, ie space not empty
157+  BBCB C9               ret
158+  BBCC
159+  BBCC              ;
160+  BBCC              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  BBCC              ; Inputs:
162+  BBCC              ; hl - memory location of top pixel row
163+  BBCC              ; bc - screen coords, b horiz, c vert
164+  BBCC              ; Outputs:
165+  BBCC              ; none - puts player into digging mode
166+  BBCC              ;
167+  BBCC              movement_spaceisdiggable:
168+  BBCC 3E 08            ld a,8                          ; 8 rows to check
169+  BBCE              movement_spaceisdiggable0:
170+  BBCE 08               ex af,af'                       ; store the loop counter
171+  BBCF 7E               ld a,(hl)                       ; get current pixel row
172+  BBD0 FE 00            cp 0
173+  BBD2 CA E2 BB         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  BBD5 FE 55            cp 85
175+  BBD7 CA E2 BB         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  BBDA FE AA            cp 170
177+  BBDC CA E2 BB         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  BBDF C3 FC BB         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  BBE2              movement_spaceisdiggable2:
180+  BBE2 79               ld a,c                          ; load the vertical coord
181+  BBE3 3C               inc a                           ; next row down
182+  BBE4 11 20 00         ld de,32
183+  BBE7 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  BBE8 4F               ld c,a                          ; copy vert coord back to c
185+  BBE9 08               ex af,af'                       ; get loop counter back
186+  BBEA 3D               dec a                           ; decrease loop counter
187+  BBEB C2 CE BB         jp nz, movement_spaceisdiggable0
188+  BBEE 21 80 BD         ld hl,player+6
189+  BBF1 36 01            ld (hl),1                       ; set the player into digging mode
190+  BBF3 23               inc hl
191+  BBF4 3A 1B BB         ld a,(movement_numberdigframes)
192+  BBF7 77               ld (hl),a                       ; set the number of frame to dig for
193+  BBF8 23               inc hl
194+  BBF9 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  BBFB C9               ret
196+  BBFC              movement_spaceisdiggable1:
197+  BBFC 21 80 BD         ld hl,player+6
198+  BBFF 36 00            ld (hl),0                       ; set the player out of digging mode
199+  BC01 C9               ret
200+  BC02
201+  BC02              ;
202+  BC02              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
203+  BC02              ; Inputs:
204+  BC02              ; hl - memory location of top pixel row
205+  BC02              ; bc - screen coords, b horiz, c vert
206+  BC02              ; Outputs:
207+  BC02              ; none - puts player into digging mode
208+  BC02              ;
209+  BC02              movement_spacebelowisdiggable:
210+  BC02 7E               ld a,(hl)                       ; get first pixel row
211+  BC03 FE 55            cp 85
212+  BC05 CA 10 BC         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
213+  BC08 FE AA            cp 170
214+  BC0A CA 10 BC         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
215+  BC0D C3 FC BB         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
216+  BC10              movement_spacebelowisdiggable3:
217+  BC10 3E 08            ld a,8                          ; rows to check
218+  BC12 1E 00            ld e,0                          ; count of rows to dig
219+  BC14              movement_spacebelowisdiggable0:
220+  BC14 08               ex af,af'                       ; store the loop counter
221+  BC15 7E               ld a,(hl)                       ; get current pixel row
222+  BC16 FE 55            cp 85
223+  BC18 CA 23 BC         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
224+  BC1B FE AA            cp 170
225+  BC1D CA 23 BC         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
226+  BC20 C3 32 BC         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
227+  BC23              movement_spacebelowisdiggable4:
228+  BC23 1C               inc e                           ; inc count of rows to dig
229+  BC24              movement_spacebelowisdiggable2:
230+  BC24 79               ld a,c                          ; load the vertical coord
231+  BC25 3C               inc a                           ; next row down
232+  BC26 D5               push de                         ; need e for later
233+  BC27 11 20 00         ld de,32
234+  BC2A 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
235+  BC2B 4F               ld c,a                          ; copy vert coord back to c
236+  BC2C D1               pop de                          ; get e back
237+  BC2D 08               ex af,af'                       ; get loop counter back
238+  BC2E 3D               dec a                           ; incease loop counter
239+  BC2F C2 14 BC         jp nz, movement_spacebelowisdiggable0
240+  BC32              movement_spacebelowisdiggable5:
241+  BC32 21 80 BD         ld hl,player+6
242+  BC35 36 01            ld (hl),1                       ; set the player into digging mode
243+  BC37 23               inc hl
244+  BC38 3A 1B BB         ld a,(movement_numberdigframes)
245+  BC3B 77               ld (hl),a                       ; set the number of frame to dig for
246+  BC3C 23               inc hl
247+  BC3D 73               ld (hl),e                       ; set the number of pixels to dig
248+  BC3E C9               ret
249+  BC3F              movement_spacebelowisdiggable1:
250+  BC3F 21 80 BD         ld hl,player+6
251+  BC42 36 00            ld (hl),0                       ; set the player out of digging mode
252+  BC44 C9               ret
253+  BC45
254+  BC45              ;
255+  BC45              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
256+  BC45              ; Inputs:
257+  BC45              ; hl - memory location of top pixel row
258+  BC45              ; bc - screen coords, b horiz, c vert
259+  BC45              ; Outputs:
260+  BC45              ; none - puts player into digging mode
261+  BC45              ;
262+  BC45              movement_spaceaboveisdiggable:
263+  BC45 7E               ld a,(hl)                       ; get first pixel row
264+  BC46 FE 55            cp 85
265+  BC48 CA 53 BC         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
266+  BC4B FE AA            cp 170
267+  BC4D CA 53 BC         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
268+  BC50 C3 FC BB         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
269+  BC53              movement_spaceaboveisdiggable3:
270+  BC53 3E 08            ld a,8                          ; rows to check
271+  BC55 1E 00            ld e,0                          ; count of rows to dig
272+  BC57              movement_spaceaboveisdiggable0:
273+  BC57 08               ex af,af'                       ; store the loop counter
274+  BC58 7E               ld a,(hl)                       ; get current pixel row
275+  BC59 FE 55            cp 85
276+  BC5B CA 66 BC         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
277+  BC5E FE AA            cp 170
278+  BC60 CA 66 BC         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
279+  BC63 C3 76 BC         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
280+  BC66              movement_spaceaboveisdiggable4:
281+  BC66 1C               inc e                           ; inc count of rows to dig
282+  BC67              movement_spaceaboveisdiggable2:
283+  BC67 79               ld a,c                          ; load the vertical coord
284+  BC68 3D               dec a                           ; next row up
285+  BC69 D5               push de                         ; need e for later
286+  BC6A 11 20 00         ld de,32
287+  BC6D ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
288+  BC6F 4F               ld c,a                          ; copy vert coord back to c
289+  BC70 D1               pop de                          ; get e back
290+  BC71 08               ex af,af'                       ; get loop counter back
291+  BC72 3D               dec a                           ; incease loop counter
292+  BC73 C2 57 BC         jp nz, movement_spaceaboveisdiggable0
293+  BC76              movement_spaceaboveisdiggable5:
294+  BC76 21 80 BD         ld hl,player+6
295+  BC79 36 01            ld (hl),1                       ; set the player into digging mode
296+  BC7B 23               inc hl
297+  BC7C 3A 1B BB         ld a,(movement_numberdigframes)
298+  BC7F 77               ld (hl),a                       ; set the number of frame to dig for
299+  BC80 23               inc hl
300+  BC81 73               ld (hl),e                       ; set the number of pixels to dig
301+  BC82 C9               ret
302+  BC83              movement_spaceaboveisdiggable1:
303+  BC83 21 80 BD         ld hl,player+6
304+  BC86 36 00            ld (hl),0                       ; set the player out of digging mode
305+  BC88 C9               ret
306+  BC89
307+  BC89              ;
308+  BC89              ; Checks if the player can move down
309+  BC89              ; Inputs:
310+  BC89              ; bc - player coords, b horiz, c vert
311+  BC89              ; Outputs:
312+  BC89              ; de - 1 can move
313+  BC89              movement_checkcanmove_down:
314+  BC89 F5               push af
315+  BC8A C5               push bc
316+  BC8B CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
317+  BC8E 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
318+  BC90 24               inc h                       ; memory location of cell beneath now in hl
319+  BC91 3E 08            ld a,8                       ; look below
320+  BC93 81               add c
321+  BC94 4F               ld c,a
322+  BC95 CD 96 BB         call movement_linebelowisempty       ; check space is empty
323+  BC98 7B               ld a,e                          ; check space empty flag
324+  BC99 FE 00            cp 0
325+  BC9B CA A4 BC         jp z, movement_checkcanmove_down1 ; can't move
326+  BC9E CD 73 BF         call player_justmoved
327+  BCA1 C1               pop bc
328+  BCA2 F1               pop af
329+  BCA3 C9               ret
330+  BCA4              movement_checkcanmove_down1:
331+  BCA4 C1               pop bc
332+  BCA5 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
333+  BCA8 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
334+  BCAA 24               inc h
335+  BCAB C5               push bc
336+  BCAC CD 02 BC         call movement_spacebelowisdiggable    ; can't move here, but can we dig
337+  BCAF 11 00 00         ld de,0
338+  BCB2 C1               pop bc
339+  BCB3 F1               pop af
340+  BCB4 C9               ret
341+  BCB5
342+  BCB5              ;
343+  BCB5              ; Checks if the player can move up
344+  BCB5              ; Inputs:
345+  BCB5              ; bc - player coords, b horiz, c vert
346+  BCB5              ; Outputs:
347+  BCB5              ; de - 1 can move
348+  BCB5              movement_checkcanmove_up:
349+  BCB5 F5               push af
350+  BCB6 C5               push bc
351+  BCB7 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
352+  BCBA 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
353+  BCBC 11 20 00         ld de,32
354+  BCBF ED 52            sbc hl,de                       ; memory location of line above now in hl
355+  BCC1 0D               dec c                           ; look above
356+  BCC2 CD B1 BB         call movement_lineaboveisempty       ; check space is empty
357+  BCC5 7B               ld a,e                          ; check space empty flag
358+  BCC6 FE 00            cp 0
359+  BCC8 CA D3 BC         jp z, movement_checkcanmove_up1 ; can't move
360+  BCCB 1E 01            ld e,1
361+  BCCD CD 73 BF         call player_justmoved
362+  BCD0 C1               pop bc
363+  BCD1 F1               pop af
364+  BCD2 C9               ret
365+  BCD3              movement_checkcanmove_up1:
366+  BCD3 C1               pop bc
367+  BCD4 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
368+  BCD7 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
369+  BCD9 11 20 00         ld de,32
370+  BCDC ED 52            sbc hl,de                       ; memory location of line above now in hl
371+  BCDE C5               push bc
372+  BCDF CD 45 BC         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
373+  BCE2 11 00 00         ld de,0
374+  BCE5 C1               pop bc
375+  BCE6 F1               pop af
376+  BCE7 C9               ret
377+  BCE8
378+  BCE8              ;
379+  BCE8              ; Checks if the player can move right
380+  BCE8              ; Inputs:
381+  BCE8              ; bc - player coords, b horiz, c vert
382+  BCE8              ; Outputs:
383+  BCE8              ; de - 1 can move
384+  BCE8              movement_checkcanmove_right:
385+  BCE8 F5               push af
386+  BCE9 C5               push bc
387+  BCEA CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
388+  BCED 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
389+  BCEF 3E 08            ld a,8
390+  BCF1 80               add b                           ; move one cell right
391+  BCF2 47               ld b,a
392+  BCF3 23               inc hl                          ; memory location of cell to the right now in hl
393+  BCF4 CD 1C BB         call movement_spaceisempty       ; check space is empty
394+  BCF7 7B               ld a,e                          ; check space empty flag
395+  BCF8 FE 00            cp 0
396+  BCFA CA 03 BD         jp z, movement_checkcanmove_right1 ; can't move
397+  BCFD CD 73 BF         call player_justmoved
398+  BD00 C1               pop bc
399+  BD01 F1               pop af
400+  BD02 C9               ret
401+  BD03              movement_checkcanmove_right1:
402+  BD03 C1               pop bc
403+  BD04 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
404+  BD07 62 6B            ld hl,de
405+  BD09 23               inc hl                          ; memory location of cell to the right now in hl
406+  BD0A C5               push bc
407+  BD0B CD CC BB         call movement_spaceisdiggable    ; can't move here, but can we dig
408+  BD0E 11 00 00         ld de,0
409+  BD11 C1               pop bc
410+  BD12 F1               pop af
411+  BD13 C9               ret
412+  BD14
413+  BD14              ;
414+  BD14              ; Checks if the player can move left
415+  BD14              ; Inputs:
416+  BD14              ; bc - player coords, b horiz, c vert
417+  BD14              ; Outputs:
418+  BD14              ; de - 1 can move
419+  BD14              movement_checkcanmove_left:
420+  BD14 F5               push af
421+  BD15 C5               push bc
422+  BD16 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
423+  BD19 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
424+  BD1B 78               ld a,b
425+  BD1C 06 08            ld b,8
426+  BD1E 90               sub b                           ; move one cell left
427+  BD1F 47               ld b,a
428+  BD20 2B               dec hl                          ; memory location of cell to the right now in hl
429+  BD21 CD 1C BB         call movement_spaceisempty       ; check space is empty
430+  BD24 7B               ld a,e                          ; check space empty flag
431+  BD25 FE 00            cp 0
432+  BD27 CA 30 BD         jp z, movement_checkcanmove_left1 ; can't move
433+  BD2A CD 73 BF         call player_justmoved
434+  BD2D C1               pop bc
435+  BD2E F1               pop af
436+  BD2F C9               ret
437+  BD30              movement_checkcanmove_left1:
438+  BD30 C1               pop bc
439+  BD31 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
440+  BD34 62 6B            ld hl,de
441+  BD36 2B               dec hl                          ; memory location of cell to the right now in hl
442+  BD37 C5               push bc
443+  BD38 CD CC BB         call movement_spaceisdiggable    ; can't move here, but can we dig
444+  BD3B 11 00 00         ld de,0
445+  BD3E C1               pop bc
446+  BD3F F1               pop af
447+  BD40 C9               ret
# file closed: game/movement.asm
 39   BD41                  include "game\game.asm"
# file opened: game/game.asm
  1+  BD41              ;
  2+  BD41              ; The current frame count, incremented each frame
  3+  BD41              ;
  4+  BD41              game_framenumber:
  5+  BD41 00               defb    0
  6+  BD42
  7+  BD42              ;
  8+  BD42              ; The number of players
  9+  BD42              ;
 10+  BD42              game_numberplayers:
 11+  BD42 01               defb 1
 12+  BD43
 13+  BD43              ;
 14+  BD43              ; The current player
 15+  BD43              ;
 16+  BD43              game_currentplayer:
 17+  BD43 01               defb 1
 18+  BD44
 19+  BD44              ;
 20+  BD44              ; The default number of lives
 21+  BD44              ;
 22+  BD44              game_numberlives:
 23+  BD44 04               defb 4
 24+  BD45
 25+  BD45              ;
 26+  BD45              ; The current difficulty
 27+  BD45              ;
 28+  BD45              game_difficulty:
 29+  BD45 00               defb 0
 30+  BD46
 31+  BD46              ;
 32+  BD46              ; Control method: 0 for keyboard, 1 for kempston
 33+  BD46              ;
 34+  BD46              game_control:
 35+  BD46 00               defb 0
 36+  BD47
 37+  BD47              ;
 38+  BD47              ; Moves to the next player
 39+  BD47              ;
 40+  BD47              game_changeplayer:
 41+  BD47 3A 43 BD         ld a,(game_currentplayer)
 42+  BD4A FE 01            cp 1
 43+  BD4C C8               ret z                       ; if just one player, no need to change
 44+  BD4D 3D               dec a                       ; otherwise decrease by one
 45+  BD4E EE 01            xor 1                       ; xor with one to flip
 46+  BD50 3C               inc a                       ; increment
 47+  BD51 21 43 BD         ld hl,game_currentplayer
 48+  BD54 77               ld (hl),a                   ; store
 49+  BD55 C9               ret
 50+  BD56
 51+  BD56              ;
 52+  BD56              ; Sets the number of players at the start of the game
 53+  BD56              ; Inputs:
 54+  BD56              ; a - number of players
 55+  BD56              game_setnumberofplayers:
 56+  BD56 21 42 BD         ld hl,game_numberplayers
 57+  BD59 77               ld (hl),a
 58+  BD5A
 59+  BD5A              ;
 60+  BD5A              ; Increment frame number by 1
 61+  BD5A              ;
 62+  BD5A              game_incrementframe:
 63+  BD5A 3A 41 BD         ld a,(game_framenumber)
 64+  BD5D FE FF            cp 255
 65+  BD5F C2 64 BD         jp nz,game_incrementframe0
 66+  BD62 3E 00            ld a,0
 67+  BD64              game_incrementframe0:
 68+  BD64 3C               inc a
 69+  BD65 32 41 BD         ld (game_framenumber),a
 70+  BD68 C9               ret
 71+  BD69
 72+  BD69              ;
 73+  BD69              ; Returns current frame
 74+  BD69              ; Outputs:
 75+  BD69              ; a - current frame
 76+  BD69              ;
 77+  BD69              game_getcurrentframe:
 78+  BD69 3A 41 BD         ld a,(game_framenumber)
 79+  BD6C C9               ret
 80+  BD6D
 81+  BD6D              ;
 82+  BD6D              ; Resets current frame
 83+  BD6D              ;
 84+  BD6D              game_resetcurrentframe:
 85+  BD6D 21 41 BD         ld hl,game_framenumber
 86+  BD70 36 00            ld (hl),0
 87+  BD72 C9               ret
 88+  BD73
 89+  BD73              ;
 90+  BD73              ; Increases the current difficulty
 91+  BD73              ;
 92+  BD73              game_increasedifficulty:
 93+  BD73 3A 45 BD         ld a,(game_difficulty)
 94+  BD76 3C               inc a
 95+  BD77 32 45 BD         ld (game_difficulty),a
# file closed: game/game.asm
 40   BD7A                  include "game\player.asm"
# file opened: game/player.asm
  1+  BD7A              ;
  2+  BD7A              ;   Data for current player
  3+  BD7A              ;
  4+  BD7A              player:
  5+  BD7A 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  BD7C 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  BD7F 00               defb    0                   ; auto move remaining (+5)
  8+  BD80 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  BD83 00               defb    0                   ; lives remaining (+9)
 10+  BD84 00               defb    0                   ; died this life (+10)
 11+  BD85 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  BD87 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  BD88 00               defb    0                   ; difficulty (+14)
 14+  BD89
 15+  BD89              player_location:
 16+  BD89 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 17+  BD8A
 18+  BD8A              ;
 19+  BD8A              ; Works out which part of the screen the player is in
 20+  BD8A              ; Pit is between 3,9 and 8,9
 21+  BD8A              ; Diamond cavern is between 11,22 and 22,28
 22+  BD8A              ;
 23+  BD8A              player_getlocation:
 24+  BD8A ED 4B 7A BD      ld bc,(player)              ; get screen coords
 25+  BD8E CD 58 A9         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 26+  BD91 78               ld a,b                      ; check for pit first
 27+  BD92 FE 09            cp 9                        ; if not on this row, not in the pit
 28+  BD94 C2 A3 BD         jp nz,player_getlocation0
 29+  BD97 79               ld a,c                      ; check horizontal
 30+  BD98 FE 09            cp 9
 31+  BD9A D2 A3 BD         jp nc, player_getlocation0  ; if more than 9, not in the pit
 32+  BD9D 21 89 BD         ld hl,player_location
 33+  BDA0 36 02            ld (hl),2                   ; load location with 2, the pit
 34+  BDA2 C9               ret                         ; done
 35+  BDA3              player_getlocation0:            ; check for diamond cavern
 36+  BDA3 78               ld a,b                      ; first check vertical
 37+  BDA4 FE 16            cp 22                       ; if above row 22, then not in cavern
 38+  BDA6 DA BA BD         jp c,player_getlocation1
 39+  BDA9 79               ld a,c                      ; get the horizontal next
 40+  BDAA FE 0B            cp 11
 41+  BDAC DA BA BD         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 42+  BDAF FE 16            cp 22
 43+  BDB1 D2 BA BD         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 44+  BDB4 21 89 BD         ld hl,player_location
 45+  BDB7 36 01            ld (hl),1                   ; load location with 1, the cavern
 46+  BDB9 C9               ret
 47+  BDBA              player_getlocation1:
 48+  BDBA 21 89 BD         ld hl,player_location
 49+  BDBD 36 00            ld (hl),0                   ; load location with 2, the pit
 50+  BDBF C9               ret                         ; done
 51+  BDC0
 52+  BDC0
 53+  BDC0              ;
 54+  BDC0              ; Initializes a player at start of game
 55+  BDC0              ; Copy initial coords, copy lives, copy score
 56+  BDC0              ;
 57+  BDC0              player_init_gamestart:
 58+  BDC0 3A 44 BD         ld a,(game_numberlives)
 59+  BDC3 32 6F BE         ld (player1_lives),a
 60+  BDC6 32 70 BE         ld (player2_lives),a                        ; set the initial number of lives at game start
 61+  BDC9
 62+  BDC9 21 73 BE         ld hl,player1_score+2
 63+  BDCC 06 06            ld b,6
 64+  BDCE              player_init_gamestart0:
 65+  BDCE 36 30            ld (hl),48
 66+  BDD0 23               inc hl
 67+  BDD1 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 68+  BDD3 21 7C BE         ld hl,player2_score+2
 69+  BDD6 06 06            ld b,6
 70+  BDD8              player_init_gamestart1:
 71+  BDD8 36 30            ld (hl),48
 72+  BDDA 23               inc hl
 73+  BDDB 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 74+  BDDD 3E 00            ld a,0
 75+  BDDF 32 83 BE         ld (player1_difficulty),a
 76+  BDE2 32 84 BE         ld (player2_difficulty),a                   ; set player difficulties to zero
 77+  BDE5 C9               ret
 78+  BDE6
 79+  BDE6              ;
 80+  BDE6              ; Initializes a player at start of a life
 81+  BDE6              ; Copy initial coords, copy lives, copy score
 82+  BDE6              ;
 83+  BDE6              player_init_lifestart:
 84+  BDE6 21 7F BD         ld hl,player+5
 85+  BDE9 06 09            ld b,9                      ; initialise 9 properties
 86+  BDEB              player_init_lifestart2:
 87+  BDEB 36 00            ld (hl),0
 88+  BDED 23               inc hl
 89+  BDEE 10 FB            djnz player_init_lifestart2
 90+  BDF0
 91+  BDF0 21 7C BD         ld hl,player+2              ; initialise some properties
 92+  BDF3 36 02            ld (hl),2
 93+  BDF5 23               inc hl
 94+  BDF6 36 00            ld (hl),0
 95+  BDF8 23               inc hl
 96+  BDF9 36 01            ld (hl),1
 97+  BDFB
 98+  BDFB ED 4B 22 80      ld bc,(init_coord)
 99+  BDFF ED 43 7A BD      ld (player),bc
100+  BE03 01 83 BD         ld bc,player+9
101+  BE06 3A 6F BE         ld a,(player1_lives)
102+  BE09 02               ld (bc),a
103+  BE0A
104+  BE0A CD 1C C6         call diamonds_init      ; initialise gems
105+  BE0D
106+  BE0D 01 06 00         ld bc,6
107+  BE10 11 49 C4         ld de,scores_current+2
108+  BE13 3A 43 BD         ld a,(game_currentplayer)
109+  BE16 FE 01            cp 1
110+  BE18 C2 27 BE         jp nz,player_init_lifestart0
111+  BE1B 3A 83 BE         ld a,(player1_difficulty)       ; initialise player 1 difficulty
112+  BE1E 32 45 BD         ld (game_difficulty),a
113+  BE21 21 73 BE         ld hl,player1_score+2           ; itialise player 1 scores
114+  BE24 C3 30 BE         jp player_init_lifestart1
115+  BE27              player_init_lifestart0:
116+  BE27 3A 84 BE         ld a,(player2_difficulty)       ; initialise player 2 difficulty
117+  BE2A 32 45 BD         ld (game_difficulty),a
118+  BE2D 21 7C BE         ld hl,player2_score+2           ; initialise player 2 scores
119+  BE30              player_init_lifestart1:
120+  BE30 ED B0            ldir
121+  BE32 C9               ret
122+  BE33
123+  BE33              ;
124+  BE33              ; Finalises a player at end of a life
125+  BE33              ; Copy lives, copy score
126+  BE33              ;
127+  BE33              player_lifeend:
128+  BE33 01 83 BD         ld bc,player+9
129+  BE36 0A               ld a,(bc)
130+  BE37 01 6F BE         ld bc,player1_lives
131+  BE3A 02               ld (bc),a
132+  BE3B CD 3F BE         call player_recordcurrentstate
133+  BE3E C9               ret
134+  BE3F
135+  BE3F              ;
136+  BE3F              ; Copies the current score and difficulty in the current player
137+  BE3F              ;
138+  BE3F              player_recordcurrentstate:
139+  BE3F 01 06 00         ld bc,6                  ; copy current score back to correct player
140+  BE42 21 49 C4         ld hl,scores_current+2
141+  BE45 3A 43 BD         ld a,(game_currentplayer)
142+  BE48 FE 01            cp 1
143+  BE4A C2 59 BE         jp nz,player_recordcurrentstate0
144+  BE4D 3A 45 BD         ld a,(game_difficulty)
145+  BE50 32 83 BE         ld (player1_difficulty),a       ; store difficulty
146+  BE53 11 73 BE         ld de,player1_score+2
147+  BE56 C3 62 BE         jp player_recordcurrentstate1
148+  BE59              player_recordcurrentstate0:         ; do player 2
149+  BE59 3A 45 BD         ld a,(game_difficulty)
150+  BE5C 32 84 BE         ld (player2_difficulty),a       ; store difficulty
151+  BE5F 11 7C BE         ld de,player2_score+2
152+  BE62              player_recordcurrentstate1:
153+  BE62 ED B0            ldir
154+  BE64 C9               ret
155+  BE65
156+  BE65              ;
157+  BE65              ; Player just died, subtract a life
158+  BE65              ;
159+  BE65              player_died:
160+  BE65 01 83 BD         ld bc,player+9
161+  BE68 0A               ld a,(bc)
162+  BE69 3D               dec a
163+  BE6A 02               ld (bc),a
164+  BE6B CD 33 BE         call player_lifeend
165+  BE6E C9               ret
166+  BE6F
167+  BE6F              ;
168+  BE6F              ; Player lives
169+  BE6F              ;
170+  BE6F              player1_lives:
171+  BE6F 03               defb 3
172+  BE70              player2_lives:
173+  BE70 03               defb 3
174+  BE71
175+  BE71              ;
176+  BE71              ; Player scores
177+  BE71              ;
178+  BE71              player1_score:
179+  BE71 04 01 30 30      defb 4,1,'000000',255
179+  BE75 30 30 30 30
179+  BE79 FF
180+  BE7A              player2_score:
181+  BE7A 16 01 30 30      defb 22,1,'000000',255
181+  BE7E 30 30 30 30
181+  BE82 FF
182+  BE83
183+  BE83              ;
184+  BE83              ; Player difficulties
185+  BE83              ;
186+  BE83              player1_difficulty:
187+  BE83 00               defb 0
188+  BE84              player2_difficulty:
189+  BE84 00               defb 0
190+  BE85
191+  BE85              ;
192+  BE85              ; Kills a player this life
193+  BE85              ;
194+  BE85              player_killplayer:
195+  BE85 21 84 BD         ld hl,player+10
196+  BE88 36 01            ld (hl),1
197+  BE8A C9               ret
198+  BE8B
199+  BE8B              ;
200+  BE8B              ; Crush a player this life
201+  BE8B              ;
202+  BE8B              player_crushplayer:
203+  BE8B 21 85 BD         ld hl,player+11             ; mark as crushed
204+  BE8E 36 01            ld (hl),1
205+  BE90 C9               ret
206+  BE91
207+  BE91              player_tankkillplayer
208+  BE91 21 85 BD         ld hl,player+11             ; mark as tanked
209+  BE94 36 02            ld (hl),2
210+  BE96 C9               ret
211+  BE97
212+  BE97              player_zonkplayer
213+  BE97 21 85 BD         ld hl,player+11             ; mark as zonked (missile)
214+  BE9A 36 03            ld (hl),3
215+  BE9C C9               ret
216+  BE9D
217+  BE9D              player_pitkillplayer
218+  BE9D 21 85 BD         ld hl,player+11             ; mark as pit killed
219+  BEA0 36 04            ld (hl),4
220+  BEA2 C9               ret
221+  BEA3
222+  BEA3              player_robotkillplayer
223+  BEA3 21 85 BD         ld hl,player+11             ; mark as robot killed
224+  BEA6 36 05            ld (hl),5
225+  BEA8 C9               ret
226+  BEA9
227+  BEA9              ;
228+  BEA9              ; Draws the player at the current position or deletes them
229+  BEA9              ;
230+  BEA9              player_drawplayer:
231+  BEA9 3A 7C BD         ld a,(player+2)             ; get the current direction
232+  BEAC FE 03            cp 3
233+  BEAE C2 B3 BE         jp nz,player_drawplayer0
234+  BEB1 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
235+  BEB3              player_drawplayer0:             ; DYING CHECKS
236+  BEB3 5F               ld e,a                      ; store in e
237+  BEB4 3A 85 BD         ld a,(player+11)             ; get the dying flag
238+  BEB7 FE 01            cp 1
239+  BEB9 CA F3 BE         jp z,player_drawplayer3     ; if it's one, we're being crushed
240+  BEBC FE 04            cp 4
241+  BEBE CA 3B BF         jp z,player_drawplayer9     ; player is falling into the pit
242+  BEC1 FE 05            cp 5
243+  BEC3 CA 57 BF         jp z,player_drawplayer12    ; player has been killed by a robot
244+  BEC6              player_drawplayer4:             ; CHECK FOR DIGGING
245+  BEC6 3A 80 BD         ld a,(player+6)             ; get the dig flag
246+  BEC9 FE 01            cp 1
247+  BECB CA DC BE         jp z,player_drawplayer1    ; get dig frame
248+  BECE 3A 7D BD         ld a,(player+3)             ; this is normal movement so get the current frame
249+  BED1 83               add a,e
250+  BED2 C3 E1 BE         jp player_drawplayer2
251+  BED5              player_drawplayer6:             ; GETTING THE DIG FRAM
252+  BED5 E6 01            and 1                       ; check for odd
253+  BED7 C6 0A            add 10                      ; add 10, to get either 10 or 11
254+  BED9 C3 E1 BE         jp player_drawplayer2
255+  BEDC              player_drawplayer1:             ; GET THE NORMAL FRAME
256+  BEDC 3A 7C BD         ld a,(player+2)             ; digging, get the current direction again, because want all four
257+  BEDF C6 06            add a,6                     ; add direction to 6 to get frame
258+  BEE1              player_drawplayer2:             ; WORK OUT THE FRAME
259+  BEE1 07               rlca
260+  BEE2 07               rlca
261+  BEE3 07               rlca                        ; multiply by eight
262+  BEE4 6F               ld l,a
263+  BEE5 26 00            ld h,0
264+  BEE7 11 93 B6         ld de,player_sprite
265+  BEEA 19               add hl,de                   ; load hl with the location of the player sprite data
266+  BEEB              player_drawplayer7:             ; DRAW THE PlAYER
267+  BEEB ED 4B 7A BD      ld bc,(player)              ; load bc with the start coords
268+  BEEF CD 2A AA         call sprites_drawsprite     ; call the routine to draw the sprite
269+  BEF2                  ;call player_storeupdatedlines ; log updated rows
270+  BEF2 C9               ret
271+  BEF3              ;
272+  BEF3              ; CRUSHING
273+  BEF3              ;
274+  BEF3              player_drawplayer3:
275+  BEF3 21 86 BD         ld hl,player+12
276+  BEF6 7E               ld a,(hl)                  ; crushing, so get the current anim flag
277+  BEF7 FE 00            cp 0
278+  BEF9 C2 02 BF         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
279+  BEFC 3E 64            ld a,100
280+  BEFE 77               ld (hl),a                   ; otherwise, load up the anim frames
281+  BEFF C3 C6 BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
282+  BF02              player_drawplayer5:
283+  BF02 3D               dec a
284+  BF03 77               ld (hl),a
285+  BF04 FE 00            cp 0
286+  BF06 CC 85 BE         call z,player_killplayer     ; final animation, so kill the player
287+  BF09 FE 0A            cp 10                         ; play the sound
288+  BF0B CC C8 AF         call z, sound_rockfell
289+  BF0E FE 14            cp 20                        ; check if we should move the rock
290+  BF10 C2 24 BF         jp nz,player_drawplayer8
291+  BF13 D9               exx
292+  BF14 F5               push af
293+  BF15 ED 4B E7 C2      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
294+  BF19 21 DF B5         ld hl,sprites+72
295+  BF1C CD 2A AA         call sprites_drawsprite     ; draw a rock over current
296+  BF1F F1               pop af
297+  BF20 D9               exx
298+  BF21 C3 D5 BE         jp player_drawplayer6       ; continue drawing player
299+  BF24              player_drawplayer8:
300+  BF24 FE 14            cp 20
301+  BF26 D2 D5 BE         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
302+  BF29 ED 4B 7A BD      ld bc,(player)
303+  BF2D CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
304+  BF30 3E 42            ld a,66             ; load red
305+  BF32 CD B0 A9         call screen_setattr
306+  BF35 21 DF B5         ld hl,sprites+72            ; otherwise, player is rock
307+  BF38 C3 EB BE         jp player_drawplayer7
308+  BF3B              ;
309+  BF3B              ; FALLING
310+  BF3B              ;
311+  BF3B              player_drawplayer9:             ; player is falling into the pit
312+  BF3B 21 86 BD         ld hl,player+12
313+  BF3E 7E               ld a,(hl)                   ; get the frames
314+  BF3F FE 00            cp 0
315+  BF41 C2 4A BF         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
316+  BF44 3E 50            ld a,80
317+  BF46 77               ld (hl),a                   ; otherwise, load up the anim frames
318+  BF47 C3 C6 BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
319+  BF4A              player_drawplayer10:
320+  BF4A 3D               dec a
321+  BF4B 77               ld (hl),a
322+  BF4C FE 00            cp 0
323+  BF4E CC 85 BE         call z,player_killplayer     ; final frame, so kill the player
324+  BF51 3A 7D BD         ld a,(player+3)
325+  BF54 C3 E1 BE         jp player_drawplayer2
326+  BF57              ;
327+  BF57              ; ROBOT KILLED
328+  BF57              ;
329+  BF57              player_drawplayer12:
330+  BF57 21 86 BD         ld hl,player+12
331+  BF5A 7E               ld a,(hl)                   ; get the frames
332+  BF5B FE 00            cp 0
333+  BF5D C2 66 BF         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
334+  BF60 3E C8            ld a,200
335+  BF62 77               ld (hl),a                   ; otherwise, load up the anim frames
336+  BF63 C3 C6 BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
337+  BF66              player_drawplayer13:
338+  BF66 3D               dec a
339+  BF67 77               ld (hl),a
340+  BF68 FE 00            cp 0
341+  BF6A CC 85 BE         call z,player_killplayer     ; final frame, so kill the player
342+  BF6D 3A 7D BD         ld a,(player+3)
343+  BF70 C3 E1 BE         jp player_drawplayer2
344+  BF73
345+  BF73              ;
346+  BF73              ; Runs after the player just moved. Changes animation frame if required
347+  BF73              ;
348+  BF73              player_justmoved:
349+  BF73 D9               exx
350+  BF74 3A 7E BD         ld a,(player+4)             ; get the transition count
351+  BF77 FE 00            cp 0
352+  BF79 CA 7F BF         jp z, player_justmoved2     ; if zero reset and change the frame
353+  BF7C C3 99 BF         jp player_justmoved1       ; otherwise decrease and continue
354+  BF7F              player_justmoved2:
355+  BF7F                  ; reset and change frame in here
356+  BF7F 3E 01            ld a,1
357+  BF81 32 7E BD         ld (player+4),a            ; reset back to whatever
358+  BF84 3A 7D BD         ld a,(player+3)             ; load the frame
359+  BF87 FE 03            cp 3                       ; flip between 3 and 0
360+  BF89 C2 91 BF         jp nz, player_justmoved4
361+  BF8C 3E 00            ld a,0
362+  BF8E C3 93 BF         jp player_justmoved5
363+  BF91              player_justmoved4:
364+  BF91 3E 03            ld a,3
365+  BF93              player_justmoved5:
366+  BF93 32 7D BD         ld (player+3),a           ; save back
367+  BF96 C3 9D BF         jp player_justmoved3
368+  BF99              player_justmoved1:
369+  BF99                  ; decrease count
370+  BF99 3D               dec a
371+  BF9A 32 7E BD         ld (player+4),a
372+  BF9D              player_justmoved3:
373+  BF9D D9               exx;
374+  BF9E C9               ret
375+  BF9F
376+  BF9F              ;
377+  BF9F              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
378+  BF9F              ; Outputs:
379+  BF9F              ; a - 1 for completed level
380+  BF9F              player_checkforexit:
381+  BF9F ED 4B 7A BD      ld bc,(player)                 ; get player coords
382+  BFA3 ED 5B 22 80      ld de,(init_coord)             ; get start coords
383+  BFA7 78               ld a,b
384+  BFA8 BA               cp d                         ; compare horiz
385+  BFA9 C2 B4 BF         jp nz,player_checkforexit1
386+  BFAC 79               ld a,c
387+  BFAD BB               cp e                        ; compare vert
388+  BFAE C2 B4 BF         jp nz,player_checkforexit1
389+  BFB1              player_checkforexit0:
390+  BFB1 3E 01            ld a,1                       ; hasn't completed
391+  BFB3 C9               ret
392+  BFB4              player_checkforexit1:
393+  BFB4 3E 00            ld a,0                       ; has completed
394+  BFB6 C9               ret
# file closed: game/player.asm
 41   BFB7                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  BFB7              ;
  2+  BFB7              ; Ship initial position: vert,horiz
  3+  BFB7              ;
  4+  BFB7              ship_initpos:
  5+  BFB7 00 24            defb 0,36
  6+  BFB9              ship_initpos2:
  7+  BFB9 00 00            defb 0,0
  8+  BFBB              ship_frame:
  9+  BFBB 00               defb 0
 10+  BFBC              ;
 11+  BFBC              ; The current memory location
 12+  BFBC              ;
 13+  BFBC              ship_current_sprite:
 14+  BFBC 00 00            defb 0,0
 15+  BFBE
 16+  BFBE              ship_current_coords:
 17+  BFBE 00 00            defb 0,0
 18+  BFC0
 19+  BFC0              ship_process:
 20+  BFC0 3A 85 BD         ld a,(player+11)
 21+  BFC3 FE 02            cp 2                        ; has the player been killed by tank?
 22+  BFC5 C0               ret nz                      ; do nothing if not
 23+  BFC6 CD 0E BB         call control_scroll_up           ; make sure the screen is on the top screen
 24+  BFC9 CD 38 C0         call ship_takeoff           ; bye bye
 25+  BFCC CD 85 BE         call player_killplayer      ; killed
 26+  BFCF 06 32            ld b,50
 27+  BFD1 CD 99 80         call utilities_pauseforframes
 28+  BFD4 C9               ret
 29+  BFD5
 30+  BFD5              ;
 31+  BFD5              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  BFD5              ;
 33+  BFD5              ship_land:
 34+  BFD5 ED 4B B7 BF      ld bc,(ship_initpos)
 35+  BFD9 ED 43 B9 BF      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  BFDD 1E 00            ld e,0                      ; store a flag to track first time round
 37+  BFDF 06 09            ld b,9                      ; move down 8 pixels
 38+  BFE1              ship_land0:
 39+  BFE1 C5               push bc
 40+  BFE2 7B               ld a,e
 41+  BFE3 D5               push de                     ; store de for next time round
 42+  BFE4 FE 01            cp 1                        ; check first time flag
 43+  BFE6 C2 FB BF         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  BFE9 CD 80 C0         call ship_draw_full         ; delete old one
 45+  BFEC CD 64 C0         call ship_change_frame      ; increment the frame
 46+  BFEF ED 4B B9 BF      ld bc,(ship_initpos2)       ; get the current coords
 47+  BFF3 81 C6 01         add c,1                     ; move down one pixels
 48+  BFF6 4F               ld c,a
 49+  BFF7 ED 43 B9 BF      ld (ship_initpos2),bc
 50+  BFFB              ship_land1:
 51+  BFFB CD 80 C0         call ship_draw_full         ; draw the ship
 52+  BFFE CD 79 C0         call ship_draw_screen
 53+  C001 D1               pop de
 54+  C002 1E 01            ld e,1
 55+  C004 C1               pop bc
 56+  C005 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  C007                  ; done moving down
 58+  C007                  ; now move across
 59+  C007 CD A9 BE         call player_drawplayer      ; draw player
 60+  C00A CD 80 C0         call ship_draw_full         ; delete old one
 61+  C00D 1E 00            ld e,0                      ; store a flag to track first time round
 62+  C00F 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  C011              ship_land3:
 64+  C011 C5               push bc
 65+  C012 7B               ld a,e
 66+  C013 D5               push de                     ; store de for next time round
 67+  C014 FE 01            cp 1                        ; check first time flag
 68+  C016 C2 2B C0         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  C019 CD 80 C0         call ship_draw_full         ; delete old one
 70+  C01C CD 64 C0         call ship_change_frame      ; increment the frame
 71+  C01F ED 4B B9 BF      ld bc,(ship_initpos2)       ; get the current coords
 72+  C023 78               ld a,b
 73+  C024 D6 01            sub 1                       ; move back one pixels
 74+  C026 47               ld b,a
 75+  C027 ED 43 B9 BF      ld (ship_initpos2),bc
 76+  C02B              ship_land2:
 77+  C02B CD 80 C0         call ship_draw_full         ; draw the ship
 78+  C02E CD 79 C0         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  C031 D1               pop de
 80+  C032 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  C034 C1               pop bc
 82+  C035 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  C037 C9               ret
 84+  C038
 85+  C038              ;
 86+  C038              ;   Take off the ship
 87+  C038              ;
 88+  C038              ship_takeoff:
 89+  C038 1E 01            ld e,1                      ; store a flag to track first time round
 90+  C03A 06 08            ld b,8                      ; move up 8 pixels
 91+  C03C              ship_takeoff0:
 92+  C03C C5               push bc
 93+  C03D 7B               ld a,e
 94+  C03E D5               push de                     ; store de for next time round
 95+  C03F FE 01            cp 1                        ; check first time flag
 96+  C041 C2 57 C0         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  C044 ED 4B B9 BF      ld bc,(ship_initpos2)       ; get the current coords
 98+  C048 CD 80 C0         call ship_draw_full         ; delete old one
 99+  C04B CD 64 C0         call ship_change_frame      ; increment the frame
100+  C04E ED 4B B9 BF      ld bc,(ship_initpos2)       ; get the current coords
101+  C052 0D               dec c                       ; move up one pixels
102+  C053 ED 43 B9 BF      ld (ship_initpos2),bc
103+  C057              ship_takeoff1:
104+  C057 CD 80 C0         call ship_draw_full         ; draw the ship
105+  C05A CD 79 C0         call ship_draw_screen
106+  C05D D1               pop de
107+  C05E 1E 01            ld e,1
108+  C060 C1               pop bc
109+  C061 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  C063                  ; done moving up
111+  C063 C9               ret
112+  C064
113+  C064              ;
114+  C064              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  C064              ;
116+  C064              ship_change_frame:
117+  C064 F5               push af
118+  C065 3A BB BF         ld a,(ship_frame)
119+  C068 FE 00            cp 0
120+  C06A CA 72 C0         jp z,ship_change_frame0
121+  C06D 3E 00            ld a,0                      ; flip to 0
122+  C06F C3 74 C0         jp ship_change_frame1
123+  C072              ship_change_frame0:
124+  C072 3E 20            ld a,32                      ; flip to 32
125+  C074              ship_change_frame1:
126+  C074 32 BB BF         ld (ship_frame),a            ; save the frame
127+  C077 F1               pop af
128+  C078 C9               ret
129+  C079
130+  C079              ship_draw_screen:
131+  C079 76               halt
132+  C07A F3               di
133+  C07B CD 2F A7         call buffer_buffertoscreen  ; copy buffer to screen
134+  C07E FB               ei                          ; enable interupts
135+  C07F C9               ret
136+  C080
137+  C080              ship_draw_full:
138+  C080 21 03 B7         ld hl,ship_sprite
139+  C083 ED 4B B9 BF      ld bc,(ship_initpos2)         ; load bc with the start coords
140+  C087 22 BC BF         ld (ship_current_sprite),hl  ; put into memory
141+  C08A ED 43 BE BF      ld (ship_current_coords),bc  ; put into memory
142+  C08E CD AD C0         call ship_draw
143+  C091 08               ex af,af'
144+  C092 3A BB BF         ld a,(ship_frame)            ; get the animation frame
145+  C095 16 00            ld d,0
146+  C097 5F               ld e,a
147+  C098 19               add hl,de
148+  C099 22 BC BF         ld (ship_current_sprite),hl  ; put into memory
149+  C09C 08               ex af,af'
150+  C09D ED 4B B9 BF      ld bc,(ship_initpos2)         ; load bc with the start coords
151+  C0A1 81 C6 08         add c,8                      ; move one line down
152+  C0A4 4F               ld c,a
153+  C0A5 ED 43 BE BF      ld (ship_current_coords),bc  ; put into memory
154+  C0A9 CD AD C0         call ship_draw
155+  C0AC C9               ret
156+  C0AD
157+  C0AD              ;
158+  C0AD              ; Draw the ship
159+  C0AD              ; Inputs:
160+  C0AD              ; None, all in memory
161+  C0AD              ;
162+  C0AD              ship_draw:
163+  C0AD 3E 04            ld a,4                              ; 4 pieces per half
164+  C0AF              ship_draw0:
165+  C0AF F5               push af
166+  C0B0 2A BC BF         ld hl,(ship_current_sprite)
167+  C0B3 ED 4B BE BF      ld bc,(ship_current_coords)         ; load bc with the start coords
168+  C0B7 CD 2A AA         call sprites_drawsprite
169+  C0BA 2A BC BF         ld hl,(ship_current_sprite)
170+  C0BD ED 4B BE BF      ld bc,(ship_current_coords)         ; load bc with the start coords
171+  C0C1 11 08 00         ld de,8
172+  C0C4 19               add hl,de
173+  C0C5 80 C6 08         add b,8
174+  C0C8 47               ld b,a
175+  C0C9 22 BC BF         ld (ship_current_sprite),hl         ; put into memory
176+  C0CC ED 43 BE BF      ld (ship_current_coords),bc         ; put into memory
177+  C0D0 F1               pop af
178+  C0D1 3D               dec a
179+  C0D2 FE 00            cp 0
180+  C0D4 C2 AF C0         jp nz,ship_draw0
181+  C0D7
182+  C0D7 C9               ret
183+  C0D8
# file closed: game/ship.asm
 42   C0D8                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  C0D8              ;
  2+  C0D8              ; tank initial position: vert,horiz
  3+  C0D8              ;
  4+  C0D8              tank_initpos:
  5+  C0D8 10 D0            defb 16,208
  6+  C0DA              tank_initpos2:
  7+  C0DA 00 00            defb 0,0
  8+  C0DC              tank_frame:
  9+  C0DC 00               defb 0
 10+  C0DD              tank_anim:
 11+  C0DD 11               defb 17
 12+  C0DE
 13+  C0DE              ;
 14+  C0DE              ; The damage countdown
 15+  C0DE              ;
 16+  C0DE              tank_currentdamage:
 17+  C0DE F0               defb 240
 18+  C0DF
 19+  C0DF              ;
 20+  C0DF              ; The damage coordinate
 21+  C0DF              ;
 22+  C0DF              tank_currentdamagecoord:
 23+  C0DF 16 02            defb 22,2
 24+  C0E1
 25+  C0E1              ;
 26+  C0E1              ; Controls when the tank shoots
 27+  C0E1              ;
 28+  C0E1              tank_count:
 29+  C0E1 00               defb 0
 30+  C0E2
 31+  C0E2              ;
 32+  C0E2              ; Holds the block number of the current damage sprite
 33+  C0E2              ;
 34+  C0E2              tank_damageframe:
 35+  C0E2 00               defb 0
 36+  C0E3
 37+  C0E3              ;
 38+  C0E3              ; The current memory location
 39+  C0E3              ;
 40+  C0E3              tank_current_sprite:
 41+  C0E3 00 00            defb 0,0
 42+  C0E5
 43+  C0E5              tank_current_coords:
 44+  C0E5 00 00            defb 0,0
 45+  C0E7
 46+  C0E7              ;
 47+  C0E7              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  C0E7              ;
 49+  C0E7              tank_missile_displayed:
 50+  C0E7 00               defb 0
 51+  C0E8
 52+  C0E8              ;
 53+  C0E8              ; Initialise the tank
 54+  C0E8              ;
 55+  C0E8              tank_init:
 56+  C0E8 ED 4B D8 C0      ld bc,(tank_initpos)
 57+  C0EC ED 43 DA C0      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  C0F0 21 DC C0         ld hl,tank_frame
 59+  C0F3 36 00            ld (hl),0
 60+  C0F5 21 DD C0         ld hl,tank_anim
 61+  C0F8 36 11            ld (hl),17
 62+  C0FA 21 E2 C0         ld hl,tank_damageframe              ; reset tank
 63+  C0FD 36 00            ld (hl),0
 64+  C0FF 21 E1 C0         ld hl,tank_count
 65+  C102 36 00            ld (hl),0
 66+  C104 21 DE C0         ld hl,tank_currentdamage
 67+  C107 36 F0            ld (hl),240
 68+  C109 21 DF C0         ld hl,tank_currentdamagecoord
 69+  C10C 36 16            ld (hl),22
 70+  C10E 23               inc hl
 71+  C10F 36 02            ld (hl),2
 72+  C111 21 E7 C0         ld hl,tank_missile_displayed
 73+  C114 36 00            ld (hl),0
 74+  C116
 75+  C116 C9               ret
 76+  C117
 77+  C117              ;
 78+  C117              ;   Draw and move the tank
 79+  C117              ;   Start processing at frame 200
 80+  C117              ;   Don't move if anim is zero
 81+  C117              ;   Decrement frame if moved
 82+  C117              ;
 83+  C117              tank_process:
 84+  C117 3A DD C0         ld a,(tank_anim)
 85+  C11A FE 00            cp 0
 86+  C11C C2 23 C1         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  C11F CD 34 C1         call tank_fire
 88+  C122 C9               ret
 89+  C123              tank_process0:
 90+  C123 CD 69 BD         call game_getcurrentframe   ; get the current frame number into a
 91+  C126 FE 4B            cp 75
 92+  C128 D8               ret c                       ; return if the frame number is below 100
 93+  C129 CD 5A C2         call tank_move              ; move tank if not
 94+  C12C 3A DD C0         ld a,(tank_anim)
 95+  C12F 3D               dec a
 96+  C130 32 DD C0         ld (tank_anim),a            ; decrease the anim count
 97+  C133 C9               ret
 98+  C134
 99+  C134              ;
100+  C134              ; Fires the tank
101+  C134              ;
102+  C134              tank_fire:
103+  C134 3A E1 C0         ld a,(tank_count)            ; if not, don't do anything
104+  C137 3C               inc a                        ; increment
105+  C138 FE 32            cp 50                        ; have we reached fifty
106+  C13A C2 3F C1         jp nz,tank_fire0
107+  C13D 3E 00            ld a,0                       ; reset if reached fifty
108+  C13F              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  C13F 32 E1 C0         ld (tank_count),a            ; store tank count
110+  C142 FE 00            cp 0
111+  C144 CA 65 C1         jp z,tank_fire7              ; If this is zero, fire
112+  C147 3A E7 C0         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  C14A FE 00            cp 0
114+  C14C C8               ret z                       ; don't do anything if not
115+  C14D CD 14 C2         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  C150 3E 00            ld a,0                       ; reset the flag
117+  C152 32 E7 C0         ld (tank_missile_displayed),a
118+  C155 3E 02            ld a,2
119+  C157 ED 4B DF C0      ld bc,(tank_currentdamagecoord)
120+  C15B 0C               inc c
121+  C15C 0C               inc c
122+  C15D ED 43 41 AB      ld (origcoords),bc
123+  C161 CD 54 A6         call buffer_marklineforupdate
124+  C164 C9               ret                        ; only shoot if we're on 0
125+  C165              tank_fire7:
126+  C165 3A DE C0         ld a,(tank_currentdamage)    ; get the damage countdown
127+  C168 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
128+  C16A C2 A0 C1         jp nz,tank_fire1            ; not, so just do a normal frame
129+  C16D ED 4B DF C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
130+  C171 79               ld a,c
131+  C172 FE 0A            cp 10
132+  C174 C2 7B C1         jp nz, tank_fire6
133+  C177 CD 4C C2         call tank_killedbytank      ; we're through, so the player has died. Kill them.
134+  C17A C9               ret                         ; return if we're through the mountain
135+  C17B              tank_fire6:
136+  C17B 3E 0F            ld a,15
137+  C17D 32 E2 C0         ld (tank_damageframe),a     ; reset the damage frame
138+  C180 21 97 B5         ld hl,sprites               ; location of the empty block
139+  C183 CD 82 A9         call screen_showchar        ; show this character here
140+  C186 ED 4B DF C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
141+  C18A 05               dec b                       ; look one above
142+  C18B CD E6 A9         call screen_ischarempty     ; check if it is empty
143+  C18E ED 4B DF C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
144+  C192 FE 01            cp 1
145+  C194 C2 D7 C1         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
146+  C197 ED 4B DF C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  C19B 0D               dec c
148+  C19C ED 43 DF C0      ld (tank_currentdamagecoord),bc ; store the coord
149+  C1A0              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
150+  C1A0 ED 4B DF C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
151+  C1A4 3A DE C0         ld a,(tank_currentdamage)    ; get the damage countdown
152+  C1A7 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
153+  C1A9 C2 B4 C1         jp nz, tank_fire5
154+  C1AC CD 16 AA         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
155+  C1AF FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
156+  C1B1 C2 F5 C1         jp nz,tank_fire3            ; if it's a slope, handle this differently
157+  C1B4              tank_fire5:
158+  C1B4 3A E2 C0         ld a,(tank_damageframe)
159+  C1B7 CD A5 A9         call screen_getblock        ; get the block data into hl
160+  C1BA CD 82 A9         call screen_showchar        ; show this character here
161+  C1BD 3A E2 C0         ld a,(tank_damageframe)
162+  C1C0 3C               inc a
163+  C1C1 32 E2 C0         ld (tank_damageframe),a     ; increment the damage block and store
164+  C1C4 3A DE C0         ld a,(tank_currentdamage)    ; get the damage countdown
165+  C1C7 3D               dec a
166+  C1C8 3D               dec a
167+  C1C9 32 DE C0         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
168+  C1CC 3A E7 C0         ld a,(tank_missile_displayed) ; is the missile displaying?
169+  C1CF FE 00            cp 0
170+  C1D1 CC 14 C2         call z, tank_missilegraphic
171+  C1D4 C3 FE C1         jp tank_fire4
172+  C1D7              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
173+  C1D7 05               dec b
174+  C1D8 C5               push bc
175+  C1D9 CD FF A9         call screen_copyblockdown       ; copy the block down
176+  C1DC ED 4B DF C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
177+  C1E0 C1               pop bc                      ; get the coord we just checked back
178+  C1E1 78               ld a,b
179+  C1E2 FE 00            cp 0
180+  C1E4 CA A0 C1         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
181+  C1E7 C5               push bc
182+  C1E8 05               dec b
183+  C1E9 CD E6 A9         call screen_ischarempty     ; check if it is empty
184+  C1EC C1               pop bc
185+  C1ED FE 01            cp 1                        ; if empty
186+  C1EF C2 D7 C1         jp nz, tank_fire2            ; copy another one down
187+  C1F2 C3 A0 C1         jp tank_fire1               ; otherwise, return to main thread
188+  C1F5              tank_fire3:                      ; dealing with slopes
189+  C1F5 3A DE C0         ld a,(tank_currentdamage)    ; get the damage countdown
190+  C1F8 06 08            ld b,8
191+  C1FA 90               sub b                        ; special case for slopes
192+  C1FB 32 DE C0         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
193+  C1FE              tank_fire4:                     ; TIDY UP
194+  C1FE ED 4B DF C0      ld bc,(tank_currentdamagecoord)
195+  C202 ED 43 41 AB      ld (origcoords),bc
196+  C206 CD 54 A6         call buffer_marklineforupdate
197+  C209 3E 01            ld a,1
198+  C20B CD 54 A6         call buffer_marklineforupdate
199+  C20E 3E 02            ld a,2
200+  C210 CD 54 A6         call buffer_marklineforupdate
201+  C213 C9               ret
202+  C214
203+  C214              ;
204+  C214              ; Displays or hides the missile graphic, and changes the gun
205+  C214              ;
206+  C214              tank_missilegraphic:
207+  C214 3A E7 C0         ld a,(tank_missile_displayed)
208+  C217 FE 00            cp 0
209+  C219 C2 21 C2         jp nz,tank_missilegraphic0
210+  C21C 3E 13            ld a,19
211+  C21E C3 23 C2         jp tank_missilegraphic1
212+  C221              tank_missilegraphic0:
213+  C221 3E 00            ld a,0
214+  C223              tank_missilegraphic1:
215+  C223 32 E7 C0         ld (tank_missile_displayed),a ; store the flipped graphic
216+  C226 ED 4B DF C0      ld bc,(tank_currentdamagecoord)
217+  C22A 0C               inc c
218+  C22B 0C               inc c                   ; print the graphic 2 spaces right
219+  C22C CD A5 A9         call screen_getblock        ; get the block data into hl
220+  C22F CD 82 A9         call screen_showchar        ; show this character here
221+  C232 06 02            ld b,2
222+  C234 0E 18            ld c,24                     ; set gunbarrel coords
223+  C236 11 00 00         ld de,0
224+  C239 21 63 B7         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
225+  C23C 3A E7 C0         ld a,(tank_missile_displayed)
226+  C23F FE 00            cp 0
227+  C241 CA 47 C2         jp z,tank_missilegraphic2
228+  C244 11 40 00         ld de,64
229+  C247              tank_missilegraphic2:
230+  C247 19               add hl,de                   ; work out missile graphic
231+  C248 CD 82 A9         call screen_showchar        ; show this character here
232+  C24B C9               ret
233+  C24C
234+  C24C              ;
235+  C24C              ; Deal with the player being killed by the tank
236+  C24C              ;
237+  C24C              tank_killedbytank:
238+  C24C ED 4B DF C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
239+  C250 21 97 B5         ld hl,sprites                   ; empty sprite
240+  C253 CD 82 A9         call screen_showchar            ; hide the last piece of dirt
241+  C256 CD 91 BE         call player_tankkillplayer
242+  C259 C9               ret
243+  C25A
244+  C25A              tank_move:
245+  C25A ED 4B DA C0      ld bc,(tank_initpos2)
246+  C25E C5               push bc
247+  C25F 3A DD C0         ld a,(tank_anim)
248+  C262 FE 11            cp 17                       ; check first time flag
249+  C264 CA 76 C2         jp z,tank_move1             ; don't draw over previous one if first time
250+  C267 CD 7B C2         call tank_draw_full         ; delete old one
251+  C26A ED 4B DA C0      ld bc,(tank_initpos2)       ; get the current coords
252+  C26E 78               ld a,b
253+  C26F D6 01            sub 1                       ; move back one pixels
254+  C271 47               ld b,a
255+  C272 ED 43 DA C0      ld (tank_initpos2),bc
256+  C276              tank_move1:
257+  C276 CD 7B C2         call tank_draw_full         ; draw the tank
258+  C279 C1               pop bc
259+  C27A C9               ret
260+  C27B
261+  C27B              tank_draw_full:
262+  C27B 21 63 B7         ld hl,tank_sprite
263+  C27E ED 4B DA C0      ld bc,(tank_initpos2)         ; load bc with the start coords
264+  C282 22 E3 C0         ld (tank_current_sprite),hl  ; put into memory
265+  C285 ED 43 E5 C0      ld (tank_current_coords),bc  ; put into memory
266+  C289 CD A8 C2         call tank_draw
267+  C28C 08               ex af,af'
268+  C28D 3A DC C0         ld a,(tank_frame)            ; get the animation frame
269+  C290 16 00            ld d,0
270+  C292 5F               ld e,a
271+  C293 19               add hl,de
272+  C294 22 E3 C0         ld (tank_current_sprite),hl  ; put into memory
273+  C297 08               ex af,af'
274+  C298 ED 4B DA C0      ld bc,(tank_initpos2)         ; load bc with the start coords
275+  C29C 81 C6 08         add c,8                      ; move one line down
276+  C29F 4F               ld c,a
277+  C2A0 ED 43 E5 C0      ld (tank_current_coords),bc  ; put into memory
278+  C2A4 CD A8 C2         call tank_draw
279+  C2A7 C9               ret
280+  C2A8
281+  C2A8              ;
282+  C2A8              ; Draw the tank
283+  C2A8              ; Inputs:
284+  C2A8              ; None, all in memory
285+  C2A8              ;
286+  C2A8              tank_draw:
287+  C2A8 3E 04            ld a,4                              ; 4 pieces per half
288+  C2AA              tank_draw0:
289+  C2AA F5               push af
290+  C2AB 2A E3 C0         ld hl,(tank_current_sprite)
291+  C2AE ED 4B E5 C0      ld bc,(tank_current_coords)         ; load bc with the start coords
292+  C2B2 CD 2A AA         call sprites_drawsprite
293+  C2B5 2A E3 C0         ld hl,(tank_current_sprite)
294+  C2B8 ED 4B E5 C0      ld bc,(tank_current_coords)         ; load bc with the start coords
295+  C2BC 11 08 00         ld de,8
296+  C2BF 19               add hl,de
297+  C2C0 80 C6 08         add b,8
298+  C2C3 47               ld b,a
299+  C2C4 22 E3 C0         ld (tank_current_sprite),hl         ; put into memory
300+  C2C7 ED 43 E5 C0      ld (tank_current_coords),bc         ; put into memory
301+  C2CB F1               pop af
302+  C2CC 3D               dec a
303+  C2CD FE 00            cp 0
304+  C2CF C2 AA C2         jp nz,tank_draw0
305+  C2D2
306+  C2D2 C9               ret
307+  C2D3
# file closed: game/tank.asm
 43   C2D3                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  C2D3              ;
  2+  C2D3              ; A structure of falling rocks
  3+  C2D3              ; Assume we'll never have more than 4 falling at any one time
  4+  C2D3              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  C2D3              ;
  6+  C2D3              rocks_falling:
  7+  C2D3 00 00 00 00      defb 0,0,0,0
  8+  C2D7 00 00 00 00      defb 0,0,0,0
  9+  C2DB 00 00 00 00      defb 0,0,0,0
 10+  C2DF 00 00 00 00      defb 0,0,0,0
 11+  C2E3
 12+  C2E3              rocks_tmp:
 13+  C2E3 00               defb 0
 14+  C2E4
 15+  C2E4              rocks_tmp2:
 16+  C2E4 00 00            defb 0,0
 17+  C2E6
 18+  C2E6              ;
 19+  C2E6              ; The number of frames to wobble for
 20+  C2E6              ; Must always be 10 more than the number of frames a player digs
 21+  C2E6              ;
 22+  C2E6              rocks_numberofframestowobble:
 23+  C2E6 14               defb 20
 24+  C2E7
 25+  C2E7              ;
 26+  C2E7              ; Coords of the rock that killed us
 27+  C2E7              ;
 28+  C2E7              rocks_killerrock:
 29+  C2E7 00 00            defb 0,0
 30+  C2E9
 31+  C2E9              ;
 32+  C2E9              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  C2E9              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  C2E9              ; If the pixel row is not the rock bottom, stop checking.
 35+  C2E9              ; Inputs:
 36+  C2E9              ; hl- memory location
 37+  C2E9              ;
 38+  C2E9              rocks_checkforfalling:
 39+  C2E9 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  C2EA FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  C2EC C2 F2 C2         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  C2EF CD F3 C2         call rocks_addrocktofalling ; mark the rock as falling
 43+  C2F2              rocks_checkforfalling2:
 44+  C2F2 C9               ret
 45+  C2F3
 46+  C2F3              ;
 47+  C2F3              ; Adds the rock to the structure that tracks falling rocks
 48+  C2F3              ; Inputs:
 49+  C2F3              ; hl - memory location of falling rock graphic
 50+  C2F3              ; bc - coords of rock, c vert
 51+  C2F3              rocks_addrocktofalling:
 52+  C2F3 C5               push bc             ; store the coords
 53+  C2F4 11 D3 C2         ld de,rocks_falling
 54+  C2F7 06 04            ld b,4              ; number of possible falling rocks
 55+  C2F9              rocks_addrocktofalling0:
 56+  C2F9 13               inc de
 57+  C2FA                  ;inc de
 58+  C2FA 13               inc de              ; move three along to get the state
 59+  C2FB 1A               ld a,(de)           ; load the state
 60+  C2FC FE 00            cp 0                ; check if this is not falling
 61+  C2FE C2 15 C3         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  C301 13               inc de              ; move to frame
 63+  C302 3A E6 C2         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  C305 12               ld (de),a
 65+  C306 1B               dec de              ; move de back to state
 66+  C307 3E 02            ld a,2
 67+  C309 12               ld (de),a           ; set the state to wobbling
 68+  C30A 1B               dec de              ; move back coords
 69+  C30B C1               pop bc              ; get back coords
 70+  C30C 78               ld a,b
 71+  C30D 12               ld (de),a           ; store the vertical
 72+  C30E 1B               dec de
 73+  C30F 79               ld a,c
 74+  C310 12               ld (de),a           ; store the horizontal
 75+  C311 C5               push bc
 76+  C312 C3 19 C3         jp rocks_addrocktofalling2 ; done
 77+  C315              rocks_addrocktofalling1:
 78+  C315 13               inc de
 79+  C316 13               inc de              ; move memory along to next rock
 80+  C317 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  C319              rocks_addrocktofalling2: ; done, return
 82+  C319 C1               pop bc              ; to tidy up
 83+  C31A C9               ret
 84+  C31B
 85+  C31B              ;
 86+  C31B              ; Processes any falling rocks
 87+  C31B              ;
 88+  C31B              rocks_processrocks:
 89+  C31B DD 21 D3 C2      ld ix,rocks_falling
 90+  C31F 06 04            ld b,4              ; the number of rocks to check
 91+  C321              rocks_processrocks0:
 92+  C321 C5               push bc             ; store loop count
 93+  C322 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  C326 46 01
 94+  C328 DD 23            inc ix
 95+  C32A DD 23            inc ix              ; move to the state
 96+  C32C DD 7E 00         ld a,(ix)           ; load the state into a
 97+  C32F FE 00            cp 0
 98+  C331 CA 52 C3         jp z,rocks_processrocks3 ; if not falling, check next
 99+  C334 FE 02            cp 2
100+  C336 C2 46 C3         jp nz, rocks_processrocks2
101+  C339                  ; we're wobbling
102+  C339 DD 23            inc ix              ; get frame number for wobble
103+  C33B DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  C33E CD 15 C4         call rocks_wobble
105+  C341 DD 23            inc ix              ; increment for next
106+  C343 C3 56 C3         jp rocks_processrocks1  ; do next rock
107+  C346              rocks_processrocks2:
108+  C346                  ; we're falling
109+  C346 C5               push bc
110+  C347 CD 5A C3         call rocks_fall
111+  C34A C1               pop bc
112+  C34B DD 23            inc ix
113+  C34D DD 23            inc ix              ; inc ix to get to next
114+  C34F C3 56 C3         jp rocks_processrocks1
115+  C352              rocks_processrocks3:
116+  C352 DD 23            inc ix
117+  C354 DD 23            inc ix
118+  C356              rocks_processrocks1:
119+  C356 C1               pop bc              ; get loop count back
120+  C357 10 C8            djnz rocks_processrocks0
121+  C359 C9               ret
122+  C35A
123+  C35A              ;
124+  C35A              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  C35A              ; bc - coord of current rock graphic on screen
126+  C35A              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  C35A              ;
128+  C35A              rocks_fall:
129+  C35A DD 2B            dec ix
130+  C35C DD 2B            dec ix              ; decrease ix back to coords
131+  C35E ED 43 E4 C2      ld (rocks_tmp2),bc  ; store original coords
132+  C362 3E 03            ld a,3              ; move this number of pixels
133+  C364              rocks_fall1:
134+  C364 32 E3 C2         ld (rocks_tmp),a    ; store loop counter
135+  C367 DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  C36B 46 01
136+  C36D CD 1F AB         call sprites_scadd  ; get the memory of the coords into de
137+  C370 14               inc d               ; add 256 to get next row
138+  C371 1A               ld a,(de)           ; get the contents of the next row
139+  C372 FE 00            cp 0
140+  C374 C2 D4 C3         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  C377 0C               inc c               ; increment the vertical
142+  C378 DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  C37C 70 01
143+  C37E 79               ld a,c              ; get the vertical coord into a
144+  C37F E6 07            and 7               ; divisible by 8?
145+  C381 FE 00            cp 0
146+  C383 C2 A0 C3         jp nz,rocks_fall4   ; if not, carry on
147+  C386 CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  C389 3E 42            ld a,66             ; load red
149+  C38B CD B0 A9         call screen_setattr
150+  C38E DD 4E 00 DD      ld bc,(ix)
150+  C392 46 01
151+  C394 79               ld a,c              ; get vertical
152+  C395 D6 08            sub 8               ; look up one square
153+  C397 4F               ld c,a              ; put a back in c
154+  C398 CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  C39B 3E 46            ld a,70             ; load yellow
156+  C39D CD B0 A9         call screen_setattr
157+  C3A0              rocks_fall4:
158+  C3A0 3A E3 C2         ld a,(rocks_tmp)    ; get the loop counter
159+  C3A3 3D               dec a
160+  C3A4 FE 00            cp 0
161+  C3A6 C2 64 C3         jp nz,rocks_fall1   ; do another pixel if needed
162+  C3A9              rocks_fall2:
163+  C3A9 3E 09            ld a,9              ; rock graphic
164+  C3AB ED 4B E4 C2      ld bc,(rocks_tmp2)  ; get the original coords
165+  C3AF CD A5 A9         call screen_getblock     ; get the memory into hl
166+  C3B2 CD 2A AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  C3B5 3E 09            ld a,9
168+  C3B7 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  C3BB 46 01
169+  C3BD CD A5 A9         call screen_getblock     ; get the memory into hl
170+  C3C0 CD 2A AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  C3C3 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  C3C7 46 01
172+  C3C9 CD FA C3         call rocks_checkforplayer ; check to see if we hit a player
173+  C3CC DD 23            inc ix
174+  C3CE DD 23            inc ix                  ; get ix back to state
175+  C3D0 CD EA C3         call rocks_makesound
176+  C3D3 C9               ret
177+  C3D4              rocks_fall3:
178+  C3D4 3E 00            ld a,0              ; set the state to fell
179+  C3D6 DD 77 02         ld (ix+2),a           ; store the falling state
180+  C3D9 DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  C3DD 46 01
181+  C3DF CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  C3E2 3E 42            ld a,66             ; load magenta
183+  C3E4 CD B0 A9         call screen_setattr
184+  C3E7 C3 A9 C3         jp rocks_fall2      ; rejoin main loop
185+  C3EA
186+  C3EA              ;
187+  C3EA              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  C3EA              ;
189+  C3EA              rocks_makesound:
190+  C3EA DD 7E 00         ld a,(ix)           ; get the state
191+  C3ED FE 00            cp 0
192+  C3EF C0               ret nz              ; if we haven't fallen, don't do anything
193+  C3F0 21 85 BD         ld hl,player+11
194+  C3F3 7E               ld a,(hl)
195+  C3F4 FE 01            cp 1
196+  C3F6 C4 C8 AF         call nz, sound_rockfell ; only make sound if didn't kill player
197+  C3F9 C9               ret
198+  C3FA
199+  C3FA              ;
200+  C3FA              ; Checks to see if the rock is hitting a player
201+  C3FA              ; Inputs:
202+  C3FA              ; bc - coords of rock we're checking
203+  C3FA              rocks_checkforplayer:
204+  C3FA ED 5B 7A BD      ld de,(player)       ; get the player coords
205+  C3FE 7B               ld a,e               ; get the vert coord first
206+  C3FF 91               sub c                ; subtract the rock vertical coord from players
207+  C400 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  C402 C0               ret nz               ; if not, hasn't hit
209+  C403 7A               ld a,d               ; get the player horiz coord
210+  C404 90               sub b                ; subtract rock coord
211+  C405 C6 07            add 7                ; add max distance
212+  C407 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  C409 DA 0D C4         jp c,rocks_checkforplayer0
214+  C40C C9               ret
215+  C40D              rocks_checkforplayer0:
216+  C40D ED 43 E7 C2      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  C411 CD 8B BE         call player_crushplayer ; if so, jump out
218+  C414 C9               ret
219+  C415
220+  C415              ;
221+  C415              ; Wobbles a rocks
222+  C415              ; Inputs:
223+  C415              ; bc - coord of current rock graphic on screen
224+  C415              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  C415              ; a - wobble frame
226+  C415              rocks_wobble:
227+  C415 DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  C418 E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  C41A 1E 09            ld e,9              ; this is the rock frame
230+  C41C 83               add a,e             ; add the frame toggle
231+  C41D C5               push bc
232+  C41E CD A5 A9         call screen_getblock     ; get the memory into hl
233+  C421 CD 2A AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  C424 DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  C427 3D               dec a               ; decrease
236+  C428 DD 77 00         ld (ix),a           ; store
237+  C42B E6 01            and 1
238+  C42D 1E 09            ld e,9              ; this is the rock frame
239+  C42F 83               add a,e             ; add the frame toggle
240+  C430 CD A5 A9         call screen_getblock     ; get the memory into hl
241+  C433 C1               pop bc
242+  C434 CD 2A AA         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  C437 DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  C43A FE 00            cp 0
245+  C43C C0               ret nz              ; if we're not at zero, return
246+  C43D DD 2B            dec ix              ; otherwise look to state location
247+  C43F 3E 01            ld a,1              ; set the state to falling
248+  C441 DD 77 00         ld (ix),a           ; store the falling state
249+  C444 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  C446 C9               ret
251+  C447
# file closed: game/rocks.asm
 44   C447                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  C447              ;
  2+  C447              ; The score of the current player
  3+  C447              ;
  4+  C447              scores_current:
  5+  C447 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  C44B 30 30 30 30
  5+  C44F FF
  6+  C450
  7+  C450              scores_defaultname:
  8+  C450 2D 2D 2D         defb '---'
  9+  C453
 10+  C453              ;
 11+  C453              ; The current high score table
 12+  C453              ;
 13+  C453              scores_table:
 14+  C453 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  C457 4D 30 30 30
 14+  C45B 30 30 30 FF
 15+  C45F 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  C463 4D 30 30 30
 15+  C467 30 30 30 FF
 16+  C46B 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  C46F 4D 30 30 30
 16+  C473 30 30 30 FF
 17+  C477
 18+  C477              ;
 19+  C477              ; Add thousands to the score
 20+  C477              ; Inputs:
 21+  C477              ; b - number to add
 22+  C477              ;
 23+  C477              scores_addthousands:
 24+  C477 21 4B C4         ld hl,scores_current+4
 25+  C47A CD AB C4         call scores_update
 26+  C47D C9               ret
 27+  C47E
 28+  C47E              ;
 29+  C47E              ; Add hundreds to the score
 30+  C47E              ; Inputs:
 31+  C47E              ; b - number to add
 32+  C47E              ;
 33+  C47E              scores_addhundreds:
 34+  C47E 21 4C C4         ld hl,scores_current+5
 35+  C481 CD AB C4         call scores_update
 36+  C484 C9               ret
 37+  C485
 38+  C485              ;
 39+  C485              ; Prints the score to screen
 40+  C485              ;
 41+  C485              scores_printscore:
 42+  C485 3A 43 BD         ld a,(game_currentplayer)   ; get current player
 43+  C488 21 47 C4         ld hl,scores_current
 44+  C48B FE 01            cp 1
 45+  C48D C2 95 C4         jp nz, score_printscore0    ; if not player 1
 46+  C490 36 04            ld (hl),4       ; set position for player 1
 47+  C492 C3 97 C4         jp score_printscore1
 48+  C495              score_printscore0:
 49+  C495 36 16            ld (hl),22       ; set position for player 2
 50+  C497              score_printscore1:
 51+  C497 21 47 C4         ld hl,scores_current
 52+  C49A CD 54 85         call string_print
 53+  C49D C9               ret
 54+  C49E
 55+  C49E              ;
 56+  C49E              ; Prints both scores to screen
 57+  C49E              ;
 58+  C49E              scores_printscores:
 59+  C49E 21 71 BE         ld hl,player1_score
 60+  C4A1 CD 54 85         call string_print
 61+  C4A4 21 7A BE         ld hl,player2_score
 62+  C4A7 CD 54 85         call string_print
 63+  C4AA C9               ret
 64+  C4AB
 65+  C4AB              ;
 66+  C4AB              ; Updates the current score.
 67+  C4AB              ; Inputs:
 68+  C4AB              ; hl - memory location of the score column
 69+  C4AB              ; b - number to add
 70+  C4AB              ;
 71+  C4AB              scores_update:
 72+  C4AB 7E               ld a,(hl)           ; current value of digit.
 73+  C4AC 80               add a,b             ; add points to this digit.
 74+  C4AD 77               ld (hl),a           ; place new digit back in string.
 75+  C4AE FE 3A            cp 58               ; more than ASCII value '9'?
 76+  C4B0 D8               ret c               ; no - relax.
 77+  C4B1 D6 0A            sub 10              ; subtract 10.
 78+  C4B3 77               ld (hl),a           ; put new character back in string.
 79+  C4B4              scores_update0:
 80+  C4B4 2B               dec hl              ; previous character in string.
 81+  C4B5 34               inc (hl)            ; up this by one.
 82+  C4B6 7E               ld a,(hl)           ; what's the new value?
 83+  C4B7 FE 3A            cp 58               ; gone past ASCII nine?
 84+  C4B9 D8               ret c               ; no, scoring done.
 85+  C4BA D6 0A            sub 10              ; down by ten.
 86+  C4BC 77               ld (hl),a           ; put it back
 87+  C4BD C3 B4 C4         jp scores_update0   ; go round again.
 88+  C4C0
 89+  C4C0
 90+  C4C0              ;
 91+  C4C0              ; Displays the high score table at the bottom of the screen
 92+  C4C0              ;
 93+  C4C0              scores_showtable:
 94+  C4C0 21 53 C4         ld hl, scores_table
 95+  C4C3 CD 54 85         call string_print
 96+  C4C6 21 5F C4         ld hl, scores_table+12
 97+  C4C9 CD 54 85         call string_print
 98+  C4CC 21 6B C4         ld hl, scores_table+24
 99+  C4CF CD 54 85         call string_print
100+  C4D2 C9               ret
101+  C4D3
102+  C4D3              ;
103+  C4D3              ; Place to store the current position we're checking
104+  C4D3              ;
105+  C4D3              scores_highscoretmp:
106+  C4D3 00               defb 0
107+  C4D4
108+  C4D4              ;
109+  C4D4              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
110+  C4D4              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
111+  C4D4              ;
112+  C4D4              scores_processhighscores:
113+  C4D4 21 D3 C4         ld hl,scores_highscoretmp
114+  C4D7 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
115+  C4D9 3E 1D            ld a,29
116+  C4DB              scores_processhighscores3:
117+  C4DB 21 53 C4         ld hl,scores_table          ; position of first score column
118+  C4DE 5F               ld e,a
119+  C4DF 16 00            ld d,0
120+  C4E1 19               add hl,de
121+  C4E2 08               ex af,af'                   ; store a for later
122+  C4E3 11 49 C4         ld de,scores_current+2      ; position of current score column
123+  C4E6 06 06            ld b,6                      ; times to loop
124+  C4E8              scores_processhighscores0:
125+  C4E8 7E               ld a,(hl)
126+  C4E9 4F               ld c,a                      ; get first score column
127+  C4EA 1A               ld a,(de)                   ; get first current column
128+  C4EB B9               cp c                        ; compare current with first
129+  C4EC DA FD C4         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
130+  C4EF 23               inc hl
131+  C4F0 13               inc de                      ; move to next column
132+  C4F1 10 F5            djnz scores_processhighscores0 ; loop
133+  C4F3 08               ex af,af'                     ; still here, so must be bigger
134+  C4F4 32 D3 C4         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
135+  C4F7 0E 0C            ld c,12
136+  C4F9 91               sub c
137+  C4FA D2 DB C4         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
138+  C4FD              scores_processhighscores4
139+  C4FD CD 01 C5         call scores_updatehighscores
140+  C500 C9               ret
141+  C501
142+  C501              ;
143+  C501              ; Update score table
144+  C501              ;
145+  C501              scores_updatehighscores:
146+  C501 3A D3 C4         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
147+  C504 FE 00            cp 0
148+  C506 C8               ret z                       ; if this is 0, didn't get a high score
149+  C507 FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
150+  C509 CA 3C C5         jp z, scores_updatehighscores3
151+  C50C                                              ; copy old score over one below, if not first
152+  C50C 21 53 C4         ld hl,scores_table
153+  C50F 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
154+  C512 19               add hl,de                   ; position of first column
155+  C513 2B               dec hl
156+  C514 2B               dec hl
157+  C515 2B               dec hl
158+  C516 E5               push hl
159+  C517 11 0C 00         ld de,12
160+  C51A 19               add hl,de                   ; get position of next score
161+  C51B 54 5D            ld de,hl
162+  C51D E1               pop hl                      ; get hl back
163+  C51E 01 09 00         ld bc,9
164+  C521 ED B0            ldir
165+  C523 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
166+  C525 CA 3C C5         jp z,scores_updatehighscores3
167+  C528 21 53 C4         ld hl,scores_table
168+  C52B 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
169+  C52E 19               add hl,de                   ; position of first column
170+  C52F E5               push hl
171+  C530 11 0C 00         ld de,12
172+  C533 19               add hl,de                   ; get position of next score
173+  C534 54 5D            ld de,hl
174+  C536 E1               pop hl                      ; get hl back
175+  C537 01 09 00         ld bc,9
176+  C53A ED B0            ldir
177+  C53C              scores_updatehighscores3:
178+  C53C 06 06            ld b,6                      ; now overwrite
179+  C53E 21 53 C4         ld hl,scores_table
180+  C541 16 00            ld d,0
181+  C543 5F               ld e,a
182+  C544 19               add hl,de                   ; position of first column
183+  C545 08               ex af,af'
184+  C546 11 49 C4         ld de,scores_current+2      ; position of current score column
185+  C549              scores_updatehighscores2:
186+  C549 1A               ld a,(de)
187+  C54A 77               ld (hl),a
188+  C54B 23               inc hl
189+  C54C 13               inc de
190+  C54D 10 FA            djnz scores_updatehighscores2
191+  C54F 11 09 00         ld de,9
192+  C552 ED 52            sbc hl,de
193+  C554 54 5D            ld de,hl                    ; get back to start of entry
194+  C556 21 50 C4         ld hl,scores_defaultname    ; still need to overwrite the name
195+  C559 01 03 00         ld bc,3                      ; 3 chars to copy
196+  C55C ED B0            ldir
197+  C55E C9               ret
# file closed: game/scores.asm
 45   C55F                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  C55F              diamonds_tmp:
  2+  C55F 00               defb 0
  3+  C560
  4+  C560              diamonds_tmp2:
  5+  C560 00               defb 0
  6+  C561
  7+  C561              ;
  8+  C561              ; Holds the number of thousands for the current gem type
  9+  C561              ;
 10+  C561              diamonds_score:
 11+  C561 00               defb 0
 12+  C562
 13+  C562              ;
 14+  C562              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  C562              ; Inputs:
 16+  C562              ; hl - memory location of gem type
 17+  C562              diamonds_twinkle_type:
 18+  C562 CD 69 BD         call game_getcurrentframe       ; get current frame number
 19+  C565 E6 07            and 7                           ; want a number from 0-7
 20+  C567 C6 40            add 64                          ; add to 60 to get attr colour
 21+  C569 32 60 C5         ld (diamonds_tmp2),a             ; store the colour
 22+  C56C              diamonds_twinkle_type0:
 23+  C56C 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  C570 79               ld a,c                          ; load c into a
 25+  C571 FE FF            cp 255                          ; is this the end?
 26+  C573 CA 9B C5         jp z,diamonds_twinkle_type1           ; step out if so
 27+  C576 23               inc hl
 28+  C577 23               inc hl
 29+  C578 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  C579 FE 01            cp 1
 31+  C57B CA 9C C5         jp z,diamonds_twinkle_type2           ; step out if so
 32+  C57E CD DC C5         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  C581 DC A3 C5         call c,diamonds_collect     ; we collided
 34+  C584 23               inc hl
 35+  C585 E5               push hl
 36+  C586 E5 DD E1         ld ix,hl
 37+  C589 DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  C58D 46 FE
 38+  C58F 3A 60 C5         ld a,(diamonds_tmp2)
 39+  C592 CD B0 A9         call screen_setattr
 40+  C595 E1               pop hl
 41+  C596 23               inc hl
 42+  C597 23               inc hl                          ; move to next diamond
 43+  C598 C3 6C C5         jp diamonds_twinkle_type0
 44+  C59B              diamonds_twinkle_type1:
 45+  C59B C9               ret
 46+  C59C              diamonds_twinkle_type2:
 47+  C59C 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  C59D 23               inc hl
 49+  C59E 23               inc hl
 50+  C59F 08               ex af,af'
 51+  C5A0 C3 6C C5         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  C5A3
 53+  C5A3              ;
 54+  C5A3              ; Collect the diamond we collided with
 55+  C5A3              ; Inputs:
 56+  C5A3              ; hl - memory location of current diamond, currently on state
 57+  C5A3              ; Output:
 58+  C5A3              ; a - 70 - for yellow on black
 59+  C5A3              diamonds_collect:
 60+  C5A3 36 01            ld (hl),1                       ; collected
 61+  C5A5 E5               push hl
 62+  C5A6 2B               dec hl
 63+  C5A7 2B               dec hl
 64+  C5A8 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  C5AC CD 68 A9         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  C5AF ED 5B 5F C5      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  C5B3 16 00            ld d,0
 68+  C5B5 21 97 B5         ld hl,sprites
 69+  C5B8 19               add hl,de
 70+  C5B9 CD 2A AA         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  C5BC E1               pop hl
 72+  C5BD 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  C5BF 32 60 C5         ld (diamonds_tmp2),a
 74+  C5C2 D9               exx
 75+  C5C3 3A 61 C5         ld a,(diamonds_score)
 76+  C5C6 47               ld b,a
 77+  C5C7 CD 77 C4         call scores_addthousands
 78+  C5CA 3A 5F C5         ld a,(diamonds_tmp)
 79+  C5CD FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  C5CF C2 D7 C5         jp nz,diamonds_collect0
 81+  C5D2 21 87 BD         ld hl,player+13
 82+  C5D5 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  C5D7              diamonds_collect0:
 84+  C5D7 CD AB AF         call sound_gemcollected
 85+  C5DA D9               exx
 86+  C5DB C9               ret
 87+  C5DC
 88+  C5DC              ;
 89+  C5DC              ; Checks to see if the gem is hitting a player
 90+  C5DC              ; Inputs:
 91+  C5DC              ; bc - coords of diamond we're checking
 92+  C5DC              diamonds_checkforplayer:
 93+  C5DC 78               ld a,b               ; multiply b by 8
 94+  C5DD 07               rlca
 95+  C5DE 07               rlca
 96+  C5DF 07               rlca
 97+  C5E0 47               ld b,a
 98+  C5E1 ED 5B 7A BD      ld de,(player)       ; get the player coords
 99+  C5E5 7B               ld a,e               ; get the vert coord first
100+  C5E6 90               sub b                ; subtract the diamond vertical coord from players
101+  C5E7 C6 04            add 4                ; add the max distance
102+  C5E9 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  C5EB D0               ret nc               ; if not, hasn't hit
104+  C5EC 79               ld a,c               ; multiply c by 8
105+  C5ED 07               rlca
106+  C5EE 07               rlca
107+  C5EF 07               rlca
108+  C5F0 4F               ld c,a
109+  C5F1 7A               ld a,d               ; get the player horiz coord
110+  C5F2 91               sub c                ; subtract rock coord
111+  C5F3 C6 04            add 4                ; add max distance
112+  C5F5 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  C5F7 D0               ret nc
114+  C5F8 3E 00            ld a,0
115+  C5FA C9               ret
116+  C5FB
117+  C5FB
118+  C5FB              ;
119+  C5FB              ; Initialise diamonds and gems
120+  C5FB              ;
121+  C5FB              diamonds_twinkle
122+  C5FB 21 61 C5         ld hl,diamonds_score
123+  C5FE 36 02            ld (hl),2         ; store the score we'll add
124+  C600 21 5F C5         ld hl,diamonds_tmp
125+  C603 36 40            ld (hl),64         ; store the location the diamond sprite
126+  C605 21 12 B5         ld hl, level01diamonds
127+  C608 CD 62 C5         call diamonds_twinkle_type
128+  C60B 21 61 C5         ld hl,diamonds_score
129+  C60E 36 01            ld (hl),1         ; store the score we'll add
130+  C610 21 5F C5         ld hl,diamonds_tmp
131+  C613 36 70            ld (hl),112         ; store the location the gem sprite
132+  C615 21 22 B5         ld hl, level01gems
133+  C618 CD 62 C5         call diamonds_twinkle_type
134+  C61B C9               ret
135+  C61C
136+  C61C              ;
137+  C61C              ; Initialise diamonds and gems
138+  C61C              ;
139+  C61C              diamonds_init:
140+  C61C 21 12 B5         ld hl, level01diamonds
141+  C61F CD 29 C6         call diamonds_init_type
142+  C622 21 22 B5         ld hl, level01gems
143+  C625 CD 29 C6         call diamonds_init_type
144+  C628 C9               ret
145+  C629
146+  C629              ;
147+  C629              ; Initialise diamonds or gems, get memory addresses
148+  C629              ; Inputs:
149+  C629              ; hl - memory location
150+  C629              diamonds_init_type:
151+  C629 4E               ld c,(hl)                      ; get coords into c
152+  C62A 79               ld a,c                          ; load c into add
153+  C62B FE FF            cp 255                          ; is this the end?
154+  C62D CA 44 C6         jp z,diamonds_init_type1             ; step out if so
155+  C630 23               inc hl
156+  C631 46               ld b,(hl)                       ; get coords into b
157+  C632 E5               push hl
158+  C633 CD 19 A9         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  C636 E1               pop hl
160+  C637 23               inc hl                          ; move to state
161+  C638 36 00            ld (hl),0
162+  C63A 23               inc hl                          ; move to memory
163+  C63B 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  C63F 23               inc hl                          ; move to next diamond
165+  C640 23               inc hl
166+  C641 C3 29 C6         jp diamonds_init_type
167+  C644              diamonds_init_type1:
168+  C644 C9               ret
# file closed: game/diamonds.asm
 46   C645                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  C645              ;
  2+  C645              ; Controls when missiles fall
  3+  C645              ;
  4+  C645              missiles_count:
  5+  C645 00               defb 0
  6+  C646
  7+  C646              ;
  8+  C646              ; A structure of falling missiles
  9+  C646              ; Assume we'll never have more than 4 falling at any one time
 10+  C646              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  C646              ;
 12+  C646              missiles_falling:
 13+  C646 00 00 00         defb 0,0,0
 14+  C649 00 00 00         defb 0,0,0
 15+  C64C 00 00 00         defb 0,0,0
 16+  C64F 00 00 00         defb 0,0,0
 17+  C652
 18+  C652              ;
 19+  C652              ; The coords of the missile that killed us
 20+  C652              ;
 21+  C652              missiles_killermissile:
 22+  C652 00 00            defb 0,0
 23+  C654
 24+  C654              ;
 25+  C654              ; Zeroes the state of each missile
 26+  C654              ;
 27+  C654              missiles_init:
 28+  C654 06 0C            ld b,12
 29+  C656 DD 21 99 B4      ld ix,level01missiles
 30+  C65A              missiles_init0:
 31+  C65A DD 36 02 00      ld (ix+2),0               ; set the state to zero
 32+  C65E 11 05 00         ld de,5
 33+  C661 DD 19            add ix,de
 34+  C663 DD 36 02 00      ld (ix+2),0
 35+  C667 DD 19            add ix,de
 36+  C669 10 EF            djnz missiles_init0
 37+  C66B 06 04            ld b,4                  ; reset four falling missiles
 38+  C66D 21 46 C6         ld hl,missiles_falling
 39+  C670              missiles_init1:
 40+  C670 36 00            ld (hl),0
 41+  C672 23               inc hl
 42+  C673 36 00            ld (hl),0
 43+  C675 23               inc hl
 44+  C676 36 00            ld (hl),0
 45+  C678 23               inc hl
 46+  C679 10 F5            djnz missiles_init1
 47+  C67B C9               ret
 48+  C67C
 49+  C67C              ;
 50+  C67C              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 51+  C67C              ; Processes any already falling missiles
 52+  C67C              ;
 53+  C67C              missiles_process:
 54+  C67C 3A 85 BD         ld a,(player+11)                        ; check if the player was hit by a missile previously
 55+  C67F FE 03            cp 3
 56+  C681 C2 88 C6         jp nz,missiles_process3                 ; if not, continue
 57+  C684 CD C5 C7         call missiles_zonkplayer
 58+  C687 C9               ret
 59+  C688              missiles_process3:
 60+  C688 3A 89 BD         ld a,(player_location)
 61+  C68B FE 01            cp 1
 62+  C68D C2 FB C6         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 63+  C690 21 87 BD         ld hl,player+13
 64+  C693 7E               ld a,(hl)                               ; check if player has collected a diamond
 65+  C694 FE 01            cp 1
 66+  C696 C2 FB C6         jp nz, missiles_process0                ; don't activate if not
 67+  C699 21 45 C6         ld hl,missiles_count
 68+  C69C 7E               ld a,(hl)                   ; get the missiles count
 69+  C69D 3C               inc a
 70+  C69E FE 32            cp 50                                   ; have we reached the count yet
 71+  C6A0 CA A7 C6         jp z,missiles_process2                 ; if not, don't activate a new one
 72+  C6A3 77               ld (hl),a                               ; store the updated count, and continue without activating
 73+  C6A4 C3 FB C6         jp missiles_process0
 74+  C6A7              missiles_process2:
 75+  C6A7 36 00            ld (hl),0                               ; zero the counter
 76+  C6A9 1E 0C            ld e,12
 77+  C6AB CD ED 80         call utilities_randomupper              ; get random number from 0 to 11
 78+  C6AE 11 0A 00         ld de,10
 79+  C6B1 CD 3A 80         call utilities_multiply                 ; multiple random number by 10
 80+  C6B4 54 5D            ld de,hl                                ; this is the offset for the random missile
 81+  C6B6 DD 21 99 B4      ld ix,level01missiles                   ; load the location of the missile definitions
 82+  C6BA DD 19            add ix,de                               ; get to location of missile
 83+  C6BC DD 7E 02         ld a,(ix+2)
 84+  C6BF FE 00            cp 0
 85+  C6C1 CA D1 C6         jp z,missiles_process1                  ; if this missile isn't active, activate it
 86+  C6C4 11 05 00         ld de,5                                 ; otherwise, check the missile above
 87+  C6C7 DD 19            add ix,de
 88+  C6C9 DD 7E 02         ld a,(ix+2)
 89+  C6CC FE 00            cp 0
 90+  C6CE C2 FB C6         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 91+  C6D1              missiles_process1:                          ; activate a missile
 92+  C6D1 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
 93+  C6D5 DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
 93+  C6D9 46 01
 94+  C6DB 78               ld a,b
 95+  C6DC ED 5B 06 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
 96+  C6E0 93               sub e
 97+  C6E1 CD 68 A9         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
 98+  C6E4 C5               push bc
 99+  C6E5 3E 0C            ld a,12                                 ; inactive missile sprite
100+  C6E7 CD A5 A9         call screen_getblock
101+  C6EA CD 2A AA         call sprites_drawsprite                 ; draw the sprite over the old one
102+  C6ED C1               pop bc
103+  C6EE C5               push bc
104+  C6EF 3E 14            ld a,20                                 ; active missile sprite
105+  C6F1 CD A5 A9         call screen_getblock
106+  C6F4 CD 2A AA         call sprites_drawsprite                 ; draw the sprite over the old one
107+  C6F7 C1               pop bc
108+  C6F8 CD 89 C7         call missiles_addmissiletofalling
109+  C6FB              missiles_process0:
110+  C6FB CD FF C6         call missiles_fall
111+  C6FE C9               ret
112+  C6FF
113+  C6FF              ;
114+  C6FF              ; Processes falling missiles
115+  C6FF              ;
116+  C6FF              missiles_fall:
117+  C6FF 06 04            ld b,4              ; number of possible falling missiles
118+  C701 DD 21 46 C6      ld ix,missiles_falling
119+  C705              missiles_fall0:
120+  C705 C5               push bc
121+  C706 DD 7E 02         ld a,(ix+2)
122+  C709 FE 00            cp 0
123+  C70B CA 68 C7         jp z,missiles_fall1 ; not falling move to next
124+  C70E FE 01            cp 1                ; is this ready to fall
125+  C710 CA 16 C7         jp z, missiles_fall3
126+  C713 C3 82 C7         jp missiles_fall4   ; if not, decrease the countdown
127+  C716              missiles_fall3:
128+  C716 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
128+  C71A 46 01
129+  C71C CD 1F AB         call sprites_scadd  ; get the memory of the coords into de
130+  C71F 14               inc d               ; add 256 to get next row
131+  C720 1A               ld a,(de)           ; get the contents of the next row
132+  C721 FE 00            cp 0
133+  C723 C2 7B C7         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
134+  C726 3E 14            ld a,20                                 ; active missile sprite
135+  C728 CD A5 A9         call screen_getblock
136+  C72B CD 2A AA         call sprites_drawsprite                 ; draw the sprite over the old one
137+  C72E DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
137+  C732 46 01
138+  C734 0C               inc c               ; move down one pixel
139+  C735 DD 71 00 DD      ld (ix),bc          ; store the new coords
139+  C739 70 01
140+  C73B 3E 14            ld a,20                                 ; active missile sprite
141+  C73D CD A5 A9         call screen_getblock
142+  C740 CD 2A AA         call sprites_drawsprite                 ; draw the sprite
143+  C743 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
143+  C747 46 01
144+  C749 79               ld a,c              ; get the vertical coord into a
145+  C74A E6 07            and 7               ; divisible by 8?
146+  C74C FE 00            cp 0
147+  C74E C2 68 C7         jp nz,missiles_fall1   ; if not, carry on
148+  C751 CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
149+  C754 3E 43            ld a,67             ; load magenta
150+  C756 CD B0 A9         call screen_setattr
151+  C759 DD 4E 00 DD      ld bc,(ix)
151+  C75D 46 01
152+  C75F CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the attr address into de
153+  C762 05               dec b               ; look one square above
154+  C763 3E 46            ld a,70             ; load yellow
155+  C765 CD B0 A9         call screen_setattr
156+  C768              missiles_fall1:         ; hl at state
157+  C768 DD 4E 00 DD      ld bc,(ix)          ; get coords back
157+  C76C 46 01
158+  C76E CD AA C7         call missiles_checkforplayer ; check for player
159+  C771 DD 23            inc ix
160+  C773 DD 23            inc ix
161+  C775 DD 23            inc ix              ; get to next missile
162+  C777 C1               pop bc
163+  C778 10 8B            djnz missiles_fall0
164+  C77A C9               ret
165+  C77B              missiles_fall2:
166+  C77B DD 36 02 00      ld (ix+2),0
167+  C77F C3 68 C7         jp missiles_fall1   ; rejoin the loop
168+  C782              missiles_fall4:
169+  C782 3D               dec a               ; decrease the countdown
170+  C783 DD 77 02         ld (ix+2),a         ; store back
171+  C786 C3 68 C7         jp missiles_fall1   ; do next missile
172+  C789
173+  C789              ;
174+  C789              ; Adds the missile to the structure that tracks falling missile
175+  C789              ; Inputs:
176+  C789              ; bc - coords of missile, c vert
177+  C789              missiles_addmissiletofalling:
178+  C789 C5               push bc             ; store the coords
179+  C78A 11 46 C6         ld de,missiles_falling
180+  C78D 06 04            ld b,4              ; number of possible falling missiles
181+  C78F              missiles_addmissiletofalling0:
182+  C78F 13               inc de
183+  C790 13               inc de              ; move three along to get the state
184+  C791 1A               ld a,(de)           ; load the state
185+  C792 FE 00            cp 0                ; check if this is not falling
186+  C794 C2 A5 C7         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
187+  C797 3E 19            ld a,25
188+  C799 12               ld (de),a           ; set the state to pre-falling
189+  C79A 1B               dec de              ; move back coords
190+  C79B C1               pop bc              ; get back coords
191+  C79C 78               ld a,b
192+  C79D 12               ld (de),a           ; store the vertical
193+  C79E 1B               dec de
194+  C79F 79               ld a,c
195+  C7A0 12               ld (de),a           ; store the horizontal
196+  C7A1 C5               push bc
197+  C7A2 C3 A8 C7         jp missiles_addmissiletofalling2 ; done
198+  C7A5              missiles_addmissiletofalling1:
199+  C7A5 13               inc de              ; move memory along to next rock
200+  C7A6 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
201+  C7A8              missiles_addmissiletofalling2: ; done, return
202+  C7A8 C1               pop bc              ; to tidy up
203+  C7A9 C9               ret
204+  C7AA
205+  C7AA              ;
206+  C7AA              ; Checks to see if the missile is hitting a player
207+  C7AA              ; Inputs:
208+  C7AA              ; bc - coords of missile we're checking
209+  C7AA              missiles_checkforplayer:
210+  C7AA ED 5B 7A BD      ld de,(player)       ; get the player coords
211+  C7AE 7B               ld a,e               ; get the vert coord first
212+  C7AF 91               sub c                ; subtract the missile vertical coord from players
213+  C7B0 FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
214+  C7B2 C0               ret nz               ; if not, hasn't hit
215+  C7B3 7A               ld a,d               ; get the player horiz coord
216+  C7B4 90               sub b                ; subtract missile coord
217+  C7B5 C6 07            add 7                ; add max distance
218+  C7B7 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
219+  C7B9 DA BD C7         jp c,missiles_checkforplayer0
220+  C7BC C9               ret
221+  C7BD              missiles_checkforplayer0:
222+  C7BD ED 43 52 C6      ld (missiles_killermissile),bc; store the coords of the killer missile
223+  C7C1 CD 97 BE         call player_zonkplayer ; if so, jump out
224+  C7C4 C9               ret
225+  C7C5
226+  C7C5              ;
227+  C7C5              ; Player has been hit, so draw text over them and mark as dead
228+  C7C5              ;
229+  C7C5              missiles_zonkplayer:
230+  C7C5 CD 85 BE         call player_killplayer      ; mark as dead
231+  C7C8 ED 4B 7A BD      ld bc,(player)              ; get player coords
232+  C7CC CD 58 A9         call screen_getcharcoordsfromscreencoords
233+  C7CF 0D               dec c
234+  C7D0 0D               dec c
235+  C7D1 04               inc b
236+  C7D2 C5               push bc
237+  C7D3 3E 42            ld a,66
238+  C7D5 CD B0 A9         call screen_setattr
239+  C7D8 0C               inc c
240+  C7D9 CD B0 A9         call screen_setattr
241+  C7DC 0C               inc c
242+  C7DD CD B0 A9         call screen_setattr
243+  C7E0 0C               inc c
244+  C7E1 CD B0 A9         call screen_setattr
245+  C7E4 0C               inc c
246+  C7E5 CD B0 A9         call screen_setattr
247+  C7E8 C1               pop bc
248+  C7E9 ED 5B 06 A8      ld de,(screen_offset)
249+  C7ED 78               ld a,b
250+  C7EE 93               sub e
251+  C7EF 47               ld b,a                      ; subtract the offset
252+  C7F0 04               inc b
253+  C7F1 04               inc b                       ; add two for the score rows
254+  C7F2 ED 43 CD 84      ld (string_zonk),bc         ; set coords of string
255+  C7F6 21 CD 84         ld hl,string_zonk
256+  C7F9 CD 54 85         call string_print
257+  C7FC 06 14            ld b,20
258+  C7FE CD 99 80         call utilities_pauseforframes ; pause
259+  C801 C9               ret
260+  C802
# file closed: game/missiles.asm
 47   C802                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  C802              ;
  2+  C802              ; Timer for deciding how fast the trap withdraws
  3+  C802              ;
  4+  C802              thepit_timer:
  5+  C802 00               defb 0
  6+  C803
  7+  C803              ;
  8+  C803              ; Ticks for the trap state. Will count to 3 then reset
  9+  C803              ;
 10+  C803              thepit_trapcount:
 11+  C803 00               defb 0
 12+  C804
 13+  C804              ;
 14+  C804              ; The horizontal coordinate of the current pit trap
 15+  C804              ;
 16+  C804              thepit_trapcoord:
 17+  C804 08               defb 8
 18+  C805
 19+  C805              ;
 20+  C805              ; Initialises the pit
 21+  C805              ;
 22+  C805              thepit_init:
 23+  C805 21 04 C8         ld hl,thepit_trapcoord
 24+  C808 36 08            ld (hl),8
 25+  C80A 21 03 C8         ld hl,thepit_trapcount
 26+  C80D 36 00            ld (hl),0
 27+  C80F C9               ret
 28+  C810
 29+  C810              ;
 30+  C810              ; Performs per frame processing on the pit room
 31+  C810              ;
 32+  C810              thepit_process:
 33+  C810 3A 89 BD         ld a,(player_location)
 34+  C813 FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 35+  C815 C2 71 C8         jp nz,thepit_process0
 36+  C818 ED 4B 7A BD      ld bc,(player)                  ; get the player's coords to check if about to fall
 37+  C81C 3E 08            ld a,8
 38+  C81E 81               add a,c
 39+  C81F 4F               ld c,a                          ; look at the square underneath
 40+  C820 CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the cell coords
 41+  C823 CD E6 A9         call screen_ischarempty
 42+  C826 FE 01            cp 1                            ; check if this is 1=empty
 43+  C828 CA 72 C8         jp z,thepit_process2
 44+  C82B 3A 02 C8         ld a,(thepit_timer)             ; get the timer
 45+  C82E 3C               inc a
 46+  C82F 32 02 C8         ld (thepit_timer),a             ; store
 47+  C832 FE 02            cp 2                           ; have we reached the trigger?
 48+  C834 C2 71 C8         jp nz, thepit_process0          ; no need to do anything
 49+  C837 3E 00            ld a,0
 50+  C839 32 02 C8         ld (thepit_timer),a             ; zero the timer and process
 51+  C83C 3A 03 C8         ld a,(thepit_trapcount)         ; get the current count
 52+  C83F 3C               inc a
 53+  C840 32 03 C8         ld (thepit_trapcount),a         ; reset the trap count
 54+  C843 FE 04            cp 4                            ; do we need to begin another character?
 55+  C845 C2 59 C8         jp nz,thepit_process1           ; if not, draw as normal
 56+  C848 3E 00            ld a,0
 57+  C84A 32 03 C8         ld (thepit_trapcount),a         ; reset the trap count
 58+  C84D 3A 04 C8         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 59+  C850 FE 02            cp 2
 60+  C852 CA 71 C8         jp z,thepit_process0
 61+  C855 3D               dec a
 62+  C856 32 04 C8         ld (thepit_trapcoord),a         ; store the reduced coord
 63+  C859
 64+  C859              thepit_process1:                    ; draw the trapdoor in current position
 65+  C859 3A 04 C8         ld a,(thepit_trapcoord)
 66+  C85C FE 02            cp 2
 67+  C85E CA 71 C8         jp z, thepit_process0           ; don't process outside of the pit
 68+  C861 4F               ld c,a
 69+  C862 06 0A            ld b,10                         ; vertical coord will always be the same
 70+  C864 3A 03 C8         ld a,(thepit_trapcount)         ; get the trap count
 71+  C867 5F               ld e,a                          ; store in e
 72+  C868 3E 16            ld a,22                         ; 21 is full trapdoor
 73+  C86A 83               add a,e
 74+  C86B CD A5 A9         call screen_getblock
 75+  C86E CD 82 A9         call screen_showchar            ; show the char
 76+  C871
 77+  C871              thepit_process0:
 78+  C871 C9               ret
 79+  C872              thepit_process2:
 80+  C872 CD 9D BE         call player_pitkillplayer
 81+  C875 C9               ret
 82+  C876
# file closed: game/thepit.asm
 48   C876                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  C876
  2+  C876              ;
  3+  C876              ; Where the monster currently is
  4+  C876              ;
  5+  C876              monster_currentcoords:
  6+  C876 00 00            defb 0,0
  7+  C878
  8+  C878              ;
  9+  C878              ; The start coords of the monster
 10+  C878              ;
 11+  C878              monster_initcoords:
 12+  C878 70 1B            defb 112,27
 13+  C87A
 14+  C87A              ;
 15+  C87A              ; Store the memory location of the current jump position
 16+  C87A              ;
 17+  C87A              monster_jumppos:
 18+  C87A 00 00            defb 0,0
 19+  C87C
 20+  C87C              ;
 21+  C87C              ; The jump table for the monster.
 22+  C87C              ;
 23+  C87C              monster_jumptable:
 24+  C87C FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  C880 02 02 02 02
 24+  C884 02 02 01 01
 24+  C888 01 01 01 01
 24+  C88C FF
 25+  C88D
 26+  C88D              ;
 27+  C88D              ; The vertical direction: 0 up, 1 down
 28+  C88D              ;
 29+  C88D              monster_jumpdirectionvert:
 30+  C88D 00               defb 0
 31+  C88E
 32+  C88E              ;
 33+  C88E              ; The horiz direction: 0 right, 1 left
 34+  C88E              ;
 35+  C88E              monster_jumpdirectionhoriz:
 36+  C88E 00               defb 0
 37+  C88F
 38+  C88F              ;
 39+  C88F              ; Frame offset, 0 or 32
 40+  C88F              ;
 41+  C88F              monster_frameoffset:
 42+  C88F 00               defb 0
 43+  C890
 44+  C890              ;
 45+  C890              ; Monster tick
 46+  C890              ;
 47+  C890              monster_tick:
 48+  C890 00               defb 0
 49+  C891
 50+  C891              ;
 51+  C891              ; Initialises the pit monster
 52+  C891              ;
 53+  C891              monster_init:
 54+  C891 ED 4B 78 C8      ld bc,(monster_initcoords)              ; load the initial coords
 55+  C895 ED 43 76 C8      ld (monster_currentcoords),bc           ; save in current coords
 56+  C899 21 7D C8         ld hl,monster_jumptable+1
 57+  C89C 22 7A C8         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 58+  C89F 3E 00            ld a,0
 59+  C8A1 32 8D C8         ld (monster_jumpdirectionvert),a        ; going up
 60+  C8A4 32 8F C8         ld (monster_frameoffset),a
 61+  C8A7 32 90 C8         ld (monster_tick),a
 62+  C8AA CD 2A C9         call monster_draw                       ; the monster
 63+  C8AD C9               ret
 64+  C8AE
 65+  C8AE              ;
 66+  C8AE              ; Animate the monster
 67+  C8AE              ;
 68+  C8AE              monster_process:
 69+  C8AE 3A 90 C8         ld a,(monster_tick)                     ; check if we should draw this frame
 70+  C8B1 FE 01            cp 1
 71+  C8B3 CA BB C8         jp z,monster_process6
 72+  C8B6 3C               inc a
 73+  C8B7 32 90 C8         ld (monster_tick),a                     ; increase the tick and continue
 74+  C8BA C9               ret
 75+  C8BB              monster_process6:
 76+  C8BB 3E 00            ld a,0
 77+  C8BD 32 90 C8         ld (monster_tick),a                     ; zero the tick
 78+  C8C0 CD 2A C9         call monster_draw                       ; overwrite the old sprite
 79+  C8C3 3A 8F C8         ld a,(monster_frameoffset)              ; get the anim frame offset
 80+  C8C6 EE 20            xor 32                                  ; flip between 0 and 32
 81+  C8C8 32 8F C8         ld (monster_frameoffset),a              ; store
 82+  C8CB ED 4B 76 C8      ld bc,(monster_currentcoords)           ; get the current coords
 83+  C8CF 2A 7A C8         ld hl,(monster_jumppos)                 ; get the position in the jump table
 84+  C8D2 56               ld d,(hl)                               ; get the jump modifier
 85+  C8D3 3A 8D C8         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 86+  C8D6 FE 00            cp 0                                    ; if 0, going up, so dec vert
 87+  C8D8 C2 E1 C8         jp nz,monster_process0
 88+  C8DB 79               ld a,c
 89+  C8DC 92               sub d
 90+  C8DD 23               inc hl                                  ; move forward a jump pos
 91+  C8DE C3 E4 C8         jp monster_process1
 92+  C8E1              monster_process0:
 93+  C8E1 79               ld a,c                                   ; going down so inc c
 94+  C8E2 82               add a,d
 95+  C8E3 2B               dec hl                                  ; move back a jump pos
 96+  C8E4              monster_process1:
 97+  C8E4 4F               ld c,a                                  ; get the vertical coord back
 98+  C8E5 7E               ld a,(hl)                               ; check the next jump pos
 99+  C8E6 FE FF            cp 255                                  ; if 255 reverse
100+  C8E8 CA F1 C8         jp z,monster_process3
101+  C8EB 22 7A C8         ld (monster_jumppos),hl                 ; store the new pos
102+  C8EE C3 F9 C8         jp monster_process2                     ; keep going
103+  C8F1              monster_process3:
104+  C8F1 3A 8D C8         ld a,(monster_jumpdirectionvert)        ; get the direction
105+  C8F4 EE 01            xor 1                                   ; flip it
106+  C8F6 32 8D C8         ld (monster_jumpdirectionvert),a        ; store it
107+  C8F9              monster_process2:
108+  C8F9 3A 8E C8         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
109+  C8FC FE 00            cp 0                                    ; is it right?
110+  C8FE C2 13 C9         jp nz,monster_process4
111+  C901 04               inc b                                   ; 1 pixel right
112+  C902 78               ld a,b
113+  C903 FE 38            cp 56                                   ; reached the edge of the pit?
114+  C905 C2 22 C9         jp nz,monster_process5
115+  C908 3A 8E C8         ld a,(monster_jumpdirectionhoriz)
116+  C90B EE 01            xor 1
117+  C90D 32 8E C8         ld (monster_jumpdirectionhoriz),a       ; flip direction
118+  C910 C3 22 C9         jp monster_process5
119+  C913              monster_process4:
120+  C913 05               dec b                                   ; 1 pixel left
121+  C914 78               ld a,b
122+  C915 FE 18            cp 24                                   ; reached the edge of the pit?
123+  C917 C2 22 C9         jp nz,monster_process5
124+  C91A 3A 8E C8         ld a,(monster_jumpdirectionhoriz)
125+  C91D EE 01            xor 1
126+  C91F 32 8E C8         ld (monster_jumpdirectionhoriz),a       ; flip direction
127+  C922              monster_process5:
128+  C922 ED 43 76 C8      ld (monster_currentcoords),bc           ; store the new vertical coords
129+  C926 CD 2A C9         call monster_draw                       ; finally, draw the monster
130+  C929 C9               ret
131+  C92A
132+  C92A              ;
133+  C92A              ; Draw the monster at the current location
134+  C92A              ;
135+  C92A              monster_draw:
136+  C92A ED 4B 76 C8      ld bc,(monster_currentcoords)
137+  C92E 3A 8F C8         ld a,(monster_frameoffset)
138+  C931 11 00 00         ld de,0
139+  C934 5F               ld e,a
140+  C935 21 AB B7         ld hl,monster_sprite                    ; load the first frame
141+  C938 19               add hl,de
142+  C939 CD 88 AA         call sprites_draw2by2sprite
143+  C93C C9               ret
# file closed: game/monster.asm
 49   C93D                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  C93D
  2+  C93D              ;
  3+  C93D              ; Array of robot states
  4+  C93D              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  C93D              robots_robots:
  6+  C93D 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  C941 00 00 00
  7+  C944 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  C948 00 00 00
  8+  C94B 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  C94F 00 00 00
  9+  C952 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  C956 00 00 00
 10+  C959 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  C95D 00 00 00
 11+  C960
 12+  C960              robots_initcoords:
 13+  C960 18 E8            defb 24,232
 14+  C962
 15+  C962              ;
 16+  C962              ; When this reaches zero, spawn a new robot
 17+  C962              ;
 18+  C962              robots_spawntimer:
 19+  C962 FA               defb 250
 20+  C963
 21+  C963              ;
 22+  C963              ; When this reaches max, change the anim frame
 23+  C963              ;
 24+  C963              robots_animtimer:
 25+  C963 00               defb 0
 26+  C964
 27+  C964              ;
 28+  C964              ; When this reaches max, change move the robot
 29+  C964              ;
 30+  C964              robots_movetimer:
 31+  C964 00               defb 0
 32+  C965
 33+  C965
 34+  C965              ;
 35+  C965              ; The number of robots active
 36+  C965              ;
 37+  C965              robots_numberactive:
 38+  C965 00               defb 0
 39+  C966
 40+  C966              ;
 41+  C966              ; Tracks which directions a robot can move
 42+  C966              ; up,down,left,right
 43+  C966              robots_canmovedirections:
 44+  C966 00 00 00 00      defb 0,0,0,0
 45+  C96A
 46+  C96A              ;
 47+  C96A              ; The current robot speed
 48+  C96A              ;
 49+  C96A              robots_robotspeed:
 50+  C96A 02               defb 2
 51+  C96B
 52+  C96B              ;
 53+  C96B              ; The current max robots
 54+  C96B              ;
 55+  C96B              robots_robotsmax:
 56+  C96B 02               defb 2
 57+  C96C
 58+  C96C              ;
 59+  C96C              ; Initialises the robots
 60+  C96C              ;
 61+  C96C              robots_init:
 62+  C96C 06 23            ld b,35
 63+  C96E DD 21 3D C9      ld ix,robots_robots
 64+  C972              robots_init0:
 65+  C972 DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 66+  C976 DD 23            inc ix
 67+  C978 10 F8            djnz robots_init0
 68+  C97A 3E 00            ld a,0
 69+  C97C 32 65 C9         ld (robots_numberactive),a
 70+  C97F 3E FA            ld a,250
 71+  C981 32 62 C9         ld (robots_spawntimer),a
 72+  C984                  ; Self writing code
 73+  C984                  ; Robot speed
 74+  C984 3A 6A C9         ld a,(robots_robotspeed)
 75+  C987 32 21 CA         ld (robots_process7+1),a
 76+  C98A 3C               inc a
 77+  C98B 32 51 CA         ld (robots_process6+1),a
 78+  C98E                  ; Robots max
 79+  C98E 3A 6B C9         ld a,(robots_robotsmax)
 80+  C991 32 9C C9         ld (robots_spawn+1),a
 81+  C994 32 F3 C9         ld (robots_process8+1),a
 82+  C997 32 0F CA         ld (robots_process0+1),a
 83+  C99A C9               ret
 84+  C99B
 85+  C99B              ;
 86+  C99B              ; Spawns a new robot
 87+  C99B              ; Inputs:
 88+  C99B              ; ix - pointer to start of robot array entry
 89+  C99B              ;
 90+  C99B              robots_spawn:
 91+  C99B 06 03            ld b,3                      ;(SELF WRITING CODE)
 92+  C99D DD 21 3D C9      ld ix,robots_robots
 93+  C9A1              robots_spawn0:
 94+  C9A1 DD 7E 02         ld a,(ix+2)                 ; get the state
 95+  C9A4 FE 00            cp 0
 96+  C9A6 C2 D2 C9         jp nz,robots_spawn1         ; if already active, move on
 97+  C9A9 ED 4B 60 C9      ld bc,(robots_initcoords)
 98+  C9AD DD 71 00 DD      ld (ix),bc
 98+  C9B1 70 01
 99+  C9B3 DD 36 02 01      ld (ix+2),1
100+  C9B7 DD 36 03 00      ld (ix+3),0
101+  C9BB DD 36 04 00      ld (ix+4),0
102+  C9BF DD 36 05 00      ld (ix+5),0
103+  C9C3 DD 36 06 00      ld (ix+6),0
104+  C9C7 3A 65 C9         ld a,(robots_numberactive)
105+  C9CA 3C               inc a
106+  C9CB 32 65 C9         ld (robots_numberactive),a  ; increase the number active
107+  C9CE CD 85 CC         call robots_draw            ; draw initial frame
108+  C9D1 C9               ret
109+  C9D2              robots_spawn1:
110+  C9D2 11 07 00         ld de,7
111+  C9D5 DD 19            add ix,de
112+  C9D7 10 C8            djnz robots_spawn0
113+  C9D9 C9               ret
114+  C9DA              ;
115+  C9DA              ; Kills robot
116+  C9DA              ; Inputs:
117+  C9DA              ; ix - pointer to start of robot array entry
118+  C9DA              ;
119+  C9DA              robots_kill:
120+  C9DA 3A 65 C9         ld a,(robots_numberactive)
121+  C9DD 3D               dec a
122+  C9DE 32 65 C9         ld (robots_numberactive),a
123+  C9E1 DD 36 02 00      ld (ix+2),0                     ; set to inactive
124+  C9E5 C5               push bc
125+  C9E6 E5               push hl
126+  C9E7 06 01            ld b,1
127+  C9E9 CD 7E C4         call scores_addhundreds
128+  C9EC E1               pop hl
129+  C9ED C1               pop bc
130+  C9EE C9               ret
131+  C9EF
132+  C9EF              ;
133+  C9EF              ; Processes the robots
134+  C9EF              ;
135+  C9EF              robots_process:
136+  C9EF 3A 65 C9         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
137+  C9F2              robots_process8:
138+  C9F2 FE 03            cp 3                                    ; 3 is the maximum
139+  C9F4 CA 0E CA         jp z,robots_process0                    ; if already three, nothing to do
140+  C9F7 3A 62 C9         ld a,(robots_spawntimer)                ; now check the spawn timer
141+  C9FA FE 00            cp 0
142+  C9FC C2 0A CA         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
143+  C9FF 3E FA            ld a,250
144+  CA01 32 62 C9         ld (robots_spawntimer),a                ; reset the spawn timer
145+  CA04 CD 9B C9         call robots_spawn                       ; spawn a robot
146+  CA07 C3 0E CA         jp robots_process0                      ; carry on
147+  CA0A              robots_process1:
148+  CA0A 3D               dec a
149+  CA0B 32 62 C9         ld (robots_spawntimer),a                ; decrease the spawn timer and store
150+  CA0E              robots_process0:
151+  CA0E 06 03            ld b,3                                  ; max number of robots (SELF WRITING CODE)
152+  CA10 DD 21 3D C9      ld ix, robots_robots                    ; point ix at the robot array
153+  CA14              robots_process2:
154+  CA14 C5               push bc
155+  CA15 DD 7E 02         ld a,(ix+2)                             ; check the state
156+  CA18 FE 00            cp 0
157+  CA1A CA 36 CA         jp z,robots_process3                    ; if not active, move on
158+  CA1D 3A 64 C9         ld a,(robots_movetimer)
159+  CA20              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
160+  CA20 FE 04            cp 4
161+  CA22 C2 36 CA         jp nz,robots_process3                   ; can we move this frame
162+  CA25 CD 85 CC         call robots_draw                        ; draw over existing
163+  CA28 CD 5B CA         call robots_move                        ; move the
164+  CA2B DD 7E 02         ld a,(ix+2)                             ; get the state again
165+  CA2E FE 00            cp 0
166+  CA30 CA 36 CA         jp z,robots_process3                    ; move to next if this robot has become inactive
167+  CA33 CD 85 CC         call robots_draw                        ; draw the new robot
168+  CA36              robots_process3:
169+  CA36 C1               pop bc
170+  CA37 11 07 00         ld de,7
171+  CA3A DD 19            add ix,de
172+  CA3C 10 D6            djnz robots_process2
173+  CA3E 3A 63 C9         ld a,(robots_animtimer)
174+  CA41 3C               inc a
175+  CA42 FE 08            cp 8
176+  CA44 C2 49 CA         jp nz,robots_process4
177+  CA47 3E 00            ld a,0                                  ; reset if we reached max
178+  CA49              robots_process4:
179+  CA49 32 63 C9         ld (robots_animtimer),a
180+  CA4C 3A 64 C9         ld a,(robots_movetimer)                 ; increment the robot move timer
181+  CA4F 3C               inc a
182+  CA50              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
183+  CA50 FE 05            cp 5                                    ; there is another reference to this number above
184+  CA52 C2 57 CA         jp nz,robots_process5
185+  CA55 3E 00            ld a,0
186+  CA57              robots_process5:
187+  CA57 32 64 C9         ld (robots_movetimer),a
188+  CA5A
189+  CA5A C9               ret
190+  CA5B
191+  CA5B
192+  CA5B              ;
193+  CA5B              ; Moves a robot
194+  CA5B              ; Inputs:
195+  CA5B              ; ix - points to first byte of robot in array
196+  CA5B              robots_move:
197+  CA5B DD 7E 02         ld a,(ix+2)                             ; get the state
198+  CA5E FE 02            cp 2
199+  CA60 CA 91 CA         jp z,robots_move4                       ; don't move if shot, just change the anim
200+  CA63 3A 63 C9         ld a,(robots_animtimer)                 ; get the anim timer
201+  CA66 FE 07            cp 7                                    ; compare with 8
202+  CA68 C2 7B CA         jp nz,robots_move1                       ; if even, don't increment frame
203+  CA6B DD 7E 04         ld a,(ix+4)                             ; get the anim frame
204+  CA6E 06 08            ld b,8
205+  CA70 80               add a,b                                 ; add to anim frame
206+  CA71 FE 20            cp 32
207+  CA73 C2 78 CA         jp nz,robots_move0                      ; if not 32, then just store
208+  CA76 3E 00            ld a,0                                  ; otherwise, reset
209+  CA78              robots_move0:
210+  CA78 DD 77 04         ld (ix+4),a                             ; store
211+  CA7B              robots_move1:
212+  CA7B DD 7E 05         ld a,(ix+5)
213+  CA7E FE 00            cp 0                                    ; are we automoving
214+  CA80 CA 89 CA         jp z,robots_move2                       ; if not, keep directions
215+  CA83 CD A5 CA         call robots_automove
216+  CA86 C3 8D CA         jp robots_move3
217+  CA89              robots_move2:
218+  CA89 CD D8 CA         call robots_checkdirectionsandmove
219+  CA8C C9               ret
220+  CA8D              robots_move3:
221+  CA8D CD CE CC         call robots_checkforplayer              ; check to see if we collided with a player
222+  CA90 C9               ret
223+  CA91              robots_move4:
224+  CA91 DD 7E 04         ld a,(ix+4)
225+  CA94 FE 48            cp 72
226+  CA96 C2 9F CA         jp nz,robots_move5
227+  CA99 3E 40            ld a,64
228+  CA9B DD 77 04         ld (ix+4),a
229+  CA9E C9               ret
230+  CA9F              robots_move5:
231+  CA9F 3E 48            ld a,72
232+  CAA1 DD 77 04         ld (ix+4),a
233+  CAA4 C9               ret
234+  CAA5
235+  CAA5
236+  CAA5              ;
237+  CAA5              ; Processes automove
238+  CAA5              ; Inputs:
239+  CAA5              ; ix - points to the current robot
240+  CAA5              ; a - number of frames left to move
241+  CAA5              robots_automove:
242+  CAA5 3D               dec a
243+  CAA6 DD 77 05         ld (ix+5),a                         ; store the decreased frames
244+  CAA9 DD 4E 00 DD      ld bc,(ix)                          ; get coords
244+  CAAD 46 01
245+  CAAF DD 7E 06         ld a,(ix+6)                         ; get the direction
246+  CAB2 FE 00            cp 0                                ; left
247+  CAB4 CA C5 CA         jp z,robots_automove1
248+  CAB7 FE 02            cp 2                                ; up
249+  CAB9 CA C9 CA         jp z,robots_automove3
250+  CABC FE 03            cp 3                                ; down
251+  CABE CA CD CA         jp z,robots_automove4
252+  CAC1 04               inc b                               ; right
253+  CAC2 C3 D1 CA         jp robots_automove2
254+  CAC5              robots_automove1:
255+  CAC5 05               dec b
256+  CAC6 C3 D1 CA         jp robots_automove2
257+  CAC9              robots_automove3:
258+  CAC9 0D               dec c
259+  CACA C3 D1 CA         jp robots_automove2
260+  CACD              robots_automove4:
261+  CACD 0C               inc c
262+  CACE C3 D1 CA         jp robots_automove2
263+  CAD1              robots_automove2:
264+  CAD1 DD 71 00 DD      ld (ix),bc
264+  CAD5 70 01
265+  CAD7 C9               ret
266+  CAD8
267+  CAD8              ;
268+  CAD8              ; Checks if a robot can move in all directions, then picks one and moves there.
269+  CAD8              ; This looks complicated, but really what it does is:
270+  CAD8              ; 1) Look at the current direction
271+  CAD8              ; 2) Randomly determine which orthoganal direction check first
272+  CAD8              ; 3) If orthogonal can't be moved, keep going in direction we're going
273+  CAD8              ; 4) Otherwise, back the way we came
274+  CAD8              ; Inputs:
275+  CAD8              ; ix - points to the current robot
276+  CAD8              ;
277+  CAD8              robots_checkdirectionsandmove:
278+  CAD8 DD 7E 06         ld a,(ix+6)                 ; get the direction
279+  CADB FE 00            cp 0                        ; left
280+  CADD C2 04 CB         jp nz,robots_checkdirectionsandmove0
281+  CAE0                  ; random check
282+  CAE0 CD 69 BD         call game_getcurrentframe
283+  CAE3 E6 01            and 1                       ; odd or even
284+  CAE5 CA F1 CA         jp z,robots_checkdirectionsandmove3
285+  CAE8 CD 8A CB         call robots_checkupthendown ; prefer up over down
286+  CAEB FE 01            cp 1
287+  CAED C8               ret z
288+  CAEE C3 F7 CA         jp robots_checkdirectionsandmove4
289+  CAF1              robots_checkdirectionsandmove3:
290+  CAF1 CD 80 CB         call robots_checkdownthenup ; prefer down over up
291+  CAF4 FE 01            cp 1
292+  CAF6 C8               ret z
293+  CAF7              robots_checkdirectionsandmove4:
294+  CAF7                  ; check left
295+  CAF7 CD 0E CC         call robots_checkleftandmove
296+  CAFA FE 01            cp 1
297+  CAFC C8               ret z                       ; if we moved, don't check again
298+  CAFD                  ; check right
299+  CAFD CD 47 CC         call robots_checkrightandmove
300+  CB00 FE 01            cp 1
301+  CB02 C8               ret z                       ; if we moved, don't check again
302+  CB03                  ; if we're here and haven't moved...
303+  CB03 C9               ret
304+  CB04              robots_checkdirectionsandmove0
305+  CB04 FE 01            cp 1                        ; right
306+  CB06 C2 2D CB         jp nz,robots_checkdirectionsandmove1
307+  CB09                  ; ALREADY MOVING RIGHT
308+  CB09                  ; random check
309+  CB09 CD 69 BD         call game_getcurrentframe
310+  CB0C E6 01            and 1                       ; odd or even
311+  CB0E CA 1A CB         jp z,robots_checkdirectionsandmove5
312+  CB11 CD 80 CB         call robots_checkdownthenup ; prefer down over up
313+  CB14 FE 01            cp 1
314+  CB16 C8               ret z
315+  CB17 C3 20 CB         jp robots_checkdirectionsandmove6
316+  CB1A              robots_checkdirectionsandmove5:
317+  CB1A CD 8A CB         call robots_checkupthendown ; prefer down over up
318+  CB1D FE 01            cp 1
319+  CB1F C8               ret z
320+  CB20              robots_checkdirectionsandmove6:
321+  CB20                  ; check right
322+  CB20 CD 47 CC         call robots_checkrightandmove
323+  CB23 FE 01            cp 1
324+  CB25 C8               ret z                       ; if we moved, don't check again
325+  CB26                  ; check left
326+  CB26 CD 0E CC         call robots_checkleftandmove
327+  CB29 FE 01            cp 1
328+  CB2B C8               ret z                       ; if we moved, don't check again
329+  CB2C                  ; if we're here and haven't moved...
330+  CB2C C9               ret
331+  CB2D              robots_checkdirectionsandmove1
332+  CB2D FE 02            cp 2                        ; up
333+  CB2F C2 56 CB         jp nz,robots_checkdirectionsandmove2
334+  CB32                  ; ALREADY MOVING UP
335+  CB32                  ; random check
336+  CB32 CD 69 BD         call game_getcurrentframe
337+  CB35 E6 01            and 1                       ; odd or even
338+  CB37 CA 43 CB         jp z,robots_checkdirectionsandmove7
339+  CB3A CD A0 CB         call robots_checkleftthenright ; prefer left over right
340+  CB3D FE 01            cp 1
341+  CB3F C8               ret z
342+  CB40 C3 49 CB         jp robots_checkdirectionsandmove8
343+  CB43              robots_checkdirectionsandmove7:
344+  CB43 CD 96 CB         call robots_checkrightthenleft ; prefer right over left
345+  CB46 FE 01            cp 1
346+  CB48 C8               ret z
347+  CB49              robots_checkdirectionsandmove8:
348+  CB49                  ; check up
349+  CB49 CD AC CB         call robots_checkupandmove
350+  CB4C FE 01            cp 1
351+  CB4E C8               ret z                       ; if we moved, don't check again
352+  CB4F                  ; check down
353+  CB4F CD E1 CB         call robots_checkdownandmove
354+  CB52 FE 01            cp 1
355+  CB54 C8               ret z                       ; if we moved, don't check again
356+  CB55                  ; if we're here and haven't moved...
357+  CB55 C9               ret
358+  CB56              robots_checkdirectionsandmove2
359+  CB56                  ; ALREADY MOVING DOWN
360+  CB56                  ; random check
361+  CB56 CD 69 BD         call game_getcurrentframe
362+  CB59 E6 01            and 1                       ; odd or even
363+  CB5B CA 67 CB         jp z,robots_checkdirectionsandmove9
364+  CB5E CD 96 CB         call robots_checkrightthenleft ; prefer right over left
365+  CB61 FE 01            cp 1
366+  CB63 C8               ret z
367+  CB64 C3 6D CB         jp robots_checkdirectionsandmove10
368+  CB67              robots_checkdirectionsandmove9:
369+  CB67 CD A0 CB         call robots_checkleftthenright ; prefer left over right
370+  CB6A FE 01            cp 1
371+  CB6C C8               ret z
372+  CB6D              robots_checkdirectionsandmove10:
373+  CB6D                  ; check down
374+  CB6D CD E1 CB         call robots_checkdownandmove
375+  CB70 FE 01            cp 1
376+  CB72 C8               ret z                       ; if we moved, don't check again
377+  CB73                  ; check right first
378+  CB73 CD 47 CC         call robots_checkrightandmove
379+  CB76 FE 01            cp 1
380+  CB78 C8               ret z                       ; if we moved, don't check again
381+  CB79                  ; check up
382+  CB79 CD AC CB         call robots_checkupandmove
383+  CB7C FE 01            cp 1
384+  CB7E C8               ret z                       ; if we moved, don't check again
385+  CB7F                  ; if we're here and haven't moved...
386+  CB7F C9               ret
387+  CB80
388+  CB80              ;
389+  CB80              ; Different orders of checking directions, for pseudo random motion
390+  CB80              ;
391+  CB80              robots_checkdownthenup:
392+  CB80                  ; check down
393+  CB80 CD E1 CB         call robots_checkdownandmove
394+  CB83 FE 01            cp 1
395+  CB85 C8               ret z                       ; if we moved, don't check again
396+  CB86                  ; check up
397+  CB86 CD AC CB         call robots_checkupandmove
398+  CB89 C9               ret
399+  CB8A
400+  CB8A              robots_checkupthendown:
401+  CB8A                  ; check up
402+  CB8A CD AC CB         call robots_checkupandmove
403+  CB8D FE 01            cp 1
404+  CB8F C8               ret z
405+  CB90                  ; check down
406+  CB90 CD E1 CB         call robots_checkdownandmove
407+  CB93 FE 01            cp 1
408+  CB95 C9               ret
409+  CB96              robots_checkrightthenleft:
410+  CB96                  ; check right
411+  CB96 CD 47 CC         call robots_checkrightandmove
412+  CB99 FE 01            cp 1
413+  CB9B C8               ret z                       ; if we moved, don't check again
414+  CB9C                  ; check left
415+  CB9C CD 0E CC         call robots_checkleftandmove
416+  CB9F C9               ret
417+  CBA0
418+  CBA0              robots_checkleftthenright:
419+  CBA0                  ; check left
420+  CBA0 CD 0E CC         call robots_checkleftandmove
421+  CBA3 FE 01            cp 1
422+  CBA5 C8               ret z
423+  CBA6                  ; check right
424+  CBA6 CD 47 CC         call robots_checkrightandmove
425+  CBA9 FE 01            cp 1
426+  CBAB C9               ret
427+  CBAC
428+  CBAC              ;
429+  CBAC              ; Checks up for movement
430+  CBAC              ; Outputs:
431+  CBAC              ; a - 1 if have moved
432+  CBAC              robots_checkupandmove:
433+  CBAC                  ; check above
434+  CBAC DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
434+  CBB0 46 01
435+  CBB2 79               ld a,c
436+  CBB3 FE 20            cp 32
437+  CBB5 D8               ret c
438+  CBB6 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
439+  CBB9 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
440+  CBBB 11 20 00         ld de,32
441+  CBBE ED 52            sbc hl,de                       ; memory location of line above now in hl
442+  CBC0 7E               ld a,(hl)                       ; get the contents of the line
443+  CBC1 FE 00            cp 0
444+  CBC3 C2 DE CB         jp nz,robots_checkupandmove0    ; can't move here so return
445+  CBC6 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
445+  CBCA 46 01
446+  CBCC 0D               dec c                       ; move up
447+  CBCD DD 71 00 DD      ld (ix),bc
447+  CBD1 70 01
448+  CBD3 DD 36 06 02      ld (ix+6),2
449+  CBD7 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
450+  CBDB 3E 01            ld a,1
451+  CBDD C9               ret
452+  CBDE              robots_checkupandmove0:
453+  CBDE 3E 00            ld a,0
454+  CBE0 C9               ret
455+  CBE1
456+  CBE1              ;
457+  CBE1              ; Checks down for movement
458+  CBE1              ; Outputs:
459+  CBE1              ; a - 1 if have moved
460+  CBE1              robots_checkdownandmove:
461+  CBE1                  ; check below
462+  CBE1 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
462+  CBE5 46 01
463+  CBE7 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
464+  CBEA 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
465+  CBEC 24               inc h                       ; memory location of cell beneath now in hl
466+  CBED 7E               ld a,(hl)                       ; get the contents of the line
467+  CBEE FE 00            cp 0
468+  CBF0 C2 0B CC         jp nz,robots_checkdownandmove0    ; can't move here so return
469+  CBF3 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
469+  CBF7 46 01
470+  CBF9 0C               inc c                       ; move up
471+  CBFA DD 71 00 DD      ld (ix),bc
471+  CBFE 70 01
472+  CC00 DD 36 06 03      ld (ix+6),3
473+  CC04 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
474+  CC08 3E 01            ld a,1
475+  CC0A C9               ret
476+  CC0B              robots_checkdownandmove0:
477+  CC0B 3E 00            ld a,0
478+  CC0D C9               ret
479+  CC0E
480+  CC0E              ;
481+  CC0E              ; Checks left for movement
482+  CC0E              ; Outputs:
483+  CC0E              ; a - 1 if have moved
484+  CC0E              robots_checkleftandmove:
485+  CC0E                  ; check below
486+  CC0E DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
486+  CC12 46 01
487+  CC14 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
488+  CC17 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
489+  CC19 78               ld a,b
490+  CC1A 06 08            ld b,8
491+  CC1C 90               sub b                           ; move one cell left
492+  CC1D 47               ld b,a
493+  CC1E 2B               dec hl                          ; memory location of cell to the right now in hl
494+  CC1F CD 1C BB         call movement_spaceisempty       ; check space is empty
495+  CC22 7B               ld a,e                          ; check space empty flag
496+  CC23 FE 00            cp 0
497+  CC25 CA 44 CC         jp z,robots_checkleftandmove0    ; if zero can't move
498+  CC28 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
498+  CC2C 46 01
499+  CC2E 05               dec b
500+  CC2F DD 71 00 DD      ld (ix),bc
500+  CC33 70 01
501+  CC35 DD 36 06 00      ld (ix+6),0
502+  CC39 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
503+  CC3D DD 36 03 00      ld (ix+3),0                 ; set to right
504+  CC41 3E 01            ld a,1
505+  CC43 C9               ret
506+  CC44              robots_checkleftandmove0:
507+  CC44 3E 00            ld a,0
508+  CC46 C9               ret
509+  CC47
510+  CC47              ;
511+  CC47              ; Checks right for movement
512+  CC47              ; Outputs:
513+  CC47              ; a - 1 if have moved
514+  CC47              robots_checkrightandmove:
515+  CC47                  ; check below
516+  CC47 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
516+  CC4B 46 01
517+  CC4D 78               ld a,b
518+  CC4E FE E8            cp 232
519+  CC50 CA 82 CC         jp z,robots_checkrightandmove0  ; can't move if at edge
520+  CC53 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
521+  CC56 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
522+  CC58 3E 08            ld a,8
523+  CC5A 80               add b                           ; move one cell right
524+  CC5B 47               ld b,a
525+  CC5C 23               inc hl                          ; memory location of cell to the right now in hl
526+  CC5D CD 1C BB         call movement_spaceisempty       ; check space is empty
527+  CC60 7B               ld a,e                          ; check space empty flag
528+  CC61 FE 00            cp 0
529+  CC63 CA 82 CC         jp z,robots_checkrightandmove0    ; if zero can't move
530+  CC66 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
530+  CC6A 46 01
531+  CC6C 04               inc b
532+  CC6D DD 71 00 DD      ld (ix),bc
532+  CC71 70 01
533+  CC73 DD 36 06 01      ld (ix+6),1
534+  CC77 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
535+  CC7B DD 36 03 01      ld (ix+3),1                 ; set to right
536+  CC7F 3E 01            ld a,1
537+  CC81 C9               ret
538+  CC82              robots_checkrightandmove0:
539+  CC82 3E 00            ld a,0
540+  CC84 C9               ret
541+  CC85
542+  CC85              ;
543+  CC85              ; Draws a robot
544+  CC85              ; Inputs:
545+  CC85              ; ix - points to first byte of robot in array
546+  CC85              robots_draw:
547+  CC85 DD 4E 00 DD      ld bc,(ix)
547+  CC89 46 01
548+  CC8B 21 EB B7         ld hl,robot_sprite                      ; set to the robot sprite
549+  CC8E DD 7E 02         ld a,(ix+2)                             ; get the state
550+  CC91 FE 02            cp 2                                    ; is this dying
551+  CC93 CA AE CC         jp z,robots_draw1
552+  CC96              robots_draw3:
553+  CC96 DD 7E 03         ld a,(ix+3)                             ; get the direction
554+  CC99 FE 00            cp 0
555+  CC9B CA A2 CC         jp z,robots_draw0                       ; if left, nothing to do
556+  CC9E 11 20 00         ld de,32
557+  CCA1 19               add hl,de                               ; add four frames to sprite
558+  CCA2              robots_draw0:
559+  CCA2 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
560+  CCA5 11 00 00         ld de,0
561+  CCA8 5F               ld e,a
562+  CCA9 19               add hl,de                               ; add to base
563+  CCAA CD 2A AA         call sprites_drawsprite
564+  CCAD C9               ret
565+  CCAE              ;
566+  CCAE              ; Dying
567+  CCAE              ;
568+  CCAE              robots_draw1:
569+  CCAE DD 7E 05         ld a,(ix+5)                             ; get anim frames
570+  CCB1 FE 00            cp 0                                    ; if zero this is the first time around
571+  CCB3 C2 BE CC         jp nz,robots_draw2
572+  CCB6 3E 18            ld a,24
573+  CCB8 DD 77 05         ld (ix+5),a                             ; load up the anim frames
574+  CCBB C3 96 CC         jp robots_draw3                         ; return to main loop to draw as normal
575+  CCBE              robots_draw2:
576+  CCBE 3D               dec a
577+  CCBF DD 77 05         ld (ix+5),a
578+  CCC2 FE 00            cp 0                                    ; have we reached the end yet
579+  CCC4 C2 CA CC         jp nz, robots_draw4
580+  CCC7 CD DA C9         call robots_kill
581+  CCCA              robots_draw4:
582+  CCCA C3 A2 CC         jp robots_draw0
583+  CCCD C9               ret
584+  CCCE
585+  CCCE              ;
586+  CCCE              ; Checks to see if the robot is hitting a player
587+  CCCE              ; Inputs:
588+  CCCE              ; ix - memory location of robot we're checking
589+  CCCE              robots_checkforplayer:
590+  CCCE 3A 85 BD         ld a,(player+11)     ; get player state
591+  CCD1 FE 00            cp 0
592+  CCD3 C0               ret nz               ; if already dying, don't kill again
593+  CCD4 DD 4E 00 DD      ld bc,(ix)           ; get coords
593+  CCD8 46 01
594+  CCDA ED 5B 7A BD      ld de,(player)       ; get the player coords
595+  CCDE 7B               ld a,e               ; get the vert coord first
596+  CCDF 91               sub c                ; subtract the diamond vertical coord from players
597+  CCE0 C6 08            add 8                ; add the max distance
598+  CCE2 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
599+  CCE4 D0               ret nc               ; if not, hasn't hit
600+  CCE5 7A               ld a,d               ; get the player horiz coord
601+  CCE6 90               sub b                ; subtract rock coord
602+  CCE7 C6 08            add 8                ; add max distance
603+  CCE9 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
604+  CCEB D0               ret nc
605+  CCEC DD 36 02 00      ld (ix+2),0          ; mark as inactive
606+  CCF0 CD A3 BE         call player_robotkillplayer ; mark the player as killed
607+  CCF3 C9               ret
# file closed: game/robots.asm
 50   CCF4                  include "game\bullet.asm"
# file opened: game/bullet.asm
  1+  CCF4              ;
  2+  CCF4              ; Current state: x & y coords (screen), direction (0 left, 1 right), state
  3+  CCF4              ;
  4+  CCF4              bullet_state:
  5+  CCF4 00 00 00 00      defb 0,0,0,0
  6+  CCF8
  7+  CCF8              ;
  8+  CCF8              ; Initialise a the bullet
  9+  CCF8              ;
 10+  CCF8              bullet_init:
 11+  CCF8 DD 21 F4 CC      ld ix,bullet_state
 12+  CCFC DD 36 00 00      ld (ix),0
 13+  CD00 DD 36 01 00      ld (ix+1),0
 14+  CD04 DD 36 02 00      ld (ix+2),0
 15+  CD08 DD 36 03 00      ld (ix+3),0
 16+  CD0C C9               ret
 17+  CD0D
 18+  CD0D              ;
 19+  CD0D              ; Shoots the bullet
 20+  CD0D              ;
 21+  CD0D              bullet_shoot:
 22+  CD0D DD 21 F4 CC      ld ix,bullet_state
 23+  CD11 ED 4B 7A BD      ld bc,(player)              ; get the player coords
 24+  CD15 3A 7C BD         ld a,(player+2)             ; get the player direction
 25+  CD18 FE 01            cp 1                        ; going left?
 26+  CD1A CA 28 CD         jp z,bullet_shoot0
 27+  CD1D 3E 08            ld a,8
 28+  CD1F 80               add a,b                     ; going right so add eight to start coords
 29+  CD20 47               ld b,a
 30+  CD21 DD 36 02 01      ld (ix+2),1                 ; set right
 31+  CD25 C3 31 CD         jp bullet_shoot1
 32+  CD28              bullet_shoot0:
 33+  CD28 78               ld a,b
 34+  CD29 06 08            ld b,8
 35+  CD2B 90               sub b
 36+  CD2C 47               ld b,a                      ; going left so subtract eight to start coords
 37+  CD2D DD 36 02 00      ld (ix+2),0                 ; set right
 38+  CD31              bullet_shoot1:
 39+  CD31 DD 71 00 DD      ld (ix),bc        ; store coords
 39+  CD35 70 01
 40+  CD37 DD 36 03 01      ld (ix+3),1       ; set state to 1
 41+  CD3B CD 91 CD         call bullet_draw ; draw the initial frame
 42+  CD3E C9               ret
 43+  CD3F
 44+  CD3F              ;
 45+  CD3F              ; Performs bullet processing
 46+  CD3F              ;
 47+  CD3F              bullet_process:
 48+  CD3F 3A F7 CC         ld a,(bullet_state+3)       ; get the state
 49+  CD42 FE 00            cp 0
 50+  CD44 C8               ret z                       ; don't draw if this has become inactive
 51+  CD45 CD 91 CD         call bullet_draw            ; delete current frame
 52+  CD48 CD 55 CD         call bullet_move            ; move the bullet
 53+  CD4B 3A F7 CC         ld a,(bullet_state+3)       ; get the state
 54+  CD4E FE 00            cp 0
 55+  CD50 C8               ret z                       ; don't draw if this has become inactive
 56+  CD51 CD 91 CD         call bullet_draw            ; draw new frame
 57+  CD54 C9               ret
 58+  CD55
 59+  CD55              ;
 60+  CD55              ; Moves the bullet, checking for collisions
 61+  CD55              ;
 62+  CD55              bullet_move:
 63+  CD55 DD 21 F4 CC      ld ix,bullet_state
 64+  CD59 DD 4E 00 DD      ld bc,(ix)
 64+  CD5D 46 01
 65+  CD5F DD 7E 02         ld a,(ix+2)                 ; get the direction
 66+  CD62 FE 00            cp 0                        ; going left?
 67+  CD64 CA 6E CD         jp z,bullet_move0
 68+  CD67 3E 08            ld a,8
 69+  CD69 80               add b
 70+  CD6A 47               ld b,a                      ; add 8 since going right
 71+  CD6B C3 73 CD         jp bullet_move1
 72+  CD6E              bullet_move0:
 73+  CD6E 78               ld a,b
 74+  CD6F 06 08            ld b,8
 75+  CD71 90               sub b
 76+  CD72 47               ld b,a                      ; subtract 8 since going left
 77+  CD73              bullet_move1:
 78+  CD73 DD 71 00 DD      ld (ix),bc                  ; store new coords
 78+  CD77 70 01
 79+  CD79 C5               push bc
 80+  CD7A CD 9E CD         call bullets_checkforrobot
 81+  CD7D C1               pop bc
 82+  CD7E FE 01            cp 1                        ; if we hit a robot, keep moving
 83+  CD80 C8               ret z
 84+  CD81 CD 1F AB         call sprites_scadd          ; get memory loc of this block into de
 85+  CD84 21 60 00         ld hl,96
 86+  CD87 19               add hl,de
 87+  CD88 7E               ld a,(hl)                   ; get the content
 88+  CD89 FE 00            cp 0
 89+  CD8B C8               ret z                       ; if empty, continue
 90+  CD8C DD 36 03 00      ld (ix+3),0                 ; otherwise, mark bullet as inactive
 91+  CD90 C9               ret
 92+  CD91
 93+  CD91              ;
 94+  CD91              ; Draw the bullet
 95+  CD91              ;
 96+  CD91              bullet_draw:
 97+  CD91 ED 4B F4 CC      ld bc,(bullet_state)        ; get coords
 98+  CD95 3E 1B            ld a,27
 99+  CD97 CD A5 A9         call screen_getblock        ; get the block address
100+  CD9A CD 2A AA         call sprites_drawsprite     ; draw the sprite
101+  CD9D C9               ret
102+  CD9E
103+  CD9E              ;
104+  CD9E              ; Checks to see if the robot is hitting a bullet
105+  CD9E              ; Outputs:
106+  CD9E              ; a = 0 if not robot hit
107+  CD9E              ; a = 1 if robot not hit
108+  CD9E              bullets_checkforrobot:
109+  CD9E 3E 00            ld a,0
110+  CDA0 32 EB CD         ld (bullets_tmp),a
111+  CDA3 3A 6B C9         ld a,(robots_robotsmax) ; robots to check
112+  CDA6 47               ld b,a
113+  CDA7 FD 21 3D C9      ld iy,robots_robots   ; start of robot array
114+  CDAB              bullets_checkforrobot0:
115+  CDAB C5               push bc
116+  CDAC FD 7E 02         ld a,(iy+2)             ; get the state
117+  CDAF FE 01            cp 1
118+  CDB1 C2 DF CD         jp nz,bullets_checkforrobot1 ; if not active, don't check
119+  CDB4 FD 5E 00 FD      ld de,(iy)              ; get robot coords
119+  CDB8 56 01
120+  CDBA 7A               ld a,d
121+  CDBB E6 F8            and 248                 ; get nearest multiple of 8
122+  CDBD 57               ld d,a
123+  CDBE ED 4B F4 CC      ld bc,(bullet_state)    ; get bullet coords
124+  CDC2 7A               ld a,d               ; get the player horiz coord
125+  CDC3 90               sub b                ; subtract robot coord
126+  CDC4 FE 00            cp 0                ; should be the same
127+  CDC6 C2 DF CD         jp nz,bullets_checkforrobot1 ; if not, haven't hit
128+  CDC9 7B               ld a,e               ; get the vert coord
129+  CDCA 91               sub c                ; subtract the bullet vertical coord from robots
130+  CDCB C6 04            add 4                ; add the max distance
131+  CDCD FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
132+  CDCF D2 DF CD         jp nc,bullets_checkforrobot1   ; if not, hasn't hit
133+  CDD2 FD 36 02 02      ld (iy+2),2             ; mark the robot as killed
134+  CDD6 FD 36 05 00      ld (iy+5),0             ; mark the anim frames as zero
135+  CDDA 3E 01            ld a,1
136+  CDDC 32 EB CD         ld (bullets_tmp),a      ; hit the flag to say we killed a robot
137+  CDDF              bullets_checkforrobot1:
138+  CDDF 11 07 00         ld de,7
139+  CDE2 FD 19            add iy,de              ; move to next robot
140+  CDE4 C1               pop bc
141+  CDE5 10 C4            djnz bullets_checkforrobot0
142+  CDE7 3A EB CD         ld a,(bullets_tmp)
143+  CDEA C9               ret
144+  CDEB
145+  CDEB              bullets_tmp:
146+  CDEB 00               defb 0
147+  CDEC
# file closed: game/bullet.asm
 51   CDEC
 52   CDEC              ;===========================================================================
 53   CDEC              ; main routine - the code execution starts here.
 54   CDEC              ; Sets up the new interrupt routine, the memory
 55   CDEC              ; banks and jumps to the start loop.
 56   CDEC              ;===========================================================================
 57   CDEC              main:
 58   CDEC CD 02 AF         call options_show
 59   CDEF
 60   CDEF                  ; Draw the title screen
 61   CDEF              main_titlescreen:
 62   CDEF CD 49 AB         call titlescreen_show
 63   CDF2 CD C0 BD         call player_init_gamestart
 64   CDF5
 65   CDF5              main_lifestart:
 66   CDF5
 67   CDF5 CD E6 BD         call player_init_lifestart
 68   CDF8
 69   CDF8 CD B9 AC         call lifescreen_draw        ; show the lives remaining screen
 70   CDFB
 71   CDFB CD 00 80         call init_start
 72   CDFE CD 21 A8         call screen_draw
 73   CE01 CD 70 A7         call buffer_allbuffertoscreen
 74   CE04
 75   CE04 CD 54 C6         call missiles_init
 76   CE07 CD D5 BF         call ship_land              ; land the ship
 77   CE0A CD E8 C0         call tank_init
 78   CE0D CD 1C C6         call diamonds_init
 79   CE10 CD 05 C8         call thepit_init
 80   CE13 CD 91 C8         call monster_init
 81   CE16 CD 6C C9         call robots_init
 82   CE19 CD F8 CC         call bullet_init
 83   CE1C
 84   CE1C              mloop:
 85   CE1C                  ;halt
 86   CE1C CD 50 CE         call main_loop_processing
 87   CE1F
 88   CE1F                  ;
 89   CE1F                  ; Check if the player died
 90   CE1F                  ;
 91   CE1F 21 84 BD         ld hl,player+10
 92   CE22 7E               ld a,(hl)                   ; check if the player died this frame
 93   CE23 FE 01            cp 1
 94   CE25 C2 3C CE         jp nz,mloop0
 95   CE28 CD 65 BE         call player_died        ; do end of life housekeeping
 96   CE2B 06 28            ld b,40
 97   CE2D CD 99 80         call utilities_pauseforframes
 98   CE30 21 83 BD         ld hl,player+9        ; check lives remaining
 99   CE33 7E               ld a,(hl)
100   CE34 FE 00            cp 0
101   CE36 CA 84 CE         jp z,main_gameover   ; leave the loop if we're done
102   CE39 C3 F5 CD         jp main_lifestart    ; otherwise, start a new life
103   CE3C              mloop0:
104   CE3C                  ;
105   CE3C                  ; Check if the player completed the level
106   CE3C                  ;
107   CE3C 21 87 BD         ld hl,player+13
108   CE3F 7E               ld a,(hl)
109   CE40 FE 01            cp 1
110   CE42 C2 1C CE         jp nz,mloop
111   CE45 CD 9F BF         call player_checkforexit
112   CE48 FE 01            cp 1                        ; look at return, if 1, level has been completed
113   CE4A CA 8A CE         jp z,main_endlevel          ; jump to level transition screen
114   CE4D C3 1C CE         jp mloop                ; start the loop again
115   CE50
116   CE50
117   CE50              main_loop_processing:
118   CE50
119   CE50 CD 2F A7         call buffer_buffertoscreen  ; copy buffer to screen
120   CE53 CD 94 A6         call buffer_clearlist       ; zero the updated lines list
121   CE56 CD 8A BD         call player_getlocation     ; figure out where the player is
122   CE59 CD A9 BE         call player_drawplayer      ; delete player
123   CE5C CD 3B B8         call control_input          ; check input
124   CE5F CD A9 BE         call player_drawplayer      ; draw player
125   CE62 CD 17 C1         call tank_process           ; prcoess the tank
126   CE65 CD C0 BF         call ship_process           ; proces the ship
127   CE68 CD 1B C3         call rocks_processrocks     ; process falling rocks
128   CE6B CD 10 C8         call thepit_process         ; process the pit trap
129   CE6E CD 7C C6         call missiles_process       ; process missiles
130   CE71 CD AE C8         call monster_process        ; process monster
131   CE74 CD EF C9         call robots_process         ; process robots
132   CE77 CD 3F CD         call bullet_process         ; process the bullet
133   CE7A CD FB C5         call diamonds_twinkle       ; make the diamonds twinkle
134   CE7D CD 85 C4         call scores_printscore      ; update the score on screen
135   CE80 CD 5A BD         call game_incrementframe    ; increment the game frame
136   CE83
137   CE83 C9               ret
138   CE84
139   CE84              main_gameover:
140   CE84 CD 11 AD         call gameover_draw          ; show the game over screen
141   CE87 C3 EF CD         jp main_titlescreen         ; go back to title
142   CE8A
143   CE8A              main_endlevel:
144   CE8A CD 3F BE         call player_recordcurrentstate
145   CE8D CD FF AD         call endlevel_draw          ; show the end level screen
146   CE90 C3 F5 CD         jp main_lifestart           ; start a new life
147   CE93
148   CE93              ;===========================================================================
149   CE93              ; Stack.
150   CE93              ;===========================================================================
151   CE93
152   CE93              ; Stack: this area is reserved for the stack
153   CE93              STACK_SIZE: equ 100    ; in words
154   CE93
155   CE93              ; Reserve stack space
156   CE93 00 00            defw 0  ; WPMEM, 2
157   CE95              stack_bottom:
158   CE95 00 00 00...      defs    STACK_SIZE*2, 0
159   CF5D              stack_top:
160   CF5D 00 00            defw 0  ; WPMEM, 2
161   CF5F
162   CF5F                     SAVESNA "ThePit.sna", main
# file closed: main.asm
