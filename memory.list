# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000 CD 6B 0D         call $0D6B
  7+  8003 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8005                                      ; bright (64).
  9+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 10+  8008 AF               xor a               ; quick way to load accumulator with zero.
 11+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 12+  800C CD AF 0D         call 3503           ; ROM routine - clears screen, opens chan 2.
 13+  800F
 14+  800F C9               ret
 15+  8010
 16+  8010              ;
 17+  8010              ;   Start coord
 18+  8010              ;   vert c, horiz b
 19+  8010              start_coord:
 20+  8010 18 30            defb 24,48
 21+  8012
# file closed: init.asm
 21   8012                  include "utilities.asm"
# file opened: utilities.asm
  1+  8012              ; ##########################################################################
  2+  8012              ; Print a character
  3+  8012              ; Inputs:
  4+  8012              ; b - x coord
  5+  8012              ; c - y coord
  6+  8012              ; d - character
  7+  8012              ; e - colour
  8+  8012              ; ##########################################################################
  9+  8012              utilities_print_char:
 10+  8012 7B               ld a,e
 11+  8013 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  8016 3E 16            ld a,22
 13+  8018 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8019 78               ld a,b              ; Gets the X co-ordinate
 15+  801A 3D               dec a
 16+  801B D7               rst 16
 17+  801C 79               ld a,c              ; and the Y co-ordinate
 18+  801D D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  801E 7A               ld a,d              ; ASCII code for udg.
 20+  801F D7               rst 16              ; draw block.
 21+  8020 C9               ret
 22+  8021
 23+  8021
 24+  8021              ;Inputs:
 25+  8021              ;     DE and A are factors
 26+  8021              ;Outputs:
 27+  8021              ;     A is not changed
 28+  8021              ;     B is 0
 29+  8021              ;     C is not changed
 30+  8021              ;     DE is not changed
 31+  8021              ;     HL is the product
 32+  8021              ;Time:
 33+  8021              ;     342+6x
 34+  8021              ;
 35+  8021              utilities_multiply:
 36+  8021 06 08            ld b,8          ;7           7
 37+  8023 21 00 00         ld hl,0         ;10         10
 38+  8026 29               add hl,hl     ;11*8       88
 39+  8027 07               rlca          ;4*8        32
 40+  8028 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  802A 19                   add hl,de   ;--         --
 42+  802B 10 F9            djnz $-5      ;13*7+8     99
 43+  802D C9               ret             ;10         10
 44+  802E
 45+  802E              utilities_waitforkey:
 46+  802E 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  8031 36 00            ld (hl),0           ; put null value there.
 48+  8033              utilities_waitforkey0:
 49+  8033 7E               ld a,(hl)           ; new value of LAST K.
 50+  8034 FE 00            cp 0                ; is it still zero?
 51+  8036 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8038 C9               ret                 ; key was pressed.
 53+  8039
# file closed: utilities.asm
 22   8039                  include "strings.asm"
# file opened: strings.asm
  1+  8039              string_score1:
  2+  8039 04 00 53 43      defb 4,0,'SCORE1',255
  2+  803D 4F 52 45 31
  2+  8041 FF
  3+  8042              string_scorenumbers1:
  4+  8042 04 01 30 30      defb 4,1,'000000',255
  4+  8046 30 30 30 30
  4+  804A FF
  5+  804B              string_company:
  6+  804B 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  804F 4E 54 55 52
  6+  8053 49 FF
  7+  8055              string_credits:
  8+  8055 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  8059 41 59 45 52
  8+  805D 20 31 FF
  9+  8060              string_score2:
 10+  8060 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8064 4F 52 45 32
 10+  8068 FF
 11+  8069              string_scorenumbers2:
 12+  8069 16 01 30 30      defb 22,1,'000000',255
 12+  806D 30 30 30 30
 12+  8071 FF
 13+  8072              string_titlescreen_copyright:
 14+  8072 04 16 7F 20      defb 4,22, 127,' 1982 AW ZILEC ELC LTD',255
 14+  8076 31 39 38 32
 14+  807A 20 41 57 20
 14+  807E 5A 49 4C 45
 14+  8082 43 20 45 4C
 14+  8086 43 20 4C 54
 14+  808A 44 FF
 15+  808C
 16+  808C              ;
 17+  808C              ; Prints specified string
 18+  808C              ; Inputs:
 19+  808C              ; de: pointer to string
 20+  808C              ; bc: length of string
 21+  808C              ;
 22+  808C              ; Print String Data
 23+  808C              ; First two bytes of string contain X and Y char position, then the string
 24+  808C              ; Individual strings are terminated with 0xFE
 25+  808C              ; End of data is terminated with 0xFF
 26+  808C              ; HL: Address of string
 27+  808C              ;
 28+  808C 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
 29+  808D 23                                   INC HL                          ; Increase HL to the next memory location
 30+  808E 56                                   LD D,(HL)                       ; Fetch the Y coordinate
 31+  808F 23                                   INC HL                          ; Increase HL to the next memory location
 32+  8090 CD A3 80                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
 33+  8093 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
 34+  8094 23                                   INC HL                          ; Increase HL to the next character
 35+  8095 FE FE                                CP 0xFE                         ; Compare with 0xFE
 36+  8097 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
 37+  8099 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
 38+  809A E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
 39+  809B CD B3 80                             CALL Print_Char                 ; Print the character
 40+  809E E1                                   POP HL                          ; Retrieve HL back off the stack
 41+  809F 1C                                   INC E                           ; Go to the next screen address
 42+  80A0 18 F1                                JR string_print_0               ; Loop back to print next character
 43+  80A2 C9                                   RET
 44+  80A3
 45+  80A3              ; Get screen address
 46+  80A3              ; D = Y character position
 47+  80A3              ; E = X character position
 48+  80A3              ; Returns address in DE
 49+  80A3              ;
 50+  80A3 7A           string_getcharaddress:       LD A,D
 51+  80A4 E6 07                                AND %00000111
 52+  80A6 1F                                   RRA
 53+  80A7 1F                                   RRA
 54+  80A8 1F                                   RRA
 55+  80A9 1F                                   RRA
 56+  80AA B3                                   OR E
 57+  80AB 5F                                   LD E,A
 58+  80AC 7A                                   LD A,D
 59+  80AD E6 18                                AND %00011000
 60+  80AF F6 40                                OR %01000000
 61+  80B1 57                                   LD D,A
 62+  80B2 C9                                   RET                             ; Returns screen address in DE
 63+  80B3
 64+  80B3              ; Print a single character out
 65+  80B3              ; A:  Character to print
 66+  80B3              ; DE: Screen address to print character at
 67+  80B3              ;
 68+  80B3 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
 69+  80B6 06 00                                LD B,0                          ; Set BC to A
 70+  80B8 4F                                   LD C,A
 71+  80B9 E6 FF                                AND 0xFF                        ; Clear the carry bit
 72+  80BB CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
 73+  80BD CB 10                                RL B
 74+  80BF CB 11                                RL C
 75+  80C1 CB 10                                RL B
 76+  80C3 CB 11                                RL C
 77+  80C5 CB 10                                RL B
 78+  80C7 09                                   ADD HL,BC                       ; Get the character address in HL
 79+  80C8 0E 08                                LD C,8                          ; Loop counter
 80+  80CA D5                                   PUSH DE
 81+  80CB 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
 82+  80CC 12                                   LD (DE),A                       ; Stick A onto the screen
 83+  80CD 14                                   INC D                           ; Goto next line on screen
 84+  80CE 2C                                   INC L                           ; Goto next byte of character
 85+  80CF 0D                                   DEC C                           ; Decrease the loop counter
 86+  80D0 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
 87+  80D2 D1                                   POP DE
 88+  80D3 C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   80D4                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  80D4              screen_buffer:
  2+  80D4 00 00 00...      defs 7424                   ; area reserved for screen
  3+  9DD4
  4+  9DD4              screen_attr_buffer:
  5+  9DD4 00 00 00...      defs 928                    ; attrs buffer area
  6+  A174
  7+  A174              screen_offset:
  8+  A174 00               defb 0                      ; offset from top of screen in lines
  9+  A175
 10+  A175              ;
 11+  A175              ; Copies the buffer to the screen. Use stack.
 12+  A175              ; Inputs: none
 13+  A175              ;
 14+  A175              screen_buffertoscreen:
 15+  A175 3A 74 A1         ld a,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 16+  A178 11 00 01         ld de,256
 17+  A17B CD 21 80         call utilities_multiply
 18+  A17E 54 5D            ld de,hl
 19+  A180 21 D4 80         ld hl,screen_buffer
 20+  A183 19               add hl,de                   ; add the offset
 21+  A184 ED 73 F0 A1      ld (screen_buffertoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
 22+  A188 D9               exx
 23+  A189 21 50 40         ld hl,16384+80              ; where the actual screen is, but as we're using the stack it's the right hand side of the buffer (16+32+32)
 24+  A18C              screen_buffertoscreen0:
 25+  A18C D9               exx                         ; hl is now buffer
 26+  A18D F9               ld sp,hl                    ; do first sixteen for left hand side
 27+  A18E F1               pop af
 28+  A18F C1               pop bc
 29+  A190 D1               pop de
 30+  A191 DD E1            pop ix
 31+  A193 D9               exx                         ; hl is now screen
 32+  A194 08               ex af,af'
 33+  A195 F1               pop af
 34+  A196 C1               pop bc
 35+  A197 D1               pop de
 36+  A198 FD E1            pop iy
 37+  A19A F9               ld sp,hl
 38+  A19B FD E5            push iy
 39+  A19D D5               push de
 40+  A19E C5               push bc
 41+  A19F F5               push af
 42+  A1A0 08               ex af,af'
 43+  A1A1 D9               exx                         ; hl is now buffer
 44+  A1A2 DD E5            push ix
 45+  A1A4 D5               push de
 46+  A1A5 C5               push bc
 47+  A1A6 F5               push af
 48+  A1A7 1E 10            ld e,16                    ; do another sixteen for right hand side
 49+  A1A9 16 00            ld d,0
 50+  A1AB 19               add hl,de
 51+  A1AC F9               ld sp,hl
 52+  A1AD F1               pop af
 53+  A1AE C1               pop bc
 54+  A1AF D1               pop de
 55+  A1B0 DD E1            pop ix
 56+  A1B2 D9               exx                         ; hl is now screen
 57+  A1B3 08               ex af,af'
 58+  A1B4 1E 10            ld e,16
 59+  A1B6 16 00            ld d,0
 60+  A1B8 19               add hl,de
 61+  A1B9 F1               pop af
 62+  A1BA C1               pop bc
 63+  A1BB D1               pop de
 64+  A1BC FD E1            pop iy
 65+  A1BE F9               ld sp,hl
 66+  A1BF FD E5            push iy
 67+  A1C1 D5               push de
 68+  A1C2 C5               push bc
 69+  A1C3 F5               push af
 70+  A1C4 08               ex af,af'
 71+  A1C5 D9               exx                         ; hl is now buffer
 72+  A1C6 DD E5            push ix
 73+  A1C8 D5               push de
 74+  A1C9 C5               push bc
 75+  A1CA F5               push af
 76+  A1CB 1E 10            ld e,16
 77+  A1CD 16 00            ld d,0
 78+  A1CF 19               add hl,de
 79+  A1D0 D9               exx                         ; hl is now screen
 80+  A1D1 1E 10            ld e,16
 81+  A1D3 16 00            ld d,0
 82+  A1D5 ED 52            sbc hl,de
 83+  A1D7 24               inc h
 84+  A1D8 7C               ld a,h
 85+  A1D9 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
 86+  A1DB 20 AF            jr nz,screen_buffertoscreen0 ; next line in cell
 87+  A1DD 7C               ld a,h
 88+  A1DE D6 08            sub 8
 89+  A1E0 67               ld h,a
 90+  A1E1 7D               ld a,l
 91+  A1E2 C6 20            add a,32
 92+  A1E4 6F               ld l,a
 93+  A1E5 30 A5            jr nc,screen_buffertoscreen0
 94+  A1E7 7C               ld a,h
 95+  A1E8 C6 08            add a,8
 96+  A1EA 67               ld h,a
 97+  A1EB FE 58            cp 0x58
 98+  A1ED 20 9D            jr nz,screen_buffertoscreen0
 99+  A1EF              screen_buffertoscreen1:
100+  A1EF 31 00 00         ld sp,0
101+  A1F2 D9               exx
102+  A1F3 CD F7 A1         call screen_buffertoattrs
103+  A1F6 C9               ret
104+  A1F7
105+  A1F7              screen_buffertoattrs:
106+  A1F7 3A 74 A1         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
107+  A1FA 11 20 00         ld de,32
108+  A1FD CD 21 80         call utilities_multiply
109+  A200 54 5D            ld de,hl
110+  A202 21 D4 9D         ld hl,screen_attr_buffer
111+  A205 19               add hl,de                       ; add the offset
112+  A206 11 40 58         ld de,22528+64                  ; add 32x2 to the attr memory address to account for the top two rows
113+  A209 01 A0 03         ld bc,928
114+  A20C ED B0            ldir
115+  A20E C9               ret
116+  A20F
117+  A20F              screen_setscorecolours:
118+  A20F 21 FB A8         ld hl,score_colours
119+  A212 11 00 58         ld de,22528                     ; attrs here
120+  A215 01 40 00         ld bc,64
121+  A218 ED B0            ldir
122+  A21A C9               ret
123+  A21B
124+  A21B
125+  A21B              ; Draw the screen
126+  A21B              ; Inputs:
127+  A21B              ; none
128+  A21B              ; Notes:
129+  A21B              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
130+  A21B              screen_draw:
131+  A21B                  ;call clear_screen
132+  A21B 0E 00            ld c,0                      ; horiz
133+  A21D 06 00            ld b,0                      ; vert, 0 at top
134+  A21F DD 21 C1 A4      ld ix,level01               ; point ix at level data
135+  A223 FD 21 D4 9D      ld iy,screen_attr_buffer    ; point iy at attr data
136+  A227              screen_draw0:
137+  A227 DD 7E 00         ld a,(ix)                   ; load the block number
138+  A22A C5               push bc                     ; store bc, contains loop count
139+  A22B CD 34 A3         call screen_getattr         ; get the memory location for this cell's attr into hl
140+  A22E 7E               ld a,(hl)                   ; get the attr value at the address
141+  A22F FD 77 00         ld (iy),a                   ; load the attr into memory
142+  A232 DD 7E 00         ld a,(ix)                   ; load the block number
143+  A235 CD 29 A3         call screen_getblock        ; get the block data into hl
144+  A238 CD 0F A3         call screen_showchar        ; show this character here
145+  A23B C1               pop bc                      ; get the loop counter back
146+  A23C DD 23            inc ix                      ; increment level location
147+  A23E FD 23            inc iy                      ; increment attr location
148+  A240 0C               inc c                       ; increment horiz
149+  A241 79               ld a,c
150+  A242 FE 20            cp 32                       ; check if horiz has reach edge of screen
151+  A244 C2 27 A2         jp nz,screen_draw0          ; if not, loop
152+  A247 0E 00            ld c,0                      ; if so, reset horiz
153+  A249 04               inc b                       ; increment vertical
154+  A24A 78               ld a,b
155+  A24B FE 1D            cp 29                       ; check if at bottom
156+  A24D C2 27 A2         jp nz,screen_draw0          ; if not, loop
157+  A250 CD 7F A2         call screen_initrocks       ; draw rocks
158+  A253
159+  A253 CD 57 A2         call screen_setuptext       ; draws text on the screen
160+  A256 C9               ret
161+  A257
162+  A257              ;
163+  A257              ; Sets up text on the screen
164+  A257              ;
165+  A257              screen_setuptext:
166+  A257 21 39 80         ld hl, string_score1
167+  A25A CD 8C 80         call string_print
168+  A25D 21 42 80         ld hl, string_scorenumbers1
169+  A260 CD 8C 80         call string_print
170+  A263 21 4B 80         ld hl, string_company
171+  A266 CD 8C 80         call string_print
172+  A269 21 60 80         ld hl, string_score2
173+  A26C CD 8C 80         call string_print
174+  A26F 21 69 80         ld hl, string_scorenumbers2
175+  A272 CD 8C 80         call string_print
176+  A275 21 55 80         ld hl, string_credits
177+  A278 CD 8C 80         call string_print
178+  A27B CD 0F A2         call screen_setscorecolours
179+  A27E C9               ret
180+  A27F              ;
181+  A27F              ; Draw initial rock positions
182+  A27F              ; Inputs:
183+  A27F              ;
184+  A27F              screen_initrocks:
185+  A27F DD 21 61 A8      ld ix,level01rocks          ; load the location of the rock into ix
186+  A283              screen_initrocks0:
187+  A283 DD 4E 00         ld c,(ix)                   ; get the horiz coord
188+  A286 79               ld a,c
189+  A287 FE FF            cp 255
190+  A289 CA AC A2         jp z,screen_initrocks2
191+  A28C DD 23            inc ix                      ; move to next
192+  A28E DD 46 00         ld b,(ix)                   ; get the vert coord
193+  A291 DD 23            inc ix
194+  A293 CD BE A2         call screen_getcellattradress ; get the memory address of b,c attr into de
195+  A296 3E 09            ld a,9                      ; load the block number for rock
196+  A298 D5               push de
197+  A299 CD 34 A3         call screen_getattr         ; get the memory location for this cell's attr into hl
198+  A29C D1               pop de
199+  A29D 7E               ld a,(hl)                   ; get the attr value at the address
200+  A29E 12               ld (de),a                   ; load the attr into memory
201+  A29F 3E 09            ld a,9                      ; load the block number for rock
202+  A2A1 CD 29 A3         call screen_getblock        ; get the block data into hl
203+  A2A4 CD 0F A3         call screen_showchar        ; show this character here
204+  A2A7              screen_initrocks1:
205+  A2A7 DD 23            inc ix                      ; move past state
206+  A2A9 C3 83 A2         jp screen_initrocks0      ; decrease b and check if zero
207+  A2AC              screen_initrocks2:
208+  A2AC C9               ret
209+  A2AD
210+  A2AD
211+  A2AD              ;
212+  A2AD              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
213+  A2AD              ; Inputs:
214+  A2AD              ; bc: coords
215+  A2AD              ; Outputs:
216+  A2AD              ; de: memory location
217+  A2AD              ;
218+  A2AD              screen_getcelladdress:
219+  A2AD 78               ld a,b      ; vertical position.
220+  A2AE E6 18            and 24      ; which segment, 0, 1 or 2?
221+  A2B0 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
222+  A2B2 57               ld d,a      ; this is our high byte.
223+  A2B3 78               ld a,b      ; what was that vertical position again?
224+  A2B4 E6 07            and 7       ; which row within segment?
225+  A2B6 0F               rrca        ; multiply row by 32.
226+  A2B7 0F               rrca
227+  A2B8 0F               rrca
228+  A2B9 5F               ld e,a      ; low byte.
229+  A2BA 79               ld a,c      ; add on y coordinate.
230+  A2BB 83               add a,e     ; mix with low byte.
231+  A2BC 5F               ld e,a      ; address of screen position in de.
232+  A2BD C9               ret
233+  A2BE
234+  A2BE              ;
235+  A2BE              ; Calculate buffer address of attribute for character at (b, c).
236+  A2BE              ; Inputs:
237+  A2BE              ; bc: coords
238+  A2BE              ; Outputs:
239+  A2BE              ; de: memory location
240+  A2BE              ;
241+  A2BE              screen_getcellattradress:
242+  A2BE 11 D4 9D         ld de,screen_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
243+  A2C1 69               ld l,c      ; x position.
244+  A2C2 26 00            ld h,0      ; 0 h
245+  A2C4 19               add hl,de
246+  A2C5 54 5D            ld de,hl    ; horiz done
247+  A2C7 78               ld a,b      ; do vert
248+  A2C8 D5               push de
249+  A2C9 C5               push bc
250+  A2CA 11 20 00         ld de,32
251+  A2CD CD 21 80         call utilities_multiply
252+  A2D0 C1               pop bc
253+  A2D1 D1               pop de
254+  A2D2 19               add hl,de
255+  A2D3 54 5D            ld de,hl    ; vert done
256+  A2D5 C9               ret
257+  A2D6
258+  A2D6              ;
259+  A2D6              ; Calculate buffer address of attribute for character at (b, c).
260+  A2D6              ; Inputs:
261+  A2D6              ; bc: coords
262+  A2D6              ; Outputs:
263+  A2D6              ; de: memory location
264+  A2D6              ;
265+  A2D6              screen_getscreenattradress:
266+  A2D6 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
267+  A2D9 69               ld l,c      ; x position.
268+  A2DA 26 00            ld h,0      ; 0 h
269+  A2DC 19               add hl,de
270+  A2DD 54 5D            ld de,hl    ; horiz done
271+  A2DF 78               ld a,b      ; do vert
272+  A2E0 D5               push de
273+  A2E1 C5               push bc
274+  A2E2 11 20 00         ld de,32
275+  A2E5 CD 21 80         call utilities_multiply
276+  A2E8 C1               pop bc
277+  A2E9 D1               pop de
278+  A2EA 19               add hl,de
279+  A2EB 54 5D            ld de,hl    ; vert done
280+  A2ED C9               ret
281+  A2EE
282+  A2EE              ;
283+  A2EE              ; Gets the attr memory location for a screen coord
284+  A2EE              ; Will overwrite bc
285+  A2EE              ; Inputs:
286+  A2EE              ; bc - screen coords
287+  A2EE              ; Outputs:
288+  A2EE              ; de - memory location
289+  A2EE              ; bc - character coords
290+  A2EE              ;
291+  A2EE              screen_getattraddressfromscreencoords:
292+  A2EE 78               ld a,b                          ; get the player block coords of current block
293+  A2EF E6 F8            and 248                         ; find closest multiple of eight
294+  A2F1 0F               rrca
295+  A2F2 0F               rrca
296+  A2F3 0F               rrca                ; divide by 8
297+  A2F4 47               ld b,a
298+  A2F5 79               ld a,c
299+  A2F6 48               ld c,b                         ; swap b and c
300+  A2F7 E6 F8            and 248
301+  A2F9 0F               rrca
302+  A2FA 0F               rrca
303+  A2FB 0F               rrca                ; divide by 8
304+  A2FC 47               ld b,a
305+  A2FD CD BE A2         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
306+  A300 C9               ret
307+  A301
308+  A301              ;
309+  A301              ; Get buffer address for a character at b,c - b vert
310+  A301              ; Buffer memory is stored as sequential block
311+  A301              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
312+  A301              ; Inputs:
313+  A301              ; bc - coords
314+  A301              ; Outputs:
315+  A301              ; de - memory location of first byte
316+  A301              screen_getbufferaddress:
317+  A301 21 D4 80         ld hl, screen_buffer    ; first get screen buffer start
318+  A304 50               ld d,b                  ; then work out vertical offset
319+  A305 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
320+  A307 19               add hl,de               ; add to base
321+  A308 59               ld e,c                  ; then add horizontal offset (c)
322+  A309 16 00            ld d,0
323+  A30B 19               add hl,de               ; add to base
324+  A30C 54 5D            ld de,hl
325+  A30E C9               ret
326+  A30F
327+  A30F              ;
328+  A30F              ; Display character hl at (b, c) to buffer.
329+  A30F              ; Stored sequentially
330+  A30F              ; Inputs:
331+  A30F              ; hl: block address
332+  A30F              ; bc: coords
333+  A30F              ;
334+  A30F              screen_showchar:
335+  A30F 3E 00            ld a,0
336+  A311 E5               push hl
337+  A312 CD 01 A3         call screen_getbufferaddress ; get the current screen buffer pointer
338+  A315 E1               pop hl
339+  A316 06 08            ld b,8              ; number of pixels high.
340+  A318              screen_showchar0:
341+  A318 7E               ld a,(hl)           ; source graphic.
342+  A319 12               ld (de),a           ; transfer to screen.
343+  A31A 23               inc hl              ; next piece of data.
344+  A31B E5               push hl             ; store hl
345+  A31C 62 6B            ld hl,de            ; put de in hl
346+  A31E 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
347+  A320 16 00            ld d,0
348+  A322 19               add hl,de              ; add de to hl
349+  A323 54 5D            ld de,hl            ; load back to de
350+  A325 E1               pop hl              ; restore hl
351+  A326
352+  A326 10 F0            djnz screen_showchar0 ; repeat
353+  A328 C9               ret
354+  A329
355+  A329
356+  A329              ;
357+  A329              ; Get cell graphic.
358+  A329              ; Inputs:
359+  A329              ; a: block
360+  A329              ; Outputs:
361+  A329              ; hl: memory
362+  A329              ;
363+  A329              screen_getblock:
364+  A329 07               rlca                        ; multiply block number by eight.
365+  A32A 07               rlca
366+  A32B 07               rlca
367+  A32C 5F               ld e,a                      ; displacement to graphic address.
368+  A32D 16 00            ld d,0                      ; no high byte.
369+  A32F 21 3B A9         ld hl,sprites               ; address of character blocks.
370+  A332 19               add hl,de                   ; point to block.
371+  A333 C9               ret
372+  A334
373+  A334              ;
374+  A334              ; Get cell attribute.
375+  A334              ; Inputs:
376+  A334              ; a: block
377+  A334              ; Outputs:
378+  A334              ; hl: memory
379+  A334              ;
380+  A334              screen_getattr:
381+  A334 5F               ld e,a                      ; displacement to attribute address.
382+  A335 16 00            ld d,0                      ; no high byte.
383+  A337 21 9B A9         ld hl,sprite_attrs          ; address of block attributes.
384+  A33A 19               add hl,de                   ; point to attribute.
385+  A33B C9               ret
386+  A33C
# file closed: screen/screen.asm
 24   A33C                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A33C              ;
  2+  A33C              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A33C              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A33C              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A33C              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A33C              ; routine takes care of all the shifting itself. This means that sprite
  7+  A33C              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A33C              ; space they would require in pre-shifted form.
  9+  A33C              ; Inputs:
 10+  A33C              ; hl - sprite data
 11+  A33C              ; bc - screen coords
 12+  A33C              ;
 13+  A33C              sprites_drawsprite7:
 14+  A33C EE 07            xor 7               ; complement last 3 bits.
 15+  A33E 3C               inc a               ; add one for luck!
 16+  A33F              sprites_drawsprite3:
 17+  A33F CB 11            rl c                ; ...into middle byte...
 18+  A341 CB 12            rl d                ; ...and finally into left character cell.
 19+  A343 3D               dec a               ; count shifts we've done.
 20+  A344 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A346                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A346 79               ld a,c              ; left edge of image is currently in e.
 23+  A347 4A               ld c,d              ; put right edge there instead.
 24+  A348 57               ld d,a              ; and the left edge back into c.
 25+  A349 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A34B              sprites_drawsprite:
 27+  A34B ED 43 B0 A3      ld (dispx),bc       ; store coords in dispx for now.
 28+  A34F E5               push hl
 29+  A350 CD 8E A3         call sprites_scadd  ; calculate screen address.
 30+  A353 E1               pop hl
 31+  A354 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A356              sprites_drawsprite1:
 33+  A356 08               ex af,af'           ; store loop counter.
 34+  A357 D5               push de             ; store screen address.
 35+  A358 4E               ld c,(hl)           ; first sprite graphic.
 36+  A359 23               inc hl              ; increment poiinter to sprite data.
 37+  A35A 22 B2 A3         ld (sprtmp),hl      ; store it for later.
 38+  A35D 16 00            ld d,0              ; blank right byte for now.
 39+  A35F 78               ld a,b              ; b holds y position.
 40+  A360 E6 07            and 7               ; how are we straddling character cells?
 41+  A362 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A364 FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A366 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A368 A7               and a               ; oops, carry flag is set so clear it.
 45+  A369              sprites_drawsprite2:
 46+  A369 CB 19            rr c                ; rotate left byte right...
 47+  A36B CB 1A            rr d                ; ...into right byte.
 48+  A36D 3D               dec a               ; one less shift to do.
 49+  A36E 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A370              sprites_drawsprite0:
 51+  A370 E1               pop hl              ; pop screen address from stack.
 52+  A371 7E               ld a,(hl)           ; what's there already.
 53+  A372 A9               xor c               ; merge in image data.
 54+  A373 77               ld (hl),a           ; place onto screen.
 55+  A374 23               inc hl
 56+  A375 7E               ld a,(hl)           ; what's already there.
 57+  A376 AA               xor d               ; right edge of sprite image data.
 58+  A377 77               ld (hl),a           ; plonk it on screen.
 59+  A378 3A B0 A3         ld a,(dispx)        ; vertical coordinate.
 60+  A37B 3C               inc a               ; next line down.
 61+  A37C 32 B0 A3         ld (dispx),a        ; store new position.
 62+  A37F 2B               dec hl
 63+  A380 11 20 00         ld de,32            ; add 32 to get to the next row
 64+  A383 19               add hl,de           ; add 32
 65+  A384              sprites_drawsprite6:
 66+  A384 EB               ex de,hl            ; screen address in de.
 67+  A385 2A B2 A3         ld hl,(sprtmp)      ; restore graphic address.
 68+  A388 08               ex af,af'           ; restore loop counter.
 69+  A389 3D               dec a               ; decrement it.
 70+  A38A C2 56 A3         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 71+  A38D C9               ret                 ; job done.
 72+  A38E
 73+  A38E              ;
 74+  A38E              ; This routine returns a buffer address for (c, b) in de (c vert).
 75+  A38E              ; For example: 0,0 will be at memory offset 0
 76+  A38E              ; 1,0 (1 down) will be at memory offset 1
 77+  A38E              ; 0,7 will be at memory offset 0
 78+  A38E              ; 9,1 will be at memory offset 8+1
 79+  A38E              ; 8,0 will be at memory offset 256
 80+  A38E              ; 9,0 will be at memory offset 257
 81+  A38E              ; Inputs:
 82+  A38E              ; de - coords
 83+  A38E              ;
 84+  A38E              sprites_scadd:
 85+  A38E 79               ld a,c               ; calculate vertical offset
 86+  A38F E6 F8            and 248             ;  to get nearest multiple of 8
 87+  A391 0F               rrca
 88+  A392 0F               rrca
 89+  A393 0F               rrca                ; divide by 8
 90+  A394 67               ld h,a
 91+  A395 78               ld a,b               ; calculate horizontal offset
 92+  A396 E6 F8            and 248             ;  to get nearest multiple of 8
 93+  A398 0F               rrca
 94+  A399 0F               rrca
 95+  A39A 0F               rrca                ; divide by 8
 96+  A39B 6F               ld l,a
 97+  A39C C5               push bc             ; store the screen coords
 98+  A39D 44 4D            ld bc,hl            ; load bc with the character coords
 99+  A39F CD 01 A3         call screen_getbufferaddress
100+  A3A2 C1               pop bc              ; get back screen coords, de is now memory of character
101+  A3A3 79               ld a,c              ; now add the vertical within the cell
102+  A3A4 E6 07            and 7
103+  A3A6 0F               rrca                ; multiply by 32.
104+  A3A7 0F               rrca
105+  A3A8 0F               rrca
106+  A3A9 6F               ld l,a
107+  A3AA 26 00            ld h,0
108+  A3AC 19               add hl,de
109+  A3AD 54 5D            ld de,hl
110+  A3AF C9               ret
111+  A3B0
112+  A3B0 00           dispx   defb 0           ; general-use coordinates.
113+  A3B1 00           dispy   defb 0
114+  A3B2 00           sprtmp  defb 0           ; sprite temporary address.
115+  A3B3
# file closed: screen/sprites.asm
 25   A3B3                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  A3B3              ;
  2+  A3B3              ; Draws the title screen
  3+  A3B3              ;
  4+  A3B3              titlescreen_show:
  5+  A3B3 CD D9 A3         call titlescreen_init
  6+  A3B6 CD BD A3         call titlescreen_drawtitle
  7+  A3B9 CD 2E 80         call utilities_waitforkey   ; wait for keypress
  8+  A3BC C9               ret
  9+  A3BD
 10+  A3BD              ;
 11+  A3BD              ; Draws the iconic logo
 12+  A3BD              ;
 13+  A3BD              titlescreen_drawtitle:
 14+  A3BD 06 69            ld b,105              ; number of points
 15+  A3BF DD 21 EF A3      ld ix,titlescreen_logo_data
 16+  A3C3              titlescreen_drawtitle0:
 17+  A3C3 C5               push bc
 18+  A3C4 DD 4E 00         ld c,(ix)                   ; got horiz
 19+  A3C7 DD 23            inc ix
 20+  A3C9 DD 46 00         ld b,(ix)                   ; got vert
 21+  A3CC DD 23            inc ix
 22+  A3CE CD D6 A2         call screen_getscreenattradress ; memory in de
 23+  A3D1 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 24+  A3D2 3E 13            ld a,19
 25+  A3D4 12               ld (de),a
 26+  A3D5 C1               pop bc
 27+  A3D6 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 28+  A3D8 C9               ret
 29+  A3D9
 30+  A3D9              ;
 31+  A3D9              ; Initialises the screen
 32+  A3D9              ;
 33+  A3D9              titlescreen_init:
 34+  A3D9              ; We want a black screen.
 35+  A3D9 CD 6B 0D         call $0D6B
 36+  A3DC 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 37+  A3DE                                      ; bright (64).
 38+  A3DE 32 8D 5C         ld (23693),a        ; set our screen colours.
 39+  A3E1 3E 01            ld a,1              ; 2 is the code for red.
 40+  A3E3 D3 FE            out (254),a         ; write to port 254.
 41+  A3E5 CD AF 0D         call 3503           ; ROM routine - clears screen, opens chan 2.
 42+  A3E8
 43+  A3E8 21 72 80         ld hl,string_titlescreen_copyright
 44+  A3EB CD 8C 80         call string_print
 45+  A3EE
 46+  A3EE C9               ret
 47+  A3EF
 48+  A3EF              ;
 49+  A3EF              ; Horiz, vert
 50+  A3EF              ;
 51+  A3EF              titlescreen_logo_data:
 52+  A3EF 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0,20,0
 52+  A3F3 0A 00 0C 00
 52+  A3F7 0F 00 11 00
 52+  A3FB 12 00 13 00
 52+  A3FF 14 00
 53+  A401 09 01 0C 01      defb 9,1,12,1,15,1,17,1
 53+  A405 0F 01 11 01
 54+  A409 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2,20,2
 54+  A40D 0D 02 0E 02
 54+  A411 0F 02 11 02
 54+  A415 12 02 13 02
 54+  A419 14 02
 55+  A41B 09 03 0C 03      defb 9,3,12,3,15,3,17,3
 55+  A41F 0F 03 11 03
 56+  A423 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4,20,4
 56+  A427 0F 04 11 04
 56+  A42B 12 04 13 04
 56+  A42F 14 04
 57+  A431 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
 57+  A435 02 06 03 06
 57+  A439 04 06 05 06
 57+  A43D 06 06 07 06
 57+  A441 08 06 09 06
 57+  A445 0A 06 0B 06
 58+  A449 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
 58+  A44D 12 06 13 06
 58+  A451 14 06 15 06
 58+  A455 16 06 17 06
 58+  A459 18 06 19 06
 58+  A45D 1A 06 1B 06
 59+  A461 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20
 59+  A465 02 09 02 0A
 59+  A469 02 0B 02 0C
 59+  A46D 02 0D 02 0E
 59+  A471 02 0F 02 10
 59+  A475 02 11 02 12
 59+  A479 02 13 02 14
 60+  A47D 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20
 60+  A481 19 09 19 0A
 60+  A485 19 0B 19 0C
 60+  A489 19 0D 19 0E
 60+  A48D 19 0F 19 10
 60+  A491 19 11 19 12
 60+  A495 19 13 19 14
 61+  A499 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
 61+  A49D 05 0B 06 0B
 61+  A4A1 07 0B 08 0B
 61+  A4A5 09 0B 0A 0B
 61+  A4A9 0B 0B
 62+  A4AB 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
 62+  A4AF 0B 09 0B 0A
 63+  A4B3 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19,16,20
 63+  A4B7 10 10 10 11
 63+  A4BB 10 12 10 13
 63+  A4BF 10 14
 64+  A4C1
# file closed: screen/titlescreen.asm
 26   A4C1
 27   A4C1                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  A4C1              ; ###############################################################
  2+  A4C1              ; Data for level 1
  3+  A4C1              ; ###############################################################
  4+  A4C1              level01:
  5+  A4C1
  6+  A4C1 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  6+  A4C5 05 05 05 05
  6+  A4C9 05 05 05 05
  6+  A4CD 05 05 02 01
  6+  A4D1 01 01 03 05
  6+  A4D5 05 05 05 05
  6+  A4D9 05 05 05 05
  6+  A4DD 05 05 00 00
  7+  A4E1 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  7+  A4E5 05 05 05 05
  7+  A4E9 05 05 05 05
  7+  A4ED 02 01 01 01
  7+  A4F1 01 01 01 01
  7+  A4F5 03 05 05 05
  7+  A4F9 05 05 05 05
  7+  A4FD 05 05 00 00
  8+  A501 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,10,10,10,10,10,10,00,00
  8+  A505 05 05 05 05
  8+  A509 05 05 02 01
  8+  A50D 01 01 01 01
  8+  A511 01 01 01 01
  8+  A515 01 01 03 05
  8+  A519 0A 0A 0A 0A
  8+  A51D 0A 0A 00 00
  9+  A521 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,11,05,00,00
  9+  A525 01 01 00 01
  9+  A529 01 01 01 01
  9+  A52D 01 01 01 01
  9+  A531 01 01 01 01
  9+  A535 01 01 01 03
  9+  A539 05 05 05 05
  9+  A53D 0B 05 00 00
 10+  A541 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 10+  A545 04 04 04 04
 10+  A549 04 04 01 01
 10+  A54D 01 01 01 01
 10+  A551 01 01 01 01
 10+  A555 01 01 01 01
 10+  A559 01 01 01 01
 10+  A55D 00 01 00 00
 11+  A561 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 11+  A565 04 04 04 04
 11+  A569 04 04 04 04
 11+  A56D 01 01 01 01
 11+  A571 01 01 01 01
 11+  A575 01 01 01 01
 11+  A579 00 00 00 00
 11+  A57D 00 01 00 00
 12+  A581 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 12+  A585 04 01 01 01
 12+  A589 01 01 04 04
 12+  A58D 04 04 01 01
 12+  A591 01 01 01 01
 12+  A595 01 00 00 00
 12+  A599 00 01 01 01
 12+  A59D 01 01 00 00
 13+  A5A1 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 13+  A5A5 04 04 04 04
 13+  A5A9 04 01 04 04
 13+  A5AD 04 04 04 04
 13+  A5B1 04 04 00 00
 13+  A5B5 00 00 04 04
 13+  A5B9 04 04 04 04
 13+  A5BD 04 01 00 00
 14+  A5C1 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 14+  A5C5 01 04 01 01
 14+  A5C9 01 01 04 04
 14+  A5CD 04 04 04 04
 14+  A5D1 04 04 00 04
 14+  A5D5 04 04 04 04
 14+  A5D9 04 04 04 04
 14+  A5DD 04 01 00 00
 15+  A5E1 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 15+  A5E5 00 00 00 00
 15+  A5E9 00 04 04 04
 15+  A5ED 04 04 04 04
 15+  A5F1 04 04 00 04
 15+  A5F5 04 04 04 04
 15+  A5F9 04 04 04 04
 15+  A5FD 04 01 00 00
 16+  A601 00 00 01 07      defb 00,00,01,07,07,07,07,07,07,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  A605 07 07 07 07
 16+  A609 07 01 04 04
 16+  A60D 04 04 04 04
 16+  A611 04 04 00 04
 16+  A615 04 04 04 04
 16+  A619 04 04 04 04
 16+  A61D 04 01 00 00
 17+  A621 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 17+  A625 00 00 00 00
 17+  A629 00 01 04 04
 17+  A62D 04 04 04 04
 17+  A631 04 04 00 04
 17+  A635 04 04 04 04
 17+  A639 04 00 00 00
 17+  A63D 00 01 00 00
 18+  A641 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 18+  A645 00 00 00 00
 18+  A649 00 01 04 04
 18+  A64D 04 04 04 04
 18+  A651 04 04 00 04
 18+  A655 04 04 04 04
 18+  A659 04 00 04 04
 18+  A65D 00 01 00 00
 19+  A661 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 19+  A665 06 06 06 06
 19+  A669 06 01 04 04
 19+  A66D 04 04 04 04
 19+  A671 04 04 00 04
 19+  A675 04 04 04 04
 19+  A679 04 00 04 04
 19+  A67D 00 01 00 00
 20+  A681 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 20+  A685 06 06 06 06
 20+  A689 06 01 04 00
 20+  A68D 00 00 00 00
 20+  A691 00 00 00 00
 20+  A695 00 00 00 00
 20+  A699 00 00 04 04
 20+  A69D 00 01 00 00
 21+  A6A1 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 21+  A6A5 06 06 06 06
 21+  A6A9 06 01 04 00
 21+  A6AD 04 04 04 04
 21+  A6B1 04 04 00 04
 21+  A6B5 04 04 00 04
 21+  A6B9 04 04 04 04
 21+  A6BD 00 01 00 00
 22+  A6C1 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 22+  A6C5 06 06 06 06
 22+  A6C9 06 01 04 00
 22+  A6CD 04 04 04 04
 22+  A6D1 04 04 00 04
 22+  A6D5 04 04 00 04
 22+  A6D9 04 04 04 04
 22+  A6DD 00 01 00 00
 23+  A6E1 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  A6E5 01 01 01 01
 23+  A6E9 01 01 04 00
 23+  A6ED 04 04 04 04
 23+  A6F1 04 04 00 04
 23+  A6F5 04 04 00 04
 23+  A6F9 04 04 04 04
 23+  A6FD 00 01 00 00
 24+  A701 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 24+  A705 04 04 04 04
 24+  A709 04 04 04 00
 24+  A70D 04 04 04 04
 24+  A711 04 04 00 04
 24+  A715 04 04 00 00
 24+  A719 00 00 04 04
 24+  A71D 04 01 00 00
 25+  A721 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 25+  A725 04 04 00 00
 25+  A729 00 00 00 00
 25+  A72D 04 04 04 04
 25+  A731 04 04 00 04
 25+  A735 04 04 04 04
 25+  A739 04 00 04 04
 25+  A73D 04 01 00 00
 26+  A741 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 26+  A745 04 04 00 04
 26+  A749 04 04 04 04
 26+  A74D 04 04 04 04
 26+  A751 04 04 00 04
 26+  A755 04 04 04 04
 26+  A759 04 00 04 04
 26+  A75D 04 01 00 00
 27+  A761 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 27+  A765 04 04 00 04
 27+  A769 04 04 01 01
 27+  A76D 01 01 01 01
 27+  A771 01 01 01 01
 27+  A775 01 01 01 01
 27+  A779 04 00 04 04
 27+  A77D 04 01 00 00
 28+  A781 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 28+  A785 04 04 00 04
 28+  A789 04 04 01 00
 28+  A78D 00 00 00 00
 28+  A791 00 00 00 00
 28+  A795 00 00 00 01
 28+  A799 04 00 04 04
 28+  A79D 04 01 00 00
 29+  A7A1 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 29+  A7A5 04 04 00 04
 29+  A7A9 04 04 01 00
 29+  A7AD 00 00 00 00
 29+  A7B1 00 00 00 00
 29+  A7B5 00 00 00 01
 29+  A7B9 04 00 04 04
 29+  A7BD 04 01 00 00
 30+  A7C1 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  A7C5 04 04 00 04
 30+  A7C9 04 04 01 00
 30+  A7CD 00 00 00 00
 30+  A7D1 00 00 00 00
 30+  A7D5 00 00 00 01
 30+  A7D9 04 00 04 04
 30+  A7DD 04 01 00 00
 31+  A7E1 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 31+  A7E5 04 04 00 04
 31+  A7E9 04 04 04 00
 31+  A7ED 00 00 00 00
 31+  A7F1 00 00 00 00
 31+  A7F5 00 00 00 04
 31+  A7F9 04 04 04 04
 31+  A7FD 04 01 00 00
 32+  A801 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 32+  A805 04 04 04 04
 32+  A809 04 04 01 00
 32+  A80D 00 00 00 00
 32+  A811 00 00 00 00
 32+  A815 00 00 00 01
 32+  A819 04 04 04 04
 32+  A81D 04 01 00 00
 33+  A821 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,08,00,01,00,08,00,00,01,00,08,00,01,04,04,04,04,04,01,00,00
 33+  A825 04 04 04 04
 33+  A829 04 04 01 00
 33+  A82D 08 00 01 00
 33+  A831 08 00 00 01
 33+  A835 00 08 00 01
 33+  A839 04 04 04 04
 33+  A83D 04 01 00 00
 34+  A841 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 34+  A845 01 01 01 01
 34+  A849 01 01 01 01
 34+  A84D 01 01 01 01
 34+  A851 01 01 01 01
 34+  A855 01 01 01 01
 34+  A859 01 01 01 01
 34+  A85D 01 01 00 00
 35+  A861
 36+  A861              ; ###############################################################
 37+  A861              ; Rock data: horiz, vert, state
 38+  A861              ; ###############################################################
 39+  A861              level01rocks:
 40+  A861 09 04 00         defb 9,4,0
 41+  A864 0C 07 00         defb 12,7,0
 42+  A867 10 07 00         defb 16,7,0
 43+  A86A 0B 08 00         defb 11,8,0
 44+  A86D 0A 0A 00         defb 10,10,0
 45+  A870 0C 0A 00         defb 12,10,0
 46+  A873 0D 09 00         defb 13,9,0
 47+  A876 0E 08 00         defb 14,8,0
 48+  A879 0F 0B 00         defb 15,11,0
 49+  A87C 0B 0C 00         defb 11,12,0
 50+  A87F 11 0C 00         defb 17,12,0
 51+  A882 13 08 00         defb 19,8,0
 52+  A885 16 09 00         defb 22,9,0
 53+  A888 13 0A 00         defb 19,10,0
 54+  A88B 15 0A 00         defb 21,10,0
 55+  A88E 15 0C 00         defb 21,12,0
 56+  A891 16 0C 00         defb 22,12,0
 57+  A894 18 0A 00         defb 24,10,0
 58+  A897 19 09 00         defb 25,9,0
 59+  A89A 1C 09 00         defb 28,9,0
 60+  A89D 1B 0C 00         defb 27,12,0
 61+  A8A0 1A 0D 00         defb 26,13,0
 62+  A8A3 19 0E 00         defb 25,14,0
 63+  A8A6 19 10 00         defb 25,16,0
 64+  A8A9 1A 11 00         defb 26,17,0
 65+  A8AC 1B 11 00         defb 27,17,0
 66+  A8AF 1C 12 00         defb 28,18,0
 67+  A8B2 1A 13 00         defb 26,19,0
 68+  A8B5 1B 15 00         defb 27,21,0
 69+  A8B8 1A 17 00         defb 26,23,0
 70+  A8BB 1B 18 00         defb 27,24,0
 71+  A8BE 19 18 00         defb 25,24,0
 72+  A8C1 18 17 00         defb 24,23,0
 73+  A8C4 13 14 00         defb 19,20,0
 74+  A8C7 14 12 00         defb 20,18,0
 75+  A8CA 14 10 00         defb 20,16,0
 76+  A8CD 15 10 00         defb 21,16,0
 77+  A8D0 16 12 00         defb 22,18,0
 78+  A8D3 11 14 00         defb 17,20,0
 79+  A8D6 0D 11 00         defb 13,17,0
 80+  A8D9 0C 13 00         defb 12,19,0
 81+  A8DC 0B 13 00         defb 11,19,0
 82+  A8DF 0A 11 00         defb 10,17,0
 83+  A8E2 05 12 00         defb 5,18,0
 84+  A8E5 07 16 00         defb 7,22,0
 85+  A8E8 09 17 00         defb 9,23,0
 86+  A8EB 07 18 00         defb 7,24,0
 87+  A8EE 05 18 00         defb 5,24,0
 88+  A8F1 06 19 00         defb 6,25,0
 89+  A8F4 08 19 00         defb 8,25,0
 90+  A8F7 04 17 00         defb 4,23,0
 91+  A8FA FF               defb 255
 92+  A8FB
 93+  A8FB              ;
 94+  A8FB              ; Score area colours
 95+  A8FB              ;
 96+  A8FB              score_colours:
 97+  A8FB 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
 97+  A8FF 47 47 47 47
 97+  A903 47 47 47 42
 97+  A907 43 43 43 43
 97+  A90B 43 43 43 43
 97+  A90F 42 47 47 47
 97+  A913 47 47 47 47
 97+  A917 47 47 47 47
 98+  A91B 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
 98+  A91F 47 47 47 47
 98+  A923 47 47 47 46
 98+  A927 46 46 46 46
 98+  A92B 46 46 46 46
 98+  A92F 46 47 47 47
 98+  A933 47 47 47 47
 98+  A937 47 47 47 47
# file closed: leveldata/level01.asm
 28   A93B                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  A93B              ; Tiles graphics.
  2+  A93B              sprites:
  3+  A93B 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  A93F 00 00 00 00
  4+  A943 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  A947 FF FF FF FF
  5+  A94B 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  A94F 1F 3F 7F FF
  6+  A953 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  A957 F8 FC FE FF
  7+  A95B 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  A95F 55 AA 55 AA
  8+  A963 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  A967 00 00 00 00
  9+  A96B FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  A96F FF FF FF FF
 10+  A973 FF FF 00 00      defb    255,255,  0,  0,  0,  0,  0,  0   ; 7, trapdoor
 10+  A977 00 00 00 00
 11+  A97B 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, gem
 11+  A97F F1 72 34 18
 12+  A983 1C 7E FF 7F      defb    28,126,255,127,254,252,127,  62    ; 9, rock
 12+  A987 FE FC 7F 3E
 13+  A98B 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 10, sky block, tank background
 13+  A98F 00 00 00 00
 14+  A993 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  A997 00 00 FF FF
 15+  A99B
 16+  A99B              sprite_attrs:
 17+  A99B 46               defb    070 ; 0, space
 18+  A99C 65               defb    101 ; 1, cyan block
 19+  A99D 4D               defb    077 ; 2, slope left
 20+  A99E 4D               defb    077 ; 3, slope right
 21+  A99F 46               defb    070 ; 4, dirt
 22+  A9A0 4E               defb    078 ; 5, sky
 23+  A9A1 4C               defb    076 ; 6, slime
 24+  A9A2 42               defb    066 ; 7, trapdoor
 25+  A9A3 46               defb    070 ; 8, gem
 26+  A9A4 42               defb    066 ; 9, rock
 27+  A9A5 4A               defb    074 ; 10, sky, red ink (tank)
 28+  A9A6 49           	defb    073 ; 11, sky, trapdoor
 29+  A9A7
 30+  A9A7              player_sprite:
 31+  A9A7 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 31+  A9AB 38 3D C3 80
 32+  A9AF 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 32+  A9B3 3C 1C 16 32
 33+  A9B7 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 33+  A9BB 3C 38 68 4C
 34+  A9BF 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 34+  A9C3 1C BC C3 01
 35+  A9C7 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 35+  A9CB 3C 3C 64 0C
 36+  A9CF 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 36+  A9D3 3C 3C 26 30
 37+  A9D7 02 07 02 3F  	defb	 2,  7,  2, 63, 15, 15, 25,  3  ; 6 shoot left
 37+  A9DB 0F 0F 19 03
 38+  A9DF 40 E0 40 FC  	defb	 64,224, 64,252,240,240,152,192 ; 7 shoot right
 38+  A9E3 F0 F0 98 C0
 39+  A9E7
 40+  A9E7              ;
 41+  A9E7              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 42+  A9E7              ;
 43+  A9E7              ship_sprite:
 44+  A9E7 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 44+  A9EB 03 1F 7F FF
 45+  A9EF 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 45+  A9F3 FF FF FF FF
 46+  A9F7 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 46+  A9FB FF FF FF FF
 47+  A9FF 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 47+  AA03 C0 F8 FE FF
 48+  AA07 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 48+  AA0B 03 03 02 07
 49+  AA0F 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 49+  AA13 FF 0F 07 83
 50+  AA17 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 50+  AA1B FF 10 20 C1
 51+  AA1F 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 51+  AA23 C0 C0 40 E0
 52+  AA27 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 52+  AA2B 03 03 02 07
 53+  AA2F F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 53+  AA33 FF 08 04 83
 54+  AA37 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 54+  AA3B FF F0 E0 C1
 55+  AA3F CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 55+  AA43 C0 C0 40 E0
 56+  AA47
 57+  AA47              ;
 58+  AA47              ;  First 8 frames are tank, last frame is the gun barrel
 59+  AA47              ;
 60+  AA47              tank_sprite:
 61+  AA47 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 61+  AA4B 7F 00 00 00
 62+  AA4F 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 62+  AA53 FE FF 7F 40
 63+  AA57 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 63+  AA5B 03 FF FF 01
 64+  AA5F 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
 64+  AA63 E0 C0 00 00
 65+  AA67 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
 65+  AA6B F7 E1 7F 3F
 66+  AA6F FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
 66+  AA73 54 16 FF FF
 67+  AA77 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
 67+  AA7B 9B A8 FF FF
 68+  AA7F FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
 68+  AA83 9F AF FE FC
 69+  AA87 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0
 69+  AA8B 1F 00 00 00
# file closed: graphics/graphics.asm
 29   AA8F
 30   AA8F                  include "game\control.asm"
# file opened: game/control.asm
  1+  AA8F              ;
  2+  AA8F              ; Check the keyboard then move
  3+  AA8F              ;
  4+  AA8F              control_keyboard:
  5+  AA8F 3A 78 AD         ld a,(player+5)      ; first, check if the player has pixels left to move
  6+  AA92 FE 00            cp 0
  7+  AA94 CA 9B AA         jp z, control_keyboard1
  8+  AA97 CD 3C AB         call control_automove
  9+  AA9A C9               ret
 10+  AA9B              control_keyboard1:
 11+  AA9B 3A 79 AD         ld a,(player+6)      ; next, check if the player is digging
 12+  AA9E FE 00            cp 0
 13+  AAA0 CA A7 AA         jp z, control_keyboard0
 14+  AAA3 CD CE AA         call control_dig
 15+  AAA6 C9               ret
 16+  AAA7              control_keyboard0:
 17+  AAA7 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 18+  AAAA ED 78            in a,(c)            ; read keyboard.
 19+  AAAC 47               ld b,a              ; store result in b register.
 20+  AAAD CB 18            rr b                ; check outermost key (q).
 21+  AAAF D4 85 AB         call nc,control_pl_moveup         ; player up.
 22+  AAB2 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 23+  AAB5 ED 78            in a,(c)            ; read keyboard.
 24+  AAB7 47               ld b,a              ; store result in b register.
 25+  AAB8 CB 18            rr b                ; check outermost key (a).
 26+  AABA D4 B4 AB         call nc,control_pl_movedown       ; player down.
 27+  AABD 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 28+  AAC0 ED 78            in a,(c)            ; read keyboard.
 29+  AAC2 47               ld b,a              ; store result in b register.
 30+  AAC3 CB 18            rr b                ; check outermost key (p).
 31+  AAC5 D4 11 AC         call nc,control_pl_moveright       ; player left.
 32+  AAC8 CB 18            rr b                ; check next key.
 33+  AACA D4 E1 AB         call nc,control_pl_moveleft       ; player right.
 34+  AACD C9               ret
 35+  AACE
 36+  AACE              ;
 37+  AACE              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 38+  AACE              ;
 39+  AACE              control_dig:
 40+  AACE ED 4B 73 AD      ld bc,(player)      ; load the current coords into bc
 41+  AAD2 C5               push bc
 42+  AAD3 3A 75 AD         ld a,(player+2)     ; get the direction
 43+  AAD6 FE 01            cp 1                ; left
 44+  AAD8 CA F0 AA         jp z,control_dig0
 45+  AADB FE 02            cp 2                ; right
 46+  AADD CA F9 AA         jp z,control_dig1
 47+  AAE0 FE 03            cp 3                ; down
 48+  AAE2 CA 0F AB         jp z,control_dig5
 49+  AAE5 FE 00            cp 0                ; up
 50+  AAE7 CA 02 AB         jp z,control_dig4
 51+  AAEA 21 79 AD         ld hl,player+6
 52+  AAED 36 00            ld (hl),0           ; turn off digging
 53+  AAEF C9               ret                 ; return
 54+  AAF0              control_dig0:           ; going left
 55+  AAF0 CD 8E A3         call sprites_scadd  ; get the current coord
 56+  AAF3 62 6B            ld hl,de
 57+  AAF5 2B               dec hl              ; move one left
 58+  AAF6 C3 18 AB         jp control_dig2
 59+  AAF9              control_dig1:
 60+  AAF9 CD 8E A3         call sprites_scadd  ; get the current coord
 61+  AAFC 62 6B            ld hl,de
 62+  AAFE 23               inc hl              ; move one left
 63+  AAFF C3 18 AB         jp control_dig2
 64+  AB02              control_dig4:
 65+  AB02 CD 8E A3         call sprites_scadd  ; get the current coord
 66+  AB05 62 6B            ld hl,de
 67+  AB07 11 00 01         ld de,256
 68+  AB0A ED 52            sbc hl,de             ; move one up
 69+  AB0C C3 18 AB         jp control_dig2
 70+  AB0F              control_dig5:
 71+  AB0F CD 8E A3         call sprites_scadd  ; get the current coord
 72+  AB12 62 6B            ld hl,de
 73+  AB14 24               inc h              ; move one down
 74+  AB15 C3 18 AB         jp control_dig2
 75+  AB18              control_dig2:
 76+  AB18 C1               pop bc
 77+  AB19 E5               push hl
 78+  AB1A CD 8E AC         call control_spaceisdiggable ; check again if the row is diggable
 79+  AB1D 3A 79 AD         ld a,(player+6)      ; next, check if the player is digging
 80+  AB20 FE 01            cp 1
 81+  AB22 C0               ret nz              ; return if we're not supposed to be digging
 82+  AB23 E1               pop hl
 83+  AB24 3A 7B AD         ld a,(player+8)     ; get the number of rows we need to overwrite
 84+  AB27 47               ld b,a              ; rows to copy over
 85+  AB28              control_dig3:
 86+  AB28 36 00            ld (hl),0           ; load empty into row
 87+  AB2A 11 20 00         ld de,32
 88+  AB2D 19               add hl,de           ; move to next row
 89+  AB2E 10 F8            djnz control_dig3
 90+  AB30 21 79 AD         ld hl,player+6
 91+  AB33 36 00            ld (hl),0           ; turn off digging
 92+  AB35 21 78 AD         ld hl,player+5      ; automove into this space
 93+  AB38 3E 04            ld a,4
 94+  AB3A 77               ld (hl),a
 95+  AB3B C9               ret
 96+  AB3C
 97+  AB3C              ;
 98+  AB3C              ; Auto move the player until pixels is zero
 99+  AB3C              ;
100+  AB3C              control_automove:
101+  AB3C 5F               ld e,a              ; store the number of pixels left to move in e
102+  AB3D ED 4B 73 AD      ld bc,(player)      ; load the current coords into bc
103+  AB41 21 75 AD         ld hl,player+2      ; get the direction
104+  AB44 7E               ld a,(hl)
105+  AB45 FE 03            cp 3                ; down
106+  AB47 CA 5B AB         jp z,control_automove3  ; don't need to do anything
107+  AB4A FE 00            cp 0                ; going up
108+  AB4C CA 67 AB         jp z,control_automove2
109+  AB4F FE 01            cp 1                ; going left?
110+  AB51 CA 73 AB         jp z,control_automove0
111+  AB54 78               ld a,b
112+  AB55 3C               inc a               ; if we're going right, increment a twice for two pixels
113+  AB56 3C               inc a
114+  AB57 47               ld b,a
115+  AB58 C3 77 AB         jp control_automove1
116+  AB5B              control_automove3:
117+  AB5B 79               ld a,c
118+  AB5C 3C               inc a
119+  AB5D 3C               inc a               ; if we're going down, increment twice
120+  AB5E 4F               ld c,a
121+  AB5F FE 90            cp 144
122+  AB61 CC 3F AC         call z, control_scroll_down
123+  AB64 C3 77 AB         jp control_automove1
124+  AB67              control_automove2:
125+  AB67 79               ld a,c
126+  AB68 3D               dec a
127+  AB69 3D               dec a               ; if we're going up, decrement twice
128+  AB6A 4F               ld c,a
129+  AB6B FE 60            cp 96
130+  AB6D CC 47 AC         call z, control_scroll_up
131+  AB70 C3 77 AB         jp control_automove1
132+  AB73              control_automove0:
133+  AB73 78               ld a,b
134+  AB74 3D               dec a               ; if we're going left, decrement a twice
135+  AB75 3D               dec a
136+  AB76 47               ld b,a
137+  AB77              control_automove1:
138+  AB77 ED 43 73 AD      ld (player),bc      ; and back to player
139+  AB7B 7B               ld a,e              ; now get the pixel count back
140+  AB7C 3D               dec a               ; decrease by one
141+  AB7D 21 78 AD         ld hl,player+5
142+  AB80 77               ld (hl),a           ; copy back
143+  AB81 CD A6 AD         call player_justmoved
144+  AB84 C9               ret
145+  AB85
146+  AB85              ;
147+  AB85              ; Moves the player up
148+  AB85              ;
149+  AB85              control_pl_moveup:
150+  AB85 C5               push bc
151+  AB86 ED 4B 73 AD      ld bc,(player)          ; get the current coords, b horiz, c vert
152+  AB8A 79               ld a,c                  ; load c into the acc
153+  AB8B FE 18            cp 24
154+  AB8D CA AD AB         jp z,control_pl_moveup0 ; are we at the edge of the screen
155+  AB90 FE 60            cp 96
156+  AB92 DC 47 AC         call c, control_scroll_up
157+  AB95 CD EA AC         call control_checkcanmove_up ; check we can move up, e will be 1 if we can
158+  AB98 F5               push af
159+  AB99 7B               ld a,e                  ; put e in a
160+  AB9A FE 00            cp 0
161+  AB9C CA AC AB         jp z,control_pl_moveup1 ; don't move if we can't
162+  AB9F F1               pop af
163+  ABA0 D6 01            sub 1                   ; subtract 1
164+  ABA2 D6 01            sub 1                   ; subtract 1
165+  ABA4 4F               ld c,a                  ; load back to c
166+  ABA5 ED 43 73 AD      ld (player),bc          ; load back to player
167+  ABA9 C3 AD AB         jp control_pl_moveup0
168+  ABAC              control_pl_moveup1:
169+  ABAC F1               pop af                  ; restore af if needed
170+  ABAD              control_pl_moveup0:
171+  ABAD 3E 00            ld a,0
172+  ABAF 32 75 AD         ld (player+2),a        ; set direction to up
173+  ABB2 C1               pop bc
174+  ABB3 C9               ret
175+  ABB4              ;
176+  ABB4              ; Moves the player down
177+  ABB4              ;
178+  ABB4              control_pl_movedown:
179+  ABB4 C5               push bc
180+  ABB5 ED 4B 73 AD      ld bc,(player)          ; get the current coords, b horiz, c vert
181+  ABB9 79               ld a,c                  ; load c into the acc
182+  ABBA FE E0            cp 224
183+  ABBC CA DA AB         jp z,control_pl_movedown0 ; are we at the edge of the screen
184+  ABBF FE 90            cp 144
185+  ABC1 D4 3F AC         call nc, control_scroll_down
186+  ABC4 CD C2 AC         call control_checkcanmove_down ; check we can move down, e will be 1 if we can
187+  ABC7 F5               push af
188+  ABC8 7B               ld a,e                  ; put e in a
189+  ABC9 FE 00            cp 0
190+  ABCB CA D9 AB         jp z,control_pl_movedown1 ; don't move if we can't
191+  ABCE F1               pop af
192+  ABCF 3C               inc a                   ; add 1
193+  ABD0 3C               inc a                   ; add 1
194+  ABD1 4F               ld c,a                  ; load back to c
195+  ABD2 ED 43 73 AD      ld (player),bc          ; load back to player
196+  ABD6 C3 DA AB         jp control_pl_movedown0
197+  ABD9              control_pl_movedown1:
198+  ABD9 F1               pop af                  ; restore af if needed
199+  ABDA              control_pl_movedown0:
200+  ABDA 3E 03            ld a,3
201+  ABDC 32 75 AD         ld (player+2),a        ; set direction to down
202+  ABDF C1               pop bc
203+  ABE0 C9               ret
204+  ABE1              ;
205+  ABE1              ; Moves the player left
206+  ABE1              ;
207+  ABE1              control_pl_moveleft:
208+  ABE1 C5               push bc
209+  ABE2 ED 4B 73 AD      ld bc,(player)          ; get the current coords, b horiz, c vert
210+  ABE6 78               ld a,b                  ; load b into the acc
211+  ABE7 FE 10            cp 16
212+  ABE9 CA 0A AC         jp z,control_pl_moveleft0 ; are we at the edge of the screen
213+  ABEC CD 3E AD         call control_checkcanmove_left ; check we can move down, e will be 1 if we can
214+  ABEF F5               push af
215+  ABF0 7B               ld a,e                  ; put e in a
216+  ABF1 FE 00            cp 0
217+  ABF3 CA 09 AC         jp z,control_pl_moveleft1 ; don't move if we can't
218+  ABF6 21 78 AD         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
219+  ABF9 3E 03            ld a,3
220+  ABFB 77               ld (hl),a
221+  ABFC F1               pop af
222+  ABFD D6 01            sub 1                    ; subtract 2
223+  ABFF D6 01            sub 1
224+  AC01 47               ld b,a                  ; load back to c
225+  AC02 ED 43 73 AD      ld (player),bc          ; load back to player
226+  AC06 C3 0A AC         jp control_pl_moveleft0
227+  AC09              control_pl_moveleft1:
228+  AC09 F1               pop af
229+  AC0A              control_pl_moveleft0:
230+  AC0A 3E 01            ld a,1
231+  AC0C 32 75 AD         ld (player+2),a        ; set direction to left
232+  AC0F C1               pop bc
233+  AC10 C9               ret
234+  AC11              ;
235+  AC11              ; Moves the player right
236+  AC11              ;
237+  AC11              control_pl_moveright:
238+  AC11 C5               push bc
239+  AC12 ED 4B 73 AD      ld bc,(player)          ; get the current coords, b horiz, c vert
240+  AC16 78               ld a,b                  ; load b into the acc
241+  AC17 FE F0            cp 240
242+  AC19 CA 38 AC         jp z,control_pl_moveright0 ; are we at the edge of the screen
243+  AC1C CD 16 AD         call control_checkcanmove_right ; check we can move down, e will be 1 if we can
244+  AC1F F5               push af
245+  AC20 7B               ld a,e                  ; put e in a
246+  AC21 FE 00            cp 0
247+  AC23 CA 37 AC         jp z,control_pl_moveright1 ; don't move if we can't
248+  AC26 21 78 AD         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
249+  AC29 3E 03            ld a,3
250+  AC2B 77               ld (hl),a
251+  AC2C F1               pop af
252+  AC2D 3C               inc a                   ; add 2
253+  AC2E 3C               inc a
254+  AC2F 47               ld b,a                  ; load back to b
255+  AC30 ED 43 73 AD      ld (player),bc          ; load back to player
256+  AC34 C3 38 AC         jp control_pl_moveright0
257+  AC37              control_pl_moveright1:
258+  AC37 F1               pop af                  ; restore af if needed
259+  AC38              control_pl_moveright0:
260+  AC38 3E 02            ld a,2
261+  AC3A 32 75 AD         ld (player+2),a        ; set direction to right
262+  AC3D C1               pop bc
263+  AC3E C9               ret
264+  AC3F
265+  AC3F              ;
266+  AC3F              ; Scrolls the screen down
267+  AC3F              ;
268+  AC3F              control_scroll_down:
269+  AC3F F5               push af
270+  AC40 3E 07            ld a,7
271+  AC42 32 74 A1         ld (screen_offset),a
272+  AC45 F1               pop af
273+  AC46 C9               ret
274+  AC47
275+  AC47              ;
276+  AC47              ; Scrolls the screen up
277+  AC47              ;
278+  AC47              control_scroll_up:
279+  AC47 F5               push af
280+  AC48 3E 00            ld a,0
281+  AC4A 32 74 A1         ld (screen_offset),a
282+  AC4D F1               pop af
283+  AC4E C9               ret
284+  AC4F
285+  AC4F              ;
286+  AC4F              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
287+  AC4F              ; Inputs:
288+  AC4F              ; hl - memory location of top pixel row
289+  AC4F              ; bc - screen coords, b horiz, c vert
290+  AC4F              ; Outputs:
291+  AC4F              ; e - 0 if not empty, 1 if empty
292+  AC4F              ;
293+  AC4F              control_spaceisempty:
294+  AC4F 3E 08            ld a,8                          ; 8 rows to check
295+  AC51              control_spaceisempty0:
296+  AC51 08               ex af,af'                       ; store the loop counter
297+  AC52 7E               ld a,(hl)                       ; get current pixel row
298+  AC53 FE 00            cp 0
299+  AC55 C2 69 AC         jp nz, control_spaceisempty1    ; row is not empty, can't move here
300+  AC58 79               ld a,c                          ; load the vertical coord
301+  AC59 3C               inc a                           ; next row down
302+  AC5A 11 20 00         ld de,32
303+  AC5D 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
304+  AC5E 4F               ld c,a                          ; copy vert coord back to c
305+  AC5F 08               ex af,af'                       ; get loop counter back
306+  AC60 3D               dec a                           ; decrease loop counter
307+  AC61 C2 51 AC         jp nz, control_spaceisempty0
308+  AC64 16 00            ld d,0
309+  AC66 1E 01            ld e,1                          ; got to end, so space is empty
310+  AC68 C9               ret
311+  AC69              control_spaceisempty1:
312+  AC69 16 00            ld d,0
313+  AC6B 1E 00            ld e,0                          ; returning false, ie space not empty
314+  AC6D C9               ret
315+  AC6E
316+  AC6E              ;
317+  AC6E              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
318+  AC6E              ; Inputs:
319+  AC6E              ; hl - memory location of top pixel row
320+  AC6E              ; bc - screen coords, b horiz, c vert
321+  AC6E              ; Outputs:
322+  AC6E              ; e - 0 if not empty, 1 if empty
323+  AC6E              ;
324+  AC6E              control_linebelowisempty:
325+  AC6E 7E               ld a,(hl)                       ; get current pixel row
326+  AC6F FE 00            cp 0
327+  AC71 C2 79 AC         jp nz, control_linebelowisempty1    ; row is not empty, can't move here
328+  AC74 16 00            ld d,0
329+  AC76 1E 01            ld e,1                          ; got to end, so space is empty
330+  AC78 C9               ret
331+  AC79              control_linebelowisempty1:
332+  AC79 16 00            ld d,0
333+  AC7B 1E 00            ld e,0                          ; returning false, ie space not empty
334+  AC7D C9               ret
335+  AC7E
336+  AC7E              ;
337+  AC7E              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
338+  AC7E              ; Inputs:
339+  AC7E              ; hl - memory location of top pixel row
340+  AC7E              ; bc - screen coords, b horiz, c vert
341+  AC7E              ; Outputs:
342+  AC7E              ; e - 0 if not empty, 1 if empty
343+  AC7E              ;
344+  AC7E              control_lineaboveisempty:
345+  AC7E 7E               ld a,(hl)                       ; get current pixel row
346+  AC7F FE 00            cp 0
347+  AC81 C2 89 AC         jp nz, control_lineaboveisempty1    ; row is not empty, can't move here
348+  AC84 16 00            ld d,0
349+  AC86 1E 01            ld e,1                          ; got to end, so space is empty
350+  AC88 C9               ret
351+  AC89              control_lineaboveisempty1:
352+  AC89 16 00            ld d,0
353+  AC8B 1E 00            ld e,0                          ; returning false, ie space not empty
354+  AC8D C9               ret
355+  AC8E
356+  AC8E              ;
357+  AC8E              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
358+  AC8E              ; Inputs:
359+  AC8E              ; hl - memory location of top pixel row
360+  AC8E              ; bc - screen coords, b horiz, c vert
361+  AC8E              ; Outputs:
362+  AC8E              ; none - puts player into digging mode
363+  AC8E              ;
364+  AC8E              control_spaceisdiggable:
365+  AC8E 3E 08            ld a,8                          ; 8 rows to check
366+  AC90              control_spaceisdiggable0:
367+  AC90 08               ex af,af'                       ; store the loop counter
368+  AC91 7E               ld a,(hl)                       ; get current pixel row
369+  AC92 FE 00            cp 0
370+  AC94 CA A4 AC         jp z, control_spaceisdiggable2  ; row is empty, can dig here
371+  AC97 FE 55            cp 85
372+  AC99 CA A4 AC         jp z, control_spaceisdiggable2  ; row is dirt, can dig here
373+  AC9C FE AA            cp 170
374+  AC9E CA A4 AC         jp z, control_spaceisdiggable2  ; row is dirt, can dig here
375+  ACA1 C3 BC AC         jp control_spaceisdiggable1     ; otherwise, stop checking
376+  ACA4              control_spaceisdiggable2:
377+  ACA4 79               ld a,c                          ; load the vertical coord
378+  ACA5 3C               inc a                           ; next row down
379+  ACA6 11 20 00         ld de,32
380+  ACA9 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
381+  ACAA 4F               ld c,a                          ; copy vert coord back to c
382+  ACAB 08               ex af,af'                       ; get loop counter back
383+  ACAC 3D               dec a                           ; decrease loop counter
384+  ACAD C2 90 AC         jp nz, control_spaceisdiggable0
385+  ACB0 21 79 AD         ld hl,player+6
386+  ACB3 36 01            ld (hl),1                       ; set the player into digging mode
387+  ACB5 23               inc hl
388+  ACB6 36 32            ld (hl),50                      ; set the number of frame to dig for
389+  ACB8 23               inc hl
390+  ACB9 36 08            ld (hl),8                       ; set the number of pixels to dig
391+  ACBB C9               ret
392+  ACBC              control_spaceisdiggable1:
393+  ACBC 21 79 AD         ld hl,player+6
394+  ACBF 36 00            ld (hl),0                       ; set the player out of digging mode
395+  ACC1 C9               ret
396+  ACC2
397+  ACC2
398+  ACC2              ;
399+  ACC2              ; Checks if the player can move down
400+  ACC2              ; Inputs:
401+  ACC2              ; bc - player coords, b horiz, c vert
402+  ACC2              ; Outputs:
403+  ACC2              ; de - 1 can move
404+  ACC2              control_checkcanmove_down:
405+  ACC2 F5               push af
406+  ACC3 C5               push bc
407+  ACC4 CD 8E A3         call sprites_scadd              ; get the memory location of cell into de
408+  ACC7 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
409+  ACC9 24               inc h                       ; memory location of cell beneath now in hl
410+  ACCA CD 6E AC         call control_linebelowisempty       ; check space is empty
411+  ACCD 7B               ld a,e                          ; check space empty flag
412+  ACCE FE 00            cp 0
413+  ACD0 CA D9 AC         jp z, control_checkcanmove_down1 ; can't move
414+  ACD3 CD A6 AD         call player_justmoved
415+  ACD6 C1               pop bc
416+  ACD7 F1               pop af
417+  ACD8 C9               ret
418+  ACD9              control_checkcanmove_down1:
419+  ACD9 C1               pop bc
420+  ACDA CD 8E A3         call sprites_scadd              ; get the memory location of cell into de
421+  ACDD 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
422+  ACDF 24               inc h
423+  ACE0 C5               push bc
424+  ACE1 CD 8E AC         call control_spaceisdiggable    ; can't move here, but can we dig
425+  ACE4 11 00 00         ld de,0
426+  ACE7 C1               pop bc
427+  ACE8 F1               pop af
428+  ACE9 C9               ret
429+  ACEA
430+  ACEA              ;
431+  ACEA              ; Checks if the player can move up
432+  ACEA              ; Inputs:
433+  ACEA              ; bc - player coords, b horiz, c vert
434+  ACEA              ; Outputs:
435+  ACEA              ; de - 1 can move
436+  ACEA              control_checkcanmove_up:
437+  ACEA F5               push af
438+  ACEB C5               push bc
439+  ACEC CD 8E A3         call sprites_scadd              ; get the memory location of cell into de
440+  ACEF 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
441+  ACF1 11 20 00         ld de,32
442+  ACF4 ED 52            sbc hl,de                       ; memory location of line above now in hl
443+  ACF6 CD 7E AC         call control_lineaboveisempty       ; check space is empty
444+  ACF9 7B               ld a,e                          ; check space empty flag
445+  ACFA FE 00            cp 0
446+  ACFC CA 07 AD         jp z, control_checkcanmove_up1 ; can't move
447+  ACFF 1E 01            ld e,1
448+  AD01 CD A6 AD         call player_justmoved
449+  AD04 C1               pop bc
450+  AD05 F1               pop af
451+  AD06 C9               ret
452+  AD07              control_checkcanmove_up1:
453+  AD07 C1               pop bc
454+  AD08 CD 8E A3         call sprites_scadd              ; get the memory location of cell into de
455+  AD0B 25               dec h                        ; look at cell directly above (sub 256)
456+  AD0C C5               push bc
457+  AD0D CD 8E AC         call control_spaceisdiggable    ; can't move here, but can we dig
458+  AD10 11 00 00         ld de,0
459+  AD13 C1               pop bc
460+  AD14 F1               pop af
461+  AD15 C9               ret
462+  AD16
463+  AD16              ;
464+  AD16              ; Checks if the player can move right
465+  AD16              ; Inputs:
466+  AD16              ; bc - player coords, b horiz, c vert
467+  AD16              ; Outputs:
468+  AD16              ; de - 1 can move
469+  AD16              control_checkcanmove_right:
470+  AD16 F5               push af
471+  AD17 C5               push bc
472+  AD18 CD 8E A3         call sprites_scadd              ; get the memory location of cell into de
473+  AD1B 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
474+  AD1D 23               inc hl                          ; memory location of cell to the right now in hl
475+  AD1E CD 4F AC         call control_spaceisempty       ; check space is empty
476+  AD21 7B               ld a,e                          ; check space empty flag
477+  AD22 FE 00            cp 0
478+  AD24 CA 2D AD         jp z, control_checkcanmove_right1 ; can't move
479+  AD27 CD A6 AD         call player_justmoved
480+  AD2A C1               pop bc
481+  AD2B F1               pop af
482+  AD2C C9               ret
483+  AD2D              control_checkcanmove_right1:
484+  AD2D C1               pop bc
485+  AD2E CD 8E A3         call sprites_scadd              ; get the memory location of cell into de
486+  AD31 62 6B            ld hl,de
487+  AD33 23               inc hl                          ; memory location of cell to the right now in hl
488+  AD34 C5               push bc
489+  AD35 CD 8E AC         call control_spaceisdiggable    ; can't move here, but can we dig
490+  AD38 11 00 00         ld de,0
491+  AD3B C1               pop bc
492+  AD3C F1               pop af
493+  AD3D C9               ret
494+  AD3E
495+  AD3E              ;
496+  AD3E              ; Checks if the player can move left
497+  AD3E              ; Inputs:
498+  AD3E              ; bc - player coords, b horiz, c vert
499+  AD3E              ; Outputs:
500+  AD3E              ; de - 1 can move
501+  AD3E              control_checkcanmove_left:
502+  AD3E F5               push af
503+  AD3F C5               push bc
504+  AD40 CD 8E A3         call sprites_scadd              ; get the memory location of cell into de
505+  AD43 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
506+  AD45 2B               dec hl                          ; memory location of cell to the right now in hl
507+  AD46 CD 4F AC         call control_spaceisempty       ; check space is empty
508+  AD49 7B               ld a,e                          ; check space empty flag
509+  AD4A FE 00            cp 0
510+  AD4C CA 55 AD         jp z, control_checkcanmove_left1 ; can't move
511+  AD4F CD A6 AD         call player_justmoved
512+  AD52 C1               pop bc
513+  AD53 F1               pop af
514+  AD54 C9               ret
515+  AD55              control_checkcanmove_left1:
516+  AD55 C1               pop bc
517+  AD56 CD 8E A3         call sprites_scadd              ; get the memory location of cell into de
518+  AD59 62 6B            ld hl,de
519+  AD5B 2B               dec hl                          ; memory location of cell to the right now in hl
520+  AD5C C5               push bc
521+  AD5D CD 8E AC         call control_spaceisdiggable    ; can't move here, but can we dig
522+  AD60 11 00 00         ld de,0
523+  AD63 C1               pop bc
524+  AD64 F1               pop af
525+  AD65 C9               ret
526+  AD66
527+  AD66
# file closed: game/control.asm
 31   AD66                  include "game\game.asm"
# file opened: game/game.asm
  1+  AD66              ;
  2+  AD66              ; The current frame count, incremented each frame
  3+  AD66              ;
  4+  AD66              game_framenumber:
  5+  AD66 00               defb    0
  6+  AD67
  7+  AD67              ;
  8+  AD67              ; Increment frame number by 1
  9+  AD67              ;
 10+  AD67              game_incrementframe:
 11+  AD67 3A 66 AD         ld a,(game_framenumber)
 12+  AD6A 3C               inc a
 13+  AD6B 32 66 AD         ld (game_framenumber),a
 14+  AD6E C9               ret
 15+  AD6F
 16+  AD6F              ;
 17+  AD6F              ; Returns current frame
 18+  AD6F              ; Outputs:
 19+  AD6F              ; a - current frame
 20+  AD6F              ;
 21+  AD6F              game_getcurrentframe:
 22+  AD6F 3A 66 AD         ld a,(game_framenumber)
 23+  AD72 C9               ret
# file closed: game/game.asm
 32   AD73                  include "game\player.asm"
# file opened: game/player.asm
  1+  AD73              ;
  2+  AD73              ;   Data for current player
  3+  AD73              ;   horiz,vert,dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count,move remaining, is digging (0 no), digging count, pixels to dig
  4+  AD73              player:
  5+  AD73 00 00 02 00      defb    0,0,2,0,1,0,0,0,0
  5+  AD77 01 00 00 00
  5+  AD7B 00
  6+  AD7C              ;
  7+  AD7C              ; Initializes a player
  8+  AD7C              ;
  9+  AD7C              player_init:
 10+  AD7C ED 4B 10 80      ld bc,(start_coord)
 11+  AD80 ED 43 73 AD      ld (player),bc
 12+  AD84 C9               ret
 13+  AD85
 14+  AD85              ;
 15+  AD85              ; Draws the player at the current position or deletes them
 16+  AD85              ;
 17+  AD85              player_drawplayer:
 18+  AD85 3A 75 AD         ld a,(player+2)             ; get the current direction
 19+  AD88 FE 03            cp 3
 20+  AD8A C2 8F AD         jp nz,player_drawplayer0
 21+  AD8D 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
 22+  AD8F              player_drawplayer0:
 23+  AD8F 5F               ld e,a                      ; store in e
 24+  AD90 3A 76 AD         ld a,(player+3)             ; get the current frame
 25+  AD93 83               add a,e
 26+  AD94 07               rlca
 27+  AD95 07               rlca
 28+  AD96 07               rlca                        ; multiply by eight
 29+  AD97 6F               ld l,a
 30+  AD98 26 00            ld h,0
 31+  AD9A 11 A7 A9         ld de,player_sprite
 32+  AD9D 19               add hl,de                   ; load hl with the location of the player sprite data
 33+  AD9E ED 4B 73 AD      ld bc,(player)         ; load bc with the start coords
 34+  ADA2 CD 4B A3         call sprites_drawsprite     ; call the routine to draw the sprite
 35+  ADA5 C9               ret
 36+  ADA6
 37+  ADA6              ;
 38+  ADA6              ; Runs after the player just moved. Changes animation frame if required
 39+  ADA6              ;
 40+  ADA6              player_justmoved:
 41+  ADA6 D9               exx
 42+  ADA7 3A 77 AD         ld a,(player+4)             ; get the transition count
 43+  ADAA FE 00            cp 0
 44+  ADAC CA B2 AD         jp z, player_justmoved2     ; if zero reset and change the frame
 45+  ADAF C3 CC AD         jp player_justmoved1       ; otherwise decrease and continue
 46+  ADB2              player_justmoved2:
 47+  ADB2                  ; reset and change frame in here
 48+  ADB2 3E 01            ld a,1
 49+  ADB4 32 77 AD         ld (player+4),a            ; reset back to whatever
 50+  ADB7 3A 76 AD         ld a,(player+3)             ; load the frame
 51+  ADBA FE 03            cp 3                       ; flip between 3 and 0
 52+  ADBC C2 C4 AD         jp nz, player_justmoved4
 53+  ADBF 3E 00            ld a,0
 54+  ADC1 C3 C6 AD         jp player_justmoved5
 55+  ADC4              player_justmoved4:
 56+  ADC4 3E 03            ld a,3
 57+  ADC6              player_justmoved5:
 58+  ADC6 32 76 AD         ld (player+3),a           ; save back
 59+  ADC9 C3 D0 AD         jp player_justmoved3
 60+  ADCC              player_justmoved1:
 61+  ADCC                  ; decrease count
 62+  ADCC 3D               dec a
 63+  ADCD 32 77 AD         ld (player+4),a
 64+  ADD0              player_justmoved3:
 65+  ADD0 D9               exx;
 66+  ADD1 C9               ret
# file closed: game/player.asm
 33   ADD2                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  ADD2              ;
  2+  ADD2              ; Ship initial position: vert,horiz
  3+  ADD2              ;
  4+  ADD2              ship_initpos:
  5+  ADD2 00 24            defb 0,36
  6+  ADD4              ship_initpos2:
  7+  ADD4 00 00            defb 0,0
  8+  ADD6              ship_frame:
  9+  ADD6 00               defb 0
 10+  ADD7              ;
 11+  ADD7              ; The current memory location
 12+  ADD7              ;
 13+  ADD7              ship_current_sprite:
 14+  ADD7 00 00            defb 0,0
 15+  ADD9
 16+  ADD9              ship_current_coords:
 17+  ADD9 00 00            defb 0,0
 18+  ADDB
 19+  ADDB              ;
 20+  ADDB              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 21+  ADDB              ;
 22+  ADDB              ship_land:
 23+  ADDB ED 4B D2 AD      ld bc,(ship_initpos)
 24+  ADDF ED 43 D4 AD      ld (ship_initpos2),bc        ; save the initial position for later use
 25+  ADE3 1E 00            ld e,0                      ; store a flag to track first time round
 26+  ADE5 06 09            ld b,9                      ; move down 8 pixels
 27+  ADE7              ship_land0:
 28+  ADE7 C5               push bc
 29+  ADE8 7B               ld a,e
 30+  ADE9 D5               push de                     ; store de for next time round
 31+  ADEA FE 01            cp 1                        ; check first time flag
 32+  ADEC C2 01 AE         jp nz,ship_land1             ; don't draw over previous one if first time
 33+  ADEF CD 5A AE         call ship_draw_full         ; delete old one
 34+  ADF2 CD 3E AE         call ship_change_frame      ; increment the frame
 35+  ADF5 ED 4B D4 AD      ld bc,(ship_initpos2)       ; get the current coords
 36+  ADF9 81 C6 01         add c,1                     ; move down one pixels
 37+  ADFC 4F               ld c,a
 38+  ADFD ED 43 D4 AD      ld (ship_initpos2),bc
 39+  AE01              ship_land1:
 40+  AE01 CD 5A AE         call ship_draw_full         ; draw the ship
 41+  AE04 CD 53 AE         call ship_draw_screen
 42+  AE07 D1               pop de
 43+  AE08 1E 01            ld e,1
 44+  AE0A C1               pop bc
 45+  AE0B 10 DA            djnz ship_land0             ; repeat for downward movement
 46+  AE0D                  ; done moving down
 47+  AE0D                  ; now move across
 48+  AE0D CD 85 AD         call player_drawplayer      ; draw player
 49+  AE10 CD 5A AE         call ship_draw_full         ; delete old one
 50+  AE13 1E 00            ld e,0                      ; store a flag to track first time round
 51+  AE15 06 14            ld b,20                      ; move back 20 pixels pixels
 52+  AE17              ship_land3:
 53+  AE17 C5               push bc
 54+  AE18 7B               ld a,e
 55+  AE19 D5               push de                     ; store de for next time round
 56+  AE1A FE 01            cp 1                        ; check first time flag
 57+  AE1C C2 31 AE         jp nz,ship_land2             ; don't draw over previous one if first time
 58+  AE1F CD 5A AE         call ship_draw_full         ; delete old one
 59+  AE22 CD 3E AE         call ship_change_frame      ; increment the frame
 60+  AE25 ED 4B D4 AD      ld bc,(ship_initpos2)       ; get the current coords
 61+  AE29 78               ld a,b
 62+  AE2A D6 01            sub 1                       ; move back one pixels
 63+  AE2C 47               ld b,a
 64+  AE2D ED 43 D4 AD      ld (ship_initpos2),bc
 65+  AE31              ship_land2:
 66+  AE31 CD 5A AE         call ship_draw_full         ; draw the ship
 67+  AE34 CD 53 AE         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 68+  AE37 D1               pop de
 69+  AE38 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 70+  AE3A C1               pop bc
 71+  AE3B 10 DA            djnz ship_land3             ; repeat for vertical movement
 72+  AE3D C9               ret
 73+  AE3E
 74+  AE3E              ;
 75+  AE3E              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
 76+  AE3E              ;
 77+  AE3E              ship_change_frame:
 78+  AE3E F5               push af
 79+  AE3F 3A D6 AD         ld a,(ship_frame)
 80+  AE42 FE 00            cp 0
 81+  AE44 CA 4C AE         jp z,ship_change_frame0
 82+  AE47 3E 00            ld a,0                      ; flip to 0
 83+  AE49 C3 4E AE         jp ship_change_frame1
 84+  AE4C              ship_change_frame0:
 85+  AE4C 3E 20            ld a,32                      ; flip to 32
 86+  AE4E              ship_change_frame1:
 87+  AE4E 32 D6 AD         ld (ship_frame),a            ; save the frame
 88+  AE51 F1               pop af
 89+  AE52 C9               ret
 90+  AE53
 91+  AE53              ship_draw_screen:
 92+  AE53 76               halt
 93+  AE54 F3               di
 94+  AE55 CD 75 A1         call screen_buffertoscreen  ; copy buffer to screen
 95+  AE58 FB               ei                          ; enable interupts
 96+  AE59 C9               ret
 97+  AE5A
 98+  AE5A              ship_draw_full:
 99+  AE5A 21 E7 A9         ld hl,ship_sprite
100+  AE5D ED 4B D4 AD      ld bc,(ship_initpos2)         ; load bc with the start coords
101+  AE61 22 D7 AD         ld (ship_current_sprite),hl  ; put into memory
102+  AE64 ED 43 D9 AD      ld (ship_current_coords),bc  ; put into memory
103+  AE68 CD 87 AE         call ship_draw
104+  AE6B 08               ex af,af'
105+  AE6C 3A D6 AD         ld a,(ship_frame)            ; get the animation frame
106+  AE6F 16 00            ld d,0
107+  AE71 5F               ld e,a
108+  AE72 19               add hl,de
109+  AE73 22 D7 AD         ld (ship_current_sprite),hl  ; put into memory
110+  AE76 08               ex af,af'
111+  AE77 ED 4B D4 AD      ld bc,(ship_initpos2)         ; load bc with the start coords
112+  AE7B 81 C6 08         add c,8                      ; move one line down
113+  AE7E 4F               ld c,a
114+  AE7F ED 43 D9 AD      ld (ship_current_coords),bc  ; put into memory
115+  AE83 CD 87 AE         call ship_draw
116+  AE86 C9               ret
117+  AE87
118+  AE87              ;
119+  AE87              ; Draw the ship
120+  AE87              ; Inputs:
121+  AE87              ; None, all in memory
122+  AE87              ;
123+  AE87              ship_draw:
124+  AE87 3E 04            ld a,4                              ; 4 pieces per half
125+  AE89              ship_draw0:
126+  AE89 F5               push af
127+  AE8A 2A D7 AD         ld hl,(ship_current_sprite)
128+  AE8D ED 4B D9 AD      ld bc,(ship_current_coords)         ; load bc with the start coords
129+  AE91 CD 4B A3         call sprites_drawsprite
130+  AE94 2A D7 AD         ld hl,(ship_current_sprite)
131+  AE97 ED 4B D9 AD      ld bc,(ship_current_coords)         ; load bc with the start coords
132+  AE9B 11 08 00         ld de,8
133+  AE9E 19               add hl,de
134+  AE9F 80 C6 08         add b,8
135+  AEA2 47               ld b,a
136+  AEA3 22 D7 AD         ld (ship_current_sprite),hl         ; put into memory
137+  AEA6 ED 43 D9 AD      ld (ship_current_coords),bc         ; put into memory
138+  AEAA F1               pop af
139+  AEAB 3D               dec a
140+  AEAC FE 00            cp 0
141+  AEAE C2 89 AE         jp nz,ship_draw0
142+  AEB1
143+  AEB1 C9               ret
144+  AEB2
# file closed: game/ship.asm
 34   AEB2                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  AEB2              ;
  2+  AEB2              ; tank initial position: vert,horiz
  3+  AEB2              ;
  4+  AEB2              tank_initpos:
  5+  AEB2 10 D0            defb 16,208
  6+  AEB4              tank_initpos2:
  7+  AEB4 00 00            defb 0,0
  8+  AEB6              tank_frame:
  9+  AEB6 00               defb 0
 10+  AEB7              tank_anim:
 11+  AEB7 11               defb 17
 12+  AEB8              ;
 13+  AEB8              ; The current memory location
 14+  AEB8              ;
 15+  AEB8              tank_current_sprite:
 16+  AEB8 00 00            defb 0,0
 17+  AEBA
 18+  AEBA              tank_current_coords:
 19+  AEBA 00 00            defb 0,0
 20+  AEBC
 21+  AEBC              ;
 22+  AEBC              ; Initialise the tank
 23+  AEBC              ;
 24+  AEBC              tank_init:
 25+  AEBC ED 4B B2 AE      ld bc,(tank_initpos)
 26+  AEC0 ED 43 B4 AE      ld (tank_initpos2),bc       ; save the initial position for later use
 27+  AEC4 C9               ret
 28+  AEC5
 29+  AEC5              ;
 30+  AEC5              ;   Draw and move the tank
 31+  AEC5              ;   Start processing at frame 200
 32+  AEC5              ;   Don't move if anim is zero
 33+  AEC5              ;   Decrement frame if moved
 34+  AEC5              ;
 35+  AEC5              tank_process:
 36+  AEC5 3A B7 AE         ld a,(tank_anim)
 37+  AEC8 FE 00            cp 0
 38+  AECA C8               ret z                       ; return if we've already moved
 39+  AECB CD 6F AD         call game_getcurrentframe   ; get the current frame number into a
 40+  AECE FE 4B            cp 75
 41+  AED0 D8               ret c                      ; return if the frame number is below 100
 42+  AED1 CD DC AE         call tank_move              ; move tank if not
 43+  AED4 3A B7 AE         ld a,(tank_anim)
 44+  AED7 3D               dec a
 45+  AED8 32 B7 AE         ld (tank_anim),a            ; decrease the anim count
 46+  AEDB C9               ret
 47+  AEDC
 48+  AEDC              tank_move:
 49+  AEDC ED 4B B4 AE      ld bc,(tank_initpos2)
 50+  AEE0 C5               push bc
 51+  AEE1 3A B7 AE         ld a,(tank_anim)
 52+  AEE4 FE 11            cp 17                       ; check first time flag
 53+  AEE6 CA F8 AE         jp z,tank_move1         ; don't draw over previous one if first time
 54+  AEE9 CD FD AE         call tank_draw_full         ; delete old one
 55+  AEEC ED 4B B4 AE      ld bc,(tank_initpos2)       ; get the current coords
 56+  AEF0 78               ld a,b
 57+  AEF1 D6 01            sub 1                       ; move back one pixels
 58+  AEF3 47               ld b,a
 59+  AEF4 ED 43 B4 AE      ld (tank_initpos2),bc
 60+  AEF8              tank_move1:
 61+  AEF8 CD FD AE         call tank_draw_full         ; draw the tank
 62+  AEFB C1               pop bc
 63+  AEFC C9               ret
 64+  AEFD
 65+  AEFD              tank_draw_full:
 66+  AEFD 21 47 AA         ld hl,tank_sprite
 67+  AF00 ED 4B B4 AE      ld bc,(tank_initpos2)         ; load bc with the start coords
 68+  AF04 22 B8 AE         ld (tank_current_sprite),hl  ; put into memory
 69+  AF07 ED 43 BA AE      ld (tank_current_coords),bc  ; put into memory
 70+  AF0B CD 2A AF         call tank_draw
 71+  AF0E 08               ex af,af'
 72+  AF0F 3A B6 AE         ld a,(tank_frame)            ; get the animation frame
 73+  AF12 16 00            ld d,0
 74+  AF14 5F               ld e,a
 75+  AF15 19               add hl,de
 76+  AF16 22 B8 AE         ld (tank_current_sprite),hl  ; put into memory
 77+  AF19 08               ex af,af'
 78+  AF1A ED 4B B4 AE      ld bc,(tank_initpos2)         ; load bc with the start coords
 79+  AF1E 81 C6 08         add c,8                      ; move one line down
 80+  AF21 4F               ld c,a
 81+  AF22 ED 43 BA AE      ld (tank_current_coords),bc  ; put into memory
 82+  AF26 CD 2A AF         call tank_draw
 83+  AF29 C9               ret
 84+  AF2A
 85+  AF2A              ;
 86+  AF2A              ; Draw the tank
 87+  AF2A              ; Inputs:
 88+  AF2A              ; None, all in memory
 89+  AF2A              ;
 90+  AF2A              tank_draw:
 91+  AF2A 3E 04            ld a,4                              ; 4 pieces per half
 92+  AF2C              tank_draw0:
 93+  AF2C F5               push af
 94+  AF2D 2A B8 AE         ld hl,(tank_current_sprite)
 95+  AF30 ED 4B BA AE      ld bc,(tank_current_coords)         ; load bc with the start coords
 96+  AF34 CD 4B A3         call sprites_drawsprite
 97+  AF37 2A B8 AE         ld hl,(tank_current_sprite)
 98+  AF3A ED 4B BA AE      ld bc,(tank_current_coords)         ; load bc with the start coords
 99+  AF3E 11 08 00         ld de,8
100+  AF41 19               add hl,de
101+  AF42 80 C6 08         add b,8
102+  AF45 47               ld b,a
103+  AF46 22 B8 AE         ld (tank_current_sprite),hl         ; put into memory
104+  AF49 ED 43 BA AE      ld (tank_current_coords),bc         ; put into memory
105+  AF4D F1               pop af
106+  AF4E 3D               dec a
107+  AF4F FE 00            cp 0
108+  AF51 C2 2C AF         jp nz,tank_draw0
109+  AF54
110+  AF54 C9               ret
111+  AF55
# file closed: game/tank.asm
 35   AF55
 36   AF55              ;===========================================================================
 37   AF55              ; main routine - the code execution starts here.
 38   AF55              ; Sets up the new interrupt routine, the memory
 39   AF55              ; banks and jumps to the start loop.
 40   AF55              ;===========================================================================
 41   AF55              main:
 42   AF55
 43   AF55                  ; Setup stack
 44   AF55 31 49 B0         ld sp,stack_top
 45   AF58
 46   AF58                  ; Draw the title screen
 47   AF58                  ;call titlescreen_show
 48   AF58
 49   AF58 CD 00 80         call init_start
 50   AF5B CD 1B A2         call screen_draw
 51   AF5E CD 7C AD         call player_init
 52   AF61 CD DB AD         call ship_land              ; land the ship
 53   AF64 CD BC AE         call tank_init
 54   AF67
 55   AF67              mloop:
 56   AF67 76               halt
 57   AF68 F3               di
 58   AF69 CD 75 A1         call screen_buffertoscreen  ; copy buffer to screen
 59   AF6C FB               ei                          ; enable interupts
 60   AF6D
 61   AF6D CD 85 AD         call player_drawplayer      ; delete player
 62   AF70 CD 8F AA         call control_keyboard       ; check keyboard
 63   AF73 CD 85 AD         call player_drawplayer      ; draw player
 64   AF76 CD C5 AE         call tank_process           ; prcoess the tank
 65   AF79
 66   AF79 CD 67 AD         call game_incrementframe    ; increment the game frame
 67   AF7C
 68   AF7C C3 67 AF         jp mloop
 69   AF7F
 70   AF7F              ;===========================================================================
 71   AF7F              ; Stack.
 72   AF7F              ;===========================================================================
 73   AF7F
 74   AF7F              ; Stack: this area is reserved for the stack
 75   AF7F              STACK_SIZE: equ 100    ; in words
 76   AF7F
 77   AF7F              ; Reserve stack space
 78   AF7F 00 00            defw 0  ; WPMEM, 2
 79   AF81              stack_bottom:
 80   AF81 00 00 00...      defs    STACK_SIZE*2, 0
 81   B049              stack_top:
 82   B049 00 00            defw 0  ; WPMEM, 2
 83   B04B
 84   B04B                     SAVESNA "ThePit.sna", main
# file closed: main.asm
