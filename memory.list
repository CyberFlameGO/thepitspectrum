# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 67 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 71 A7         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 72 A7         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 A7 A5         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD 02 BB         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8051 C9               ret                 ; key was pressed.
 53+  8052
 54+  8052              ;
 55+  8052              ; Waits number of frames for keypress. If got, returns 1, if not 0
 56+  8052              ; Inputs:
 57+  8052              ; a - number of frames to waits
 58+  8052              ; Ouputs:
 59+  8052              ; e - 0 not pressed, 1 pressed
 60+  8052              utilities_waitforkey_forframes:
 61+  8052 21 08 5C         ld hl,23560         ; LAST K system variable.
 62+  8055 36 00            ld (hl),0           ; put null value there.
 63+  8057 47               ld b,a              ; number of frames to wait
 64+  8058              utilities_waitforkey_forframes0:
 65+  8058 7E               ld a,(hl)           ; new value of LAST K.
 66+  8059 FE 00            cp 0                ; is it still zero?
 67+  805B 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 68+  805D 1E 01            ld e,1              ; set the pressed flag
 69+  805F C9               ret                 ; key was pressed.
 70+  8060              utilities_waitforkey_forframes1:
 71+  8060 76               halt                ; wait for frame
 72+  8061 76               halt                ; wait for frame
 73+  8062 10 F4            djnz utilities_waitforkey_forframes0 ; loop again
 74+  8064 1E 00            ld e,0              ; nothing pressed in time
 75+  8066 C9               ret
 76+  8067
 77+  8067              ;
 78+  8067              ; Clears the screen
 79+  8067              ; Inputs:
 80+  8067              ; a - attribute colour
 81+  8067              utilities_clearscreen:
 82+  8067 76               halt
 83+  8068 21 00 58         ld hl,22528         ; attr
 84+  806B 11 01 58         ld de,22529         ; attr+1
 85+  806E 01 FF 02         ld bc,767
 86+  8071 77               ld (hl),a
 87+  8072 ED B0            ldir
 88+  8074
 89+  8074 21 00 40         ld hl, 16384        ;pixels
 90+  8077 11 01 40         ld de, 16385        ;pixels + 1
 91+  807A 01 FF 17         ld bc, 6143         ;pixels area length - 1
 92+  807D 36 00            ld (hl), 0          ;set first byte to '0'
 93+  807F ED B0            ldir                ;copy bytes
 94+  8081
 95+  8081 C9               ret
 96+  8082
 97+  8082              ;
 98+  8082              ; Wait for a number of frames
 99+  8082              ; Inputs:
100+  8082              ; b - number of frames
101+  8082              utilities_pauseforframes:
102+  8082 76               halt
103+  8083 10 FD            djnz utilities_pauseforframes
104+  8085 C9               ret
105+  8086
106+  8086              utilities_readkey:
107+  8086 21 A6 80         LD HL,utilties_keymap              ; Point HL at the keyboard list
108+  8089 16 08            LD D,8                                  ; This is the number of ports (rows) to check
109+  808B 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
110+  808D              utilities_readkey_0:
111+  808D 46               LD B,(HL)                               ; Get the keyboard port address from table
112+  808E 23               INC HL                                  ; Increment to list of keys
113+  808F ED 78            IN A,(C)                                ; Read the row of keys in
114+  8091 E6 1F            AND $1F                                     ; We are only interested in the first five bits
115+  8093 1E 05            LD E,5                                  ; This is the number of keys in the row
116+  8095              utilities_readkey_1:
117+  8095 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
118+  8097 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
119+  8099 23               INC HL                                  ; Go to next table address
120+  809A 1D               DEC E                                   ; Decrement key loop counter
121+  809B 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
122+  809D 15               DEC D                                   ; Decrement row loop counter
123+  809E 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
124+  80A0 A7               AND A                                   ; Clear A (no key found)
125+  80A1 C3 86 80         jp utilities_readkey
126+  80A4              utilities_readkey_2:
127+  80A4 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
128+  80A5 C9               RET
129+  80A6
130+  80A6              utilties_keymap:
131+  80A6 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
131+  80AA 43 56
132+  80AC FD 41 53 44      defb $FD,"A","S","D","F","G"
132+  80B0 46 47
133+  80B2 FB 51 57 45      defb $FB,"Q","W","E","R","T"
133+  80B6 52 54
134+  80B8 F7 31 32 33      defb $F7,"1","2","3","4","5"
134+  80BC 34 35
135+  80BE EF 30 39 38      defb $EF,"0","9","8","7","6"
135+  80C2 37 36
136+  80C4 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
136+  80C8 55 59
137+  80CA BF 23 4C 4B      defb $BF,"#","L","K","J","H"
137+  80CE 4A 48
138+  80D0 7F 20 23 4D      defb $7F," ","#","M","N","B"
138+  80D4 4E 42
139+  80D6
140+  80D6
141+  80D6              ;
142+  80D6              ; Generates a randomish number in the range 0 to e
143+  80D6              ; Inputs:
144+  80D6              ; e - upper value
145+  80D6              ; Outputs:
146+  80D6              ; a - random number
147+  80D6              utilities_randomupper
148+  80D6 3A D8 BA         ld a,(game_framenumber)
149+  80D9 6F               ld l,a
150+  80DA 26 00            ld h,0
151+  80DC 16 00            ld d,0
152+  80DE 42 4B            ld bc,de
153+  80E0              utilities_randomupper0:
154+  80E0 B7               or a
155+  80E1 ED 42            sbc hl,bc
156+  80E3 F2 E0 80         jp p,utilities_randomupper0
157+  80E6 09               add hl,bc
158+  80E7 01 00 00         ld bc,0
159+  80EA 09               add hl,bc
160+  80EB 7D               ld a,l
161+  80EC C9               ret
# file closed: utilities.asm
 22   80ED                  include "strings.asm"
# file opened: strings.asm
  1+  80ED              string_score1:
  2+  80ED 04 00 53 43      defb 4,0,'SCORE1',255
  2+  80F1 4F 52 45 31
  2+  80F5 FF
  3+  80F6              string_scorenumbers1:
  4+  80F6 04 01 30 30      defb 4,1,'000000',255
  4+  80FA 30 30 30 30
  4+  80FE FF
  5+  80FF              string_company:
  6+  80FF 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  8103 4E 54 55 52
  6+  8107 49 FF
  7+  8109              string_credits:
  8+  8109 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  810D 41 59 45 52
  8+  8111 20 31 FF
  9+  8114              string_score2:
 10+  8114 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8118 4F 52 45 32
 10+  811C FF
 11+  811D              string_scorenumbers2:
 12+  811D 16 01 30 30      defb 22,1,'000000',255
 12+  8121 30 30 30 30
 12+  8125 FF
 13+  8126              string_titlescreen_copyright:
 14+  8126 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 14+  812A 39 38 32 20
 14+  812E 20 43 45 4E
 14+  8132 54 55 52 49
 14+  8136 20 49 4E 43
 14+  813A FF
 15+  813B
 16+  813B
 17+  813B              string_alttitlescreen_1:
 18+  813B 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  813F 45 44 49 54
 18+  8143 53 20 31 FF
 19+  8147              string_alttitlescreen_2:
 20+  8147 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  814B 20 20 20 20
 20+  814F 20 20 20 20
 20+  8153 20 54 48 45
 20+  8157 20 4F 42 4A
 20+  815B 45 43 54 FE
 21+  815F 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  8163 20 20 20 20
 21+  8167 20 20 20 20
 21+  816B 4F 46 20 54
 21+  816F 48 49 53 20
 21+  8173 47 41 4D 45
 21+  8177 FE
 22+  8178 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  817C 20 20 20 20
 22+  8180 20 20 20 49
 22+  8184 53 20 54 4F
 22+  8188 20 44 49 47
 22+  818C 20 44 4F 57
 22+  8190 4E FE
 23+  8192 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  8196 20 20 20 20
 23+  819A 20 20 54 4F
 23+  819E 20 54 48 45
 23+  81A2 20 42 4F 54
 23+  81A6 54 4F 4D 20
 23+  81AA 50 49 54 FE
 24+  81AE 00 06 20 20      defb 0,6,'               AND',254
 24+  81B2 20 20 20 20
 24+  81B6 20 20 20 20
 24+  81BA 20 20 20 20
 24+  81BE 20 41 4E 44
 24+  81C2 FE
 25+  81C3 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  81C7 20 20 20 20
 25+  81CB 20 20 43 4F
 25+  81CF 4C 4C 45 43
 25+  81D3 54 20 41 54
 25+  81D7 20 4C 45 41
 25+  81DB 53 54 FE
 26+  81DE 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  81E2 20 20 20 20
 26+  81E6 20 20 20 4F
 26+  81EA 4E 45 20 4C
 26+  81EE 41 52 47 45
 26+  81F2 20 4A 45 57
 26+  81F6 45 4C FE
 27+  81F9 00 09 20 20      defb 0,9,'              THEN',254
 27+  81FD 20 20 20 20
 27+  8201 20 20 20 20
 27+  8205 20 20 20 20
 27+  8209 54 48 45 4E
 27+  820D FE
 28+  820E 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  8212 20 20 20 20
 28+  8216 20 20 20 52
 28+  821A 45 54 55 52
 28+  821E 4E 20 54 4F
 28+  8222 20 53 48 49
 28+  8226 50 FE
 29+  8228 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  822C 20 20 20 20
 29+  8230 20 20 20 54
 29+  8234 48 52 55 20
 29+  8238 55 50 50 45
 29+  823C 52 20 50 49
 29+  8240 54 FF
 30+  8242              string_alttitlescreen_3:
 31+  8242 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  8246 20 20 53 49
 31+  824A 4E 47 4C 45
 31+  824E 20 42 4F 4E
 31+  8252 55 53 20 20
 31+  8256 35 30 30 30
 31+  825A 20 50 4F 49
 31+  825E 4E 54 53 FE
 32+  8262 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  8266 20 20 20 20
 32+  826A 43 4F 4C 4C
 32+  826E 45 43 54 20
 32+  8272 31 20 4C 41
 32+  8276 52 47 45 20
 32+  827A 4A 45 57 45
 32+  827E 4C FE
 33+  8280 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  8284 20 20 20 20
 33+  8288 20 41 4E 44
 33+  828C 20 52 45 54
 33+  8290 55 52 4E 20
 33+  8294 54 4F 20 53
 33+  8298 48 49 50 FE
 34+  829C 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  82A0 20 20 44 4F
 34+  82A4 55 42 4C 45
 34+  82A8 20 42 4F 4E
 34+  82AC 55 53 20 20
 34+  82B0 31 30 30 30
 34+  82B4 30 20 50 4F
 34+  82B8 49 4E 54 53
 34+  82BC FE
 35+  82BD 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  82C1 20 20 43 4F
 35+  82C5 4C 4C 45 43
 35+  82C9 54 20 41 4C
 35+  82CD 4C 20 33 20
 35+  82D1 4C 41 52 47
 35+  82D5 45 20 4A 45
 35+  82D9 57 45 4C 53
 35+  82DD FE
 36+  82DE 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  82E2 20 20 20 20
 36+  82E6 20 4F 52 20
 36+  82EA 20 20 41 4C
 36+  82EE 4C 20 34 20
 36+  82F2 53 4D 41 4C
 36+  82F6 4C 20 4A 45
 36+  82FA 57 45 4C 53
 36+  82FE FE
 37+  82FF 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  8303 20 20 54 52
 37+  8307 49 50 4C 45
 37+  830B 20 42 4F 4E
 37+  830F 55 53 20 20
 37+  8313 31 35 30 30
 37+  8317 30 20 50 4F
 37+  831B 49 4E 54 53
 37+  831F FE
 38+  8320 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  8324 20 20 20 20
 38+  8328 20 43 4F 4C
 38+  832C 4C 45 43 54
 38+  8330 20 41 4C 4C
 38+  8334 20 37 20 4A
 38+  8338 45 57 45 4C
 38+  833C 53 FF
 39+  833E
 40+  833E              string_lifescreen_player:
 41+  833E 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  8342 4C 41 59 45
 41+  8346 52 20 31 20
 41+  834A FF
 42+  834B              string_lifescreen_lives:
 43+  834B 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  834F 4D 45 4E 20
 43+  8353 4C 45 46 54
 43+  8357 FF
 44+  8358              string_lifescreen_lastman:
 45+  8358 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  835C 53 54 20 4D
 45+  8360 41 4E FF
 46+  8363
 47+  8363              string_gameoverscreen_gameover:
 48+  8363 0C 06 47 41      defb 12,6,'GAME OVER',255
 48+  8367 4D 45 20 4F
 48+  836B 56 45 52 FF
 49+  836F              string_gameoverscreen_copyright:
 50+  836F 06 12 7F 31      defb 6,18,127,'1982  CENTURI INC',255
 50+  8373 39 38 32 20
 50+  8377 20 43 45 4E
 50+  837B 54 55 52 49
 50+  837F 20 49 4E 43
 50+  8383 FF
 51+  8384              string_gameoverscreen_bestscores:
 52+  8384 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  8388 53 54 20 53
 52+  838C 43 4F 52 45
 52+  8390 53 20 54 4F
 52+  8394 44 41 59 FF
 53+  8398              string_gameover_credits:
 54+  8398 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  839C 45 44 49 54
 54+  83A0 53 20 30 FF
 55+  83A4
 56+  83A4              string_highscore_congratulations:
 57+  83A4 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 57+  83A8 4E 47 52 41
 57+  83AC 54 55 4C 41
 57+  83B0 54 49 4F 4E
 57+  83B4 53 FF
 58+  83B6              string_highscore_player1:
 59+  83B6 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 59+  83BA 41 59 45 52
 59+  83BE 20 31 FF
 60+  83C1              string_highscore_player2:
 61+  83C1 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 61+  83C5 41 59 45 52
 61+  83C9 20 32 FF
 62+  83CC              string_highscore_youhaveearned:
 63+  83CC 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 63+  83D0 55 20 48 41
 63+  83D4 56 45 20 45
 63+  83D8 41 52 4E 45
 63+  83DC 44 FF
 64+  83DE              string_highscore_place1:
 65+  83DE 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 65+  83E2 45 20 47 52
 65+  83E6 45 41 54 45
 65+  83EA 53 54 20 53
 65+  83EE 43 4F 52 45
 65+  83F2 FF
 66+  83F3              string_highscore_place2:
 67+  83F3 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 67+  83F7 45 20 32 4E
 67+  83FB 44 20 42 45
 67+  83FF 53 54 20 53
 67+  8403 43 4F 52 45
 67+  8407 FF
 68+  8408              string_highscore_place3:
 69+  8408 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 69+  840C 45 20 33 52
 69+  8410 44 20 42 45
 69+  8414 53 54 20 53
 69+  8418 43 4F 52 45
 69+  841C FF
 70+  841D              string_highscore_pleaseenter
 71+  841D 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 71+  8421 43 4F 52 44
 71+  8425 20 59 4F 55
 71+  8429 52 20 49 4E
 71+  842D 49 54 49 41
 71+  8431 4C 53 20 42
 71+  8435 45 4C 4F 57
 71+  8439 FF
 72+  843A
 73+  843A              string_endlevel_youhaveearned:
 74+  843A 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 74+  843E 55 20 48 41
 74+  8442 56 45 20 45
 74+  8446 41 52 4E 45
 74+  844A 44 FF
 75+  844C              string_endlevel_bonus1:
 76+  844C 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 76+  8450 4E 47 4C 45
 76+  8454 20 42 4F 4E
 76+  8458 55 53 FF
 77+  845B              string_endlevel_bonus2:
 78+  845B 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 78+  845F 55 42 4C 45
 78+  8463 20 42 4F 4E
 78+  8467 55 53 FF
 79+  846A              string_endlevel_bonus3:
 80+  846A 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 80+  846E 49 50 4C 45
 80+  8472 20 42 4F 4E
 80+  8476 55 53 FF
 81+  8479              string_endlevel_points1:
 82+  8479 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 82+  847D 30 30 20 50
 82+  8481 4F 49 4E 54
 82+  8485 53 FF
 83+  8487              string_endlevel_points2:
 84+  8487 09 0F 31 30      defb 9,15,'10000 POINTS',255
 84+  848B 30 30 30 20
 84+  848F 50 4F 49 4E
 84+  8493 54 53 FF
 85+  8496              string_endlevel_points3:
 86+  8496 09 0F 31 35      defb 9,15,'15000 POINTS',255
 86+  849A 30 30 30 20
 86+  849E 50 4F 49 4E
 86+  84A2 54 53 FF
 87+  84A5              string_endlevel_anothergo:
 88+  84A5 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 88+  84A9 56 45 20 41
 88+  84AD 4E 4F 54 48
 88+  84B1 45 52 20 47
 88+  84B5 4F FF
 89+  84B7
 90+  84B7              string_zonk:
 91+  84B7 00 00 5A 4F      defb 0,0,'ZONK!',255
 91+  84BB 4E 4B 21 FF
 92+  84BF              ;
 93+  84BF              ; Prints specified string
 94+  84BF              ; Inputs:
 95+  84BF              ; de: pointer to string
 96+  84BF              ; bc: length of string
 97+  84BF              ;
 98+  84BF              ; Print String Data
 99+  84BF              ; First two bytes of string contain X and Y char position, then the string
100+  84BF              ; Individual strings are terminated with 0xFE
101+  84BF              ; End of data is terminated with 0xFF
102+  84BF              ; HL: Address of string
103+  84BF              ;
104+  84BF 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
105+  84C0 23                                   INC HL                          ; Increase HL to the next memory location
106+  84C1 56                                   LD D,(HL)                       ; Fetch the Y coordinate
107+  84C2 23                                   INC HL                          ; Increase HL to the next memory location
108+  84C3 CD D6 84                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
109+  84C6 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
110+  84C7 23                                   INC HL                          ; Increase HL to the next character
111+  84C8 FE FE                                CP 0xFE                         ; Compare with 0xFE
112+  84CA 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
113+  84CC D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
114+  84CD E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
115+  84CE CD E6 84                             CALL Print_Char                 ; Print the character
116+  84D1 E1                                   POP HL                          ; Retrieve HL back off the stack
117+  84D2 1C                                   INC E                           ; Go to the next screen address
118+  84D3 18 F1                                JR string_print_0               ; Loop back to print next character
119+  84D5 C9                                   RET
120+  84D6
121+  84D6              ; Get screen address
122+  84D6              ; D = Y character position
123+  84D6              ; E = X character position
124+  84D6              ; Returns address in DE
125+  84D6              ;
126+  84D6 7A           string_getcharaddress:       LD A,D
127+  84D7 E6 07                                AND %00000111
128+  84D9 1F                                   RRA
129+  84DA 1F                                   RRA
130+  84DB 1F                                   RRA
131+  84DC 1F                                   RRA
132+  84DD B3                                   OR E
133+  84DE 5F                                   LD E,A
134+  84DF 7A                                   LD A,D
135+  84E0 E6 18                                AND %00011000
136+  84E2 F6 40                                OR %01000000
137+  84E4 57                                   LD D,A
138+  84E5 C9                                   RET                             ; Returns screen address in DE
139+  84E6
140+  84E6              ; Print a single character out
141+  84E6              ; A:  Character to print
142+  84E6              ; DE: Screen address to print character at
143+  84E6              ;
144+  84E6 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
145+  84E9 06 00                                LD B,0                          ; Set BC to A
146+  84EB 4F                                   LD C,A
147+  84EC E6 FF                                AND 0xFF                        ; Clear the carry bit
148+  84EE CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
149+  84F0 CB 10                                RL B
150+  84F2 CB 11                                RL C
151+  84F4 CB 10                                RL B
152+  84F6 CB 11                                RL C
153+  84F8 CB 10                                RL B
154+  84FA 09                                   ADD HL,BC                       ; Get the character address in HL
155+  84FB 0E 08                                LD C,8                          ; Loop counter
156+  84FD D5                                   PUSH DE
157+  84FE 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
158+  84FF 12                                   LD (DE),A                       ; Stick A onto the screen
159+  8500 14                                   INC D                           ; Goto next line on screen
160+  8501 2C                                   INC L                           ; Goto next byte of character
161+  8502 0D                                   DEC C                           ; Decrease the loop counter
162+  8503 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
163+  8505 D1                                   POP DE
164+  8506 C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   8507                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  8507              buffer_buffer:
  2+  8507 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A207
  4+  A207              buffer_attr_buffer:
  5+  A207 00 00 00...      defs 928                    ; attrs buffer area
  6+  A5A7
  7+  A5A7              buffer_tmp:
  8+  A5A7 00 00            defb 0,0                    ; temp area
  9+  A5A9
 10+  A5A9              ;
 11+  A5A9              ; This list stores lines to be updated by the buffer.
 12+  A5A9              ; This is done by half line. Lines are encded with.
 13+  A5A9              ; 00hlllll
 14+  A5A9              ; Where h is the half of the screen (0 or 1), lllll is the line number
 15+  A5A9              buffer_updatedlines:
 16+  A5A9 FF FF FF...      defs 21,255
 17+  A5BE
 18+  A5BE              buffer_updateall:
 19+  A5BE 00               defb 0
 20+  A5BF
 21+  A5BF              ;
 22+  A5BF              ; Stores a line number in the update list
 23+  A5BF              ; Inputs:
 24+  A5BF              ; a - row number
 25+  A5BF              buffer_marklineforupdate:
 26+  A5BF FE 15            cp 21
 27+  A5C1 D0               ret nc                          ; dont store lines that we shouldn't draw
 28+  A5C2 5F               ld e,a                          ; store in e
 29+  A5C3 ED 4B AC AA      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 30+  A5C7 79               ld a,c                          ; get the horiz coord
 31+  A5C8 FE 0F            cp 15
 32+  A5CA CA E1 A5         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 33+  A5CD FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 34+  A5CF CA E1 A5         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 35+  A5D2 DA DD A5         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 36+  A5D5 78               ld a,b                          ; get the vertical
 37+  A5D6 3E 20            ld a,32                         ; set the 6th bit by adding 32
 38+  A5D8 83               add a,e
 39+  A5D9 5F               ld e,a                          ; store this value
 40+  A5DA C3 E8 A5         jp buffer_marklineforupdate2
 41+  A5DD              buffer_marklineforupdate4:
 42+  A5DD 78               ld a,b
 43+  A5DE C3 E8 A5         jp buffer_marklineforupdate2    ; just get the vertical
 44+  A5E1              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 45+  A5E1 CD EC A5         call buffer_storelineforupdate  ; call store update for e
 46+  A5E4 3E 20            ld a,32
 47+  A5E6 83               add a,e
 48+  A5E7 5F               ld e,a
 49+  A5E8              buffer_marklineforupdate2:
 50+  A5E8 CD EC A5         call buffer_storelineforupdate  ; call store update for e
 51+  A5EB C9               ret
 52+  A5EC
 53+  A5EC
 54+  A5EC              ;
 55+  A5EC              ; Stores the calculated line and half if needed
 56+  A5EC              ; Inputs:
 57+  A5EC              ; e - half/row
 58+  A5EC              ;
 59+  A5EC              buffer_storelineforupdate:
 60+  A5EC 06 15            ld b,21
 61+  A5EE 21 A9 A5         ld hl,buffer_updatedlines
 62+  A5F1              buffer_storelineforupdate0:
 63+  A5F1 7E               ld a,(hl)                       ; get the line stored in updated lines
 64+  A5F2 BB               cp e                            ; is this the same as the row number passed in?
 65+  A5F3 C8               ret z                           ; if so, don't need to do anything
 66+  A5F4 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 67+  A5F6 C2 FB A5         jp nz,buffer_storelineforupdate1 ; if not, move to next
 68+  A5F9 73               ld (hl),e
 69+  A5FA C9               ret
 70+  A5FB              buffer_storelineforupdate1:
 71+  A5FB 23               inc hl
 72+  A5FC 10 F3            djnz buffer_storelineforupdate0
 73+  A5FE C9               ret
 74+  A5FF
 75+  A5FF              ;
 76+  A5FF              ; Zeroes the updated lines list
 77+  A5FF              ;
 78+  A5FF              buffer_clearlist:
 79+  A5FF 06 15            ld b,21
 80+  A601 21 A9 A5         ld hl,buffer_updatedlines
 81+  A604              buffer_clearlist0:
 82+  A604 36 FF            ld (hl),255
 83+  A606 23               inc hl
 84+  A607 10 FB            djnz buffer_clearlist0
 85+  A609 C9               ret
 86+  A60A
 87+  A60A              ;
 88+  A60A              ; Which half are we displaying? 0 left 1 right
 89+  A60A              ;
 90+  A60A              buffer_bufferhalf:
 91+  A60A 00               defb 0
 92+  A60B
 93+  A60B              ;
 94+  A60B              ; Copies the buffer to the screen. Use stack.
 95+  A60B              ; Inputs:
 96+  A60B              ; hl - half/line number to display - 0 is first half, 0 is first line
 97+  A60B              ;
 98+  A60B              buffer_bufferlinetoscreen:
 99+  A60B 7C               ld a,h
100+  A60C 32 0A A6         ld (buffer_bufferhalf),a        ; store the half
101+  A60F 7D               ld a,l
102+  A610 4F               ld c,a                          ; store a
103+  A611 ED 5B 71 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
104+  A615 83               add a,e                       ; add the row number
105+  A616 11 00 01         ld de,256
106+  A619 CD 3A 80         call utilities_multiply
107+  A61C 54 5D            ld de,hl
108+  A61E 21 07 85         ld hl,buffer_buffer
109+  A621 19               add hl,de                   ; add the offset
110+  A622 79               ld a,c                      ; get original row back
111+  A623 ED 73 96 A6      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
112+  A627 D9               exx
113+  A628 0E 00            ld c,0                      ; zero horizontal
114+  A62A 47               ld b,a                      ; load the row number into vertical coord
115+  A62B 04               inc b
116+  A62C 04               inc b                       ; move forward 2 to allow for scores
117+  A62D CD 5B A8         call screen_getcelladdress  ; get the memory into de
118+  A630 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
119+  A633 19               add hl,de
120+  A634 3A 0A A6         ld a,(buffer_bufferhalf)    ; get the half
121+  A637 FE 01            cp 1
122+  A639 CA 66 A6         jp z,buffer_bufferlinetoscreen4
123+  A63C              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
124+  A63C D9               exx                         ; hl is now buffer
125+  A63D 23               inc hl
126+  A63E 23               inc hl                      ; move hl forward 2 to skip first two blocks
127+  A63F F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
128+  A640 F1               pop af
129+  A641 C1               pop bc
130+  A642 D1               pop de
131+  A643 DD E1            pop ix
132+  A645 D9               exx                         ; hl is now screen
133+  A646 08               ex af,af'
134+  A647 F1               pop af
135+  A648 C1               pop bc
136+  A649 D1               pop de
137+  A64A F9               ld sp,hl                    ; sp pointing at screen
138+  A64B D5               push de
139+  A64C C5               push bc
140+  A64D F5               push af
141+  A64E 08               ex af,af'
142+  A64F D9               exx                         ; hl is now buffer
143+  A650 DD E5            push ix
144+  A652 D5               push de
145+  A653 C5               push bc
146+  A654 F5               push af
147+  A655 11 1E 00         ld de,30                    ; add thirty to get to next line
148+  A658 19               add hl,de
149+  A659 F9               ld sp,hl                    ; sp pointing at buffer
150+  A65A D9               exx                         ; hl is now screen
151+  A65B 08               ex af,af'
152+  A65C 24               inc h
153+  A65D 7C               ld a,h
154+  A65E E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
155+  A660 C2 3C A6         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
156+  A663              buffer_bufferlinetoscreen1:
157+  A663 C3 95 A6         jp buffer_bufferlinetoscreen3
158+  A666              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
159+  A666 D9               exx                         ; hl is buffer
160+  A667 11 10 00         ld de,16
161+  A66A 19               add hl,de                   ; move halfway across
162+  A66B D9               exx                         ; hl is screen
163+  A66C 11 0E 00         ld de,14
164+  A66F 19               add hl,de
165+  A670              buffer_bufferlinetoscreen2:
166+  A670 D9               exx                         ; hl is now buffer
167+  A671 F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
168+  A672 F1               pop af
169+  A673 C1               pop bc
170+  A674 D1               pop de
171+  A675 DD E1            pop ix
172+  A677 D9               exx                         ; hl is now screen
173+  A678 08               ex af,af'
174+  A679 F1               pop af
175+  A67A C1               pop bc
176+  A67B D1               pop de
177+  A67C F9               ld sp,hl                    ; sp pointing at screen
178+  A67D D5               push de
179+  A67E C5               push bc
180+  A67F F5               push af
181+  A680 08               ex af,af'
182+  A681 D9               exx                         ; hl is now buffer
183+  A682 DD E5            push ix
184+  A684 D5               push de
185+  A685 C5               push bc
186+  A686 F5               push af
187+  A687 11 20 00         ld de,32                    ; add thirty two to get to next line
188+  A68A 19               add hl,de
189+  A68B F9               ld sp,hl                    ; sp pointing at buffer
190+  A68C D9               exx                         ; hl is now screen
191+  A68D 08               ex af,af'
192+  A68E 24               inc h
193+  A68F 7C               ld a,h
194+  A690 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
195+  A692 C2 70 A6         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
196+  A695              buffer_bufferlinetoscreen3:
197+  A695 31 00 00         ld sp,0
198+  A698 D9               exx
199+  A699 C9               ret
200+  A69A
201+  A69A              ;
202+  A69A              ; Copies the buffer to the screen for updated lines. Use stack.
203+  A69A              ; Inputs: none
204+  A69A              ;
205+  A69A              buffer_buffertoscreen:
206+  A69A 3A BE A5         ld a,(buffer_updateall)      ; get the all update flag
207+  A69D FE 00            cp 0
208+  A69F CA AB A6         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
209+  A6A2 CD DB A6         call buffer_allbuffertoscreen ; otherwise, draw whole screen
210+  A6A5 21 BE A5         ld hl,buffer_updateall
211+  A6A8 36 00            ld (hl),0                    ; reset flag
212+  A6AA C9               ret
213+  A6AB              buffer_buffertoscreen2:
214+  A6AB 06 15            ld b,21
215+  A6AD FD 21 A9 A5      ld iy,buffer_updatedlines    ; the location of the updated lines
216+  A6B1              buffer_buffertoscreen0:
217+  A6B1 FD 7E 00         ld a,(iy)
218+  A6B4 FE FF            cp 255
219+  A6B6 CA DA A6         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
220+  A6B9 6F               ld l,a
221+  A6BA 26 00            ld h,0
222+  A6BC E6 20            and 32                      ; and with 32 to see if 6th bit is set
223+  A6BE FE 20            cp 32                       ; if so, second half of screen
224+  A6C0 C2 CB A6         jp nz,buffer_buffertoscreen3
225+  A6C3 26 01            ld h,1                      ; store half in h
226+  A6C5 FD 7E 00         ld a,(iy)
227+  A6C8 D6 20            sub 32                      ; remove 32
228+  A6CA 6F               ld l,a                      ; stor in line number
229+  A6CB              buffer_buffertoscreen3:
230+  A6CB C5               push bc
231+  A6CC FD E5            push iy
232+  A6CE F3               di
233+  A6CF CD 0B A6         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
234+  A6D2 FB               ei
235+  A6D3 FD E1            pop iy
236+  A6D5 C1               pop bc
237+  A6D6 FD 23            inc iy
238+  A6D8 10 D7            djnz buffer_buffertoscreen0
239+  A6DA              buffer_buffertoscreen1:
240+  A6DA                  ;call buffer_buffertoattrsfast
241+  A6DA C9               ret
242+  A6DB
243+  A6DB              ;
244+  A6DB              ; Copies the buffer to the screen. Use stack.
245+  A6DB              ; Inputs: none
246+  A6DB              ;
247+  A6DB              buffer_allbuffertoscreen:
248+  A6DB 06 15            ld b,21
249+  A6DD 3E 00            ld a,0
250+  A6DF              buffer_allbuffertoscreen0:
251+  A6DF C5               push bc
252+  A6E0 F5               push af
253+  A6E1 F3               di
254+  A6E2 26 00            ld h,0
255+  A6E4 6F               ld l,a
256+  A6E5 CD 0B A6         call buffer_bufferlinetoscreen
257+  A6E8 FB               ei
258+  A6E9 F1               pop af
259+  A6EA F5               push af
260+  A6EB F3               di
261+  A6EC 26 01            ld h,1
262+  A6EE 6F               ld l,a
263+  A6EF CD 0B A6         call buffer_bufferlinetoscreen
264+  A6F2 FB               ei
265+  A6F3 F1               pop af
266+  A6F4 C1               pop bc
267+  A6F5 3C               inc a
268+  A6F6 10 E7            djnz buffer_allbuffertoscreen0
269+  A6F8 F3               di
270+  A6F9 CD FE A6         call buffer_buffertoattrsfast
271+  A6FC FB               ei
272+  A6FD C9               ret
273+  A6FE
274+  A6FE              ;
275+  A6FE              ; Copies the attrs buffer to screen with the stack
276+  A6FE              ;
277+  A6FE              buffer_buffertoattrsfast:
278+  A6FE ED 73 6D A7      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
279+  A702 3A 71 A7         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
280+  A705 11 20 00         ld de,32
281+  A708 CD 3A 80         call utilities_multiply
282+  A70B 54 5D            ld de,hl
283+  A70D 21 07 A2         ld hl,buffer_attr_buffer
284+  A710 19               add hl,de                       ; add the offset, start of attr buffer now in hl
285+  A711 D9               exx
286+  A712 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
287+  A715 FD 21 A7 A5      ld iy,buffer_tmp
288+  A719 FD 36 00 15      ld (iy),21              ; number of times to loop
289+  A71D              buffer_buffertoattrsfast0:
290+  A71D D9               exx                         ; hl is now buffer
291+  A71E 23               inc hl
292+  A71F 23               inc hl                      ; move hl forward 2 to skip first two blocks
293+  A720 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
294+  A721 F1               pop af
295+  A722 C1               pop bc
296+  A723 D1               pop de
297+  A724 DD E1            pop ix
298+  A726 D9               exx                         ; hl is now screen
299+  A727 08               ex af,af'
300+  A728 F1               pop af
301+  A729 C1               pop bc
302+  A72A D1               pop de
303+  A72B F9               ld sp,hl                    ; sp pointing at screen
304+  A72C D5               push de
305+  A72D C5               push bc
306+  A72E F5               push af
307+  A72F 08               ex af,af'
308+  A730 D9               exx                         ; hl is now buffer
309+  A731 DD E5            push ix
310+  A733 D5               push de
311+  A734 C5               push bc
312+  A735 F5               push af
313+  A736 1E 0E            ld e,14                    ; do another fourteen for right hand side
314+  A738 16 00            ld d,0
315+  A73A 19               add hl,de
316+  A73B F9               ld sp,hl                    ; sp pointing at buffer
317+  A73C F1               pop af
318+  A73D C1               pop bc
319+  A73E D1               pop de
320+  A73F DD E1            pop ix
321+  A741 D9               exx                         ; hl is now screen
322+  A742 08               ex af,af'
323+  A743 1E 0E            ld e,14
324+  A745 16 00            ld d,0
325+  A747 19               add hl,de
326+  A748 F1               pop af
327+  A749 C1               pop bc
328+  A74A D1               pop de
329+  A74B F9               ld sp,hl                    ; sp pointing at screen
330+  A74C D5               push de
331+  A74D C5               push bc
332+  A74E F5               push af
333+  A74F 08               ex af,af'
334+  A750 D9               exx                         ; hl is now buffer
335+  A751 DD E5            push ix
336+  A753 D5               push de
337+  A754 C5               push bc
338+  A755 F5               push af
339+  A756 1E 10            ld e,16
340+  A758 16 00            ld d,0
341+  A75A 19               add hl,de
342+  A75B D9               exx                         ; hl is now screen
343+  A75C 11 12 00         ld de,18
344+  A75F 19               add hl,de
345+  A760 FD 7E 00         ld a,(iy)
346+  A763 3D               dec a
347+  A764 FE 00            cp 0
348+  A766 FD 77 00         ld (iy),a
349+  A769 C2 1D A7         jp nz,buffer_buffertoattrsfast0 ; do another row
350+  A76C              buffer_buffertoattrsfast1:
351+  A76C 31 00 00         ld sp,0
352+  A76F D9               exx
353+  A770 C9               ret
# file closed: screen/buffer.asm
 24   A771                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A771              screen_offset:
  2+  A771 00               defb 0                      ; offset from top of screen in lines
  3+  A772
  4+  A772              screen_tmp:
  5+  A772 00 00            defb 0,0                      ; temporary memory
  6+  A774
  7+  A774              screen_setscorecolours:
  8+  A774 21 EA B3         ld hl,score_colours
  9+  A777 11 00 58         ld de,22528                     ; attrs here
 10+  A77A 01 40 00         ld bc,64
 11+  A77D ED B0            ldir
 12+  A77F C9               ret
 13+  A780
 14+  A780              screen_sethighscorecolours:
 15+  A780 21 2A B4         ld hl,high_score_colours
 16+  A783 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A786 01 20 00         ld bc,32
 18+  A789 ED B0            ldir
 19+  A78B C9               ret
 20+  A78C
 21+  A78C              ; Draw the screen
 22+  A78C              ; Inputs:
 23+  A78C              ; none
 24+  A78C              ; Notes:
 25+  A78C              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A78C              screen_draw:
 27+  A78C                  ;call clear_screen
 28+  A78C 0E 00            ld c,0                      ; horiz
 29+  A78E 06 00            ld b,0                      ; vert, 0 at top
 30+  A790 DD 21 AC AE      ld ix,level01               ; point ix at level data
 31+  A794 FD 21 07 A2      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A798              screen_draw0:
 33+  A798 DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A79B C5               push bc                     ; store bc, contains loop count
 35+  A79C CD 49 A9         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A79F 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A7A0 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A7A3 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A7A6 CD 10 A9         call screen_getblock        ; get the block data into hl
 40+  A7A9 CD ED A8         call screen_showchar        ; show this character here
 41+  A7AC C1               pop bc                      ; get the loop counter back
 42+  A7AD DD 23            inc ix                      ; increment level location
 43+  A7AF FD 23            inc iy                      ; increment attr location
 44+  A7B1 0C               inc c                       ; increment horiz
 45+  A7B2 79               ld a,c
 46+  A7B3 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A7B5 C2 98 A7         jp nz,screen_draw0          ; if not, loop
 48+  A7B8 0E 00            ld c,0                      ; if so, reset horiz
 49+  A7BA 04               inc b                       ; increment vertical
 50+  A7BB 78               ld a,b
 51+  A7BC FE 1D            cp 29                       ; check if at bottom
 52+  A7BE C2 98 A7         jp nz,screen_draw0          ; if not, loop
 53+  A7C1 21 72 A7         ld hl, screen_tmp
 54+  A7C4 36 09            ld (hl),9                   ; load the block number into memory
 55+  A7C6 DD 21 4C B2      ld ix,level01rocks          ; rock memory
 56+  A7CA CD 2B A8         call screen_initobjects     ; draw rocks
 57+  A7CD 21 72 A7         ld hl, screen_tmp
 58+  A7D0 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A7D2 DD 21 4C B3      ld ix,level01missiles       ; missile memory
 60+  A7D6 CD 2B A8         call screen_initobjects     ; draw missiles
 61+  A7D9 21 72 A7         ld hl, screen_tmp
 62+  A7DC 36 08            ld (hl),08                  ; load the block number into memory
 63+  A7DE DD 21 C5 B3      ld ix,level01diamonds       ; diamond memory
 64+  A7E2 CD 2B A8         call screen_initobjects     ; draw diamonds
 65+  A7E5 21 72 A7         ld hl, screen_tmp
 66+  A7E8 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A7EA DD 21 D5 B3      ld ix,level01gems           ; gems memory
 68+  A7EE CD 2B A8         call screen_initobjects     ; draw gems
 69+  A7F1 CD F8 A7         call screen_setuptext       ; draws text on the screen
 70+  A7F4 CD A0 C1         call scores_printscores     ; print the current scores
 71+  A7F7 C9               ret
 72+  A7F8
 73+  A7F8              ;
 74+  A7F8              ; Sets up text on the screen
 75+  A7F8              ;
 76+  A7F8              screen_setuptext:
 77+  A7F8 CD C2 C1         call scores_showtable
 78+  A7FB CD 80 A7         call screen_sethighscorecolours
 79+  A7FE 21 ED 80         ld hl, string_score1
 80+  A801 CD BF 84         call string_print
 81+  A804 21 F6 80         ld hl, string_scorenumbers1
 82+  A807 CD BF 84         call string_print
 83+  A80A 21 FF 80         ld hl, string_company
 84+  A80D CD BF 84         call string_print
 85+  A810 21 14 81         ld hl, string_score2
 86+  A813 CD BF 84         call string_print
 87+  A816 21 1D 81         ld hl, string_scorenumbers2
 88+  A819 CD BF 84         call string_print
 89+  A81C 21 09 81         ld hl, string_credits
 90+  A81F CD BF 84         call string_print
 91+  A822 CD 74 A7         call screen_setscorecolours
 92+  A825 C9               ret
 93+  A826
 94+  A826              ;
 95+  A826              ; Sets a line of colours
 96+  A826              ; Inputs:
 97+  A826              ; a - colour to set
 98+  A826              ; b - number to set
 99+  A826              ; de - start memory location
100+  A826              ;
101+  A826              screen_setcolours:
102+  A826 12               ld (de),a
103+  A827 13               inc de
104+  A828 10 FC            djnz screen_setcolours
105+  A82A C9               ret
106+  A82B
107+  A82B              ;
108+  A82B              ; Draw initial object positions
109+  A82B              ; Inputs:
110+  A82B              ; ix - memory location of objects
111+  A82B              ; a - graphic
112+  A82B              screen_initobjects:
113+  A82B DD 4E 00         ld c,(ix)                   ; get the horiz coord
114+  A82E 79               ld a,c
115+  A82F FE FF            cp 255
116+  A831 CA 5A A8         jp z,screen_initobjects2
117+  A834 DD 23            inc ix                      ; move to next
118+  A836 DD 46 00         ld b,(ix)                   ; get the vert coord
119+  A839 DD 23            inc ix
120+  A83B CD 6C A8         call screen_getcellattradress ; get the memory address of b,c attr into de
121+  A83E D5               push de
122+  A83F 3A 72 A7         ld a,(screen_tmp)                  ; get the block number back
123+  A842 CD 49 A9         call screen_getattr         ; get the memory location for this cell's attr into hl
124+  A845 D1               pop de
125+  A846 7E               ld a,(hl)                   ; get the attr value at the address
126+  A847 12               ld (de),a                   ; load the attr into memory
127+  A848 3A 72 A7         ld a,(screen_tmp)                  ; get the block number back
128+  A84B CD 10 A9         call screen_getblock        ; get the block data into hl
129+  A84E CD ED A8         call screen_showchar        ; show this character here
130+  A851
131+  A851              screen_initobjects1:
132+  A851 DD 23            inc ix                      ; move past state
133+  A853 DD 23            inc ix
134+  A855 DD 23            inc ix                      ; move past mem
135+  A857 C3 2B A8         jp screen_initobjects
136+  A85A              screen_initobjects2:
137+  A85A C9               ret
138+  A85B
139+  A85B
140+  A85B              ;
141+  A85B              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
142+  A85B              ; Inputs:
143+  A85B              ; bc: coords
144+  A85B              ; Outputs:
145+  A85B              ; de: memory location
146+  A85B              ;
147+  A85B              screen_getcelladdress:
148+  A85B 78               ld a,b      ; vertical position.
149+  A85C E6 18            and 24      ; which segment, 0, 1 or 2?
150+  A85E C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
151+  A860 57               ld d,a      ; this is our high byte.
152+  A861 78               ld a,b      ; what was that vertical position again?
153+  A862 E6 07            and 7       ; which row within segment?
154+  A864 0F               rrca        ; multiply row by 32.
155+  A865 0F               rrca
156+  A866 0F               rrca
157+  A867 5F               ld e,a      ; low byte.
158+  A868 79               ld a,c      ; add on y coordinate.
159+  A869 83               add a,e     ; mix with low byte.
160+  A86A 5F               ld e,a      ; address of screen position in de.
161+  A86B C9               ret
162+  A86C
163+  A86C              ;
164+  A86C              ; Calculate buffer address of attribute for character at (b, c).
165+  A86C              ; Inputs:
166+  A86C              ; bc: coords
167+  A86C              ; Outputs:
168+  A86C              ; de: memory location
169+  A86C              ;
170+  A86C              screen_getcellattradress:
171+  A86C 11 07 A2         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
172+  A86F 69               ld l,c      ; x position.
173+  A870 26 00            ld h,0      ; 0 h
174+  A872 19               add hl,de
175+  A873 54 5D            ld de,hl    ; horiz done
176+  A875 78               ld a,b      ; do vert
177+  A876 D5               push de
178+  A877 C5               push bc
179+  A878 11 20 00         ld de,32
180+  A87B CD 3A 80         call utilities_multiply
181+  A87E C1               pop bc
182+  A87F D1               pop de
183+  A880 19               add hl,de
184+  A881 54 5D            ld de,hl    ; vert done
185+  A883 C9               ret
186+  A884
187+  A884              ;
188+  A884              ; Calculate buffer address offset of attribute for character at (b, c).
189+  A884              ; Inputs:
190+  A884              ; bc: coords
191+  A884              ; Outputs:
192+  A884              ; de: memory location
193+  A884              ;
194+  A884              screen_getcellattroffset:
195+  A884 69               ld l,c      ; x position.
196+  A885 26 00            ld h,0      ; 0 h
197+  A887 54 5D            ld de,hl    ; horiz done
198+  A889 78               ld a,b      ; do vert
199+  A88A D5               push de
200+  A88B C5               push bc
201+  A88C 11 20 00         ld de,32
202+  A88F CD 3A 80         call utilities_multiply
203+  A892 C1               pop bc
204+  A893 D1               pop de
205+  A894 19               add hl,de
206+  A895 54 5D            ld de,hl    ; vert done
207+  A897 C9               ret
208+  A898
209+  A898              ;
210+  A898              ; Calculate buffer address of attribute for character at (b, c).
211+  A898              ; Inputs:
212+  A898              ; bc: coords
213+  A898              ; Outputs:
214+  A898              ; de: memory location
215+  A898              ;
216+  A898              screen_getscreenattradress:
217+  A898 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
218+  A89B 69               ld l,c      ; x position.
219+  A89C 26 00            ld h,0      ; 0 h
220+  A89E 19               add hl,de
221+  A89F 54 5D            ld de,hl    ; horiz done
222+  A8A1 78               ld a,b      ; do vert
223+  A8A2 D5               push de
224+  A8A3 C5               push bc
225+  A8A4 11 20 00         ld de,32
226+  A8A7 CD 3A 80         call utilities_multiply
227+  A8AA C1               pop bc
228+  A8AB D1               pop de
229+  A8AC 19               add hl,de
230+  A8AD 54 5D            ld de,hl    ; vert done
231+  A8AF C9               ret
232+  A8B0
233+  A8B0              ;
234+  A8B0              ; Gets the attr memory location for a screen coord
235+  A8B0              ; Will overwrite bc
236+  A8B0              ; Inputs:
237+  A8B0              ; bc - screen coords
238+  A8B0              ; Outputs:
239+  A8B0              ; de - memory location
240+  A8B0              ; bc - character coords
241+  A8B0              ;
242+  A8B0              screen_getattraddressfromscreencoords:
243+  A8B0 78               ld a,b                          ; get the player block coords of current block
244+  A8B1 E6 F8            and 248                         ; find closest multiple of eight
245+  A8B3 0F               rrca
246+  A8B4 0F               rrca
247+  A8B5 0F               rrca                ; divide by 8
248+  A8B6 47               ld b,a
249+  A8B7 79               ld a,c
250+  A8B8 48               ld c,b                         ; swap b and c
251+  A8B9 E6 F8            and 248
252+  A8BB 0F               rrca
253+  A8BC 0F               rrca
254+  A8BD 0F               rrca                ; divide by 8
255+  A8BE 47               ld b,a
256+  A8BF CD 6C A8         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
257+  A8C2 C9               ret
258+  A8C3
259+  A8C3
260+  A8C3              ; Gets the nearest cell coords for a screen coord
261+  A8C3              ; Will overwrite bc
262+  A8C3              ; Inputs:
263+  A8C3              ; bc - screen coords
264+  A8C3              ; Outputs:
265+  A8C3              ; bc - character coords
266+  A8C3              ;
267+  A8C3              screen_getcharcoordsfromscreencoords:
268+  A8C3 78               ld a,b                          ; get the player block coords of current block
269+  A8C4 E6 F8            and 248                         ; find closest multiple of eight
270+  A8C6 0F               rrca
271+  A8C7 0F               rrca
272+  A8C8 0F               rrca                ; divide by 8
273+  A8C9 47               ld b,a
274+  A8CA 79               ld a,c
275+  A8CB 48               ld c,b                         ; swap b and c
276+  A8CC E6 F8            and 248
277+  A8CE 0F               rrca
278+  A8CF 0F               rrca
279+  A8D0 0F               rrca                ; divide by 8
280+  A8D1 47               ld b,a
281+  A8D2 C9               ret
282+  A8D3
283+  A8D3              ; Gets the screen coords for a cell coord
284+  A8D3              ; Will overwrite bc
285+  A8D3              ; Inputs:
286+  A8D3              ; bc - char coords
287+  A8D3              ; Outputs:
288+  A8D3              ; bc - screen coords
289+  A8D3              ;
290+  A8D3              screen_getscreencoordsfromcharcoords:
291+  A8D3 78               ld a,b                          ; get the player block coords of current block
292+  A8D4 07               rlca
293+  A8D5 07               rlca
294+  A8D6 07               rlca                ; multiply by 8
295+  A8D7 47               ld b,a
296+  A8D8 79               ld a,c
297+  A8D9 48               ld c,b                         ; swap b and c
298+  A8DA 07               rlca
299+  A8DB 07               rlca
300+  A8DC 07               rlca                ; divide by 8
301+  A8DD 47               ld b,a
302+  A8DE C9               ret
303+  A8DF
304+  A8DF              ;
305+  A8DF              ; Get buffer address for a character at b,c - b vert
306+  A8DF              ; Buffer memory is stored as sequential block
307+  A8DF              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
308+  A8DF              ; Inputs:
309+  A8DF              ; bc - coords
310+  A8DF              ; Outputs:
311+  A8DF              ; de - memory location of first byte
312+  A8DF              screen_getbufferaddress:
313+  A8DF 21 07 85         ld hl, buffer_buffer    ; first get screen buffer start
314+  A8E2 50               ld d,b                  ; then work out vertical offset
315+  A8E3 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
316+  A8E5 19               add hl,de               ; add to base
317+  A8E6 59               ld e,c                  ; then add horizontal offset (c)
318+  A8E7 16 00            ld d,0
319+  A8E9 19               add hl,de               ; add to base
320+  A8EA 54 5D            ld de,hl
321+  A8EC C9               ret
322+  A8ED
323+  A8ED              ;
324+  A8ED              ; Display character hl at (b, c) to buffer.
325+  A8ED              ; Stored sequentially
326+  A8ED              ; Inputs:
327+  A8ED              ; hl: block address
328+  A8ED              ; bc: coords
329+  A8ED              ;
330+  A8ED              screen_showchar:
331+  A8ED ED 43 AC AA      ld (origcoords),bc   ; store char coords
332+  A8F1 3E 00            ld a,0
333+  A8F3 E5               push hl
334+  A8F4 CD DF A8         call screen_getbufferaddress ; get the current screen buffer pointer
335+  A8F7 E1               pop hl
336+  A8F8 06 08            ld b,8              ; number of pixels high.
337+  A8FA              screen_showchar0:
338+  A8FA 7E               ld a,(hl)           ; source graphic.
339+  A8FB 12               ld (de),a           ; transfer to screen.
340+  A8FC 23               inc hl              ; next piece of data.
341+  A8FD E5               push hl             ; store hl
342+  A8FE 62 6B            ld hl,de            ; put de in hl
343+  A900 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
344+  A902 16 00            ld d,0
345+  A904 19               add hl,de              ; add de to hl
346+  A905 54 5D            ld de,hl            ; load back to de
347+  A907 E1               pop hl              ; restore hl
348+  A908
349+  A908 10 F0            djnz screen_showchar0 ; repeat
350+  A90A 2E 01            ld l,1
351+  A90C CD 5D AA         call sprites_marklinesforupdatechar
352+  A90F
353+  A90F C9               ret
354+  A910
355+  A910
356+  A910              ;
357+  A910              ; Get cell graphic.
358+  A910              ; Inputs:
359+  A910              ; a: block
360+  A910              ; Outputs:
361+  A910              ; hl: memory
362+  A910              ;
363+  A910              screen_getblock:
364+  A910 07               rlca                        ; multiply block number by eight.
365+  A911 07               rlca
366+  A912 07               rlca
367+  A913 5F               ld e,a                      ; displacement to graphic address.
368+  A914 16 00            ld d,0                      ; no high byte.
369+  A916 21 4A B4         ld hl,sprites               ; address of character blocks.
370+  A919 19               add hl,de                   ; point to block.
371+  A91A C9               ret
372+  A91B
373+  A91B              ;
374+  A91B              ; Set a the attr of a coord
375+  A91B              ; Inputs:
376+  A91B              ; bc - char coords
377+  A91B              ; a - attr
378+  A91B              ;
379+  A91B              screen_setattr:
380+  A91B DD E5            push ix
381+  A91D C5               push bc
382+  A91E 08               ex af, af'
383+  A91F CD 84 A8         call screen_getcellattroffset   ; get offset into de
384+  A922 21 07 A2         ld hl,buffer_attr_buffer
385+  A925 19               add hl,de                       ; get the memory location
386+  A926 08               ex af, af'                      ; get attr back
387+  A927 77               ld (hl),a                         ; set the attr
388+  A928 08               ex af, af'                      ; get attr back
389+  A929 ED 5B 71 A7      ld de,(screen_offset)           ; get the offset
390+  A92D 78               ld a,b                          ; get the vertical
391+  A92E 93               sub e                           ; subtract the offset
392+  A92F DA 45 A9         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
393+  A932 FE 15            cp 21
394+  A934 D2 45 A9         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
395+  A937 47               ld b,a                          ; put the coord back in b
396+  A938 CD 98 A8         call screen_getscreenattradress ; screen attr address in de
397+  A93B 21 40 00         ld hl,64                        ; attr memory + two rows for scores
398+  A93E 19               add hl,de
399+  A93F 08               ex af, af'                      ; get attr back
400+  A940 77               ld (hl),a
401+  A941 C1               pop bc
402+  A942 DD E1            pop ix
403+  A944 C9               ret
404+  A945              screen_setattr0:
405+  A945 C1               pop bc
406+  A946 DD E1            pop ix
407+  A948 C9               ret
408+  A949
409+  A949              ;
410+  A949              ; Get cell attribute.
411+  A949              ; Inputs:
412+  A949              ; a: block
413+  A949              ; Outputs:
414+  A949              ; hl: memory
415+  A949              ;
416+  A949              screen_getattr:
417+  A949 5F               ld e,a                      ; displacement to attribute address.
418+  A94A 16 00            ld d,0                      ; no high byte.
419+  A94C 21 22 B5         ld hl,sprite_attrs          ; address of block attributes.
420+  A94F 19               add hl,de                   ; point to attribute.
421+  A950 C9               ret
422+  A951
423+  A951              ;
424+  A951              ; Checks whether a character block has anything in it
425+  A951              ; Inputs:
426+  A951              ; bc - char coords
427+  A951              ; Outputs:
428+  A951              ; a - 1, empty
429+  A951              screen_ischarempty:
430+  A951 CD DF A8         call screen_getbufferaddress ; get the current screen buffer pointer
431+  A954 06 08            ld b,8                      ; check 8 rows
432+  A956              screen_ischarempty2:
433+  A956 1A               ld a,(de)                   ; check line
434+  A957 FE 00            cp 0
435+  A959 C2 67 A9         jp nz,screen_ischarempty1   ; if not zero, jump out with false
436+  A95C 21 20 00         ld hl,32
437+  A95F 19               add hl,de
438+  A960 54 5D            ld de,hl                    ; move to next row
439+  A962 10 F2            djnz screen_ischarempty2
440+  A964              screen_ischarempty0:
441+  A964 3E 01            ld a,1
442+  A966 C9               ret
443+  A967              screen_ischarempty1:
444+  A967 3E 00            ld a,0
445+  A969 C9               ret
446+  A96A
447+  A96A              ;
448+  A96A              ; Copies a block from one place to another directly underneath, leaves the original empty
449+  A96A              ; Inputs:
450+  A96A              ; bc - coords of block to copy from
451+  A96A              screen_copyblockdown
452+  A96A CD DF A8         call screen_getbufferaddress ; get the current screen buffer pointer for source
453+  A96D 06 08            ld b,8                      ; copy 8 rows
454+  A96F              screen_copyblock0:
455+  A96F 1A               ld a,(de)                    ; get what we're copying
456+  A970 08               ex af,af'
457+  A971 3E 00            ld a,0
458+  A973 12               ld (de),a                    ; replace with empty
459+  A974 08               ex af,af'
460+  A975 14               inc d                        ; add 256 to get to the next row
461+  A976 12               ld (de),a                    ; copy to the next row
462+  A977 15               dec d
463+  A978 21 20 00         ld hl,32
464+  A97B 19               add hl,de                       ; return back to source, next row down
465+  A97C 54 5D            ld de,hl
466+  A97E 10 EF            djnz screen_copyblock0
467+  A980 C9               ret
468+  A981
469+  A981              ;
470+  A981              ; Returns the first byte of a character. Useful for figuring out what's there
471+  A981              ; Inputs:
472+  A981              ; bc - coords
473+  A981              ; Outputs:
474+  A981              ; a - first byte
475+  A981              ;
476+  A981              screen_getcharfirstbyte:
477+  A981 CD DF A8         call screen_getbufferaddress ; get the current screen buffer pointer for source
478+  A984 1A               ld a,(de)
479+  A985 C9               ret
480+  A986
# file closed: screen/screen.asm
 25   A986                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A986              ;
  2+  A986              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A986              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A986              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A986              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A986              ; routine takes care of all the shifting itself. This means that sprite
  7+  A986              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A986              ; space they would require in pre-shifted form.
  9+  A986              ; Inputs:
 10+  A986              ; hl - sprite data
 11+  A986              ; bc - screen coords
 12+  A986              ;
 13+  A986              sprites_drawsprite7:
 14+  A986 EE 07            xor 7               ; complement last 3 bits.
 15+  A988 3C               inc a               ; add one for luck!
 16+  A989              sprites_drawsprite3:
 17+  A989 CB 11            rl c                ; ...into middle byte...
 18+  A98B CB 12            rl d                ; ...and finally into left character cell.
 19+  A98D 3D               dec a               ; count shifts we've done.
 20+  A98E 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A990                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A990 79               ld a,c              ; left edge of image is currently in e.
 23+  A991 4A               ld c,d              ; put right edge there instead.
 24+  A992 57               ld d,a              ; and the left edge back into c.
 25+  A993 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A995              sprites_drawsprite:
 27+  A995 ED 43 AC AA      ld (origcoords),bc  ; store coords
 28+  A999 ED 43 AE AA      ld (dispx),bc       ; store coords in dispx for now.
 29+  A99D E5               push hl
 30+  A99E CD 8A AA         call sprites_scadd  ; calculate screen address.
 31+  A9A1 E1               pop hl
 32+  A9A2 3E 08            ld a,8              ; height of sprite in pixels.
 33+  A9A4              sprites_drawsprite1:
 34+  A9A4 08               ex af,af'           ; store loop counter.
 35+  A9A5 D5               push de             ; store screen address.
 36+  A9A6 4E               ld c,(hl)           ; first sprite graphic.
 37+  A9A7 23               inc hl              ; increment poiinter to sprite data.
 38+  A9A8 22 B0 AA         ld (sprtmp),hl      ; store it for later.
 39+  A9AB 16 00            ld d,0              ; blank right byte for now.
 40+  A9AD 78               ld a,b              ; b holds y position.
 41+  A9AE E6 07            and 7               ; how are we straddling character cells?
 42+  A9B0 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  A9B2 FE 05            cp 5                ; 5 or more right shifts needed?
 44+  A9B4 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  A9B6 A7               and a               ; oops, carry flag is set so clear it.
 46+  A9B7              sprites_drawsprite2:
 47+  A9B7 CB 19            rr c                ; rotate left byte right...
 48+  A9B9 CB 1A            rr d                ; ...into right byte.
 49+  A9BB 3D               dec a               ; one less shift to do.
 50+  A9BC 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  A9BE              sprites_drawsprite0:
 52+  A9BE E1               pop hl              ; pop screen address from stack.
 53+  A9BF 7E               ld a,(hl)           ; what's there already.
 54+  A9C0 A9               xor c               ; merge in image data.
 55+  A9C1 77               ld (hl),a           ; place onto screen.
 56+  A9C2 23               inc hl
 57+  A9C3 7E               ld a,(hl)           ; what's already there.
 58+  A9C4 AA               xor d               ; right edge of sprite image data.
 59+  A9C5 77               ld (hl),a           ; plonk it on screen.
 60+  A9C6 3A AE AA         ld a,(dispx)        ; vertical coordinate.
 61+  A9C9 3C               inc a               ; next line down.
 62+  A9CA 32 AE AA         ld (dispx),a        ; store new position.
 63+  A9CD 2B               dec hl
 64+  A9CE 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  A9D1 19               add hl,de           ; add 32
 66+  A9D2              sprites_drawsprite6:
 67+  A9D2 EB               ex de,hl            ; screen address in de.
 68+  A9D3 2A B0 AA         ld hl,(sprtmp)      ; restore graphic address.
 69+  A9D6 08               ex af,af'           ; restore loop counter.
 70+  A9D7 3D               dec a               ; decrement it.
 71+  A9D8 C2 A4 A9         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  A9DB 2E 02            ld l,2
 73+  A9DD CD 4C AA         call sprites_marklinesforupdatescreen
 74+  A9E0 C9               ret                 ; job done.
 75+  A9E1
 76+  A9E1              ; Inputs:
 77+  A9E1              ; hl - sprite data
 78+  A9E1              ; bc - screen coords
 79+  A9E1              ;
 80+  A9E1              sprites_draw2by2sprite7
 81+  A9E1 EE 07            xor 7               ; complement last 3 bits.
 82+  A9E3 3C               inc a               ; add one for luck!
 83+  A9E4              sprites_draw2by2sprite3
 84+  A9E4 CB 12            rl d                ; rotate left...
 85+  A9E6 CB 11            rl c                ; ...into middle byte...
 86+  A9E8 CB 13            rl e                ; ...and finally into left character cell.
 87+  A9EA 3D               dec a               ; count shifts we've done.
 88+  A9EB 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  A9ED                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  A9ED 7B               ld a,e              ; left edge of image is currently in e.
 91+  A9EE 5A               ld e,d              ; put right edge there instead.
 92+  A9EF 51               ld d,c              ; middle bit goes in d.
 93+  A9F0 4F               ld c,a              ; and the left edge back into c.
 94+  A9F1 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  A9F3              sprites_draw2by2sprite
 96+  A9F3 ED 43 AC AA      ld (origcoords),bc  ; store coords
 97+  A9F7 ED 43 AE AA      ld (dispx),bc       ; store coords in dispx for now.
 98+  A9FB 79               ld a,c
 99+  A9FC 32 B2 AA         ld (sprtmp0),a         ; store vertical.
100+  A9FF E5               push hl
101+  AA00 CD 8A AA         call sprites_scadd          ; calculate screen address.
102+  AA03 E1               pop hl
103+  AA04 3E 10            ld a,16             ; height of sprite in pixels.
104+  AA06              sprites_draw2by2sprite1
105+  AA06 08               ex af,af'           ; store loop counter.
106+  AA07 D5               push de             ; store screen address.
107+  AA08 4E               ld c,(hl)           ; first sprite graphic.
108+  AA09 23               inc hl              ; increment poiinter to sprite data.
109+  AA0A 56               ld d,(hl)           ; next bit of sprite image.
110+  AA0B 23               inc hl              ; point to next row of sprite data.
111+  AA0C 22 B0 AA         ld (sprtmp),hl        ; store in tmp0 for later.
112+  AA0F 1E 00            ld e,0              ; blank right byte for now.
113+  AA11 78               ld a,b              ; b holds y position.
114+  AA12 E6 07            and 7               ; how are we straddling character cells?
115+  AA14 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  AA16 FE 05            cp 5                ; 5 or more right shifts needed?
117+  AA18 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  AA1A A7               and a               ; oops, carry flag is set so clear it.
119+  AA1B              sprites_draw2by2sprite2
120+  AA1B CB 19            rr c                ; rotate left byte right...
121+  AA1D CB 1A            rr d                ; ...through middle byte...
122+  AA1F CB 1B            rr e                ; ...into right byte.
123+  AA21 3D               dec a               ; one less shift to do.
124+  AA22 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  AA24              sprites_draw2by2sprite0
126+  AA24 E1               pop hl              ; pop screen address from stack.
127+  AA25 7E               ld a,(hl)           ; what's there already.
128+  AA26 A9               xor c               ; merge in image data.
129+  AA27 77               ld (hl),a           ; place onto screen.
130+  AA28 23               inc hl               ; next character cell to right please.
131+  AA29 7E               ld a,(hl)           ; what's there already.
132+  AA2A AA               xor d               ; merge with middle bit of image.
133+  AA2B 77               ld (hl),a           ; put back onto screen.
134+  AA2C 23               inc hl              ; next bit of screen area.
135+  AA2D 7E               ld a,(hl)           ; what's already there.
136+  AA2E AB               xor e               ; right edge of sprite image data.
137+  AA2F 77               ld (hl),a           ; plonk it on screen.
138+  AA30 3A B2 AA         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  AA33 3C               inc a               ; next line down.
140+  AA34 32 B2 AA         ld (sprtmp0),a         ; store new position.
141+  AA37 2B               dec hl
142+  AA38 2B               dec hl
143+  AA39 11 20 00         ld de,32            ; add 32 to get to the next row
144+  AA3C 19               add hl,de           ; add 32
145+  AA3D              sprites_draw2by2sprite6
146+  AA3D EB               ex de,hl            ; screen address in de.
147+  AA3E 2A B0 AA         ld hl,(sprtmp)        ; restore graphic address.
148+  AA41 08               ex af,af'           ; restore loop counter.
149+  AA42 3D               dec a               ; decrement it.
150+  AA43 C2 06 AA         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  AA46 2E 03            ld l,3
152+  AA48 CD 4C AA         call sprites_marklinesforupdatescreen
153+  AA4B C9               ret                 ; job done.
154+  AA4C
155+  AA4C              ;
156+  AA4C              ; Marks lines for update with screen coords
157+  AA4C              ; Inputs:
158+  AA4C              ; l - number to update
159+  AA4C              ;
160+  AA4C              sprites_marklinesforupdatescreen:
161+  AA4C F5               push af
162+  AA4D ED 4B AC AA      ld bc,(origcoords)
163+  AA51 CD C3 A8         call screen_getcharcoordsfromscreencoords
164+  AA54 ED 43 AC AA      ld (origcoords),bc
165+  AA58 CD 67 AA         call sprites_marklinesforupdate
166+  AA5B F1               pop af
167+  AA5C C9               ret
168+  AA5D
169+  AA5D              ;
170+  AA5D              ; Marks lines for update with char coords
171+  AA5D              ; Inputs:
172+  AA5D              ; l - number to update
173+  AA5D              ;
174+  AA5D              sprites_marklinesforupdatechar:
175+  AA5D F5               push af
176+  AA5E ED 43 AC AA      ld (origcoords),bc
177+  AA62 CD 67 AA         call sprites_marklinesforupdate
178+  AA65 F1               pop af
179+  AA66 C9               ret
180+  AA67
181+  AA67              ;
182+  AA67              ; Marks lines for update
183+  AA67              ; Inputs:
184+  AA67              ; l - number to update
185+  AA67              ;
186+  AA67              sprites_marklinesforupdate:
187+  AA67 ED 4B AC AA      ld bc,(origcoords)
188+  AA6B ED 5B 71 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
189+  AA6F 78               ld a,b
190+  AA70 93               sub e
191+  AA71 47               ld b,a
192+  AA72 7D               ld a,l                          ; get loop counter
193+  AA73              sprites_marklinesforupdate0:
194+  AA73 C5               push bc
195+  AA74 08               ex af,af'                     ; store loop counter
196+  AA75 78               ld a,b
197+  AA76 CD BF A5         call buffer_marklineforupdate ; mark this line for update
198+  AA79 ED 4B AC AA      ld bc,(origcoords)            ; move the coords for the next line
199+  AA7D 04               inc b
200+  AA7E ED 43 AC AA      ld (origcoords),bc
201+  AA82 C1               pop bc
202+  AA83 04               inc b
203+  AA84 08               ex af,af'                     ; restore loop counter
204+  AA85 3D               dec a
205+  AA86 C2 73 AA         jp nz,sprites_marklinesforupdate0
206+  AA89 C9               ret
207+  AA8A
208+  AA8A              ;
209+  AA8A              ; This routine returns a buffer address for (c, b) in de (c vert).
210+  AA8A              ; For example: 0,0 will be at memory offset 0
211+  AA8A              ; 1,0 (1 down) will be at memory offset 1
212+  AA8A              ; 0,7 will be at memory offset 0
213+  AA8A              ; 9,1 will be at memory offset 8+1
214+  AA8A              ; 8,0 will be at memory offset 256
215+  AA8A              ; 9,0 will be at memory offset 257
216+  AA8A              ; Outputs:
217+  AA8A              ; de - coords
218+  AA8A              ;
219+  AA8A              sprites_scadd:
220+  AA8A 79               ld a,c               ; calculate vertical offset
221+  AA8B E6 F8            and 248             ;  to get nearest multiple of 8
222+  AA8D 0F               rrca
223+  AA8E 0F               rrca
224+  AA8F 0F               rrca                ; divide by 8
225+  AA90 67               ld h,a
226+  AA91 78               ld a,b               ; calculate horizontal offset
227+  AA92 E6 F8            and 248             ;  to get nearest multiple of 8
228+  AA94 0F               rrca
229+  AA95 0F               rrca
230+  AA96 0F               rrca                ; divide by 8
231+  AA97 6F               ld l,a
232+  AA98 C5               push bc             ; store the screen coords
233+  AA99 44 4D            ld bc,hl            ; load bc with the character coords
234+  AA9B CD DF A8         call screen_getbufferaddress
235+  AA9E C1               pop bc              ; get back screen coords, de is now memory of character
236+  AA9F 79               ld a,c              ; now add the vertical within the cell
237+  AAA0 E6 07            and 7
238+  AAA2 0F               rrca                ; multiply by 32.
239+  AAA3 0F               rrca
240+  AAA4 0F               rrca
241+  AAA5 6F               ld l,a
242+  AAA6 26 00            ld h,0
243+  AAA8 19               add hl,de
244+  AAA9 54 5D            ld de,hl
245+  AAAB C9               ret
246+  AAAC
247+  AAAC 00 00        origcoords   defb 0,0           ; general-use coordinates.
248+  AAAE
249+  AAAE 00           dispx   defb 0           ; general-use coordinates.
250+  AAAF 00           dispy   defb 0
251+  AAB0 00 00        sprtmp  defb 0,0           ; sprite temporary address.
252+  AAB2 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
253+  AAB4
# file closed: screen/sprites.asm
 26   AAB4                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AAB4              ;
  2+  AAB4              ; Draws the title screen
  3+  AAB4              ;
  4+  AAB4              titlescreen_show:
  5+  AAB4 CD 2C AB         call titlescreen_init
  6+  AAB7 CD D5 AA         call titlescreen_drawtitle
  7+  AABA 3E FA            ld a,250                              ; wait for 200 frames
  8+  AABC CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
  9+  AABF 7B               ld a,e
 10+  AAC0 FE 01            cp 1                                  ; was anything pressed?
 11+  AAC2 C8               ret z                                 ; end titlescreen if so
 12+  AAC3
 13+  AAC3 CD 3F AB         call titlescreen_alt_init             ; otherwise, draw alt screen
 14+  AAC6 CD F1 AA         call titlescreen_alt_drawtitle
 15+  AAC9 3E FA            ld a,250                              ; wait for 200 frames
 16+  AACB CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 17+  AACE 7B               ld a,e
 18+  AACF FE 01            cp 1                                  ; was anything pressed?
 19+  AAD1 C2 B4 AA         jp nz,titlescreen_show                ; start again if not
 20+  AAD4 C9               ret
 21+  AAD5
 22+  AAD5              ;
 23+  AAD5              ; Draws the iconic logo
 24+  AAD5              ;
 25+  AAD5              titlescreen_drawtitle:
 26+  AAD5 06 67            ld b,103              ; number of points
 27+  AAD7 DD 21 4C AB      ld ix,titlescreen_logo_data
 28+  AADB              titlescreen_drawtitle0:
 29+  AADB C5               push bc
 30+  AADC DD 4E 00         ld c,(ix)                   ; got horiz
 31+  AADF DD 23            inc ix
 32+  AAE1 DD 46 00         ld b,(ix)                   ; got vert
 33+  AAE4 DD 23            inc ix
 34+  AAE6 CD 98 A8         call screen_getscreenattradress ; memory in de
 35+  AAE9 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 36+  AAEA 3E 13            ld a,19
 37+  AAEC 12               ld (de),a
 38+  AAED C1               pop bc
 39+  AAEE 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 40+  AAF0 C9               ret
 41+  AAF1
 42+  AAF1              ;
 43+  AAF1              ; Draws the alternate title screen
 44+  AAF1              ;
 45+  AAF1              titlescreen_alt_drawtitle:
 46+  AAF1 21 3B 81         ld hl,string_alttitlescreen_1
 47+  AAF4 CD BF 84         call string_print
 48+  AAF7 21 47 81         ld hl,string_alttitlescreen_2
 49+  AAFA CD BF 84         call string_print
 50+  AAFD 21 42 82         ld hl,string_alttitlescreen_3
 51+  AB00 CD BF 84         call string_print
 52+  AB03 06 20            ld b,32
 53+  AB05 3E 43            ld a,67
 54+  AB07 11 00 58         ld de,22528                         ; top row attrs here
 55+  AB0A CD 26 A8         call screen_setcolours
 56+  AB0D 06 20            ld b,32
 57+  AB0F 3E 46            ld a,70
 58+  AB11 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 59+  AB14 CD 26 A8         call screen_setcolours
 60+  AB17 06 20            ld b,32
 61+  AB19 3E 43            ld a,67
 62+  AB1B 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 63+  AB1E CD 26 A8         call screen_setcolours
 64+  AB21 06 20            ld b,32
 65+  AB23 3E 42            ld a,66
 66+  AB25 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 67+  AB28 CD 26 A8         call screen_setcolours
 68+  AB2B C9               ret
 69+  AB2C
 70+  AB2C              ;
 71+  AB2C              ; Initialises the screen
 72+  AB2C              ;
 73+  AB2C              titlescreen_init:
 74+  AB2C              ; We want a black screen.
 75+  AB2C 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 76+  AB2E                                      ; bright (64).
 77+  AB2E CD 67 80         call utilities_clearscreen
 78+  AB31 32 8D 5C         ld (23693),a        ; set our screen colours.
 79+  AB34 3E 01            ld a,1              ; 2 is the code for red.
 80+  AB36 D3 FE            out (254),a         ; write to port 254.
 81+  AB38
 82+  AB38 21 26 81         ld hl,string_titlescreen_copyright
 83+  AB3B CD BF 84         call string_print
 84+  AB3E
 85+  AB3E C9               ret
 86+  AB3F
 87+  AB3F              ;
 88+  AB3F              ; Initialises the screen
 89+  AB3F              ;
 90+  AB3F              titlescreen_alt_init:
 91+  AB3F              ; We want a black screen.
 92+  AB3F 3E 47            ld a,71             ; white ink (7) on black paper (0),
 93+  AB41                                      ; bright (64).
 94+  AB41 CD 67 80         call utilities_clearscreen
 95+  AB44 32 8D 5C         ld (23693),a        ; set our screen colours.
 96+  AB47 3E 00            ld a,0              ; 2 is the code for red.
 97+  AB49 D3 FE            out (254),a         ; write to port 254.
 98+  AB4B
 99+  AB4B C9               ret
100+  AB4C
101+  AB4C              ;
102+  AB4C              ; Horiz, vert
103+  AB4C              ;
104+  AB4C              titlescreen_logo_data:
105+  AB4C 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
105+  AB50 0A 00 0C 00
105+  AB54 0F 00 11 00
105+  AB58 12 00 13 00
106+  AB5C 09 01 0C 01      defb 9,1,12,1,15,1,17,1
106+  AB60 0F 01 11 01
107+  AB64 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
107+  AB68 0D 02 0E 02
107+  AB6C 0F 02 11 02
107+  AB70 12 02 13 02
108+  AB74 09 03 0C 03      defb 9,3,12,3,15,3,17,3
108+  AB78 0F 03 11 03
109+  AB7C 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
109+  AB80 0F 04 11 04
109+  AB84 12 04 13 04
110+  AB88 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
110+  AB8C 02 06 03 06
110+  AB90 04 06 05 06
110+  AB94 06 06 07 06
110+  AB98 08 06 09 06
110+  AB9C 0A 06 0B 06
111+  ABA0 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
111+  ABA4 12 06 13 06
111+  ABA8 14 06 15 06
111+  ABAC 16 06 17 06
111+  ABB0 18 06 19 06
111+  ABB4 1A 06 1B 06
112+  ABB8 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
112+  ABBC 02 09 02 0A
112+  ABC0 02 0B 02 0C
112+  ABC4 02 0D 02 0E
112+  ABC8 02 0F 02 10
112+  ABCC 02 11 02 12
112+  ABD0 02 13 02 14
112+  ABD4 02 15
113+  ABD6 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
113+  ABDA 19 09 19 0A
113+  ABDE 19 0B 19 0C
113+  ABE2 19 0D 19 0E
113+  ABE6 19 0F 19 10
113+  ABEA 19 11 19 12
113+  ABEE 19 13 19 14
113+  ABF2 19 15
114+  ABF4 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
114+  ABF8 05 0B 06 0B
114+  ABFC 07 0B 08 0B
114+  AC00 09 0B 0A 0B
114+  AC04 0B 0B
115+  AC06 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
115+  AC0A 0B 09 0B 0A
116+  AC0E 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
116+  AC12 10 10 10 11
116+  AC16 10 12 10 13
117+  AC1A
# file closed: screen/titlescreen.asm
 27   AC1A                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  AC1A              ;
  2+  AC1A              ; Draws the life remaining screen
  3+  AC1A              ;
  4+  AC1A              lifescreen_draw:
  5+  AC1A CD 60 AC         call lifescreen_init
  6+  AC1D
  7+  AC1D 3A DA BA         ld a,(game_currentplayer)             ; get the current player
  8+  AC20 C6 30            add 48                                ; add 48 to get char
  9+  AC22 21 48 83         ld hl,string_lifescreen_player+10
 10+  AC25 77               ld (hl),a                             ; load this to the string we're about to show
 11+  AC26
 12+  AC26 21 3E 83         ld hl,string_lifescreen_player
 13+  AC29 CD BF 84         call string_print
 14+  AC2C
 15+  AC2C 3A 11 BB         ld a,(player+9)                       ; get the current player lives
 16+  AC2F C6 30            add 48                                ; add 48 to get the character
 17+  AC31 FE 31            cp 49
 18+  AC33 C2 46 AC         jp nz,lifescreen_draw0
 19+  AC36 21 58 83         ld hl,string_lifescreen_lastman
 20+  AC39
 21+  AC39 06 08            ld b,8
 22+  AC3B 3E 0A            ld a,10                                ; set red
 23+  AC3D 11 6C 58         ld de,22528+108                        ; attrs here
 24+  AC40 CD 26 A8         call screen_setcolours
 25+  AC43
 26+  AC43 C3 4D AC         jp lifescreen_draw1
 27+  AC46              lifescreen_draw0:
 28+  AC46 21 4D 83         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  AC49 77               ld (hl),a                             ; load this to the string we're about to show
 30+  AC4A 21 4B 83         ld hl,string_lifescreen_lives
 31+  AC4D              lifescreen_draw1:
 32+  AC4D CD BF 84         call string_print
 33+  AC50
 34+  AC50 3E 86            ld a,134
 35+  AC52 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AC55 06 0A            ld b,10
 37+  AC57 CD 26 A8         call screen_setcolours
 38+  AC5A
 39+  AC5A 3E 64            ld a,100                              ; wait for 200 frames
 40+  AC5C CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 41+  AC5F
 42+  AC5F C9               ret
 43+  AC60
 44+  AC60              ;
 45+  AC60              ; Initialises the screen
 46+  AC60              ;
 47+  AC60              lifescreen_init:
 48+  AC60              ; We want a blue screen.
 49+  AC60                  ;call $0D6B
 50+  AC60 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 51+  AC62                                      ; bright (64).
 52+  AC62 CD 67 80         call utilities_clearscreen
 53+  AC65 32 8D 5C         ld (23693),a        ; set our screen colours.
 54+  AC68 3E 01            ld a,1              ; 1 is the code for blue.
 55+  AC6A D3 FE            out (254),a         ; write to port 254.
 56+  AC6C                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 57+  AC6C
 58+  AC6C C9               ret
# file closed: screen/lifescreen.asm
 28   AC6D                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AC6D              ;
  2+  AC6D              ; Draws the game over screen
  3+  AC6D              ;
  4+  AC6D              gameover_draw:
  5+  AC6D CD D6 C1         call scores_processhighscores
  6+  AC70
  7+  AC70              gameover_draw0:
  8+  AC70 CD B0 AC         call gameover_enterhighscores
  9+  AC73
 10+  AC73 CD 4E AD         call gameover_init
 11+  AC76
 12+  AC76 21 63 83         ld hl,string_gameoverscreen_gameover
 13+  AC79 CD BF 84         call string_print
 14+  AC7C
 15+  AC7C 21 6F 83         ld hl,string_gameoverscreen_copyright
 16+  AC7F CD BF 84         call string_print
 17+  AC82
 18+  AC82 CD 93 AC         call gameover_commontext
 19+  AC85
 20+  AC85 06 0B            ld b,11
 21+  AC87 3E 42            ld a,66
 22+  AC89 11 2B 58         ld de,22528+43                         ; attrs here
 23+  AC8C CD 26 A8         call screen_setcolours
 24+  AC8F CD 47 80         call utilities_waitforkey   ; wait for keypress
 25+  AC92
 26+  AC92 C9               ret
 27+  AC93
 28+  AC93              ;
 29+  AC93              ; Draws text shared by the game over and high score screens
 30+  AC93              ;
 31+  AC93              gameover_commontext:
 32+  AC93 CD F8 A7         call screen_setuptext       ; show scores
 33+  AC96 CD A0 C1         call scores_printscores     ; print the current scores
 34+  AC99
 35+  AC99 21 98 83         ld hl,string_gameover_credits
 36+  AC9C CD BF 84         call string_print
 37+  AC9F
 38+  AC9F 21 84 83         ld hl,string_gameoverscreen_bestscores
 39+  ACA2 CD BF 84         call string_print
 40+  ACA5
 41+  ACA5 06 20            ld b,32
 42+  ACA7 3E 45            ld a,69
 43+  ACA9 11 C0 5A         ld de,22528+704                         ; attrs here
 44+  ACAC CD 26 A8         call screen_setcolours
 45+  ACAF
 46+  ACAF C9               ret
 47+  ACB0
 48+  ACB0              ;
 49+  ACB0              ; If required, enter highscore
 50+  ACB0              ;
 51+  ACB0              gameover_enterhighscores:
 52+  ACB0                  ; check if we need to enter initial
 53+  ACB0 3A D5 C1         ld a,(scores_highscoretmp)
 54+  ACB3 FE 00            cp 0
 55+  ACB5 C8               ret z
 56+  ACB6 CD E4 AC         call gameover_enterhighscores_init
 57+  ACB9 3A D5 C1         ld a,(scores_highscoretmp)
 58+  ACBC 3D               dec a
 59+  ACBD 3D               dec a
 60+  ACBE 3D               dec a                                   ; get high score location back to position of name
 61+  ACBF 16 00            ld d,0
 62+  ACC1 5F               ld e,a
 63+  ACC2 21 5C C1         ld hl,scores_table
 64+  ACC5 19               add hl,de                               ; load memory into hl
 65+  ACC6 08               ex af,af'
 66+  ACC7 06 0F            ld b,15
 67+  ACC9 CD 82 80         call utilities_pauseforframes           ; pause for a little bit
 68+  ACCC 06 03            ld b,3                                  ; collect three chars
 69+  ACCE              gameover_draw2:
 70+  ACCE C5               push bc
 71+  ACCF E5               push hl
 72+  ACD0 CD 86 80         call utilities_readkey               ; get key into a
 73+  ACD3 E1               pop hl
 74+  ACD4 77               ld (hl),a
 75+  ACD5 23               inc hl
 76+  ACD6 E5               push hl
 77+  ACD7 CD C2 C1         call scores_showtable
 78+  ACDA E1               pop hl
 79+  ACDB 06 0F            ld b,15
 80+  ACDD CD 82 80         call utilities_pauseforframes
 81+  ACE0 C1               pop bc
 82+  ACE1 10 EB            djnz gameover_draw2
 83+  ACE3 C9               ret
 84+  ACE4
 85+  ACE4              ;
 86+  ACE4              ; Displays the screen text for high score entry
 87+  ACE4              ;
 88+  ACE4              gameover_enterhighscores_init:
 89+  ACE4
 90+  ACE4 CD 4E AD         call gameover_init
 91+  ACE7 CD 93 AC         call gameover_commontext
 92+  ACEA
 93+  ACEA 21 A4 83         ld hl,string_highscore_congratulations
 94+  ACED CD BF 84         call string_print
 95+  ACF0
 96+  ACF0 3A DA BA         ld a,(game_currentplayer)
 97+  ACF3 FE 01            cp 1
 98+  ACF5 21 B6 83         ld hl,string_highscore_player1
 99+  ACF8 C3 FE AC         jp gameover_enterhighscores_init1
100+  ACFB              gameover_enterhighscores_init0:
101+  ACFB 21 C1 83         ld hl,string_highscore_player2
102+  ACFE              gameover_enterhighscores_init1:
103+  ACFE CD BF 84         call string_print
104+  AD01 06 60            ld b,96
105+  AD03 3E 43            ld a,67
106+  AD05 11 A0 58         ld de,22528+160                         ; attrs here
107+  AD08 CD 26 A8         call screen_setcolours
108+  AD0B
109+  AD0B 21 CC 83         ld hl,string_highscore_youhaveearned
110+  AD0E CD BF 84         call string_print
111+  AD11
112+  AD11 3A D5 C1         ld a,(scores_highscoretmp)
113+  AD14 FE 05            cp 5
114+  AD16 CA 24 AD         jp z, gameover_enterhighscores_init2    ; first place
115+  AD19 FE 11            cp 17
116+  AD1B CA 2A AD         jp z, gameover_enterhighscores_init3    ; 2nd place
117+  AD1E 21 08 84         ld hl,string_highscore_place3           ; 3rd place
118+  AD21 C3 30 AD         jp gameover_enterhighscores_init4
119+  AD24              gameover_enterhighscores_init2
120+  AD24 21 DE 83         ld hl,string_highscore_place1
121+  AD27 C3 30 AD         jp gameover_enterhighscores_init4
122+  AD2A              gameover_enterhighscores_init3
123+  AD2A 21 F3 83         ld hl,string_highscore_place2
124+  AD2D C3 30 AD         jp gameover_enterhighscores_init4
125+  AD30              gameover_enterhighscores_init4
126+  AD30 CD BF 84         call string_print
127+  AD33
128+  AD33 06 60            ld b,96
129+  AD35 3E 42            ld a,66
130+  AD37 11 40 59         ld de,22528+320                         ; attrs here
131+  AD3A CD 26 A8         call screen_setcolours
132+  AD3D
133+  AD3D 21 1D 84         ld hl,string_highscore_pleaseenter
134+  AD40 CD BF 84         call string_print
135+  AD43
136+  AD43 06 60            ld b,96
137+  AD45 3E 46            ld a,70
138+  AD47 11 E0 59         ld de,22528+480                         ; attrs here
139+  AD4A CD 26 A8         call screen_setcolours
140+  AD4D C9               ret
141+  AD4E
142+  AD4E              ;
143+  AD4E              ; Initialises the screen
144+  AD4E              ;
145+  AD4E              gameover_init:
146+  AD4E              ; We want a black screen.
147+  AD4E 3E 47            ld a,71             ; white ink (7) on black paper (0),
148+  AD50                                      ; bright (64).
149+  AD50 CD 67 80         call utilities_clearscreen
150+  AD53 32 8D 5C         ld (23693),a        ; set our screen colours.
151+  AD56 3E 00            ld a,0              ; 2 is the code for red.
152+  AD58 D3 FE            out (254),a         ; write to port 254.
153+  AD5A C9               ret
# file closed: screen/gameover.asm
 29   AD5B                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AD5B              ;
  2+  AD5B              ; Draws the level transition screen
  3+  AD5B              ;
  4+  AD5B              endlevel_draw:
  5+  AD5B CD 51 AE         call endlevel_init
  6+  AD5E CD 3A AE         call endlevel_commontext
  7+  AD61
  8+  AD61 21 A4 83         ld hl,string_highscore_congratulations
  9+  AD64 CD BF 84         call string_print
 10+  AD67
 11+  AD67 3A DA BA         ld a,(game_currentplayer)
 12+  AD6A FE 01            cp 1
 13+  AD6C 21 B6 83         ld hl,string_highscore_player1
 14+  AD6F C3 75 AD         jp endlevel_init1
 15+  AD72              endlevel_init0:
 16+  AD72 21 C1 83         ld hl,string_highscore_player2
 17+  AD75              endlevel_init1:
 18+  AD75 CD BF 84         call string_print
 19+  AD78
 20+  AD78 21 3A 84         ld hl,string_endlevel_youhaveearned
 21+  AD7B CD BF 84         call string_print
 22+  AD7E
 23+  AD7E CD D9 AD         call endlevel_workoutbonus
 24+  AD81 D5               push de
 25+  AD82 08               ex af,af'                               ; store the a value for later
 26+  AD83 CD BF 84         call string_print
 27+  AD86 D1               pop de
 28+  AD87 62 6B            ld hl,de                                ; get the points text into de
 29+  AD89 CD BF 84         call string_print
 30+  AD8C
 31+  AD8C 21 A5 84         ld hl, string_endlevel_anothergo
 32+  AD8F CD BF 84         call string_print
 33+  AD92
 34+  AD92 06 20            ld b,32
 35+  AD94 3E 63            ld a,99
 36+  AD96 11 60 59         ld de,22528+352                         ; attrs here
 37+  AD99 CD 26 A8         call screen_setcolours
 38+  AD9C
 39+  AD9C 06 20            ld b,32
 40+  AD9E 3E 65            ld a,101
 41+  ADA0 11 A0 59         ld de,22528+416                         ; attrs here
 42+  ADA3 CD 26 A8         call screen_setcolours
 43+  ADA6
 44+  ADA6 06 20            ld b,32
 45+  ADA8 3E 63            ld a,99
 46+  ADAA 11 E0 59         ld de,22528+480                         ; attrs here
 47+  ADAD CD 26 A8         call screen_setcolours
 48+  ADB0
 49+  ADB0 06 20            ld b,32
 50+  ADB2 3E 62            ld a,98
 51+  ADB4 11 40 5A         ld de,22528+576                         ; attrs here
 52+  ADB7 CD 26 A8         call screen_setcolours
 53+  ADBA
 54+  ADBA 08               ex af,af'                               ; get back a value with bonus type
 55+  ADBB 06 14            ld b,20
 56+  ADBD CD 82 80         call utilities_pauseforframes
 57+  ADC0
 58+  ADC0 47               ld b,a                      ; put the bonus count in b
 59+  ADC1              endlevel_init2:
 60+  ADC1 C5               push bc
 61+  ADC2 06 01            ld b,1
 62+  ADC4 CD 80 C1         call scores_addthousands
 63+  ADC7 CD B8 BB         call player_recordcurrentscore
 64+  ADCA CD A0 C1         call scores_printscores     ; print the current scores
 65+  ADCD 06 0A            ld b,10
 66+  ADCF CD 82 80         call utilities_pauseforframes
 67+  ADD2 C1               pop bc
 68+  ADD3 10 EC            djnz endlevel_init2
 69+  ADD5
 70+  ADD5 CD 47 80         call utilities_waitforkey   ; wait for keypress
 71+  ADD8
 72+  ADD8 C9               ret
 73+  ADD9
 74+  ADD9              ;
 75+  ADD9              ; Works out the bonus
 76+  ADD9              ; Outputs:
 77+  ADD9              ; a = 15 (all seven)
 78+  ADD9              ; a = 10 (3 large or 4 small)
 79+  ADD9              ; a = 5 (1 large diamond)
 80+  ADD9              ; hl - pointer to bonus text
 81+  ADD9              ; de - pointer to points text
 82+  ADD9              ;
 83+  ADD9              endlevel_workoutbonus:
 84+  ADD9 21 C7 B3         ld hl,level01diamonds+2     ; location of state of first diamond
 85+  ADDC 06 03            ld b,3                      ; number to check
 86+  ADDE 16 00            ld d,0                      ; zero diamond count
 87+  ADE0              endlevel_workoutbonus0:
 88+  ADE0 7E               ld a,(hl)                   ; get state
 89+  ADE1 FE 01            cp 1
 90+  ADE3 C2 E7 AD         jp nz,endlevel_workoutbonus1 ; if not, move on
 91+  ADE6 14               inc d                       ; increment diamond count
 92+  ADE7              endlevel_workoutbonus1:
 93+  ADE7 23               inc hl
 94+  ADE8 23               inc hl
 95+  ADE9 23               inc hl
 96+  ADEA 23               inc hl
 97+  ADEB 23               inc hl                      ; get to next state
 98+  ADEC 10 F2            djnz endlevel_workoutbonus0
 99+  ADEE
100+  ADEE 21 D7 B3         ld hl,level01gems+2     ; location of state of first gem
101+  ADF1 06 04            ld b,4                      ; number to check
102+  ADF3 1E 00            ld e,0                      ; zero gem count
103+  ADF5              endlevel_workoutbonus2:
104+  ADF5 7E               ld a,(hl)                   ; get state
105+  ADF6 FE 01            cp 1
106+  ADF8 C2 FC AD         jp nz,endlevel_workoutbonus3 ; if not, move on
107+  ADFB 1C               inc e                       ; increment diamond count
108+  ADFC              endlevel_workoutbonus3:
109+  ADFC 23               inc hl
110+  ADFD 23               inc hl
111+  ADFE 23               inc hl
112+  ADFF 23               inc hl
113+  AE00 23               inc hl                     ; get to next state
114+  AE01 10 F2            djnz endlevel_workoutbonus2
115+  AE03
116+  AE03 7A               ld a,d
117+  AE04 83               add e
118+  AE05 FE 07            cp 7                        ; check for max bonus
119+  AE07 C2 13 AE         jp nz,endlevel_workoutbonus4 ;
120+  AE0A 3E 0F            ld a,15
121+  AE0C 21 6A 84         ld hl, string_endlevel_bonus3
122+  AE0F 11 96 84         ld de, string_endlevel_points3
123+  AE12 C9               ret                         ; return with bonus of 15
124+  AE13              endlevel_workoutbonus4:
125+  AE13 7A               ld a,d                      ; check for for diamonds
126+  AE14 FE 03            cp 3
127+  AE16 C2 22 AE         jp nz,endlevel_workoutbonus5
128+  AE19 3E 0A            ld a,10
129+  AE1B 21 5B 84         ld hl, string_endlevel_bonus2
130+  AE1E 11 87 84         ld de, string_endlevel_points2
131+  AE21 C9               ret                         ; return with bonus of ten
132+  AE22              endlevel_workoutbonus5:
133+  AE22 7B               ld a,e                      ; check for four gems
134+  AE23 FE 04            cp 4
135+  AE25 C2 31 AE         jp nz,endlevel_workoutbonus6
136+  AE28 3E 0A            ld a,10
137+  AE2A 21 5B 84         ld hl, string_endlevel_bonus2
138+  AE2D 11 87 84         ld de, string_endlevel_points2
139+  AE30 C9               ret                         ; return with bonus of 10
140+  AE31              endlevel_workoutbonus6:
141+  AE31 3E 05            ld a,5                      ; otherwise, bonus is 5
142+  AE33 21 4C 84         ld hl, string_endlevel_bonus1
143+  AE36 11 79 84         ld de, string_endlevel_points1
144+  AE39 C9               ret
145+  AE3A
146+  AE3A              ;
147+  AE3A              ; Draws text shared by the game over and high score screens
148+  AE3A              ;
149+  AE3A              endlevel_commontext:
150+  AE3A CD F8 A7         call screen_setuptext       ; show scores
151+  AE3D CD A0 C1         call scores_printscores     ; print the current scores
152+  AE40
153+  AE40 21 84 83         ld hl,string_gameoverscreen_bestscores
154+  AE43 CD BF 84         call string_print
155+  AE46
156+  AE46 06 20            ld b,32
157+  AE48 3E 45            ld a,69
158+  AE4A 11 C0 5A         ld de,22528+704                         ; attrs here
159+  AE4D CD 26 A8         call screen_setcolours
160+  AE50
161+  AE50 C9               ret
162+  AE51
163+  AE51              ;
164+  AE51              ; Initialises the screen
165+  AE51              ;
166+  AE51              endlevel_init:
167+  AE51              ; We want a green screen.
168+  AE51 3E 61            ld a,97             ; white ink (7) on black paper (0),
169+  AE53                                      ; bright (64).
170+  AE53 CD 67 80         call utilities_clearscreen
171+  AE56 32 8D 5C         ld (23693),a        ; set our screen colours.
172+  AE59 3E 00            ld a,0              ; 2 is the code for red.
173+  AE5B D3 FE            out (254),a         ; write to port 254.
174+  AE5D C9               ret
# file closed: screen/endlevel.asm
 30   AE5E
 31   AE5E                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  AE5E              sound_gemcollected:
  2+  AE5E 21 C8 00         ld hl,200 ; pitch.
  3+  AE61 11 3E 00         ld de,62 ; duration.
  4+  AE64 CD B5 03         call 949 ; ROM beeper routine.
  5+  AE67 C9               ret
  6+  AE68
  7+  AE68              sound_pitchbend:
  8+  AE68 21 F4 01         ld hl,500 ; starting pitch.
  9+  AE6B 06 FA            ld b,250 ; length of pitch bend.
 10+  AE6D              sound_pitchbend0:
 11+  AE6D C5                push bc
 12+  AE6E E5               push hl ; store pitch.
 13+  AE6F 11 01 00         ld de,1 ; very short duration.
 14+  AE72 CD B5 03         call 949 ; ROM beeper routine.
 15+  AE75 E1               pop hl ; restore pitch.
 16+  AE76 23               inc hl ; pitch going up.
 17+  AE77 C1               pop bc
 18+  AE78 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  AE7A C9               ret
 20+  AE7B
 21+  AE7B              sound_rockfell:
 22+  AE7B 08               ex af,af'
 23+  AE7C 1E 32            ld e,50 ; repeat 250 times.
 24+  AE7E 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  AE81 D5           sound_rockfell2 push de
 26+  AE82 06 20            ld b,32 ; length of step.
 27+  AE84 C5           sound_rockfell0 push bc
 28+  AE85 7E               ld a,(hl) ; next "random" number.
 29+  AE86 23               inc hl ; pointer.
 30+  AE87 E6 F8            and 248 ; we want a black border.
 31+  AE89 D3 FE            out (254),a ; write to speaker.
 32+  AE8B 7B               ld a,e ; as e gets smaller...
 33+  AE8C 2F               cpl ; ...we increase the delay.
 34+  AE8D 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  AE8E 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  AE90 C1               pop bc
 37+  AE91 10 F1            djnz sound_rockfell0 ; next step.
 38+  AE93 D1               pop de
 39+  AE94 7B               ld a,e
 40+  AE95 D6 18            sub 24 ; size of step.
 41+  AE97 FE 1E            cp 30 ; end of range.
 42+  AE99 CA AA AE         jp z,sound_rockfell5
 43+  AE9C DA AA AE         jp c, sound_rockfell5
 44+  AE9F 5F               ld e,a
 45+  AEA0 2F               cpl
 46+  AEA1 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  AEA3 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  AEA5 3D               dec a
 49+  AEA6 20 F9            jr nz,sound_rockfell3
 50+  AEA8 18 D7            jr sound_rockfell2
 51+  AEAA              sound_rockfell5
 52+  AEAA 08               ex af,af'
 53+  AEAB C9               ret
 54+  AEAC
# file closed: sound/sound.asm
 32   AEAC
 33   AEAC                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  AEAC              ; ###############################################################
  2+  AEAC              ; Data for level 1
  3+  AEAC              ; ###############################################################
  4+  AEAC              level01:
  5+  AEAC
  6+  AEAC                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  AEAC
  8+  AEAC 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  AEB0 05 05 05 05
  8+  AEB4 05 05 05 05
  8+  AEB8 05 05 02 01
  8+  AEBC 01 01 03 05
  8+  AEC0 05 05 05 05
  8+  AEC4 05 05 05 05
  8+  AEC8 05 05 00 00
  9+  AECC 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  AED0 05 05 05 05
  9+  AED4 05 05 05 05
  9+  AED8 02 01 01 01
  9+  AEDC 01 01 01 01
  9+  AEE0 03 05 05 05
  9+  AEE4 05 05 05 05
  9+  AEE8 05 05 00 00
 10+  AEEC 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  AEF0 05 05 05 05
 10+  AEF4 05 05 02 01
 10+  AEF8 01 01 01 01
 10+  AEFC 01 01 01 01
 10+  AF00 01 01 03 05
 10+  AF04 0D 0D 0D 0D
 10+  AF08 0D 0D 00 00
 11+  AF0C 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  AF10 01 01 00 01
 11+  AF14 01 01 01 01
 11+  AF18 01 01 01 01
 11+  AF1C 01 01 01 01
 11+  AF20 01 01 01 03
 11+  AF24 05 05 05 05
 11+  AF28 05 05 00 00
 12+  AF2C 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  AF30 04 04 04 04
 12+  AF34 04 04 01 01
 12+  AF38 01 01 01 01
 12+  AF3C 01 01 01 01
 12+  AF40 01 01 01 01
 12+  AF44 01 01 01 01
 12+  AF48 00 01 00 00
 13+  AF4C 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  AF50 04 04 04 04
 13+  AF54 04 04 04 04
 13+  AF58 01 01 01 01
 13+  AF5C 01 01 01 01
 13+  AF60 01 01 01 01
 13+  AF64 00 00 00 00
 13+  AF68 00 01 00 00
 14+  AF6C 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  AF70 04 01 01 01
 14+  AF74 01 01 04 04
 14+  AF78 04 04 01 01
 14+  AF7C 01 01 01 01
 14+  AF80 01 00 00 00
 14+  AF84 00 01 01 01
 14+  AF88 01 01 00 00
 15+  AF8C 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  AF90 04 04 04 04
 15+  AF94 04 01 04 04
 15+  AF98 04 04 04 04
 15+  AF9C 04 04 00 00
 15+  AFA0 00 00 04 04
 15+  AFA4 04 04 04 04
 15+  AFA8 04 01 00 00
 16+  AFAC 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  AFB0 01 04 01 01
 16+  AFB4 01 01 04 04
 16+  AFB8 04 04 04 04
 16+  AFBC 04 04 00 04
 16+  AFC0 04 04 04 04
 16+  AFC4 04 04 04 04
 16+  AFC8 04 01 00 00
 17+  AFCC 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  AFD0 00 00 00 00
 17+  AFD4 00 04 04 04
 17+  AFD8 04 04 04 04
 17+  AFDC 04 04 00 04
 17+  AFE0 04 04 04 04
 17+  AFE4 04 04 04 04
 17+  AFE8 04 01 00 00
 18+  AFEC 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  AFF0 15 15 15 15
 18+  AFF4 15 01 04 04
 18+  AFF8 04 04 04 04
 18+  AFFC 04 04 00 04
 18+  B000 04 04 04 04
 18+  B004 04 04 04 04
 18+  B008 04 01 00 00
 19+  B00C 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B010 00 00 00 00
 19+  B014 00 01 04 04
 19+  B018 04 04 04 04
 19+  B01C 04 04 00 04
 19+  B020 04 04 04 04
 19+  B024 04 00 00 00
 19+  B028 00 01 00 00
 20+  B02C 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B030 00 00 00 00
 20+  B034 00 01 04 04
 20+  B038 04 04 04 04
 20+  B03C 04 04 00 04
 20+  B040 04 04 04 04
 20+  B044 04 00 04 04
 20+  B048 00 01 00 00
 21+  B04C 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B050 06 06 06 06
 21+  B054 06 01 04 04
 21+  B058 04 04 04 04
 21+  B05C 04 04 00 04
 21+  B060 04 04 04 04
 21+  B064 04 00 04 04
 21+  B068 00 01 00 00
 22+  B06C 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B070 1A 1A 1A 1A
 22+  B074 1A 01 04 00
 22+  B078 00 00 00 00
 22+  B07C 00 00 00 00
 22+  B080 00 00 00 00
 22+  B084 00 00 04 04
 22+  B088 00 01 00 00
 23+  B08C 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B090 1A 1A 1A 1A
 23+  B094 1A 01 04 00
 23+  B098 04 04 04 04
 23+  B09C 04 04 00 04
 23+  B0A0 04 04 00 04
 23+  B0A4 04 04 04 04
 23+  B0A8 00 01 00 00
 24+  B0AC 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B0B0 1A 1A 1A 1A
 24+  B0B4 1A 01 04 00
 24+  B0B8 04 04 04 04
 24+  B0BC 04 04 00 04
 24+  B0C0 04 04 00 04
 24+  B0C4 04 04 04 04
 24+  B0C8 00 01 00 00
 25+  B0CC 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B0D0 01 01 01 01
 25+  B0D4 01 01 04 00
 25+  B0D8 04 04 04 04
 25+  B0DC 04 04 00 04
 25+  B0E0 04 04 00 04
 25+  B0E4 04 04 04 04
 25+  B0E8 00 01 00 00
 26+  B0EC 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B0F0 04 04 04 04
 26+  B0F4 04 04 04 00
 26+  B0F8 04 04 04 04
 26+  B0FC 04 04 00 04
 26+  B100 04 04 00 00
 26+  B104 00 00 04 04
 26+  B108 04 01 00 00
 27+  B10C 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B110 04 04 00 00
 27+  B114 00 00 00 00
 27+  B118 04 04 04 04
 27+  B11C 04 04 00 04
 27+  B120 04 04 04 04
 27+  B124 04 00 04 04
 27+  B128 04 01 00 00
 28+  B12C 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B130 04 04 00 04
 28+  B134 04 04 04 04
 28+  B138 04 04 04 04
 28+  B13C 04 04 00 04
 28+  B140 04 04 04 04
 28+  B144 04 00 04 04
 28+  B148 04 01 00 00
 29+  B14C 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B150 04 04 00 04
 29+  B154 04 04 01 01
 29+  B158 01 01 01 01
 29+  B15C 01 01 01 01
 29+  B160 01 01 01 01
 29+  B164 04 00 04 04
 29+  B168 04 01 00 00
 30+  B16C 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B170 04 04 00 04
 30+  B174 04 04 01 00
 30+  B178 00 00 00 00
 30+  B17C 00 00 00 00
 30+  B180 00 00 00 01
 30+  B184 04 00 04 04
 30+  B188 04 01 00 00
 31+  B18C 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B190 04 04 00 04
 31+  B194 04 04 01 00
 31+  B198 00 00 00 00
 31+  B19C 00 00 00 00
 31+  B1A0 00 00 00 01
 31+  B1A4 04 00 04 04
 31+  B1A8 04 01 00 00
 32+  B1AC 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B1B0 04 04 00 04
 32+  B1B4 04 04 01 00
 32+  B1B8 00 00 00 00
 32+  B1BC 00 00 00 00
 32+  B1C0 00 00 00 01
 32+  B1C4 04 00 04 04
 32+  B1C8 04 01 00 00
 33+  B1CC 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B1D0 04 04 00 04
 33+  B1D4 04 04 04 00
 33+  B1D8 00 00 00 00
 33+  B1DC 00 00 00 00
 33+  B1E0 00 00 00 04
 33+  B1E4 04 04 04 04
 33+  B1E8 04 01 00 00
 34+  B1EC 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B1F0 04 04 04 04
 34+  B1F4 04 04 01 00
 34+  B1F8 00 00 00 00
 34+  B1FC 00 00 00 00
 34+  B200 00 00 00 01
 34+  B204 04 04 04 04
 34+  B208 04 01 00 00
 35+  B20C 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B210 04 04 04 04
 35+  B214 04 04 01 00
 35+  B218 00 00 01 00
 35+  B21C 00 00 00 01
 35+  B220 00 00 00 01
 35+  B224 04 04 04 04
 35+  B228 04 01 00 00
 36+  B22C 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B230 01 01 01 01
 36+  B234 01 01 01 01
 36+  B238 01 01 01 01
 36+  B23C 01 01 01 01
 36+  B240 01 01 01 01
 36+  B244 01 01 01 01
 36+  B248 01 01 00 00
 37+  B24C
 38+  B24C              ; ###############################################################
 39+  B24C              ; Object data: horiz, vert, state, memh, meml
 40+  B24C              ; ###############################################################
 41+  B24C              level01rocks:
 42+  B24C 09 04 00 00      defb 9,4,0,0,0
 42+  B250 00
 43+  B251 0C 07 00 00      defb 12,7,0,0,0
 43+  B255 00
 44+  B256 10 07 00 00      defb 16,7,0,0,0
 44+  B25A 00
 45+  B25B 0B 08 00 00      defb 11,8,0,0,0
 45+  B25F 00
 46+  B260 0A 0A 00 00      defb 10,10,0,0,0
 46+  B264 00
 47+  B265 0C 0A 00 00      defb 12,10,0,0,0
 47+  B269 00
 48+  B26A 0D 09 00 00      defb 13,9,0,0,0
 48+  B26E 00
 49+  B26F 0E 08 00 00      defb 14,8,0,0,0
 49+  B273 00
 50+  B274 0F 0B 00 00      defb 15,11,0,0,0
 50+  B278 00
 51+  B279 0B 0C 00 00      defb 11,12,0,0,0
 51+  B27D 00
 52+  B27E 11 0C 00 00      defb 17,12,0,0,0
 52+  B282 00
 53+  B283 13 08 00 00      defb 19,8,0,0,0
 53+  B287 00
 54+  B288 16 09 00 00      defb 22,9,0,0,0
 54+  B28C 00
 55+  B28D 13 0A 00 00      defb 19,10,0,0,0
 55+  B291 00
 56+  B292 15 0A 00 00      defb 21,10,0,0,0
 56+  B296 00
 57+  B297 15 0C 00 00      defb 21,12,0,0,0
 57+  B29B 00
 58+  B29C 16 0C 00 00      defb 22,12,0,0,0
 58+  B2A0 00
 59+  B2A1 18 0A 00 00      defb 24,10,0,0,0
 59+  B2A5 00
 60+  B2A6 19 09 00 00      defb 25,9,0,0,0
 60+  B2AA 00
 61+  B2AB 1C 09 00 00      defb 28,9,0,0,0
 61+  B2AF 00
 62+  B2B0 1B 0C 00 00      defb 27,12,0,0,0
 62+  B2B4 00
 63+  B2B5 1A 0D 00 00      defb 26,13,0,0,0
 63+  B2B9 00
 64+  B2BA 19 0E 00 00      defb 25,14,0,0,0
 64+  B2BE 00
 65+  B2BF 19 10 00 00      defb 25,16,0,0,0
 65+  B2C3 00
 66+  B2C4 1A 11 00 00      defb 26,17,0,0,0
 66+  B2C8 00
 67+  B2C9 1B 11 00 00      defb 27,17,0,0,0
 67+  B2CD 00
 68+  B2CE 1C 12 00 00      defb 28,18,0,0,0
 68+  B2D2 00
 69+  B2D3 1A 13 00 00      defb 26,19,0,0,0
 69+  B2D7 00
 70+  B2D8 1B 15 00 00      defb 27,21,0,0,0
 70+  B2DC 00
 71+  B2DD 1A 17 00 00      defb 26,23,0,0,0
 71+  B2E1 00
 72+  B2E2 1B 18 00 00      defb 27,24,0,0,0
 72+  B2E6 00
 73+  B2E7 19 18 00 00      defb 25,24,0,0,0
 73+  B2EB 00
 74+  B2EC 18 17 00 00      defb 24,23,0,0,0
 74+  B2F0 00
 75+  B2F1 13 14 00 00      defb 19,20,0,0,0
 75+  B2F5 00
 76+  B2F6 14 12 00 00      defb 20,18,0,0,0
 76+  B2FA 00
 77+  B2FB 14 10 00 00      defb 20,16,0,0,0
 77+  B2FF 00
 78+  B300 15 10 00 00      defb 21,16,0,0,0
 78+  B304 00
 79+  B305 16 12 00 00      defb 22,18,0,0,0
 79+  B309 00
 80+  B30A 11 14 00 00      defb 17,20,0,0,0
 80+  B30E 00
 81+  B30F 0D 11 00 00      defb 13,17,0,0,0
 81+  B313 00
 82+  B314 0C 13 00 00      defb 12,19,0,0,0
 82+  B318 00
 83+  B319 0B 13 00 00      defb 11,19,0,0,0
 83+  B31D 00
 84+  B31E 0A 11 00 00      defb 10,17,0,0,0
 84+  B322 00
 85+  B323 05 12 00 00      defb 5,18,0,0,0
 85+  B327 00
 86+  B328 07 16 00 00      defb 7,22,0,0,0
 86+  B32C 00
 87+  B32D 09 17 00 00      defb 9,23,0,0,0
 87+  B331 00
 88+  B332 07 18 00 00      defb 7,24,0,0,0
 88+  B336 00
 89+  B337 05 18 00 00      defb 5,24,0,0,0
 89+  B33B 00
 90+  B33C 06 19 00 00      defb 6,25,0,0,0
 90+  B340 00
 91+  B341 08 19 00 00      defb 8,25,0,0,0
 91+  B345 00
 92+  B346 04 17 00 00      defb 4,23,0,0,0
 92+  B34A 00
 93+  B34B FF               defb 255
 94+  B34C
 95+  B34C              level01missiles:
 96+  B34C 0B 17 00 00      defb 11,23,0,0,0
 96+  B350 00
 97+  B351 0B 16 00 00      defb 11,22,0,0,0
 97+  B355 00
 98+  B356 0C 17 00 00      defb 12,23,0,0,0
 98+  B35A 00
 99+  B35B 0C 16 00 00      defb 12,22,0,0,0
 99+  B35F 00
100+  B360 0D 17 00 00      defb 13,23,0,0,0
100+  B364 00
101+  B365 0D 16 00 00      defb 13,22,0,0,0
101+  B369 00
102+  B36A 0E 17 00 00      defb 14,23,0,0,0
102+  B36E 00
103+  B36F 0E 16 00 00      defb 14,22,0,0,0
103+  B373 00
104+  B374 0F 17 00 00      defb 15,23,0,0,0
104+  B378 00
105+  B379 0F 16 00 00      defb 15,22,0,0,0
105+  B37D 00
106+  B37E 10 17 00 00      defb 16,23,0,0,0
106+  B382 00
107+  B383 10 16 00 00      defb 16,22,0,0,0
107+  B387 00
108+  B388 11 17 00 00      defb 17,23,0,0,0
108+  B38C 00
109+  B38D 11 16 00 00      defb 17,22,0,0,0
109+  B391 00
110+  B392 12 17 00 00      defb 18,23,0,0,0
110+  B396 00
111+  B397 12 16 00 00      defb 18,22,0,0,0
111+  B39B 00
112+  B39C 13 17 00 00      defb 19,23,0,0,0
112+  B3A0 00
113+  B3A1 13 16 00 00      defb 19,22,0,0,0
113+  B3A5 00
114+  B3A6 14 17 00 00      defb 20,23,0,0,0
114+  B3AA 00
115+  B3AB 14 16 00 00      defb 20,22,0,0,0
115+  B3AF 00
116+  B3B0 15 17 00 00      defb 21,23,0,0,0
116+  B3B4 00
117+  B3B5 15 16 00 00      defb 21,22,0,0,0
117+  B3B9 00
118+  B3BA 16 17 00 00      defb 22,23,0,0,0
118+  B3BE 00
119+  B3BF 16 16 00 00      defb 22,22,0,0,0
119+  B3C3 00
120+  B3C4 FF               defb 255
121+  B3C5
122+  B3C5              ;
123+  B3C5              ; Diamonds: x,y,state,mem1+mem2
124+  B3C5              ;
125+  B3C5              level01diamonds:
126+  B3C5 0C 1B 00 00      defb 12,27,0,0,0
126+  B3C9 00
127+  B3CA 10 1B 00 00      defb 16,27,0,0,0
127+  B3CE 00
128+  B3CF 15 1B 00 00      defb 21,27,0,0,0
128+  B3D3 00
129+  B3D4 FF               defb 255
130+  B3D5
131+  B3D5              level01gems:
132+  B3D5 12 14 00 00      defb 18,20,0,0,0
132+  B3D9 00
133+  B3DA 06 18 00 00      defb 6,24,0,0,0
133+  B3DE 00
134+  B3DF 19 17 00 00      defb 25,23,0,0,0
134+  B3E3 00
135+  B3E4 1C 11 00 00      defb 28,17,0,0,0
135+  B3E8 00
136+  B3E9 FF               defb 255
137+  B3EA              ;
138+  B3EA              ; Score area colours
139+  B3EA              ;
140+  B3EA              score_colours:
141+  B3EA 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  B3EE 47 47 47 47
141+  B3F2 47 47 47 42
141+  B3F6 43 43 43 43
141+  B3FA 43 43 43 43
141+  B3FE 42 47 47 47
141+  B402 47 47 47 47
141+  B406 47 47 47 47
142+  B40A 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  B40E 47 47 47 47
142+  B412 47 47 47 46
142+  B416 46 46 46 46
142+  B41A 46 46 46 46
142+  B41E 46 47 47 47
142+  B422 47 47 47 47
142+  B426 47 47 47 47
143+  B42A
144+  B42A              high_score_colours:
145+  B42A 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  B42E 42 42 47 47
145+  B432 47 47 47 47
145+  B436 43 43 43 47
145+  B43A 47 47 47 47
145+  B43E 47 46 46 46
145+  B442 47 47 47 47
145+  B446 47 47 00 00
# file closed: leveldata/level01.asm
 34   B44A                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B44A              ; Tiles graphics.
  2+  B44A              sprites:
  3+  B44A 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B44E 00 00 00 00
  4+  B452 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B456 FF FF FF FF
  5+  B45A 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B45E 1F 3F 7F FF
  6+  B462 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B466 F8 FC FE FF
  7+  B46A 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B46E 55 AA 55 AA
  8+  B472 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B476 00 00 00 00
  9+  B47A FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  B47E FF FF FF FF
 10+  B482 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  B486 00 00 00 00
 11+  B48A 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B48E F1 72 34 18
 12+  B492 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B496 FE FE FF 7E
 13+  B49A 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B49E FE FF 7E 3C
 14+  B4A2 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B4A6 00 00 FF FF
 15+  B4AA 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  B4AE FF 42 24 18
 16+  B4B2 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B4B6 00 00 00 00
 17+  B4BA 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B4BE 00 3C 5A 34
 18+  B4C2 FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  B4C6 FD FE FD FE
 19+  B4CA F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  B4CE F4 F8 F4 F8
 20+  B4D2 D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  B4D6 D0 E0 D0 E0
 21+  B4DA 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  B4DE 40 80 40 80
 22+  B4E2 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  B4E6 ED 00 00 00
 23+  B4EA 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  B4EE FF 7E 3C 18
 24+  B4F2 FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  B4F6 00 00 00 00
 25+  B4FA FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  B4FE 00 00 00 00
 26+  B502 F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  B506 00 00 00 00
 27+  B50A C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  B50E 00 00 00 00
 28+  B512 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  B516 00 00 00 00
 29+  B51A FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  B51E FF FF FF FF
 30+  B522
 31+  B522
 32+  B522              sprite_attrs:
 33+  B522 46               defb    070 ; 0, space
 34+  B523 4D               defb    077 ; 1, cyan block
 35+  B524 4D               defb    077 ; 2, slope left
 36+  B525 4D               defb    077 ; 3, slope right
 37+  B526 46               defb    070 ; 4, dirt
 38+  B527 4E               defb    078 ; 5, sky
 39+  B528 4C               defb    076 ; 6, slime
 40+  B529 42               defb    066 ; 7, trapdoor
 41+  B52A 46               defb    070 ; 8, diamond
 42+  B52B 42               defb    066 ; 9, rock
 43+  B52C 42               defb    066 ; 10, rock 2
 44+  B52D 49           	defb    073 ; 11, sky, trapdoor
 45+  B52E 43           	defb    067 ; 12, missile
 46+  B52F 4A               defb    074 ; 13, sky, red ink (tank)
 47+  B530 46               defb    070 ; 14, gem
 48+  B531 4D               defb    077 ; 15, damaged mountain
 49+  B532 4D               defb    077 ; 16, damaged mountain 2
 50+  B533 4D               defb    077 ; 17, damaged mountain 3
 51+  B534 4D               defb    077 ; 18, damaged mountain 4
 52+  B535 00           	defb 	000 ; 19, tank missile (not used
 53+  B536 43           	defb    067 ; 20, missile active
 54+  B537 42           	defb	066	; 21, the pit 1
 55+  B538 42           	defb	066	; 22, the pit 2
 56+  B539 42           	defb	066	; 23, the pit 3
 57+  B53A 42           	defb	066	; 24, the pit 4
 58+  B53B 42           	defb	066	; 25, the pit 5
 59+  B53C 64           	defb    100 ; 26, slime, green on green
 60+  B53D
 61+  B53D
 62+  B53D              player_sprite:
 63+  B53D 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 63+  B541 38 3D C3 80
 64+  B545 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 64+  B549 3C 1C 16 32
 65+  B54D 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 65+  B551 3C 38 68 4C
 66+  B555 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 66+  B559 1C BC C3 01
 67+  B55D 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 67+  B561 3C 3C 64 0C
 68+  B565 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 68+  B569 3C 3C 26 30
 69+  B56D 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 69+  B571 1E 5C FD 5F
 70+  B575 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 70+  B579 4F 8F 19 03
 71+  B57D 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 71+  B581 F2 F1 98 C0
 72+  B585 FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 72+  B589 48 08 14 2A
 73+  B58D 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 73+  B591 38 78 44 C3
 74+  B595 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 74+  B599 1C 1E 22 C3
 75+  B59D
 76+  B59D              ;
 77+  B59D              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 78+  B59D              ;
 79+  B59D              ship_sprite:
 80+  B59D 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 80+  B5A1 03 1F 7F FF
 81+  B5A5 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 81+  B5A9 FF FF FF FF
 82+  B5AD F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 82+  B5B1 FF FF FF FF
 83+  B5B5 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 83+  B5B9 C0 F8 FE FF
 84+  B5BD B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 84+  B5C1 03 03 02 07
 85+  B5C5 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 85+  B5C9 FF 0F 07 83
 86+  B5CD 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 86+  B5D1 FF 10 20 C1
 87+  B5D5 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 87+  B5D9 C0 C0 40 E0
 88+  B5DD 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 88+  B5E1 03 03 02 07
 89+  B5E5 F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 89+  B5E9 FF 08 04 83
 90+  B5ED F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 90+  B5F1 FF F0 E0 C1
 91+  B5F5 CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 91+  B5F9 C0 C0 40 E0
 92+  B5FD
 93+  B5FD              ;
 94+  B5FD              ;  First 8 frames are tank, last frame is the gun barrel
 95+  B5FD              ;
 96+  B5FD              tank_sprite:
 97+  B5FD 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 97+  B601 7F 00 00 00
 98+  B605 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 98+  B609 FE FF 7F 40
 99+  B60D FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 99+  B611 03 FF FF 01
100+  B615 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
100+  B619 E0 C0 00 00
101+  B61D 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
101+  B621 F7 E1 7F 3F
102+  B625 FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
102+  B629 54 16 FF FF
103+  B62D FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
103+  B631 9B A8 FF FF
104+  B635 FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
104+  B639 9F AF FE FC
105+  B63D 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
105+  B641 1F 00 00 00
106+  B645
107+  B645              monster_sprite:
108+  B645 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
108+  B649 0B D0 16 68
109+  B64D 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
109+  B651 35 AC 7F FE
110+  B655 FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
110+  B659 8F F1 8F F1
111+  B65D 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
111+  B661 18 18 00 00
112+  B665 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  B669 0B D0 16 68
113+  B66D 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
113+  B671 F5 AF FF FF
114+  B675 BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
114+  B679 0F F0 0F F0
115+  B67D 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
115+  B681 00 00 00 00
# file closed: graphics/graphics.asm
 35   B685
 36   B685                  include "game\control.asm"
# file opened: game/control.asm
  1+  B685              ;
  2+  B685              ; Check the keyboard then move
  3+  B685              ;
  4+  B685              control_keyboard:
  5+  B685 3A 13 BB         ld a,(player+11)    ; first, check if player is dying
  6+  B688 FE 00            cp 0
  7+  B68A C0               ret nz               ; if so, can't move
  8+  B68B 3A 0D BB         ld a,(player+5)      ; next, check if the player has pixels left to move
  9+  B68E FE 00            cp 0
 10+  B690 CA 97 B6         jp z, control_keyboard5
 11+  B693 CD 9C B7         call control_automove
 12+  B696 C9               ret
 13+  B697              control_keyboard5:
 14+  B697 3A 0E BB         ld a,(player+6)      ; next, check if the player is digging
 15+  B69A FE 00            cp 0
 16+  B69C CA A3 B6         jp z, control_keyboard0
 17+  B69F CD DA B6         call control_dig
 18+  B6A2 C9               ret
 19+  B6A3              control_keyboard0:
 20+  B6A3 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 21+  B6A6 ED 78            in a,(c)            ; read keyboard.
 22+  B6A8 47               ld b,a              ; store result in b register.
 23+  B6A9 CB 18            rr b                ; check outermost key (q).
 24+  B6AB D2 CA B6         jp nc,control_keyboard1
 25+  B6AE 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 26+  B6B1 ED 78            in a,(c)            ; read keyboard.
 27+  B6B3 47               ld b,a              ; store result in b register.
 28+  B6B4 CB 18            rr b                ; check outermost key (a).
 29+  B6B6 D2 CE B6         jp nc,control_keyboard2
 30+  B6B9 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 31+  B6BC ED 78            in a,(c)            ; read keyboard.
 32+  B6BE 47               ld b,a              ; store result in b register.
 33+  B6BF CB 18            rr b                ; check outermost key (p).
 34+  B6C1 D2 D2 B6         jp nc,control_keyboard3
 35+  B6C4 CB 18            rr b                ; check next key.
 36+  B6C6 D2 D6 B6         jp nc,control_keyboard4
 37+  B6C9 C9               ret
 38+  B6CA              control_keyboard1:
 39+  B6CA CD E5 B7         call control_pl_moveup         ; player up.
 40+  B6CD C9               ret
 41+  B6CE              control_keyboard2:
 42+  B6CE CD 14 B8         call control_pl_movedown       ; player down.
 43+  B6D1 C9               ret
 44+  B6D2              control_keyboard3:
 45+  B6D2 CD 71 B8         call control_pl_moveright       ; player left.
 46+  B6D5 C9               ret
 47+  B6D6              control_keyboard4:
 48+  B6D6 CD 41 B8         call control_pl_moveleft       ; player right.
 49+  B6D9 C9               ret
 50+  B6DA
 51+  B6DA              ;
 52+  B6DA              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 53+  B6DA              ;
 54+  B6DA              control_dig:
 55+  B6DA ED 4B 08 BB      ld bc,(player)      ; load the current coords into bc
 56+  B6DE C5               push bc
 57+  B6DF 3A 0A BB         ld a,(player+2)     ; get the direction
 58+  B6E2 FE 01            cp 1                ; left
 59+  B6E4 CA FC B6         jp z,control_dig0
 60+  B6E7 FE 02            cp 2                ; right
 61+  B6E9 CA 11 B7         jp z,control_dig1
 62+  B6EC FE 03            cp 3                ; down
 63+  B6EE CA 35 B7         jp z,control_dig5
 64+  B6F1 FE 00            cp 0                ; up
 65+  B6F3 CA 25 B7         jp z,control_dig4
 66+  B6F6 21 0E BB         ld hl,player+6
 67+  B6F9 36 00            ld (hl),0           ; turn off digging
 68+  B6FB C9               ret                 ; return
 69+  B6FC              control_dig0:           ; going left
 70+  B6FC CD 8A AA         call sprites_scadd  ; get the current coord
 71+  B6FF 62 6B            ld hl,de
 72+  B701 2B               dec hl              ; move one left
 73+  B702 C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
 74+  B703 78               ld a,b
 75+  B704 06 08            ld b,8
 76+  B706 90               sub b
 77+  B707 47               ld b,a
 78+  B708 79               ld a,c
 79+  B709 0E 08            ld c,8
 80+  B70B 91               sub c
 81+  B70C 4F               ld c,a
 82+  B70D C5               push bc
 83+  B70E C3 3E B7         jp control_dig2
 84+  B711              control_dig1:
 85+  B711 CD 8A AA         call sprites_scadd  ; get the current coord
 86+  B714 62 6B            ld hl,de
 87+  B716 23               inc hl              ; move one right
 88+  B717 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
 89+  B718 3E 08            ld a,8
 90+  B71A 80               add a,b
 91+  B71B 47               ld b,a
 92+  B71C 79               ld a,c
 93+  B71D 0E 08            ld c,8
 94+  B71F 91               sub c
 95+  B720 4F               ld c,a
 96+  B721 C5               push bc
 97+  B722 C3 3E B7         jp control_dig2
 98+  B725              control_dig4:
 99+  B725 CD 8A AA         call sprites_scadd  ; get the current coord
100+  B728 62 6B            ld hl,de
101+  B72A 11 20 00         ld de,32
102+  B72D ED 52            sbc hl,de             ; move one up
103+  B72F C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
104+  B730 0D               dec c
105+  B731 C5               push bc
106+  B732 C3 56 B7         jp control_dig6
107+  B735              control_dig5:
108+  B735 CD 8A AA         call sprites_scadd  ; get the current coord
109+  B738 62 6B            ld hl,de
110+  B73A 24               inc h              ; move one down
111+  B73B                                     ; not bothered about working out bc here, since rock will never fall if digging down
112+  B73B C3 3E B7         jp control_dig2
113+  B73E              ; Normal (not up) digging
114+  B73E              control_dig2:
115+  B73E 3A 10 BB         ld a,(player+8)     ; get the number of rows we need to overwrite
116+  B741 47               ld b,a              ; rows to copy over
117+  B742 E5               push hl             ; store the memory location of the first row for later
118+  B743              control_dig3:
119+  B743 CD 85 B7         call control_getpixelrow
120+  B746 77               ld (hl),a           ; load contents into row
121+  B747 11 20 00         ld de,32
122+  B74A 19               add hl,de           ; move to next row
123+  B74B 10 F6            djnz control_dig3
124+  B74D E1               pop hl              ; get the original memory location back
125+  B74E 11 20 00         ld de,32
126+  B751 ED 52            sbc hl,de           ; move to above row, ready for checking for rock
127+  B753 C3 6C B7         jp control_dig10
128+  B756              ; Special case for going up
129+  B756              control_dig6:
130+  B756 3A 10 BB         ld a,(player+8)     ; get the number of rows we need to overwrite
131+  B759 47               ld b,a              ; rows to copy over
132+  B75A              control_dig7:
133+  B75A CD 85 B7         call control_getpixelrow
134+  B75D              control_dig12:
135+  B75D 77               ld (hl),a           ; load empty into row
136+  B75E 11 20 00         ld de,32
137+  B761 ED 52            sbc hl,de           ; move up to next row
138+  B763 0D               dec c               ; decrease c to track rows
139+  B764 10 F4            djnz control_dig7
140+  B766 79               ld a,c
141+  B767 D6 07            sub 7
142+  B769 C1               pop bc
143+  B76A 4F               ld c,a
144+  B76B C5               push bc             ; store the decreased c coord
145+  B76C              control_dig10:
146+  B76C DD 21 0F BB      ld ix,player+7
147+  B770 DD 7E 00         ld a,(ix)     ; get the dig frame number
148+  B773 3D               dec a
149+  B774 DD 77 00         ld (ix),a
150+  B777                  ; call the check for rocks above the removed dirt
151+  B777 DD 21 0E BB      ld ix,player+6
152+  B77B DD 7E 00         ld a,(ix)     ; get the dig state
153+  B77E FE 00            cp 0
154+  B780 C1               pop bc
155+  B781 CC F3 BF         call z, rocks_checkforfalling ; make the check if we're no longer digging
156+  B784 C9               ret
157+  B785
158+  B785              ;
159+  B785              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
160+  B785              ; Inputs:
161+  B785              ; hl - memory of pixel row
162+  B785              ; Outputs:
163+  B785              ; a - modified row to write
164+  B785              ;
165+  B785              control_getpixelrow:
166+  B785 3A 0F BB         ld a,(player+7)     ; get the dig frame number
167+  B788 FE 00            cp 0                ; is this the last dig
168+  B78A CA 91 B7         jp z,control_getpixelrow1
169+  B78D 7E               ld a,(hl)           ; if not, xor with 255 to flip it
170+  B78E EE FF            xor 255
171+  B790 C9               ret
172+  B791              control_getpixelrow1:
173+  B791 DD 21 0E BB      ld ix,player+6
174+  B795 DD 36 00 00      ld (ix),0           ; turn off digging
175+  B799 3E 00            ld a,0              ; if it is, load with empty
176+  B79B C9               ret
177+  B79C
178+  B79C              ;
179+  B79C              ; Auto move the player until pixels is zero
180+  B79C              ;
181+  B79C              control_automove:
182+  B79C 5F               ld e,a              ; store the number of pixels left to move in e
183+  B79D ED 4B 08 BB      ld bc,(player)      ; load the current coords into bc
184+  B7A1 21 0A BB         ld hl,player+2      ; get the direction
185+  B7A4 7E               ld a,(hl)
186+  B7A5 FE 03            cp 3                ; down
187+  B7A7 CA BB B7         jp z,control_automove3  ; don't need to do anything
188+  B7AA FE 00            cp 0                ; going up
189+  B7AC CA C7 B7         jp z,control_automove2
190+  B7AF FE 01            cp 1                ; going left?
191+  B7B1 CA D3 B7         jp z,control_automove0
192+  B7B4 78               ld a,b
193+  B7B5 3C               inc a               ; if we're going right, increment a twice for two pixels
194+  B7B6 3C               inc a
195+  B7B7 47               ld b,a
196+  B7B8 C3 D7 B7         jp control_automove1
197+  B7BB              control_automove3:
198+  B7BB 79               ld a,c
199+  B7BC 3C               inc a
200+  B7BD 3C               inc a               ; if we're going down, increment twice
201+  B7BE 4F               ld c,a
202+  B7BF FE 90            cp 144
203+  B7C1 CC 9F B8         call z, control_scroll_down
204+  B7C4 C3 D7 B7         jp control_automove1
205+  B7C7              control_automove2:
206+  B7C7 79               ld a,c
207+  B7C8 3D               dec a
208+  B7C9 3D               dec a               ; if we're going up, decrement twice
209+  B7CA 4F               ld c,a
210+  B7CB FE 60            cp 96
211+  B7CD CC AC B8         call z, control_scroll_up
212+  B7D0 C3 D7 B7         jp control_automove1
213+  B7D3              control_automove0:
214+  B7D3 78               ld a,b
215+  B7D4 3D               dec a               ; if we're going left, decrement a twice
216+  B7D5 3D               dec a
217+  B7D6 47               ld b,a
218+  B7D7              control_automove1:
219+  B7D7 ED 43 08 BB      ld (player),bc      ; and back to player
220+  B7DB 7B               ld a,e              ; now get the pixel count back
221+  B7DC 3D               dec a               ; decrease by one
222+  B7DD 21 0D BB         ld hl,player+5
223+  B7E0 77               ld (hl),a           ; copy back
224+  B7E1 CD 90 BC         call player_justmoved
225+  B7E4 C9               ret
226+  B7E5
227+  B7E5              ;
228+  B7E5              ; Moves the player up
229+  B7E5              ;
230+  B7E5              control_pl_moveup:
231+  B7E5 C5               push bc
232+  B7E6 ED 4B 08 BB      ld bc,(player)          ; get the current coords, b horiz, c vert
233+  B7EA 79               ld a,c                  ; load c into the acc
234+  B7EB FE 18            cp 24
235+  B7ED CA 0D B8         jp z,control_pl_moveup0 ; are we at the edge of the screen
236+  B7F0 FE 60            cp 96
237+  B7F2 CC AC B8         call z, control_scroll_up
238+  B7F5 CD 4C BA         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
239+  B7F8 F5               push af
240+  B7F9 7B               ld a,e                  ; put e in a
241+  B7FA FE 00            cp 0
242+  B7FC CA 0C B8         jp z,control_pl_moveup1 ; don't move if we can't
243+  B7FF F1               pop af
244+  B800 D6 01            sub 1                   ; subtract 1
245+  B802 D6 01            sub 1                   ; subtract 1
246+  B804 4F               ld c,a                  ; load back to c
247+  B805 ED 43 08 BB      ld (player),bc          ; load back to player
248+  B809 C3 0D B8         jp control_pl_moveup0
249+  B80C              control_pl_moveup1:
250+  B80C F1               pop af                  ; restore af if needed
251+  B80D              control_pl_moveup0:
252+  B80D 3E 00            ld a,0
253+  B80F 32 0A BB         ld (player+2),a        ; set direction to up
254+  B812 C1               pop bc
255+  B813 C9               ret
256+  B814              ;
257+  B814              ; Moves the player down
258+  B814              ;
259+  B814              control_pl_movedown:
260+  B814 C5               push bc
261+  B815 ED 4B 08 BB      ld bc,(player)          ; get the current coords, b horiz, c vert
262+  B819 79               ld a,c                  ; load c into the acc
263+  B81A FE E0            cp 224
264+  B81C CA 3A B8         jp z,control_pl_movedown0 ; are we at the edge of the screen
265+  B81F FE 80            cp 128
266+  B821 CC 9F B8         call z, control_scroll_down
267+  B824 CD 20 BA         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
268+  B827 F5               push af
269+  B828 7B               ld a,e                  ; put e in a
270+  B829 FE 00            cp 0
271+  B82B CA 39 B8         jp z,control_pl_movedown1 ; don't move if we can't
272+  B82E F1               pop af
273+  B82F 3C               inc a                   ; add 1
274+  B830 3C               inc a                   ; add 1
275+  B831 4F               ld c,a                  ; load back to c
276+  B832 ED 43 08 BB      ld (player),bc          ; load back to player
277+  B836 C3 3A B8         jp control_pl_movedown0
278+  B839              control_pl_movedown1:
279+  B839 F1               pop af                  ; restore af if needed
280+  B83A              control_pl_movedown0:
281+  B83A 3E 03            ld a,3
282+  B83C 32 0A BB         ld (player+2),a        ; set direction to down
283+  B83F C1               pop bc
284+  B840 C9               ret
285+  B841              ;
286+  B841              ; Moves the player left
287+  B841              ;
288+  B841              control_pl_moveleft:
289+  B841 C5               push bc
290+  B842 ED 4B 08 BB      ld bc,(player)          ; get the current coords, b horiz, c vert
291+  B846 78               ld a,b                  ; load b into the acc
292+  B847 FE 10            cp 16
293+  B849 CA 6A B8         jp z,control_pl_moveleft0 ; are we at the edge of the screen
294+  B84C CD AB BA         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
295+  B84F F5               push af
296+  B850 7B               ld a,e                  ; put e in a
297+  B851 FE 00            cp 0
298+  B853 CA 69 B8         jp z,control_pl_moveleft1 ; don't move if we can't
299+  B856 21 0D BB         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
300+  B859 3E 03            ld a,3
301+  B85B 77               ld (hl),a
302+  B85C F1               pop af
303+  B85D D6 01            sub 1                    ; subtract 2
304+  B85F D6 01            sub 1
305+  B861 47               ld b,a                  ; load back to c
306+  B862 ED 43 08 BB      ld (player),bc          ; load back to player
307+  B866 C3 6A B8         jp control_pl_moveleft0
308+  B869              control_pl_moveleft1:
309+  B869 F1               pop af
310+  B86A              control_pl_moveleft0:
311+  B86A 3E 01            ld a,1
312+  B86C 32 0A BB         ld (player+2),a        ; set direction to left
313+  B86F C1               pop bc
314+  B870 C9               ret
315+  B871              ;
316+  B871              ; Moves the player right
317+  B871              ;
318+  B871              control_pl_moveright:
319+  B871 C5               push bc
320+  B872 ED 4B 08 BB      ld bc,(player)          ; get the current coords, b horiz, c vert
321+  B876 78               ld a,b                  ; load b into the acc
322+  B877 FE F0            cp 240
323+  B879 CA 98 B8         jp z,control_pl_moveright0 ; are we at the edge of the screen
324+  B87C CD 7F BA         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
325+  B87F F5               push af
326+  B880 7B               ld a,e                  ; put e in a
327+  B881 FE 00            cp 0
328+  B883 CA 97 B8         jp z,control_pl_moveright1 ; don't move if we can't
329+  B886 21 0D BB         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
330+  B889 3E 03            ld a,3
331+  B88B 77               ld (hl),a
332+  B88C F1               pop af
333+  B88D 3C               inc a                   ; add 2
334+  B88E 3C               inc a
335+  B88F 47               ld b,a                  ; load back to b
336+  B890 ED 43 08 BB      ld (player),bc          ; load back to player
337+  B894 C3 98 B8         jp control_pl_moveright0
338+  B897              control_pl_moveright1:
339+  B897 F1               pop af                  ; restore af if needed
340+  B898              control_pl_moveright0:
341+  B898 3E 02            ld a,2
342+  B89A 32 0A BB         ld (player+2),a        ; set direction to right
343+  B89D C1               pop bc
344+  B89E C9               ret
345+  B89F
346+  B89F              ;
347+  B89F              ; Scrolls the screen down
348+  B89F              ;
349+  B89F              control_scroll_down:
350+  B89F F5               push af
351+  B8A0 3E 08            ld a,8
352+  B8A2 32 71 A7         ld (screen_offset),a
353+  B8A5 F1               pop af
354+  B8A6 21 BE A5         ld hl,buffer_updateall
355+  B8A9 36 01            ld (hl),1         ; flag as screen needing update
356+  B8AB C9               ret
357+  B8AC
358+  B8AC              ;
359+  B8AC              ; Scrolls the screen up
360+  B8AC              ;
361+  B8AC              control_scroll_up:
362+  B8AC F5               push af
363+  B8AD 3E 00            ld a,0
364+  B8AF 32 71 A7         ld (screen_offset),a
365+  B8B2 F1               pop af
366+  B8B3 21 BE A5         ld hl,buffer_updateall
367+  B8B6 36 01            ld (hl),1         ; flag as screen needing update
368+  B8B8 C9               ret
369+  B8B9
370+  B8B9
371+  B8B9
372+  B8B9
# file closed: game/control.asm
 37   B8B9                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  B8B9              ;
  2+  B8B9              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  3+  B8B9              ; Inputs:
  4+  B8B9              ; hl - memory location of top pixel row
  5+  B8B9              ; bc - screen coords, b horiz, c vert
  6+  B8B9              ; Outputs:
  7+  B8B9              ; e - 0 if not empty, 1 if empty
  8+  B8B9              ;
  9+  B8B9              movement_spaceisempty:
 10+  B8B9 C5               push bc
 11+  B8BA E5               push hl
 12+  B8BB CD E3 B8         call movement_spaceisgem        ; check if space is a gem
 13+  B8BE E1               pop hl
 14+  B8BF C1               pop bc
 15+  B8C0 7B               ld a,e
 16+  B8C1 FE 01            cp 1
 17+  B8C3 C8               ret z                           ; if e is 1, space is a gem so can move here, return
 18+  B8C4 3E 08            ld a,8                          ; 8 rows to check
 19+  B8C6              movement_spaceisempty0:
 20+  B8C6 08               ex af,af'                       ; store the loop counter
 21+  B8C7 7E               ld a,(hl)                       ; get current pixel row
 22+  B8C8 FE 00            cp 0
 23+  B8CA C2 DE B8         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 24+  B8CD 79               ld a,c                          ; load the vertical coord
 25+  B8CE 3C               inc a                           ; next row down
 26+  B8CF 11 20 00         ld de,32
 27+  B8D2 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 28+  B8D3 4F               ld c,a                          ; copy vert coord back to c
 29+  B8D4 08               ex af,af'                       ; get loop counter back
 30+  B8D5 3D               dec a                           ; decrease loop counter
 31+  B8D6 C2 C6 B8         jp nz, movement_spaceisempty0
 32+  B8D9 16 00            ld d,0
 33+  B8DB 1E 01            ld e,1                          ; got to end, so space is empty
 34+  B8DD C9               ret
 35+  B8DE              movement_spaceisempty1:
 36+  B8DE 16 00            ld d,0
 37+  B8E0 1E 00            ld e,0                          ; returning false, ie space not empty
 38+  B8E2 C9               ret
 39+  B8E3
 40+  B8E3              ;
 41+  B8E3              ; Check if a space contains a gem
 42+  B8E3              ; Inputs:
 43+  B8E3              ; bc - screen coords
 44+  B8E3              ; Outputs:
 45+  B8E3              ; e = 1 if gem
 46+  B8E3              movement_spaceisgem:
 47+  B8E3 CD C3 A8         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 48+  B8E6 21 C5 B3         ld hl,level01diamonds           ; check diamonds first
 49+  B8E9              movement_spaceisgem0:
 50+  B8E9 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 51+  B8ED 7B               ld a,e                          ; check for end of data
 52+  B8EE FE FF            cp 255
 53+  B8F0 CA 0B B9         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 54+  B8F3 23               inc hl
 55+  B8F4 23               inc hl                          ; move to state
 56+  B8F5 7E               ld a,(hl)
 57+  B8F6 23               inc hl
 58+  B8F7 23               inc hl
 59+  B8F8 23               inc hl                          ; get to next
 60+  B8F9 FE 01            cp 1                            ; check if collected
 61+  B8FB CA E9 B8         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 62+  B8FE 7B               ld a,e                          ; load e again
 63+  B8FF B9               cp c                            ; otherwise, compare c with e
 64+  B900 C2 E9 B8         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 65+  B903 7A               ld a,d                          ; get d coord
 66+  B904 B8               cp b                            ; compare b with d
 67+  B905 C2 E9 B8         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 68+  B908 1E 01            ld e,1                          ; otherwise, exit with e = 1
 69+  B90A C9               ret
 70+  B90B              movement_spaceisgem1:
 71+  B90B 21 D5 B3         ld hl,level01gems              ; check gems
 72+  B90E              movement_spaceisgem2:
 73+  B90E 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 74+  B912 7B               ld a,e                          ; check for end of data
 75+  B913 FE FF            cp 255
 76+  B915 CA 30 B9         jp z,movement_spaceisgem3       ; if yes, done with gems
 77+  B918 23               inc hl
 78+  B919 23               inc hl                          ; move to state
 79+  B91A 7E               ld a,(hl)
 80+  B91B 23               inc hl
 81+  B91C 23               inc hl
 82+  B91D 23               inc hl                          ; get to next
 83+  B91E FE 01            cp 1                            ; check if collected
 84+  B920 CA 0E B9         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 85+  B923 7B               ld a,e                          ; load e again
 86+  B924 B9               cp c                            ; otherwise, compare c with e
 87+  B925 C2 0E B9         jp nz,movement_spaceisgem2      ; if different, move to next gem
 88+  B928 7A               ld a,d                          ; get d coord
 89+  B929 B8               cp b                            ; compare b with d
 90+  B92A C2 0E B9         jp nz,movement_spaceisgem2      ; if different, move to next gem
 91+  B92D 1E 01            ld e,1                          ; otherwise, exit with e = 1
 92+  B92F C9               ret
 93+  B930              movement_spaceisgem3:
 94+  B930 1E 00            ld e,0                          ; nothing found, return e = 0
 95+  B932 C9               ret
 96+  B933
 97+  B933              ;
 98+  B933              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
 99+  B933              ; Inputs:
100+  B933              ; hl - memory location of top pixel row
101+  B933              ; bc - screen coords, b horiz, c vert
102+  B933              ; Outputs:
103+  B933              ; e - 0 if not empty, 1 if empty
104+  B933              ;
105+  B933              movement_linebelowisempty:
106+  B933 C5               push bc
107+  B934 E5               push hl
108+  B935 CD E3 B8         call movement_spaceisgem        ; check if space is a gem
109+  B938 E1               pop hl
110+  B939 C1               pop bc
111+  B93A 7B               ld a,e
112+  B93B FE 01            cp 1
113+  B93D C8               ret z                           ; if e is 1, space is a gem so can move here, return
114+  B93E 7E               ld a,(hl)                       ; get current pixel row
115+  B93F FE 00            cp 0
116+  B941 C2 49 B9         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
117+  B944 16 00            ld d,0
118+  B946 1E 01            ld e,1                          ; got to end, so space is empty
119+  B948 C9               ret
120+  B949              movement_linebelowisempty1:
121+  B949 16 00            ld d,0
122+  B94B 1E 00            ld e,0                          ; returning false, ie space not empty
123+  B94D C9               ret
124+  B94E
125+  B94E              ;
126+  B94E              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
127+  B94E              ; Inputs:
128+  B94E              ; hl - memory location of top pixel row
129+  B94E              ; bc - screen coords, b horiz, c vert
130+  B94E              ; Outputs:
131+  B94E              ; e - 0 if not empty, 1 if empty
132+  B94E              ;
133+  B94E              movement_lineaboveisempty:
134+  B94E C5               push bc
135+  B94F E5               push hl
136+  B950 CD E3 B8         call movement_spaceisgem        ; check if space is a gem
137+  B953 E1               pop hl
138+  B954 C1               pop bc
139+  B955 7B               ld a,e
140+  B956 FE 01            cp 1
141+  B958 C8               ret z
142+  B959 7E               ld a,(hl)                       ; get current pixel row
143+  B95A FE 00            cp 0
144+  B95C C2 64 B9         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
145+  B95F 16 00            ld d,0
146+  B961 1E 01            ld e,1                          ; got to end, so space is empty
147+  B963 C9               ret
148+  B964              movement_lineaboveisempty1:
149+  B964 16 00            ld d,0
150+  B966 1E 00            ld e,0                          ; returning false, ie space not empty
151+  B968 C9               ret
152+  B969
153+  B969              ;
154+  B969              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
155+  B969              ; Inputs:
156+  B969              ; hl - memory location of top pixel row
157+  B969              ; bc - screen coords, b horiz, c vert
158+  B969              ; Outputs:
159+  B969              ; none - puts player into digging mode
160+  B969              ;
161+  B969              movement_spaceisdiggable:
162+  B969 3E 08            ld a,8                          ; 8 rows to check
163+  B96B              movement_spaceisdiggable0:
164+  B96B 08               ex af,af'                       ; store the loop counter
165+  B96C 7E               ld a,(hl)                       ; get current pixel row
166+  B96D FE 00            cp 0
167+  B96F CA 7F B9         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
168+  B972 FE 55            cp 85
169+  B974 CA 7F B9         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
170+  B977 FE AA            cp 170
171+  B979 CA 7F B9         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
172+  B97C C3 97 B9         jp movement_spaceisdiggable1     ; otherwise, stop checking
173+  B97F              movement_spaceisdiggable2:
174+  B97F 79               ld a,c                          ; load the vertical coord
175+  B980 3C               inc a                           ; next row down
176+  B981 11 20 00         ld de,32
177+  B984 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
178+  B985 4F               ld c,a                          ; copy vert coord back to c
179+  B986 08               ex af,af'                       ; get loop counter back
180+  B987 3D               dec a                           ; decrease loop counter
181+  B988 C2 6B B9         jp nz, movement_spaceisdiggable0
182+  B98B 21 0E BB         ld hl,player+6
183+  B98E 36 01            ld (hl),1                       ; set the player into digging mode
184+  B990 23               inc hl
185+  B991 36 05            ld (hl),5                      ; set the number of frame to dig for
186+  B993 23               inc hl
187+  B994 36 08            ld (hl),8                       ; set the number of pixels to dig
188+  B996 C9               ret
189+  B997              movement_spaceisdiggable1:
190+  B997 21 0E BB         ld hl,player+6
191+  B99A 36 00            ld (hl),0                       ; set the player out of digging mode
192+  B99C C9               ret
193+  B99D
194+  B99D              ;
195+  B99D              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
196+  B99D              ; Inputs:
197+  B99D              ; hl - memory location of top pixel row
198+  B99D              ; bc - screen coords, b horiz, c vert
199+  B99D              ; Outputs:
200+  B99D              ; none - puts player into digging mode
201+  B99D              ;
202+  B99D              movement_spacebelowisdiggable:
203+  B99D 7E               ld a,(hl)                       ; get first pixel row
204+  B99E FE 55            cp 85
205+  B9A0 CA AB B9         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
206+  B9A3 FE AA            cp 170
207+  B9A5 CA AB B9         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
208+  B9A8 C3 97 B9         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
209+  B9AB              movement_spacebelowisdiggable3:
210+  B9AB 3E 08            ld a,8                          ; rows to check
211+  B9AD 1E 00            ld e,0                          ; count of rows to dig
212+  B9AF              movement_spacebelowisdiggable0:
213+  B9AF 08               ex af,af'                       ; store the loop counter
214+  B9B0 7E               ld a,(hl)                       ; get current pixel row
215+  B9B1 FE 55            cp 85
216+  B9B3 CA BE B9         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
217+  B9B6 FE AA            cp 170
218+  B9B8 CA BE B9         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
219+  B9BB C3 CD B9         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
220+  B9BE              movement_spacebelowisdiggable4:
221+  B9BE 1C               inc e                           ; inc count of rows to dig
222+  B9BF              movement_spacebelowisdiggable2:
223+  B9BF 79               ld a,c                          ; load the vertical coord
224+  B9C0 3C               inc a                           ; next row down
225+  B9C1 D5               push de                         ; need e for later
226+  B9C2 11 20 00         ld de,32
227+  B9C5 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
228+  B9C6 4F               ld c,a                          ; copy vert coord back to c
229+  B9C7 D1               pop de                          ; get e back
230+  B9C8 08               ex af,af'                       ; get loop counter back
231+  B9C9 3D               dec a                           ; incease loop counter
232+  B9CA C2 AF B9         jp nz, movement_spacebelowisdiggable0
233+  B9CD              movement_spacebelowisdiggable5:
234+  B9CD 21 0E BB         ld hl,player+6
235+  B9D0 36 01            ld (hl),1                       ; set the player into digging mode
236+  B9D2 23               inc hl
237+  B9D3 36 03            ld (hl),3                      ; set the number of frame to dig for
238+  B9D5 23               inc hl
239+  B9D6 73               ld (hl),e                       ; set the number of pixels to dig
240+  B9D7 C9               ret
241+  B9D8              movement_spacebelowisdiggable1:
242+  B9D8 21 0E BB         ld hl,player+6
243+  B9DB 36 00            ld (hl),0                       ; set the player out of digging mode
244+  B9DD C9               ret
245+  B9DE
246+  B9DE              ;
247+  B9DE              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
248+  B9DE              ; Inputs:
249+  B9DE              ; hl - memory location of top pixel row
250+  B9DE              ; bc - screen coords, b horiz, c vert
251+  B9DE              ; Outputs:
252+  B9DE              ; none - puts player into digging mode
253+  B9DE              ;
254+  B9DE              movement_spaceaboveisdiggable:
255+  B9DE 7E               ld a,(hl)                       ; get first pixel row
256+  B9DF FE 55            cp 85
257+  B9E1 CA EC B9         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
258+  B9E4 FE AA            cp 170
259+  B9E6 CA EC B9         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
260+  B9E9 C3 97 B9         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
261+  B9EC              movement_spaceaboveisdiggable3:
262+  B9EC 3E 08            ld a,8                          ; rows to check
263+  B9EE 1E 00            ld e,0                          ; count of rows to dig
264+  B9F0              movement_spaceaboveisdiggable0:
265+  B9F0 08               ex af,af'                       ; store the loop counter
266+  B9F1 7E               ld a,(hl)                       ; get current pixel row
267+  B9F2 FE 55            cp 85
268+  B9F4 CA FF B9         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
269+  B9F7 FE AA            cp 170
270+  B9F9 CA FF B9         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
271+  B9FC C3 0F BA         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
272+  B9FF              movement_spaceaboveisdiggable4:
273+  B9FF 1C               inc e                           ; inc count of rows to dig
274+  BA00              movement_spaceaboveisdiggable2:
275+  BA00 79               ld a,c                          ; load the vertical coord
276+  BA01 3D               dec a                           ; next row up
277+  BA02 D5               push de                         ; need e for later
278+  BA03 11 20 00         ld de,32
279+  BA06 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
280+  BA08 4F               ld c,a                          ; copy vert coord back to c
281+  BA09 D1               pop de                          ; get e back
282+  BA0A 08               ex af,af'                       ; get loop counter back
283+  BA0B 3D               dec a                           ; incease loop counter
284+  BA0C C2 F0 B9         jp nz, movement_spaceaboveisdiggable0
285+  BA0F              movement_spaceaboveisdiggable5:
286+  BA0F 21 0E BB         ld hl,player+6
287+  BA12 36 01            ld (hl),1                       ; set the player into digging mode
288+  BA14 23               inc hl
289+  BA15 36 05            ld (hl),5                       ; set the number of frame to dig for
290+  BA17 23               inc hl
291+  BA18 73               ld (hl),e                       ; set the number of pixels to dig
292+  BA19 C9               ret
293+  BA1A              movement_spaceaboveisdiggable1:
294+  BA1A 21 0E BB         ld hl,player+6
295+  BA1D 36 00            ld (hl),0                       ; set the player out of digging mode
296+  BA1F C9               ret
297+  BA20
298+  BA20              ;
299+  BA20              ; Checks if the player can move down
300+  BA20              ; Inputs:
301+  BA20              ; bc - player coords, b horiz, c vert
302+  BA20              ; Outputs:
303+  BA20              ; de - 1 can move
304+  BA20              movement_checkcanmove_down:
305+  BA20 F5               push af
306+  BA21 C5               push bc
307+  BA22 CD 8A AA         call sprites_scadd              ; get the memory location of cell into de
308+  BA25 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
309+  BA27 24               inc h                       ; memory location of cell beneath now in hl
310+  BA28 3E 08            ld a,8                       ; look below
311+  BA2A 81               add c
312+  BA2B 4F               ld c,a
313+  BA2C CD 33 B9         call movement_linebelowisempty       ; check space is empty
314+  BA2F 7B               ld a,e                          ; check space empty flag
315+  BA30 FE 00            cp 0
316+  BA32 CA 3B BA         jp z, movement_checkcanmove_down1 ; can't move
317+  BA35 CD 90 BC         call player_justmoved
318+  BA38 C1               pop bc
319+  BA39 F1               pop af
320+  BA3A C9               ret
321+  BA3B              movement_checkcanmove_down1:
322+  BA3B C1               pop bc
323+  BA3C CD 8A AA         call sprites_scadd              ; get the memory location of cell into de
324+  BA3F 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
325+  BA41 24               inc h
326+  BA42 C5               push bc
327+  BA43 CD 9D B9         call movement_spacebelowisdiggable    ; can't move here, but can we dig
328+  BA46 11 00 00         ld de,0
329+  BA49 C1               pop bc
330+  BA4A F1               pop af
331+  BA4B C9               ret
332+  BA4C
333+  BA4C              ;
334+  BA4C              ; Checks if the player can move up
335+  BA4C              ; Inputs:
336+  BA4C              ; bc - player coords, b horiz, c vert
337+  BA4C              ; Outputs:
338+  BA4C              ; de - 1 can move
339+  BA4C              movement_checkcanmove_up:
340+  BA4C F5               push af
341+  BA4D C5               push bc
342+  BA4E CD 8A AA         call sprites_scadd              ; get the memory location of cell into de
343+  BA51 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
344+  BA53 11 20 00         ld de,32
345+  BA56 ED 52            sbc hl,de                       ; memory location of line above now in hl
346+  BA58 0D               dec c                           ; look above
347+  BA59 CD 4E B9         call movement_lineaboveisempty       ; check space is empty
348+  BA5C 7B               ld a,e                          ; check space empty flag
349+  BA5D FE 00            cp 0
350+  BA5F CA 6A BA         jp z, movement_checkcanmove_up1 ; can't move
351+  BA62 1E 01            ld e,1
352+  BA64 CD 90 BC         call player_justmoved
353+  BA67 C1               pop bc
354+  BA68 F1               pop af
355+  BA69 C9               ret
356+  BA6A              movement_checkcanmove_up1:
357+  BA6A C1               pop bc
358+  BA6B CD 8A AA         call sprites_scadd              ; get the memory location of cell into de
359+  BA6E 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
360+  BA70 11 20 00         ld de,32
361+  BA73 ED 52            sbc hl,de                       ; memory location of line above now in hl
362+  BA75 C5               push bc
363+  BA76 CD DE B9         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
364+  BA79 11 00 00         ld de,0
365+  BA7C C1               pop bc
366+  BA7D F1               pop af
367+  BA7E C9               ret
368+  BA7F
369+  BA7F              ;
370+  BA7F              ; Checks if the player can move right
371+  BA7F              ; Inputs:
372+  BA7F              ; bc - player coords, b horiz, c vert
373+  BA7F              ; Outputs:
374+  BA7F              ; de - 1 can move
375+  BA7F              movement_checkcanmove_right:
376+  BA7F F5               push af
377+  BA80 C5               push bc
378+  BA81 CD 8A AA         call sprites_scadd              ; get the memory location of cell into de
379+  BA84 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
380+  BA86 3E 08            ld a,8
381+  BA88 80               add b                           ; move one cell right
382+  BA89 47               ld b,a
383+  BA8A 23               inc hl                          ; memory location of cell to the right now in hl
384+  BA8B CD B9 B8         call movement_spaceisempty       ; check space is empty
385+  BA8E 7B               ld a,e                          ; check space empty flag
386+  BA8F FE 00            cp 0
387+  BA91 CA 9A BA         jp z, movement_checkcanmove_right1 ; can't move
388+  BA94 CD 90 BC         call player_justmoved
389+  BA97 C1               pop bc
390+  BA98 F1               pop af
391+  BA99 C9               ret
392+  BA9A              movement_checkcanmove_right1:
393+  BA9A C1               pop bc
394+  BA9B CD 8A AA         call sprites_scadd              ; get the memory location of cell into de
395+  BA9E 62 6B            ld hl,de
396+  BAA0 23               inc hl                          ; memory location of cell to the right now in hl
397+  BAA1 C5               push bc
398+  BAA2 CD 69 B9         call movement_spaceisdiggable    ; can't move here, but can we dig
399+  BAA5 11 00 00         ld de,0
400+  BAA8 C1               pop bc
401+  BAA9 F1               pop af
402+  BAAA C9               ret
403+  BAAB
404+  BAAB              ;
405+  BAAB              ; Checks if the player can move left
406+  BAAB              ; Inputs:
407+  BAAB              ; bc - player coords, b horiz, c vert
408+  BAAB              ; Outputs:
409+  BAAB              ; de - 1 can move
410+  BAAB              movement_checkcanmove_left:
411+  BAAB F5               push af
412+  BAAC C5               push bc
413+  BAAD CD 8A AA         call sprites_scadd              ; get the memory location of cell into de
414+  BAB0 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
415+  BAB2 78               ld a,b
416+  BAB3 06 08            ld b,8
417+  BAB5 90               sub b                           ; move one cell left
418+  BAB6 47               ld b,a
419+  BAB7 2B               dec hl                          ; memory location of cell to the right now in hl
420+  BAB8 CD B9 B8         call movement_spaceisempty       ; check space is empty
421+  BABB 7B               ld a,e                          ; check space empty flag
422+  BABC FE 00            cp 0
423+  BABE CA C7 BA         jp z, movement_checkcanmove_left1 ; can't move
424+  BAC1 CD 90 BC         call player_justmoved
425+  BAC4 C1               pop bc
426+  BAC5 F1               pop af
427+  BAC6 C9               ret
428+  BAC7              movement_checkcanmove_left1:
429+  BAC7 C1               pop bc
430+  BAC8 CD 8A AA         call sprites_scadd              ; get the memory location of cell into de
431+  BACB 62 6B            ld hl,de
432+  BACD 2B               dec hl                          ; memory location of cell to the right now in hl
433+  BACE C5               push bc
434+  BACF CD 69 B9         call movement_spaceisdiggable    ; can't move here, but can we dig
435+  BAD2 11 00 00         ld de,0
436+  BAD5 C1               pop bc
437+  BAD6 F1               pop af
438+  BAD7 C9               ret
# file closed: game/movement.asm
 38   BAD8                  include "game\game.asm"
# file opened: game/game.asm
  1+  BAD8              ;
  2+  BAD8              ; The current frame count, incremented each frame
  3+  BAD8              ;
  4+  BAD8              game_framenumber:
  5+  BAD8 00               defb    0
  6+  BAD9
  7+  BAD9              ;
  8+  BAD9              ; The number of players
  9+  BAD9              ;
 10+  BAD9              game_numberplayers:
 11+  BAD9 01               defb 1
 12+  BADA
 13+  BADA              ;
 14+  BADA              ; The current player
 15+  BADA              ;
 16+  BADA              game_currentplayer:
 17+  BADA 01               defb 1
 18+  BADB
 19+  BADB              ;
 20+  BADB              ; The default number of lives
 21+  BADB              ;
 22+  BADB              game_numberlives:
 23+  BADB 04               defb 4
 24+  BADC
 25+  BADC              ;
 26+  BADC              ; Moves to the next player
 27+  BADC              ;
 28+  BADC              game_changeplayer:
 29+  BADC 3A DA BA         ld a,(game_currentplayer)
 30+  BADF FE 01            cp 1
 31+  BAE1 C8               ret z                       ; if just one player, no need to change
 32+  BAE2 3D               dec a                       ; otherwise decrease by one
 33+  BAE3 EE 01            xor 1                       ; xor with one to flip
 34+  BAE5 3C               inc a                       ; increment
 35+  BAE6 21 DA BA         ld hl,game_currentplayer
 36+  BAE9 77               ld (hl),a                   ; store
 37+  BAEA C9               ret
 38+  BAEB
 39+  BAEB              ;
 40+  BAEB              ; Sets the number of players at the start of the game
 41+  BAEB              ; Inputs:
 42+  BAEB              ; a - number of players
 43+  BAEB              game_setnumberofplayers:
 44+  BAEB 21 D9 BA         ld hl,game_numberplayers
 45+  BAEE 77               ld (hl),a
 46+  BAEF
 47+  BAEF              ;
 48+  BAEF              ; Increment frame number by 1
 49+  BAEF              ;
 50+  BAEF              game_incrementframe:
 51+  BAEF 3A D8 BA         ld a,(game_framenumber)
 52+  BAF2 FE FF            cp 255
 53+  BAF4 C2 F9 BA         jp nz,game_incrementframe0
 54+  BAF7 3E 00            ld a,0
 55+  BAF9              game_incrementframe0:
 56+  BAF9 3C               inc a
 57+  BAFA 32 D8 BA         ld (game_framenumber),a
 58+  BAFD C9               ret
 59+  BAFE
 60+  BAFE              ;
 61+  BAFE              ; Returns current frame
 62+  BAFE              ; Outputs:
 63+  BAFE              ; a - current frame
 64+  BAFE              ;
 65+  BAFE              game_getcurrentframe:
 66+  BAFE 3A D8 BA         ld a,(game_framenumber)
 67+  BB01 C9               ret
 68+  BB02
 69+  BB02              ;
 70+  BB02              ; Resets current frame
 71+  BB02              ;
 72+  BB02              game_resetcurrentframe:
 73+  BB02 21 D8 BA         ld hl,game_framenumber
 74+  BB05 36 00            ld (hl),0
 75+  BB07 C9               ret
# file closed: game/game.asm
 39   BB08                  include "game\player.asm"
# file opened: game/player.asm
  1+  BB08              ;
  2+  BB08              ;   Data for current player
  3+  BB08              ;
  4+  BB08              player:
  5+  BB08 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  BB0A 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  BB0D 00               defb    0                   ; auto move remaining (+5)
  8+  BB0E 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  BB11 00               defb    0                   ; lives remaining (+9)
 10+  BB12 00               defb    0                   ; died this life (+10)
 11+  BB13 00 00            defb    0,0                 ; crushed (+11), frames (+12)
 12+  BB15 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  BB16
 14+  BB16              player_location:
 15+  BB16 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 16+  BB17
 17+  BB17              ;
 18+  BB17              ; Works out which part of the screen the player is in
 19+  BB17              ; Pit is between 3,9 and 8,9
 20+  BB17              ; Diamond cavern is between 11,22 and 22,28
 21+  BB17              ;
 22+  BB17              player_getlocation:
 23+  BB17 ED 4B 08 BB      ld bc,(player)              ; get screen coords
 24+  BB1B CD C3 A8         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 25+  BB1E 78               ld a,b                      ; check for pit first
 26+  BB1F FE 09            cp 9                        ; if not on this row, not in the pit
 27+  BB21 C2 30 BB         jp nz,player_getlocation0
 28+  BB24 79               ld a,c                      ; check horizontal
 29+  BB25 FE 08            cp 8
 30+  BB27 D2 30 BB         jp nc, player_getlocation0  ; if more than 8, not in the pit
 31+  BB2A 21 16 BB         ld hl,player_location
 32+  BB2D 36 02            ld (hl),2                   ; load location with 2, the pit
 33+  BB2F C9               ret                         ; done
 34+  BB30              player_getlocation0:            ; check for diamond cavern
 35+  BB30 78               ld a,b                      ; first check vertical
 36+  BB31 FE 16            cp 22                       ; if above row 22, then not in cavern
 37+  BB33 DA 47 BB         jp c,player_getlocation1
 38+  BB36 79               ld a,c                      ; get the horizontal next
 39+  BB37 FE 0B            cp 11
 40+  BB39 DA 47 BB         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 41+  BB3C FE 16            cp 22
 42+  BB3E D2 47 BB         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 43+  BB41 21 16 BB         ld hl,player_location
 44+  BB44 36 01            ld (hl),1                   ; load location with 1, the cavern
 45+  BB46 C9               ret
 46+  BB47              player_getlocation1:
 47+  BB47 21 16 BB         ld hl,player_location
 48+  BB4A 36 00            ld (hl),0                   ; load location with 2, the pit
 49+  BB4C C9               ret                         ; done
 50+  BB4D
 51+  BB4D
 52+  BB4D              ;
 53+  BB4D              ; Initializes a player at start of game
 54+  BB4D              ; Copy initial coords, copy lives, copy score
 55+  BB4D              ;
 56+  BB4D              player_init_gamestart:
 57+  BB4D 3A DB BA         ld a,(game_numberlives)
 58+  BB50 32 DC BB         ld (player1_lives),a
 59+  BB53 32 DD BB         ld (player2_lives),a                        ; set the initial number of lives at game start
 60+  BB56
 61+  BB56 21 E0 BB         ld hl,player1_score+2
 62+  BB59 06 06            ld b,6
 63+  BB5B              player_init_gamestart0:
 64+  BB5B 36 30            ld (hl),48
 65+  BB5D 23               inc hl
 66+  BB5E 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 67+  BB60 21 E9 BB         ld hl,player2_score+2
 68+  BB63 06 06            ld b,6
 69+  BB65              player_init_gamestart1:
 70+  BB65 36 30            ld (hl),48
 71+  BB67 23               inc hl
 72+  BB68 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 73+  BB6A C9               ret
 74+  BB6B
 75+  BB6B              ;
 76+  BB6B              ; Initializes a player at start of a life
 77+  BB6B              ; Copy initial coords, copy lives, copy score
 78+  BB6B              ;
 79+  BB6B              player_init_lifestart:
 80+  BB6B 21 0D BB         ld hl,player+5
 81+  BB6E 06 09            ld b,9                      ; initialise 9 properties
 82+  BB70              player_init_lifestart2:
 83+  BB70 36 00            ld (hl),0
 84+  BB72 23               inc hl
 85+  BB73 10 FB            djnz player_init_lifestart2
 86+  BB75
 87+  BB75 21 0A BB         ld hl,player+2              ; initialise some properties
 88+  BB78 36 02            ld (hl),2
 89+  BB7A 23               inc hl
 90+  BB7B 36 00            ld (hl),0
 91+  BB7D 23               inc hl
 92+  BB7E 36 01            ld (hl),1
 93+  BB80
 94+  BB80 ED 4B 22 80      ld bc,(init_coord)
 95+  BB84 ED 43 08 BB      ld (player),bc
 96+  BB88 01 11 BB         ld bc,player+9
 97+  BB8B 3A DC BB         ld a,(player1_lives)
 98+  BB8E 02               ld (bc),a
 99+  BB8F
100+  BB8F CD 1E C3         call diamonds_init      ; initialise gems
101+  BB92
102+  BB92 01 06 00         ld bc,6
103+  BB95 11 52 C1         ld de,scores_current+2
104+  BB98 3A DA BA         ld a,(game_currentplayer)
105+  BB9B FE 01            cp 1
106+  BB9D C2 A6 BB         jp nz,player_init_lifestart0
107+  BBA0 21 E0 BB         ld hl,player1_score+2
108+  BBA3 C3 A9 BB         jp player_init_lifestart1
109+  BBA6              player_init_lifestart0:
110+  BBA6 21 E9 BB         ld hl,player2_score+2
111+  BBA9              player_init_lifestart1:
112+  BBA9 ED B0            ldir
113+  BBAB C9               ret
114+  BBAC
115+  BBAC              ;
116+  BBAC              ; Finalises a player at end of a life
117+  BBAC              ; Copy lives, copy score
118+  BBAC              ;
119+  BBAC              player_lifeend:
120+  BBAC 01 11 BB         ld bc,player+9
121+  BBAF 0A               ld a,(bc)
122+  BBB0 01 DC BB         ld bc,player1_lives
123+  BBB3 02               ld (bc),a
124+  BBB4 CD B8 BB         call player_recordcurrentscore
125+  BBB7 C9               ret
126+  BBB8
127+  BBB8              ;
128+  BBB8              ; Copies the current score in the current
129+  BBB8              ;
130+  BBB8              player_recordcurrentscore:
131+  BBB8 01 06 00         ld bc,6                  ; copy current score back to correct player
132+  BBBB 21 52 C1         ld hl,scores_current+2
133+  BBBE 3A DA BA         ld a,(game_currentplayer)
134+  BBC1 FE 01            cp 1
135+  BBC3 C2 CC BB         jp nz,player_lifeend0
136+  BBC6 11 E0 BB         ld de,player1_score+2
137+  BBC9 C3 CF BB         jp player_lifeend1
138+  BBCC              player_lifeend0:
139+  BBCC 11 E9 BB         ld de,player2_score+2
140+  BBCF              player_lifeend1:
141+  BBCF ED B0            ldir
142+  BBD1 C9               ret
143+  BBD2
144+  BBD2              ;
145+  BBD2              ; Player just died, subtract a life
146+  BBD2              ;
147+  BBD2              player_died:
148+  BBD2 01 11 BB         ld bc,player+9
149+  BBD5 0A               ld a,(bc)
150+  BBD6 3D               dec a
151+  BBD7 02               ld (bc),a
152+  BBD8 CD AC BB         call player_lifeend
153+  BBDB C9               ret
154+  BBDC
155+  BBDC              ;
156+  BBDC              ; Player lives
157+  BBDC              ;
158+  BBDC              player1_lives:
159+  BBDC 03               defb 3
160+  BBDD              player2_lives:
161+  BBDD 03               defb 3
162+  BBDE
163+  BBDE              ;
164+  BBDE              ; Player scores
165+  BBDE              ;
166+  BBDE              player1_score:
167+  BBDE 04 01 30 30      defb 4,1,'000000',255
167+  BBE2 30 30 30 30
167+  BBE6 FF
168+  BBE7              player2_score:
169+  BBE7 16 01 30 30      defb 22,1,'000000',255
169+  BBEB 30 30 30 30
169+  BBEF FF
170+  BBF0
171+  BBF0              ;
172+  BBF0              ; Kills a player this life
173+  BBF0              ;
174+  BBF0              player_killplayer:
175+  BBF0 21 12 BB         ld hl,player+10
176+  BBF3 36 01            ld (hl),1
177+  BBF5 C9               ret
178+  BBF6
179+  BBF6              ;
180+  BBF6              ; Crush a player this life
181+  BBF6              ;
182+  BBF6              player_crushplayer:
183+  BBF6 21 13 BB         ld hl,player+11             ; mark as crushed
184+  BBF9 36 01            ld (hl),1
185+  BBFB C9               ret
186+  BBFC
187+  BBFC              player_tankkillplayer
188+  BBFC 21 13 BB         ld hl,player+11             ; mark as tanked
189+  BBFF 36 02            ld (hl),2
190+  BC01 C9               ret
191+  BC02
192+  BC02              player_zonkplayer
193+  BC02 21 13 BB         ld hl,player+11             ; mark as zonked (missile)
194+  BC05 36 03            ld (hl),3
195+  BC07 C9               ret
196+  BC08
197+  BC08              ;
198+  BC08              ; Draws the player at the current position or deletes them
199+  BC08              ;
200+  BC08              player_drawplayer:
201+  BC08 3A 0A BB         ld a,(player+2)             ; get the current direction
202+  BC0B FE 03            cp 3
203+  BC0D C2 12 BC         jp nz,player_drawplayer0
204+  BC10 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
205+  BC12              player_drawplayer0:
206+  BC12 5F               ld e,a                      ; store in e
207+  BC13 3A 13 BB         ld a,(player+11)             ; get the dying flag
208+  BC16 FE 01            cp 1
209+  BC18 CA 2A BC         jp z,player_drawplayer3     ; if it's one, we're being crushed
210+  BC1B              player_drawplayer4:
211+  BC1B 3A 0E BB         ld a,(player+6)             ; get the dig flag
212+  BC1E FE 01            cp 1
213+  BC20 CA 79 BC         jp z,player_drawplayer1    ; get dig frame
214+  BC23 3A 0B BB         ld a,(player+3)             ; this is normal movement so get the current frame
215+  BC26 83               add a,e
216+  BC27 C3 7E BC         jp player_drawplayer2
217+  BC2A              player_drawplayer3:
218+  BC2A 21 14 BB         ld hl,player+12
219+  BC2D 7E               ld a,(hl)                  ; crushing, so get the current anim flag
220+  BC2E FE 00            cp 0
221+  BC30 C2 39 BC         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
222+  BC33 3E 64            ld a,100
223+  BC35 77               ld (hl),a                   ; otherwise, load up the anim frames
224+  BC36 C3 1B BC         jp player_drawplayer4       ; and return to the main loop to remove the current frame
225+  BC39              player_drawplayer5:
226+  BC39 3D               dec a
227+  BC3A 77               ld (hl),a
228+  BC3B FE 00            cp 0
229+  BC3D CC F0 BB         call z,player_killplayer     ; final animation, so kill the player
230+  BC40 FE 0A            cp 10                         ; play the sound
231+  BC42 CC 7B AE         call z, sound_rockfell
232+  BC45 FE 14            cp 20                        ; check if we should move the rock
233+  BC47 C2 5B BC         jp nz,player_drawplayer8
234+  BC4A D9               exx
235+  BC4B F5               push af
236+  BC4C ED 4B F1 BF      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
237+  BC50 21 92 B4         ld hl,sprites+72
238+  BC53 CD 95 A9         call sprites_drawsprite     ; draw a rock over current
239+  BC56 F1               pop af
240+  BC57 D9               exx
241+  BC58 C3 72 BC         jp player_drawplayer6       ; continue drawing player
242+  BC5B              player_drawplayer8:
243+  BC5B FE 14            cp 20
244+  BC5D D2 72 BC         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
245+  BC60 ED 4B 08 BB      ld bc,(player)
246+  BC64 CD C3 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
247+  BC67 3E 42            ld a,66             ; load red
248+  BC69 CD 1B A9         call screen_setattr
249+  BC6C 21 92 B4         ld hl,sprites+72            ; otherwise, player is rock
250+  BC6F C3 88 BC         jp player_drawplayer7
251+  BC72              player_drawplayer6:
252+  BC72 E6 01            and 1                       ; check for odd
253+  BC74 C6 0A            add 10                      ; add 10, to get either 10 or 11
254+  BC76 C3 7E BC         jp player_drawplayer2
255+  BC79              player_drawplayer1:
256+  BC79 3A 0A BB         ld a,(player+2)             ; digging, get the current direction again, because want all four
257+  BC7C C6 06            add a,6                     ; add direction to 6 to get frame
258+  BC7E              player_drawplayer2:
259+  BC7E 07               rlca
260+  BC7F 07               rlca
261+  BC80 07               rlca                        ; multiply by eight
262+  BC81 6F               ld l,a
263+  BC82 26 00            ld h,0
264+  BC84 11 3D B5         ld de,player_sprite
265+  BC87 19               add hl,de                   ; load hl with the location of the player sprite data
266+  BC88              player_drawplayer7:
267+  BC88 ED 4B 08 BB      ld bc,(player)              ; load bc with the start coords
268+  BC8C CD 95 A9         call sprites_drawsprite     ; call the routine to draw the sprite
269+  BC8F                  ;call player_storeupdatedlines ; log updated rows
270+  BC8F C9               ret
271+  BC90
272+  BC90
273+  BC90              ;
274+  BC90              ; Runs after the player just moved. Changes animation frame if required
275+  BC90              ;
276+  BC90              player_justmoved:
277+  BC90 D9               exx
278+  BC91 3A 0C BB         ld a,(player+4)             ; get the transition count
279+  BC94 FE 00            cp 0
280+  BC96 CA 9C BC         jp z, player_justmoved2     ; if zero reset and change the frame
281+  BC99 C3 B6 BC         jp player_justmoved1       ; otherwise decrease and continue
282+  BC9C              player_justmoved2:
283+  BC9C                  ; reset and change frame in here
284+  BC9C 3E 01            ld a,1
285+  BC9E 32 0C BB         ld (player+4),a            ; reset back to whatever
286+  BCA1 3A 0B BB         ld a,(player+3)             ; load the frame
287+  BCA4 FE 03            cp 3                       ; flip between 3 and 0
288+  BCA6 C2 AE BC         jp nz, player_justmoved4
289+  BCA9 3E 00            ld a,0
290+  BCAB C3 B0 BC         jp player_justmoved5
291+  BCAE              player_justmoved4:
292+  BCAE 3E 03            ld a,3
293+  BCB0              player_justmoved5:
294+  BCB0 32 0B BB         ld (player+3),a           ; save back
295+  BCB3 C3 BA BC         jp player_justmoved3
296+  BCB6              player_justmoved1:
297+  BCB6                  ; decrease count
298+  BCB6 3D               dec a
299+  BCB7 32 0C BB         ld (player+4),a
300+  BCBA              player_justmoved3:
301+  BCBA D9               exx;
302+  BCBB C9               ret
303+  BCBC
304+  BCBC              ;
305+  BCBC              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
306+  BCBC              ; Outputs:
307+  BCBC              ; a - 1 for completed level
308+  BCBC              player_checkforexit:
309+  BCBC ED 4B 08 BB      ld bc,(player)                 ; get player coords
310+  BCC0 ED 5B 22 80      ld de,(init_coord)             ; get start coords
311+  BCC4 78               ld a,b
312+  BCC5 BA               cp d                         ; compare horiz
313+  BCC6 C2 D1 BC         jp nz,player_checkforexit1
314+  BCC9 79               ld a,c
315+  BCCA BB               cp e                        ; compare vert
316+  BCCB C2 D1 BC         jp nz,player_checkforexit1
317+  BCCE              player_checkforexit0:
318+  BCCE 3E 01            ld a,1                       ; hasn't completed
319+  BCD0 C9               ret
320+  BCD1              player_checkforexit1:
321+  BCD1 3E 00            ld a,0                       ; has completed
322+  BCD3 C9               ret
# file closed: game/player.asm
 40   BCD4                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  BCD4              ;
  2+  BCD4              ; Ship initial position: vert,horiz
  3+  BCD4              ;
  4+  BCD4              ship_initpos:
  5+  BCD4 00 24            defb 0,36
  6+  BCD6              ship_initpos2:
  7+  BCD6 00 00            defb 0,0
  8+  BCD8              ship_frame:
  9+  BCD8 00               defb 0
 10+  BCD9              ;
 11+  BCD9              ; The current memory location
 12+  BCD9              ;
 13+  BCD9              ship_current_sprite:
 14+  BCD9 00 00            defb 0,0
 15+  BCDB
 16+  BCDB              ship_current_coords:
 17+  BCDB 00 00            defb 0,0
 18+  BCDD
 19+  BCDD              ship_process:
 20+  BCDD 3A 13 BB         ld a,(player+11)
 21+  BCE0 FE 02            cp 2                        ; has the player been killed by tank?
 22+  BCE2 C0               ret nz                      ; do nothing if not
 23+  BCE3 CD AC B8         call control_scroll_up           ; make sure the screen is on the top screen
 24+  BCE6 CD 55 BD         call ship_takeoff           ; bye bye
 25+  BCE9 CD F0 BB         call player_killplayer      ; killed
 26+  BCEC 06 32            ld b,50
 27+  BCEE CD 82 80         call utilities_pauseforframes
 28+  BCF1 C9               ret
 29+  BCF2
 30+  BCF2              ;
 31+  BCF2              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  BCF2              ;
 33+  BCF2              ship_land:
 34+  BCF2 ED 4B D4 BC      ld bc,(ship_initpos)
 35+  BCF6 ED 43 D6 BC      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  BCFA 1E 00            ld e,0                      ; store a flag to track first time round
 37+  BCFC 06 09            ld b,9                      ; move down 8 pixels
 38+  BCFE              ship_land0:
 39+  BCFE C5               push bc
 40+  BCFF 7B               ld a,e
 41+  BD00 D5               push de                     ; store de for next time round
 42+  BD01 FE 01            cp 1                        ; check first time flag
 43+  BD03 C2 18 BD         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  BD06 CD 9D BD         call ship_draw_full         ; delete old one
 45+  BD09 CD 81 BD         call ship_change_frame      ; increment the frame
 46+  BD0C ED 4B D6 BC      ld bc,(ship_initpos2)       ; get the current coords
 47+  BD10 81 C6 01         add c,1                     ; move down one pixels
 48+  BD13 4F               ld c,a
 49+  BD14 ED 43 D6 BC      ld (ship_initpos2),bc
 50+  BD18              ship_land1:
 51+  BD18 CD 9D BD         call ship_draw_full         ; draw the ship
 52+  BD1B CD 96 BD         call ship_draw_screen
 53+  BD1E D1               pop de
 54+  BD1F 1E 01            ld e,1
 55+  BD21 C1               pop bc
 56+  BD22 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  BD24                  ; done moving down
 58+  BD24                  ; now move across
 59+  BD24 CD 08 BC         call player_drawplayer      ; draw player
 60+  BD27 CD 9D BD         call ship_draw_full         ; delete old one
 61+  BD2A 1E 00            ld e,0                      ; store a flag to track first time round
 62+  BD2C 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  BD2E              ship_land3:
 64+  BD2E C5               push bc
 65+  BD2F 7B               ld a,e
 66+  BD30 D5               push de                     ; store de for next time round
 67+  BD31 FE 01            cp 1                        ; check first time flag
 68+  BD33 C2 48 BD         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  BD36 CD 9D BD         call ship_draw_full         ; delete old one
 70+  BD39 CD 81 BD         call ship_change_frame      ; increment the frame
 71+  BD3C ED 4B D6 BC      ld bc,(ship_initpos2)       ; get the current coords
 72+  BD40 78               ld a,b
 73+  BD41 D6 01            sub 1                       ; move back one pixels
 74+  BD43 47               ld b,a
 75+  BD44 ED 43 D6 BC      ld (ship_initpos2),bc
 76+  BD48              ship_land2:
 77+  BD48 CD 9D BD         call ship_draw_full         ; draw the ship
 78+  BD4B CD 96 BD         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  BD4E D1               pop de
 80+  BD4F 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  BD51 C1               pop bc
 82+  BD52 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  BD54 C9               ret
 84+  BD55
 85+  BD55              ;
 86+  BD55              ;   Take off the ship
 87+  BD55              ;
 88+  BD55              ship_takeoff:
 89+  BD55 1E 01            ld e,1                      ; store a flag to track first time round
 90+  BD57 06 08            ld b,8                      ; move up 8 pixels
 91+  BD59              ship_takeoff0:
 92+  BD59 C5               push bc
 93+  BD5A 7B               ld a,e
 94+  BD5B D5               push de                     ; store de for next time round
 95+  BD5C FE 01            cp 1                        ; check first time flag
 96+  BD5E C2 74 BD         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  BD61 ED 4B D6 BC      ld bc,(ship_initpos2)       ; get the current coords
 98+  BD65 CD 9D BD         call ship_draw_full         ; delete old one
 99+  BD68 CD 81 BD         call ship_change_frame      ; increment the frame
100+  BD6B ED 4B D6 BC      ld bc,(ship_initpos2)       ; get the current coords
101+  BD6F 0D               dec c                       ; move up one pixels
102+  BD70 ED 43 D6 BC      ld (ship_initpos2),bc
103+  BD74              ship_takeoff1:
104+  BD74 CD 9D BD         call ship_draw_full         ; draw the ship
105+  BD77 CD 96 BD         call ship_draw_screen
106+  BD7A D1               pop de
107+  BD7B 1E 01            ld e,1
108+  BD7D C1               pop bc
109+  BD7E 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  BD80                  ; done moving up
111+  BD80 C9               ret
112+  BD81
113+  BD81              ;
114+  BD81              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  BD81              ;
116+  BD81              ship_change_frame:
117+  BD81 F5               push af
118+  BD82 3A D8 BC         ld a,(ship_frame)
119+  BD85 FE 00            cp 0
120+  BD87 CA 8F BD         jp z,ship_change_frame0
121+  BD8A 3E 00            ld a,0                      ; flip to 0
122+  BD8C C3 91 BD         jp ship_change_frame1
123+  BD8F              ship_change_frame0:
124+  BD8F 3E 20            ld a,32                      ; flip to 32
125+  BD91              ship_change_frame1:
126+  BD91 32 D8 BC         ld (ship_frame),a            ; save the frame
127+  BD94 F1               pop af
128+  BD95 C9               ret
129+  BD96
130+  BD96              ship_draw_screen:
131+  BD96 76               halt
132+  BD97 F3               di
133+  BD98 CD 9A A6         call buffer_buffertoscreen  ; copy buffer to screen
134+  BD9B FB               ei                          ; enable interupts
135+  BD9C C9               ret
136+  BD9D
137+  BD9D              ship_draw_full:
138+  BD9D 21 9D B5         ld hl,ship_sprite
139+  BDA0 ED 4B D6 BC      ld bc,(ship_initpos2)         ; load bc with the start coords
140+  BDA4 22 D9 BC         ld (ship_current_sprite),hl  ; put into memory
141+  BDA7 ED 43 DB BC      ld (ship_current_coords),bc  ; put into memory
142+  BDAB CD CA BD         call ship_draw
143+  BDAE 08               ex af,af'
144+  BDAF 3A D8 BC         ld a,(ship_frame)            ; get the animation frame
145+  BDB2 16 00            ld d,0
146+  BDB4 5F               ld e,a
147+  BDB5 19               add hl,de
148+  BDB6 22 D9 BC         ld (ship_current_sprite),hl  ; put into memory
149+  BDB9 08               ex af,af'
150+  BDBA ED 4B D6 BC      ld bc,(ship_initpos2)         ; load bc with the start coords
151+  BDBE 81 C6 08         add c,8                      ; move one line down
152+  BDC1 4F               ld c,a
153+  BDC2 ED 43 DB BC      ld (ship_current_coords),bc  ; put into memory
154+  BDC6 CD CA BD         call ship_draw
155+  BDC9 C9               ret
156+  BDCA
157+  BDCA              ;
158+  BDCA              ; Draw the ship
159+  BDCA              ; Inputs:
160+  BDCA              ; None, all in memory
161+  BDCA              ;
162+  BDCA              ship_draw:
163+  BDCA 3E 04            ld a,4                              ; 4 pieces per half
164+  BDCC              ship_draw0:
165+  BDCC F5               push af
166+  BDCD 2A D9 BC         ld hl,(ship_current_sprite)
167+  BDD0 ED 4B DB BC      ld bc,(ship_current_coords)         ; load bc with the start coords
168+  BDD4 CD 95 A9         call sprites_drawsprite
169+  BDD7 2A D9 BC         ld hl,(ship_current_sprite)
170+  BDDA ED 4B DB BC      ld bc,(ship_current_coords)         ; load bc with the start coords
171+  BDDE 11 08 00         ld de,8
172+  BDE1 19               add hl,de
173+  BDE2 80 C6 08         add b,8
174+  BDE5 47               ld b,a
175+  BDE6 22 D9 BC         ld (ship_current_sprite),hl         ; put into memory
176+  BDE9 ED 43 DB BC      ld (ship_current_coords),bc         ; put into memory
177+  BDED F1               pop af
178+  BDEE 3D               dec a
179+  BDEF FE 00            cp 0
180+  BDF1 C2 CC BD         jp nz,ship_draw0
181+  BDF4
182+  BDF4 C9               ret
183+  BDF5
# file closed: game/ship.asm
 41   BDF5                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  BDF5              ;
  2+  BDF5              ; tank initial position: vert,horiz
  3+  BDF5              ;
  4+  BDF5              tank_initpos:
  5+  BDF5 10 D0            defb 16,208
  6+  BDF7              tank_initpos2:
  7+  BDF7 00 00            defb 0,0
  8+  BDF9              tank_frame:
  9+  BDF9 00               defb 0
 10+  BDFA              tank_anim:
 11+  BDFA 11               defb 17
 12+  BDFB
 13+  BDFB              ;
 14+  BDFB              ; The damage countdown
 15+  BDFB              ;
 16+  BDFB              tank_currentdamage:
 17+  BDFB F0               defb 240
 18+  BDFC
 19+  BDFC              ;
 20+  BDFC              ; The damage coordinate
 21+  BDFC              ;
 22+  BDFC              tank_currentdamagecoord:
 23+  BDFC 16 02            defb 22,2
 24+  BDFE
 25+  BDFE              ;
 26+  BDFE              ; Controls when the tank shoots
 27+  BDFE              ;
 28+  BDFE              tank_count:
 29+  BDFE 00               defb 0
 30+  BDFF
 31+  BDFF              ;
 32+  BDFF              ; Holds the block number of the current damage sprite
 33+  BDFF              ;
 34+  BDFF              tank_damageframe:
 35+  BDFF 00               defb 0
 36+  BE00
 37+  BE00              ;
 38+  BE00              ; The current memory location
 39+  BE00              ;
 40+  BE00              tank_current_sprite:
 41+  BE00 00 00            defb 0,0
 42+  BE02
 43+  BE02              tank_current_coords:
 44+  BE02 00 00            defb 0,0
 45+  BE04
 46+  BE04              ;
 47+  BE04              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  BE04              ;
 49+  BE04              tank_missile_displayed:
 50+  BE04 00               defb 0
 51+  BE05
 52+  BE05              ;
 53+  BE05              ; Initialise the tank
 54+  BE05              ;
 55+  BE05              tank_init:
 56+  BE05 ED 4B F5 BD      ld bc,(tank_initpos)
 57+  BE09 ED 43 F7 BD      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  BE0D 21 F9 BD         ld hl,tank_frame
 59+  BE10 36 00            ld (hl),0
 60+  BE12 21 FA BD         ld hl,tank_anim
 61+  BE15 36 11            ld (hl),17
 62+  BE17 21 FF BD         ld hl,tank_damageframe              ; reset tank
 63+  BE1A 36 00            ld (hl),0
 64+  BE1C 21 FE BD         ld hl,tank_count
 65+  BE1F 36 00            ld (hl),0
 66+  BE21 21 FB BD         ld hl,tank_currentdamage
 67+  BE24 36 F0            ld (hl),240
 68+  BE26 21 FC BD         ld hl,tank_currentdamagecoord
 69+  BE29 36 16            ld (hl),22
 70+  BE2B 23               inc hl
 71+  BE2C 36 02            ld (hl),2
 72+  BE2E 21 04 BE         ld hl,tank_missile_displayed
 73+  BE31 36 00            ld (hl),0
 74+  BE33
 75+  BE33 C9               ret
 76+  BE34
 77+  BE34              ;
 78+  BE34              ;   Draw and move the tank
 79+  BE34              ;   Start processing at frame 200
 80+  BE34              ;   Don't move if anim is zero
 81+  BE34              ;   Decrement frame if moved
 82+  BE34              ;
 83+  BE34              tank_process:
 84+  BE34 3A FA BD         ld a,(tank_anim)
 85+  BE37 FE 00            cp 0
 86+  BE39 C2 40 BE         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  BE3C CD 51 BE         call tank_fire
 88+  BE3F C9               ret
 89+  BE40              tank_process0:
 90+  BE40 CD FE BA         call game_getcurrentframe   ; get the current frame number into a
 91+  BE43 FE 4B            cp 75
 92+  BE45 D8               ret c                       ; return if the frame number is below 100
 93+  BE46 CD 65 BF         call tank_move              ; move tank if not
 94+  BE49 3A FA BD         ld a,(tank_anim)
 95+  BE4C 3D               dec a
 96+  BE4D 32 FA BD         ld (tank_anim),a            ; decrease the anim count
 97+  BE50 C9               ret
 98+  BE51
 99+  BE51              ;
100+  BE51              ; Fires the tank
101+  BE51              ;
102+  BE51              tank_fire:
103+  BE51 3A FE BD         ld a,(tank_count)            ; if not, don't do anything
104+  BE54 3C               inc a                        ; increment
105+  BE55 FE 19            cp 25                        ; have we reached fifty
106+  BE57 C2 5C BE         jp nz,tank_fire0
107+  BE5A 3E 00            ld a,0                       ; reset if reached fifty
108+  BE5C              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  BE5C 32 FE BD         ld (tank_count),a            ; store tank count
110+  BE5F FE 00            cp 0
111+  BE61 CA 78 BE         jp z,tank_fire7              ; If this is zero, fire
112+  BE64 3A 04 BE         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  BE67 FE 00            cp 0
114+  BE69 C8               ret z                       ; don't do anything if not
115+  BE6A CD 1F BF         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  BE6D 3E 00            ld a,0                       ; reset the flag
117+  BE6F 32 04 BE         ld (tank_missile_displayed),a
118+  BE72 3E 02            ld a,2
119+  BE74 CD BF A5         call buffer_marklineforupdate
120+  BE77 C9               ret                        ; only shoot if we're on 0
121+  BE78              tank_fire7:
122+  BE78 3A FB BD         ld a,(tank_currentdamage)    ; get the damage countdown
123+  BE7B E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
124+  BE7D C2 B3 BE         jp nz,tank_fire1            ; not, so just do a normal frame
125+  BE80 ED 4B FC BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
126+  BE84 79               ld a,c
127+  BE85 FE 0A            cp 10
128+  BE87 C2 8E BE         jp nz, tank_fire6
129+  BE8A CD 57 BF         call tank_killedbytank      ; we're through, so the player has died. Kill them.
130+  BE8D C9               ret                         ; return if we're through the mountain
131+  BE8E              tank_fire6:
132+  BE8E 3E 0F            ld a,15
133+  BE90 32 FF BD         ld (tank_damageframe),a     ; reset the damage frame
134+  BE93 21 4A B4         ld hl,sprites               ; location of the empty block
135+  BE96 CD ED A8         call screen_showchar        ; show this character here
136+  BE99 ED 4B FC BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
137+  BE9D 05               dec b                       ; look one above
138+  BE9E CD 51 A9         call screen_ischarempty     ; check if it is empty
139+  BEA1 ED 4B FC BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
140+  BEA5 FE 01            cp 1
141+  BEA7 C2 EA BE         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
142+  BEAA ED 4B FC BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
143+  BEAE 0D               dec c
144+  BEAF ED 43 FC BD      ld (tank_currentdamagecoord),bc ; store the coord
145+  BEB3              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
146+  BEB3 ED 4B FC BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  BEB7 3A FB BD         ld a,(tank_currentdamage)    ; get the damage countdown
148+  BEBA E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
149+  BEBC C2 C7 BE         jp nz, tank_fire5
150+  BEBF CD 81 A9         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
151+  BEC2 FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
152+  BEC4 C2 08 BF         jp nz,tank_fire3            ; if it's a slope, handle this differently
153+  BEC7              tank_fire5:
154+  BEC7 3A FF BD         ld a,(tank_damageframe)
155+  BECA CD 10 A9         call screen_getblock        ; get the block data into hl
156+  BECD CD ED A8         call screen_showchar        ; show this character here
157+  BED0 3A FF BD         ld a,(tank_damageframe)
158+  BED3 3C               inc a
159+  BED4 32 FF BD         ld (tank_damageframe),a     ; increment the damage block and store
160+  BED7 3A FB BD         ld a,(tank_currentdamage)    ; get the damage countdown
161+  BEDA 3D               dec a
162+  BEDB 3D               dec a
163+  BEDC 32 FB BD         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
164+  BEDF 3A 04 BE         ld a,(tank_missile_displayed) ; is the missile displaying?
165+  BEE2 FE 00            cp 0
166+  BEE4 CC 1F BF         call z, tank_missilegraphic
167+  BEE7 C3 11 BF         jp tank_fire4
168+  BEEA              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
169+  BEEA 05               dec b
170+  BEEB C5               push bc
171+  BEEC CD 6A A9         call screen_copyblockdown       ; copy the block down
172+  BEEF ED 4B FC BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
173+  BEF3 C1               pop bc                      ; get the coord we just checked back
174+  BEF4 78               ld a,b
175+  BEF5 FE 00            cp 0
176+  BEF7 CA B3 BE         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
177+  BEFA C5               push bc
178+  BEFB 05               dec b
179+  BEFC CD 51 A9         call screen_ischarempty     ; check if it is empty
180+  BEFF C1               pop bc
181+  BF00 FE 01            cp 1                        ; if empty
182+  BF02 C2 EA BE         jp nz, tank_fire2            ; copy another one down
183+  BF05 C3 B3 BE         jp tank_fire1               ; otherwise, return to main thread
184+  BF08              tank_fire3:                      ; dealing with slopes
185+  BF08 3A FB BD         ld a,(tank_currentdamage)    ; get the damage countdown
186+  BF0B 06 08            ld b,8
187+  BF0D 90               sub b                        ; special case for slopes
188+  BF0E 32 FB BD         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
189+  BF11              tank_fire4:                     ; TIDY UP
190+  BF11 CD BF A5         call buffer_marklineforupdate
191+  BF14 3E 01            ld a,1
192+  BF16 CD BF A5         call buffer_marklineforupdate
193+  BF19 3E 02            ld a,2
194+  BF1B CD BF A5         call buffer_marklineforupdate
195+  BF1E C9               ret
196+  BF1F
197+  BF1F              ;
198+  BF1F              ; Displays or hides the missile graphic, and changes the gun
199+  BF1F              ;
200+  BF1F              tank_missilegraphic:
201+  BF1F 3A 04 BE         ld a,(tank_missile_displayed)
202+  BF22 FE 00            cp 0
203+  BF24 C2 2C BF         jp nz,tank_missilegraphic0
204+  BF27 3E 13            ld a,19
205+  BF29 C3 2E BF         jp tank_missilegraphic1
206+  BF2C              tank_missilegraphic0:
207+  BF2C 3E 00            ld a,0
208+  BF2E              tank_missilegraphic1:
209+  BF2E 32 04 BE         ld (tank_missile_displayed),a ; store the flipped graphic
210+  BF31 ED 4B FC BD      ld bc,(tank_currentdamagecoord)
211+  BF35 0C               inc c
212+  BF36 0C               inc c                   ; print the graphic 2 spaces right
213+  BF37 CD 10 A9         call screen_getblock        ; get the block data into hl
214+  BF3A CD ED A8         call screen_showchar        ; show this character here
215+  BF3D 06 02            ld b,2
216+  BF3F 0E 18            ld c,24                     ; set gunbarrel coords
217+  BF41 11 00 00         ld de,0
218+  BF44 21 FD B5         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
219+  BF47 3A 04 BE         ld a,(tank_missile_displayed)
220+  BF4A FE 00            cp 0
221+  BF4C CA 52 BF         jp z,tank_missilegraphic2
222+  BF4F 11 40 00         ld de,64
223+  BF52              tank_missilegraphic2:
224+  BF52 19               add hl,de                   ; work out missile graphic
225+  BF53 CD ED A8         call screen_showchar        ; show this character here
226+  BF56 C9               ret
227+  BF57
228+  BF57              ;
229+  BF57              ; Deal with the player being killed by the tank
230+  BF57              ;
231+  BF57              tank_killedbytank:
232+  BF57 ED 4B FC BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
233+  BF5B 21 4A B4         ld hl,sprites                   ; empty sprite
234+  BF5E CD ED A8         call screen_showchar            ; hide the last piece of dirt
235+  BF61 CD FC BB         call player_tankkillplayer
236+  BF64 C9               ret
237+  BF65
238+  BF65              tank_move:
239+  BF65 ED 4B F7 BD      ld bc,(tank_initpos2)
240+  BF69 C5               push bc
241+  BF6A 3A FA BD         ld a,(tank_anim)
242+  BF6D FE 11            cp 17                       ; check first time flag
243+  BF6F CA 81 BF         jp z,tank_move1             ; don't draw over previous one if first time
244+  BF72 CD 86 BF         call tank_draw_full         ; delete old one
245+  BF75 ED 4B F7 BD      ld bc,(tank_initpos2)       ; get the current coords
246+  BF79 78               ld a,b
247+  BF7A D6 01            sub 1                       ; move back one pixels
248+  BF7C 47               ld b,a
249+  BF7D ED 43 F7 BD      ld (tank_initpos2),bc
250+  BF81              tank_move1:
251+  BF81 CD 86 BF         call tank_draw_full         ; draw the tank
252+  BF84 C1               pop bc
253+  BF85 C9               ret
254+  BF86
255+  BF86              tank_draw_full:
256+  BF86 21 FD B5         ld hl,tank_sprite
257+  BF89 ED 4B F7 BD      ld bc,(tank_initpos2)         ; load bc with the start coords
258+  BF8D 22 00 BE         ld (tank_current_sprite),hl  ; put into memory
259+  BF90 ED 43 02 BE      ld (tank_current_coords),bc  ; put into memory
260+  BF94 CD B3 BF         call tank_draw
261+  BF97 08               ex af,af'
262+  BF98 3A F9 BD         ld a,(tank_frame)            ; get the animation frame
263+  BF9B 16 00            ld d,0
264+  BF9D 5F               ld e,a
265+  BF9E 19               add hl,de
266+  BF9F 22 00 BE         ld (tank_current_sprite),hl  ; put into memory
267+  BFA2 08               ex af,af'
268+  BFA3 ED 4B F7 BD      ld bc,(tank_initpos2)         ; load bc with the start coords
269+  BFA7 81 C6 08         add c,8                      ; move one line down
270+  BFAA 4F               ld c,a
271+  BFAB ED 43 02 BE      ld (tank_current_coords),bc  ; put into memory
272+  BFAF CD B3 BF         call tank_draw
273+  BFB2 C9               ret
274+  BFB3
275+  BFB3              ;
276+  BFB3              ; Draw the tank
277+  BFB3              ; Inputs:
278+  BFB3              ; None, all in memory
279+  BFB3              ;
280+  BFB3              tank_draw:
281+  BFB3 3E 04            ld a,4                              ; 4 pieces per half
282+  BFB5              tank_draw0:
283+  BFB5 F5               push af
284+  BFB6 2A 00 BE         ld hl,(tank_current_sprite)
285+  BFB9 ED 4B 02 BE      ld bc,(tank_current_coords)         ; load bc with the start coords
286+  BFBD CD 95 A9         call sprites_drawsprite
287+  BFC0 2A 00 BE         ld hl,(tank_current_sprite)
288+  BFC3 ED 4B 02 BE      ld bc,(tank_current_coords)         ; load bc with the start coords
289+  BFC7 11 08 00         ld de,8
290+  BFCA 19               add hl,de
291+  BFCB 80 C6 08         add b,8
292+  BFCE 47               ld b,a
293+  BFCF 22 00 BE         ld (tank_current_sprite),hl         ; put into memory
294+  BFD2 ED 43 02 BE      ld (tank_current_coords),bc         ; put into memory
295+  BFD6 F1               pop af
296+  BFD7 3D               dec a
297+  BFD8 FE 00            cp 0
298+  BFDA C2 B5 BF         jp nz,tank_draw0
299+  BFDD
300+  BFDD C9               ret
301+  BFDE
# file closed: game/tank.asm
 42   BFDE                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  BFDE              ;
  2+  BFDE              ; A structure of falling rocks
  3+  BFDE              ; Assume we'll never have more than 4 falling at any one time
  4+  BFDE              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  BFDE              ;
  6+  BFDE              rocks_falling:
  7+  BFDE 00 00 00 00      defb 0,0,0,0
  8+  BFE2 00 00 00 00      defb 0,0,0,0
  9+  BFE6 00 00 00 00      defb 0,0,0,0
 10+  BFEA 00 00 00 00      defb 0,0,0,0
 11+  BFEE
 12+  BFEE              rocks_tmp:
 13+  BFEE 00               defb 0
 14+  BFEF
 15+  BFEF              rocks_tmp2:
 16+  BFEF 00 00            defb 0,0
 17+  BFF1
 18+  BFF1              ;
 19+  BFF1              ; Coords of the rock that killed us
 20+  BFF1              ;
 21+  BFF1              rocks_killerrock:
 22+  BFF1 00 00            defb 0,0
 23+  BFF3
 24+  BFF3              ;
 25+  BFF3              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 26+  BFF3              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 27+  BFF3              ; If the pixel row is not the rock bottom, stop checking.
 28+  BFF3              ; Inputs:
 29+  BFF3              ; hl- memory location
 30+  BFF3              ;
 31+  BFF3              rocks_checkforfalling:
 32+  BFF3 7E               ld a,(hl)           ; get the pixel row in this memory location
 33+  BFF4 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 34+  BFF6 C2 FC BF         jp nz,rocks_checkforfalling2 ; not a rock, stop
 35+  BFF9 CD FD BF         call rocks_addrocktofalling ; mark the rock as falling
 36+  BFFC              rocks_checkforfalling2:
 37+  BFFC C9               ret
 38+  BFFD
 39+  BFFD              ;
 40+  BFFD              ; Adds the rock to the structure that tracks falling rocks
 41+  BFFD              ; Inputs:
 42+  BFFD              ; hl - memory location of falling rock graphic
 43+  BFFD              ; bc - coords of rock, c vert
 44+  BFFD              rocks_addrocktofalling:
 45+  BFFD C5               push bc             ; store the coords
 46+  BFFE 11 DE BF         ld de,rocks_falling
 47+  C001 06 04            ld b,4              ; number of possible falling rocks
 48+  C003              rocks_addrocktofalling0:
 49+  C003 13               inc de
 50+  C004                  ;inc de
 51+  C004 13               inc de              ; move three along to get the state
 52+  C005 1A               ld a,(de)           ; load the state
 53+  C006 FE 00            cp 0                ; check if this is not falling
 54+  C008 C2 1E C0         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 55+  C00B 13               inc de              ; move to frame
 56+  C00C 3E 10            ld a,16             ; load the number of frames to wobble
 57+  C00E 12               ld (de),a
 58+  C00F 1B               dec de              ; move de back to state
 59+  C010 3E 02            ld a,2
 60+  C012 12               ld (de),a           ; set the state to wobbling
 61+  C013 1B               dec de              ; move back coords
 62+  C014 C1               pop bc              ; get back coords
 63+  C015 78               ld a,b
 64+  C016 12               ld (de),a           ; store the vertical
 65+  C017 1B               dec de
 66+  C018 79               ld a,c
 67+  C019 12               ld (de),a           ; store the horizontal
 68+  C01A C5               push bc
 69+  C01B C3 22 C0         jp rocks_addrocktofalling2 ; done
 70+  C01E              rocks_addrocktofalling1:
 71+  C01E 13               inc de
 72+  C01F 13               inc de              ; move memory along to next rock
 73+  C020 10 E1            djnz rocks_addrocktofalling0 ; try the next rock
 74+  C022              rocks_addrocktofalling2: ; done, return
 75+  C022 C1               pop bc              ; to tidy up
 76+  C023 C9               ret
 77+  C024
 78+  C024              ;
 79+  C024              ; Processes any falling rocks
 80+  C024              ;
 81+  C024              rocks_processrocks:
 82+  C024 DD 21 DE BF      ld ix,rocks_falling
 83+  C028 06 04            ld b,4              ; the number of rocks to check
 84+  C02A              rocks_processrocks0:
 85+  C02A C5               push bc             ; store loop count
 86+  C02B DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 86+  C02F 46 01
 87+  C031 DD 23            inc ix
 88+  C033 DD 23            inc ix              ; move to the state
 89+  C035 DD 7E 00         ld a,(ix)           ; load the state into a
 90+  C038 FE 00            cp 0
 91+  C03A CA 5B C0         jp z,rocks_processrocks3 ; if not falling, check next
 92+  C03D FE 02            cp 2
 93+  C03F C2 4F C0         jp nz, rocks_processrocks2
 94+  C042                  ; we're wobbling
 95+  C042 DD 23            inc ix              ; get frame number for wobble
 96+  C044 DD 7E 00         ld a,(ix)           ; get wobble frame into a
 97+  C047 CD 1E C1         call rocks_wobble
 98+  C04A DD 23            inc ix              ; increment for next
 99+  C04C C3 5F C0         jp rocks_processrocks1  ; do next rock
100+  C04F              rocks_processrocks2:
101+  C04F                  ; we're falling
102+  C04F C5               push bc
103+  C050 CD 63 C0         call rocks_fall
104+  C053 C1               pop bc
105+  C054 DD 23            inc ix
106+  C056 DD 23            inc ix              ; inc ix to get to next
107+  C058 C3 5F C0         jp rocks_processrocks1
108+  C05B              rocks_processrocks3:
109+  C05B DD 23            inc ix
110+  C05D DD 23            inc ix
111+  C05F              rocks_processrocks1:
112+  C05F C1               pop bc              ; get loop count back
113+  C060 10 C8            djnz rocks_processrocks0
114+  C062 C9               ret
115+  C063
116+  C063              ;
117+  C063              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
118+  C063              ; bc - coord of current rock graphic on screen
119+  C063              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
120+  C063              ;
121+  C063              rocks_fall:
122+  C063 DD 2B            dec ix
123+  C065 DD 2B            dec ix              ; decrease ix back to coords
124+  C067 ED 43 EF BF      ld (rocks_tmp2),bc  ; store original coords
125+  C06B 3E 03            ld a,3              ; move this number of pixels
126+  C06D              rocks_fall1:
127+  C06D 32 EE BF         ld (rocks_tmp),a    ; store loop counter
128+  C070 DD 4E 00 DD      ld bc,(ix)          ; get current coords
128+  C074 46 01
129+  C076 CD 8A AA         call sprites_scadd  ; get the memory of the coords into de
130+  C079 14               inc d               ; add 256 to get next row
131+  C07A 1A               ld a,(de)           ; get the contents of the next row
132+  C07B FE 00            cp 0
133+  C07D C2 DD C0         jp nz,rocks_fall3    ; move the rock if the row is empty
134+  C080 0C               inc c               ; increment the vertical
135+  C081 DD 71 00 DD      ld (ix),bc          ; store the new coords
135+  C085 70 01
136+  C087 79               ld a,c              ; get the vertical coord into a
137+  C088 E6 07            and 7               ; divisible by 8?
138+  C08A FE 00            cp 0
139+  C08C C2 A9 C0         jp nz,rocks_fall4   ; if not, carry on
140+  C08F CD C3 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
141+  C092 3E 42            ld a,66             ; load red
142+  C094 CD 1B A9         call screen_setattr
143+  C097 DD 4E 00 DD      ld bc,(ix)
143+  C09B 46 01
144+  C09D 79               ld a,c              ; get vertical
145+  C09E D6 08            sub 8               ; look up one square
146+  C0A0 4F               ld c,a              ; put a back in c
147+  C0A1 CD C3 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  C0A4 3E 46            ld a,70             ; load yellow
149+  C0A6 CD 1B A9         call screen_setattr
150+  C0A9              rocks_fall4:
151+  C0A9 3A EE BF         ld a,(rocks_tmp)    ; get the loop counter
152+  C0AC 3D               dec a
153+  C0AD FE 00            cp 0
154+  C0AF C2 6D C0         jp nz,rocks_fall1   ; do another pixel if needed
155+  C0B2              rocks_fall2:
156+  C0B2 3E 09            ld a,9              ; rock graphic
157+  C0B4 ED 4B EF BF      ld bc,(rocks_tmp2)  ; get the original coords
158+  C0B8 CD 10 A9         call screen_getblock     ; get the memory into hl
159+  C0BB CD 95 A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
160+  C0BE 3E 09            ld a,9
161+  C0C0 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
161+  C0C4 46 01
162+  C0C6 CD 10 A9         call screen_getblock     ; get the memory into hl
163+  C0C9 CD 95 A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
164+  C0CC DD 4E 00 DD      ld bc,(ix)          ; get the coords again
164+  C0D0 46 01
165+  C0D2 CD 03 C1         call rocks_checkforplayer ; check to see if we hit a player
166+  C0D5 DD 23            inc ix
167+  C0D7 DD 23            inc ix                  ; get ix back to state
168+  C0D9 CD F3 C0         call rocks_makesound
169+  C0DC C9               ret
170+  C0DD              rocks_fall3:
171+  C0DD 3E 00            ld a,0              ; set the state to fell
172+  C0DF DD 77 02         ld (ix+2),a           ; store the falling state
173+  C0E2 DD 4E 00 DD      ld bc,(ix)          ; get the coords
173+  C0E6 46 01
174+  C0E8 CD C3 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
175+  C0EB 3E 42            ld a,66             ; load magenta
176+  C0ED CD 1B A9         call screen_setattr
177+  C0F0 C3 B2 C0         jp rocks_fall2      ; rejoin main loop
178+  C0F3
179+  C0F3              ;
180+  C0F3              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
181+  C0F3              ;
182+  C0F3              rocks_makesound:
183+  C0F3 DD 7E 00         ld a,(ix)           ; get the state
184+  C0F6 FE 00            cp 0
185+  C0F8 C0               ret nz              ; if we haven't fallen, don't do anything
186+  C0F9 21 13 BB         ld hl,player+11
187+  C0FC 7E               ld a,(hl)
188+  C0FD FE 01            cp 1
189+  C0FF C4 7B AE         call nz, sound_rockfell ; only make sound if didn't kill player
190+  C102 C9               ret
191+  C103
192+  C103              ;
193+  C103              ; Checks to see if the rock is hitting a player
194+  C103              ; Inputs:
195+  C103              ; bc - coords of rock we're checking
196+  C103              rocks_checkforplayer:
197+  C103 ED 5B 08 BB      ld de,(player)       ; get the player coords
198+  C107 7B               ld a,e               ; get the vert coord first
199+  C108 91               sub c                ; subtract the rock vertical coord from players
200+  C109 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
201+  C10B C0               ret nz               ; if not, hasn't hit
202+  C10C 7A               ld a,d               ; get the player horiz coord
203+  C10D 90               sub b                ; subtract rock coord
204+  C10E C6 07            add 7                ; add max distance
205+  C110 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
206+  C112 DA 16 C1         jp c,rocks_checkforplayer0
207+  C115 C9               ret
208+  C116              rocks_checkforplayer0:
209+  C116 ED 43 F1 BF      ld (rocks_killerrock),bc; store the coords of the killer rock
210+  C11A CD F6 BB         call player_crushplayer ; if so, jump out
211+  C11D C9               ret
212+  C11E
213+  C11E              ;
214+  C11E              ; Wobbles a rocks
215+  C11E              ; Inputs:
216+  C11E              ; bc - coord of current rock graphic on screen
217+  C11E              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
218+  C11E              ; a - wobble frame
219+  C11E              rocks_wobble:
220+  C11E DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
221+  C121 E6 01            and 1               ; is it odd or even, gets 1 or 0
222+  C123 1E 09            ld e,9              ; this is the rock frame
223+  C125 83               add a,e             ; add the frame toggle
224+  C126 C5               push bc
225+  C127 CD 10 A9         call screen_getblock     ; get the memory into hl
226+  C12A CD 95 A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
227+  C12D
228+  C12D DD 7E 00         ld a,(ix)           ; get the frame toggle again
229+  C130 3D               dec a               ; decrease
230+  C131 DD 77 00         ld (ix),a           ; store
231+  C134
232+  C134 E6 01            and 1
233+  C136 1E 09            ld e,9              ; this is the rock frame
234+  C138 83               add a,e             ; add the frame toggle
235+  C139 CD 10 A9         call screen_getblock     ; get the memory into hl
236+  C13C
237+  C13C C1               pop bc
238+  C13D CD 95 A9         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
239+  C140
240+  C140 DD 7E 00         ld a,(ix)           ; get the wobble count back
241+  C143 FE 00            cp 0
242+  C145 C0               ret nz              ; if we're not at zero, return
243+  C146 DD 2B            dec ix              ; otherwise look to state location
244+  C148 3E 01            ld a,1              ; set the state to falling
245+  C14A DD 77 00         ld (ix),a           ; store the falling state
246+  C14D DD 23            inc ix              ; set ix back to location of wobble count, and we're done
247+  C14F C9               ret
248+  C150
# file closed: game/rocks.asm
 43   C150                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  C150              ;
  2+  C150              ; The score of the current player
  3+  C150              ;
  4+  C150              scores_current:
  5+  C150 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  C154 30 30 30 30
  5+  C158 FF
  6+  C159
  7+  C159              scores_defaultname:
  8+  C159 2D 2D 2D         defb '---'
  9+  C15C
 10+  C15C              ;
 11+  C15C              ; The current high score table
 12+  C15C              ;
 13+  C15C              scores_table:
 14+  C15C 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  C160 4D 30 30 30
 14+  C164 30 30 30 FF
 15+  C168 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  C16C 4D 30 30 30
 15+  C170 30 30 30 FF
 16+  C174 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  C178 4D 30 30 30
 16+  C17C 30 30 30 FF
 17+  C180
 18+  C180              ;
 19+  C180              ; Add thousands to the score
 20+  C180              ; Inputs:
 21+  C180              ; b - number to add
 22+  C180              ;
 23+  C180              scores_addthousands:
 24+  C180 21 54 C1         ld hl,scores_current+4
 25+  C183 CD AD C1         call scores_update
 26+  C186 C9               ret
 27+  C187
 28+  C187              ;
 29+  C187              ; Prints the score to screen
 30+  C187              ;
 31+  C187              scores_printscore:
 32+  C187 3A DA BA         ld a,(game_currentplayer)   ; get current player
 33+  C18A 21 50 C1         ld hl,scores_current
 34+  C18D FE 01            cp 1
 35+  C18F C2 97 C1         jp nz, score_printscore0    ; if not player 1
 36+  C192 36 04            ld (hl),4       ; set position for player 1
 37+  C194 C3 99 C1         jp score_printscore1
 38+  C197              score_printscore0:
 39+  C197 36 16            ld (hl),22       ; set position for player 2
 40+  C199              score_printscore1:
 41+  C199 21 50 C1         ld hl,scores_current
 42+  C19C CD BF 84         call string_print
 43+  C19F C9               ret
 44+  C1A0
 45+  C1A0              ;
 46+  C1A0              ; Prints both scores to screen
 47+  C1A0              ;
 48+  C1A0              scores_printscores:
 49+  C1A0 21 DE BB         ld hl,player1_score
 50+  C1A3 CD BF 84         call string_print
 51+  C1A6 21 E7 BB         ld hl,player2_score
 52+  C1A9 CD BF 84         call string_print
 53+  C1AC C9               ret
 54+  C1AD
 55+  C1AD              ;
 56+  C1AD              ; Updates the current score.
 57+  C1AD              ; Inputs:
 58+  C1AD              ; hl - memory location of the score column
 59+  C1AD              ; b - number to add
 60+  C1AD              ;
 61+  C1AD              scores_update:
 62+  C1AD 7E               ld a,(hl)           ; current value of digit.
 63+  C1AE 80               add a,b             ; add points to this digit.
 64+  C1AF 77               ld (hl),a           ; place new digit back in string.
 65+  C1B0 FE 3A            cp 58               ; more than ASCII value '9'?
 66+  C1B2 D8               ret c               ; no - relax.
 67+  C1B3 D6 0A            sub 10              ; subtract 10.
 68+  C1B5 77               ld (hl),a           ; put new character back in string.
 69+  C1B6              scores_update0:
 70+  C1B6 2B               dec hl              ; previous character in string.
 71+  C1B7 34               inc (hl)            ; up this by one.
 72+  C1B8 7E               ld a,(hl)           ; what's the new value?
 73+  C1B9 FE 3A            cp 58               ; gone past ASCII nine?
 74+  C1BB D8               ret c               ; no, scoring done.
 75+  C1BC D6 0A            sub 10              ; down by ten.
 76+  C1BE 77               ld (hl),a           ; put it back
 77+  C1BF C3 B6 C1         jp scores_update0   ; go round again.
 78+  C1C2
 79+  C1C2
 80+  C1C2              ;
 81+  C1C2              ; Displays the high score table at the bottom of the screen
 82+  C1C2              ;
 83+  C1C2              scores_showtable:
 84+  C1C2 21 5C C1         ld hl, scores_table
 85+  C1C5 CD BF 84         call string_print
 86+  C1C8 21 68 C1         ld hl, scores_table+12
 87+  C1CB CD BF 84         call string_print
 88+  C1CE 21 74 C1         ld hl, scores_table+24
 89+  C1D1 CD BF 84         call string_print
 90+  C1D4 C9               ret
 91+  C1D5
 92+  C1D5              ;
 93+  C1D5              ; Place to store the current position we're checking
 94+  C1D5              ;
 95+  C1D5              scores_highscoretmp:
 96+  C1D5 00               defb 0
 97+  C1D6
 98+  C1D6              ;
 99+  C1D6              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
100+  C1D6              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
101+  C1D6              ;
102+  C1D6              scores_processhighscores:
103+  C1D6 21 D5 C1         ld hl,scores_highscoretmp
104+  C1D9 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
105+  C1DB 3E 1D            ld a,29
106+  C1DD              scores_processhighscores3:
107+  C1DD 21 5C C1         ld hl,scores_table          ; position of first score column
108+  C1E0 5F               ld e,a
109+  C1E1 16 00            ld d,0
110+  C1E3 19               add hl,de
111+  C1E4 08               ex af,af'                   ; store a for later
112+  C1E5 11 52 C1         ld de,scores_current+2      ; position of current score column
113+  C1E8 06 06            ld b,6                      ; times to loop
114+  C1EA              scores_processhighscores0:
115+  C1EA 7E               ld a,(hl)
116+  C1EB 4F               ld c,a                      ; get first score column
117+  C1EC 1A               ld a,(de)                   ; get first current column
118+  C1ED B9               cp c                        ; compare current with first
119+  C1EE DA FF C1         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
120+  C1F1 23               inc hl
121+  C1F2 13               inc de                      ; move to next column
122+  C1F3 10 F5            djnz scores_processhighscores0 ; loop
123+  C1F5 08               ex af,af'                     ; still here, so must be bigger
124+  C1F6 32 D5 C1         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
125+  C1F9 0E 0C            ld c,12
126+  C1FB 91               sub c
127+  C1FC D2 DD C1         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
128+  C1FF              scores_processhighscores4
129+  C1FF CD 03 C2         call scores_updatehighscores
130+  C202 C9               ret
131+  C203
132+  C203              ;
133+  C203              ; Update score table
134+  C203              ;
135+  C203              scores_updatehighscores:
136+  C203 3A D5 C1         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
137+  C206 FE 00            cp 0
138+  C208 C8               ret z                       ; if this is 0, didn't get a high score
139+  C209 FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
140+  C20B CA 3E C2         jp z, scores_updatehighscores3
141+  C20E                                              ; copy old score over one below, if not first
142+  C20E 21 5C C1         ld hl,scores_table
143+  C211 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
144+  C214 19               add hl,de                   ; position of first column
145+  C215 2B               dec hl
146+  C216 2B               dec hl
147+  C217 2B               dec hl
148+  C218 E5               push hl
149+  C219 11 0C 00         ld de,12
150+  C21C 19               add hl,de                   ; get position of next score
151+  C21D 54 5D            ld de,hl
152+  C21F E1               pop hl                      ; get hl back
153+  C220 01 09 00         ld bc,9
154+  C223 ED B0            ldir
155+  C225 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
156+  C227 CA 3E C2         jp z,scores_updatehighscores3
157+  C22A 21 5C C1         ld hl,scores_table
158+  C22D 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
159+  C230 19               add hl,de                   ; position of first column
160+  C231 E5               push hl
161+  C232 11 0C 00         ld de,12
162+  C235 19               add hl,de                   ; get position of next score
163+  C236 54 5D            ld de,hl
164+  C238 E1               pop hl                      ; get hl back
165+  C239 01 09 00         ld bc,9
166+  C23C ED B0            ldir
167+  C23E              scores_updatehighscores3:
168+  C23E 06 06            ld b,6                      ; now overwrite
169+  C240 21 5C C1         ld hl,scores_table
170+  C243 16 00            ld d,0
171+  C245 5F               ld e,a
172+  C246 19               add hl,de                   ; position of first column
173+  C247 08               ex af,af'
174+  C248 11 52 C1         ld de,scores_current+2      ; position of current score column
175+  C24B              scores_updatehighscores2:
176+  C24B 1A               ld a,(de)
177+  C24C 77               ld (hl),a
178+  C24D 23               inc hl
179+  C24E 13               inc de
180+  C24F 10 FA            djnz scores_updatehighscores2
181+  C251 11 09 00         ld de,9
182+  C254 ED 52            sbc hl,de
183+  C256 54 5D            ld de,hl                    ; get back to start of entry
184+  C258 21 59 C1         ld hl,scores_defaultname    ; still need to overwrite the name
185+  C25B 01 03 00         ld bc,3                      ; 3 chars to copy
186+  C25E ED B0            ldir
187+  C260 C9               ret
# file closed: game/scores.asm
 44   C261                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  C261              diamonds_tmp:
  2+  C261 00               defb 0
  3+  C262
  4+  C262              diamonds_tmp2:
  5+  C262 00               defb 0
  6+  C263
  7+  C263              ;
  8+  C263              ; Holds the number of thousands for the current gem type
  9+  C263              ;
 10+  C263              diamonds_score:
 11+  C263 00               defb 0
 12+  C264
 13+  C264              ;
 14+  C264              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  C264              ; Inputs:
 16+  C264              ; hl - memory location of gem type
 17+  C264              diamonds_twinkle_type:
 18+  C264 CD FE BA         call game_getcurrentframe       ; get current frame number
 19+  C267 E6 07            and 7                           ; want a number from 0-7
 20+  C269 C6 40            add 64                          ; add to 60 to get attr colour
 21+  C26B 32 62 C2         ld (diamonds_tmp2),a             ; store the colour
 22+  C26E              diamonds_twinkle_type0:
 23+  C26E 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  C272 79               ld a,c                          ; load c into a
 25+  C273 FE FF            cp 255                          ; is this the end?
 26+  C275 CA 9D C2         jp z,diamonds_twinkle_type1           ; step out if so
 27+  C278 23               inc hl
 28+  C279 23               inc hl
 29+  C27A 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  C27B FE 01            cp 1
 31+  C27D CA 9E C2         jp z,diamonds_twinkle_type2           ; step out if so
 32+  C280 CD DE C2         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  C283 DC A5 C2         call c,diamonds_collect     ; we collided
 34+  C286 23               inc hl
 35+  C287 E5               push hl
 36+  C288 E5 DD E1         ld ix,hl
 37+  C28B DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  C28F 46 FE
 38+  C291 3A 62 C2         ld a,(diamonds_tmp2)
 39+  C294 CD 1B A9         call screen_setattr
 40+  C297 E1               pop hl
 41+  C298 23               inc hl
 42+  C299 23               inc hl                          ; move to next diamond
 43+  C29A C3 6E C2         jp diamonds_twinkle_type0
 44+  C29D              diamonds_twinkle_type1:
 45+  C29D C9               ret
 46+  C29E              diamonds_twinkle_type2:
 47+  C29E 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  C29F 23               inc hl
 49+  C2A0 23               inc hl
 50+  C2A1 08               ex af,af'
 51+  C2A2 C3 6E C2         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  C2A5
 53+  C2A5              ;
 54+  C2A5              ; Collect the diamond we collided with
 55+  C2A5              ; Inputs:
 56+  C2A5              ; hl - memory location of current diamond, currently on state
 57+  C2A5              ; Output:
 58+  C2A5              ; a - 70 - for yellow on black
 59+  C2A5              diamonds_collect:
 60+  C2A5 36 01            ld (hl),1                       ; collected
 61+  C2A7 E5               push hl
 62+  C2A8 2B               dec hl
 63+  C2A9 2B               dec hl
 64+  C2AA 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  C2AE CD D3 A8         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  C2B1 ED 5B 61 C2      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  C2B5 16 00            ld d,0
 68+  C2B7 21 4A B4         ld hl,sprites
 69+  C2BA 19               add hl,de
 70+  C2BB CD 95 A9         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  C2BE E1               pop hl
 72+  C2BF 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  C2C1 32 62 C2         ld (diamonds_tmp2),a
 74+  C2C4 D9               exx
 75+  C2C5 3A 63 C2         ld a,(diamonds_score)
 76+  C2C8 47               ld b,a
 77+  C2C9 CD 80 C1         call scores_addthousands
 78+  C2CC 3A 61 C2         ld a,(diamonds_tmp)
 79+  C2CF FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  C2D1 C2 D9 C2         jp nz,diamonds_collect0
 81+  C2D4 21 15 BB         ld hl,player+13
 82+  C2D7 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  C2D9              diamonds_collect0:
 84+  C2D9 CD 5E AE         call sound_gemcollected
 85+  C2DC D9               exx
 86+  C2DD C9               ret
 87+  C2DE
 88+  C2DE              ;
 89+  C2DE              ; Checks to see if the gem is hitting a player
 90+  C2DE              ; Inputs:
 91+  C2DE              ; bc - coords of diamond we're checking
 92+  C2DE              diamonds_checkforplayer:
 93+  C2DE 78               ld a,b               ; multiply b by 8
 94+  C2DF 07               rlca
 95+  C2E0 07               rlca
 96+  C2E1 07               rlca
 97+  C2E2 47               ld b,a
 98+  C2E3 ED 5B 08 BB      ld de,(player)       ; get the player coords
 99+  C2E7 7B               ld a,e               ; get the vert coord first
100+  C2E8 90               sub b                ; subtract the diamond vertical coord from players
101+  C2E9 C6 04            add 4                ; add the max distance
102+  C2EB FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  C2ED D0               ret nc               ; if not, hasn't hit
104+  C2EE 79               ld a,c               ; multiply c by 8
105+  C2EF 07               rlca
106+  C2F0 07               rlca
107+  C2F1 07               rlca
108+  C2F2 4F               ld c,a
109+  C2F3 7A               ld a,d               ; get the player horiz coord
110+  C2F4 91               sub c                ; subtract rock coord
111+  C2F5 C6 04            add 4                ; add max distance
112+  C2F7 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  C2F9 D0               ret nc
114+  C2FA 3E 00            ld a,0
115+  C2FC C9               ret
116+  C2FD
117+  C2FD
118+  C2FD              ;
119+  C2FD              ; Initialise diamonds and gems
120+  C2FD              ;
121+  C2FD              diamonds_twinkle
122+  C2FD 21 63 C2         ld hl,diamonds_score
123+  C300 36 02            ld (hl),2         ; store the score we'll add
124+  C302 21 61 C2         ld hl,diamonds_tmp
125+  C305 36 40            ld (hl),64         ; store the location the diamond sprite
126+  C307 21 C5 B3         ld hl, level01diamonds
127+  C30A CD 64 C2         call diamonds_twinkle_type
128+  C30D 21 63 C2         ld hl,diamonds_score
129+  C310 36 01            ld (hl),1         ; store the score we'll add
130+  C312 21 61 C2         ld hl,diamonds_tmp
131+  C315 36 70            ld (hl),112         ; store the location the gem sprite
132+  C317 21 D5 B3         ld hl, level01gems
133+  C31A CD 64 C2         call diamonds_twinkle_type
134+  C31D C9               ret
135+  C31E
136+  C31E              ;
137+  C31E              ; Initialise diamonds and gems
138+  C31E              ;
139+  C31E              diamonds_init:
140+  C31E 21 C5 B3         ld hl, level01diamonds
141+  C321 CD 2B C3         call diamonds_init_type
142+  C324 21 D5 B3         ld hl, level01gems
143+  C327 CD 2B C3         call diamonds_init_type
144+  C32A C9               ret
145+  C32B
146+  C32B              ;
147+  C32B              ; Initialise diamonds or gems, get memory addresses
148+  C32B              ; Inputs:
149+  C32B              ; hl - memory location
150+  C32B              diamonds_init_type:
151+  C32B 4E               ld c,(hl)                      ; get coords into c
152+  C32C 79               ld a,c                          ; load c into add
153+  C32D FE FF            cp 255                          ; is this the end?
154+  C32F CA 46 C3         jp z,diamonds_init_type1             ; step out if so
155+  C332 23               inc hl
156+  C333 46               ld b,(hl)                       ; get coords into b
157+  C334 E5               push hl
158+  C335 CD 84 A8         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  C338 E1               pop hl
160+  C339 23               inc hl                          ; move to state
161+  C33A 36 00            ld (hl),0
162+  C33C 23               inc hl                          ; move to memory
163+  C33D 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  C341 23               inc hl                          ; move to next diamond
165+  C342 23               inc hl
166+  C343 C3 2B C3         jp diamonds_init_type
167+  C346              diamonds_init_type1:
168+  C346 C9               ret
# file closed: game/diamonds.asm
 45   C347                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  C347              ;
  2+  C347              ; Controls when missiles fall
  3+  C347              ;
  4+  C347              missiles_count:
  5+  C347 00               defb 0
  6+  C348
  7+  C348              ;
  8+  C348              ; A structure of falling missiles
  9+  C348              ; Assume we'll never have more than 4 falling at any one time
 10+  C348              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  C348              ;
 12+  C348              missiles_falling:
 13+  C348 00 00 00         defb 0,0,0
 14+  C34B 00 00 00         defb 0,0,0
 15+  C34E 00 00 00         defb 0,0,0
 16+  C351 00 00 00         defb 0,0,0
 17+  C354
 18+  C354              ;
 19+  C354              ; The coords of the missile that killed us
 20+  C354              ;
 21+  C354              missiles_killermissile:
 22+  C354 00 00            defb 0,0
 23+  C356
 24+  C356              ;
 25+  C356              ; Zeroes the state of each missile
 26+  C356              ;
 27+  C356              missiles_init:
 28+  C356 06 0C            ld b,12
 29+  C358 DD 21 4C B3      ld ix,level01missiles
 30+  C35C              missiles_init0:
 31+  C35C DD 36 02 00      ld (ix+2),0               ; set the state to zero
 32+  C360 11 05 00         ld de,5
 33+  C363 DD 19            add ix,de
 34+  C365 DD 36 02 00      ld (ix+2),0
 35+  C369 DD 19            add ix,de
 36+  C36B 10 EF            djnz missiles_init0
 37+  C36D 06 04            ld b,4                  ; reset four falling missiles
 38+  C36F 21 48 C3         ld hl,missiles_falling
 39+  C372              missiles_init1:
 40+  C372 36 00            ld (hl),0
 41+  C374 23               inc hl
 42+  C375 36 00            ld (hl),0
 43+  C377 23               inc hl
 44+  C378 36 00            ld (hl),0
 45+  C37A 23               inc hl
 46+  C37B 10 F5            djnz missiles_init1
 47+  C37D C9               ret
 48+  C37E
 49+  C37E              ;
 50+  C37E              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 51+  C37E              ; Processes any already falling missiles
 52+  C37E              ;
 53+  C37E              missiles_process:
 54+  C37E 3A 13 BB         ld a,(player+11)                        ; check if the player was hit by a missile previously
 55+  C381 FE 03            cp 3
 56+  C383 C2 8A C3         jp nz,missiles_process3                 ; if not, continue
 57+  C386 CD C7 C4         call missiles_zonkplayer
 58+  C389 C9               ret
 59+  C38A              missiles_process3:
 60+  C38A 3A 16 BB         ld a,(player_location)
 61+  C38D FE 01            cp 1
 62+  C38F C2 FD C3         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 63+  C392 21 15 BB         ld hl,player+13
 64+  C395 7E               ld a,(hl)                               ; check if player has collected a diamond
 65+  C396 FE 01            cp 1
 66+  C398 C2 FD C3         jp nz, missiles_process0                ; don't activate if not
 67+  C39B 21 47 C3         ld hl,missiles_count
 68+  C39E 7E               ld a,(hl)                   ; get the missiles count
 69+  C39F 3C               inc a
 70+  C3A0 FE 32            cp 50                                   ; have we reached the count yet
 71+  C3A2 CA A9 C3         jp z,missiles_process2                 ; if not, don't activate a new one
 72+  C3A5 77               ld (hl),a                               ; store the updated count, and continue without activating
 73+  C3A6 C3 FD C3         jp missiles_process0
 74+  C3A9              missiles_process2:
 75+  C3A9 36 00            ld (hl),0                               ; zero the counter
 76+  C3AB 1E 0C            ld e,12
 77+  C3AD CD D6 80         call utilities_randomupper              ; get random number from 0 to 11
 78+  C3B0 11 0A 00         ld de,10
 79+  C3B3 CD 3A 80         call utilities_multiply                 ; multiple random number by 10
 80+  C3B6 54 5D            ld de,hl                                ; this is the offset for the random missile
 81+  C3B8 DD 21 4C B3      ld ix,level01missiles                   ; load the location of the missile definitions
 82+  C3BC DD 19            add ix,de                               ; get to location of missile
 83+  C3BE DD 7E 02         ld a,(ix+2)
 84+  C3C1 FE 00            cp 0
 85+  C3C3 CA D3 C3         jp z,missiles_process1                  ; if this missile isn't active, activate it
 86+  C3C6 11 05 00         ld de,5                                 ; otherwise, check the missile above
 87+  C3C9 DD 19            add ix,de
 88+  C3CB DD 7E 02         ld a,(ix+2)
 89+  C3CE FE 00            cp 0
 90+  C3D0 C2 FD C3         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 91+  C3D3              missiles_process1:                          ; activate a missile
 92+  C3D3 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
 93+  C3D7 DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
 93+  C3DB 46 01
 94+  C3DD 78               ld a,b
 95+  C3DE ED 5B 71 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
 96+  C3E2 93               sub e
 97+  C3E3 CD D3 A8         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
 98+  C3E6 C5               push bc
 99+  C3E7 3E 0C            ld a,12                                 ; inactive missile sprite
100+  C3E9 CD 10 A9         call screen_getblock
101+  C3EC CD 95 A9         call sprites_drawsprite                 ; draw the sprite over the old one
102+  C3EF C1               pop bc
103+  C3F0 C5               push bc
104+  C3F1 3E 14            ld a,20                                 ; active missile sprite
105+  C3F3 CD 10 A9         call screen_getblock
106+  C3F6 CD 95 A9         call sprites_drawsprite                 ; draw the sprite over the old one
107+  C3F9 C1               pop bc
108+  C3FA CD 8B C4         call missiles_addmissiletofalling
109+  C3FD              missiles_process0:
110+  C3FD CD 01 C4         call missiles_fall
111+  C400 C9               ret
112+  C401
113+  C401              ;
114+  C401              ; Processes falling missiles
115+  C401              ;
116+  C401              missiles_fall:
117+  C401 06 04            ld b,4              ; number of possible falling missiles
118+  C403 DD 21 48 C3      ld ix,missiles_falling
119+  C407              missiles_fall0:
120+  C407 C5               push bc
121+  C408 DD 7E 02         ld a,(ix+2)
122+  C40B FE 00            cp 0
123+  C40D CA 6A C4         jp z,missiles_fall1 ; not falling move to next
124+  C410 FE 01            cp 1                ; is this ready to fall
125+  C412 CA 18 C4         jp z, missiles_fall3
126+  C415 C3 84 C4         jp missiles_fall4   ; if not, decrease the countdown
127+  C418              missiles_fall3:
128+  C418 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
128+  C41C 46 01
129+  C41E CD 8A AA         call sprites_scadd  ; get the memory of the coords into de
130+  C421 14               inc d               ; add 256 to get next row
131+  C422 1A               ld a,(de)           ; get the contents of the next row
132+  C423 FE 00            cp 0
133+  C425 C2 7D C4         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
134+  C428 3E 14            ld a,20                                 ; active missile sprite
135+  C42A CD 10 A9         call screen_getblock
136+  C42D CD 95 A9         call sprites_drawsprite                 ; draw the sprite over the old one
137+  C430 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
137+  C434 46 01
138+  C436 0C               inc c               ; move down one pixel
139+  C437 DD 71 00 DD      ld (ix),bc          ; store the new coords
139+  C43B 70 01
140+  C43D 3E 14            ld a,20                                 ; active missile sprite
141+  C43F CD 10 A9         call screen_getblock
142+  C442 CD 95 A9         call sprites_drawsprite                 ; draw the sprite
143+  C445 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
143+  C449 46 01
144+  C44B 79               ld a,c              ; get the vertical coord into a
145+  C44C E6 07            and 7               ; divisible by 8?
146+  C44E FE 00            cp 0
147+  C450 C2 6A C4         jp nz,missiles_fall1   ; if not, carry on
148+  C453 CD C3 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
149+  C456 3E 43            ld a,67             ; load magenta
150+  C458 CD 1B A9         call screen_setattr
151+  C45B DD 4E 00 DD      ld bc,(ix)
151+  C45F 46 01
152+  C461 CD C3 A8         call screen_getcharcoordsfromscreencoords ; get the attr address into de
153+  C464 05               dec b               ; look one square above
154+  C465 3E 46            ld a,70             ; load yellow
155+  C467 CD 1B A9         call screen_setattr
156+  C46A              missiles_fall1:         ; hl at state
157+  C46A DD 4E 00 DD      ld bc,(ix)          ; get coords back
157+  C46E 46 01
158+  C470 CD AC C4         call missiles_checkforplayer ; check for player
159+  C473 DD 23            inc ix
160+  C475 DD 23            inc ix
161+  C477 DD 23            inc ix              ; get to next missile
162+  C479 C1               pop bc
163+  C47A 10 8B            djnz missiles_fall0
164+  C47C C9               ret
165+  C47D              missiles_fall2:
166+  C47D DD 36 02 00      ld (ix+2),0
167+  C481 C3 6A C4         jp missiles_fall1   ; rejoin the loop
168+  C484              missiles_fall4:
169+  C484 3D               dec a               ; decrease the countdown
170+  C485 DD 77 02         ld (ix+2),a         ; store back
171+  C488 C3 6A C4         jp missiles_fall1   ; do next missile
172+  C48B
173+  C48B              ;
174+  C48B              ; Adds the missile to the structure that tracks falling missile
175+  C48B              ; Inputs:
176+  C48B              ; bc - coords of missile, c vert
177+  C48B              missiles_addmissiletofalling:
178+  C48B C5               push bc             ; store the coords
179+  C48C 11 48 C3         ld de,missiles_falling
180+  C48F 06 04            ld b,4              ; number of possible falling missiles
181+  C491              missiles_addmissiletofalling0:
182+  C491 13               inc de
183+  C492 13               inc de              ; move three along to get the state
184+  C493 1A               ld a,(de)           ; load the state
185+  C494 FE 00            cp 0                ; check if this is not falling
186+  C496 C2 A7 C4         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
187+  C499 3E 19            ld a,25
188+  C49B 12               ld (de),a           ; set the state to pre-falling
189+  C49C 1B               dec de              ; move back coords
190+  C49D C1               pop bc              ; get back coords
191+  C49E 78               ld a,b
192+  C49F 12               ld (de),a           ; store the vertical
193+  C4A0 1B               dec de
194+  C4A1 79               ld a,c
195+  C4A2 12               ld (de),a           ; store the horizontal
196+  C4A3 C5               push bc
197+  C4A4 C3 AA C4         jp missiles_addmissiletofalling2 ; done
198+  C4A7              missiles_addmissiletofalling1:
199+  C4A7 13               inc de              ; move memory along to next rock
200+  C4A8 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
201+  C4AA              missiles_addmissiletofalling2: ; done, return
202+  C4AA C1               pop bc              ; to tidy up
203+  C4AB C9               ret
204+  C4AC
205+  C4AC              ;
206+  C4AC              ; Checks to see if the missile is hitting a player
207+  C4AC              ; Inputs:
208+  C4AC              ; bc - coords of missile we're checking
209+  C4AC              missiles_checkforplayer:
210+  C4AC ED 5B 08 BB      ld de,(player)       ; get the player coords
211+  C4B0 7B               ld a,e               ; get the vert coord first
212+  C4B1 91               sub c                ; subtract the missile vertical coord from players
213+  C4B2 FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
214+  C4B4 C0               ret nz               ; if not, hasn't hit
215+  C4B5 7A               ld a,d               ; get the player horiz coord
216+  C4B6 90               sub b                ; subtract missile coord
217+  C4B7 C6 07            add 7                ; add max distance
218+  C4B9 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
219+  C4BB DA BF C4         jp c,missiles_checkforplayer0
220+  C4BE C9               ret
221+  C4BF              missiles_checkforplayer0:
222+  C4BF ED 43 54 C3      ld (missiles_killermissile),bc; store the coords of the killer missile
223+  C4C3 CD 02 BC         call player_zonkplayer ; if so, jump out
224+  C4C6 C9               ret
225+  C4C7
226+  C4C7              ;
227+  C4C7              ; Player has been hit, so draw text over them and mark as dead
228+  C4C7              ;
229+  C4C7              missiles_zonkplayer:
230+  C4C7 CD F0 BB         call player_killplayer      ; mark as dead
231+  C4CA ED 4B 08 BB      ld bc,(player)              ; get player coords
232+  C4CE CD C3 A8         call screen_getcharcoordsfromscreencoords
233+  C4D1 0D               dec c
234+  C4D2 0D               dec c
235+  C4D3 04               inc b
236+  C4D4 C5               push bc
237+  C4D5 3E 42            ld a,66
238+  C4D7 CD 1B A9         call screen_setattr
239+  C4DA 0C               inc c
240+  C4DB CD 1B A9         call screen_setattr
241+  C4DE 0C               inc c
242+  C4DF CD 1B A9         call screen_setattr
243+  C4E2 0C               inc c
244+  C4E3 CD 1B A9         call screen_setattr
245+  C4E6 0C               inc c
246+  C4E7 CD 1B A9         call screen_setattr
247+  C4EA C1               pop bc
248+  C4EB ED 5B 71 A7      ld de,(screen_offset)
249+  C4EF 78               ld a,b
250+  C4F0 93               sub e
251+  C4F1 47               ld b,a                      ; subtract the offset
252+  C4F2 04               inc b
253+  C4F3 04               inc b                       ; add two for the score rows
254+  C4F4 ED 43 B7 84      ld (string_zonk),bc         ; set coords of string
255+  C4F8 21 B7 84         ld hl,string_zonk
256+  C4FB CD BF 84         call string_print
257+  C4FE 06 14            ld b,20
258+  C500 CD 82 80         call utilities_pauseforframes ; pause
259+  C503 C9               ret
260+  C504
# file closed: game/missiles.asm
 46   C504                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  C504              ;
  2+  C504              ; Timer for deciding how fast the trap withdraws
  3+  C504              ;
  4+  C504              thepit_timer:
  5+  C504 00               defb 0
  6+  C505
  7+  C505              ;
  8+  C505              ; Ticks for the trap state. Will count to 3 then reset
  9+  C505              ;
 10+  C505              thepit_trapcount:
 11+  C505 00               defb 0
 12+  C506
 13+  C506              ;
 14+  C506              ; The horizontal coordinate of the current pit trap
 15+  C506              ;
 16+  C506              thepit_trapcoord:
 17+  C506 08               defb 8
 18+  C507
 19+  C507              ;
 20+  C507              ; Initialises the pit
 21+  C507              ;
 22+  C507              thepit_init:
 23+  C507 21 06 C5         ld hl,thepit_trapcoord
 24+  C50A 36 08            ld (hl),8
 25+  C50C 21 05 C5         ld hl,thepit_trapcount
 26+  C50F 36 00            ld (hl),0
 27+  C511 C9               ret
 28+  C512
 29+  C512              ;
 30+  C512              ; Performs per frame processing on the pit room
 31+  C512              ;
 32+  C512              thepit_process:
 33+  C512 3A 16 BB         ld a,(player_location)
 34+  C515 FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 35+  C517 C2 60 C5         jp nz,thepit_process0
 36+  C51A 3A 04 C5         ld a,(thepit_timer)             ; get the timer
 37+  C51D 3C               inc a
 38+  C51E 32 04 C5         ld (thepit_timer),a             ; store
 39+  C521 FE 02            cp 2                           ; have we reached the trigger?
 40+  C523 C2 60 C5         jp nz, thepit_process0          ; no need to do anything
 41+  C526 3E 00            ld a,0
 42+  C528 32 04 C5         ld (thepit_timer),a             ; zero the timer and process
 43+  C52B 3A 05 C5         ld a,(thepit_trapcount)         ; get the current count
 44+  C52E 3C               inc a
 45+  C52F 32 05 C5         ld (thepit_trapcount),a         ; reset the trap count
 46+  C532 FE 04            cp 4                            ; do we need to begin another character?
 47+  C534 C2 48 C5         jp nz,thepit_process1           ; if not, draw as normal
 48+  C537 3E 00            ld a,0
 49+  C539 32 05 C5         ld (thepit_trapcount),a         ; reset the trap count
 50+  C53C 3A 06 C5         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 51+  C53F FE 02            cp 2
 52+  C541 CA 60 C5         jp z,thepit_process0
 53+  C544 3D               dec a
 54+  C545 32 06 C5         ld (thepit_trapcoord),a         ; store the reduced coord
 55+  C548
 56+  C548              thepit_process1:                    ; draw the trapdoor in current position
 57+  C548 3A 06 C5         ld a,(thepit_trapcoord)
 58+  C54B FE 02            cp 2
 59+  C54D CA 60 C5         jp z, thepit_process0           ; don't process outside of the pit
 60+  C550 4F               ld c,a
 61+  C551 06 0A            ld b,10                         ; vertical coord will always be the same
 62+  C553 3A 05 C5         ld a,(thepit_trapcount)         ; get the trap count
 63+  C556 5F               ld e,a                          ; store in e
 64+  C557 3E 16            ld a,22                         ; 21 is full trapdoor
 65+  C559 83               add a,e
 66+  C55A CD 10 A9         call screen_getblock
 67+  C55D CD ED A8         call screen_showchar            ; show the char
 68+  C560
 69+  C560              thepit_process0:
 70+  C560 C9               ret
 71+  C561
# file closed: game/thepit.asm
 47   C561                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  C561
  2+  C561              ;
  3+  C561              ; Where the monster currently is
  4+  C561              ;
  5+  C561              monster_currentcoords:
  6+  C561 00 00            defb 0,0
  7+  C563
  8+  C563              ;
  9+  C563              ; The start coords of the monster
 10+  C563              ;
 11+  C563              monster_initcoords:
 12+  C563 70 1B            defb 112,27
 13+  C565
 14+  C565              ;
 15+  C565              ; Store the memory location of the current jump position
 16+  C565              ;
 17+  C565              monster_jumppos:
 18+  C565 00 00            defb 0,0
 19+  C567
 20+  C567              ;
 21+  C567              ; The jump table for the monster.
 22+  C567              ;
 23+  C567              monster_jumptable:
 24+  C567 FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  C56B 02 02 02 02
 24+  C56F 02 02 01 01
 24+  C573 01 01 01 01
 24+  C577 FF
 25+  C578
 26+  C578              ;
 27+  C578              ; The vertical direction: 0 up, 1 down
 28+  C578              ;
 29+  C578              monster_jumpdirectionvert:
 30+  C578 00               defb 0
 31+  C579
 32+  C579              ;
 33+  C579              ; The horiz direction: 0 right, 1 left
 34+  C579              ;
 35+  C579              monster_jumpdirectionhoriz:
 36+  C579 00               defb 0
 37+  C57A
 38+  C57A              ;
 39+  C57A              ; Frame offset, 0 or 32
 40+  C57A              ;
 41+  C57A              monster_frameoffset:
 42+  C57A 00               defb 0
 43+  C57B
 44+  C57B              ;
 45+  C57B              ; Monster tick
 46+  C57B              ;
 47+  C57B              monster_tick:
 48+  C57B 00               defb 0
 49+  C57C
 50+  C57C              ;
 51+  C57C              ; Initialises the pit monster
 52+  C57C              ;
 53+  C57C              monster_init:
 54+  C57C ED 4B 63 C5      ld bc,(monster_initcoords)              ; load the initial coords
 55+  C580 ED 43 61 C5      ld (monster_currentcoords),bc           ; save in current coords
 56+  C584 21 68 C5         ld hl,monster_jumptable+1
 57+  C587 22 65 C5         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 58+  C58A 3E 00            ld a,0
 59+  C58C 32 78 C5         ld (monster_jumpdirectionvert),a        ; going up
 60+  C58F 32 7A C5         ld (monster_frameoffset),a
 61+  C592 32 7B C5         ld (monster_tick),a
 62+  C595 CD 15 C6         call monster_draw                       ; the monster
 63+  C598 C9               ret
 64+  C599
 65+  C599              ;
 66+  C599              ; Animate the monster
 67+  C599              ;
 68+  C599              monster_process:
 69+  C599 3A 7B C5         ld a,(monster_tick)                     ; check if we should draw this frame
 70+  C59C FE 01            cp 1
 71+  C59E CA A6 C5         jp z,monster_process6
 72+  C5A1 3C               inc a
 73+  C5A2 32 7B C5         ld (monster_tick),a                     ; increase the tick and continue
 74+  C5A5 C9               ret
 75+  C5A6              monster_process6:
 76+  C5A6 3E 00            ld a,0
 77+  C5A8 32 7B C5         ld (monster_tick),a                     ; zero the tick
 78+  C5AB CD 15 C6         call monster_draw                       ; overwrite the old sprite
 79+  C5AE 3A 7A C5         ld a,(monster_frameoffset)              ; get the anim frame offset
 80+  C5B1 EE 20            xor 32                                  ; flip between 0 and 32
 81+  C5B3 32 7A C5         ld (monster_frameoffset),a              ; store
 82+  C5B6 ED 4B 61 C5      ld bc,(monster_currentcoords)           ; get the current coords
 83+  C5BA 2A 65 C5         ld hl,(monster_jumppos)                 ; get the position in the jump table
 84+  C5BD 56               ld d,(hl)                               ; get the jump modifier
 85+  C5BE 3A 78 C5         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 86+  C5C1 FE 00            cp 0                                    ; if 0, going up, so dec vert
 87+  C5C3 C2 CC C5         jp nz,monster_process0
 88+  C5C6 79               ld a,c
 89+  C5C7 92               sub d
 90+  C5C8 23               inc hl                                  ; move forward a jump pos
 91+  C5C9 C3 CF C5         jp monster_process1
 92+  C5CC              monster_process0:
 93+  C5CC 79               ld a,c                                   ; going down so inc c
 94+  C5CD 82               add a,d
 95+  C5CE 2B               dec hl                                  ; move back a jump pos
 96+  C5CF              monster_process1:
 97+  C5CF 4F               ld c,a                                  ; get the vertical coord back
 98+  C5D0 7E               ld a,(hl)                               ; check the next jump pos
 99+  C5D1 FE FF            cp 255                                  ; if 255 reverse
100+  C5D3 CA DC C5         jp z,monster_process3
101+  C5D6 22 65 C5         ld (monster_jumppos),hl                 ; store the new pos
102+  C5D9 C3 E4 C5         jp monster_process2                     ; keep going
103+  C5DC              monster_process3:
104+  C5DC 3A 78 C5         ld a,(monster_jumpdirectionvert)        ; get the direction
105+  C5DF EE 01            xor 1                                   ; flip it
106+  C5E1 32 78 C5         ld (monster_jumpdirectionvert),a        ; store it
107+  C5E4              monster_process2:
108+  C5E4 3A 79 C5         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
109+  C5E7 FE 00            cp 0                                    ; is it right?
110+  C5E9 C2 FE C5         jp nz,monster_process4
111+  C5EC 04               inc b                                   ; 1 pixel right
112+  C5ED 78               ld a,b
113+  C5EE FE 38            cp 56                                   ; reached the edge of the pit?
114+  C5F0 C2 0D C6         jp nz,monster_process5
115+  C5F3 3A 79 C5         ld a,(monster_jumpdirectionhoriz)
116+  C5F6 EE 01            xor 1
117+  C5F8 32 79 C5         ld (monster_jumpdirectionhoriz),a       ; flip direction
118+  C5FB C3 0D C6         jp monster_process5
119+  C5FE              monster_process4:
120+  C5FE 05               dec b                                   ; 1 pixel left
121+  C5FF 78               ld a,b
122+  C600 FE 18            cp 24                                   ; reached the edge of the pit?
123+  C602 C2 0D C6         jp nz,monster_process5
124+  C605 3A 79 C5         ld a,(monster_jumpdirectionhoriz)
125+  C608 EE 01            xor 1
126+  C60A 32 79 C5         ld (monster_jumpdirectionhoriz),a       ; flip direction
127+  C60D              monster_process5:
128+  C60D ED 43 61 C5      ld (monster_currentcoords),bc           ; store the new vertical coords
129+  C611 CD 15 C6         call monster_draw                       ; finally, draw the monster
130+  C614 C9               ret
131+  C615
132+  C615              ;
133+  C615              ; Draw the monster at the current location
134+  C615              ;
135+  C615              monster_draw:
136+  C615 ED 4B 61 C5      ld bc,(monster_currentcoords)
137+  C619 3A 7A C5         ld a,(monster_frameoffset)
138+  C61C 11 00 00         ld de,0
139+  C61F 5F               ld e,a
140+  C620 21 45 B6         ld hl,monster_sprite                    ; load the first frame
141+  C623 19               add hl,de
142+  C624 CD F3 A9         call sprites_draw2by2sprite
143+  C627 C9               ret
# file closed: game/monster.asm
 48   C628
 49   C628              ;===========================================================================
 50   C628              ; main routine - the code execution starts here.
 51   C628              ; Sets up the new interrupt routine, the memory
 52   C628              ; banks and jumps to the start loop.
 53   C628              ;===========================================================================
 54   C628              main:
 55   C628
 56   C628                  ; Draw the title screen
 57   C628              main_titlescreen:
 58   C628 CD B4 AA         call titlescreen_show
 59   C62B CD 4D BB         call player_init_gamestart
 60   C62E
 61   C62E              main_lifestart:
 62   C62E
 63   C62E CD 6B BB         call player_init_lifestart
 64   C631
 65   C631 CD 1A AC         call lifescreen_draw        ; show the lives remaining screen
 66   C634
 67   C634 CD 00 80         call init_start
 68   C637 CD 8C A7         call screen_draw
 69   C63A CD DB A6         call buffer_allbuffertoscreen
 70   C63D
 71   C63D CD 56 C3         call missiles_init
 72   C640 CD F2 BC         call ship_land              ; land the ship
 73   C643 CD 05 BE         call tank_init
 74   C646 CD 1E C3         call diamonds_init
 75   C649 CD 07 C5         call thepit_init
 76   C64C CD 7C C5         call monster_init
 77   C64F
 78   C64F              mloop:
 79   C64F 76               halt
 80   C650 CD 84 C6         call main_loop_processing
 81   C653
 82   C653                  ;
 83   C653                  ; Check if the player died
 84   C653                  ;
 85   C653 21 12 BB         ld hl,player+10
 86   C656 7E               ld a,(hl)                   ; check if the player died this frame
 87   C657 FE 01            cp 1
 88   C659 C2 70 C6         jp nz,mloop0
 89   C65C CD D2 BB         call player_died        ; do end of life housekeeping
 90   C65F 06 28            ld b,40
 91   C661 CD 82 80         call utilities_pauseforframes
 92   C664 21 11 BB         ld hl,player+9        ; check lives remaining
 93   C667 7E               ld a,(hl)
 94   C668 FE 00            cp 0
 95   C66A CA B2 C6         jp z,main_gameover   ; leave the loop if we're done
 96   C66D C3 2E C6         jp main_lifestart    ; otherwise, start a new life
 97   C670              mloop0:
 98   C670                  ;
 99   C670                  ; Check if the player completed the level
100   C670                  ;
101   C670 21 15 BB         ld hl,player+13
102   C673 7E               ld a,(hl)
103   C674 FE 01            cp 1
104   C676 C2 4F C6         jp nz,mloop
105   C679 CD BC BC         call player_checkforexit
106   C67C FE 01            cp 1                        ; look at return, if 1, level has been completed
107   C67E CA B8 C6         jp z,main_endlevel          ; jump to level transition screen
108   C681 C3 4F C6         jp mloop                ; start the loop again
109   C684
110   C684
111   C684              main_loop_processing:
112   C684
113   C684 CD 9A A6         call buffer_buffertoscreen  ; copy buffer to screen
114   C687 CD FF A5         call buffer_clearlist       ; zero the updated lines list
115   C68A CD 17 BB         call player_getlocation     ; figure out where the player is
116   C68D CD 08 BC         call player_drawplayer      ; delete player
117   C690 CD 85 B6         call control_keyboard       ; check keyboard
118   C693 CD 08 BC         call player_drawplayer      ; draw player
119   C696 CD 34 BE         call tank_process           ; prcoess the tank
120   C699 CD DD BC         call ship_process           ; proces the ship
121   C69C CD 24 C0         call rocks_processrocks     ; process falling rocks
122   C69F CD 12 C5         call thepit_process         ; process the pit trap
123   C6A2 CD 7E C3         call missiles_process       ; process missiles
124   C6A5 CD 99 C5         call monster_process        ; process monster
125   C6A8 CD FD C2         call diamonds_twinkle       ; make the diamonds twinkle
126   C6AB CD 87 C1         call scores_printscore      ; update the score on screen
127   C6AE CD EF BA         call game_incrementframe    ; increment the game frame
128   C6B1
129   C6B1 C9               ret
130   C6B2
131   C6B2              main_gameover:
132   C6B2 CD 6D AC         call gameover_draw          ; show the game over screen
133   C6B5 C3 28 C6         jp main_titlescreen         ; go back to title
134   C6B8
135   C6B8              main_endlevel:
136   C6B8 CD B8 BB         call player_recordcurrentscore
137   C6BB CD 5B AD         call endlevel_draw          ; show the end level screen
138   C6BE C3 2E C6         jp main_lifestart           ; start a new life
139   C6C1
140   C6C1              ;===========================================================================
141   C6C1              ; Stack.
142   C6C1              ;===========================================================================
143   C6C1
144   C6C1              ; Stack: this area is reserved for the stack
145   C6C1              STACK_SIZE: equ 100    ; in words
146   C6C1
147   C6C1              ; Reserve stack space
148   C6C1 00 00            defw 0  ; WPMEM, 2
149   C6C3              stack_bottom:
150   C6C3 00 00 00...      defs    STACK_SIZE*2, 0
151   C78B              stack_top:
152   C78B 00 00            defw 0  ; WPMEM, 2
153   C78D
154   C78D                     SAVESNA "ThePit.sna", main
# file closed: main.asm
