# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; main routine - the code execution starts here.
 19   8000              ; Sets up the new interrupt routine, the memory
 20   8000              ; banks and jumps to the start loop.
 21   8000              ;===========================================================================
 22   8000              main:
 23   8000 21 68 B9         ld hl,font
 24   8003 22 36 5C         ld (23606),hl
 25   8006 CD B3 B0         call options_show
 26   8009                  ; Show the red pre-title screen
 27   8009 CD 5B AC         call titlescreen_preshow
 28   800C
 29   800C                  ; Draw the title screen
 30   800C              main_titlescreen:
 31   800C CD 67 AC         call titlescreen_show
 32   800F CD 5E C6         call player_init_gamestart
 33   8012
 34   8012              main_lifestart:
 35   8012
 36   8012 CD 84 C6         call player_init_lifestart
 37   8015 CD 93 C5         call game_setcurrentrocks   ; set the current rocks based on the level
 38   8018                  ;ld a,12
 39   8018                  ;ld (game_difficulty),a
 40   8018 CD D3 C5         call game_setdifficulty     ; set the current difficulty
 41   801B
 42   801B CD F4 AD         call lifescreen_draw        ; show the lives remaining screen
 43   801E
 44   801E CD C9 80         call init_start
 45   8021 CD 12 A9         call screen_draw
 46   8024 CD 61 A8         call buffer_allbuffertoscreen
 47   8027
 48   8027 CD E4 CF         call missiles_init
 49   802A CD B0 C8         call ship_land              ; land the ship
 50   802D CD D7 C9         call tank_init
 51   8030 CD AB CF         call diamonds_init
 52   8033 CD 9C D1         call thepit_init
 53   8036 CD 37 D2         call monster_init
 54   8039 CD 87 D3         call robots_init
 55   803C CD 40 D7         call bullet_init
 56   803F
 57   803F              mloop:
 58   803F                  ;halt
 59   803F CD 86 80         call main_loop_processing
 60   8042
 61   8042                  ;
 62   8042                  ; Check if the player died
 63   8042                  ;
 64   8042 21 22 C6         ld hl,player+10
 65   8045 7E               ld a,(hl)                   ; check if the player died this frame
 66   8046 FE 01            cp 1
 67   8048 C2 72 80         jp nz,mloop0
 68   804B CD 15 C7         call player_died        ; do end of life housekeeping
 69   804E 06 28            ld b,40
 70   8050 CD 64 81         call utilities_pauseforframes
 71   8053
 72   8053 21 21 C6         ld hl,player+9        ; check lives remaining
 73   8056 7E               ld a,(hl)
 74   8057 FE 00            cp 0
 75   8059 C2 6C 80         jp nz,mloop1         ; haven't finished, so keep going
 76   805C
 77   805C 3A 28 C5         ld a,(game_numberplayers) ; get the number of players
 78   805F FE 01            cp 1
 79   8061 CA BA 80         jp z,main_gameover   ; if just one player, then this is game over
 80   8064
 81   8064 3A 29 C5         ld a,(game_currentplayer) ; get the current player
 82   8067 FE 02            cp 2                    ; if we're here, we have no lives, and if the current player is 2, then we're done
 83   8069 CA BA 80         jp z,main_gameover            ; if it's  two game over
 84   806C
 85   806C              mloop1:
 86   806C CD 77 C5         call game_changeplayer ; change player if needed
 87   806F C3 12 80         jp main_lifestart    ; otherwise, start a new life
 88   8072              mloop0:
 89   8072                  ;
 90   8072                  ; Check if the player completed the level
 91   8072                  ;
 92   8072 21 25 C6         ld hl,player+13
 93   8075 7E               ld a,(hl)
 94   8076 FE 01            cp 1
 95   8078 C2 3F 80         jp nz,mloop
 96   807B CD 4F C8         call player_checkforexit
 97   807E FE 01            cp 1                        ; look at return, if 1, level has been completed
 98   8080 CA C0 80         jp z,main_endlevel          ; jump to level transition screen
 99   8083 C3 3F 80         jp mloop                ; start the loop again
100   8086
101   8086
102   8086              main_loop_processing:
103   8086
104   8086 CD 20 A8         call buffer_buffertoscreen  ; copy buffer to screen
105   8089 CD 85 A7         call buffer_clearlist       ; zero the updated lines list
106   808C CD 28 C6         call player_getlocation     ; figure out where the player is
107   808F CD 59 C7         call player_drawplayer      ; delete player
108   8092 CD 0C C0         call control_input          ; check input
109   8095 CD 59 C7         call player_drawplayer      ; draw player
110   8098 CD 06 CA         call tank_process           ; prcoess the tank
111   809B CD 71 C8         call ship_process           ; proces the ship
112   809E CD 26 CC         call rocks_processrocks     ; process falling rocks
113   80A1 CD A8 D1         call thepit_process         ; process the pit trap
114   80A4 CD 0C D0         call missiles_process       ; process missiles
115   80A7 CD 54 D2         call monster_process        ; process monster
116   80AA CD 15 D4         call robots_process         ; process robots
117   80AD CD 8C D7         call bullet_process         ; process the bullet
118   80B0 CD 8A CF         call diamonds_twinkle       ; make the diamonds twinkle
119   80B3 CD 99 CD         call scores_printscore      ; update the score on screen
120   80B6 CD B3 C5         call game_incrementframe    ; increment the game frame
121   80B9
122   80B9 C9               ret
123   80BA
124   80BA              main_gameover:
125   80BA CD 57 AE         call gameover_draw          ; show the game over screen
126   80BD C3 0C 80         jp main_titlescreen         ; go back to title
127   80C0
128   80C0              main_endlevel:
129   80C0 CD E3 C6         call player_recordcurrentstate
130   80C3 CD A5 AF         call endlevel_draw          ; show the end level screen
131   80C6 C3 12 80         jp main_lifestart           ; start a new life
132   80C9
133   80C9
134   80C9              ;===========================================================================
135   80C9              ; Include modules
136   80C9              ;===========================================================================
137   80C9                  include "init.asm"
# file opened: init.asm
  1+  80C9              ;
  2+  80C9              ; Set up at start up
  3+  80C9              ;
  4+  80C9              init_start:
  5+  80C9              ; We want a black screen.
  6+  80C9
  7+  80C9 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  80CB                                      ; bright (64).
  9+  80CB CD 49 81         call utilities_clearscreen
 10+  80CE 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  80D1 AF               xor a               ; quick way to load accumulator with zero.
 12+  80D2 CD 9B 22         call 8859           ; set permanent border colours.
 13+  80D5
 14+  80D5 21 F7 A8         ld hl,screen_offset ; reset some temp variables
 15+  80D8 36 00            ld (hl),0
 16+  80DA 21 F8 A8         ld hl,screen_tmp
 17+  80DD 36 00            ld (hl),0
 18+  80DF 21 2C A7         ld hl,buffer_tmp
 19+  80E2 36 00            ld (hl),0
 20+  80E4 23               inc hl
 21+  80E5 36 00            ld (hl),0
 22+  80E7
 23+  80E7 CD C6 C5         call game_resetcurrentframe ; reset current frame
 24+  80EA
 25+  80EA C9               ret
 26+  80EB
 27+  80EB              ;
 28+  80EB              ;   Start coord
 29+  80EB              ;   vert c, horiz b
 30+  80EB              init_coord:
 31+  80EB 18 30            defb 24,48
 32+  80ED
 33+  80ED              ;
 34+  80ED              ; Number of lives to start
 35+  80ED              ;
 36+  80ED              init_lives:
 37+  80ED 03               defb 3
 38+  80EE
 39+  80EE              ;
 40+  80EE              ; Score to start
 41+  80EE              ;
 42+  80EE              init_score:
 43+  80EE 30 30 30 30      defb '000000'
 43+  80F2 30 30
# file closed: init.asm
138   80F4                  include "utilities.asm"
# file opened: utilities.asm
  1+  80F4              ; ##########################################################################
  2+  80F4              ; Print a character
  3+  80F4              ; Inputs:
  4+  80F4              ; b - x coord
  5+  80F4              ; c - y coord
  6+  80F4              ; d - character
  7+  80F4              ; e - colour
  8+  80F4              ; ##########################################################################
  9+  80F4              utilities_print_char:
 10+  80F4 7B               ld a,e
 11+  80F5 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  80F8 3E 16            ld a,22
 13+  80FA D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  80FB 78               ld a,b              ; Gets the X co-ordinate
 15+  80FC 3D               dec a
 16+  80FD D7               rst 16
 17+  80FE 79               ld a,c              ; and the Y co-ordinate
 18+  80FF D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8100 7A               ld a,d              ; ASCII code for udg.
 20+  8101 D7               rst 16              ; draw block.
 21+  8102 C9               ret
 22+  8103
 23+  8103
 24+  8103              ;Inputs:
 25+  8103              ;     DE and A are factors
 26+  8103              ;Outputs:
 27+  8103              ;     A is not changed
 28+  8103              ;     B is 0
 29+  8103              ;     C is not changed
 30+  8103              ;     DE is not changed
 31+  8103              ;     HL is the product
 32+  8103              ;Time:
 33+  8103              ;     342+6x
 34+  8103              ;
 35+  8103              utilities_multiply:
 36+  8103 06 08            ld b,8          ;7           7
 37+  8105 21 00 00         ld hl,0         ;10         10
 38+  8108 29               add hl,hl     ;11*8       88
 39+  8109 07               rlca          ;4*8        32
 40+  810A 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  810C 19                   add hl,de   ;--         --
 42+  810D 10 F9            djnz $-5      ;13*7+8     99
 43+  810F C9               ret             ;10         10
 44+  8110
 45+  8110              utilities_waitforkey:
 46+  8110 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  8113 36 00            ld (hl),0           ; put null value there.
 48+  8115              utilities_waitforkey0:
 49+  8115 7E               ld a,(hl)           ; new value of LAST K.
 50+  8116 FE 00            cp 0                ; is it still zero?
 51+  8118 20 0A            jr nz,utilities_waitforkey1           ; yes, so no key pressed.
 52+  811A 01 1F 00         ld bc,31                        ; Kempston joystick port.
 53+  811D ED 78            in a,(c)                        ; read input.
 54+  811F E6 10            and 16
 55+  8121 CA 15 81         jp z,utilities_waitforkey0
 56+  8124              utilities_waitforkey1:
 57+  8124 C9               ret                 ; key was pressed.
 58+  8125
 59+  8125              ;
 60+  8125              ; Waits number of frames for keypress. If got, returns 1, if not 0
 61+  8125              ; Inputs:
 62+  8125              ; a - number of frames to waits
 63+  8125              ; Ouputs:
 64+  8125              ; e - 0 not pressed, 1 pressed
 65+  8125              utilities_waitforkey_forframes:
 66+  8125 21 08 5C         ld hl,23560         ; LAST K system variable.
 67+  8128 36 00            ld (hl),0           ; put null value there.
 68+  812A 47               ld b,a              ; number of frames to wait
 69+  812B              utilities_waitforkey_forframes0:
 70+  812B 7E               ld a,(hl)           ; new value of LAST K.
 71+  812C FE 00            cp 0                ; is it still zero?
 72+  812E 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 73+  8130 1E 01            ld e,1              ; set the pressed flag
 74+  8132 C9               ret                 ; key was pressed.
 75+  8133              utilities_waitforkey_forframes1:
 76+  8133 C5               push bc
 77+  8134 01 1F 00         ld bc,31                        ; Kempston joystick port.
 78+  8137 ED 78            in a,(c)                        ; read input.
 79+  8139 C1               pop bc
 80+  813A E6 10            and 16
 81+  813C CA 42 81         jp z,utilities_waitforkey_forframes2
 82+  813F 1E 01            ld e,1              ; set the pressed flag
 83+  8141 C9               ret                 ; key was pressed.
 84+  8142              utilities_waitforkey_forframes2:
 85+  8142 76               halt                ; wait for frame
 86+  8143 76               halt                ; wait for frame
 87+  8144 10 E5            djnz utilities_waitforkey_forframes0 ; loop again
 88+  8146 1E 00            ld e,0              ; nothing pressed in time
 89+  8148 C9               ret
 90+  8149
 91+  8149              ;
 92+  8149              ; Clears the screen
 93+  8149              ; Inputs:
 94+  8149              ; a - attribute colour
 95+  8149              utilities_clearscreen:
 96+  8149 76               halt
 97+  814A 21 00 58         ld hl,22528         ; attr
 98+  814D 11 01 58         ld de,22529         ; attr+1
 99+  8150 01 FF 02         ld bc,767
100+  8153 77               ld (hl),a
101+  8154 ED B0            ldir
102+  8156
103+  8156 21 00 40         ld hl, 16384        ;pixels
104+  8159 11 01 40         ld de, 16385        ;pixels + 1
105+  815C 01 FF 17         ld bc, 6143         ;pixels area length - 1
106+  815F 36 00            ld (hl), 0          ;set first byte to '0'
107+  8161 ED B0            ldir                ;copy bytes
108+  8163
109+  8163 C9               ret
110+  8164
111+  8164              ;
112+  8164              ; Wait for a number of frames
113+  8164              ; Inputs:
114+  8164              ; b - number of frames
115+  8164              utilities_pauseforframes:
116+  8164 76               halt
117+  8165 10 FD            djnz utilities_pauseforframes
118+  8167 C9               ret
119+  8168
120+  8168              utilities_readkey:
121+  8168 21 88 81         LD HL,utilties_keymap              ; Point HL at the keyboard list
122+  816B 16 08            LD D,8                                  ; This is the number of ports (rows) to check
123+  816D 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
124+  816F              utilities_readkey_0:
125+  816F 46               LD B,(HL)                               ; Get the keyboard port address from table
126+  8170 23               INC HL                                  ; Increment to list of keys
127+  8171 ED 78            IN A,(C)                                ; Read the row of keys in
128+  8173 E6 1F            AND $1F                                     ; We are only interested in the first five bits
129+  8175 1E 05            LD E,5                                  ; This is the number of keys in the row
130+  8177              utilities_readkey_1:
131+  8177 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
132+  8179 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
133+  817B 23               INC HL                                  ; Go to next table address
134+  817C 1D               DEC E                                   ; Decrement key loop counter
135+  817D 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
136+  817F 15               DEC D                                   ; Decrement row loop counter
137+  8180 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
138+  8182 A7               AND A                                   ; Clear A (no key found)
139+  8183 C3 68 81         jp utilities_readkey
140+  8186              utilities_readkey_2:
141+  8186 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
142+  8187 C9               RET
143+  8188
144+  8188              utilties_keymap:
145+  8188 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
145+  818C 43 56
146+  818E FD 41 53 44      defb $FD,"A","S","D","F","G"
146+  8192 46 47
147+  8194 FB 51 57 45      defb $FB,"Q","W","E","R","T"
147+  8198 52 54
148+  819A F7 31 32 33      defb $F7,"1","2","3","4","5"
148+  819E 34 35
149+  81A0 EF 30 39 38      defb $EF,"0","9","8","7","6"
149+  81A4 37 36
150+  81A6 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
150+  81AA 55 59
151+  81AC BF 23 4C 4B      defb $BF,"#","L","K","J","H"
151+  81B0 4A 48
152+  81B2 7F 20 23 4D      defb $7F," ","#","M","N","B"
152+  81B6 4E 42
153+  81B8
154+  81B8
155+  81B8              ;
156+  81B8              ; Generates a randomish number in the range 0 to e
157+  81B8              ; Inputs:
158+  81B8              ; e - upper value
159+  81B8              ; Outputs:
160+  81B8              ; a - random number
161+  81B8              utilities_randomupper
162+  81B8 3A 27 C5         ld a,(game_framenumber)
163+  81BB 6F               ld l,a
164+  81BC 26 00            ld h,0
165+  81BE 16 00            ld d,0
166+  81C0 42 4B            ld bc,de
167+  81C2              utilities_randomupper0:
168+  81C2 B7               or a
169+  81C3 ED 42            sbc hl,bc
170+  81C5 F2 C2 81         jp p,utilities_randomupper0
171+  81C8 09               add hl,bc
172+  81C9 01 00 00         ld bc,0
173+  81CC 09               add hl,bc
174+  81CD 7D               ld a,l
175+  81CE C9               ret
176+  81CF
177+  81CF              ;
178+  81CF              ; A pointer to somewhere in the first 8k of ram
179+  81CF              ;
180+  81CF              utilities_rampointer:
181+  81CF 40 1F            defb 64,31
182+  81D1
183+  81D1              utilities_randomfromram:
184+  81D1 2A CF 81         ld hl,(utilities_rampointer)
185+  81D4 2B               dec hl
186+  81D5 7C               ld a,h
187+  81D6 FE 00            cp 0
188+  81D8 C2 DE 81         jp nz,utilities_randomfromram0
189+  81DB 21 40 1F         ld hl,8000                        ; check if pointer high byte has reached zero, if so, set to 8000
190+  81DE              utilities_randomfromram0:
191+  81DE 22 CF 81         ld (utilities_rampointer),hl
192+  81E1 7E               ld a,(hl)                         ; get a byte from here
193+  81E2 C9               ret
194+  81E3
# file closed: utilities.asm
139   81E3                  include "strings.asm"
# file opened: strings.asm
  1+  81E3              string_score1:
  2+  81E3 04 00 53 43      defb 4,0,'SCORE1',255
  2+  81E7 4F 52 45 31
  2+  81EB FF
  3+  81EC              string_scorenumbers1:
  4+  81EC 04 01 30 30      defb 4,1,'000000',255
  4+  81F0 30 30 30 30
  4+  81F4 FF
  5+  81F5              string_company:
  6+  81F5 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  81F9 4E 54 55 52
  6+  81FD 49 FF
  7+  81FF              string_player1:
  8+  81FF 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  8203 41 59 45 52
  8+  8207 20 31 FF
  9+  820A              string_player2:
 10+  820A 0C 01 50 4C      defb 12,1,'PLAYER 2',255
 10+  820E 41 59 45 52
 10+  8212 20 32 FF
 11+  8215              string_score2:
 12+  8215 16 00 53 43      defb 22,0,'SCORE2',255
 12+  8219 4F 52 45 32
 12+  821D FF
 13+  821E              string_scorenumbers2:
 14+  821E 16 01 30 30      defb 22,1,'000000',255
 14+  8222 30 30 30 30
 14+  8226 FF
 15+  8227              string_titlescreen_copyright:
 16+  8227 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 16+  822B 39 38 32 20
 16+  822F 20 43 45 4E
 16+  8233 54 55 52 49
 16+  8237 20 49 4E 43
 16+  823B FF
 17+  823C
 18+  823C
 19+  823C              string_alttitlescreen_1:
 20+  823C 0C 00 43 52      defb 12,0,'CREDITS 1',255
 20+  8240 45 44 49 54
 20+  8244 53 20 31 FF
 21+  8248              string_alttitlescreen_2:
 22+  8248 00 02 20 20      defb 0,2,'           THE OBJECT',254
 22+  824C 20 20 20 20
 22+  8250 20 20 20 20
 22+  8254 20 54 48 45
 22+  8258 20 4F 42 4A
 22+  825C 45 43 54 FE
 23+  8260 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 23+  8264 20 20 20 20
 23+  8268 20 20 20 20
 23+  826C 4F 46 20 54
 23+  8270 48 49 53 20
 23+  8274 47 41 4D 45
 23+  8278 FE
 24+  8279 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 24+  827D 20 20 20 20
 24+  8281 20 20 20 49
 24+  8285 53 20 54 4F
 24+  8289 20 44 49 47
 24+  828D 20 44 4F 57
 24+  8291 4E FE
 25+  8293 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 25+  8297 20 20 20 20
 25+  829B 20 20 54 4F
 25+  829F 20 54 48 45
 25+  82A3 20 42 4F 54
 25+  82A7 54 4F 4D 20
 25+  82AB 50 49 54 FE
 26+  82AF 00 06 20 20      defb 0,6,'               AND',254
 26+  82B3 20 20 20 20
 26+  82B7 20 20 20 20
 26+  82BB 20 20 20 20
 26+  82BF 20 41 4E 44
 26+  82C3 FE
 27+  82C4 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 27+  82C8 20 20 20 20
 27+  82CC 20 20 43 4F
 27+  82D0 4C 4C 45 43
 27+  82D4 54 20 41 54
 27+  82D8 20 4C 45 41
 27+  82DC 53 54 FE
 28+  82DF 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 28+  82E3 20 20 20 20
 28+  82E7 20 20 20 4F
 28+  82EB 4E 45 20 4C
 28+  82EF 41 52 47 45
 28+  82F3 20 4A 45 57
 28+  82F7 45 4C FE
 29+  82FA 00 09 20 20      defb 0,9,'              THEN',254
 29+  82FE 20 20 20 20
 29+  8302 20 20 20 20
 29+  8306 20 20 20 20
 29+  830A 54 48 45 4E
 29+  830E FE
 30+  830F 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 30+  8313 20 20 20 20
 30+  8317 20 20 20 52
 30+  831B 45 54 55 52
 30+  831F 4E 20 54 4F
 30+  8323 20 53 48 49
 30+  8327 50 FE
 31+  8329 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 31+  832D 20 20 20 20
 31+  8331 20 20 20 54
 31+  8335 48 52 55 20
 31+  8339 55 50 50 45
 31+  833D 52 20 50 49
 31+  8341 54 FF
 32+  8343              string_alttitlescreen_3:
 33+  8343 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 33+  8347 20 20 53 49
 33+  834B 4E 47 4C 45
 33+  834F 20 42 4F 4E
 33+  8353 55 53 20 20
 33+  8357 35 30 30 30
 33+  835B 20 50 4F 49
 33+  835F 4E 54 53 FE
 34+  8363 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 34+  8367 20 20 20 20
 34+  836B 43 4F 4C 4C
 34+  836F 45 43 54 20
 34+  8373 31 20 4C 41
 34+  8377 52 47 45 20
 34+  837B 4A 45 57 45
 34+  837F 4C FE
 35+  8381 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 35+  8385 20 20 20 20
 35+  8389 20 41 4E 44
 35+  838D 20 52 45 54
 35+  8391 55 52 4E 20
 35+  8395 54 4F 20 53
 35+  8399 48 49 50 FE
 36+  839D 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 36+  83A1 20 20 44 4F
 36+  83A5 55 42 4C 45
 36+  83A9 20 42 4F 4E
 36+  83AD 55 53 20 20
 36+  83B1 31 30 30 30
 36+  83B5 30 20 50 4F
 36+  83B9 49 4E 54 53
 36+  83BD FE
 37+  83BE 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 37+  83C2 20 20 43 4F
 37+  83C6 4C 4C 45 43
 37+  83CA 54 20 41 4C
 37+  83CE 4C 20 33 20
 37+  83D2 4C 41 52 47
 37+  83D6 45 20 4A 45
 37+  83DA 57 45 4C 53
 37+  83DE FE
 38+  83DF 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 38+  83E3 20 20 20 20
 38+  83E7 20 4F 52 20
 38+  83EB 20 20 41 4C
 38+  83EF 4C 20 34 20
 38+  83F3 53 4D 41 4C
 38+  83F7 4C 20 4A 45
 38+  83FB 57 45 4C 53
 38+  83FF FE
 39+  8400 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 39+  8404 20 20 54 52
 39+  8408 49 50 4C 45
 39+  840C 20 42 4F 4E
 39+  8410 55 53 20 20
 39+  8414 31 35 30 30
 39+  8418 30 20 50 4F
 39+  841C 49 4E 54 53
 39+  8420 FE
 40+  8421 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 40+  8425 20 20 20 20
 40+  8429 20 43 4F 4C
 40+  842D 4C 45 43 54
 40+  8431 20 41 4C 4C
 40+  8435 20 37 20 4A
 40+  8439 45 57 45 4C
 40+  843D 53 FF
 41+  843F
 42+  843F              string_lifescreen_player:
 43+  843F 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 43+  8443 4C 41 59 45
 43+  8447 52 20 31 20
 43+  844B FF
 44+  844C              string_lifescreen_lives:
 45+  844C 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 45+  8450 4D 45 4E 20
 45+  8454 4C 45 46 54
 45+  8458 FF
 46+  8459              string_lifescreen_lastman:
 47+  8459 0C 03 4C 41      defb 12,3,'LAST MAN',255
 47+  845D 53 54 20 4D
 47+  8461 41 4E FF
 48+  8464
 49+  8464              string_gameoverscreen_gameover:
 50+  8464 0B 06 47 41      defb 11,6,'GAME OVER',255
 50+  8468 4D 45 20 4F
 50+  846C 56 45 52 FF
 51+  8470              string_gameoverscreen_copyright:
 52+  8470 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 52+  8474 39 38 32 20
 52+  8478 43 45 4E 54
 52+  847C 55 52 49 20
 52+  8480 49 4E 43 FF
 53+  8484              string_gameoverscreen_bestscores:
 54+  8484 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 54+  8488 53 54 20 53
 54+  848C 43 4F 52 45
 54+  8490 53 20 54 4F
 54+  8494 44 41 59 FF
 55+  8498              string_gameover_credits:
 56+  8498 0C 01 43 52      defb 12,1,'CREDITS 0',255
 56+  849C 45 44 49 54
 56+  84A0 53 20 30 FF
 57+  84A4
 58+  84A4              string_highscore_congratulations:
 59+  84A4 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 59+  84A8 4E 47 52 41
 59+  84AC 54 55 4C 41
 59+  84B0 54 49 4F 4E
 59+  84B4 53 FF
 60+  84B6              string_highscore_player1:
 61+  84B6 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 61+  84BA 41 59 45 52
 61+  84BE 20 31 FF
 62+  84C1              string_highscore_player2:
 63+  84C1 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 63+  84C5 41 59 45 52
 63+  84C9 20 32 FF
 64+  84CC              string_highscore_youhaveearned:
 65+  84CC 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 65+  84D0 55 20 48 41
 65+  84D4 56 45 20 45
 65+  84D8 41 52 4E 45
 65+  84DC 44 FF
 66+  84DE              string_highscore_place1:
 67+  84DE 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 67+  84E2 45 20 47 52
 67+  84E6 45 41 54 45
 67+  84EA 53 54 20 53
 67+  84EE 43 4F 52 45
 67+  84F2 FF
 68+  84F3              string_highscore_place2:
 69+  84F3 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 69+  84F7 45 20 32 4E
 69+  84FB 44 20 42 45
 69+  84FF 53 54 20 53
 69+  8503 43 4F 52 45
 69+  8507 FF
 70+  8508              string_highscore_place3:
 71+  8508 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 71+  850C 45 20 33 52
 71+  8510 44 20 42 45
 71+  8514 53 54 20 53
 71+  8518 43 4F 52 45
 71+  851C FF
 72+  851D              string_highscore_pleaseenter
 73+  851D 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 73+  8521 43 4F 52 44
 73+  8525 20 59 4F 55
 73+  8529 52 20 49 4E
 73+  852D 49 54 49 41
 73+  8531 4C 53 20 42
 73+  8535 45 4C 4F 57
 73+  8539 FF
 74+  853A
 75+  853A              string_endlevel_youhaveearned:
 76+  853A 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 76+  853E 55 20 48 41
 76+  8542 56 45 20 45
 76+  8546 41 52 4E 45
 76+  854A 44 FF
 77+  854C              string_endlevel_bonus1:
 78+  854C 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 78+  8550 4E 47 4C 45
 78+  8554 20 42 4F 4E
 78+  8558 55 53 FF
 79+  855B              string_endlevel_bonus2:
 80+  855B 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 80+  855F 55 42 4C 45
 80+  8563 20 42 4F 4E
 80+  8567 55 53 FF
 81+  856A              string_endlevel_bonus3:
 82+  856A 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 82+  856E 49 50 4C 45
 82+  8572 20 42 4F 4E
 82+  8576 55 53 FF
 83+  8579              string_endlevel_points1:
 84+  8579 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 84+  857D 30 30 20 50
 84+  8581 4F 49 4E 54
 84+  8585 53 FF
 85+  8587              string_endlevel_points2:
 86+  8587 09 0F 31 30      defb 9,15,'10000 POINTS',255
 86+  858B 30 30 30 20
 86+  858F 50 4F 49 4E
 86+  8593 54 53 FF
 87+  8596              string_endlevel_points3:
 88+  8596 09 0F 31 35      defb 9,15,'15000 POINTS',255
 88+  859A 30 30 30 20
 88+  859E 50 4F 49 4E
 88+  85A2 54 53 FF
 89+  85A5              string_endlevel_anothergo:
 90+  85A5 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 90+  85A9 56 45 20 41
 90+  85AD 4E 4F 54 48
 90+  85B1 45 52 20 47
 90+  85B5 4F FF
 91+  85B7
 92+  85B7              string_zonk:
 93+  85B7 00 00 5A 4F      defb 0,0,'ZONK!!',255
 93+  85BB 4E 4B 21 21
 93+  85BF FF
 94+  85C0
 95+  85C0
 96+  85C0              string_options_title:
 97+  85C0 0D 03 54 48      defb 13,3,'THE PIT',255
 97+  85C4 45 20 50 49
 97+  85C8 54 FF
 98+  85CA              string_options_1player:
 99+  85CA 09 06 31 2E      defb 9,6,'1. ONE PLAYER',255
 99+  85CE 20 4F 4E 45
 99+  85D2 20 50 4C 41
 99+  85D6 59 45 52 FF
100+  85DA              string_options_2player:
101+  85DA 09 07 32 2E      defb 9,7,'2. TWO PLAYER',255
101+  85DE 20 54 57 4F
101+  85E2 20 50 4C 41
101+  85E6 59 45 52 FF
102+  85EA              string_options_keyboard:
103+  85EA 09 08 33 2E      defb 9,8,'3. KEYS (QAOPSp)',255
103+  85EE 20 4B 45 59
103+  85F2 53 20 28 51
103+  85F6 41 4F 50 53
103+  85FA 70 29 FF
104+  85FD              string_options_joystick:
105+  85FD 09 09 34 2E      defb 9,9,'4. KEMPSTON',255
105+  8601 20 4B 45 4D
105+  8605 50 53 54 4F
105+  8609 4E FF
106+  860B              string_options_start:
107+  860B 09 0A 35 2E      defb 9,10,'5. START',255
107+  860F 20 53 54 41
107+  8613 52 54 FF
108+  8616              string_options_vanity:
109+  8616 08 16 53 70      defb 8,22,'Spectrum Conversion',254
109+  861A 65 63 74 72
109+  861E 75 6D 20 43
109+  8622 6F 6E 76 65
109+  8626 72 73 69 6F
109+  862A 6E FE
110+  862C 07 17 62 79      defb 7,23,'by Dave Tansley, 2020',255
110+  8630 20 44 61 76
110+  8634 65 20 54 61
110+  8638 6E 73 6C 65
110+  863C 79 2C 20 32
110+  8640 30 32 30 FF
111+  8644
112+  8644              ;
113+  8644              ; Prints specified string
114+  8644              ; Inputs:
115+  8644              ; de: pointer to string
116+  8644              ; bc: length of string
117+  8644              ;
118+  8644              ; Print String Data
119+  8644              ; First two bytes of string contain X and Y char position, then the string
120+  8644              ; Individual strings are terminated with 0xFE
121+  8644              ; End of data is terminated with 0xFF
122+  8644              ; HL: Address of string
123+  8644              ;
124+  8644 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
125+  8645 23                                   INC HL                          ; Increase HL to the next memory location
126+  8646 56                                   LD D,(HL)                       ; Fetch the Y coordinate
127+  8647 23                                   INC HL                          ; Increase HL to the next memory location
128+  8648 CD 5B 86                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
129+  864B 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
130+  864C 23                                   INC HL                          ; Increase HL to the next character
131+  864D FE FE                                CP 0xFE                         ; Compare with 0xFE
132+  864F 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
133+  8651 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
134+  8652 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
135+  8653 CD 6B 86                             CALL Print_Char                 ; Print the character
136+  8656 E1                                   POP HL                          ; Retrieve HL back off the stack
137+  8657 1C                                   INC E                           ; Go to the next screen address
138+  8658 18 F1                                JR string_print_0               ; Loop back to print next character
139+  865A C9                                   RET
140+  865B
141+  865B              ; Get screen address
142+  865B              ; D = Y character position
143+  865B              ; E = X character position
144+  865B              ; Returns address in DE
145+  865B              ;
146+  865B 7A           string_getcharaddress:       LD A,D
147+  865C E6 07                                AND %00000111
148+  865E 1F                                   RRA
149+  865F 1F                                   RRA
150+  8660 1F                                   RRA
151+  8661 1F                                   RRA
152+  8662 B3                                   OR E
153+  8663 5F                                   LD E,A
154+  8664 7A                                   LD A,D
155+  8665 E6 18                                AND %00011000
156+  8667 F6 40                                OR %01000000
157+  8669 57                                   LD D,A
158+  866A C9                                   RET                             ; Returns screen address in DE
159+  866B
160+  866B              ; Print a single character out
161+  866B              ; A:  Character to print
162+  866B              ; DE: Screen address to print character at
163+  866B              ;
164+  866B 2A 36 5C     Print_Char:             LD HL,(23606)                    ; Address of character set table in ROM
165+  866E 06 00                                LD B,0                          ; Set BC to A
166+  8670 4F                                   LD C,A
167+  8671 E6 FF                                AND 0xFF                        ; Clear the carry bit
168+  8673 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
169+  8675 CB 10                                RL B
170+  8677 CB 11                                RL C
171+  8679 CB 10                                RL B
172+  867B CB 11                                RL C
173+  867D CB 10                                RL B
174+  867F 09                                   ADD HL,BC                       ; Get the character address in HL
175+  8680 0E 08                                LD C,8                          ; Loop counter
176+  8682 D5                                   PUSH DE
177+  8683 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
178+  8684 12                                   LD (DE),A                       ; Stick A onto the screen
179+  8685 14                                   INC D                           ; Goto next line on screen
180+  8686 23                                   INC HL                           ; Goto next byte of character
181+  8687 0D                                   DEC C                           ; Decrease the loop counter
182+  8688 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
183+  868A D1                                   POP DE
184+  868B C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
140   868C                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  868C              buffer_buffer:
  2+  868C 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A38C
  4+  A38C              buffer_attr_buffer:
  5+  A38C 00 00 00...      defs 928                    ; attrs buffer area
  6+  A72C
  7+  A72C              buffer_tmp:
  8+  A72C 00 00            defb 0,0                    ; temp area
  9+  A72E
 10+  A72E              ;
 11+  A72E              ; If this is set to one, three lines will be refreshed for the screen coord redraw
 12+  A72E              ; This is used when digging to make sure that the above dug block gets redrawn
 13+  A72E              ;
 14+  A72E              buffer_threelinerefresh:
 15+  A72E 00               defb 0
 16+  A72F
 17+  A72F              ;
 18+  A72F              ; This list stores lines to be updated by the buffer.
 19+  A72F              ; This is done by half line. Lines are encded with.
 20+  A72F              ; 00hlllll
 21+  A72F              ; Where h is the half of the screen (0 or 1), lllll is the line number
 22+  A72F              buffer_updatedlines:
 23+  A72F FF FF FF...      defs 21,255
 24+  A744
 25+  A744              buffer_updateall:
 26+  A744 00               defb 0
 27+  A745
 28+  A745              ;
 29+  A745              ; Stores a line number in the update list
 30+  A745              ; Inputs:
 31+  A745              ; a - row number
 32+  A745              buffer_marklineforupdate:
 33+  A745 FE 15            cp 21
 34+  A747 D0               ret nc                          ; dont store lines that we shouldn't draw
 35+  A748 5F               ld e,a                          ; store in e
 36+  A749 ED 4B 53 AC      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 37+  A74D 79               ld a,c                          ; get the horiz coord
 38+  A74E FE 0F            cp 15
 39+  A750 CA 67 A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 40+  A753 FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 41+  A755 CA 67 A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 42+  A758 DA 63 A7         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 43+  A75B 78               ld a,b                          ; get the vertical
 44+  A75C 3E 20            ld a,32                         ; set the 6th bit by adding 32
 45+  A75E 83               add a,e
 46+  A75F 5F               ld e,a                          ; store this value
 47+  A760 C3 6E A7         jp buffer_marklineforupdate2
 48+  A763              buffer_marklineforupdate4:
 49+  A763 78               ld a,b
 50+  A764 C3 6E A7         jp buffer_marklineforupdate2    ; just get the vertical
 51+  A767              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 52+  A767 CD 72 A7         call buffer_storelineforupdate  ; call store update for e
 53+  A76A 3E 20            ld a,32
 54+  A76C 83               add a,e
 55+  A76D 5F               ld e,a
 56+  A76E              buffer_marklineforupdate2:
 57+  A76E CD 72 A7         call buffer_storelineforupdate  ; call store update for e
 58+  A771 C9               ret
 59+  A772
 60+  A772
 61+  A772              ;
 62+  A772              ; Stores the calculated line and half if needed
 63+  A772              ; Inputs:
 64+  A772              ; e - half/row
 65+  A772              ;
 66+  A772              buffer_storelineforupdate:
 67+  A772 06 15            ld b,21
 68+  A774 21 2F A7         ld hl,buffer_updatedlines
 69+  A777              buffer_storelineforupdate0:
 70+  A777 7E               ld a,(hl)                       ; get the line stored in updated lines
 71+  A778 BB               cp e                            ; is this the same as the row number passed in?
 72+  A779 C8               ret z                           ; if so, don't need to do anything
 73+  A77A FE FF            cp 255                          ; is this 255, ie the end of the buffer
 74+  A77C C2 81 A7         jp nz,buffer_storelineforupdate1 ; if not, move to next
 75+  A77F 73               ld (hl),e
 76+  A780 C9               ret
 77+  A781              buffer_storelineforupdate1:
 78+  A781 23               inc hl
 79+  A782 10 F3            djnz buffer_storelineforupdate0
 80+  A784 C9               ret
 81+  A785
 82+  A785              ;
 83+  A785              ; Zeroes the updated lines list
 84+  A785              ;
 85+  A785              buffer_clearlist:
 86+  A785 06 15            ld b,21
 87+  A787 21 2F A7         ld hl,buffer_updatedlines
 88+  A78A              buffer_clearlist0:
 89+  A78A 36 FF            ld (hl),255
 90+  A78C 23               inc hl
 91+  A78D 10 FB            djnz buffer_clearlist0
 92+  A78F C9               ret
 93+  A790
 94+  A790              ;
 95+  A790              ; Which half are we displaying? 0 left 1 right
 96+  A790              ;
 97+  A790              buffer_bufferhalf:
 98+  A790 00               defb 0
 99+  A791
100+  A791              ;
101+  A791              ; Copies the buffer to the screen. Use stack.
102+  A791              ; Inputs:
103+  A791              ; hl - half/line number to display - 0 is first half, 0 is first line
104+  A791              ;
105+  A791              buffer_bufferlinetoscreen:
106+  A791 7C               ld a,h
107+  A792 32 90 A7         ld (buffer_bufferhalf),a        ; store the half
108+  A795 7D               ld a,l
109+  A796 4F               ld c,a                          ; store a
110+  A797 ED 5B F7 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
111+  A79B 83               add a,e                       ; add the row number
112+  A79C 11 00 01         ld de,256
113+  A79F CD 03 81         call utilities_multiply
114+  A7A2 54 5D            ld de,hl
115+  A7A4 21 8C 86         ld hl,buffer_buffer
116+  A7A7 19               add hl,de                   ; add the offset
117+  A7A8 79               ld a,c                      ; get original row back
118+  A7A9 ED 73 1C A8      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
119+  A7AD D9               exx
120+  A7AE 0E 00            ld c,0                      ; zero horizontal
121+  A7B0 47               ld b,a                      ; load the row number into vertical coord
122+  A7B1 04               inc b
123+  A7B2 04               inc b                       ; move forward 2 to allow for scores
124+  A7B3 CD EF A9         call screen_getcelladdress  ; get the memory into de
125+  A7B6 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
126+  A7B9 19               add hl,de
127+  A7BA 3A 90 A7         ld a,(buffer_bufferhalf)    ; get the half
128+  A7BD FE 01            cp 1
129+  A7BF CA EC A7         jp z,buffer_bufferlinetoscreen4
130+  A7C2              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
131+  A7C2 D9               exx                         ; hl is now buffer
132+  A7C3 23               inc hl
133+  A7C4 23               inc hl                      ; move hl forward 2 to skip first two blocks
134+  A7C5 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
135+  A7C6 F1               pop af
136+  A7C7 C1               pop bc
137+  A7C8 D1               pop de
138+  A7C9 DD E1            pop ix
139+  A7CB D9               exx                         ; hl is now screen
140+  A7CC 08               ex af,af'
141+  A7CD F1               pop af
142+  A7CE C1               pop bc
143+  A7CF D1               pop de
144+  A7D0 F9               ld sp,hl                    ; sp pointing at screen
145+  A7D1 D5               push de
146+  A7D2 C5               push bc
147+  A7D3 F5               push af
148+  A7D4 08               ex af,af'
149+  A7D5 D9               exx                         ; hl is now buffer
150+  A7D6 DD E5            push ix
151+  A7D8 D5               push de
152+  A7D9 C5               push bc
153+  A7DA F5               push af
154+  A7DB 11 1E 00         ld de,30                    ; add thirty to get to next line
155+  A7DE 19               add hl,de
156+  A7DF F9               ld sp,hl                    ; sp pointing at buffer
157+  A7E0 D9               exx                         ; hl is now screen
158+  A7E1 08               ex af,af'
159+  A7E2 24               inc h
160+  A7E3 7C               ld a,h
161+  A7E4 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
162+  A7E6 C2 C2 A7         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
163+  A7E9              buffer_bufferlinetoscreen1:
164+  A7E9 C3 1B A8         jp buffer_bufferlinetoscreen3
165+  A7EC              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
166+  A7EC D9               exx                         ; hl is buffer
167+  A7ED 11 10 00         ld de,16
168+  A7F0 19               add hl,de                   ; move halfway across
169+  A7F1 D9               exx                         ; hl is screen
170+  A7F2 11 0E 00         ld de,14
171+  A7F5 19               add hl,de
172+  A7F6              buffer_bufferlinetoscreen2:
173+  A7F6 D9               exx                         ; hl is now buffer
174+  A7F7 F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
175+  A7F8 F1               pop af
176+  A7F9 C1               pop bc
177+  A7FA D1               pop de
178+  A7FB DD E1            pop ix
179+  A7FD D9               exx                         ; hl is now screen
180+  A7FE 08               ex af,af'
181+  A7FF F1               pop af
182+  A800 C1               pop bc
183+  A801 D1               pop de
184+  A802 F9               ld sp,hl                    ; sp pointing at screen
185+  A803 D5               push de
186+  A804 C5               push bc
187+  A805 F5               push af
188+  A806 08               ex af,af'
189+  A807 D9               exx                         ; hl is now buffer
190+  A808 DD E5            push ix
191+  A80A D5               push de
192+  A80B C5               push bc
193+  A80C F5               push af
194+  A80D 11 20 00         ld de,32                    ; add thirty two to get to next line
195+  A810 19               add hl,de
196+  A811 F9               ld sp,hl                    ; sp pointing at buffer
197+  A812 D9               exx                         ; hl is now screen
198+  A813 08               ex af,af'
199+  A814 24               inc h
200+  A815 7C               ld a,h
201+  A816 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
202+  A818 C2 F6 A7         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
203+  A81B              buffer_bufferlinetoscreen3:
204+  A81B 31 00 00         ld sp,0
205+  A81E D9               exx
206+  A81F C9               ret
207+  A820
208+  A820              ;
209+  A820              ; Copies the buffer to the screen for updated lines. Use stack.
210+  A820              ; Inputs: none
211+  A820              ;
212+  A820              buffer_buffertoscreen:
213+  A820 3A 44 A7         ld a,(buffer_updateall)      ; get the all update flag
214+  A823 FE 00            cp 0
215+  A825 CA 31 A8         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
216+  A828 CD 61 A8         call buffer_allbuffertoscreen ; otherwise, draw whole screen
217+  A82B 21 44 A7         ld hl,buffer_updateall
218+  A82E 36 00            ld (hl),0                    ; reset flag
219+  A830 C9               ret
220+  A831              buffer_buffertoscreen2:
221+  A831 06 15            ld b,21
222+  A833 FD 21 2F A7      ld iy,buffer_updatedlines    ; the location of the updated lines
223+  A837              buffer_buffertoscreen0:
224+  A837 FD 7E 00         ld a,(iy)
225+  A83A FE FF            cp 255
226+  A83C CA 60 A8         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
227+  A83F 6F               ld l,a
228+  A840 26 00            ld h,0
229+  A842 E6 20            and 32                      ; and with 32 to see if 6th bit is set
230+  A844 FE 20            cp 32                       ; if so, second half of screen
231+  A846 C2 51 A8         jp nz,buffer_buffertoscreen3
232+  A849 26 01            ld h,1                      ; store half in h
233+  A84B FD 7E 00         ld a,(iy)
234+  A84E D6 20            sub 32                      ; remove 32
235+  A850 6F               ld l,a                      ; stor in line number
236+  A851              buffer_buffertoscreen3:
237+  A851 C5               push bc
238+  A852 FD E5            push iy
239+  A854 F3               di
240+  A855 CD 91 A7         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
241+  A858 FB               ei
242+  A859 FD E1            pop iy
243+  A85B C1               pop bc
244+  A85C FD 23            inc iy
245+  A85E 10 D7            djnz buffer_buffertoscreen0
246+  A860              buffer_buffertoscreen1:
247+  A860                  ;call buffer_buffertoattrsfast
248+  A860 C9               ret
249+  A861
250+  A861              ;
251+  A861              ; Copies the buffer to the screen. Use stack.
252+  A861              ; Inputs: none
253+  A861              ;
254+  A861              buffer_allbuffertoscreen:
255+  A861 06 15            ld b,21
256+  A863 3E 00            ld a,0
257+  A865              buffer_allbuffertoscreen0:
258+  A865 C5               push bc
259+  A866 F5               push af
260+  A867 F3               di
261+  A868 26 00            ld h,0
262+  A86A 6F               ld l,a
263+  A86B CD 91 A7         call buffer_bufferlinetoscreen
264+  A86E FB               ei
265+  A86F F1               pop af
266+  A870 F5               push af
267+  A871 F3               di
268+  A872 26 01            ld h,1
269+  A874 6F               ld l,a
270+  A875 CD 91 A7         call buffer_bufferlinetoscreen
271+  A878 FB               ei
272+  A879 F1               pop af
273+  A87A C1               pop bc
274+  A87B 3C               inc a
275+  A87C 10 E7            djnz buffer_allbuffertoscreen0
276+  A87E F3               di
277+  A87F CD 84 A8         call buffer_buffertoattrsfast
278+  A882 FB               ei
279+  A883 C9               ret
280+  A884
281+  A884              ;
282+  A884              ; Copies the attrs buffer to screen with the stack
283+  A884              ;
284+  A884              buffer_buffertoattrsfast:
285+  A884 ED 73 F3 A8      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
286+  A888 3A F7 A8         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
287+  A88B 11 20 00         ld de,32
288+  A88E CD 03 81         call utilities_multiply
289+  A891 54 5D            ld de,hl
290+  A893 21 8C A3         ld hl,buffer_attr_buffer
291+  A896 19               add hl,de                       ; add the offset, start of attr buffer now in hl
292+  A897 D9               exx
293+  A898 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
294+  A89B FD 21 2C A7      ld iy,buffer_tmp
295+  A89F FD 36 00 15      ld (iy),21              ; number of times to loop
296+  A8A3              buffer_buffertoattrsfast0:
297+  A8A3 D9               exx                         ; hl is now buffer
298+  A8A4 23               inc hl
299+  A8A5 23               inc hl                      ; move hl forward 2 to skip first two blocks
300+  A8A6 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
301+  A8A7 F1               pop af
302+  A8A8 C1               pop bc
303+  A8A9 D1               pop de
304+  A8AA DD E1            pop ix
305+  A8AC D9               exx                         ; hl is now screen
306+  A8AD 08               ex af,af'
307+  A8AE F1               pop af
308+  A8AF C1               pop bc
309+  A8B0 D1               pop de
310+  A8B1 F9               ld sp,hl                    ; sp pointing at screen
311+  A8B2 D5               push de
312+  A8B3 C5               push bc
313+  A8B4 F5               push af
314+  A8B5 08               ex af,af'
315+  A8B6 D9               exx                         ; hl is now buffer
316+  A8B7 DD E5            push ix
317+  A8B9 D5               push de
318+  A8BA C5               push bc
319+  A8BB F5               push af
320+  A8BC 1E 0E            ld e,14                    ; do another fourteen for right hand side
321+  A8BE 16 00            ld d,0
322+  A8C0 19               add hl,de
323+  A8C1 F9               ld sp,hl                    ; sp pointing at buffer
324+  A8C2 F1               pop af
325+  A8C3 C1               pop bc
326+  A8C4 D1               pop de
327+  A8C5 DD E1            pop ix
328+  A8C7 D9               exx                         ; hl is now screen
329+  A8C8 08               ex af,af'
330+  A8C9 1E 0E            ld e,14
331+  A8CB 16 00            ld d,0
332+  A8CD 19               add hl,de
333+  A8CE F1               pop af
334+  A8CF C1               pop bc
335+  A8D0 D1               pop de
336+  A8D1 F9               ld sp,hl                    ; sp pointing at screen
337+  A8D2 D5               push de
338+  A8D3 C5               push bc
339+  A8D4 F5               push af
340+  A8D5 08               ex af,af'
341+  A8D6 D9               exx                         ; hl is now buffer
342+  A8D7 DD E5            push ix
343+  A8D9 D5               push de
344+  A8DA C5               push bc
345+  A8DB F5               push af
346+  A8DC 1E 10            ld e,16
347+  A8DE 16 00            ld d,0
348+  A8E0 19               add hl,de
349+  A8E1 D9               exx                         ; hl is now screen
350+  A8E2 11 12 00         ld de,18
351+  A8E5 19               add hl,de
352+  A8E6 FD 7E 00         ld a,(iy)
353+  A8E9 3D               dec a
354+  A8EA FE 00            cp 0
355+  A8EC FD 77 00         ld (iy),a
356+  A8EF C2 A3 A8         jp nz,buffer_buffertoattrsfast0 ; do another row
357+  A8F2              buffer_buffertoattrsfast1:
358+  A8F2 31 00 00         ld sp,0
359+  A8F5 D9               exx
360+  A8F6 C9               ret
# file closed: screen/buffer.asm
141   A8F7                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A8F7              screen_offset:
  2+  A8F7 00               defb 0                      ; offset from top of screen in lines
  3+  A8F8
  4+  A8F8              screen_tmp:
  5+  A8F8 00 00            defb 0,0                      ; temporary memory
  6+  A8FA
  7+  A8FA              screen_setscorecolours:
  8+  A8FA 21 08 B9         ld hl,score_colours
  9+  A8FD 11 00 58         ld de,22528                     ; attrs here
 10+  A900 01 40 00         ld bc,64
 11+  A903 ED B0            ldir
 12+  A905 C9               ret
 13+  A906
 14+  A906              screen_sethighscorecolours:
 15+  A906 21 48 B9         ld hl,high_score_colours
 16+  A909 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A90C 01 20 00         ld bc,32
 18+  A90F ED B0            ldir
 19+  A911 C9               ret
 20+  A912
 21+  A912              ; Draw the screen
 22+  A912              ; Inputs:
 23+  A912              ; none
 24+  A912              ; Notes:
 25+  A912              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A912              screen_draw:
 27+  A912                  ;call clear_screen
 28+  A912 0E 00            ld c,0                      ; horiz
 29+  A914 06 00            ld b,0                      ; vert, 0 at top
 30+  A916 DD 21 E3 B2      ld ix,level_layout               ; point ix at level data
 31+  A91A FD 21 8C A3      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A91E              screen_draw0:
 33+  A91E DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A921 C5               push bc                     ; store bc, contains loop count
 35+  A922 CD DD AA         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A925 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A926 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A929 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A92C CD A4 AA         call screen_getblock        ; get the block data into hl
 40+  A92F CD 81 AA         call screen_showchar        ; show this character here
 41+  A932 C1               pop bc                      ; get the loop counter back
 42+  A933 DD 23            inc ix                      ; increment level location
 43+  A935 FD 23            inc iy                      ; increment attr location
 44+  A937 0C               inc c                       ; increment horiz
 45+  A938 79               ld a,c
 46+  A939 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A93B C2 1E A9         jp nz,screen_draw0          ; if not, loop
 48+  A93E 0E 00            ld c,0                      ; if so, reset horiz
 49+  A940 04               inc b                       ; increment vertical
 50+  A941 78               ld a,b
 51+  A942 FE 1D            cp 29                       ; check if at bottom
 52+  A944 C2 1E A9         jp nz,screen_draw0          ; if not, loop
 53+  A947 21 F8 A8         ld hl, screen_tmp
 54+  A94A 36 09            ld (hl),9                   ; load the block number into memory
 55+  A94C DD 2A 2D C5      ld ix,(game_current_rocks)  ; current rock memory
 56+  A950 CD BF A9         call screen_initobjects     ; draw rocks
 57+  A953 21 F8 A8         ld hl, screen_tmp
 58+  A956 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A958 DD 21 6A B8      ld ix,level_missiles       ; missile memory
 60+  A95C CD BF A9         call screen_initobjects     ; draw missiles
 61+  A95F 21 F8 A8         ld hl, screen_tmp
 62+  A962 36 08            ld (hl),08                  ; load the block number into memory
 63+  A964 DD 21 E3 B8      ld ix,level_diamonds       ; diamond memory
 64+  A968 CD BF A9         call screen_initobjects     ; draw diamonds
 65+  A96B 21 F8 A8         ld hl, screen_tmp
 66+  A96E 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A970 DD 21 F3 B8      ld ix,level_gems           ; gems memory
 68+  A974 CD BF A9         call screen_initobjects     ; draw gems
 69+  A977 CD 7E A9         call screen_setuptext       ; draws text on the screen
 70+  A97A CD D9 CD         call scores_printscores     ; print the current scores
 71+  A97D C9               ret
 72+  A97E
 73+  A97E              ;
 74+  A97E              ; Sets up text on the screen
 75+  A97E              ;
 76+  A97E              screen_setuptext:
 77+  A97E CD 35 CE         call scores_showtable
 78+  A981 CD 06 A9         call screen_sethighscorecolours
 79+  A984 21 E3 81         ld hl, string_score1
 80+  A987 CD 44 86         call string_print
 81+  A98A 21 EC 81         ld hl, string_scorenumbers1
 82+  A98D CD 44 86         call string_print
 83+  A990 21 F5 81         ld hl, string_company
 84+  A993 CD 44 86         call string_print
 85+  A996 21 15 82         ld hl, string_score2
 86+  A999 CD 44 86         call string_print
 87+  A99C 21 1E 82         ld hl, string_scorenumbers2
 88+  A99F CD 44 86         call string_print
 89+  A9A2 3A 29 C5         ld a,(game_currentplayer)
 90+  A9A5 FE 01            cp 1
 91+  A9A7 C2 B0 A9         jp nz,screen_setuptext0
 92+  A9AA 21 FF 81         ld hl, string_player1
 93+  A9AD C3 B3 A9         jp screen_setuptext1
 94+  A9B0              screen_setuptext0:
 95+  A9B0 21 0A 82         ld hl, string_player2
 96+  A9B3              screen_setuptext1:
 97+  A9B3 CD 44 86         call string_print
 98+  A9B6 CD FA A8         call screen_setscorecolours
 99+  A9B9 C9               ret
100+  A9BA
101+  A9BA              ;
102+  A9BA              ; Sets a line of colours
103+  A9BA              ; Inputs:
104+  A9BA              ; a - colour to set
105+  A9BA              ; b - number to set
106+  A9BA              ; de - start memory location
107+  A9BA              ;
108+  A9BA              screen_setcolours:
109+  A9BA 12               ld (de),a
110+  A9BB 13               inc de
111+  A9BC 10 FC            djnz screen_setcolours
112+  A9BE C9               ret
113+  A9BF
114+  A9BF              ;
115+  A9BF              ; Draw initial object positions
116+  A9BF              ; Inputs:
117+  A9BF              ; ix - memory location of objects
118+  A9BF              ; a - graphic
119+  A9BF              screen_initobjects:
120+  A9BF DD 4E 00         ld c,(ix)                   ; get the horiz coord
121+  A9C2 79               ld a,c
122+  A9C3 FE FF            cp 255
123+  A9C5 CA EE A9         jp z,screen_initobjects2
124+  A9C8 DD 23            inc ix                      ; move to next
125+  A9CA DD 46 00         ld b,(ix)                   ; get the vert coord
126+  A9CD DD 23            inc ix
127+  A9CF CD 00 AA         call screen_getcellattradress ; get the memory address of b,c attr into de
128+  A9D2 D5               push de
129+  A9D3 3A F8 A8         ld a,(screen_tmp)                  ; get the block number back
130+  A9D6 CD DD AA         call screen_getattr         ; get the memory location for this cell's attr into hl
131+  A9D9 D1               pop de
132+  A9DA 7E               ld a,(hl)                   ; get the attr value at the address
133+  A9DB 12               ld (de),a                   ; load the attr into memory
134+  A9DC 3A F8 A8         ld a,(screen_tmp)                  ; get the block number back
135+  A9DF CD A4 AA         call screen_getblock        ; get the block data into hl
136+  A9E2 CD 81 AA         call screen_showchar        ; show this character here
137+  A9E5
138+  A9E5              screen_initobjects1:
139+  A9E5 DD 23            inc ix                      ; move past state
140+  A9E7 DD 23            inc ix
141+  A9E9 DD 23            inc ix                      ; move past mem
142+  A9EB C3 BF A9         jp screen_initobjects
143+  A9EE              screen_initobjects2:
144+  A9EE C9               ret
145+  A9EF
146+  A9EF
147+  A9EF              ;
148+  A9EF              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
149+  A9EF              ; Inputs:
150+  A9EF              ; bc: coords
151+  A9EF              ; Outputs:
152+  A9EF              ; de: memory location
153+  A9EF              ;
154+  A9EF              screen_getcelladdress:
155+  A9EF 78               ld a,b      ; vertical position.
156+  A9F0 E6 18            and 24      ; which segment, 0, 1 or 2?
157+  A9F2 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
158+  A9F4 57               ld d,a      ; this is our high byte.
159+  A9F5 78               ld a,b      ; what was that vertical position again?
160+  A9F6 E6 07            and 7       ; which row within segment?
161+  A9F8 0F               rrca        ; multiply row by 32.
162+  A9F9 0F               rrca
163+  A9FA 0F               rrca
164+  A9FB 5F               ld e,a      ; low byte.
165+  A9FC 79               ld a,c      ; add on y coordinate.
166+  A9FD 83               add a,e     ; mix with low byte.
167+  A9FE 5F               ld e,a      ; address of screen position in de.
168+  A9FF C9               ret
169+  AA00
170+  AA00              ;
171+  AA00              ; Calculate buffer address of attribute for character at (b, c).
172+  AA00              ; Inputs:
173+  AA00              ; bc: coords
174+  AA00              ; Outputs:
175+  AA00              ; de: memory location
176+  AA00              ;
177+  AA00              screen_getcellattradress:
178+  AA00 11 8C A3         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
179+  AA03 69               ld l,c      ; x position.
180+  AA04 26 00            ld h,0      ; 0 h
181+  AA06 19               add hl,de
182+  AA07 54 5D            ld de,hl    ; horiz done
183+  AA09 78               ld a,b      ; do vert
184+  AA0A D5               push de
185+  AA0B C5               push bc
186+  AA0C 11 20 00         ld de,32
187+  AA0F CD 03 81         call utilities_multiply
188+  AA12 C1               pop bc
189+  AA13 D1               pop de
190+  AA14 19               add hl,de
191+  AA15 54 5D            ld de,hl    ; vert done
192+  AA17 C9               ret
193+  AA18
194+  AA18              ;
195+  AA18              ; Calculate buffer address offset of attribute for character at (b, c).
196+  AA18              ; Inputs:
197+  AA18              ; bc: coords
198+  AA18              ; Outputs:
199+  AA18              ; de: memory location
200+  AA18              ;
201+  AA18              screen_getcellattroffset:
202+  AA18 69               ld l,c      ; x position.
203+  AA19 26 00            ld h,0      ; 0 h
204+  AA1B 54 5D            ld de,hl    ; horiz done
205+  AA1D 78               ld a,b      ; do vert
206+  AA1E D5               push de
207+  AA1F C5               push bc
208+  AA20 11 20 00         ld de,32
209+  AA23 CD 03 81         call utilities_multiply
210+  AA26 C1               pop bc
211+  AA27 D1               pop de
212+  AA28 19               add hl,de
213+  AA29 54 5D            ld de,hl    ; vert done
214+  AA2B C9               ret
215+  AA2C
216+  AA2C              ;
217+  AA2C              ; Calculate buffer address of attribute for character at (b, c).
218+  AA2C              ; Inputs:
219+  AA2C              ; bc: coords
220+  AA2C              ; Outputs:
221+  AA2C              ; de: memory location
222+  AA2C              ;
223+  AA2C              screen_getscreenattradress:
224+  AA2C 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
225+  AA2F 69               ld l,c      ; x position.
226+  AA30 26 00            ld h,0      ; 0 h
227+  AA32 19               add hl,de
228+  AA33 54 5D            ld de,hl    ; horiz done
229+  AA35 78               ld a,b      ; do vert
230+  AA36 D5               push de
231+  AA37 C5               push bc
232+  AA38 11 20 00         ld de,32
233+  AA3B CD 03 81         call utilities_multiply
234+  AA3E C1               pop bc
235+  AA3F D1               pop de
236+  AA40 19               add hl,de
237+  AA41 54 5D            ld de,hl    ; vert done
238+  AA43 C9               ret
239+  AA44
240+  AA44              ;
241+  AA44              ; Gets the attr memory location for a screen coord
242+  AA44              ; Will overwrite bc
243+  AA44              ; Inputs:
244+  AA44              ; bc - screen coords
245+  AA44              ; Outputs:
246+  AA44              ; de - memory location
247+  AA44              ; bc - character coords
248+  AA44              ;
249+  AA44              screen_getattraddressfromscreencoords:
250+  AA44 78               ld a,b                          ; get the player block coords of current block
251+  AA45 E6 F8            and 248                         ; find closest multiple of eight
252+  AA47 0F               rrca
253+  AA48 0F               rrca
254+  AA49 0F               rrca                ; divide by 8
255+  AA4A 47               ld b,a
256+  AA4B 79               ld a,c
257+  AA4C 48               ld c,b                         ; swap b and c
258+  AA4D E6 F8            and 248
259+  AA4F 0F               rrca
260+  AA50 0F               rrca
261+  AA51 0F               rrca                ; divide by 8
262+  AA52 47               ld b,a
263+  AA53 CD 00 AA         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
264+  AA56 C9               ret
265+  AA57
266+  AA57
267+  AA57              ; Gets the nearest cell coords for a screen coord
268+  AA57              ; Will overwrite bc
269+  AA57              ; Inputs:
270+  AA57              ; bc - screen coords
271+  AA57              ; Outputs:
272+  AA57              ; bc - character coords
273+  AA57              ;
274+  AA57              screen_getcharcoordsfromscreencoords:
275+  AA57 78               ld a,b                          ; get the player block coords of current block
276+  AA58 E6 F8            and 248                         ; find closest multiple of eight
277+  AA5A 0F               rrca
278+  AA5B 0F               rrca
279+  AA5C 0F               rrca                ; divide by 8
280+  AA5D 47               ld b,a
281+  AA5E 79               ld a,c
282+  AA5F 48               ld c,b                         ; swap b and c
283+  AA60 E6 F8            and 248
284+  AA62 0F               rrca
285+  AA63 0F               rrca
286+  AA64 0F               rrca                ; divide by 8
287+  AA65 47               ld b,a
288+  AA66 C9               ret
289+  AA67
290+  AA67              ; Gets the screen coords for a cell coord
291+  AA67              ; Will overwrite bc
292+  AA67              ; Inputs:
293+  AA67              ; bc - char coords
294+  AA67              ; Outputs:
295+  AA67              ; bc - screen coords
296+  AA67              ;
297+  AA67              screen_getscreencoordsfromcharcoords:
298+  AA67 78               ld a,b                          ; get the player block coords of current block
299+  AA68 07               rlca
300+  AA69 07               rlca
301+  AA6A 07               rlca                ; multiply by 8
302+  AA6B 47               ld b,a
303+  AA6C 79               ld a,c
304+  AA6D 48               ld c,b                         ; swap b and c
305+  AA6E 07               rlca
306+  AA6F 07               rlca
307+  AA70 07               rlca                ; divide by 8
308+  AA71 47               ld b,a
309+  AA72 C9               ret
310+  AA73
311+  AA73              ;
312+  AA73              ; Get buffer address for a character at b,c - b vert
313+  AA73              ; Buffer memory is stored as sequential block
314+  AA73              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
315+  AA73              ; Inputs:
316+  AA73              ; bc - coords
317+  AA73              ; Outputs:
318+  AA73              ; de - memory location of first byte
319+  AA73              screen_getbufferaddress:
320+  AA73 21 8C 86         ld hl, buffer_buffer    ; first get screen buffer start
321+  AA76 50               ld d,b                  ; then work out vertical offset
322+  AA77 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
323+  AA79 19               add hl,de               ; add to base
324+  AA7A 59               ld e,c                  ; then add horizontal offset (c)
325+  AA7B 16 00            ld d,0
326+  AA7D 19               add hl,de               ; add to base
327+  AA7E 54 5D            ld de,hl
328+  AA80 C9               ret
329+  AA81
330+  AA81              ;
331+  AA81              ; Display character hl at (b, c) to buffer.
332+  AA81              ; Stored sequentially
333+  AA81              ; Inputs:
334+  AA81              ; hl: block address
335+  AA81              ; bc: coords
336+  AA81              ;
337+  AA81              screen_showchar:
338+  AA81 ED 43 53 AC      ld (origcoords),bc   ; store char coords
339+  AA85 3E 00            ld a,0
340+  AA87 E5               push hl
341+  AA88 CD 73 AA         call screen_getbufferaddress ; get the current screen buffer pointer
342+  AA8B E1               pop hl
343+  AA8C 06 08            ld b,8              ; number of pixels high.
344+  AA8E              screen_showchar0:
345+  AA8E 7E               ld a,(hl)           ; source graphic.
346+  AA8F 12               ld (de),a           ; transfer to screen.
347+  AA90 23               inc hl              ; next piece of data.
348+  AA91 E5               push hl             ; store hl
349+  AA92 62 6B            ld hl,de            ; put de in hl
350+  AA94 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
351+  AA96 16 00            ld d,0
352+  AA98 19               add hl,de              ; add de to hl
353+  AA99 54 5D            ld de,hl            ; load back to de
354+  AA9B E1               pop hl              ; restore hl
355+  AA9C
356+  AA9C 10 F0            djnz screen_showchar0 ; repeat
357+  AA9E 2E 01            ld l,1
358+  AAA0 CD 04 AC         call sprites_marklinesforupdatechar
359+  AAA3
360+  AAA3 C9               ret
361+  AAA4
362+  AAA4
363+  AAA4              ;
364+  AAA4              ; Get cell graphic.
365+  AAA4              ; Inputs:
366+  AAA4              ; a: block
367+  AAA4              ; Outputs:
368+  AAA4              ; hl: memory
369+  AAA4              ;
370+  AAA4              screen_getblock:
371+  AAA4 07               rlca                        ; multiply block number by eight.
372+  AAA5 07               rlca
373+  AAA6 07               rlca
374+  AAA7 5F               ld e,a                      ; displacement to graphic address.
375+  AAA8 16 00            ld d,0                      ; no high byte.
376+  AAAA 21 68 BD         ld hl,sprites               ; address of character blocks.
377+  AAAD 19               add hl,de                   ; point to block.
378+  AAAE C9               ret
379+  AAAF
380+  AAAF              ;
381+  AAAF              ; Set a the attr of a coord
382+  AAAF              ; Inputs:
383+  AAAF              ; bc - char coords
384+  AAAF              ; a - attr
385+  AAAF              ;
386+  AAAF              screen_setattr:
387+  AAAF DD E5            push ix
388+  AAB1 C5               push bc
389+  AAB2 08               ex af, af'
390+  AAB3 CD 18 AA         call screen_getcellattroffset   ; get offset into de
391+  AAB6 21 8C A3         ld hl,buffer_attr_buffer
392+  AAB9 19               add hl,de                       ; get the memory location
393+  AABA 08               ex af, af'                      ; get attr back
394+  AABB 77               ld (hl),a                         ; set the attr
395+  AABC 08               ex af, af'                      ; get attr back
396+  AABD ED 5B F7 A8      ld de,(screen_offset)           ; get the offset
397+  AAC1 78               ld a,b                          ; get the vertical
398+  AAC2 93               sub e                           ; subtract the offset
399+  AAC3 DA D9 AA         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
400+  AAC6 FE 15            cp 21
401+  AAC8 D2 D9 AA         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
402+  AACB 47               ld b,a                          ; put the coord back in b
403+  AACC CD 2C AA         call screen_getscreenattradress ; screen attr address in de
404+  AACF 21 40 00         ld hl,64                        ; attr memory + two rows for scores
405+  AAD2 19               add hl,de
406+  AAD3 08               ex af, af'                      ; get attr back
407+  AAD4 77               ld (hl),a
408+  AAD5 C1               pop bc
409+  AAD6 DD E1            pop ix
410+  AAD8 C9               ret
411+  AAD9              screen_setattr0:
412+  AAD9 C1               pop bc
413+  AADA DD E1            pop ix
414+  AADC C9               ret
415+  AADD
416+  AADD              ;
417+  AADD              ; Get cell attribute.
418+  AADD              ; Inputs:
419+  AADD              ; a: block
420+  AADD              ; Outputs:
421+  AADD              ; hl: memory
422+  AADD              ;
423+  AADD              screen_getattr:
424+  AADD 5F               ld e,a                      ; displacement to attribute address.
425+  AADE 16 00            ld d,0                      ; no high byte.
426+  AAE0 21 48 BE         ld hl,sprite_attrs          ; address of block attributes.
427+  AAE3 19               add hl,de                   ; point to attribute.
428+  AAE4 C9               ret
429+  AAE5
430+  AAE5              ;
431+  AAE5              ; Checks whether a character block has anything in it
432+  AAE5              ; Inputs:
433+  AAE5              ; bc - char coords
434+  AAE5              ; Outputs:
435+  AAE5              ; a - 1, empty
436+  AAE5              screen_ischarempty:
437+  AAE5 CD 73 AA         call screen_getbufferaddress ; get the current screen buffer pointer
438+  AAE8 06 08            ld b,8                      ; check 8 rows
439+  AAEA              screen_ischarempty2:
440+  AAEA 1A               ld a,(de)                   ; check line
441+  AAEB FE 00            cp 0
442+  AAED C2 FB AA         jp nz,screen_ischarempty1   ; if not zero, jump out with false
443+  AAF0 21 20 00         ld hl,32
444+  AAF3 19               add hl,de
445+  AAF4 54 5D            ld de,hl                    ; move to next row
446+  AAF6 10 F2            djnz screen_ischarempty2
447+  AAF8              screen_ischarempty0:
448+  AAF8 3E 01            ld a,1
449+  AAFA C9               ret
450+  AAFB              screen_ischarempty1:
451+  AAFB 3E 00            ld a,0
452+  AAFD C9               ret
453+  AAFE
454+  AAFE              ;
455+  AAFE              ; Copies a block from one place to another directly underneath, leaves the original empty
456+  AAFE              ; Inputs:
457+  AAFE              ; bc - coords of block to copy from
458+  AAFE              screen_copyblockdown
459+  AAFE CD 73 AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
460+  AB01 06 08            ld b,8                      ; copy 8 rows
461+  AB03              screen_copyblock0:
462+  AB03 1A               ld a,(de)                    ; get what we're copying
463+  AB04 08               ex af,af'
464+  AB05 3E 00            ld a,0
465+  AB07 12               ld (de),a                    ; replace with empty
466+  AB08 08               ex af,af'
467+  AB09 14               inc d                        ; add 256 to get to the next row
468+  AB0A 12               ld (de),a                    ; copy to the next row
469+  AB0B 15               dec d
470+  AB0C 21 20 00         ld hl,32
471+  AB0F 19               add hl,de                       ; return back to source, next row down
472+  AB10 54 5D            ld de,hl
473+  AB12 10 EF            djnz screen_copyblock0
474+  AB14 C9               ret
475+  AB15
476+  AB15              ;
477+  AB15              ; Returns the first byte of a character. Useful for figuring out what's there
478+  AB15              ; Inputs:
479+  AB15              ; bc - coords
480+  AB15              ; Outputs:
481+  AB15              ; a - first byte
482+  AB15              ;
483+  AB15              screen_getcharfirstbyte:
484+  AB15 CD 73 AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
485+  AB18 1A               ld a,(de)
486+  AB19 C9               ret
487+  AB1A
# file closed: screen/screen.asm
142   AB1A                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  AB1A              ;
  2+  AB1A              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  AB1A              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  AB1A              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  AB1A              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  AB1A              ; routine takes care of all the shifting itself. This means that sprite
  7+  AB1A              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  AB1A              ; space they would require in pre-shifted form.
  9+  AB1A              ; Inputs:
 10+  AB1A              ; hl - sprite data
 11+  AB1A              ; bc - screen coords
 12+  AB1A              ;
 13+  AB1A              sprites_drawsprite7:
 14+  AB1A EE 07            xor 7               ; complement last 3 bits.
 15+  AB1C 3C               inc a               ; add one for luck!
 16+  AB1D              sprites_drawsprite3:
 17+  AB1D CB 11            rl c                ; ...into middle byte...
 18+  AB1F CB 12            rl d                ; ...and finally into left character cell.
 19+  AB21 3D               dec a               ; count shifts we've done.
 20+  AB22 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  AB24                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  AB24 79               ld a,c              ; left edge of image is currently in e.
 23+  AB25 4A               ld c,d              ; put right edge there instead.
 24+  AB26 57               ld d,a              ; and the left edge back into c.
 25+  AB27 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  AB29              sprites_drawsprite:
 27+  AB29 ED 43 53 AC      ld (origcoords),bc  ; store coords
 28+  AB2D ED 43 55 AC      ld (dispx),bc       ; store coords in dispx for now.
 29+  AB31 E5               push hl
 30+  AB32 CD 31 AC         call sprites_scadd  ; calculate screen address.
 31+  AB35 E1               pop hl
 32+  AB36 3E 08            ld a,8              ; height of sprite in pixels.
 33+  AB38              sprites_drawsprite1:
 34+  AB38 08               ex af,af'           ; store loop counter.
 35+  AB39 D5               push de             ; store screen address.
 36+  AB3A 4E               ld c,(hl)           ; first sprite graphic.
 37+  AB3B 23               inc hl              ; increment poiinter to sprite data.
 38+  AB3C 22 57 AC         ld (sprtmp),hl      ; store it for later.
 39+  AB3F 16 00            ld d,0              ; blank right byte for now.
 40+  AB41 78               ld a,b              ; b holds y position.
 41+  AB42 E6 07            and 7               ; how are we straddling character cells?
 42+  AB44 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  AB46 FE 05            cp 5                ; 5 or more right shifts needed?
 44+  AB48 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  AB4A A7               and a               ; oops, carry flag is set so clear it.
 46+  AB4B              sprites_drawsprite2:
 47+  AB4B CB 19            rr c                ; rotate left byte right...
 48+  AB4D CB 1A            rr d                ; ...into right byte.
 49+  AB4F 3D               dec a               ; one less shift to do.
 50+  AB50 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  AB52              sprites_drawsprite0:
 52+  AB52 E1               pop hl              ; pop screen address from stack.
 53+  AB53 7E               ld a,(hl)           ; what's there already.
 54+  AB54 A9               xor c               ; merge in image data.
 55+  AB55 77               ld (hl),a           ; place onto screen.
 56+  AB56 23               inc hl
 57+  AB57 7E               ld a,(hl)           ; what's already there.
 58+  AB58 AA               xor d               ; right edge of sprite image data.
 59+  AB59 77               ld (hl),a           ; plonk it on screen.
 60+  AB5A 3A 55 AC         ld a,(dispx)        ; vertical coordinate.
 61+  AB5D 3C               inc a               ; next line down.
 62+  AB5E 32 55 AC         ld (dispx),a        ; store new position.
 63+  AB61 2B               dec hl
 64+  AB62 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  AB65 19               add hl,de           ; add 32
 66+  AB66              sprites_drawsprite6:
 67+  AB66 EB               ex de,hl            ; screen address in de.
 68+  AB67 2A 57 AC         ld hl,(sprtmp)      ; restore graphic address.
 69+  AB6A 08               ex af,af'           ; restore loop counter.
 70+  AB6B 3D               dec a               ; decrement it.
 71+  AB6C C2 38 AB         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  AB6F 2E 02            ld l,2
 73+  AB71 CD E0 AB         call sprites_marklinesforupdatescreen
 74+  AB74 C9               ret                 ; job done.
 75+  AB75
 76+  AB75              ; Inputs:
 77+  AB75              ; hl - sprite data
 78+  AB75              ; bc - screen coords
 79+  AB75              ;
 80+  AB75              sprites_draw2by2sprite7
 81+  AB75 EE 07            xor 7               ; complement last 3 bits.
 82+  AB77 3C               inc a               ; add one for luck!
 83+  AB78              sprites_draw2by2sprite3
 84+  AB78 CB 12            rl d                ; rotate left...
 85+  AB7A CB 11            rl c                ; ...into middle byte...
 86+  AB7C CB 13            rl e                ; ...and finally into left character cell.
 87+  AB7E 3D               dec a               ; count shifts we've done.
 88+  AB7F 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  AB81                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  AB81 7B               ld a,e              ; left edge of image is currently in e.
 91+  AB82 5A               ld e,d              ; put right edge there instead.
 92+  AB83 51               ld d,c              ; middle bit goes in d.
 93+  AB84 4F               ld c,a              ; and the left edge back into c.
 94+  AB85 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  AB87              sprites_draw2by2sprite
 96+  AB87 ED 43 53 AC      ld (origcoords),bc  ; store coords
 97+  AB8B ED 43 55 AC      ld (dispx),bc       ; store coords in dispx for now.
 98+  AB8F 79               ld a,c
 99+  AB90 32 59 AC         ld (sprtmp0),a         ; store vertical.
100+  AB93 E5               push hl
101+  AB94 CD 31 AC         call sprites_scadd          ; calculate screen address.
102+  AB97 E1               pop hl
103+  AB98 3E 10            ld a,16             ; height of sprite in pixels.
104+  AB9A              sprites_draw2by2sprite1
105+  AB9A 08               ex af,af'           ; store loop counter.
106+  AB9B D5               push de             ; store screen address.
107+  AB9C 4E               ld c,(hl)           ; first sprite graphic.
108+  AB9D 23               inc hl              ; increment poiinter to sprite data.
109+  AB9E 56               ld d,(hl)           ; next bit of sprite image.
110+  AB9F 23               inc hl              ; point to next row of sprite data.
111+  ABA0 22 57 AC         ld (sprtmp),hl        ; store in tmp0 for later.
112+  ABA3 1E 00            ld e,0              ; blank right byte for now.
113+  ABA5 78               ld a,b              ; b holds y position.
114+  ABA6 E6 07            and 7               ; how are we straddling character cells?
115+  ABA8 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  ABAA FE 05            cp 5                ; 5 or more right shifts needed?
117+  ABAC 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  ABAE A7               and a               ; oops, carry flag is set so clear it.
119+  ABAF              sprites_draw2by2sprite2
120+  ABAF CB 19            rr c                ; rotate left byte right...
121+  ABB1 CB 1A            rr d                ; ...through middle byte...
122+  ABB3 CB 1B            rr e                ; ...into right byte.
123+  ABB5 3D               dec a               ; one less shift to do.
124+  ABB6 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  ABB8              sprites_draw2by2sprite0
126+  ABB8 E1               pop hl              ; pop screen address from stack.
127+  ABB9 7E               ld a,(hl)           ; what's there already.
128+  ABBA A9               xor c               ; merge in image data.
129+  ABBB 77               ld (hl),a           ; place onto screen.
130+  ABBC 23               inc hl               ; next character cell to right please.
131+  ABBD 7E               ld a,(hl)           ; what's there already.
132+  ABBE AA               xor d               ; merge with middle bit of image.
133+  ABBF 77               ld (hl),a           ; put back onto screen.
134+  ABC0 23               inc hl              ; next bit of screen area.
135+  ABC1 7E               ld a,(hl)           ; what's already there.
136+  ABC2 AB               xor e               ; right edge of sprite image data.
137+  ABC3 77               ld (hl),a           ; plonk it on screen.
138+  ABC4 3A 59 AC         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  ABC7 3C               inc a               ; next line down.
140+  ABC8 32 59 AC         ld (sprtmp0),a         ; store new position.
141+  ABCB 2B               dec hl
142+  ABCC 2B               dec hl
143+  ABCD 11 20 00         ld de,32            ; add 32 to get to the next row
144+  ABD0 19               add hl,de           ; add 32
145+  ABD1              sprites_draw2by2sprite6
146+  ABD1 EB               ex de,hl            ; screen address in de.
147+  ABD2 2A 57 AC         ld hl,(sprtmp)        ; restore graphic address.
148+  ABD5 08               ex af,af'           ; restore loop counter.
149+  ABD6 3D               dec a               ; decrement it.
150+  ABD7 C2 9A AB         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  ABDA 2E 03            ld l,3
152+  ABDC CD E0 AB         call sprites_marklinesforupdatescreen
153+  ABDF C9               ret                 ; job done.
154+  ABE0
155+  ABE0              ;
156+  ABE0              ; Marks lines for update with screen coords
157+  ABE0              ; Inputs:
158+  ABE0              ; l - number to update
159+  ABE0              ;
160+  ABE0              sprites_marklinesforupdatescreen:
161+  ABE0 F5               push af
162+  ABE1 ED 4B 53 AC      ld bc,(origcoords)
163+  ABE5 CD 57 AA         call screen_getcharcoordsfromscreencoords
164+  ABE8 ED 43 53 AC      ld (origcoords),bc
165+  ABEC 3A 2E A7         ld a,(buffer_threelinerefresh)              ; check the three line update flag
166+  ABEF FE 01            cp 1
167+  ABF1 C2 FF AB         jp nz,sprites_marklinesforupdatescreen0
168+  ABF4 2C               inc l                                       ; increase number to 3
169+  ABF5 05               dec b
170+  ABF6 ED 43 53 AC      ld (origcoords),bc                           ; decrease vertical coord
171+  ABFA 3E 00            ld a,0
172+  ABFC 32 2E A7         ld (buffer_threelinerefresh),a              ; reset the flag
173+  ABFF              sprites_marklinesforupdatescreen0:
174+  ABFF CD 0E AC         call sprites_marklinesforupdate
175+  AC02 F1               pop af
176+  AC03 C9               ret
177+  AC04
178+  AC04              ;
179+  AC04              ; Marks lines for update with char coords
180+  AC04              ; Inputs:
181+  AC04              ; l - number to update
182+  AC04              ;
183+  AC04              sprites_marklinesforupdatechar:
184+  AC04 F5               push af
185+  AC05 ED 43 53 AC      ld (origcoords),bc
186+  AC09 CD 0E AC         call sprites_marklinesforupdate
187+  AC0C F1               pop af
188+  AC0D C9               ret
189+  AC0E
190+  AC0E              ;
191+  AC0E              ; Marks lines for update
192+  AC0E              ; Inputs:
193+  AC0E              ; l - number to update
194+  AC0E              ;
195+  AC0E              sprites_marklinesforupdate:
196+  AC0E ED 4B 53 AC      ld bc,(origcoords)
197+  AC12 ED 5B F7 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
198+  AC16 78               ld a,b
199+  AC17 93               sub e
200+  AC18 47               ld b,a
201+  AC19 7D               ld a,l                          ; get loop counter
202+  AC1A              sprites_marklinesforupdate0:
203+  AC1A C5               push bc
204+  AC1B 08               ex af,af'                     ; store loop counter
205+  AC1C 78               ld a,b
206+  AC1D CD 45 A7         call buffer_marklineforupdate ; mark this line for update
207+  AC20 ED 4B 53 AC      ld bc,(origcoords)            ; move the coords for the next line
208+  AC24 04               inc b
209+  AC25 ED 43 53 AC      ld (origcoords),bc
210+  AC29 C1               pop bc
211+  AC2A 04               inc b
212+  AC2B 08               ex af,af'                     ; restore loop counter
213+  AC2C 3D               dec a
214+  AC2D C2 1A AC         jp nz,sprites_marklinesforupdate0
215+  AC30 C9               ret
216+  AC31
217+  AC31              ;
218+  AC31              ; This routine returns a buffer address for (c, b) in de (c vert).
219+  AC31              ; For example: 0,0 will be at memory offset 0
220+  AC31              ; 1,0 (1 down) will be at memory offset 1
221+  AC31              ; 0,7 will be at memory offset 0
222+  AC31              ; 9,1 will be at memory offset 8+1
223+  AC31              ; 8,0 will be at memory offset 256
224+  AC31              ; 9,0 will be at memory offset 257
225+  AC31              ; Outputs:
226+  AC31              ; de - coords
227+  AC31              ;
228+  AC31              sprites_scadd:
229+  AC31 79               ld a,c               ; calculate vertical offset
230+  AC32 E6 F8            and 248             ;  to get nearest multiple of 8
231+  AC34 0F               rrca
232+  AC35 0F               rrca
233+  AC36 0F               rrca                ; divide by 8
234+  AC37 67               ld h,a
235+  AC38 78               ld a,b               ; calculate horizontal offset
236+  AC39 E6 F8            and 248             ;  to get nearest multiple of 8
237+  AC3B 0F               rrca
238+  AC3C 0F               rrca
239+  AC3D 0F               rrca                ; divide by 8
240+  AC3E 6F               ld l,a
241+  AC3F C5               push bc             ; store the screen coords
242+  AC40 44 4D            ld bc,hl            ; load bc with the character coords
243+  AC42 CD 73 AA         call screen_getbufferaddress
244+  AC45 C1               pop bc              ; get back screen coords, de is now memory of character
245+  AC46 79               ld a,c              ; now add the vertical within the cell
246+  AC47 E6 07            and 7
247+  AC49 0F               rrca                ; multiply by 32.
248+  AC4A 0F               rrca
249+  AC4B 0F               rrca
250+  AC4C 6F               ld l,a
251+  AC4D 26 00            ld h,0
252+  AC4F 19               add hl,de
253+  AC50 54 5D            ld de,hl
254+  AC52 C9               ret
255+  AC53
256+  AC53 00 00        origcoords   defb 0,0           ; general-use coordinates.
257+  AC55
258+  AC55 00           dispx   defb 0           ; general-use coordinates.
259+  AC56 00           dispy   defb 0
260+  AC57 00 00        sprtmp  defb 0,0           ; sprite temporary address.
261+  AC59 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
262+  AC5B
# file closed: screen/sprites.asm
143   AC5B                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AC5B              titlescreen_preshow:
  2+  AC5B CD 0C AD         call titlescreen_preinit
  3+  AC5E CD 76 B1         call sound_gamestart
  4+  AC61 06 3C            ld b,60
  5+  AC63 CD 64 81         call utilities_pauseforframes         ; pause for a second
  6+  AC66 C9               ret
  7+  AC67
  8+  AC67              ;
  9+  AC67              ; Draws the title screen
 10+  AC67              ;
 11+  AC67              titlescreen_show:
 12+  AC67 CD F9 AC         call titlescreen_init
 13+  AC6A CD A2 AC         call titlescreen_drawtitle
 14+  AC6D 3A 2C C5         ld a,(game_control)
 15+  AC70 FE 00            cp 0
 16+  AC72 CA 7A AC         jp z,titlescreen_show1
 17+  AC75 06 32            ld b,50
 18+  AC77 CD 64 81         call utilities_pauseforframes         ; pause for a second
 19+  AC7A              titlescreen_show1:
 20+  AC7A 3E FA            ld a,250                              ; wait for 200 frames
 21+  AC7C CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 22+  AC7F 7B               ld a,e
 23+  AC80 FE 01            cp 1                                  ; was anything pressed?
 24+  AC82 C8               ret z                                 ; end titlescreen if so
 25+  AC83
 26+  AC83 CD 19 AD         call titlescreen_alt_init             ; otherwise, draw alt screen
 27+  AC86 CD BE AC         call titlescreen_alt_drawtitle
 28+  AC89 3A 2C C5         ld a,(game_control)
 29+  AC8C FE 00            cp 0
 30+  AC8E CA 96 AC         jp z,titlescreen_show0
 31+  AC91 06 32            ld b,50
 32+  AC93 CD 64 81         call utilities_pauseforframes         ; pause for a second if joystick
 33+  AC96              titlescreen_show0:
 34+  AC96 3E FA            ld a,250                              ; wait for 200 frames
 35+  AC98 CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 36+  AC9B 7B               ld a,e
 37+  AC9C FE 01            cp 1                                  ; was anything pressed?
 38+  AC9E C2 67 AC         jp nz,titlescreen_show               ; start again if not
 39+  ACA1 C9               ret
 40+  ACA2
 41+  ACA2              ;
 42+  ACA2              ; Draws the iconic logo
 43+  ACA2              ;
 44+  ACA2              titlescreen_drawtitle:
 45+  ACA2 06 67            ld b,103              ; number of points
 46+  ACA4 DD 21 26 AD      ld ix,titlescreen_logo_data
 47+  ACA8              titlescreen_drawtitle0:
 48+  ACA8 C5               push bc
 49+  ACA9 DD 4E 00         ld c,(ix)                   ; got horiz
 50+  ACAC DD 23            inc ix
 51+  ACAE DD 46 00         ld b,(ix)                   ; got vert
 52+  ACB1 DD 23            inc ix
 53+  ACB3 CD 2C AA         call screen_getscreenattradress ; memory in de
 54+  ACB6 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 55+  ACB7 3E 13            ld a,19
 56+  ACB9 12               ld (de),a
 57+  ACBA C1               pop bc
 58+  ACBB 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 59+  ACBD C9               ret
 60+  ACBE
 61+  ACBE              ;
 62+  ACBE              ; Draws the alternate title screen
 63+  ACBE              ;
 64+  ACBE              titlescreen_alt_drawtitle:
 65+  ACBE 21 3C 82         ld hl,string_alttitlescreen_1
 66+  ACC1 CD 44 86         call string_print
 67+  ACC4 21 48 82         ld hl,string_alttitlescreen_2
 68+  ACC7 CD 44 86         call string_print
 69+  ACCA 21 43 83         ld hl,string_alttitlescreen_3
 70+  ACCD CD 44 86         call string_print
 71+  ACD0 06 20            ld b,32
 72+  ACD2 3E 43            ld a,67
 73+  ACD4 11 00 58         ld de,22528                         ; top row attrs here
 74+  ACD7 CD BA A9         call screen_setcolours
 75+  ACDA 06 20            ld b,32
 76+  ACDC 3E 46            ld a,70
 77+  ACDE 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 78+  ACE1 CD BA A9         call screen_setcolours
 79+  ACE4 06 20            ld b,32
 80+  ACE6 3E 43            ld a,67
 81+  ACE8 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 82+  ACEB CD BA A9         call screen_setcolours
 83+  ACEE 06 20            ld b,32
 84+  ACF0 3E 42            ld a,66
 85+  ACF2 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 86+  ACF5 CD BA A9         call screen_setcolours
 87+  ACF8 C9               ret
 88+  ACF9
 89+  ACF9              ;
 90+  ACF9              ; Initialises the screen
 91+  ACF9              ;
 92+  ACF9              titlescreen_init:
 93+  ACF9              ; We want a black screen.
 94+  ACF9 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 95+  ACFB                                      ; bright (64).
 96+  ACFB CD 49 81         call utilities_clearscreen
 97+  ACFE 32 8D 5C         ld (23693),a        ; set our screen colours.
 98+  AD01 3E 01            ld a,1              ; 2 is the code for red.
 99+  AD03 D3 FE            out (254),a         ; write to port 254.
100+  AD05
101+  AD05 21 27 82         ld hl,string_titlescreen_copyright
102+  AD08 CD 44 86         call string_print
103+  AD0B
104+  AD0B C9               ret
105+  AD0C
106+  AD0C              ;
107+  AD0C              ; Initialises the pre-screen
108+  AD0C              ;
109+  AD0C              titlescreen_preinit:
110+  AD0C              ; We want a red screen.
111+  AD0C 3E 10            ld a,16             ; magenta ink (7) on blue paper (0),
112+  AD0E                                      ; bright (64).
113+  AD0E CD 49 81         call utilities_clearscreen
114+  AD11 32 8D 5C         ld (23693),a        ; set our screen colours.
115+  AD14 3E 02            ld a,2              ; 2 is the code for red.
116+  AD16 D3 FE            out (254),a         ; write to port 254.
117+  AD18 C9               ret
118+  AD19
119+  AD19              ;
120+  AD19              ; Initialises the screen
121+  AD19              ;
122+  AD19              titlescreen_alt_init:
123+  AD19              ; We want a black screen.
124+  AD19 3E 47            ld a,71             ; white ink (7) on black paper (0),
125+  AD1B                                      ; bright (64).
126+  AD1B CD 49 81         call utilities_clearscreen
127+  AD1E 32 8D 5C         ld (23693),a        ; set our screen colours.
128+  AD21 3E 00            ld a,0              ; 2 is the code for red.
129+  AD23 D3 FE            out (254),a         ; write to port 254.
130+  AD25
131+  AD25 C9               ret
132+  AD26
133+  AD26              ;
134+  AD26              ; Horiz, vert
135+  AD26              ;
136+  AD26              titlescreen_logo_data:
137+  AD26 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
137+  AD2A 0A 00 0C 00
137+  AD2E 0F 00 11 00
137+  AD32 12 00 13 00
138+  AD36 09 01 0C 01      defb 9,1,12,1,15,1,17,1
138+  AD3A 0F 01 11 01
139+  AD3E 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
139+  AD42 0D 02 0E 02
139+  AD46 0F 02 11 02
139+  AD4A 12 02 13 02
140+  AD4E 09 03 0C 03      defb 9,3,12,3,15,3,17,3
140+  AD52 0F 03 11 03
141+  AD56 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
141+  AD5A 0F 04 11 04
141+  AD5E 12 04 13 04
142+  AD62 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
142+  AD66 02 06 03 06
142+  AD6A 04 06 05 06
142+  AD6E 06 06 07 06
142+  AD72 08 06 09 06
142+  AD76 0A 06 0B 06
143+  AD7A 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
143+  AD7E 12 06 13 06
143+  AD82 14 06 15 06
143+  AD86 16 06 17 06
143+  AD8A 18 06 19 06
143+  AD8E 1A 06 1B 06
144+  AD92 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
144+  AD96 02 09 02 0A
144+  AD9A 02 0B 02 0C
144+  AD9E 02 0D 02 0E
144+  ADA2 02 0F 02 10
144+  ADA6 02 11 02 12
144+  ADAA 02 13 02 14
144+  ADAE 02 15
145+  ADB0 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
145+  ADB4 19 09 19 0A
145+  ADB8 19 0B 19 0C
145+  ADBC 19 0D 19 0E
145+  ADC0 19 0F 19 10
145+  ADC4 19 11 19 12
145+  ADC8 19 13 19 14
145+  ADCC 19 15
146+  ADCE 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
146+  ADD2 05 0B 06 0B
146+  ADD6 07 0B 08 0B
146+  ADDA 09 0B 0A 0B
146+  ADDE 0B 0B
147+  ADE0 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
147+  ADE4 0B 09 0B 0A
148+  ADE8 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
148+  ADEC 10 10 10 11
148+  ADF0 10 12 10 13
149+  ADF4
# file closed: screen/titlescreen.asm
144   ADF4                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ADF4              ;
  2+  ADF4              ; Draws the life remaining screen
  3+  ADF4              ;
  4+  ADF4              lifescreen_draw:
  5+  ADF4 CD 4A AE         call lifescreen_init
  6+  ADF7
  7+  ADF7 3A 29 C5         ld a,(game_currentplayer)             ; get the current player
  8+  ADFA C6 30            add 48                                ; add 48 to get char
  9+  ADFC 21 49 84         ld hl,string_lifescreen_player+10
 10+  ADFF 77               ld (hl),a                             ; load this to the string we're about to show
 11+  AE00
 12+  AE00 21 3F 84         ld hl,string_lifescreen_player
 13+  AE03 CD 44 86         call string_print
 14+  AE06
 15+  AE06 3A 21 C6         ld a,(player+9)                       ; get the current player lives
 16+  AE09 C6 30            add 48                                ; add 48 to get the character
 17+  AE0B FE 31            cp 49
 18+  AE0D C2 20 AE         jp nz,lifescreen_draw0
 19+  AE10 21 59 84         ld hl,string_lifescreen_lastman
 20+  AE13
 21+  AE13 06 08            ld b,8
 22+  AE15 3E 0A            ld a,10                                ; set red
 23+  AE17 11 6C 58         ld de,22528+108                        ; attrs here
 24+  AE1A CD BA A9         call screen_setcolours
 25+  AE1D
 26+  AE1D C3 27 AE         jp lifescreen_draw1
 27+  AE20              lifescreen_draw0:
 28+  AE20 21 4E 84         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  AE23 77               ld (hl),a                             ; load this to the string we're about to show
 30+  AE24 21 4C 84         ld hl,string_lifescreen_lives
 31+  AE27              lifescreen_draw1:
 32+  AE27 CD 44 86         call string_print
 33+  AE2A
 34+  AE2A 3E 86            ld a,134
 35+  AE2C 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AE2F 06 0A            ld b,10
 37+  AE31 CD BA A9         call screen_setcolours
 38+  AE34 3A 2C C5         ld a,(game_control)
 39+  AE37 FE 00            cp 0
 40+  AE39 CA 41 AE         jp z,lifescreen_draw2
 41+  AE3C 06 32            ld b,50
 42+  AE3E CD 64 81         call utilities_pauseforframes         ; pause for a second if joystick
 43+  AE41              lifescreen_draw2:
 44+  AE41 CD 93 B1         call sound_lifestart
 45+  AE44 3E 64            ld a,100                              ; wait for 200 frames
 46+  AE46 CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 47+  AE49
 48+  AE49 C9               ret
 49+  AE4A
 50+  AE4A              ;
 51+  AE4A              ; Initialises the screen
 52+  AE4A              ;
 53+  AE4A              lifescreen_init:
 54+  AE4A              ; We want a blue screen.
 55+  AE4A                  ;call $0D6B
 56+  AE4A 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 57+  AE4C                                      ; bright (64).
 58+  AE4C CD 49 81         call utilities_clearscreen
 59+  AE4F 32 8D 5C         ld (23693),a        ; set our screen colours.
 60+  AE52 3E 01            ld a,1              ; 1 is the code for blue.
 61+  AE54 D3 FE            out (254),a         ; write to port 254.
 62+  AE56                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 63+  AE56
 64+  AE56 C9               ret
# file closed: screen/lifescreen.asm
145   AE57                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AE57              ;
  2+  AE57              ; Draws the game over screen
  3+  AE57              ;
  4+  AE57              gameover_draw:
  5+  AE57 3E 00            ld a,0
  6+  AE59 32 95 AF         ld (gameover_soundplayed),a
  7+  AE5C 3E 01            ld a,1
  8+  AE5E 32 29 C5         ld (game_currentplayer),a               ; do the first player first
  9+  AE61 CD 84 C6         call player_init_lifestart              ; get the player config
 10+  AE64 CD BA AE         call gameover_enterhighscores
 11+  AE67
 12+  AE67 3A 28 C5         ld a,(game_numberplayers)               ; check if we need to do player 2
 13+  AE6A FE 02            cp 2
 14+  AE6C C2 7A AE         jp nz,gameover_draw0
 15+  AE6F 3E 02            ld a,2
 16+  AE71 32 29 C5         ld (game_currentplayer),a               ; do the second player
 17+  AE74 CD 84 C6         call player_init_lifestart              ; get the player config
 18+  AE77 CD BA AE         call gameover_enterhighscores
 19+  AE7A              gameover_draw0:
 20+  AE7A CD 88 AF         call gameover_init
 21+  AE7D
 22+  AE7D 21 64 84         ld hl,string_gameoverscreen_gameover
 23+  AE80 CD 44 86         call string_print
 24+  AE83
 25+  AE83 21 70 84         ld hl,string_gameoverscreen_copyright
 26+  AE86 CD 44 86         call string_print
 27+  AE89
 28+  AE89 CD 9D AE         call gameover_commontext
 29+  AE8C CD 96 AF         call gameover_playsound
 30+  AE8F 06 0B            ld b,11
 31+  AE91 3E 42            ld a,66
 32+  AE93 11 2B 58         ld de,22528+43                         ; attrs here
 33+  AE96 CD BA A9         call screen_setcolours
 34+  AE99 CD 10 81         call utilities_waitforkey   ; wait for keypress
 35+  AE9C
 36+  AE9C C9               ret
 37+  AE9D
 38+  AE9D              ;
 39+  AE9D              ; Draws text shared by the game over and high score screens
 40+  AE9D              ;
 41+  AE9D              gameover_commontext:
 42+  AE9D CD 7E A9         call screen_setuptext       ; show scores
 43+  AEA0 CD D9 CD         call scores_printscores     ; print the current scores
 44+  AEA3
 45+  AEA3 21 98 84         ld hl,string_gameover_credits
 46+  AEA6 CD 44 86         call string_print
 47+  AEA9
 48+  AEA9 21 84 84         ld hl,string_gameoverscreen_bestscores
 49+  AEAC CD 44 86         call string_print
 50+  AEAF
 51+  AEAF 06 20            ld b,32
 52+  AEB1 3E 45            ld a,69
 53+  AEB3 11 C0 5A         ld de,22528+704                         ; attrs here
 54+  AEB6 CD BA A9         call screen_setcolours
 55+  AEB9
 56+  AEB9 C9               ret
 57+  AEBA
 58+  AEBA              ;
 59+  AEBA              ; If required, enter highscore
 60+  AEBA              ;
 61+  AEBA              gameover_enterhighscores:
 62+  AEBA                  ; check if we need to enter initial
 63+  AEBA CD 4A CE         call scores_processhighscores
 64+  AEBD
 65+  AEBD 3A 48 CE         ld a,(scores_highscoretmp)
 66+  AEC0 FE 00            cp 0
 67+  AEC2 C8               ret z
 68+  AEC3 CD 1E AF         call gameover_enterhighscores_init
 69+  AEC6 CD 96 AF         call gameover_playsound
 70+  AEC9                  ; Set the flash
 71+  AEC9 3A 48 CE         ld a,(scores_highscoretmp)              ; scoretmp has the memory offset of the start of the number
 72+  AECC 1E 05            ld e,5
 73+  AECE 93               sub e                                   ; get the score position back to coords
 74+  AECF 11 00 00         ld de,0
 75+  AED2 5F               ld e,a                                  ; load into de
 76+  AED3 21 5E CD         ld hl,scores_table
 77+  AED6 19               add hl,de                               ; get the memory location
 78+  AED7 4E 23 46 2B      ld bc,(hl)                              ; get the coords
 79+  AEDB CD 2C AA         call screen_getscreenattradress         ; get the memory location of the cell attr into de
 80+  AEDE 1A               ld a,(de)                               ; get the current attr
 81+  AEDF F6 80            or 128                                  ; make it flash
 82+  AEE1 12               ld (de),a
 83+  AEE2 13               inc de
 84+  AEE3 12               ld (de),a
 85+  AEE4 13               inc de
 86+  AEE5 12               ld (de),a                               ; make all three flash
 87+  AEE6 3A 48 CE         ld a,(scores_highscoretmp)              ; get the score back again
 88+  AEE9 3D               dec a
 89+  AEEA 3D               dec a
 90+  AEEB 3D               dec a                                   ; get high score location back to position of name
 91+  AEEC 16 00            ld d,0
 92+  AEEE 5F               ld e,a
 93+  AEEF 21 5E CD         ld hl,scores_table
 94+  AEF2 19               add hl,de                               ; load memory into hl
 95+  AEF3 08               ex af,af'
 96+  AEF4 06 0F            ld b,15
 97+  AEF6 CD 64 81         call utilities_pauseforframes           ; pause for a little bit
 98+  AEF9 06 03            ld b,3                                  ; collect three chars
 99+  AEFB              gameover_enterhighscores2:
100+  AEFB C5               push bc
101+  AEFC E5               push hl
102+  AEFD              gameover_enterhighscores3:
103+  AEFD CD 68 81         call utilities_readkey               ; get key into a
104+  AF00 FE 41            cp 65
105+  AF02 DA FD AE         jp c,gameover_enterhighscores3
106+  AF05 FE 5B            cp 91
107+  AF07 D2 FD AE         jp nc,gameover_enterhighscores3      ; if not a letter, get another
108+  AF0A E1               pop hl
109+  AF0B 77               ld (hl),a
110+  AF0C 23               inc hl
111+  AF0D E5               push hl
112+  AF0E CD 0C B2         call sound_gemcollected
113+  AF11 CD 35 CE         call scores_showtable
114+  AF14 E1               pop hl
115+  AF15 06 0F            ld b,15
116+  AF17 CD 64 81         call utilities_pauseforframes
117+  AF1A C1               pop bc
118+  AF1B 10 DE            djnz gameover_enterhighscores2
119+  AF1D C9               ret
120+  AF1E
121+  AF1E              ;
122+  AF1E              ; Displays the screen text for high score entry
123+  AF1E              ;
124+  AF1E              gameover_enterhighscores_init:
125+  AF1E
126+  AF1E CD 88 AF         call gameover_init
127+  AF21 CD 9D AE         call gameover_commontext
128+  AF24
129+  AF24 21 A4 84         ld hl,string_highscore_congratulations
130+  AF27 CD 44 86         call string_print
131+  AF2A
132+  AF2A 3A 29 C5         ld a,(game_currentplayer)
133+  AF2D FE 01            cp 1
134+  AF2F 21 B6 84         ld hl,string_highscore_player1
135+  AF32 C3 38 AF         jp gameover_enterhighscores_init1
136+  AF35              gameover_enterhighscores_init0:
137+  AF35 21 C1 84         ld hl,string_highscore_player2
138+  AF38              gameover_enterhighscores_init1:
139+  AF38 CD 44 86         call string_print
140+  AF3B 06 60            ld b,96
141+  AF3D 3E 43            ld a,67
142+  AF3F 11 A0 58         ld de,22528+160                         ; attrs here
143+  AF42 CD BA A9         call screen_setcolours
144+  AF45
145+  AF45 21 CC 84         ld hl,string_highscore_youhaveearned
146+  AF48 CD 44 86         call string_print
147+  AF4B
148+  AF4B 3A 48 CE         ld a,(scores_highscoretmp)
149+  AF4E FE 05            cp 5
150+  AF50 CA 5E AF         jp z, gameover_enterhighscores_init2    ; first place
151+  AF53 FE 11            cp 17
152+  AF55 CA 64 AF         jp z, gameover_enterhighscores_init3    ; 2nd place
153+  AF58 21 08 85         ld hl,string_highscore_place3           ; 3rd place
154+  AF5B C3 6A AF         jp gameover_enterhighscores_init4
155+  AF5E              gameover_enterhighscores_init2
156+  AF5E 21 DE 84         ld hl,string_highscore_place1
157+  AF61 C3 6A AF         jp gameover_enterhighscores_init4
158+  AF64              gameover_enterhighscores_init3
159+  AF64 21 F3 84         ld hl,string_highscore_place2
160+  AF67 C3 6A AF         jp gameover_enterhighscores_init4
161+  AF6A              gameover_enterhighscores_init4
162+  AF6A CD 44 86         call string_print
163+  AF6D
164+  AF6D 06 60            ld b,96
165+  AF6F 3E 42            ld a,66
166+  AF71 11 40 59         ld de,22528+320                         ; attrs here
167+  AF74 CD BA A9         call screen_setcolours
168+  AF77
169+  AF77 21 1D 85         ld hl,string_highscore_pleaseenter
170+  AF7A CD 44 86         call string_print
171+  AF7D
172+  AF7D 06 60            ld b,96
173+  AF7F 3E 46            ld a,70
174+  AF81 11 E0 59         ld de,22528+480                         ; attrs here
175+  AF84 CD BA A9         call screen_setcolours
176+  AF87 C9               ret
177+  AF88
178+  AF88              ;
179+  AF88              ; Initialises the screen
180+  AF88              ;
181+  AF88              gameover_init:
182+  AF88              ; We want a black screen.
183+  AF88 3E 47            ld a,71             ; white ink (7) on black paper (0),
184+  AF8A                                      ; bright (64).
185+  AF8A CD 49 81         call utilities_clearscreen
186+  AF8D 32 8D 5C         ld (23693),a        ; set our screen colours.
187+  AF90 3E 00            ld a,0              ; 2 is the code for red.
188+  AF92 D3 FE            out (254),a         ; write to port 254.
189+  AF94 C9               ret
190+  AF95
191+  AF95              gameover_soundplayed:
192+  AF95 00               defb 0
193+  AF96
194+  AF96              ;
195+  AF96              ; Plays the sound if it hasn't already been played
196+  AF96              ;
197+  AF96              gameover_playsound:
198+  AF96 3A 95 AF         ld a,(gameover_soundplayed)
199+  AF99 FE 01            cp 1
200+  AF9B C8               ret z
201+  AF9C CD C0 B1         call sound_gameover
202+  AF9F 3E 01            ld a,1
203+  AFA1 32 95 AF         ld (gameover_soundplayed),a
204+  AFA4 C9               ret
# file closed: screen/gameover.asm
146   AFA5                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AFA5              ;
  2+  AFA5              ; Draws the level transition screen
  3+  AFA5              ;
  4+  AFA5              endlevel_draw:
  5+  AFA5 CD A6 B0         call endlevel_init
  6+  AFA8 CD 8F B0         call endlevel_commontext
  7+  AFAB
  8+  AFAB 21 A4 84         ld hl,string_highscore_congratulations
  9+  AFAE CD 44 86         call string_print
 10+  AFB1
 11+  AFB1 3A 29 C5         ld a,(game_currentplayer)
 12+  AFB4 FE 01            cp 1
 13+  AFB6 21 B6 84         ld hl,string_highscore_player1
 14+  AFB9 C3 BF AF         jp endlevel_init1
 15+  AFBC              endlevel_init0:
 16+  AFBC 21 C1 84         ld hl,string_highscore_player2
 17+  AFBF              endlevel_init1:
 18+  AFBF CD 44 86         call string_print
 19+  AFC2
 20+  AFC2 21 3A 85         ld hl,string_endlevel_youhaveearned
 21+  AFC5 CD 44 86         call string_print
 22+  AFC8
 23+  AFC8 CD 2E B0         call endlevel_workoutbonus
 24+  AFCB D5               push de
 25+  AFCC 08               ex af,af'                               ; store the a value for later
 26+  AFCD CD 44 86         call string_print
 27+  AFD0 D1               pop de
 28+  AFD1 62 6B            ld hl,de                                ; get the points text into de
 29+  AFD3 CD 44 86         call string_print
 30+  AFD6
 31+  AFD6 21 A5 85         ld hl, string_endlevel_anothergo
 32+  AFD9 CD 44 86         call string_print
 33+  AFDC
 34+  AFDC 06 20            ld b,32
 35+  AFDE 3E 23            ld a,35
 36+  AFE0 11 60 59         ld de,22528+352                         ; attrs here
 37+  AFE3 CD BA A9         call screen_setcolours
 38+  AFE6
 39+  AFE6 06 20            ld b,32
 40+  AFE8 3E 25            ld a,37
 41+  AFEA 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AFED CD BA A9         call screen_setcolours
 43+  AFF0
 44+  AFF0 06 20            ld b,32
 45+  AFF2 3E 23            ld a,35
 46+  AFF4 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AFF7 CD BA A9         call screen_setcolours
 48+  AFFA
 49+  AFFA 06 20            ld b,32
 50+  AFFC 3E 22            ld a,34
 51+  AFFE 11 40 5A         ld de,22528+576                         ; attrs here
 52+  B001 CD BA A9         call screen_setcolours
 53+  B004
 54+  B004 08               ex af,af'                               ; get back a value with bonus type
 55+  B005 06 14            ld b,20
 56+  B007 CD 64 81         call utilities_pauseforframes
 57+  B00A
 58+  B00A 47               ld b,a                      ; put the bonus count in b
 59+  B00B              endlevel_init2:
 60+  B00B C5               push bc
 61+  B00C 06 01            ld b,1
 62+  B00E CD 82 CD         call scores_addthousands
 63+  B011 CD DD B1         call sound_scoretick
 64+  B014 CD E3 C6         call player_recordcurrentstate
 65+  B017 CD 99 CD         call scores_printscore     ; print the current scores
 66+  B01A 06 0A            ld b,10
 67+  B01C CD 64 81         call utilities_pauseforframes
 68+  B01F C1               pop bc
 69+  B020 10 E9            djnz endlevel_init2
 70+  B022
 71+  B022 CD CC C5         call game_increasedifficulty ; move the difficulty up a level
 72+  B025 CD E3 C6         call player_recordcurrentstate
 73+  B028
 74+  B028 3E 64            ld a,100                              ; wait for 200 frames
 75+  B02A CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 76+  B02D
 77+  B02D C9               ret
 78+  B02E
 79+  B02E              ;
 80+  B02E              ; Works out the bonus
 81+  B02E              ; Outputs:
 82+  B02E              ; a = 15 (all seven)
 83+  B02E              ; a = 10 (3 large or 4 small)
 84+  B02E              ; a = 5 (1 large diamond)
 85+  B02E              ; hl - pointer to bonus text
 86+  B02E              ; de - pointer to points text
 87+  B02E              ;
 88+  B02E              endlevel_workoutbonus:
 89+  B02E 21 E5 B8         ld hl,level_diamonds+2     ; location of state of first diamond
 90+  B031 06 03            ld b,3                      ; number to check
 91+  B033 16 00            ld d,0                      ; zero diamond count
 92+  B035              endlevel_workoutbonus0:
 93+  B035 7E               ld a,(hl)                   ; get state
 94+  B036 FE 01            cp 1
 95+  B038 C2 3C B0         jp nz,endlevel_workoutbonus1 ; if not, move on
 96+  B03B 14               inc d                       ; increment diamond count
 97+  B03C              endlevel_workoutbonus1:
 98+  B03C 23               inc hl
 99+  B03D 23               inc hl
100+  B03E 23               inc hl
101+  B03F 23               inc hl
102+  B040 23               inc hl                      ; get to next state
103+  B041 10 F2            djnz endlevel_workoutbonus0
104+  B043
105+  B043 21 F5 B8         ld hl,level_gems+2     ; location of state of first gem
106+  B046 06 04            ld b,4                      ; number to check
107+  B048 1E 00            ld e,0                      ; zero gem count
108+  B04A              endlevel_workoutbonus2:
109+  B04A 7E               ld a,(hl)                   ; get state
110+  B04B FE 01            cp 1
111+  B04D C2 51 B0         jp nz,endlevel_workoutbonus3 ; if not, move on
112+  B050 1C               inc e                       ; increment diamond count
113+  B051              endlevel_workoutbonus3:
114+  B051 23               inc hl
115+  B052 23               inc hl
116+  B053 23               inc hl
117+  B054 23               inc hl
118+  B055 23               inc hl                     ; get to next state
119+  B056 10 F2            djnz endlevel_workoutbonus2
120+  B058
121+  B058 7A               ld a,d
122+  B059 83               add e
123+  B05A FE 07            cp 7                        ; check for max bonus
124+  B05C C2 68 B0         jp nz,endlevel_workoutbonus4 ;
125+  B05F 3E 0F            ld a,15
126+  B061 21 6A 85         ld hl, string_endlevel_bonus3
127+  B064 11 96 85         ld de, string_endlevel_points3
128+  B067 C9               ret                         ; return with bonus of 15
129+  B068              endlevel_workoutbonus4:
130+  B068 7A               ld a,d                      ; check for for diamonds
131+  B069 FE 03            cp 3
132+  B06B C2 77 B0         jp nz,endlevel_workoutbonus5
133+  B06E 3E 0A            ld a,10
134+  B070 21 5B 85         ld hl, string_endlevel_bonus2
135+  B073 11 87 85         ld de, string_endlevel_points2
136+  B076 C9               ret                         ; return with bonus of ten
137+  B077              endlevel_workoutbonus5:
138+  B077 7B               ld a,e                      ; check for four gems
139+  B078 FE 04            cp 4
140+  B07A C2 86 B0         jp nz,endlevel_workoutbonus6
141+  B07D 3E 0A            ld a,10
142+  B07F 21 5B 85         ld hl, string_endlevel_bonus2
143+  B082 11 87 85         ld de, string_endlevel_points2
144+  B085 C9               ret                         ; return with bonus of 10
145+  B086              endlevel_workoutbonus6:
146+  B086 3E 05            ld a,5                      ; otherwise, bonus is 5
147+  B088 21 4C 85         ld hl, string_endlevel_bonus1
148+  B08B 11 79 85         ld de, string_endlevel_points1
149+  B08E C9               ret
150+  B08F
151+  B08F              ;
152+  B08F              ; Draws text shared by the game over and high score screens
153+  B08F              ;
154+  B08F              endlevel_commontext:
155+  B08F CD 7E A9         call screen_setuptext       ; show scores
156+  B092 CD D9 CD         call scores_printscores     ; print the current scores
157+  B095
158+  B095 21 84 84         ld hl,string_gameoverscreen_bestscores
159+  B098 CD 44 86         call string_print
160+  B09B
161+  B09B 06 20            ld b,32
162+  B09D 3E 45            ld a,69
163+  B09F 11 C0 5A         ld de,22528+704                         ; attrs here
164+  B0A2 CD BA A9         call screen_setcolours
165+  B0A5
166+  B0A5 C9               ret
167+  B0A6
168+  B0A6              ;
169+  B0A6              ; Initialises the screen
170+  B0A6              ;
171+  B0A6              endlevel_init:
172+  B0A6              ; We want a green screen.
173+  B0A6 3E 21            ld a,33             ; white ink (7) on black paper (0),
174+  B0A8                                      ; bright (64).
175+  B0A8 CD 49 81         call utilities_clearscreen
176+  B0AB 32 8D 5C         ld (23693),a        ; set our screen colours.
177+  B0AE 3E 00            ld a,0              ; 2 is the code for red.
178+  B0B0 D3 FE            out (254),a         ; write to port 254.
179+  B0B2 C9               ret
# file closed: screen/endlevel.asm
147   B0B3                  include "screen\options.asm"
# file opened: screen/options.asm
  1+  B0B3              ;
  2+  B0B3              ; Show the options screen
  3+  B0B3              ;
  4+  B0B3              options_show:
  5+  B0B3 CD 54 B1         call options_init
  6+  B0B6
  7+  B0B6 21 C0 85         ld hl,string_options_title
  8+  B0B9 CD 44 86         call string_print
  9+  B0BC 21 CA 85         ld hl,string_options_1player
 10+  B0BF CD 44 86         call string_print
 11+  B0C2 21 DA 85         ld hl,string_options_2player
 12+  B0C5 CD 44 86         call string_print
 13+  B0C8 21 EA 85         ld hl,string_options_keyboard
 14+  B0CB CD 44 86         call string_print
 15+  B0CE 21 FD 85         ld hl,string_options_joystick
 16+  B0D1 CD 44 86         call string_print
 17+  B0D4 21 0B 86         ld hl,string_options_start
 18+  B0D7 CD 44 86         call string_print
 19+  B0DA 21 16 86         ld hl,string_options_vanity
 20+  B0DD CD 44 86         call string_print
 21+  B0E0
 22+  B0E0 3A 28 C5         ld a,(game_numberplayers)
 23+  B0E3 FE 01            cp 1
 24+  B0E5 C2 EE B0         jp nz,options_show0
 25+  B0E8 11 C9 58         ld de,22528+201                         ; top row attrs here
 26+  B0EB C3 F1 B0         jp options_show1
 27+  B0EE              options_show0:
 28+  B0EE 11 E9 58         ld de,22528+233                         ; top row attrs here
 29+  B0F1              options_show1:
 30+  B0F1 06 10            ld b,16
 31+  B0F3 3E C7            ld a,199
 32+  B0F5 CD BA A9         call screen_setcolours                  ; highlight current player
 33+  B0F8
 34+  B0F8 3A 2C C5         ld a,(game_control)
 35+  B0FB FE 00            cp 0
 36+  B0FD C2 06 B1         jp nz,options_show6
 37+  B100 11 09 59         ld de,22528+265                         ; top row attrs here
 38+  B103 C3 09 B1         jp options_show7
 39+  B106              options_show6:
 40+  B106 11 29 59         ld de,22528+297                         ; top row attrs here
 41+  B109              options_show7:
 42+  B109 06 10            ld b,16
 43+  B10B 3E C7            ld a,199
 44+  B10D CD BA A9         call screen_setcolours                  ; highlight current control
 45+  B110              options_show8:
 46+  B110 CD 68 81         call utilities_readkey
 47+  B113 FE 31            cp 49                                   ; was 1 pressed
 48+  B115 C2 20 B1         jp nz,options_show2
 49+  B118 21 28 C5         ld hl,game_numberplayers
 50+  B11B 36 01            ld (hl),1
 51+  B11D C3 4E B1         jp options_show9
 52+  B120              options_show2:
 53+  B120 FE 32            cp 50                                   ; was 2 pressed
 54+  B122 C2 2D B1         jp nz,options_show3
 55+  B125 21 28 C5         ld hl,game_numberplayers
 56+  B128 36 02            ld (hl),2
 57+  B12A C3 4E B1         jp options_show9
 58+  B12D              options_show3:
 59+  B12D FE 33            cp 51                                   ; was 3 pressed
 60+  B12F C2 3A B1         jp nz,options_show4
 61+  B132 21 2C C5         ld hl,game_control
 62+  B135 36 00            ld (hl),0
 63+  B137 C3 4E B1         jp options_show9
 64+  B13A              options_show4:
 65+  B13A FE 34            cp 52                                   ; was 4 pressed
 66+  B13C C2 47 B1         jp nz,options_show5
 67+  B13F 21 2C C5         ld hl,game_control
 68+  B142 36 01            ld (hl),1
 69+  B144 C3 4E B1         jp options_show9
 70+  B147              options_show5:
 71+  B147 FE 35            cp 53                                   ; was 5 pressed
 72+  B149 C8               ret z                                   ; exit if so
 73+  B14A C3 10 B1         jp options_show8                         ; otherwise, jump to top
 74+  B14D C9               ret
 75+  B14E              options_show9:
 76+  B14E CD 0C B2         call sound_gemcollected
 77+  B151 C3 B3 B0         jp options_show
 78+  B154
 79+  B154              ;
 80+  B154              ; Initialise the options screen
 81+  B154              ;
 82+  B154              options_init:
 83+  B154 3E 47            ld a,71             ; white ink (7) on black paper (0),
 84+  B156                                      ; bright (64).
 85+  B156 CD 49 81         call utilities_clearscreen
 86+  B159 32 8D 5C         ld (23693),a        ; set our screen colours.
 87+  B15C 3E 00            ld a,0              ; 2 is the code for red.
 88+  B15E D3 FE            out (254),a         ; write to port 254.
 89+  B160
 90+  B160 C9               ret
 91+  B161 C9               ret
# file closed: screen/options.asm
148   B162
149   B162                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  B162
  2+  B162
  3+  B162              ;
  4+  B162              ; Plays a note
  5+  B162              ; Inputs:
  6+  B162              ; d - border
  7+  B162              ; e - pitch
  8+  B162              ; bc - duration
  9+  B162              sound_play:
 10+  B162 7B               ld a,e
 11+  B163 32 6D B1         ld (sound_play2+1),a
 12+  B166 7A           	ld a,d
 13+  B167              sound_play0:
 14+  B167 D3 FE            out (254),a
 15+  B169 1D               dec e
 16+  B16A 20 04            jr nz,sound_play1
 17+  B16C              sound_play2:
 18+  B16C 1E 00            ld e,0
 19+  B16E EE 18            xor 24
 20+  B170              sound_play1:
 21+  B170 10 F5            djnz sound_play0
 22+  B172 0D               dec c
 23+  B173 20 F2            jr nz,sound_play0
 24+  B175 C9               ret
 25+  B176
 26+  B176              sound_gamestart:
 27+  B176 F3               di
 28+  B177 06 03            ld b,3
 29+  B179              sound_gamestart0:
 30+  B179 C5               push bc
 31+  B17A 1E 36            ld e,54
 32+  B17C 01 4B 00         ld bc,75
 33+  B17F 16 02            ld d,2
 34+  B181 CD 62 B1         call sound_play
 35+  B184 1E 4C            ld e,76
 36+  B186 01 4B 00         ld bc,75
 37+  B189 16 02            ld d,2
 38+  B18B CD 62 B1         call sound_play
 39+  B18E C1               pop bc
 40+  B18F 10 E8            djnz sound_gamestart0
 41+  B191 FB               ei
 42+  B192 C9               ret
 43+  B193
 44+  B193              sound_lifestart:
 45+  B193 F3               di
 46+  B194 06 03            ld b,3
 47+  B196              sound_lifestart0:
 48+  B196 C5               push bc
 49+  B197 1E 2D            ld e,45
 50+  B199 01 20 00         ld bc,32
 51+  B19C 16 01            ld d,1
 52+  B19E CD 62 B1         call sound_play
 53+  B1A1 1E 41            ld e,65
 54+  B1A3 01 20 00         ld bc,32
 55+  B1A6 16 01            ld d,1
 56+  B1A8 CD 62 B1         call sound_play
 57+  B1AB 1E 2D            ld e,45
 58+  B1AD 01 20 00         ld bc,32
 59+  B1B0 CD 62 B1         call sound_play
 60+  B1B3 1E 41            ld e,65
 61+  B1B5 01 20 00         ld bc,32
 62+  B1B8 CD 62 B1         call sound_play
 63+  B1BB C1               pop bc
 64+  B1BC 10 D8            djnz sound_lifestart0
 65+  B1BE FB               ei
 66+  B1BF C9               ret
 67+  B1C0
 68+  B1C0              sound_gameover:
 69+  B1C0 F3               di
 70+  B1C1 06 0A            ld b,10
 71+  B1C3 1E 28            ld e,40
 72+  B1C5              sound_gameover0:
 73+  B1C5 C5               push bc
 74+  B1C6 D5               push de
 75+  B1C7 F5               push af
 76+  B1C8 01 20 00         ld bc,32
 77+  B1CB 16 00            ld d,0
 78+  B1CD CD 62 B1         call sound_play
 79+  B1D0 F1               pop af
 80+  B1D1 D1               pop de
 81+  B1D2 3E 0A            ld a,10
 82+  B1D4 83               add e
 83+  B1D5 5F               ld e,a
 84+  B1D6 C6 04            add 4
 85+  B1D8 C1               pop bc
 86+  B1D9 10 EA            djnz sound_gameover0
 87+  B1DB FB               ei
 88+  B1DC C9               ret
 89+  B1DD
 90+  B1DD              sound_scoretick:
 91+  B1DD F3               di
 92+  B1DE 1E 23            ld e,35
 93+  B1E0 01 18 00         ld bc,24
 94+  B1E3 16 00            ld d,0
 95+  B1E5 CD 62 B1         call sound_play
 96+  B1E8 FB               ei
 97+  B1E9 C9               ret
 98+  B1EA
 99+  B1EA              sound_tankalarm:
100+  B1EA F3               di
101+  B1EB 1E 19            ld e,25
102+  B1ED 01 18 00         ld bc,24
103+  B1F0 16 00            ld d,0
104+  B1F2 CD 62 B1         call sound_play
105+  B1F5 FB               ei
106+  B1F6 C9               ret
107+  B1F7
108+  B1F7              sound_laser:
109+  B1F7 16 10        	ld d,16		            ;speaker = bit 4
110+  B1F9 1E 00        	ld e,0		            ;distance between speaker move counter
111+  B1FB 06 80        	ld b,128	            ;overall length counter
112+  B1FD              sound_laser0:
113+  B1FD 7A               ld a,d
114+  B1FE E6 F8        	and 248		            ;keep border colour the same
115+  B200 D3 FE        	out (254),a	            ;move the speaker in or out depending on bit 4
116+  B202 2F           	cpl		                ;toggle, so we alternative between speaker in and out to make sound
117+  B203 57           	ld d,a		            ;store it
118+  B204 4B           	ld c,e		            ;now a pause
119+  B205              sound_laser1:
120+  B205 0D               dec c
121+  B206 20 FD        	jr nz,sound_laser1
122+  B208 1D           	dec e		            ;change to inc e to reverse the sound, or remove to make it a note
123+  B209 10 F2        	djnz sound_laser0	;repeat B=255 times
124+  B20B C9           	ret
125+  B20C
126+  B20C              sound_gemcollected:
127+  B20C 16 10        	ld d,16		            ;speaker = bit 4
128+  B20E 1E 00        	ld e,0		            ;distance between speaker move counter
129+  B210 06 80        	ld b,128	            ;overall length counter
130+  B212              sound_gemcollected0:
131+  B212 7A               ld a,d
132+  B213 E6 F8        	and 248		            ;keep border colour the same
133+  B215 D3 FE        	out (254),a	            ;move the speaker in or out depending on bit 4
134+  B217 2F           	cpl		                ;toggle, so we alternative between speaker in and out to make sound
135+  B218 57           	ld d,a		            ;store it
136+  B219 4B           	ld c,e		            ;now a pause
137+  B21A              sound_gemcollected1:
138+  B21A 0D               dec c
139+  B21B 20 FD        	jr nz,sound_gemcollected1
140+  B21D 1C           	inc e		            ;change to inc e to reverse the sound, or remove to make it a note
141+  B21E 10 F2        	djnz sound_gemcollected0	;repeat B=255 times
142+  B220 C9           	ret
143+  B221
144+  B221              sound_pitchbend:
145+  B221 21 F4 01         ld hl,500 ; starting pitch.
146+  B224 06 FA            ld b,250 ; length of pitch bend.
147+  B226              sound_pitchbend0:
148+  B226 C5                push bc
149+  B227 E5               push hl ; store pitch.
150+  B228 11 01 00         ld de,1 ; very short duration.
151+  B22B CD B5 03         call 949 ; ROM beeper routine.
152+  B22E E1               pop hl ; restore pitch.
153+  B22F 23               inc hl ; pitch going up.
154+  B230 C1               pop bc
155+  B231 10 F3            djnz sound_pitchbend0 ; repeat.
156+  B233 C9               ret
157+  B234
158+  B234              sound_pitchbenddown:
159+  B234 21 EE 02         ld hl,750 ; starting pitch.
160+  B237 06 FA            ld b,250 ; length of pitch bend.
161+  B239              sound_pitchbenddown0:
162+  B239 C5               push bc
163+  B23A E5               push hl ; store pitch.
164+  B23B 11 01 00         ld de,1 ; very short duration.
165+  B23E CD B5 03         call 949 ; ROM beeper routine.
166+  B241 E1               pop hl ; restore pitch.
167+  B242 2B               dec hl ; pitch going down.
168+  B243 C1               pop bc
169+  B244 10 F3            djnz sound_pitchbenddown0 ; repeat.
170+  B246 C9               ret
171+  B247
172+  B247              sound_rockfell:
173+  B247 08               ex af,af'
174+  B248 1E 32            ld e,50 ; repeat 250 times.
175+  B24A 21 00 00         ld hl,0 ; start pointer in ROM.
176+  B24D              sound_rockfell2
177+  B24D D5               push de
178+  B24E 06 20            ld b,32 ; length of step.
179+  B250 C5           sound_rockfell0 push bc
180+  B251 7E               ld a,(hl) ; next "random" number.
181+  B252 23               inc hl ; pointer.
182+  B253 E6 F8            and 248 ; we want a black border.
183+  B255 D3 FE            out (254),a ; write to speaker.
184+  B257 7B               ld a,e ; as e gets smaller...
185+  B258 2F               cpl ; ...we increase the delay.
186+  B259 3D           sound_rockfell1 dec a ; decrement loop counter.
187+  B25A 20 FD            jr nz,sound_rockfell1 ; delay loop.
188+  B25C C1               pop bc
189+  B25D 10 F1            djnz sound_rockfell0 ; next step.
190+  B25F D1               pop de
191+  B260 7B               ld a,e
192+  B261 D6 18            sub 24 ; size of step.
193+  B263 FE 1E            cp 30 ; end of range.
194+  B265 CA 76 B2         jp z,sound_rockfell5
195+  B268 DA 76 B2         jp c, sound_rockfell5
196+  B26B 5F               ld e,a
197+  B26C 2F               cpl
198+  B26D 06 28        sound_rockfell3 ld b,40 ; silent period.
199+  B26F 10 FE        sound_rockfell4 djnz sound_rockfell4
200+  B271 3D               dec a
201+  B272 20 F9            jr nz,sound_rockfell3
202+  B274 18 D7            jr sound_rockfell2
203+  B276              sound_rockfell5
204+  B276 08               ex af,af'
205+  B277 C9               ret
206+  B278
207+  B278              sound_tankshoot:
208+  B278 08               ex af,af'
209+  B279 1E 32            ld e,50 ; repeat 250 times.
210+  B27B 21 00 00         ld hl,0 ; start pointer in ROM.
211+  B27E              sound_tankshoot2
212+  B27E D5               push de
213+  B27F 06 10            ld b,16 ; length of step.
214+  B281 C5           sound_tankshoot0 push bc
215+  B282 7E               ld a,(hl) ; next "random" number.
216+  B283 23               inc hl ; pointer.
217+  B284 E6 F8            and 248 ; we want a black border.
218+  B286 D3 FE            out (254),a ; write to speaker.
219+  B288 7B               ld a,e ; as e gets smaller...
220+  B289 2F               cpl ; ...we increase the delay.
221+  B28A 3D           sound_tankshoot1 dec a ; decrement loop counter.
222+  B28B 20 FD            jr nz,sound_tankshoot1 ; delay loop.
223+  B28D C1               pop bc
224+  B28E 10 F1            djnz sound_tankshoot0 ; next step.
225+  B290 D1               pop de
226+  B291 7B               ld a,e
227+  B292 D6 18            sub 24 ; size of step.
228+  B294 FE 1E            cp 30 ; end of range.
229+  B296 CA A7 B2         jp z,sound_tankshoot5
230+  B299 DA A7 B2         jp c, sound_tankshoot5
231+  B29C 5F               ld e,a
232+  B29D 2F               cpl
233+  B29E 06 28        sound_tankshoot3 ld b,40 ; silent period.
234+  B2A0 10 FE        sound_tankshoot4 djnz sound_tankshoot4
235+  B2A2 3D               dec a
236+  B2A3 20 F9            jr nz,sound_tankshoot3
237+  B2A5 18 D7            jr sound_tankshoot2
238+  B2A7              sound_tankshoot5
239+  B2A7 08               ex af,af'
240+  B2A8 C9               ret
241+  B2A9
242+  B2A9              ; Call this every time you want to initialise a sound effect
243+  B2A9              ; A = Variable 1
244+  B2A9              ; B = Variable 2
245+  B2A9              ; C = Duration of overall sound effect
246+  B2A9              ; D = Duration of each step of the sound effect
247+  B2A9              ;
248+  B2A9              soundfx_a_init:
249+  B2A9 32 D0 B2         ld (soundfx_a_v2+1),a
250+  B2AC 78               ld a,b
251+  B2AD 32 D9 B2         ld (soundfx_a_v3+1),a
252+  B2B0 79               ld a,c
253+  B2B1 32 BE B2         ld (soundfx_a_main+1),a
254+  B2B4 7A               ld a,d
255+  B2B5 32 C5 B2         ld (soundfx_a_v1+1),a
256+  B2B8 AF               xor a
257+  B2B9 32 E2 B2         ld (soundfx_a_v4),a
258+  B2BC C9               ret
259+  B2BD
260+  B2BD              ; Call this during your main loop
261+  B2BD              ; It will play one step of the sound effect each pass
262+  B2BD              ; until the complete sound effect has finished
263+  B2BD              ;
264+  B2BD              soundfx_a_main:
265+  B2BD 3E 00            ld a,0
266+  B2BF 3D               dec a
267+  B2C0 C8               ret z
268+  B2C1 32 BE B2         ld (soundfx_a_main+1),a
269+  B2C4              soundfx_a_v1:
270+  B2C4 06 00            ld b,0
271+  B2C6 21 E2 B2         ld hl,soundfx_a_v4
272+  B2C9              soundfx_a_l1:
273+  B2C9 48               ld c,b
274+  B2CA 3E 08            ld a,%00001000
275+  B2CC D3 FE            out (254),a
276+  B2CE 7E               ld a,(hl)
277+  B2CF              soundfx_a_v2:
278+  B2CF EE 00            xor 0
279+  B2D1 47               ld b,a
280+  B2D2 10 FE            djnz $
281+  B2D4 AF               xor a
282+  B2D5 D3 FE            out (254),a
283+  B2D7 7E               ld a,(hl)
284+  B2D8              soundfx_a_v3:
285+  B2D8 EE 00            xor 0
286+  B2DA 47               ld b,a
287+  B2DB 10 FE            djnz $
288+  B2DD 35               dec (hl)
289+  B2DE 41               ld b,c
290+  B2DF 10 E8            djnz soundfx_a_l1
291+  B2E1 C9               ret
292+  B2E2
293+  B2E2              soundfx_a_v4:
294+  B2E2 00               defb 0
# file closed: sound/sound.asm
150   B2E3
151   B2E3                  include "leveldata\level.asm"
# file opened: leveldata/level.asm
  1+  B2E3              ; ###############################################################
  2+  B2E3              ; Data for level 1
  3+  B2E3              ; ###############################################################
  4+  B2E3              level_layout:
  5+  B2E3
  6+  B2E3                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  B2E3
  8+  B2E3 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  B2E7 05 05 05 05
  8+  B2EB 05 05 05 05
  8+  B2EF 05 05 02 01
  8+  B2F3 01 01 03 05
  8+  B2F7 05 05 05 05
  8+  B2FB 05 05 05 05
  8+  B2FF 05 05 00 00
  9+  B303 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  B307 05 05 05 05
  9+  B30B 05 05 05 05
  9+  B30F 02 01 01 01
  9+  B313 01 01 01 01
  9+  B317 03 05 05 05
  9+  B31B 05 05 05 05
  9+  B31F 05 05 00 00
 10+  B323 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  B327 05 05 05 05
 10+  B32B 05 05 02 01
 10+  B32F 01 01 01 01
 10+  B333 01 01 01 01
 10+  B337 01 01 03 05
 10+  B33B 0D 0D 0D 0D
 10+  B33F 0D 0D 00 00
 11+  B343 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  B347 01 01 00 01
 11+  B34B 01 01 01 01
 11+  B34F 01 01 01 01
 11+  B353 01 01 01 01
 11+  B357 01 01 01 03
 11+  B35B 05 05 05 05
 11+  B35F 05 05 00 00
 12+  B363 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  B367 04 04 04 04
 12+  B36B 04 04 01 01
 12+  B36F 01 01 01 01
 12+  B373 01 01 01 01
 12+  B377 01 01 01 01
 12+  B37B 01 01 01 01
 12+  B37F 00 01 00 00
 13+  B383 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  B387 04 04 04 04
 13+  B38B 04 04 04 04
 13+  B38F 01 01 01 01
 13+  B393 01 01 01 01
 13+  B397 01 01 01 01
 13+  B39B 00 00 00 00
 13+  B39F 00 01 00 00
 14+  B3A3 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  B3A7 04 01 01 01
 14+  B3AB 01 01 04 04
 14+  B3AF 04 04 01 01
 14+  B3B3 01 01 01 01
 14+  B3B7 01 00 00 00
 14+  B3BB 00 01 01 01
 14+  B3BF 01 01 00 00
 15+  B3C3 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  B3C7 04 04 04 04
 15+  B3CB 04 01 04 04
 15+  B3CF 04 04 04 04
 15+  B3D3 04 04 00 00
 15+  B3D7 00 00 04 04
 15+  B3DB 04 04 04 04
 15+  B3DF 04 01 00 00
 16+  B3E3 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  B3E7 01 04 01 01
 16+  B3EB 01 01 04 04
 16+  B3EF 04 04 04 04
 16+  B3F3 04 04 00 04
 16+  B3F7 04 04 04 04
 16+  B3FB 04 04 04 04
 16+  B3FF 04 01 00 00
 17+  B403 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  B407 00 00 00 00
 17+  B40B 00 04 04 04
 17+  B40F 04 04 04 04
 17+  B413 04 04 00 04
 17+  B417 04 04 04 04
 17+  B41B 04 04 04 04
 17+  B41F 04 01 00 00
 18+  B423 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  B427 15 15 15 15
 18+  B42B 15 01 04 04
 18+  B42F 04 04 04 04
 18+  B433 04 04 00 04
 18+  B437 04 04 04 04
 18+  B43B 04 04 04 04
 18+  B43F 04 01 00 00
 19+  B443 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B447 00 00 00 00
 19+  B44B 00 01 04 04
 19+  B44F 04 04 04 04
 19+  B453 04 04 00 04
 19+  B457 04 04 04 04
 19+  B45B 04 00 00 00
 19+  B45F 00 01 00 00
 20+  B463 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B467 00 00 00 00
 20+  B46B 00 01 04 04
 20+  B46F 04 04 04 04
 20+  B473 04 04 00 04
 20+  B477 04 04 04 04
 20+  B47B 04 00 04 04
 20+  B47F 00 01 00 00
 21+  B483 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B487 06 06 06 06
 21+  B48B 06 01 04 04
 21+  B48F 04 04 04 04
 21+  B493 04 04 00 04
 21+  B497 04 04 04 04
 21+  B49B 04 00 04 04
 21+  B49F 00 01 00 00
 22+  B4A3 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B4A7 1A 1A 1A 1A
 22+  B4AB 1A 01 04 00
 22+  B4AF 00 00 00 00
 22+  B4B3 00 00 00 00
 22+  B4B7 00 00 00 00
 22+  B4BB 00 00 04 04
 22+  B4BF 00 01 00 00
 23+  B4C3 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B4C7 1A 1A 1A 1A
 23+  B4CB 1A 01 04 00
 23+  B4CF 04 04 04 04
 23+  B4D3 04 04 00 04
 23+  B4D7 04 04 00 04
 23+  B4DB 04 04 04 04
 23+  B4DF 00 01 00 00
 24+  B4E3 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B4E7 1A 1A 1A 1A
 24+  B4EB 1A 01 04 00
 24+  B4EF 04 04 04 04
 24+  B4F3 04 04 00 04
 24+  B4F7 04 04 00 04
 24+  B4FB 04 04 04 04
 24+  B4FF 00 01 00 00
 25+  B503 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B507 01 01 01 01
 25+  B50B 01 01 04 00
 25+  B50F 04 04 04 04
 25+  B513 04 04 00 04
 25+  B517 04 04 00 04
 25+  B51B 04 04 04 04
 25+  B51F 00 01 00 00
 26+  B523 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B527 04 04 04 04
 26+  B52B 04 04 04 00
 26+  B52F 04 04 04 04
 26+  B533 04 04 00 04
 26+  B537 04 04 00 00
 26+  B53B 00 00 04 04
 26+  B53F 04 01 00 00
 27+  B543 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B547 04 04 00 00
 27+  B54B 00 00 00 00
 27+  B54F 04 04 04 04
 27+  B553 04 04 00 04
 27+  B557 04 04 04 04
 27+  B55B 04 00 04 04
 27+  B55F 04 01 00 00
 28+  B563 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B567 04 04 00 04
 28+  B56B 04 04 04 04
 28+  B56F 04 04 04 04
 28+  B573 04 04 00 04
 28+  B577 04 04 04 04
 28+  B57B 04 00 04 04
 28+  B57F 04 01 00 00
 29+  B583 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B587 04 04 00 04
 29+  B58B 04 04 01 01
 29+  B58F 01 01 01 01
 29+  B593 01 01 01 01
 29+  B597 01 01 01 01
 29+  B59B 04 00 04 04
 29+  B59F 04 01 00 00
 30+  B5A3 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B5A7 04 04 00 04
 30+  B5AB 04 04 01 00
 30+  B5AF 00 00 00 00
 30+  B5B3 00 00 00 00
 30+  B5B7 00 00 00 01
 30+  B5BB 04 00 04 04
 30+  B5BF 04 01 00 00
 31+  B5C3 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B5C7 04 04 00 04
 31+  B5CB 04 04 01 00
 31+  B5CF 00 00 00 00
 31+  B5D3 00 00 00 00
 31+  B5D7 00 00 00 01
 31+  B5DB 04 00 04 04
 31+  B5DF 04 01 00 00
 32+  B5E3 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B5E7 04 04 00 04
 32+  B5EB 04 04 01 00
 32+  B5EF 00 00 00 00
 32+  B5F3 00 00 00 00
 32+  B5F7 00 00 00 01
 32+  B5FB 04 00 04 04
 32+  B5FF 04 01 00 00
 33+  B603 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B607 04 04 00 04
 33+  B60B 04 04 04 00
 33+  B60F 00 00 00 00
 33+  B613 00 00 00 00
 33+  B617 00 00 00 04
 33+  B61B 04 04 04 04
 33+  B61F 04 01 00 00
 34+  B623 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B627 04 04 04 04
 34+  B62B 04 04 01 00
 34+  B62F 00 00 00 00
 34+  B633 00 00 00 00
 34+  B637 00 00 00 01
 34+  B63B 04 04 04 04
 34+  B63F 04 01 00 00
 35+  B643 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B647 04 04 04 04
 35+  B64B 04 04 01 00
 35+  B64F 00 00 01 00
 35+  B653 00 00 00 01
 35+  B657 00 00 00 01
 35+  B65B 04 04 04 04
 35+  B65F 04 01 00 00
 36+  B663 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B667 01 01 01 01
 36+  B66B 01 01 01 01
 36+  B66F 01 01 01 01
 36+  B673 01 01 01 01
 36+  B677 01 01 01 01
 36+  B67B 01 01 01 01
 36+  B67F 01 01 00 00
 37+  B683
 38+  B683              ; ###############################################################
 39+  B683              ; Object data: horiz, vert, state, memh, meml
 40+  B683              ; ###############################################################
 41+  B683              level_rocks:
 42+  B683 09 04 00 00      defb 9,4,0,0,0
 42+  B687 00
 43+  B688 0C 07 00 00      defb 12,7,0,0,0
 43+  B68C 00
 44+  B68D 10 07 00 00      defb 16,7,0,0,0
 44+  B691 00
 45+  B692 0B 08 00 00      defb 11,8,0,0,0
 45+  B696 00
 46+  B697 0A 0A 00 00      defb 10,10,0,0,0
 46+  B69B 00
 47+  B69C 0C 0A 00 00      defb 12,10,0,0,0
 47+  B6A0 00
 48+  B6A1 0D 09 00 00      defb 13,9,0,0,0
 48+  B6A5 00
 49+  B6A6 0E 08 00 00      defb 14,8,0,0,0
 49+  B6AA 00
 50+  B6AB 0F 0B 00 00      defb 15,11,0,0,0
 50+  B6AF 00
 51+  B6B0 0B 0C 00 00      defb 11,12,0,0,0
 51+  B6B4 00
 52+  B6B5 11 0C 00 00      defb 17,12,0,0,0
 52+  B6B9 00
 53+  B6BA 13 08 00 00      defb 19,8,0,0,0
 53+  B6BE 00
 54+  B6BF 16 09 00 00      defb 22,9,0,0,0
 54+  B6C3 00
 55+  B6C4 13 0A 00 00      defb 19,10,0,0,0
 55+  B6C8 00
 56+  B6C9 15 0A 00 00      defb 21,10,0,0,0
 56+  B6CD 00
 57+  B6CE 15 0C 00 00      defb 21,12,0,0,0
 57+  B6D2 00
 58+  B6D3 16 0C 00 00      defb 22,12,0,0,0
 58+  B6D7 00
 59+  B6D8 18 0A 00 00      defb 24,10,0,0,0
 59+  B6DC 00
 60+  B6DD 19 09 00 00      defb 25,9,0,0,0
 60+  B6E1 00
 61+  B6E2 1C 09 00 00      defb 28,9,0,0,0
 61+  B6E6 00
 62+  B6E7 1B 0C 00 00      defb 27,12,0,0,0
 62+  B6EB 00
 63+  B6EC 1A 0D 00 00      defb 26,13,0,0,0
 63+  B6F0 00
 64+  B6F1 19 0E 00 00      defb 25,14,0,0,0
 64+  B6F5 00
 65+  B6F6 19 10 00 00      defb 25,16,0,0,0
 65+  B6FA 00
 66+  B6FB 1A 11 00 00      defb 26,17,0,0,0
 66+  B6FF 00
 67+  B700 1B 11 00 00      defb 27,17,0,0,0
 67+  B704 00
 68+  B705 1C 12 00 00      defb 28,18,0,0,0
 68+  B709 00
 69+  B70A 1A 13 00 00      defb 26,19,0,0,0
 69+  B70E 00
 70+  B70F 1B 15 00 00      defb 27,21,0,0,0
 70+  B713 00
 71+  B714 1A 17 00 00      defb 26,23,0,0,0
 71+  B718 00
 72+  B719 1B 18 00 00      defb 27,24,0,0,0
 72+  B71D 00
 73+  B71E 19 18 00 00      defb 25,24,0,0,0
 73+  B722 00
 74+  B723 18 17 00 00      defb 24,23,0,0,0
 74+  B727 00
 75+  B728 13 14 00 00      defb 19,20,0,0,0
 75+  B72C 00
 76+  B72D 14 12 00 00      defb 20,18,0,0,0
 76+  B731 00
 77+  B732 14 10 00 00      defb 20,16,0,0,0
 77+  B736 00
 78+  B737 15 10 00 00      defb 21,16,0,0,0
 78+  B73B 00
 79+  B73C 16 12 00 00      defb 22,18,0,0,0
 79+  B740 00
 80+  B741 11 14 00 00      defb 17,20,0,0,0
 80+  B745 00
 81+  B746 0D 11 00 00      defb 13,17,0,0,0
 81+  B74A 00
 82+  B74B 0C 13 00 00      defb 12,19,0,0,0
 82+  B74F 00
 83+  B750 0B 13 00 00      defb 11,19,0,0,0
 83+  B754 00
 84+  B755 0A 11 00 00      defb 10,17,0,0,0
 84+  B759 00
 85+  B75A 05 12 00 00      defb 5,18,0,0,0
 85+  B75E 00
 86+  B75F 07 16 00 00      defb 7,22,0,0,0
 86+  B763 00
 87+  B764 09 16 00 00      defb 9,22,0,0,0
 87+  B768 00
 88+  B769 07 18 00 00      defb 7,24,0,0,0
 88+  B76D 00
 89+  B76E 05 18 00 00      defb 5,24,0,0,0
 89+  B772 00
 90+  B773 06 19 00 00      defb 6,25,0,0,0
 90+  B777 00
 91+  B778 08 19 00 00      defb 8,25,0,0,0
 91+  B77C 00
 92+  B77D 04 17 00 00      defb 4,23,0,0,0
 92+  B781 00
 93+  B782 FF               defb 255
 94+  B783
 95+  B783              level_rocks_alt:
 96+  B783 09 04 00 00      defb 9,4,0,0,0
 96+  B787 00
 97+  B788 0C 07 00 00      defb 12,7,0,0,0
 97+  B78C 00
 98+  B78D 0B 07 00 00      defb 11,7,0,0,0
 98+  B791 00
 99+  B792 0A 08 00 00      defb 10,8,0,0,0
 99+  B796 00
100+  B797 10 07 00 00      defb 16,7,0,0,0
100+  B79B 00
101+  B79C 0E 08 00 00      defb 14,8,0,0,0
101+  B7A0 00
102+  B7A1 0D 09 00 00      defb 13,9,0,0,0
102+  B7A5 00
103+  B7A6 0C 0A 00 00      defb 12,10,0,0,0
103+  B7AA 00
104+  B7AB 0A 0B 00 00      defb 10,11,0,0,0
104+  B7AF 00
105+  B7B0 0B 0C 00 00      defb 11,12,0,0,0
105+  B7B4 00
106+  B7B5 0F 0B 00 00      defb 15,11,0,0,0
106+  B7B9 00
107+  B7BA 11 0C 00 00      defb 17,12,0,0,0
107+  B7BE 00
108+  B7BF 15 0B 00 00      defb 21,11,0,0,0
108+  B7C3 00
109+  B7C4 16 0C 00 00      defb 22,12,0,0,0
109+  B7C8 00
110+  B7C9 19 09 00 00      defb 25,9,0,0,0
110+  B7CD 00
111+  B7CE 1C 09 00 00      defb 28,9,0,0,0
111+  B7D2 00
112+  B7D3 1B 0C 00 00      defb 27,12,0,0,0
112+  B7D7 00
113+  B7D8 1B 0E 00 00      defb 27,14,0,0,0
113+  B7DC 00
114+  B7DD 1A 0F 00 00      defb 26,15,0,0,0
114+  B7E1 00
115+  B7E2 1B 10 00 00      defb 27,16,0,0,0
115+  B7E6 00
116+  B7E7 1C 12 00 00      defb 28,18,0,0,0
116+  B7EB 00
117+  B7EC 1A 13 00 00      defb 26,19,0,0,0
117+  B7F0 00
118+  B7F1 1A 15 00 00      defb 26,21,0,0,0
118+  B7F5 00
119+  B7F6 1B 17 00 00      defb 27,23,0,0,0
119+  B7FA 00
120+  B7FB 1A 17 00 00      defb 26,23,0,0,0
120+  B7FF 00
121+  B800 19 18 00 00      defb 25,24,0,0,0
121+  B804 00
122+  B805 18 17 00 00      defb 24,23,0,0,0
122+  B809 00
123+  B80A 17 10 00 00      defb 23,16,0,0,0
123+  B80E 00
124+  B80F 15 10 00 00      defb 21,16,0,0,0
124+  B813 00
125+  B814 14 12 00 00      defb 20,18,0,0,0
125+  B818 00
126+  B819 13 14 00 00      defb 19,20,0,0,0
126+  B81D 00
127+  B81E 10 13 00 00      defb 16,19,0,0,0
127+  B822 00
128+  B823 0D 14 00 00      defb 13,20,0,0,0
128+  B827 00
129+  B828 0E 11 00 00      defb 14,17,0,0,0
129+  B82C 00
130+  B82D 0C 12 00 00      defb 12,18,0,0,0
130+  B831 00
131+  B832 0A 11 00 00      defb 10,17,0,0,0
131+  B836 00
132+  B837 05 12 00 00      defb 5,18,0,0,0
132+  B83B 00
133+  B83C 09 14 00 00      defb 9,20,0,0,0
133+  B840 00
134+  B841 08 15 00 00      defb 8,21,0,0,0
134+  B845 00
135+  B846 07 16 00 00      defb 7,22,0,0,0
135+  B84A 00
136+  B84B 08 17 00 00      defb 8,23,0,0,0
136+  B84F 00
137+  B850 07 18 00 00      defb 7,24,0,0,0
137+  B854 00
138+  B855 08 1A 00 00      defb 8,26,0,0,0
138+  B859 00
139+  B85A 06 19 00 00      defb 6,25,0,0,0
139+  B85E 00
140+  B85F 05 18 00 00      defb 5,24,0,0,0
140+  B863 00
141+  B864 04 17 00 00      defb 4,23,0,0,0
141+  B868 00
142+  B869 FF               defb 255
143+  B86A
144+  B86A              level_missiles:
145+  B86A 0B 17 00 00      defb 11,23,0,0,0
145+  B86E 00
146+  B86F 0B 16 00 00      defb 11,22,0,0,0
146+  B873 00
147+  B874 0C 17 00 00      defb 12,23,0,0,0
147+  B878 00
148+  B879 0C 16 00 00      defb 12,22,0,0,0
148+  B87D 00
149+  B87E 0D 17 00 00      defb 13,23,0,0,0
149+  B882 00
150+  B883 0D 16 00 00      defb 13,22,0,0,0
150+  B887 00
151+  B888 0E 17 00 00      defb 14,23,0,0,0
151+  B88C 00
152+  B88D 0E 16 00 00      defb 14,22,0,0,0
152+  B891 00
153+  B892 0F 17 00 00      defb 15,23,0,0,0
153+  B896 00
154+  B897 0F 16 00 00      defb 15,22,0,0,0
154+  B89B 00
155+  B89C 10 17 00 00      defb 16,23,0,0,0
155+  B8A0 00
156+  B8A1 10 16 00 00      defb 16,22,0,0,0
156+  B8A5 00
157+  B8A6 11 17 00 00      defb 17,23,0,0,0
157+  B8AA 00
158+  B8AB 11 16 00 00      defb 17,22,0,0,0
158+  B8AF 00
159+  B8B0 12 17 00 00      defb 18,23,0,0,0
159+  B8B4 00
160+  B8B5 12 16 00 00      defb 18,22,0,0,0
160+  B8B9 00
161+  B8BA 13 17 00 00      defb 19,23,0,0,0
161+  B8BE 00
162+  B8BF 13 16 00 00      defb 19,22,0,0,0
162+  B8C3 00
163+  B8C4 14 17 00 00      defb 20,23,0,0,0
163+  B8C8 00
164+  B8C9 14 16 00 00      defb 20,22,0,0,0
164+  B8CD 00
165+  B8CE 15 17 00 00      defb 21,23,0,0,0
165+  B8D2 00
166+  B8D3 15 16 00 00      defb 21,22,0,0,0
166+  B8D7 00
167+  B8D8 16 17 00 00      defb 22,23,0,0,0
167+  B8DC 00
168+  B8DD 16 16 00 00      defb 22,22,0,0,0
168+  B8E1 00
169+  B8E2 FF               defb 255
170+  B8E3
171+  B8E3              ;
172+  B8E3              ; Diamonds: x,y,state,mem1+mem2
173+  B8E3              ;
174+  B8E3              level_diamonds:
175+  B8E3 0C 1B 00 00      defb 12,27,0,0,0
175+  B8E7 00
176+  B8E8 10 1B 00 00      defb 16,27,0,0,0
176+  B8EC 00
177+  B8ED 15 1B 00 00      defb 21,27,0,0,0
177+  B8F1 00
178+  B8F2 FF               defb 255
179+  B8F3
180+  B8F3              level_gems:
181+  B8F3 12 14 00 00      defb 18,20,0,0,0
181+  B8F7 00
182+  B8F8 06 18 00 00      defb 6,24,0,0,0
182+  B8FC 00
183+  B8FD 19 17 00 00      defb 25,23,0,0,0
183+  B901 00
184+  B902 1C 11 00 00      defb 28,17,0,0,0
184+  B906 00
185+  B907 FF               defb 255
186+  B908              ;
187+  B908              ; Score area colours
188+  B908              ;
189+  B908              score_colours:
190+  B908 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
190+  B90C 47 47 47 47
190+  B910 47 47 47 42
190+  B914 43 43 43 43
190+  B918 43 43 43 43
190+  B91C 42 47 47 47
190+  B920 47 47 47 47
190+  B924 47 47 47 47
191+  B928 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
191+  B92C 47 47 47 47
191+  B930 47 47 47 46
191+  B934 46 46 46 46
191+  B938 46 46 46 46
191+  B93C 46 47 47 47
191+  B940 47 47 47 47
191+  B944 47 47 47 47
192+  B948
193+  B948              high_score_colours:
194+  B948 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
194+  B94C 42 42 47 47
194+  B950 47 47 47 47
194+  B954 43 43 43 47
194+  B958 47 47 47 47
194+  B95C 47 46 46 46
194+  B960 47 47 47 47
194+  B964 47 47 00 00
# file closed: leveldata/level.asm
152   B968                  include "graphics\font.asm"
# file opened: graphics/font.asm
  1+  B968              font:
  2+  B968 00 00 00...  	defs 256
  3+  BA68              	; end 1
  4+  BA68 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; space
  4+  BA6C 00 00 00 00
  5+  BA70 18 18 18 18  	defb	  24, 24, 24, 24, 24,  0, 24, 0 ;!
  5+  BA74 18 00 18 00
  6+  BA78 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; "
  6+  BA7C 00 00 00 00
  7+  BA80 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; #
  7+  BA84 00 00 00 00
  8+  BA88 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; $
  8+  BA8C 00 00 00 00
  9+  BA90 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; %
  9+  BA94 00 00 00 00
 10+  BA98 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; &
 10+  BA9C 00 00 00 00
 11+  BAA0 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; '
 11+  BAA4 00 00 00 00
 12+  BAA8 0C 18 30 30  	defb	  12, 24, 48, 48, 48, 24, 12, 0; (
 12+  BAAC 30 18 0C 00
 13+  BAB0 30 18 0C 0C  	defb	  48, 24, 12, 12, 12, 24, 48,  0 ; )
 13+  BAB4 0C 18 30 00
 14+  BAB8 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; *
 14+  BABC 00 00 00 00
 15+  BAC0 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; +
 15+  BAC4 00 00 00 00
 16+  BAC8 00 00 00 00  	defb	  0,  0,  0,  0,  0,  32, 96,  0 ; ,
 16+  BACC 00 20 60 00
 17+  BAD0 00 00 00 3C  	defb	  0,  0,  0, 60,  0,  0,  0,  0 ; -
 17+  BAD4 00 00 00 00
 18+  BAD8 00 00 00 00  	defb	  0,  0,  0,  0,  0,  96,96,  0 ; .
 18+  BADC 00 60 60 00
 19+  BAE0 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; /
 19+  BAE4 00 00 00 00
 20+  BAE8 1C 26 63 63  	defb	 28, 38, 99, 99, 99, 50, 28,  0 ; 0
 20+  BAEC 63 32 1C 00
 21+  BAF0 0C 1C 0C 0C  	defb	   12, 28, 12, 12, 12, 12, 63,0 ; 1
 21+  BAF4 0C 0C 3F 00
 22+  BAF8 3E 63 07 1E  	defb	  62, 99,  7, 30, 60, 96,127, 0 ; 2
 22+  BAFC 3C 60 7F 00
 23+  BB00 3F 06 0C 1E  	defb	  63,  6, 12, 30,  3, 51, 30, 0 ; 3
 23+  BB04 03 33 1E 00
 24+  BB08 0E 1E 36 66  	defb	  14, 30, 54,102,127,  6,  6, 0 ; 4
 24+  BB0C 7F 06 06 00
 25+  BB10 7E 40 7E 03  	defb	 126, 64,126,  3,  3, 99, 62, 0 ; 5
 25+  BB14 03 63 3E 00
 26+  BB18 1E 30 60 7E  	defb	 30, 48, 96,126, 99, 99, 62,  0 ; 6
 26+  BB1C 63 63 3E 00
 27+  BB20 7F 63 06 0C  	defb	  127, 99,  6, 12, 24, 24, 24,0 ; 7
 27+  BB24 18 18 18 00
 28+  BB28 3C 62 72 3C  	defb	  60, 98,114, 60, 79, 67,62,0   ; 8
 28+  BB2C 4F 43 3E 00
 29+  BB30 3E 63 63 3F  	defb	  62, 99, 99, 63,  3,  6, 60, 0 ; 9
 29+  BB34 03 06 3C 00
 30+  BB38 00 00 18 18  	defb	  0,  0, 24, 24,  0,  24,24,  0 ; :
 30+  BB3C 00 18 18 00
 31+  BB40 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ;
 31+  BB44 00 00 00 00
 32+  BB48 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; <
 32+  BB4C 00 00 00 00
 33+  BB50 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; =
 33+  BB54 00 00 00 00
 34+  BB58 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; >
 34+  BB5C 00 00 00 00
 35+  BB60 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ?
 35+  BB64 00 00 00 00
 36+  BB68              	; end 2
 37+  BB68 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; @
 37+  BB6C 00 00 00 00
 38+  BB70 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 38+  BB74 7F 63 63 00
 39+  BB78 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 39+  BB7C 63 63 7E 00
 40+  BB80 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 40+  BB84 60 33 1E 00
 41+  BB88 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 41+  BB8C 63 66 7C 00
 42+  BB90 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 42+  BB94 60 60 7F 00
 43+  BB98 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 43+  BB9C 60 60 60 00
 44+  BBA0 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 44+  BBA4 63 33 1F 00
 45+  BBA8 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 45+  BBAC 63 63 63 00
 46+  BBB0 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 46+  BBB4 0C 0C 3F 00
 47+  BBB8 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 47+  BBBC 03 63 3E 00
 48+  BBC0 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 48+  BBC4 7C 6E 67 00
 49+  BBC8 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 49+  BBCC 30 30 3F 00
 50+  BBD0 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 50+  BBD4 6B 63 63 00
 51+  BBD8 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 51+  BBDC 6F 67 63 00
 52+  BBE0 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 52+  BBE4 63 63 3E 00
 53+  BBE8 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 53+  BBEC 7E 60 60 00
 54+  BBF0 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 54+  BBF4 6F 66 3D 00
 55+  BBF8 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 55+  BBFC 7C 6E 67 00
 56+  BC00 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 56+  BC04 03 63 3E 00
 57+  BC08 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 57+  BC0C 18 18 18 00
 58+  BC10 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 58+  BC14 63 63 3E 00
 59+  BC18 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 59+  BC1C 3E 1C 08 00
 60+  BC20 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 60+  BC24 7F 36 22 00
 61+  BC28 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 61+  BC2C 3E 77 63 00
 62+  BC30 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 62+  BC34 0C 0C 0C 00
 63+  BC38 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 63+  BC3C 38 70 7F 00
 64+  BC40 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; [
 64+  BC44 00 00 00 00
 65+  BC48 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; \
 65+  BC4C 00 00 00 00
 66+  BC50 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ]
 66+  BC54 00 00 00 00
 67+  BC58 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ^
 67+  BC5C 00 00 00 00
 68+  BC60 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; _
 68+  BC64 00 00 00 00
 69+  BC68              	; end 3
 70+  BC68 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; £
 70+  BC6C 00 00 00 00
 71+  BC70 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 71+  BC74 7F 63 63 00
 72+  BC78 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 72+  BC7C 63 63 7E 00
 73+  BC80 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 73+  BC84 60 33 1E 00
 74+  BC88 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 74+  BC8C 63 66 7C 00
 75+  BC90 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 75+  BC94 60 60 7F 00
 76+  BC98 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 76+  BC9C 60 60 60 00
 77+  BCA0 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 77+  BCA4 63 33 1F 00
 78+  BCA8 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 78+  BCAC 63 63 63 00
 79+  BCB0 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 79+  BCB4 0C 0C 3F 00
 80+  BCB8 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 80+  BCBC 03 63 3E 00
 81+  BCC0 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 81+  BCC4 7C 6E 67 00
 82+  BCC8 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 82+  BCCC 30 30 3F 00
 83+  BCD0 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 83+  BCD4 6B 63 63 00
 84+  BCD8 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 84+  BCDC 6F 67 63 00
 85+  BCE0 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 85+  BCE4 63 63 3E 00
 86+  BCE8 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 86+  BCEC 7E 60 60 00
 87+  BCF0 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 87+  BCF4 6F 66 3D 00
 88+  BCF8 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 88+  BCFC 7C 6E 67 00
 89+  BD00 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 89+  BD04 03 63 3E 00
 90+  BD08 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 90+  BD0C 18 18 18 00
 91+  BD10 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 91+  BD14 63 63 3E 00
 92+  BD18 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 92+  BD1C 3E 1C 08 00
 93+  BD20 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 93+  BD24 7F 36 22 00
 94+  BD28 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 94+  BD2C 3E 77 63 00
 95+  BD30 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 95+  BD34 0C 0C 0C 00
 96+  BD38 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 96+  BD3C 38 70 7F 00
 97+  BD40 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 97+  BD44 00 00 00 00
 98+  BD48 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 98+  BD4C 00 00 00 00
 99+  BD50 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 99+  BD54 00 00 00 00
100+  BD58 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
100+  BD5C 00 00 00 00
101+  BD60 3C 42 99 A1  	defb	  60, 66,153,161,161,153, 66, 60 ; 	©
101+  BD64 A1 99 42 3C
# file closed: graphics/font.asm
153   BD68                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  BD68              ; Tiles graphics.
  2+  BD68              sprites:
  3+  BD68 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  BD6C 00 00 00 00
  4+  BD70 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  BD74 FF FF FF FF
  5+  BD78 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  BD7C 1F 3F 7F FF
  6+  BD80 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  BD84 F8 FC FE FF
  7+  BD88 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  BD8C 55 AA 55 AA
  8+  BD90 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  BD94 00 00 00 00
  9+  BD98 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 6, slime block
  9+  BD9C 00 00 00 00
 10+  BDA0 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  BDA4 00 00 00 00
 11+  BDA8 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  BDAC F1 72 34 18
 12+  BDB0 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  BDB4 FE FE FF 7E
 13+  BDB8 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  BDBC FE FF 7E 3C
 14+  BDC0 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  BDC4 00 00 FF FF
 15+  BDC8 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  BDCC FF 42 24 18
 16+  BDD0 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  BDD4 00 00 00 00
 17+  BDD8 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  BDDC 00 3C 5A 34
 18+  BDE0 FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  BDE4 FD FE FD FE
 19+  BDE8 F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  BDEC F4 F8 F4 F8
 20+  BDF0 D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  BDF4 D0 E0 D0 E0
 21+  BDF8 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  BDFC 40 80 40 80
 22+  BE00 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  BE04 ED 00 00 00
 23+  BE08 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  BE0C FF 7E 3C 18
 24+  BE10 FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  BE14 00 00 00 00
 25+  BE18 FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  BE1C 00 00 00 00
 26+  BE20 F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  BE24 00 00 00 00
 27+  BE28 C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  BE2C 00 00 00 00
 28+  BE30 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  BE34 00 00 00 00
 29+  BE38 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  BE3C FF FF FF FF
 30+  BE40 00 00 00 66  	defb    0,  0,  0,102,  0,  0,  0,  0     ; 27, bullet
 30+  BE44 00 00 00 00
 31+  BE48
 32+  BE48
 33+  BE48              sprite_attrs:
 34+  BE48 46               defb    070 ; 0, space
 35+  BE49 4D               defb    077 ; 1, cyan block
 36+  BE4A 4D               defb    077 ; 2, slope left
 37+  BE4B 4D               defb    077 ; 3, slope right
 38+  BE4C 46               defb    070 ; 4, dirt
 39+  BE4D 4E               defb    078 ; 5, sky
 40+  BE4E 66               defb    102 ; 6, slime
 41+  BE4F 42               defb    066 ; 7, trapdoor
 42+  BE50 46               defb    070 ; 8, diamond
 43+  BE51 42               defb    066 ; 9, rock
 44+  BE52 42               defb    066 ; 10, rock 2
 45+  BE53 49           	defb    073 ; 11, sky, trapdoor
 46+  BE54 43           	defb    067 ; 12, missile
 47+  BE55 4A               defb    074 ; 13, sky, red ink (tank)
 48+  BE56 46               defb    070 ; 14, gem
 49+  BE57 4D               defb    077 ; 15, damaged mountain
 50+  BE58 4D               defb    077 ; 16, damaged mountain 2
 51+  BE59 4D               defb    077 ; 17, damaged mountain 3
 52+  BE5A 4D               defb    077 ; 18, damaged mountain 4
 53+  BE5B 00           	defb 	000 ; 19, tank missile (not used
 54+  BE5C 43           	defb    067 ; 20, missile active
 55+  BE5D 42           	defb	066	; 21, the pit 1
 56+  BE5E 42           	defb	066	; 22, the pit 2
 57+  BE5F 42           	defb	066	; 23, the pit 3
 58+  BE60 42           	defb	066	; 24, the pit 4
 59+  BE61 42           	defb	066	; 25, the pit 5
 60+  BE62 64           	defb    100 ; 26, slime, green on green
 61+  BE63 46           	defb 	070 ; 27, bullet
 62+  BE64
 63+  BE64
 64+  BE64              player_sprite:
 65+  BE64 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 65+  BE68 38 3D C3 80
 66+  BE6C 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 66+  BE70 3C 1C 16 32
 67+  BE74 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 67+  BE78 3C 38 68 4C
 68+  BE7C 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 68+  BE80 1C BC C3 01
 69+  BE84 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 69+  BE88 3C 3C 64 0C
 70+  BE8C 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 70+  BE90 3C 3C 26 30
 71+  BE94 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 71+  BE98 1E 5C FD 5F
 72+  BE9C 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 72+  BEA0 4F 8F 19 03
 73+  BEA4 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 73+  BEA8 F2 F1 98 C0
 74+  BEAC FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 74+  BEB0 48 08 14 2A
 75+  BEB4 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 75+  BEB8 38 78 44 C3
 76+  BEBC 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 76+  BEC0 1C 1E 22 C3
 77+  BEC4 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 77+  BEC8 6F 45 E1 9B
 78+  BECC 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 78+  BED0 F6 A2 87 D9
 79+  BED4
 80+  BED4              ;
 81+  BED4              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 82+  BED4              ;
 83+  BED4              ship_sprite:
 84+  BED4 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 84+  BED8 03 1F 7F FF
 85+  BEDC 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 85+  BEE0 FF FF FF FF
 86+  BEE4 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 86+  BEE8 FF FF FF FF
 87+  BEEC 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 87+  BEF0 C0 F8 FE FF
 88+  BEF4 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 88+  BEF8 03 03 02 07
 89+  BEFC 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 89+  BF00 FF 0F 07 83
 90+  BF04 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 90+  BF08 FF 10 20 C1
 91+  BF0C 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 91+  BF10 C0 C0 40 E0
 92+  BF14 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 92+  BF18 03 03 02 07
 93+  BF1C F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 93+  BF20 FF 08 04 83
 94+  BF24 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 94+  BF28 FF F0 E0 C1
 95+  BF2C CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 95+  BF30 C0 C0 40 E0
 96+  BF34
 97+  BF34              ;
 98+  BF34              ;  First 8 frames are tank, last frame is the gun barrel
 99+  BF34              ;
100+  BF34              tank_sprite:
101+  BF34 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
101+  BF38 7F 00 00 00
102+  BF3C 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
102+  BF40 FE FF 7F 40
103+  BF44 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
103+  BF48 03 FF FF 01
104+  BF4C 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
104+  BF50 E0 C0 00 00
105+  BF54 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
105+  BF58 F7 E1 7F 3F
106+  BF5C FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
106+  BF60 54 16 FF FF
107+  BF64 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
107+  BF68 9B A8 FF FF
108+  BF6C FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
108+  BF70 9F AF FE FC
109+  BF74 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
109+  BF78 1F 00 00 00
110+  BF7C
111+  BF7C              monster_sprite:
112+  BF7C 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  BF80 0B D0 16 68
113+  BF84 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
113+  BF88 35 AC 7F FE
114+  BF8C FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
114+  BF90 8F F1 8F F1
115+  BF94 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
115+  BF98 18 18 00 00
116+  BF9C 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
116+  BFA0 0B D0 16 68
117+  BFA4 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
117+  BFA8 F5 AF FF FF
118+  BFAC BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
118+  BFB0 0F F0 0F F0
119+  BFB4 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
119+  BFB8 00 00 00 00
120+  BFBC
121+  BFBC              robot_sprite:
122+  BFBC 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
122+  BFC0 CE 12 22 66
123+  BFC4 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
123+  BFC8 4E 12 24 6C
124+  BFCC 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
124+  BFD0 4E 32 63 03
125+  BFD4 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
125+  BFD8 CE 0A 09 1B
126+  BFDC 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
126+  BFE0 73 48 44 66
127+  BFE4 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
127+  BFE8 72 48 24 36
128+  BFEC 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
128+  BFF0 72 4C C6 C0
129+  BFF4 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
129+  BFF8 73 50 90 D8
130+  BFFC 38 A9 BA 7C  	defb     56,169,186,124, 56, 42, 38, 96     ; dead 1
130+  C000 38 2A 26 60
131+  C004 1C 95 5D 3E  	defb	 28,149, 93, 62, 28, 84,100,  6		; dead 2
131+  C008 1C 54 64 06
132+  C00C
# file closed: graphics/graphics.asm
154   C00C
155   C00C                  include "game\control.asm"
# file opened: game/control.asm
  1+  C00C              ;
  2+  C00C              ; Check the preferred input method then move
  3+  C00C              ;
  4+  C00C              control_input:
  5+  C00C 3A 23 C6         ld a,(player+11)    ; first, check if player is dying
  6+  C00F FE 04            cp 4                ; is the player falling
  7+  C011 CC E5 C0         call z, control_fall
  8+  C014 FE 05            cp 5                ; is the player fighting
  9+  C016 CC D2 C0         call z, control_fight
 10+  C019 3A 23 C6         ld a,(player+11)    ; first, check if player is dying
 11+  C01C FE 00            cp 0
 12+  C01E C0               ret nz               ; if so, can't move
 13+  C01F 3A 1D C6         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  C022 FE 00            cp 0
 15+  C024 CA 2B C0         jp z, control_input0
 16+  C027 CD C8 C1         call control_automove
 17+  C02A C9               ret
 18+  C02B              control_input0:
 19+  C02B 3A 1E C6         ld a,(player+6)      ; next, check if the player is digging
 20+  C02E FE 00            cp 0
 21+  C030 CA 37 C0         jp z, control_input1
 22+  C033 CD 01 C1         call control_dig
 23+  C036 C9               ret
 24+  C037              control_input1:
 25+  C037 3A 2C C5         ld a,(game_control)
 26+  C03A FE 00            cp 0                ; is this keyboard
 27+  C03C C2 43 C0         jp nz,control_input2
 28+  C03F CD 47 C0         call control_keyboard
 29+  C042 C9               ret
 30+  C043              control_input2:
 31+  C043                  ; do joystick
 32+  C043 CD 92 C0         call control_joystick
 33+  C046 C9               ret
 34+  C047
 35+  C047              ;
 36+  C047              ; Check the keyboard
 37+  C047              ;
 38+  C047              control_keyboard:
 39+  C047 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 40+  C04A ED 78            in a,(c)            ; read keyboard.
 41+  C04C 47               ld b,a              ; store result in b register.
 42+  C04D CB 18            rr b                ; check outermost key (q).
 43+  C04F D2 7E C0         jp nc,control_keyboard1
 44+  C052 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 45+  C055 ED 78            in a,(c)            ; read keyboard.
 46+  C057 47               ld b,a              ; store result in b register.
 47+  C058 CB 18            rr b                ; check outermost key (a).
 48+  C05A D2 82 C0         jp nc,control_keyboard2
 49+  C05D 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 50+  C060 ED 78            in a,(c)            ; read keyboard.
 51+  C062 47               ld b,a              ; store result in b register.
 52+  C063 CB 18            rr b                ; check outermost key (p).
 53+  C065 D2 86 C0         jp nc,control_keyboard3
 54+  C068 CB 18            rr b                ; check next key.
 55+  C06A D2 8A C0         jp nc,control_keyboard4
 56+  C06D 01 FE 7F         ld bc,32766         ; port for keyboard row b-space.
 57+  C070 ED 78            in a,(c)            ; read keyboard.
 58+  C072 47               ld b,a              ; store result in b register.
 59+  C073 CB 18            rr b                ; check outermost key (space).
 60+  C075 D2 8E C0         jp nc,control_keyboard5
 61+  C078 3E 00            ld a,0
 62+  C07A 32 3F D7         ld (bullet_enable),a ; if nothing has been pressed, reset the fire enabler
 63+  C07D C9               ret
 64+  C07E              control_keyboard1:
 65+  C07E CD 11 C2         call control_pl_moveup         ; player up.
 66+  C081 C9               ret
 67+  C082              control_keyboard2:
 68+  C082 CD 3E C2         call control_pl_movedown       ; player down.
 69+  C085 C9               ret
 70+  C086              control_keyboard3:
 71+  C086 CD 9A C2         call control_pl_moveright       ; player left.
 72+  C089 C9               ret
 73+  C08A              control_keyboard4:
 74+  C08A CD 6A C2         call control_pl_moveleft       ; player right.
 75+  C08D C9               ret
 76+  C08E              control_keyboard5:
 77+  C08E CD C8 C2         call control_pl_fire       ; player fire.
 78+  C091 C9               ret
 79+  C092
 80+  C092              ;
 81+  C092              ; Check the joystick
 82+  C092              ;
 83+  C092              control_joystick:
 84+  C092 01 1F 00         ld bc,31                        ; Kempston joystick port.
 85+  C095 ED 78            in a,(c)                        ; read input.
 86+  C097 E6 02            and 2                           ; check "left" bit.
 87+  C099 C2 C6 C0         jp nz,control_joystick3       ; move left.
 88+  C09C ED 78            in a,(c)                        ; read input.
 89+  C09E E6 01            and 1                           ; test "right" bit.
 90+  C0A0 C2 CA C0         jp nz,control_joystick4       ; move right.
 91+  C0A3 ED 78            in a,(c)                        ; read input.
 92+  C0A5 E6 08            and 8                           ; check "up" bit.
 93+  C0A7 C2 BE C0         jp nz,control_joystick1       ; move up.
 94+  C0AA ED 78            in a,(c)                        ; read input.
 95+  C0AC E6 04            and 4                           ; check "down" bit.
 96+  C0AE C2 C2 C0         jp nz,control_joystick2       ; move down.
 97+  C0B1 ED 78            in a,(c)                        ; read input.
 98+  C0B3 E6 10            and 16                          ; try the fire bit.
 99+  C0B5 C2 CE C0         jp nz,control_joystick5       ; fire pressed.
100+  C0B8 3E 00            ld a,0
101+  C0BA 32 3F D7         ld (bullet_enable),a ; if nothing has been pressed, reset the fire enabler
102+  C0BD C9               ret
103+  C0BE              control_joystick1:
104+  C0BE CD 11 C2         call control_pl_moveup         ; player up.
105+  C0C1 C9               ret
106+  C0C2              control_joystick2:
107+  C0C2 CD 3E C2         call control_pl_movedown       ; player down.
108+  C0C5 C9               ret
109+  C0C6              control_joystick3:
110+  C0C6 CD 6A C2         call control_pl_moveleft       ; player left.
111+  C0C9 C9               ret
112+  C0CA              control_joystick4:
113+  C0CA CD 9A C2         call control_pl_moveright       ; player right.
114+  C0CD C9               ret
115+  C0CE              control_joystick5:
116+  C0CE CD C8 C2         call control_pl_fire
117+  C0D1 C9               ret
118+  C0D2
119+  C0D2              ;
120+  C0D2              ; Fights the player - just flips the players anim frame
121+  C0D2              ;
122+  C0D2              control_fight:
123+  C0D2 3A 1B C6         ld a,(player+3)             ; load the frame
124+  C0D5 FE 0C            cp 12                       ; flip between 12 and 13
125+  C0D7 CA DF C0         jp z,control_fight0
126+  C0DA 3E 0C            ld a,12
127+  C0DC C3 E1 C0         jp control_fight1
128+  C0DF              control_fight0:
129+  C0DF 3E 0D            ld a,13
130+  C0E1              control_fight1:
131+  C0E1 32 1B C6         ld (player+3),a           ; save back
132+  C0E4 C9               ret
133+  C0E5
134+  C0E5              ;
135+  C0E5              ; Falls the player
136+  C0E5              ;
137+  C0E5              control_fall:
138+  C0E5 ED 4B 18 C6      ld bc,(player)              ; get coords
139+  C0E9 0C               inc c
140+  C0EA ED 43 18 C6      ld (player),bc
141+  C0EE 3A 1B C6         ld a,(player+3)             ; load the frame
142+  C0F1 FE 03            cp 3                       ; flip between 3 and 0
143+  C0F3 C2 FB C0         jp nz, control_fall0
144+  C0F6 3E 00            ld a,0
145+  C0F8 C3 FD C0         jp control_fall1
146+  C0FB              control_fall0:
147+  C0FB 3E 03            ld a,3
148+  C0FD              control_fall1:
149+  C0FD 32 1B C6         ld (player+3),a           ; save back
150+  C100 C9               ret
151+  C101
152+  C101              ;
153+  C101              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
154+  C101              ;
155+  C101              control_dig:
156+  C101 ED 4B 18 C6      ld bc,(player)      ; load the current coords into bc
157+  C105 C5               push bc
158+  C106 3A 1A C6         ld a,(player+2)     ; get the direction
159+  C109 FE 01            cp 1                ; left
160+  C10B CA 23 C1         jp z,control_dig0
161+  C10E FE 02            cp 2                ; right
162+  C110 CA 38 C1         jp z,control_dig1
163+  C113 FE 03            cp 3                ; down
164+  C115 CA 61 C1         jp z,control_dig5
165+  C118 FE 00            cp 0                ; up
166+  C11A CA 4C C1         jp z,control_dig4
167+  C11D 21 1E C6         ld hl,player+6
168+  C120 36 00            ld (hl),0           ; turn off digging
169+  C122 C9               ret                 ; return
170+  C123              control_dig0:           ; going left
171+  C123 CD 31 AC         call sprites_scadd  ; get the current coord
172+  C126 62 6B            ld hl,de
173+  C128 2B               dec hl              ; move one left
174+  C129 C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
175+  C12A 78               ld a,b
176+  C12B 06 08            ld b,8
177+  C12D 90               sub b
178+  C12E 47               ld b,a
179+  C12F 79               ld a,c
180+  C130 0E 08            ld c,8
181+  C132 91               sub c
182+  C133 4F               ld c,a
183+  C134 C5               push bc
184+  C135 C3 6A C1         jp control_dig2
185+  C138              control_dig1:
186+  C138 CD 31 AC         call sprites_scadd  ; get the current coord
187+  C13B 62 6B            ld hl,de
188+  C13D 23               inc hl              ; move one right
189+  C13E C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
190+  C13F 3E 08            ld a,8
191+  C141 80               add a,b
192+  C142 47               ld b,a
193+  C143 79               ld a,c
194+  C144 0E 08            ld c,8
195+  C146 91               sub c
196+  C147 4F               ld c,a
197+  C148 C5               push bc
198+  C149 C3 6A C1         jp control_dig2
199+  C14C              control_dig4:
200+  C14C 3E 01            ld a,1
201+  C14E 32 2E A7         ld (buffer_threelinerefresh),a  ; set the three line update flag, since we're digging up
202+  C151 CD 31 AC         call sprites_scadd  ; get the current coord
203+  C154 62 6B            ld hl,de
204+  C156 11 20 00         ld de,32
205+  C159 ED 52            sbc hl,de             ; move one up
206+  C15B C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
207+  C15C 0D               dec c
208+  C15D C5               push bc
209+  C15E C3 82 C1         jp control_dig6
210+  C161              control_dig5:
211+  C161 CD 31 AC         call sprites_scadd  ; get the current coord
212+  C164 62 6B            ld hl,de
213+  C166 24               inc h              ; move one down
214+  C167                                     ; not bothered about working out bc here, since rock will never fall if digging down
215+  C167 C3 6A C1         jp control_dig2
216+  C16A              ; Normal (not up) digging
217+  C16A              control_dig2:
218+  C16A 3A 20 C6         ld a,(player+8)     ; get the number of rows we need to overwrite
219+  C16D 47               ld b,a              ; rows to copy over
220+  C16E E5               push hl             ; store the memory location of the first row for later
221+  C16F              control_dig3:
222+  C16F CD B1 C1         call control_getpixelrow
223+  C172 77               ld (hl),a           ; load contents into row
224+  C173 11 20 00         ld de,32
225+  C176 19               add hl,de           ; move to next row
226+  C177 10 F6            djnz control_dig3
227+  C179 E1               pop hl              ; get the original memory location back
228+  C17A 11 20 00         ld de,32
229+  C17D ED 52            sbc hl,de           ; move to above row, ready for checking for rock
230+  C17F C3 98 C1         jp control_dig10
231+  C182              ; Special case for going up
232+  C182              control_dig6:
233+  C182 3A 20 C6         ld a,(player+8)     ; get the number of rows we need to overwrite
234+  C185 47               ld b,a              ; rows to copy over
235+  C186              control_dig7:
236+  C186 CD B1 C1         call control_getpixelrow
237+  C189              control_dig12:
238+  C189 77               ld (hl),a           ; load empty into row
239+  C18A 11 20 00         ld de,32
240+  C18D ED 52            sbc hl,de           ; move up to next row
241+  C18F 0D               dec c               ; decrease c to track rows
242+  C190 10 F4            djnz control_dig7
243+  C192 79               ld a,c
244+  C193 D6 07            sub 7
245+  C195 C1               pop bc
246+  C196 4F               ld c,a
247+  C197 C5               push bc             ; store the decreased c coord
248+  C198              control_dig10:
249+  C198 DD 21 1F C6      ld ix,player+7
250+  C19C DD 7E 00         ld a,(ix)     ; get the dig frame number
251+  C19F 3D               dec a
252+  C1A0 DD 77 00         ld (ix),a
253+  C1A3                  ; call the check for rocks above the removed dirt
254+  C1A3 DD 21 1E C6      ld ix,player+6
255+  C1A7 DD 7E 00         ld a,(ix)     ; get the dig state
256+  C1AA FE 00            cp 0
257+  C1AC C1               pop bc
258+  C1AD CC F4 CB         call z, rocks_checkforfalling ; make the check if we're no longer digging
259+  C1B0 C9               ret
260+  C1B1
261+  C1B1              ;
262+  C1B1              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
263+  C1B1              ; Inputs:
264+  C1B1              ; hl - memory of pixel row
265+  C1B1              ; Outputs:
266+  C1B1              ; a - modified row to write
267+  C1B1              ;
268+  C1B1              control_getpixelrow:
269+  C1B1 3A 1F C6         ld a,(player+7)     ; get the dig frame number
270+  C1B4 FE 00            cp 0                ; is this the last dig
271+  C1B6 CA BD C1         jp z,control_getpixelrow1
272+  C1B9 7E               ld a,(hl)           ; if not, xor with 255 to flip it
273+  C1BA EE FF            xor 255
274+  C1BC C9               ret
275+  C1BD              control_getpixelrow1:
276+  C1BD DD 21 1E C6      ld ix,player+6
277+  C1C1 DD 36 00 00      ld (ix),0           ; turn off digging
278+  C1C5 3E 00            ld a,0              ; if it is, load with empty
279+  C1C7 C9               ret
280+  C1C8
281+  C1C8              ;
282+  C1C8              ; Auto move the player until pixels is zero
283+  C1C8              ;
284+  C1C8              control_automove:
285+  C1C8 5F               ld e,a              ; store the number of pixels left to move in e
286+  C1C9 ED 4B 18 C6      ld bc,(player)      ; load the current coords into bc
287+  C1CD 21 1A C6         ld hl,player+2      ; get the direction
288+  C1D0 7E               ld a,(hl)
289+  C1D1 FE 03            cp 3                ; down
290+  C1D3 CA E7 C1         jp z,control_automove3  ; don't need to do anything
291+  C1D6 FE 00            cp 0                ; going up
292+  C1D8 CA F3 C1         jp z,control_automove2
293+  C1DB FE 01            cp 1                ; going left?
294+  C1DD CA FF C1         jp z,control_automove0
295+  C1E0 78               ld a,b
296+  C1E1 3C               inc a               ; if we're going right, increment a twice for two pixels
297+  C1E2 3C               inc a
298+  C1E3 47               ld b,a
299+  C1E4 C3 03 C2         jp control_automove1
300+  C1E7              control_automove3:
301+  C1E7 79               ld a,c
302+  C1E8 3C               inc a
303+  C1E9 3C               inc a               ; if we're going down, increment twice
304+  C1EA 4F               ld c,a
305+  C1EB FE 90            cp 144
306+  C1ED CC E7 C2         call z, control_scroll_down
307+  C1F0 C3 03 C2         jp control_automove1
308+  C1F3              control_automove2:
309+  C1F3 79               ld a,c
310+  C1F4 3D               dec a
311+  C1F5 3D               dec a               ; if we're going up, decrement twice
312+  C1F6 4F               ld c,a
313+  C1F7 FE 60            cp 96
314+  C1F9 CC F4 C2         call z, control_scroll_up
315+  C1FC C3 03 C2         jp control_automove1
316+  C1FF              control_automove0:
317+  C1FF 78               ld a,b
318+  C200 3D               dec a               ; if we're going left, decrement a twice
319+  C201 3D               dec a
320+  C202 47               ld b,a
321+  C203              control_automove1:
322+  C203 ED 43 18 C6      ld (player),bc      ; and back to player
323+  C207 7B               ld a,e              ; now get the pixel count back
324+  C208 3D               dec a               ; decrease by one
325+  C209 21 1D C6         ld hl,player+5
326+  C20C 77               ld (hl),a           ; copy back
327+  C20D CD 23 C8         call player_justmoved
328+  C210 C9               ret
329+  C211
330+  C211              ;
331+  C211              ; Moves the player up
332+  C211              ;
333+  C211              control_pl_moveup:
334+  C211 C5               push bc
335+  C212 ED 4B 18 C6      ld bc,(player)          ; get the current coords, b horiz, c vert
336+  C216 79               ld a,c                  ; load c into the acc
337+  C217 FE 18            cp 24
338+  C219 CA 37 C2         jp z,control_pl_moveup0 ; are we at the edge of the screen
339+  C21C FE 60            cp 96
340+  C21E CC F4 C2         call z, control_scroll_up
341+  C221 CD 9B C4         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
342+  C224 F5               push af
343+  C225 7B               ld a,e                  ; put e in a
344+  C226 FE 00            cp 0
345+  C228 CA 36 C2         jp z,control_pl_moveup1 ; don't move if we can't
346+  C22B F1               pop af
347+  C22C D6 01            sub 1                   ; subtract 1
348+  C22E                  ;sub 1                   ; subtract 1
349+  C22E 4F               ld c,a                  ; load back to c
350+  C22F ED 43 18 C6      ld (player),bc          ; load back to player
351+  C233 C3 37 C2         jp control_pl_moveup0
352+  C236              control_pl_moveup1:
353+  C236 F1               pop af                  ; restore af if needed
354+  C237              control_pl_moveup0:
355+  C237 3E 00            ld a,0
356+  C239 32 1A C6         ld (player+2),a        ; set direction to up
357+  C23C C1               pop bc
358+  C23D C9               ret
359+  C23E              ;
360+  C23E              ; Moves the player down
361+  C23E              ;
362+  C23E              control_pl_movedown:
363+  C23E C5               push bc
364+  C23F ED 4B 18 C6      ld bc,(player)          ; get the current coords, b horiz, c vert
365+  C243 79               ld a,c                  ; load c into the acc
366+  C244 FE E0            cp 224
367+  C246 CA 63 C2         jp z,control_pl_movedown0 ; are we at the edge of the screen
368+  C249 FE 80            cp 128
369+  C24B CC E7 C2         call z, control_scroll_down
370+  C24E CD 6F C4         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
371+  C251 F5               push af
372+  C252 7B               ld a,e                  ; put e in a
373+  C253 FE 00            cp 0
374+  C255 CA 62 C2         jp z,control_pl_movedown1 ; don't move if we can't
375+  C258 F1               pop af
376+  C259 3C               inc a                   ; add 1
377+  C25A                  ;inc a                   ; add 1
378+  C25A 4F               ld c,a                  ; load back to c
379+  C25B ED 43 18 C6      ld (player),bc          ; load back to player
380+  C25F C3 63 C2         jp control_pl_movedown0
381+  C262              control_pl_movedown1:
382+  C262 F1               pop af                  ; restore af if needed
383+  C263              control_pl_movedown0:
384+  C263 3E 03            ld a,3
385+  C265 32 1A C6         ld (player+2),a        ; set direction to down
386+  C268 C1               pop bc
387+  C269 C9               ret
388+  C26A              ;
389+  C26A              ; Moves the player left
390+  C26A              ;
391+  C26A              control_pl_moveleft:
392+  C26A C5               push bc
393+  C26B ED 4B 18 C6      ld bc,(player)          ; get the current coords, b horiz, c vert
394+  C26F 78               ld a,b                  ; load b into the acc
395+  C270 FE 10            cp 16
396+  C272 CA 93 C2         jp z,control_pl_moveleft0 ; are we at the edge of the screen
397+  C275 CD FA C4         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
398+  C278 F5               push af
399+  C279 7B               ld a,e                  ; put e in a
400+  C27A FE 00            cp 0
401+  C27C CA 92 C2         jp z,control_pl_moveleft1 ; don't move if we can't
402+  C27F 21 1D C6         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
403+  C282 3E 03            ld a,3
404+  C284 77               ld (hl),a
405+  C285 F1               pop af
406+  C286 D6 01            sub 1                    ; subtract 2
407+  C288 D6 01            sub 1
408+  C28A 47               ld b,a                  ; load back to c
409+  C28B ED 43 18 C6      ld (player),bc          ; load back to player
410+  C28F C3 93 C2         jp control_pl_moveleft0
411+  C292              control_pl_moveleft1:
412+  C292 F1               pop af
413+  C293              control_pl_moveleft0:
414+  C293 3E 01            ld a,1
415+  C295 32 1A C6         ld (player+2),a        ; set direction to left
416+  C298 C1               pop bc
417+  C299 C9               ret
418+  C29A              ;
419+  C29A              ; Moves the player right
420+  C29A              ;
421+  C29A              control_pl_moveright:
422+  C29A C5               push bc
423+  C29B ED 4B 18 C6      ld bc,(player)          ; get the current coords, b horiz, c vert
424+  C29F 78               ld a,b                  ; load b into the acc
425+  C2A0 FE F0            cp 240
426+  C2A2 CA C1 C2         jp z,control_pl_moveright0 ; are we at the edge of the screen
427+  C2A5 CD CE C4         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
428+  C2A8 F5               push af
429+  C2A9 7B               ld a,e                  ; put e in a
430+  C2AA FE 00            cp 0
431+  C2AC CA C0 C2         jp z,control_pl_moveright1 ; don't move if we can't
432+  C2AF 21 1D C6         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
433+  C2B2 3E 03            ld a,3
434+  C2B4 77               ld (hl),a
435+  C2B5 F1               pop af
436+  C2B6 3C               inc a                   ; add 2
437+  C2B7 3C               inc a
438+  C2B8 47               ld b,a                  ; load back to b
439+  C2B9 ED 43 18 C6      ld (player),bc          ; load back to player
440+  C2BD C3 C1 C2         jp control_pl_moveright0
441+  C2C0              control_pl_moveright1:
442+  C2C0 F1               pop af                  ; restore af if needed
443+  C2C1              control_pl_moveright0:
444+  C2C1 3E 02            ld a,2
445+  C2C3 32 1A C6         ld (player+2),a        ; set direction to right
446+  C2C6 C1               pop bc
447+  C2C7 C9               ret
448+  C2C8
449+  C2C8              ;
450+  C2C8              ; Player fires
451+  C2C8              ;
452+  C2C8              control_pl_fire:
453+  C2C8 3A 3F D7         ld a,(bullet_enable)
454+  C2CB FE 00            cp 0
455+  C2CD C0               ret nz                      ; don't shoot if the bullet isn't enabled
456+  C2CE 3A 1A C6         ld a,(player+2)         ; get player direction
457+  C2D1 FE 00            cp 0
458+  C2D3 C8               ret z
459+  C2D4 FE 03            cp 3
460+  C2D6 C8               ret z                   ; if up or down, don't fire
461+  C2D7 3A 3E D7         ld a,(bullet_state+3)       ; get the state
462+  C2DA FE 01            cp 1
463+  C2DC C8               ret z                   ; if currently firing, don't fire
464+  C2DD CD 40 D7         call bullet_init        ; initialise the bullet
465+  C2E0 CD 55 D7         call bullet_shoot       ; shoot the bullet
466+  C2E3 CD F7 B1         call sound_laser
467+  C2E6 C9               ret
468+  C2E7
469+  C2E7              ;
470+  C2E7              ; Scrolls the screen down
471+  C2E7              ;
472+  C2E7              control_scroll_down:
473+  C2E7 F5               push af
474+  C2E8 3E 08            ld a,8
475+  C2EA 32 F7 A8         ld (screen_offset),a
476+  C2ED F1               pop af
477+  C2EE 21 44 A7         ld hl,buffer_updateall
478+  C2F1 36 01            ld (hl),1         ; flag as screen needing update
479+  C2F3 C9               ret
480+  C2F4
481+  C2F4              ;
482+  C2F4              ; Scrolls the screen up
483+  C2F4              ;
484+  C2F4              control_scroll_up:
485+  C2F4 F5               push af
486+  C2F5 3E 00            ld a,0
487+  C2F7 32 F7 A8         ld (screen_offset),a
488+  C2FA F1               pop af
489+  C2FB 21 44 A7         ld hl,buffer_updateall
490+  C2FE 36 01            ld (hl),1         ; flag as screen needing update
491+  C300 C9               ret
492+  C301
493+  C301
494+  C301
495+  C301
# file closed: game/control.asm
156   C301                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  C301              ;
  2+  C301              ; The number of frames to dig for
  3+  C301              ;
  4+  C301              movement_numberdigframes:
  5+  C301 0A               defb 10
  6+  C302
  7+  C302              ;
  8+  C302              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  C302              ; Inputs:
 10+  C302              ; hl - memory location of top pixel row
 11+  C302              ; bc - screen coords, b horiz, c vert
 12+  C302              ; Outputs:
 13+  C302              ; e - 0 if not empty, 1 if empty
 14+  C302              ;
 15+  C302              movement_spaceisempty:
 16+  C302 C5               push bc
 17+  C303 E5               push hl
 18+  C304 CD 2C C3         call movement_spaceisgem        ; check if space is a gem
 19+  C307 E1               pop hl
 20+  C308 C1               pop bc
 21+  C309 7B               ld a,e
 22+  C30A FE 01            cp 1
 23+  C30C C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  C30D 3E 08            ld a,8                          ; 8 rows to check
 25+  C30F              movement_spaceisempty0:
 26+  C30F 08               ex af,af'                       ; store the loop counter
 27+  C310 7E               ld a,(hl)                       ; get current pixel row
 28+  C311 FE 00            cp 0
 29+  C313 C2 27 C3         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  C316 79               ld a,c                          ; load the vertical coord
 31+  C317 3C               inc a                           ; next row down
 32+  C318 11 20 00         ld de,32
 33+  C31B 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  C31C 4F               ld c,a                          ; copy vert coord back to c
 35+  C31D 08               ex af,af'                       ; get loop counter back
 36+  C31E 3D               dec a                           ; decrease loop counter
 37+  C31F C2 0F C3         jp nz, movement_spaceisempty0
 38+  C322 16 00            ld d,0
 39+  C324 1E 01            ld e,1                          ; got to end, so space is empty
 40+  C326 C9               ret
 41+  C327              movement_spaceisempty1:
 42+  C327 16 00            ld d,0
 43+  C329 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  C32B C9               ret
 45+  C32C
 46+  C32C              ;
 47+  C32C              ; Check if a space contains a gem
 48+  C32C              ; Inputs:
 49+  C32C              ; bc - screen coords
 50+  C32C              ; Outputs:
 51+  C32C              ; e = 1 if gem
 52+  C32C              movement_spaceisgem:
 53+  C32C CD 57 AA         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  C32F 21 E3 B8         ld hl,level_diamonds           ; check diamonds first
 55+  C332              movement_spaceisgem0:
 56+  C332 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  C336 7B               ld a,e                          ; check for end of data
 58+  C337 FE FF            cp 255
 59+  C339 CA 54 C3         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  C33C 23               inc hl
 61+  C33D 23               inc hl                          ; move to state
 62+  C33E 7E               ld a,(hl)
 63+  C33F 23               inc hl
 64+  C340 23               inc hl
 65+  C341 23               inc hl                          ; get to next
 66+  C342 FE 01            cp 1                            ; check if collected
 67+  C344 CA 32 C3         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  C347 7B               ld a,e                          ; load e again
 69+  C348 B9               cp c                            ; otherwise, compare c with e
 70+  C349 C2 32 C3         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  C34C 7A               ld a,d                          ; get d coord
 72+  C34D B8               cp b                            ; compare b with d
 73+  C34E C2 32 C3         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  C351 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  C353 C9               ret
 76+  C354              movement_spaceisgem1:
 77+  C354 21 F3 B8         ld hl,level_gems              ; check gems
 78+  C357              movement_spaceisgem2:
 79+  C357 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  C35B 7B               ld a,e                          ; check for end of data
 81+  C35C FE FF            cp 255
 82+  C35E CA 79 C3         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  C361 23               inc hl
 84+  C362 23               inc hl                          ; move to state
 85+  C363 7E               ld a,(hl)
 86+  C364 23               inc hl
 87+  C365 23               inc hl
 88+  C366 23               inc hl                          ; get to next
 89+  C367 FE 01            cp 1                            ; check if collected
 90+  C369 CA 57 C3         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  C36C 7B               ld a,e                          ; load e again
 92+  C36D B9               cp c                            ; otherwise, compare c with e
 93+  C36E C2 57 C3         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  C371 7A               ld a,d                          ; get d coord
 95+  C372 B8               cp b                            ; compare b with d
 96+  C373 C2 57 C3         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  C376 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  C378 C9               ret
 99+  C379              movement_spaceisgem3:
100+  C379 1E 00            ld e,0                          ; nothing found, return e = 0
101+  C37B C9               ret
102+  C37C
103+  C37C              ;
104+  C37C              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  C37C              ; Inputs:
106+  C37C              ; hl - memory location of top pixel row
107+  C37C              ; bc - screen coords, b horiz, c vert
108+  C37C              ; Outputs:
109+  C37C              ; e - 0 if not empty, 1 if empty
110+  C37C              ;
111+  C37C              movement_linebelowisempty:
112+  C37C C5               push bc
113+  C37D E5               push hl
114+  C37E CD 2C C3         call movement_spaceisgem        ; check if space is a gem
115+  C381 E1               pop hl
116+  C382 C1               pop bc
117+  C383 7B               ld a,e
118+  C384 FE 01            cp 1
119+  C386 C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  C387 7E               ld a,(hl)                       ; get current pixel row
121+  C388 FE 00            cp 0
122+  C38A C2 92 C3         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  C38D 16 00            ld d,0
124+  C38F 1E 01            ld e,1                          ; got to end, so space is empty
125+  C391 C9               ret
126+  C392              movement_linebelowisempty1:
127+  C392 16 00            ld d,0
128+  C394 1E 00            ld e,0                          ; returning false, ie space not empty
129+  C396 C9               ret
130+  C397
131+  C397              ;
132+  C397              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  C397              ; Inputs:
134+  C397              ; hl - memory location of top pixel row
135+  C397              ; bc - screen coords, b horiz, c vert
136+  C397              ; Outputs:
137+  C397              ; e - 0 if not empty, 1 if empty
138+  C397              ;
139+  C397              movement_lineaboveisempty:
140+  C397 C5               push bc
141+  C398 E5               push hl
142+  C399 CD 2C C3         call movement_spaceisgem        ; check if space is a gem
143+  C39C E1               pop hl
144+  C39D C1               pop bc
145+  C39E 7B               ld a,e
146+  C39F FE 01            cp 1
147+  C3A1 C8               ret z
148+  C3A2 7E               ld a,(hl)                       ; get current pixel row
149+  C3A3 FE 00            cp 0
150+  C3A5 C2 AD C3         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  C3A8 16 00            ld d,0
152+  C3AA 1E 01            ld e,1                          ; got to end, so space is empty
153+  C3AC C9               ret
154+  C3AD              movement_lineaboveisempty1:
155+  C3AD 16 00            ld d,0
156+  C3AF 1E 00            ld e,0                          ; returning false, ie space not empty
157+  C3B1 C9               ret
158+  C3B2
159+  C3B2              ;
160+  C3B2              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  C3B2              ; Inputs:
162+  C3B2              ; hl - memory location of top pixel row
163+  C3B2              ; bc - screen coords, b horiz, c vert
164+  C3B2              ; Outputs:
165+  C3B2              ; none - puts player into digging mode
166+  C3B2              ;
167+  C3B2              movement_spaceisdiggable:
168+  C3B2 3E 08            ld a,8                          ; 8 rows to check
169+  C3B4              movement_spaceisdiggable0:
170+  C3B4 08               ex af,af'                       ; store the loop counter
171+  C3B5 7E               ld a,(hl)                       ; get current pixel row
172+  C3B6 FE 00            cp 0
173+  C3B8 CA C8 C3         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  C3BB FE 55            cp 85
175+  C3BD CA C8 C3         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  C3C0 FE AA            cp 170
177+  C3C2 CA C8 C3         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  C3C5 C3 E2 C3         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  C3C8              movement_spaceisdiggable2:
180+  C3C8 79               ld a,c                          ; load the vertical coord
181+  C3C9 3C               inc a                           ; next row down
182+  C3CA 11 20 00         ld de,32
183+  C3CD 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  C3CE 4F               ld c,a                          ; copy vert coord back to c
185+  C3CF 08               ex af,af'                       ; get loop counter back
186+  C3D0 3D               dec a                           ; decrease loop counter
187+  C3D1 C2 B4 C3         jp nz, movement_spaceisdiggable0
188+  C3D4 21 1E C6         ld hl,player+6
189+  C3D7 36 01            ld (hl),1                       ; set the player into digging mode
190+  C3D9 23               inc hl
191+  C3DA 3A 01 C3         ld a,(movement_numberdigframes)
192+  C3DD 77               ld (hl),a                       ; set the number of frame to dig for
193+  C3DE 23               inc hl
194+  C3DF 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  C3E1 C9               ret
196+  C3E2              movement_spaceisdiggable1:
197+  C3E2 21 1E C6         ld hl,player+6
198+  C3E5 36 00            ld (hl),0                       ; set the player out of digging mode
199+  C3E7 C9               ret
200+  C3E8
201+  C3E8              ;
202+  C3E8              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
203+  C3E8              ; Inputs:
204+  C3E8              ; hl - memory location of top pixel row
205+  C3E8              ; bc - screen coords, b horiz, c vert
206+  C3E8              ; Outputs:
207+  C3E8              ; none - puts player into digging mode
208+  C3E8              ;
209+  C3E8              movement_spacebelowisdiggable:
210+  C3E8 7E               ld a,(hl)                       ; get first pixel row
211+  C3E9 FE 55            cp 85
212+  C3EB CA F6 C3         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
213+  C3EE FE AA            cp 170
214+  C3F0 CA F6 C3         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
215+  C3F3 C3 E2 C3         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
216+  C3F6              movement_spacebelowisdiggable3:
217+  C3F6 3E 08            ld a,8                          ; rows to check
218+  C3F8 1E 00            ld e,0                          ; count of rows to dig
219+  C3FA              movement_spacebelowisdiggable0:
220+  C3FA 08               ex af,af'                       ; store the loop counter
221+  C3FB 7E               ld a,(hl)                       ; get current pixel row
222+  C3FC FE 55            cp 85
223+  C3FE CA 09 C4         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
224+  C401 FE AA            cp 170
225+  C403 CA 09 C4         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
226+  C406 C3 18 C4         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
227+  C409              movement_spacebelowisdiggable4:
228+  C409 1C               inc e                           ; inc count of rows to dig
229+  C40A              movement_spacebelowisdiggable2:
230+  C40A 79               ld a,c                          ; load the vertical coord
231+  C40B 3C               inc a                           ; next row down
232+  C40C D5               push de                         ; need e for later
233+  C40D 11 20 00         ld de,32
234+  C410 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
235+  C411 4F               ld c,a                          ; copy vert coord back to c
236+  C412 D1               pop de                          ; get e back
237+  C413 08               ex af,af'                       ; get loop counter back
238+  C414 3D               dec a                           ; incease loop counter
239+  C415 C2 FA C3         jp nz, movement_spacebelowisdiggable0
240+  C418              movement_spacebelowisdiggable5:
241+  C418 21 1E C6         ld hl,player+6
242+  C41B 36 01            ld (hl),1                       ; set the player into digging mode
243+  C41D 23               inc hl
244+  C41E 3A 01 C3         ld a,(movement_numberdigframes)
245+  C421 77               ld (hl),a                       ; set the number of frame to dig for
246+  C422 23               inc hl
247+  C423 73               ld (hl),e                       ; set the number of pixels to dig
248+  C424 C9               ret
249+  C425              movement_spacebelowisdiggable1:
250+  C425 21 1E C6         ld hl,player+6
251+  C428 36 00            ld (hl),0                       ; set the player out of digging mode
252+  C42A C9               ret
253+  C42B
254+  C42B              ;
255+  C42B              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
256+  C42B              ; Inputs:
257+  C42B              ; hl - memory location of top pixel row
258+  C42B              ; bc - screen coords, b horiz, c vert
259+  C42B              ; Outputs:
260+  C42B              ; none - puts player into digging mode
261+  C42B              ;
262+  C42B              movement_spaceaboveisdiggable:
263+  C42B 7E               ld a,(hl)                       ; get first pixel row
264+  C42C FE 55            cp 85
265+  C42E CA 39 C4         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
266+  C431 FE AA            cp 170
267+  C433 CA 39 C4         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
268+  C436 C3 E2 C3         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
269+  C439              movement_spaceaboveisdiggable3:
270+  C439 3E 08            ld a,8                          ; rows to check
271+  C43B 1E 00            ld e,0                          ; count of rows to dig
272+  C43D              movement_spaceaboveisdiggable0:
273+  C43D 08               ex af,af'                       ; store the loop counter
274+  C43E 7E               ld a,(hl)                       ; get current pixel row
275+  C43F FE 55            cp 85
276+  C441 CA 4C C4         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
277+  C444 FE AA            cp 170
278+  C446 CA 4C C4         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
279+  C449 C3 5C C4         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
280+  C44C              movement_spaceaboveisdiggable4:
281+  C44C 1C               inc e                           ; inc count of rows to dig
282+  C44D              movement_spaceaboveisdiggable2:
283+  C44D 79               ld a,c                          ; load the vertical coord
284+  C44E 3D               dec a                           ; next row up
285+  C44F D5               push de                         ; need e for later
286+  C450 11 20 00         ld de,32
287+  C453 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
288+  C455 4F               ld c,a                          ; copy vert coord back to c
289+  C456 D1               pop de                          ; get e back
290+  C457 08               ex af,af'                       ; get loop counter back
291+  C458 3D               dec a                           ; incease loop counter
292+  C459 C2 3D C4         jp nz, movement_spaceaboveisdiggable0
293+  C45C              movement_spaceaboveisdiggable5:
294+  C45C 21 1E C6         ld hl,player+6
295+  C45F 36 01            ld (hl),1                       ; set the player into digging mode
296+  C461 23               inc hl
297+  C462 3A 01 C3         ld a,(movement_numberdigframes)
298+  C465 77               ld (hl),a                       ; set the number of frame to dig for
299+  C466 23               inc hl
300+  C467 73               ld (hl),e                       ; set the number of pixels to dig
301+  C468 C9               ret
302+  C469              movement_spaceaboveisdiggable1:
303+  C469 21 1E C6         ld hl,player+6
304+  C46C 36 00            ld (hl),0                       ; set the player out of digging mode
305+  C46E C9               ret
306+  C46F
307+  C46F              ;
308+  C46F              ; Checks if the player can move down
309+  C46F              ; Inputs:
310+  C46F              ; bc - player coords, b horiz, c vert
311+  C46F              ; Outputs:
312+  C46F              ; de - 1 can move
313+  C46F              movement_checkcanmove_down:
314+  C46F F5               push af
315+  C470 C5               push bc
316+  C471 CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
317+  C474 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
318+  C476 24               inc h                       ; memory location of cell beneath now in hl
319+  C477 3E 08            ld a,8                       ; look below
320+  C479 81               add c
321+  C47A 4F               ld c,a
322+  C47B CD 7C C3         call movement_linebelowisempty       ; check space is empty
323+  C47E 7B               ld a,e                          ; check space empty flag
324+  C47F FE 00            cp 0
325+  C481 CA 8A C4         jp z, movement_checkcanmove_down1 ; can't move
326+  C484 CD 23 C8         call player_justmoved
327+  C487 C1               pop bc
328+  C488 F1               pop af
329+  C489 C9               ret
330+  C48A              movement_checkcanmove_down1:
331+  C48A C1               pop bc
332+  C48B CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
333+  C48E 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
334+  C490 24               inc h
335+  C491 C5               push bc
336+  C492 CD E8 C3         call movement_spacebelowisdiggable    ; can't move here, but can we dig
337+  C495 11 00 00         ld de,0
338+  C498 C1               pop bc
339+  C499 F1               pop af
340+  C49A C9               ret
341+  C49B
342+  C49B              ;
343+  C49B              ; Checks if the player can move up
344+  C49B              ; Inputs:
345+  C49B              ; bc - player coords, b horiz, c vert
346+  C49B              ; Outputs:
347+  C49B              ; de - 1 can move
348+  C49B              movement_checkcanmove_up:
349+  C49B F5               push af
350+  C49C C5               push bc
351+  C49D CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
352+  C4A0 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
353+  C4A2 11 20 00         ld de,32
354+  C4A5 ED 52            sbc hl,de                       ; memory location of line above now in hl
355+  C4A7 0D               dec c                           ; look above
356+  C4A8 CD 97 C3         call movement_lineaboveisempty       ; check space is empty
357+  C4AB 7B               ld a,e                          ; check space empty flag
358+  C4AC FE 00            cp 0
359+  C4AE CA B9 C4         jp z, movement_checkcanmove_up1 ; can't move
360+  C4B1 1E 01            ld e,1
361+  C4B3 CD 23 C8         call player_justmoved
362+  C4B6 C1               pop bc
363+  C4B7 F1               pop af
364+  C4B8 C9               ret
365+  C4B9              movement_checkcanmove_up1:
366+  C4B9 C1               pop bc
367+  C4BA CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
368+  C4BD 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
369+  C4BF 11 20 00         ld de,32
370+  C4C2 ED 52            sbc hl,de                       ; memory location of line above now in hl
371+  C4C4 C5               push bc
372+  C4C5 CD 2B C4         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
373+  C4C8 11 00 00         ld de,0
374+  C4CB C1               pop bc
375+  C4CC F1               pop af
376+  C4CD C9               ret
377+  C4CE
378+  C4CE              ;
379+  C4CE              ; Checks if the player can move right
380+  C4CE              ; Inputs:
381+  C4CE              ; bc - player coords, b horiz, c vert
382+  C4CE              ; Outputs:
383+  C4CE              ; de - 1 can move
384+  C4CE              movement_checkcanmove_right:
385+  C4CE F5               push af
386+  C4CF C5               push bc
387+  C4D0 CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
388+  C4D3 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
389+  C4D5 3E 08            ld a,8
390+  C4D7 80               add b                           ; move one cell right
391+  C4D8 47               ld b,a
392+  C4D9 23               inc hl                          ; memory location of cell to the right now in hl
393+  C4DA CD 02 C3         call movement_spaceisempty       ; check space is empty
394+  C4DD 7B               ld a,e                          ; check space empty flag
395+  C4DE FE 00            cp 0
396+  C4E0 CA E9 C4         jp z, movement_checkcanmove_right1 ; can't move
397+  C4E3 CD 23 C8         call player_justmoved
398+  C4E6 C1               pop bc
399+  C4E7 F1               pop af
400+  C4E8 C9               ret
401+  C4E9              movement_checkcanmove_right1:
402+  C4E9 C1               pop bc
403+  C4EA CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
404+  C4ED 62 6B            ld hl,de
405+  C4EF 23               inc hl                          ; memory location of cell to the right now in hl
406+  C4F0 C5               push bc
407+  C4F1 CD B2 C3         call movement_spaceisdiggable    ; can't move here, but can we dig
408+  C4F4 11 00 00         ld de,0
409+  C4F7 C1               pop bc
410+  C4F8 F1               pop af
411+  C4F9 C9               ret
412+  C4FA
413+  C4FA              ;
414+  C4FA              ; Checks if the player can move left
415+  C4FA              ; Inputs:
416+  C4FA              ; bc - player coords, b horiz, c vert
417+  C4FA              ; Outputs:
418+  C4FA              ; de - 1 can move
419+  C4FA              movement_checkcanmove_left:
420+  C4FA F5               push af
421+  C4FB C5               push bc
422+  C4FC CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
423+  C4FF 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
424+  C501 78               ld a,b
425+  C502 06 08            ld b,8
426+  C504 90               sub b                           ; move one cell left
427+  C505 47               ld b,a
428+  C506 2B               dec hl                          ; memory location of cell to the right now in hl
429+  C507 CD 02 C3         call movement_spaceisempty       ; check space is empty
430+  C50A 7B               ld a,e                          ; check space empty flag
431+  C50B FE 00            cp 0
432+  C50D CA 16 C5         jp z, movement_checkcanmove_left1 ; can't move
433+  C510 CD 23 C8         call player_justmoved
434+  C513 C1               pop bc
435+  C514 F1               pop af
436+  C515 C9               ret
437+  C516              movement_checkcanmove_left1:
438+  C516 C1               pop bc
439+  C517 CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
440+  C51A 62 6B            ld hl,de
441+  C51C 2B               dec hl                          ; memory location of cell to the right now in hl
442+  C51D C5               push bc
443+  C51E CD B2 C3         call movement_spaceisdiggable    ; can't move here, but can we dig
444+  C521 11 00 00         ld de,0
445+  C524 C1               pop bc
446+  C525 F1               pop af
447+  C526 C9               ret
# file closed: game/movement.asm
157   C527                  include "game\game.asm"
# file opened: game/game.asm
  1+  C527              ;
  2+  C527              ; The current frame count, incremented each frame
  3+  C527              ;
  4+  C527              game_framenumber:
  5+  C527 00               defb    0
  6+  C528
  7+  C528              ;
  8+  C528              ; The number of players
  9+  C528              ;
 10+  C528              game_numberplayers:
 11+  C528 01               defb 1
 12+  C529
 13+  C529              ;
 14+  C529              ; The current player
 15+  C529              ;
 16+  C529              game_currentplayer:
 17+  C529 01               defb 1
 18+  C52A
 19+  C52A              ;
 20+  C52A              ; The default number of lives
 21+  C52A              ;
 22+  C52A              game_numberlives:
 23+  C52A 04               defb 4
 24+  C52B
 25+  C52B              ;
 26+  C52B              ; The current difficulty
 27+  C52B              ;
 28+  C52B              game_difficulty:
 29+  C52B 01               defb 1
 30+  C52C
 31+  C52C              ;
 32+  C52C              ; Control method: 0 for keyboard, 1 for kempston
 33+  C52C              ;
 34+  C52C              game_control:
 35+  C52C 00               defb 0
 36+  C52D
 37+  C52D              ;
 38+  C52D              ; The current rocks used
 39+  C52D              ;
 40+  C52D              game_current_rocks:
 41+  C52D 00 00            defb 0,0
 42+  C52F
 43+  C52F
 44+  C52F              game_tankdifficulty:
 45+  C52F 46 41 3C 37      defb 70,65,60,55,50,45,40,35,30,25,20,12
 45+  C533 32 2D 28 23
 45+  C537 1E 19 14 0C
 46+  C53B              game_pitdifficulty:
 47+  C53B 07 05 05 04      defb 7,5,5,4,4,4,2,2,2,2,2,2
 47+  C53F 04 04 02 02
 47+  C543 02 02 02 02
 48+  C547              game_robotdifficulty:
 49+  C547 06 04 04 04      defb 6,4,4,4,3,3,3,2,0,0,0,0
 49+  C54B 03 03 03 02
 49+  C54F 00 00 00 00
 50+  C553              game_digdifficulty:
 51+  C553 14 0E 0A 0A      defb 20,14,10,10,8,8,8,8,6,6,6,4
 51+  C557 08 08 08 08
 51+  C55B 06 06 06 04
 52+  C55F              game_rockdifficulty:
 53+  C55F 28 1C 14 14      defb 40,28,20,20,18,18,18,18,18,18,18,18
 53+  C563 12 12 12 12
 53+  C567 12 12 12 12
 54+  C56B              game_missiledifficulty:
 55+  C56B 46 32 2D 2D      defb 70,50,45,45,40,35,35,30,30,25,25,20
 55+  C56F 28 23 23 1E
 55+  C573 1E 19 19 14
 56+  C577              ;
 57+  C577              ; Moves to the next player
 58+  C577              ;
 59+  C577              game_changeplayer:
 60+  C577 3A 28 C5         ld a,(game_numberplayers)
 61+  C57A FE 01            cp 1
 62+  C57C C8               ret z                       ; if just one player, no need to change
 63+  C57D 3A 29 C5         ld a,(game_currentplayer)   ; get current player
 64+  C580 3D               dec a                       ; otherwise decrease by one
 65+  C581 EE 01            xor 1                       ; xor with one to flip
 66+  C583 3C               inc a                       ; increment
 67+  C584 21 29 C5         ld hl,game_currentplayer
 68+  C587 77               ld (hl),a                   ; store
 69+  C588 C9               ret
 70+  C589
 71+  C589              ;
 72+  C589              ; Sets the number of players at the start of the game
 73+  C589              ; Inputs:
 74+  C589              ; a - number of players
 75+  C589              game_setnumberofplayers:
 76+  C589 21 28 C5         ld hl,game_numberplayers
 77+  C58C 77               ld (hl),a
 78+  C58D
 79+  C58D              ;
 80+  C58D              ; Starts a game
 81+  C58D              ;
 82+  C58D              game_init:
 83+  C58D 3E 01            ld a,1
 84+  C58F 32 29 C5         ld (game_currentplayer),a
 85+  C592 C9               ret
 86+  C593
 87+  C593              ;
 88+  C593              ; Sets the current rock layout. Odd gets 1, even gets 2
 89+  C593              ;
 90+  C593              game_setcurrentrocks:
 91+  C593 3A 2B C5         ld a,(game_difficulty)
 92+  C596 E6 01            and 1
 93+  C598 FE 00            cp 0
 94+  C59A CA A8 C5         jp z,game_setcurrentrocks0
 95+  C59D 11 83 B6         ld de,level_rocks
 96+  C5A0 21 2D C5         ld hl,game_current_rocks
 97+  C5A3 73 23 72 2B      ld (hl),de
 98+  C5A7 C9               ret
 99+  C5A8              game_setcurrentrocks0:
100+  C5A8 11 83 B7         ld de,level_rocks_alt
101+  C5AB 21 2D C5         ld hl,game_current_rocks
102+  C5AE 73 23 72 2B      ld (hl),de
103+  C5B2 C9               ret
104+  C5B3
105+  C5B3              ;
106+  C5B3              ; Increment frame number by 1
107+  C5B3              ;
108+  C5B3              game_incrementframe:
109+  C5B3 3A 27 C5         ld a,(game_framenumber)
110+  C5B6 FE FF            cp 255
111+  C5B8 C2 BD C5         jp nz,game_incrementframe0
112+  C5BB 3E 00            ld a,0
113+  C5BD              game_incrementframe0:
114+  C5BD 3C               inc a
115+  C5BE 32 27 C5         ld (game_framenumber),a
116+  C5C1 C9               ret
117+  C5C2
118+  C5C2              ;
119+  C5C2              ; Returns current frame
120+  C5C2              ; Outputs:
121+  C5C2              ; a - current frame
122+  C5C2              ;
123+  C5C2              game_getcurrentframe:
124+  C5C2 3A 27 C5         ld a,(game_framenumber)
125+  C5C5 C9               ret
126+  C5C6
127+  C5C6              ;
128+  C5C6              ; Resets current frame
129+  C5C6              ;
130+  C5C6              game_resetcurrentframe:
131+  C5C6 21 27 C5         ld hl,game_framenumber
132+  C5C9 36 00            ld (hl),0
133+  C5CB C9               ret
134+  C5CC
135+  C5CC              ;
136+  C5CC              ; Increases the current difficulty
137+  C5CC              ;
138+  C5CC              game_increasedifficulty:
139+  C5CC 3A 2B C5         ld a,(game_difficulty)
140+  C5CF 3C               inc a
141+  C5D0 32 2B C5         ld (game_difficulty),a
142+  C5D3
143+  C5D3              ;
144+  C5D3              ; Sets the various difficulties
145+  C5D3              ;
146+  C5D3              game_setdifficulty:
147+  C5D3 3A 2B C5         ld a,(game_difficulty)
148+  C5D6 FE 0D            cp 13
149+  C5D8 C2 DD C5         jp nz,game_setdifficulty0
150+  C5DB 3E 0C            ld a,12                         ; limit difficulty to twelve
151+  C5DD              game_setdifficulty0:
152+  C5DD 11 00 00         ld de,0
153+  C5E0 5F               ld e,a                          ; keep the difficulty in de
154+  C5E1                  ; Set the tank difficulty
155+  C5E1 21 2F C5         ld hl,game_tankdifficulty
156+  C5E4 2B               dec hl
157+  C5E5 19               add hl,de                       ; add the difficulty
158+  C5E6 7E               ld a,(hl)                       ; get the value
159+  C5E7 32 D6 C9         ld (tank_speed),a               ; set the tank speed
160+  C5EA                  ; Set the pit difficulty
161+  C5EA 21 3B C5         ld hl,game_pitdifficulty
162+  C5ED 2B               dec hl
163+  C5EE 19               add hl,de                       ; add the difficulty
164+  C5EF 7E               ld a,(hl)                       ; get the value
165+  C5F0 32 A7 D1         ld (thepit_speed),a               ; set the pit speed
166+  C5F3                  ; Set the robot difficulty
167+  C5F3 21 47 C5         ld hl,game_robotdifficulty
168+  C5F6 2B               dec hl
169+  C5F7 19               add hl,de                       ; add the difficulty
170+  C5F8 7E               ld a,(hl)                       ; get the value
171+  C5F9 32 84 D3         ld (robots_robotspeed),a        ; set the robot speed
172+  C5FC                  ; Set the dig difficulty
173+  C5FC 21 53 C5         ld hl,game_digdifficulty
174+  C5FF 2B               dec hl
175+  C600 19               add hl,de                       ; add the difficulty
176+  C601 7E               ld a,(hl)                       ; get the value
177+  C602 32 01 C3         ld (movement_numberdigframes),a ; set the dig frames
178+  C605                  ; Set the rock difficulty
179+  C605 21 5F C5         ld hl,game_rockdifficulty
180+  C608 2B               dec hl
181+  C609 19               add hl,de                       ; add the difficulty
182+  C60A 7E               ld a,(hl)                       ; get the value
183+  C60B 32 F1 CB         ld (rocks_numberofframestowobble),a ; set the wobble frames
184+  C60E                  ; Set the missile difficulty
185+  C60E 21 6B C5         ld hl,game_missiledifficulty
186+  C611 2B               dec hl
187+  C612 19               add hl,de                       ; add the difficulty
188+  C613 7E               ld a,(hl)                       ; get the value
189+  C614 32 E3 CF         ld (missiles_speed),a           ; set the missile difficulty
190+  C617 C9               ret
# file closed: game/game.asm
158   C618                  include "game\player.asm"
# file opened: game/player.asm
  1+  C618              ;
  2+  C618              ;   Data for current player
  3+  C618              ;
  4+  C618              player:
  5+  C618 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  C61A 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  C61D 00               defb    0                   ; auto move remaining (+5)
  8+  C61E 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  C621 00               defb    0                   ; lives remaining (+9)
 10+  C622 00               defb    0                   ; died this life (+10)
 11+  C623 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  C625 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  C626 00               defb    0                   ; difficulty (+14)
 14+  C627
 15+  C627              player_location:
 16+  C627 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 17+  C628
 18+  C628              ;
 19+  C628              ; Works out which part of the screen the player is in
 20+  C628              ; Pit is between 3,9 and 8,9
 21+  C628              ; Diamond cavern is between 11,22 and 22,28
 22+  C628              ;
 23+  C628              player_getlocation:
 24+  C628 ED 4B 18 C6      ld bc,(player)              ; get screen coords
 25+  C62C CD 57 AA         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 26+  C62F 78               ld a,b                      ; check for pit first
 27+  C630 FE 09            cp 9                        ; if not on this row, not in the pit
 28+  C632 C2 41 C6         jp nz,player_getlocation0
 29+  C635 79               ld a,c                      ; check horizontal
 30+  C636 FE 09            cp 9
 31+  C638 D2 41 C6         jp nc, player_getlocation0  ; if more than 9, not in the pit
 32+  C63B 21 27 C6         ld hl,player_location
 33+  C63E 36 02            ld (hl),2                   ; load location with 2, the pit
 34+  C640 C9               ret                         ; done
 35+  C641              player_getlocation0:            ; check for diamond cavern
 36+  C641 78               ld a,b                      ; first check vertical
 37+  C642 FE 16            cp 22                       ; if above row 22, then not in cavern
 38+  C644 DA 58 C6         jp c,player_getlocation1
 39+  C647 79               ld a,c                      ; get the horizontal next
 40+  C648 FE 0B            cp 11
 41+  C64A DA 58 C6         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 42+  C64D FE 17            cp 23
 43+  C64F D2 58 C6         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 44+  C652 21 27 C6         ld hl,player_location
 45+  C655 36 01            ld (hl),1                   ; load location with 1, the cavern
 46+  C657 C9               ret
 47+  C658              player_getlocation1:
 48+  C658 21 27 C6         ld hl,player_location
 49+  C65B 36 00            ld (hl),0                   ; load location with 2, the pit
 50+  C65D C9               ret                         ; done
 51+  C65E
 52+  C65E
 53+  C65E              ;
 54+  C65E              ; Initializes a player at start of game
 55+  C65E              ; Copy initial coords, copy lives, copy score
 56+  C65E              ;
 57+  C65E              player_init_gamestart:
 58+  C65E 3A 2A C5         ld a,(game_numberlives)
 59+  C661 32 1F C7         ld (player1_lives),a
 60+  C664 32 20 C7         ld (player2_lives),a                        ; set the initial number of lives at game start
 61+  C667
 62+  C667 21 23 C7         ld hl,player1_score+2
 63+  C66A 06 06            ld b,6
 64+  C66C              player_init_gamestart0:
 65+  C66C 36 30            ld (hl),48
 66+  C66E 23               inc hl
 67+  C66F 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 68+  C671 21 2C C7         ld hl,player2_score+2
 69+  C674 06 06            ld b,6
 70+  C676              player_init_gamestart1:
 71+  C676 36 30            ld (hl),48
 72+  C678 23               inc hl
 73+  C679 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 74+  C67B 3E 01            ld a,1
 75+  C67D 32 33 C7         ld (player1_difficulty),a
 76+  C680 32 34 C7         ld (player2_difficulty),a                   ; set player difficulties to zero
 77+  C683 C9               ret
 78+  C684
 79+  C684              ;
 80+  C684              ; Initializes a player at start of a life
 81+  C684              ; Copy initial coords, copy lives, copy score
 82+  C684              ;
 83+  C684              player_init_lifestart:
 84+  C684 21 1D C6         ld hl,player+5
 85+  C687 06 09            ld b,9                      ; initialise 9 properties
 86+  C689              player_init_lifestart2:
 87+  C689 36 00            ld (hl),0
 88+  C68B 23               inc hl
 89+  C68C 10 FB            djnz player_init_lifestart2
 90+  C68E
 91+  C68E 21 1A C6         ld hl,player+2              ; initialise some properties
 92+  C691 36 02            ld (hl),2
 93+  C693 23               inc hl
 94+  C694 36 00            ld (hl),0
 95+  C696 23               inc hl
 96+  C697 36 01            ld (hl),1
 97+  C699
 98+  C699 ED 4B EB 80      ld bc,(init_coord)
 99+  C69D ED 43 18 C6      ld (player),bc
100+  C6A1
101+  C6A1 3A 29 C5         ld a,(game_currentplayer)
102+  C6A4 FE 01            cp 1
103+  C6A6 C2 B3 C6         jp nz,player_init_lifestart4
104+  C6A9 01 21 C6         ld bc,player+9
105+  C6AC 3A 1F C7         ld a,(player1_lives)
106+  C6AF 02               ld (bc),a
107+  C6B0 C3 BA C6         jp player_init_lifestart3
108+  C6B3              player_init_lifestart4:
109+  C6B3 01 21 C6         ld bc,player+9
110+  C6B6 3A 20 C7         ld a,(player2_lives)
111+  C6B9 02               ld (bc),a
112+  C6BA              player_init_lifestart3:
113+  C6BA CD AB CF         call diamonds_init      ; initialise gems
114+  C6BD 01 06 00         ld bc,6
115+  C6C0 11 54 CD         ld de,scores_current+2
116+  C6C3 3A 29 C5         ld a,(game_currentplayer)
117+  C6C6 FE 01            cp 1
118+  C6C8 C2 D7 C6         jp nz,player_init_lifestart0
119+  C6CB 3A 33 C7         ld a,(player1_difficulty)       ; initialise player 1 difficulty
120+  C6CE 32 2B C5         ld (game_difficulty),a
121+  C6D1 21 23 C7         ld hl,player1_score+2           ; itialise player 1 scores
122+  C6D4 C3 E0 C6         jp player_init_lifestart1
123+  C6D7              player_init_lifestart0:
124+  C6D7 3A 34 C7         ld a,(player2_difficulty)       ; initialise player 2 difficulty
125+  C6DA 32 2B C5         ld (game_difficulty),a
126+  C6DD 21 2C C7         ld hl,player2_score+2           ; initialise player 2 scores
127+  C6E0              player_init_lifestart1:
128+  C6E0 ED B0            ldir
129+  C6E2 C9               ret
130+  C6E3
131+  C6E3
132+  C6E3              ;
133+  C6E3              ; Copies the current score and difficulty in the current player
134+  C6E3              ;
135+  C6E3              player_recordcurrentstate:
136+  C6E3 01 06 00         ld bc,6                  ; copy current score back to correct player
137+  C6E6 21 54 CD         ld hl,scores_current+2
138+  C6E9 3A 29 C5         ld a,(game_currentplayer)
139+  C6EC FE 01            cp 1
140+  C6EE C2 03 C7         jp nz,player_recordcurrentstate0
141+  C6F1 3A 2B C5         ld a,(game_difficulty)
142+  C6F4 32 33 C7         ld (player1_difficulty),a       ; store difficulty
143+  C6F7 11 23 C7         ld de,player1_score+2
144+  C6FA 3A 21 C6         ld a,(player+9)
145+  C6FD 32 1F C7         ld (player1_lives),a              ; record lives
146+  C700 C3 12 C7         jp player_recordcurrentstate1
147+  C703              player_recordcurrentstate0:         ; do player 2
148+  C703 3A 2B C5         ld a,(game_difficulty)
149+  C706 32 34 C7         ld (player2_difficulty),a       ; store difficulty
150+  C709 3A 21 C6         ld a,(player+9)
151+  C70C 32 20 C7         ld (player2_lives),a              ; record lives
152+  C70F 11 2C C7         ld de,player2_score+2
153+  C712              player_recordcurrentstate1:
154+  C712 ED B0            ldir
155+  C714 C9               ret
156+  C715
157+  C715              ;
158+  C715              ; Player just died, subtract a life
159+  C715              ;
160+  C715              player_died:
161+  C715 01 21 C6         ld bc,player+9
162+  C718 0A               ld a,(bc)
163+  C719 3D               dec a
164+  C71A 02               ld (bc),a
165+  C71B CD E3 C6         call player_recordcurrentstate
166+  C71E C9               ret
167+  C71F
168+  C71F              ;
169+  C71F              ; Player lives
170+  C71F              ;
171+  C71F              player1_lives:
172+  C71F 03               defb 3
173+  C720              player2_lives:
174+  C720 03               defb 3
175+  C721
176+  C721              ;
177+  C721              ; Player scores
178+  C721              ;
179+  C721              player1_score:
180+  C721 04 01 30 30      defb 4,1,'000000',255
180+  C725 30 30 30 30
180+  C729 FF
181+  C72A              player2_score:
182+  C72A 16 01 30 30      defb 22,1,'000000',255
182+  C72E 30 30 30 30
182+  C732 FF
183+  C733
184+  C733              ;
185+  C733              ; Player difficulties
186+  C733              ;
187+  C733              player1_difficulty:
188+  C733 00               defb 0
189+  C734              player2_difficulty:
190+  C734 00               defb 0
191+  C735
192+  C735              ;
193+  C735              ; Kills a player this life
194+  C735              ;
195+  C735              player_killplayer:
196+  C735 21 22 C6         ld hl,player+10
197+  C738 36 01            ld (hl),1
198+  C73A C9               ret
199+  C73B
200+  C73B              ;
201+  C73B              ; Crush a player this life
202+  C73B              ;
203+  C73B              player_crushplayer:
204+  C73B 21 23 C6         ld hl,player+11             ; mark as crushed
205+  C73E 36 01            ld (hl),1
206+  C740 C9               ret
207+  C741
208+  C741              player_tankkillplayer
209+  C741 21 23 C6         ld hl,player+11             ; mark as tanked
210+  C744 36 02            ld (hl),2
211+  C746 C9               ret
212+  C747
213+  C747              player_zonkplayer
214+  C747 21 23 C6         ld hl,player+11             ; mark as zonked (missile)
215+  C74A 36 03            ld (hl),3
216+  C74C C9               ret
217+  C74D
218+  C74D              player_pitkillplayer
219+  C74D 21 23 C6         ld hl,player+11             ; mark as pit killed
220+  C750 36 04            ld (hl),4
221+  C752 C9               ret
222+  C753
223+  C753              player_robotkillplayer
224+  C753 21 23 C6         ld hl,player+11             ; mark as robot killed
225+  C756 36 05            ld (hl),5
226+  C758 C9               ret
227+  C759
228+  C759              ;
229+  C759              ; Draws the player at the current position or deletes them
230+  C759              ;
231+  C759              player_drawplayer:
232+  C759 3A 1A C6         ld a,(player+2)             ; get the current direction
233+  C75C FE 03            cp 3
234+  C75E C2 63 C7         jp nz,player_drawplayer0
235+  C761 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
236+  C763              player_drawplayer0:             ; DYING CHECKS
237+  C763 5F               ld e,a                      ; store in e
238+  C764 3A 23 C6         ld a,(player+11)             ; get the dying flag
239+  C767 FE 01            cp 1
240+  C769 CA A3 C7         jp z,player_drawplayer3     ; if it's one, we're being crushed
241+  C76C FE 04            cp 4
242+  C76E CA EB C7         jp z,player_drawplayer9     ; player is falling into the pit
243+  C771 FE 05            cp 5
244+  C773 CA 07 C8         jp z,player_drawplayer12    ; player has been killed by a robot
245+  C776              player_drawplayer4:             ; CHECK FOR DIGGING
246+  C776 3A 1E C6         ld a,(player+6)             ; get the dig flag
247+  C779 FE 01            cp 1
248+  C77B CA 8C C7         jp z,player_drawplayer1    ; get dig frame
249+  C77E 3A 1B C6         ld a,(player+3)             ; this is normal movement so get the current frame
250+  C781 83               add a,e
251+  C782 C3 91 C7         jp player_drawplayer2
252+  C785              player_drawplayer6:             ; GETTING THE DIG FRAM
253+  C785 E6 01            and 1                       ; check for odd
254+  C787 C6 0A            add 10                      ; add 10, to get either 10 or 11
255+  C789 C3 91 C7         jp player_drawplayer2
256+  C78C              player_drawplayer1:             ; GET THE NORMAL FRAME
257+  C78C 3A 1A C6         ld a,(player+2)             ; digging, get the current direction again, because want all four
258+  C78F C6 06            add a,6                     ; add direction to 6 to get frame
259+  C791              player_drawplayer2:             ; WORK OUT THE FRAME
260+  C791 07               rlca
261+  C792 07               rlca
262+  C793 07               rlca                        ; multiply by eight
263+  C794 6F               ld l,a
264+  C795 26 00            ld h,0
265+  C797 11 64 BE         ld de,player_sprite
266+  C79A 19               add hl,de                   ; load hl with the location of the player sprite data
267+  C79B              player_drawplayer7:             ; DRAW THE PlAYER
268+  C79B ED 4B 18 C6      ld bc,(player)              ; load bc with the start coords
269+  C79F CD 29 AB         call sprites_drawsprite     ; call the routine to draw the sprite
270+  C7A2                  ;call player_storeupdatedlines ; log updated rows
271+  C7A2 C9               ret
272+  C7A3              ;
273+  C7A3              ; CRUSHING
274+  C7A3              ;
275+  C7A3              player_drawplayer3:
276+  C7A3 21 24 C6         ld hl,player+12
277+  C7A6 7E               ld a,(hl)                  ; crushing, so get the current anim flag
278+  C7A7 FE 00            cp 0
279+  C7A9 C2 B2 C7         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
280+  C7AC 3E 64            ld a,100
281+  C7AE 77               ld (hl),a                   ; otherwise, load up the anim frames
282+  C7AF C3 76 C7         jp player_drawplayer4       ; and return to the main loop to remove the current frame
283+  C7B2              player_drawplayer5:
284+  C7B2 3D               dec a
285+  C7B3 77               ld (hl),a
286+  C7B4 FE 00            cp 0
287+  C7B6 CC 35 C7         call z,player_killplayer     ; final animation, so kill the player
288+  C7B9 FE 0A            cp 10                         ; play the sound
289+  C7BB CC 47 B2         call z, sound_rockfell
290+  C7BE FE 14            cp 20                        ; check if we should move the rock
291+  C7C0 C2 D4 C7         jp nz,player_drawplayer8
292+  C7C3 D9               exx
293+  C7C4 F5               push af
294+  C7C5 ED 4B F2 CB      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
295+  C7C9 21 B0 BD         ld hl,sprites+72
296+  C7CC CD 29 AB         call sprites_drawsprite     ; draw a rock over current
297+  C7CF F1               pop af
298+  C7D0 D9               exx
299+  C7D1 C3 85 C7         jp player_drawplayer6       ; continue drawing player
300+  C7D4              player_drawplayer8:
301+  C7D4 FE 14            cp 20
302+  C7D6 D2 85 C7         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
303+  C7D9 ED 4B 18 C6      ld bc,(player)
304+  C7DD CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
305+  C7E0 3E 42            ld a,66             ; load red
306+  C7E2 CD AF AA         call screen_setattr
307+  C7E5 21 B0 BD         ld hl,sprites+72            ; otherwise, player is rock
308+  C7E8 C3 9B C7         jp player_drawplayer7
309+  C7EB              ;
310+  C7EB              ; FALLING
311+  C7EB              ;
312+  C7EB              player_drawplayer9:             ; player is falling into the pit
313+  C7EB 21 24 C6         ld hl,player+12
314+  C7EE 7E               ld a,(hl)                   ; get the frames
315+  C7EF FE 00            cp 0
316+  C7F1 C2 FA C7         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
317+  C7F4 3E 50            ld a,80
318+  C7F6 77               ld (hl),a                   ; otherwise, load up the anim frames
319+  C7F7 C3 76 C7         jp player_drawplayer4       ; and return to the main loop to remove the current frame
320+  C7FA              player_drawplayer10:
321+  C7FA 3D               dec a
322+  C7FB 77               ld (hl),a
323+  C7FC FE 00            cp 0
324+  C7FE CC 35 C7         call z,player_killplayer     ; final frame, so kill the player
325+  C801 3A 1B C6         ld a,(player+3)
326+  C804 C3 91 C7         jp player_drawplayer2
327+  C807              ;
328+  C807              ; ROBOT KILLED
329+  C807              ;
330+  C807              player_drawplayer12:
331+  C807 21 24 C6         ld hl,player+12
332+  C80A 7E               ld a,(hl)                   ; get the frames
333+  C80B FE 00            cp 0
334+  C80D C2 16 C8         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
335+  C810 3E C8            ld a,200
336+  C812 77               ld (hl),a                   ; otherwise, load up the anim frames
337+  C813 C3 76 C7         jp player_drawplayer4       ; and return to the main loop to remove the current frame
338+  C816              player_drawplayer13:
339+  C816 3D               dec a
340+  C817 77               ld (hl),a
341+  C818 FE 00            cp 0
342+  C81A CC 35 C7         call z,player_killplayer     ; final frame, so kill the player
343+  C81D 3A 1B C6         ld a,(player+3)
344+  C820 C3 91 C7         jp player_drawplayer2
345+  C823
346+  C823              ;
347+  C823              ; Runs after the player just moved. Changes animation frame if required
348+  C823              ;
349+  C823              player_justmoved:
350+  C823 D9               exx
351+  C824 3A 1C C6         ld a,(player+4)             ; get the transition count
352+  C827 FE 00            cp 0
353+  C829 CA 2F C8         jp z, player_justmoved2     ; if zero reset and change the frame
354+  C82C C3 49 C8         jp player_justmoved1       ; otherwise decrease and continue
355+  C82F              player_justmoved2:
356+  C82F                  ; reset and change frame in here
357+  C82F 3E 01            ld a,1
358+  C831 32 1C C6         ld (player+4),a            ; reset back to whatever
359+  C834 3A 1B C6         ld a,(player+3)             ; load the frame
360+  C837 FE 03            cp 3                       ; flip between 3 and 0
361+  C839 C2 41 C8         jp nz, player_justmoved4
362+  C83C 3E 00            ld a,0
363+  C83E C3 43 C8         jp player_justmoved5
364+  C841              player_justmoved4:
365+  C841 3E 03            ld a,3
366+  C843              player_justmoved5:
367+  C843 32 1B C6         ld (player+3),a           ; save back
368+  C846 C3 4D C8         jp player_justmoved3
369+  C849              player_justmoved1:
370+  C849                  ; decrease count
371+  C849 3D               dec a
372+  C84A 32 1C C6         ld (player+4),a
373+  C84D              player_justmoved3:
374+  C84D D9               exx;
375+  C84E C9               ret
376+  C84F
377+  C84F              ;
378+  C84F              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
379+  C84F              ; Outputs:
380+  C84F              ; a - 1 for completed level
381+  C84F              player_checkforexit:
382+  C84F ED 4B 18 C6      ld bc,(player)                 ; get player coords
383+  C853 ED 5B EB 80      ld de,(init_coord)             ; get start coords
384+  C857 78               ld a,b
385+  C858 BA               cp d                         ; compare horiz
386+  C859 C2 64 C8         jp nz,player_checkforexit1
387+  C85C 79               ld a,c
388+  C85D BB               cp e                        ; compare vert
389+  C85E C2 64 C8         jp nz,player_checkforexit1
390+  C861              player_checkforexit0:
391+  C861 3E 01            ld a,1                       ; hasn't completed
392+  C863 C9               ret
393+  C864              player_checkforexit1:
394+  C864 3E 00            ld a,0                       ; has completed
395+  C866 C9               ret
# file closed: game/player.asm
159   C867                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  C867              ;
  2+  C867              ; Ship initial position: vert,horiz
  3+  C867              ;
  4+  C867              ship_initpos:
  5+  C867 00 24            defb 0,36
  6+  C869              ship_initpos2:
  7+  C869 00 00            defb 0,0
  8+  C86B              ship_frame:
  9+  C86B 00               defb 0
 10+  C86C              ;
 11+  C86C              ; The current memory location
 12+  C86C              ;
 13+  C86C              ship_current_sprite:
 14+  C86C 00 00            defb 0,0
 15+  C86E
 16+  C86E              ship_current_coords:
 17+  C86E 00 00            defb 0,0
 18+  C870
 19+  C870              ship_soundpitch:
 20+  C870 00               defb 0
 21+  C871
 22+  C871              ship_process:
 23+  C871 3A 23 C6         ld a,(player+11)
 24+  C874 FE 02            cp 2                        ; has the player been killed by tank?
 25+  C876 C0               ret nz                      ; do nothing if not
 26+  C877 CD F4 C2         call control_scroll_up           ; make sure the screen is on the top screen
 27+  C87A CD 23 C9         call ship_takeoff           ; bye bye
 28+  C87D CD 35 C7         call player_killplayer      ; killed
 29+  C880 06 32            ld b,50
 30+  C882 CD 64 81         call utilities_pauseforframes
 31+  C885 C9               ret
 32+  C886
 33+  C886              ship_sound:
 34+  C886 16 00            ld d,0
 35+  C888 3A 70 C8         ld a,(ship_soundpitch)
 36+  C88B 1E 04            ld e,4
 37+  C88D 93               sub e
 38+  C88E 5F               ld e,a
 39+  C88F 32 70 C8         ld (ship_soundpitch),a
 40+  C892 01 10 00         ld bc,16
 41+  C895 F3               di
 42+  C896 CD 62 B1         call sound_play
 43+  C899 FB               ei
 44+  C89A C9               ret
 45+  C89B
 46+  C89B              ship_soundup:
 47+  C89B 16 00            ld d,0
 48+  C89D 3A 70 C8         ld a,(ship_soundpitch)
 49+  C8A0 1E 04            ld e,4
 50+  C8A2 83               add e
 51+  C8A3 5F               ld e,a
 52+  C8A4 32 70 C8         ld (ship_soundpitch),a
 53+  C8A7 01 10 00         ld bc,16
 54+  C8AA F3               di
 55+  C8AB CD 62 B1         call sound_play
 56+  C8AE FB               ei
 57+  C8AF C9               ret
 58+  C8B0
 59+  C8B0              ;
 60+  C8B0              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 61+  C8B0              ;
 62+  C8B0              ship_land:
 63+  C8B0 3E 96            ld a,150
 64+  C8B2 32 70 C8         ld (ship_soundpitch),a
 65+  C8B5 ED 4B 67 C8      ld bc,(ship_initpos)
 66+  C8B9 ED 43 69 C8      ld (ship_initpos2),bc        ; save the initial position for later use
 67+  C8BD 1E 00            ld e,0                      ; store a flag to track first time round
 68+  C8BF 06 09            ld b,9                      ; move down 8 pixels
 69+  C8C1              ship_land0:
 70+  C8C1 C5               push bc
 71+  C8C2 7B               ld a,e
 72+  C8C3 D5               push de                     ; store de for next time round
 73+  C8C4 FE 01            cp 1                        ; check first time flag
 74+  C8C6 C2 DB C8         jp nz,ship_land1             ; don't draw over previous one if first time
 75+  C8C9 CD 6E C9         call ship_draw_full         ; delete old one
 76+  C8CC CD 52 C9         call ship_change_frame      ; increment the frame
 77+  C8CF ED 4B 69 C8      ld bc,(ship_initpos2)       ; get the current coords
 78+  C8D3 81 C6 01         add c,1                     ; move down one pixels
 79+  C8D6 4F               ld c,a
 80+  C8D7 ED 43 69 C8      ld (ship_initpos2),bc
 81+  C8DB              ship_land1:
 82+  C8DB CD 6E C9         call ship_draw_full         ; draw the ship
 83+  C8DE D1               pop de
 84+  C8DF 7B               ld a,e
 85+  C8E0 FE 00            cp 0
 86+  C8E2 C2 E5 C8         jp nz,ship_land4
 87+  C8E5                  ;call sound_pitchbend        ; play sound if first frame
 88+  C8E5              ship_land4:
 89+  C8E5 D5               push de
 90+  C8E6 CD 67 C9         call ship_draw_screen
 91+  C8E9 CD 86 C8         call ship_sound
 92+  C8EC D1               pop de
 93+  C8ED 1E 01            ld e,1
 94+  C8EF C1               pop bc
 95+  C8F0 10 CF            djnz ship_land0             ; repeat for downward movement
 96+  C8F2                  ; done moving down
 97+  C8F2                  ; now move across
 98+  C8F2 CD 59 C7         call player_drawplayer      ; draw player
 99+  C8F5 CD 6E C9         call ship_draw_full         ; delete old one
100+  C8F8 1E 00            ld e,0                      ; store a flag to track first time round
101+  C8FA 06 14            ld b,20                      ; move back 20 pixels pixels
102+  C8FC              ship_land3:
103+  C8FC C5               push bc
104+  C8FD 7B               ld a,e
105+  C8FE D5               push de                     ; store de for next time round
106+  C8FF FE 01            cp 1                        ; check first time flag
107+  C901 C2 16 C9         jp nz,ship_land2             ; don't draw over previous one if first time
108+  C904 CD 6E C9         call ship_draw_full         ; delete old one
109+  C907 CD 52 C9         call ship_change_frame      ; increment the frame
110+  C90A ED 4B 69 C8      ld bc,(ship_initpos2)       ; get the current coords
111+  C90E 78               ld a,b
112+  C90F D6 01            sub 1                       ; move back one pixels
113+  C911 47               ld b,a
114+  C912 ED 43 69 C8      ld (ship_initpos2),bc
115+  C916              ship_land2:
116+  C916 CD 6E C9         call ship_draw_full         ; draw the ship
117+  C919 CD 67 C9         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
118+  C91C D1               pop de
119+  C91D 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
120+  C91F C1               pop bc
121+  C920 10 DA            djnz ship_land3             ; repeat for vertical movement
122+  C922 C9               ret
123+  C923
124+  C923              ;
125+  C923              ;   Take off the ship
126+  C923              ;
127+  C923              ship_takeoff:
128+  C923                  ;call sound_pitchbenddown
129+  C923 1E 01            ld e,1                      ; store a flag to track first time round
130+  C925 06 08            ld b,8                      ; move up 8 pixels
131+  C927              ship_takeoff0:
132+  C927 C5               push bc
133+  C928 7B               ld a,e
134+  C929 D5               push de                     ; store de for next time round
135+  C92A FE 01            cp 1                        ; check first time flag
136+  C92C C2 42 C9         jp nz,ship_takeoff1             ; don't draw over previous one if first time
137+  C92F ED 4B 69 C8      ld bc,(ship_initpos2)       ; get the current coords
138+  C933 CD 6E C9         call ship_draw_full         ; delete old one
139+  C936 CD 52 C9         call ship_change_frame      ; increment the frame
140+  C939 ED 4B 69 C8      ld bc,(ship_initpos2)       ; get the current coords
141+  C93D 0D               dec c                       ; move up one pixels
142+  C93E ED 43 69 C8      ld (ship_initpos2),bc
143+  C942              ship_takeoff1:
144+  C942 CD 6E C9         call ship_draw_full         ; draw the ship
145+  C945 CD 67 C9         call ship_draw_screen
146+  C948 CD 9B C8         call ship_soundup
147+  C94B D1               pop de
148+  C94C 1E 01            ld e,1
149+  C94E C1               pop bc
150+  C94F 10 D6            djnz ship_takeoff0             ; repeat for upward movement
151+  C951                  ; done moving up
152+  C951 C9               ret
153+  C952
154+  C952              ;
155+  C952              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
156+  C952              ;
157+  C952              ship_change_frame:
158+  C952 F5               push af
159+  C953 3A 6B C8         ld a,(ship_frame)
160+  C956 FE 00            cp 0
161+  C958 CA 60 C9         jp z,ship_change_frame0
162+  C95B 3E 00            ld a,0                      ; flip to 0
163+  C95D C3 62 C9         jp ship_change_frame1
164+  C960              ship_change_frame0:
165+  C960 3E 20            ld a,32                      ; flip to 32
166+  C962              ship_change_frame1:
167+  C962 32 6B C8         ld (ship_frame),a            ; save the frame
168+  C965 F1               pop af
169+  C966 C9               ret
170+  C967
171+  C967              ship_draw_screen:
172+  C967 76               halt
173+  C968 F3               di
174+  C969 CD 20 A8         call buffer_buffertoscreen  ; copy buffer to screen
175+  C96C FB               ei                          ; enable interupts
176+  C96D C9               ret
177+  C96E
178+  C96E              ship_draw_full:
179+  C96E 21 D4 BE         ld hl,ship_sprite
180+  C971 ED 4B 69 C8      ld bc,(ship_initpos2)         ; load bc with the start coords
181+  C975 22 6C C8         ld (ship_current_sprite),hl  ; put into memory
182+  C978 ED 43 6E C8      ld (ship_current_coords),bc  ; put into memory
183+  C97C CD 9B C9         call ship_draw
184+  C97F 08               ex af,af'
185+  C980 3A 6B C8         ld a,(ship_frame)            ; get the animation frame
186+  C983 16 00            ld d,0
187+  C985 5F               ld e,a
188+  C986 19               add hl,de
189+  C987 22 6C C8         ld (ship_current_sprite),hl  ; put into memory
190+  C98A 08               ex af,af'
191+  C98B ED 4B 69 C8      ld bc,(ship_initpos2)         ; load bc with the start coords
192+  C98F 81 C6 08         add c,8                      ; move one line down
193+  C992 4F               ld c,a
194+  C993 ED 43 6E C8      ld (ship_current_coords),bc  ; put into memory
195+  C997 CD 9B C9         call ship_draw
196+  C99A C9               ret
197+  C99B
198+  C99B              ;
199+  C99B              ; Draw the ship
200+  C99B              ; Inputs:
201+  C99B              ; None, all in memory
202+  C99B              ;
203+  C99B              ship_draw:
204+  C99B 3E 04            ld a,4                              ; 4 pieces per half
205+  C99D              ship_draw0:
206+  C99D F5               push af
207+  C99E 2A 6C C8         ld hl,(ship_current_sprite)
208+  C9A1 ED 4B 6E C8      ld bc,(ship_current_coords)         ; load bc with the start coords
209+  C9A5 CD 29 AB         call sprites_drawsprite
210+  C9A8 2A 6C C8         ld hl,(ship_current_sprite)
211+  C9AB ED 4B 6E C8      ld bc,(ship_current_coords)         ; load bc with the start coords
212+  C9AF 11 08 00         ld de,8
213+  C9B2 19               add hl,de
214+  C9B3 80 C6 08         add b,8
215+  C9B6 47               ld b,a
216+  C9B7 22 6C C8         ld (ship_current_sprite),hl         ; put into memory
217+  C9BA ED 43 6E C8      ld (ship_current_coords),bc         ; put into memory
218+  C9BE F1               pop af
219+  C9BF 3D               dec a
220+  C9C0 FE 00            cp 0
221+  C9C2 C2 9D C9         jp nz,ship_draw0
222+  C9C5
223+  C9C5 C9               ret
224+  C9C6
# file closed: game/ship.asm
160   C9C6                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  C9C6              ;
  2+  C9C6              ; tank initial position: vert,horiz
  3+  C9C6              ;
  4+  C9C6              tank_initpos:
  5+  C9C6 10 D0            defb 16,208
  6+  C9C8              tank_initpos2:
  7+  C9C8 00 00            defb 0,0
  8+  C9CA              tank_frame:
  9+  C9CA 00               defb 0
 10+  C9CB              tank_anim:
 11+  C9CB 11               defb 17
 12+  C9CC
 13+  C9CC              ;
 14+  C9CC              ; The damage countdown
 15+  C9CC              ;
 16+  C9CC              tank_currentdamage:
 17+  C9CC F0               defb 240
 18+  C9CD
 19+  C9CD              ;
 20+  C9CD              ; The damage coordinate
 21+  C9CD              ;
 22+  C9CD              tank_currentdamagecoord:
 23+  C9CD 16 02            defb 22,2
 24+  C9CF
 25+  C9CF              ;
 26+  C9CF              ; Controls when the tank shoots
 27+  C9CF              ;
 28+  C9CF              tank_count:
 29+  C9CF 00               defb 0
 30+  C9D0
 31+  C9D0              ;
 32+  C9D0              ; Holds the block number of the current damage sprite
 33+  C9D0              ;
 34+  C9D0              tank_damageframe:
 35+  C9D0 00               defb 0
 36+  C9D1
 37+  C9D1              ;
 38+  C9D1              ; The current memory location
 39+  C9D1              ;
 40+  C9D1              tank_current_sprite:
 41+  C9D1 00 00            defb 0,0
 42+  C9D3
 43+  C9D3              tank_current_coords:
 44+  C9D3 00 00            defb 0,0
 45+  C9D5
 46+  C9D5              ;
 47+  C9D5              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  C9D5              ;
 49+  C9D5              tank_missile_displayed:
 50+  C9D5 00               defb 0
 51+  C9D6
 52+  C9D6              ;
 53+  C9D6              ; Speed that the tank fires
 54+  C9D6              ;
 55+  C9D6              tank_speed:
 56+  C9D6 00               defb 0
 57+  C9D7
 58+  C9D7              ;
 59+  C9D7              ; Initialise the tank
 60+  C9D7              ;
 61+  C9D7              tank_init:
 62+  C9D7 ED 4B C6 C9      ld bc,(tank_initpos)
 63+  C9DB ED 43 C8 C9      ld (tank_initpos2),bc       ; save the initial position for later use
 64+  C9DF 21 CA C9         ld hl,tank_frame
 65+  C9E2 36 00            ld (hl),0
 66+  C9E4 21 CB C9         ld hl,tank_anim
 67+  C9E7 36 11            ld (hl),17
 68+  C9E9 21 D0 C9         ld hl,tank_damageframe              ; reset tank
 69+  C9EC 36 00            ld (hl),0
 70+  C9EE 21 CF C9         ld hl,tank_count
 71+  C9F1 36 00            ld (hl),0
 72+  C9F3 21 CC C9         ld hl,tank_currentdamage
 73+  C9F6 36 F0            ld (hl),240
 74+  C9F8 21 CD C9         ld hl,tank_currentdamagecoord
 75+  C9FB 36 16            ld (hl),22
 76+  C9FD 23               inc hl
 77+  C9FE 36 02            ld (hl),2
 78+  CA00 21 D5 C9         ld hl,tank_missile_displayed
 79+  CA03 36 00            ld (hl),0
 80+  CA05
 81+  CA05 C9               ret
 82+  CA06
 83+  CA06              ;
 84+  CA06              ;   Draw and move the tank
 85+  CA06              ;   Start processing at frame 75
 86+  CA06              ;   Don't move if anim is zero
 87+  CA06              ;   Decrement frame if moved
 88+  CA06              ;
 89+  CA06              tank_process:
 90+  CA06 3A CB C9         ld a,(tank_anim)
 91+  CA09 FE 00            cp 0
 92+  CA0B C2 12 CA         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 93+  CA0E CD 2B CA         call tank_fire
 94+  CA11 C9               ret
 95+  CA12              tank_process0:
 96+  CA12 CD C2 C5         call game_getcurrentframe   ; get the current frame number into a
 97+  CA15 FE 4B            cp 75
 98+  CA17 D8               ret c                       ; return if the frame number is below 75
 99+  CA18 CD 65 CB         call tank_move              ; move tank if not
100+  CA1B 3A CB C9         ld a,(tank_anim)
101+  CA1E 3D               dec a
102+  CA1F 32 CB C9         ld (tank_anim),a            ; decrease the anim count
103+  CA22 FE 00            cp 0
104+  CA24 C0               ret nz
105+  CA25 3E 01            ld a,1
106+  CA27 32 7C D3         ld (robots_spawntimer),a ; set the spawn speed low so that a robot spawns soon after the tank stops moving
107+  CA2A C9               ret
108+  CA2B
109+  CA2B              ;
110+  CA2B              ; Fires the tank
111+  CA2B              ;
112+  CA2B              tank_fire:
113+  CA2B 3A CF C9         ld a,(tank_count)            ; if not, don't do anything
114+  CA2E 3C               inc a                        ; increment
115+  CA2F ED 5B D6 C9      ld de,(tank_speed)
116+  CA33 BB               cp e                        ; have we reached the speed
117+  CA34 C2 39 CA         jp nz,tank_fire0
118+  CA37 3E 00            ld a,0                       ; reset if reached fifty
119+  CA39              tank_fire0:                      ; DEALING WITH A NEW BLOCK
120+  CA39 32 CF C9         ld (tank_count),a            ; store tank count
121+  CA3C FE 00            cp 0
122+  CA3E CA 5F CA         jp z,tank_fire7              ; If this is zero, fire
123+  CA41 3A D5 C9         ld a,(tank_missile_displayed) ; is the missile displaying?
124+  CA44 FE 00            cp 0
125+  CA46 C8               ret z                       ; don't do anything if not
126+  CA47 CD 1F CB         call tank_missilegraphic     ; if not, overwrite the previous tank missile
127+  CA4A 3E 00            ld a,0                       ; reset the flag
128+  CA4C 32 D5 C9         ld (tank_missile_displayed),a
129+  CA4F 3E 02            ld a,2
130+  CA51 ED 4B CD C9      ld bc,(tank_currentdamagecoord)
131+  CA55 0C               inc c
132+  CA56 0C               inc c
133+  CA57 ED 43 53 AC      ld (origcoords),bc
134+  CA5B CD 45 A7         call buffer_marklineforupdate
135+  CA5E C9               ret                        ; only shoot if we're on 0
136+  CA5F              tank_fire7:
137+  CA5F 3A CC C9         ld a,(tank_currentdamage)    ; get the damage countdown
138+  CA62 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
139+  CA64 C2 9A CA         jp nz,tank_fire1            ; not, so just do a normal frame
140+  CA67 ED 4B CD C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
141+  CA6B 79               ld a,c
142+  CA6C FE 0A            cp 10
143+  CA6E C2 75 CA         jp nz, tank_fire6
144+  CA71 CD 57 CB         call tank_killedbytank      ; we're through, so the player has died. Kill them.
145+  CA74 C9               ret                         ; return if we're through the mountain
146+  CA75              tank_fire6:
147+  CA75 3E 0F            ld a,15
148+  CA77 32 D0 C9         ld (tank_damageframe),a     ; reset the damage frame
149+  CA7A 21 68 BD         ld hl,sprites               ; location of the empty block
150+  CA7D CD 81 AA         call screen_showchar        ; show this character here
151+  CA80 ED 4B CD C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
152+  CA84 05               dec b                       ; look one above
153+  CA85 CD E5 AA         call screen_ischarempty     ; check if it is empty
154+  CA88 ED 4B CD C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
155+  CA8C FE 01            cp 1
156+  CA8E C2 D1 CA         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
157+  CA91 ED 4B CD C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
158+  CA95 0D               dec c
159+  CA96 ED 43 CD C9      ld (tank_currentdamagecoord),bc ; store the coord
160+  CA9A              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
161+  CA9A ED 4B CD C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
162+  CA9E 3A CC C9         ld a,(tank_currentdamage)    ; get the damage countdown
163+  CAA1 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
164+  CAA3 C2 AE CA         jp nz, tank_fire5
165+  CAA6 CD 15 AB         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
166+  CAA9 FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
167+  CAAB C2 EF CA         jp nz,tank_fire3            ; if it's a slope, handle this differently
168+  CAAE              tank_fire5:
169+  CAAE 3A D0 C9         ld a,(tank_damageframe)
170+  CAB1 CD A4 AA         call screen_getblock        ; get the block data into hl
171+  CAB4 CD 81 AA         call screen_showchar        ; show this character here
172+  CAB7 3A D0 C9         ld a,(tank_damageframe)
173+  CABA 3C               inc a
174+  CABB 32 D0 C9         ld (tank_damageframe),a     ; increment the damage block and store
175+  CABE 3A CC C9         ld a,(tank_currentdamage)    ; get the damage countdown
176+  CAC1 3D               dec a
177+  CAC2 3D               dec a
178+  CAC3 32 CC C9         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
179+  CAC6 3A D5 C9         ld a,(tank_missile_displayed) ; is the missile displaying?
180+  CAC9 FE 00            cp 0
181+  CACB CC 1F CB         call z, tank_missilegraphic
182+  CACE C3 F8 CA         jp tank_fire4
183+  CAD1              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
184+  CAD1 05               dec b
185+  CAD2 C5               push bc
186+  CAD3 CD FE AA         call screen_copyblockdown       ; copy the block down
187+  CAD6 ED 4B CD C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
188+  CADA C1               pop bc                      ; get the coord we just checked back
189+  CADB 78               ld a,b
190+  CADC FE 00            cp 0
191+  CADE CA 9A CA         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
192+  CAE1 C5               push bc
193+  CAE2 05               dec b
194+  CAE3 CD E5 AA         call screen_ischarempty     ; check if it is empty
195+  CAE6 C1               pop bc
196+  CAE7 FE 01            cp 1                        ; if empty
197+  CAE9 C2 D1 CA         jp nz, tank_fire2            ; copy another one down
198+  CAEC C3 9A CA         jp tank_fire1               ; otherwise, return to main thread
199+  CAEF              tank_fire3:                      ; dealing with slopes
200+  CAEF 3A CC C9         ld a,(tank_currentdamage)    ; get the damage countdown
201+  CAF2 06 08            ld b,8
202+  CAF4 90               sub b                        ; special case for slopes
203+  CAF5 32 CC C9         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
204+  CAF8              tank_fire4:                     ; TIDY UP
205+  CAF8 ED 4B CD C9      ld bc,(tank_currentdamagecoord)
206+  CAFC ED 43 53 AC      ld (origcoords),bc
207+  CB00 CD 45 A7         call buffer_marklineforupdate
208+  CB03 3E 01            ld a,1
209+  CB05 CD 45 A7         call buffer_marklineforupdate
210+  CB08 3E 02            ld a,2
211+  CB0A CD 45 A7         call buffer_marklineforupdate
212+  CB0D ED 4B CD C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
213+  CB11 79               ld a,c
214+  CB12 FE 0D            cp 13
215+  CB14 DA 1B CB         jp c, tank_fire8                ; play alarm instead if getting close
216+  CB17 CD 78 B2         call sound_tankshoot
217+  CB1A C9               ret
218+  CB1B              tank_fire8:
219+  CB1B CD EA B1         call sound_tankalarm
220+  CB1E C9               ret
221+  CB1F
222+  CB1F              ;
223+  CB1F              ; Displays or hides the missile graphic, and changes the gun
224+  CB1F              ;
225+  CB1F              tank_missilegraphic:
226+  CB1F 3A D5 C9         ld a,(tank_missile_displayed)
227+  CB22 FE 00            cp 0
228+  CB24 C2 2C CB         jp nz,tank_missilegraphic0
229+  CB27 3E 13            ld a,19
230+  CB29 C3 2E CB         jp tank_missilegraphic1
231+  CB2C              tank_missilegraphic0:
232+  CB2C 3E 00            ld a,0
233+  CB2E              tank_missilegraphic1:
234+  CB2E 32 D5 C9         ld (tank_missile_displayed),a ; store the flipped graphic
235+  CB31 ED 4B CD C9      ld bc,(tank_currentdamagecoord)
236+  CB35 0C               inc c
237+  CB36 0C               inc c                   ; print the graphic 2 spaces right
238+  CB37 CD A4 AA         call screen_getblock        ; get the block data into hl
239+  CB3A CD 81 AA         call screen_showchar        ; show this character here
240+  CB3D 06 02            ld b,2
241+  CB3F 0E 18            ld c,24                     ; set gunbarrel coords
242+  CB41 11 00 00         ld de,0
243+  CB44 21 34 BF         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
244+  CB47 3A D5 C9         ld a,(tank_missile_displayed)
245+  CB4A FE 00            cp 0
246+  CB4C CA 52 CB         jp z,tank_missilegraphic2
247+  CB4F 11 40 00         ld de,64
248+  CB52              tank_missilegraphic2:
249+  CB52 19               add hl,de                   ; work out missile graphic
250+  CB53 CD 81 AA         call screen_showchar        ; show this character here
251+  CB56 C9               ret
252+  CB57
253+  CB57              ;
254+  CB57              ; Deal with the player being killed by the tank
255+  CB57              ;
256+  CB57              tank_killedbytank:
257+  CB57 ED 4B CD C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
258+  CB5B 21 68 BD         ld hl,sprites                   ; empty sprite
259+  CB5E CD 81 AA         call screen_showchar            ; hide the last piece of dirt
260+  CB61 CD 41 C7         call player_tankkillplayer
261+  CB64 C9               ret
262+  CB65
263+  CB65              tank_move:
264+  CB65 ED 4B C8 C9      ld bc,(tank_initpos2)
265+  CB69 C5               push bc
266+  CB6A 3A CB C9         ld a,(tank_anim)
267+  CB6D FE 11            cp 17                       ; check first time flag
268+  CB6F CA 81 CB         jp z,tank_move1             ; don't draw over previous one if first time
269+  CB72 CD 86 CB         call tank_draw_full         ; delete old one
270+  CB75 ED 4B C8 C9      ld bc,(tank_initpos2)       ; get the current coords
271+  CB79 78               ld a,b
272+  CB7A D6 01            sub 1                       ; move back one pixels
273+  CB7C 47               ld b,a
274+  CB7D ED 43 C8 C9      ld (tank_initpos2),bc
275+  CB81              tank_move1:
276+  CB81 CD 86 CB         call tank_draw_full         ; draw the tank
277+  CB84 C1               pop bc
278+  CB85 C9               ret
279+  CB86
280+  CB86              tank_draw_full:
281+  CB86 21 34 BF         ld hl,tank_sprite
282+  CB89 ED 4B C8 C9      ld bc,(tank_initpos2)         ; load bc with the start coords
283+  CB8D 22 D1 C9         ld (tank_current_sprite),hl  ; put into memory
284+  CB90 ED 43 D3 C9      ld (tank_current_coords),bc  ; put into memory
285+  CB94 CD B3 CB         call tank_draw
286+  CB97 08               ex af,af'
287+  CB98 3A CA C9         ld a,(tank_frame)            ; get the animation frame
288+  CB9B 16 00            ld d,0
289+  CB9D 5F               ld e,a
290+  CB9E 19               add hl,de
291+  CB9F 22 D1 C9         ld (tank_current_sprite),hl  ; put into memory
292+  CBA2 08               ex af,af'
293+  CBA3 ED 4B C8 C9      ld bc,(tank_initpos2)         ; load bc with the start coords
294+  CBA7 81 C6 08         add c,8                      ; move one line down
295+  CBAA 4F               ld c,a
296+  CBAB ED 43 D3 C9      ld (tank_current_coords),bc  ; put into memory
297+  CBAF CD B3 CB         call tank_draw
298+  CBB2 C9               ret
299+  CBB3
300+  CBB3              ;
301+  CBB3              ; Draw the tank
302+  CBB3              ; Inputs:
303+  CBB3              ; None, all in memory
304+  CBB3              ;
305+  CBB3              tank_draw:
306+  CBB3 3E 04            ld a,4                              ; 4 pieces per half
307+  CBB5              tank_draw0:
308+  CBB5 F5               push af
309+  CBB6 2A D1 C9         ld hl,(tank_current_sprite)
310+  CBB9 ED 4B D3 C9      ld bc,(tank_current_coords)         ; load bc with the start coords
311+  CBBD CD 29 AB         call sprites_drawsprite
312+  CBC0 2A D1 C9         ld hl,(tank_current_sprite)
313+  CBC3 ED 4B D3 C9      ld bc,(tank_current_coords)         ; load bc with the start coords
314+  CBC7 11 08 00         ld de,8
315+  CBCA 19               add hl,de
316+  CBCB 80 C6 08         add b,8
317+  CBCE 47               ld b,a
318+  CBCF 22 D1 C9         ld (tank_current_sprite),hl         ; put into memory
319+  CBD2 ED 43 D3 C9      ld (tank_current_coords),bc         ; put into memory
320+  CBD6 F1               pop af
321+  CBD7 3D               dec a
322+  CBD8 FE 00            cp 0
323+  CBDA C2 B5 CB         jp nz,tank_draw0
324+  CBDD
325+  CBDD C9               ret
326+  CBDE
# file closed: game/tank.asm
161   CBDE                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  CBDE              ;
  2+  CBDE              ; A structure of falling rocks
  3+  CBDE              ; Assume we'll never have more than 4 falling at any one time
  4+  CBDE              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  CBDE              ;
  6+  CBDE              rocks_falling:
  7+  CBDE 00 00 00 00      defb 0,0,0,0
  8+  CBE2 00 00 00 00      defb 0,0,0,0
  9+  CBE6 00 00 00 00      defb 0,0,0,0
 10+  CBEA 00 00 00 00      defb 0,0,0,0
 11+  CBEE
 12+  CBEE              rocks_tmp:
 13+  CBEE 00               defb 0
 14+  CBEF
 15+  CBEF              rocks_tmp2:
 16+  CBEF 00 00            defb 0,0
 17+  CBF1
 18+  CBF1              ;
 19+  CBF1              ; The number of frames to wobble for
 20+  CBF1              ; Must always be 10 more than the number of frames a player digs
 21+  CBF1              ;
 22+  CBF1              rocks_numberofframestowobble:
 23+  CBF1 14               defb 20
 24+  CBF2
 25+  CBF2              ;
 26+  CBF2              ; Coords of the rock that killed us
 27+  CBF2              ;
 28+  CBF2              rocks_killerrock:
 29+  CBF2 00 00            defb 0,0
 30+  CBF4
 31+  CBF4              ;
 32+  CBF4              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  CBF4              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  CBF4              ; If the pixel row is not the rock bottom, stop checking.
 35+  CBF4              ; Inputs:
 36+  CBF4              ; hl- memory location
 37+  CBF4              ;
 38+  CBF4              rocks_checkforfalling:
 39+  CBF4 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  CBF5 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  CBF7 C2 FD CB         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  CBFA CD FE CB         call rocks_addrocktofalling ; mark the rock as falling
 43+  CBFD              rocks_checkforfalling2:
 44+  CBFD C9               ret
 45+  CBFE
 46+  CBFE              ;
 47+  CBFE              ; Adds the rock to the structure that tracks falling rocks
 48+  CBFE              ; Inputs:
 49+  CBFE              ; hl - memory location of falling rock graphic
 50+  CBFE              ; bc - coords of rock, c vert
 51+  CBFE              rocks_addrocktofalling:
 52+  CBFE C5               push bc             ; store the coords
 53+  CBFF 11 DE CB         ld de,rocks_falling
 54+  CC02 06 04            ld b,4              ; number of possible falling rocks
 55+  CC04              rocks_addrocktofalling0:
 56+  CC04 13               inc de
 57+  CC05                  ;inc de
 58+  CC05 13               inc de              ; move three along to get the state
 59+  CC06 1A               ld a,(de)           ; load the state
 60+  CC07 FE 00            cp 0                ; check if this is not falling
 61+  CC09 C2 20 CC         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  CC0C 13               inc de              ; move to frame
 63+  CC0D 3A F1 CB         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  CC10 12               ld (de),a
 65+  CC11 1B               dec de              ; move de back to state
 66+  CC12 3E 02            ld a,2
 67+  CC14 12               ld (de),a           ; set the state to wobbling
 68+  CC15 1B               dec de              ; move back coords
 69+  CC16 C1               pop bc              ; get back coords
 70+  CC17 78               ld a,b
 71+  CC18 12               ld (de),a           ; store the vertical
 72+  CC19 1B               dec de
 73+  CC1A 79               ld a,c
 74+  CC1B 12               ld (de),a           ; store the horizontal
 75+  CC1C C5               push bc
 76+  CC1D C3 24 CC         jp rocks_addrocktofalling2 ; done
 77+  CC20              rocks_addrocktofalling1:
 78+  CC20 13               inc de
 79+  CC21 13               inc de              ; move memory along to next rock
 80+  CC22 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  CC24              rocks_addrocktofalling2: ; done, return
 82+  CC24 C1               pop bc              ; to tidy up
 83+  CC25 C9               ret
 84+  CC26
 85+  CC26              ;
 86+  CC26              ; Processes any falling rocks
 87+  CC26              ;
 88+  CC26              rocks_processrocks:
 89+  CC26 DD 21 DE CB      ld ix,rocks_falling
 90+  CC2A 06 04            ld b,4              ; the number of rocks to check
 91+  CC2C              rocks_processrocks0:
 92+  CC2C C5               push bc             ; store loop count
 93+  CC2D DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  CC31 46 01
 94+  CC33 DD 23            inc ix
 95+  CC35 DD 23            inc ix              ; move to the state
 96+  CC37 DD 7E 00         ld a,(ix)           ; load the state into a
 97+  CC3A FE 00            cp 0
 98+  CC3C CA 5D CC         jp z,rocks_processrocks3 ; if not falling, check next
 99+  CC3F FE 02            cp 2
100+  CC41 C2 51 CC         jp nz, rocks_processrocks2
101+  CC44                  ; we're wobbling
102+  CC44 DD 23            inc ix              ; get frame number for wobble
103+  CC46 DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  CC49 CD 20 CD         call rocks_wobble
105+  CC4C DD 23            inc ix              ; increment for next
106+  CC4E C3 61 CC         jp rocks_processrocks1  ; do next rock
107+  CC51              rocks_processrocks2:
108+  CC51                  ; we're falling
109+  CC51 C5               push bc
110+  CC52 CD 65 CC         call rocks_fall
111+  CC55 C1               pop bc
112+  CC56 DD 23            inc ix
113+  CC58 DD 23            inc ix              ; inc ix to get to next
114+  CC5A C3 61 CC         jp rocks_processrocks1
115+  CC5D              rocks_processrocks3:
116+  CC5D DD 23            inc ix
117+  CC5F DD 23            inc ix
118+  CC61              rocks_processrocks1:
119+  CC61 C1               pop bc              ; get loop count back
120+  CC62 10 C8            djnz rocks_processrocks0
121+  CC64 C9               ret
122+  CC65
123+  CC65              ;
124+  CC65              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  CC65              ; bc - coord of current rock graphic on screen
126+  CC65              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  CC65              ;
128+  CC65              rocks_fall:
129+  CC65 DD 2B            dec ix
130+  CC67 DD 2B            dec ix              ; decrease ix back to coords
131+  CC69 ED 43 EF CB      ld (rocks_tmp2),bc  ; store original coords
132+  CC6D 3E 03            ld a,3              ; move this number of pixels
133+  CC6F              rocks_fall1:
134+  CC6F 32 EE CB         ld (rocks_tmp),a    ; store loop counter
135+  CC72 DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  CC76 46 01
136+  CC78 CD 31 AC         call sprites_scadd  ; get the memory of the coords into de
137+  CC7B 14               inc d               ; add 256 to get next row
138+  CC7C 1A               ld a,(de)           ; get the contents of the next row
139+  CC7D FE 00            cp 0
140+  CC7F C2 DF CC         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  CC82 0C               inc c               ; increment the vertical
142+  CC83 DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  CC87 70 01
143+  CC89 79               ld a,c              ; get the vertical coord into a
144+  CC8A E6 07            and 7               ; divisible by 8?
145+  CC8C FE 00            cp 0
146+  CC8E C2 AB CC         jp nz,rocks_fall4   ; if not, carry on
147+  CC91 CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  CC94 3E 42            ld a,66             ; load red
149+  CC96 CD AF AA         call screen_setattr
150+  CC99 DD 4E 00 DD      ld bc,(ix)
150+  CC9D 46 01
151+  CC9F 79               ld a,c              ; get vertical
152+  CCA0 D6 08            sub 8               ; look up one square
153+  CCA2 4F               ld c,a              ; put a back in c
154+  CCA3 CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  CCA6 3E 46            ld a,70             ; load yellow
156+  CCA8 CD AF AA         call screen_setattr
157+  CCAB              rocks_fall4:
158+  CCAB 3A EE CB         ld a,(rocks_tmp)    ; get the loop counter
159+  CCAE 3D               dec a
160+  CCAF FE 00            cp 0
161+  CCB1 C2 6F CC         jp nz,rocks_fall1   ; do another pixel if needed
162+  CCB4              rocks_fall2:
163+  CCB4 3E 09            ld a,9              ; rock graphic
164+  CCB6 ED 4B EF CB      ld bc,(rocks_tmp2)  ; get the original coords
165+  CCBA CD A4 AA         call screen_getblock     ; get the memory into hl
166+  CCBD CD 29 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  CCC0 3E 09            ld a,9
168+  CCC2 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  CCC6 46 01
169+  CCC8 CD A4 AA         call screen_getblock     ; get the memory into hl
170+  CCCB CD 29 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  CCCE DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  CCD2 46 01
172+  CCD4 CD 05 CD         call rocks_checkforplayer ; check to see if we hit a player
173+  CCD7 DD 23            inc ix
174+  CCD9 DD 23            inc ix                  ; get ix back to state
175+  CCDB CD F5 CC         call rocks_makesound
176+  CCDE C9               ret
177+  CCDF              rocks_fall3:
178+  CCDF 3E 00            ld a,0              ; set the state to fell
179+  CCE1 DD 77 02         ld (ix+2),a           ; store the falling state
180+  CCE4 DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  CCE8 46 01
181+  CCEA CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  CCED 3E 42            ld a,66             ; load magenta
183+  CCEF CD AF AA         call screen_setattr
184+  CCF2 C3 B4 CC         jp rocks_fall2      ; rejoin main loop
185+  CCF5
186+  CCF5              ;
187+  CCF5              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  CCF5              ;
189+  CCF5              rocks_makesound:
190+  CCF5 DD 7E 00         ld a,(ix)           ; get the state
191+  CCF8 FE 00            cp 0
192+  CCFA C0               ret nz              ; if we haven't fallen, don't do anything
193+  CCFB 21 23 C6         ld hl,player+11
194+  CCFE 7E               ld a,(hl)
195+  CCFF FE 01            cp 1
196+  CD01 C4 47 B2         call nz, sound_rockfell ; only make sound if didn't kill player
197+  CD04 C9               ret
198+  CD05
199+  CD05              ;
200+  CD05              ; Checks to see if the rock is hitting a player
201+  CD05              ; Inputs:
202+  CD05              ; bc - coords of rock we're checking
203+  CD05              rocks_checkforplayer:
204+  CD05 ED 5B 18 C6      ld de,(player)       ; get the player coords
205+  CD09 7B               ld a,e               ; get the vert coord first
206+  CD0A 91               sub c                ; subtract the rock vertical coord from players
207+  CD0B FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  CD0D C0               ret nz               ; if not, hasn't hit
209+  CD0E 7A               ld a,d               ; get the player horiz coord
210+  CD0F 90               sub b                ; subtract rock coord
211+  CD10 C6 07            add 7                ; add max distance
212+  CD12 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  CD14 DA 18 CD         jp c,rocks_checkforplayer0
214+  CD17 C9               ret
215+  CD18              rocks_checkforplayer0:
216+  CD18 ED 43 F2 CB      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  CD1C CD 3B C7         call player_crushplayer ; if so, jump out
218+  CD1F C9               ret
219+  CD20
220+  CD20              ;
221+  CD20              ; Wobbles a rocks
222+  CD20              ; Inputs:
223+  CD20              ; bc - coord of current rock graphic on screen
224+  CD20              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  CD20              ; a - wobble frame
226+  CD20              rocks_wobble:
227+  CD20 DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  CD23 E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  CD25 1E 09            ld e,9              ; this is the rock frame
230+  CD27 83               add a,e             ; add the frame toggle
231+  CD28 C5               push bc
232+  CD29 CD A4 AA         call screen_getblock     ; get the memory into hl
233+  CD2C CD 29 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  CD2F DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  CD32 3D               dec a               ; decrease
236+  CD33 DD 77 00         ld (ix),a           ; store
237+  CD36 E6 01            and 1
238+  CD38 1E 09            ld e,9              ; this is the rock frame
239+  CD3A 83               add a,e             ; add the frame toggle
240+  CD3B CD A4 AA         call screen_getblock     ; get the memory into hl
241+  CD3E C1               pop bc
242+  CD3F CD 29 AB         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  CD42 DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  CD45 FE 00            cp 0
245+  CD47 C0               ret nz              ; if we're not at zero, return
246+  CD48 DD 2B            dec ix              ; otherwise look to state location
247+  CD4A 3E 01            ld a,1              ; set the state to falling
248+  CD4C DD 77 00         ld (ix),a           ; store the falling state
249+  CD4F DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  CD51 C9               ret
251+  CD52
# file closed: game/rocks.asm
162   CD52                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  CD52              ;
  2+  CD52              ; The score of the current player
  3+  CD52              ;
  4+  CD52              scores_current:
  5+  CD52 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  CD56 30 30 30 30
  5+  CD5A FF
  6+  CD5B
  7+  CD5B              scores_defaultname:
  8+  CD5B 2D 2D 2D         defb '---'
  9+  CD5E
 10+  CD5E              ;
 11+  CD5E              ; The current high score table
 12+  CD5E              ;
 13+  CD5E              scores_table:
 14+  CD5E 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  CD62 4D 30 30 30
 14+  CD66 30 30 30 FF
 15+  CD6A 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  CD6E 4D 30 30 30
 15+  CD72 30 30 30 FF
 16+  CD76 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  CD7A 4D 30 30 30
 16+  CD7E 30 30 30 FF
 17+  CD82
 18+  CD82              ;
 19+  CD82              ; Add thousands to the score
 20+  CD82              ; Inputs:
 21+  CD82              ; b - number to add
 22+  CD82              ;
 23+  CD82              scores_addthousands:
 24+  CD82 21 56 CD         ld hl,scores_current+4
 25+  CD85 CD E6 CD         call scores_update
 26+  CD88 C9               ret
 27+  CD89
 28+  CD89              ;
 29+  CD89              ; Add hundreds to the score
 30+  CD89              ; Inputs:
 31+  CD89              ; b - number to add
 32+  CD89              ;
 33+  CD89              scores_addhundreds:
 34+  CD89 21 57 CD         ld hl,scores_current+5
 35+  CD8C CD E6 CD         call scores_update
 36+  CD8F C9               ret
 37+  CD90
 38+  CD90              ;
 39+  CD90              ; Temporary area for printing scores
 40+  CD90              ;
 41+  CD90              scores_printscore_tmp:
 42+  CD90 00 00 00 00      defb 0,0,0,0,0,0,0,0,255
 42+  CD94 00 00 00 00
 42+  CD98 FF
 43+  CD99
 44+  CD99              ;
 45+  CD99              ; Prints the score to screen
 46+  CD99              ;
 47+  CD99              scores_printscore:
 48+  CD99 3A 29 C5         ld a,(game_currentplayer)   ; get current player
 49+  CD9C 21 52 CD         ld hl,scores_current
 50+  CD9F FE 01            cp 1
 51+  CDA1 C2 A9 CD         jp nz, score_printscore0    ; if not player 1
 52+  CDA4 36 04            ld (hl),4       ; set position for player 1
 53+  CDA6 C3 AB CD         jp score_printscore1
 54+  CDA9              score_printscore0:
 55+  CDA9 36 16            ld (hl),22       ; set position for player 2
 56+  CDAB              score_printscore1:
 57+  CDAB CD AF CD         call score_printscoreformatted
 58+  CDAE C9               ret
 59+  CDAF
 60+  CDAF              ;
 61+  CDAF              ; Formats a score and prints to the top screen
 62+  CDAF              ; Inputs:
 63+  CDAF              ; hl - where is the score
 64+  CDAF              score_printscoreformatted:
 65+  CDAF 01 08 00         ld bc,8
 66+  CDB2 11 90 CD         ld de,scores_printscore_tmp
 67+  CDB5 ED B0            ldir                        ; copy to temp
 68+  CDB7 21 90 CD         ld hl,scores_printscore_tmp
 69+  CDBA E5 DD E1         ld ix,hl
 70+  CDBD DD 7E 02         ld a,(ix+2)
 71+  CDC0 FE 30            cp 48                   ; is it a leading zero?
 72+  CDC2 C2 D5 CD         jp nz,score_printscore2
 73+  CDC5 DD 36 02 20      ld (ix+2),32              ; load it with a space
 74+  CDC9 DD 7E 03         ld a,(ix+3)
 75+  CDCC FE 30            cp 48                   ; is it a leading zero?
 76+  CDCE C2 D5 CD         jp nz,score_printscore2
 77+  CDD1 DD 36 03 20      ld (ix+3),32              ; load it with a space
 78+  CDD5              score_printscore2:
 79+  CDD5 CD 44 86         call string_print
 80+  CDD8 C9               ret
 81+  CDD9
 82+  CDD9              ;
 83+  CDD9              ; Prints both scores to screen
 84+  CDD9              ;
 85+  CDD9              scores_printscores:
 86+  CDD9 21 21 C7         ld hl,player1_score
 87+  CDDC CD AF CD         call score_printscoreformatted
 88+  CDDF 21 2A C7         ld hl,player2_score
 89+  CDE2 CD AF CD         call score_printscoreformatted
 90+  CDE5 C9               ret
 91+  CDE6
 92+  CDE6              ;
 93+  CDE6              ; Updates the current score.
 94+  CDE6              ; Inputs:
 95+  CDE6              ; hl - memory location of the score column
 96+  CDE6              ; b - number to add
 97+  CDE6              ;
 98+  CDE6              scores_update:
 99+  CDE6 7E               ld a,(hl)           ; current value of digit.
100+  CDE7 80               add a,b             ; add points to this digit.
101+  CDE8 77               ld (hl),a           ; place new digit back in string.
102+  CDE9 FE 3A            cp 58               ; more than ASCII value '9'?
103+  CDEB D8               ret c               ; no - relax.
104+  CDEC D6 0A            sub 10              ; subtract 10.
105+  CDEE 77               ld (hl),a           ; put new character back in string.
106+  CDEF              scores_update0:
107+  CDEF 2B               dec hl              ; previous character in string.
108+  CDF0 34               inc (hl)            ; up this by one.
109+  CDF1 7E               ld a,(hl)           ; what's the new value?
110+  CDF2 FE 3A            cp 58               ; gone past ASCII nine?
111+  CDF4 D8               ret c               ; no, scoring done.
112+  CDF5 D6 0A            sub 10              ; down by ten.
113+  CDF7 77               ld (hl),a           ; put it back
114+  CDF8 C3 EF CD         jp scores_update0   ; go round again.
115+  CDFB
116+  CDFB
117+  CDFB              ;
118+  CDFB              ; Temporary area to store score
119+  CDFB              ;
120+  CDFB              scores_showtable_tmp:
121+  CDFB 00 00 00 00      defb 0,0,0,0,0,0,0,0,0,0,0,255
121+  CDFF 00 00 00 00
121+  CE03 00 00 00 FF
122+  CE07
123+  CE07              ;
124+  CE07              ; Processes a score
125+  CE07              ; Inputs:
126+  CE07              ; hl - location on table
127+  CE07              ;
128+  CE07              scores_showtable_process:
129+  CE07 01 0B 00         ld bc,11                     ; copy this many
130+  CE0A 11 FB CD         ld de,scores_showtable_tmp
131+  CE0D ED B0            ldir
132+  CE0F DD 21 FB CD      ld ix,scores_showtable_tmp   ; decide whether to show five or six numbers
133+  CE13 DD 7E 05         ld a,(ix+5)
134+  CE16 FE 30            cp 48                        ; is this a zero?
135+  CE18 C2 2E CE         jp nz,scores_showtable_process0 ; if not, show the whole thing
136+  CE1B 01 05 00         ld bc,5                      ; copy this many
137+  CE1E DD E5 E1         ld hl,ix
138+  CE21 11 06 00         ld de,6
139+  CE24 19               add hl,de                    ; move to second digit
140+  CE25 54 5D            ld de,hl
141+  CE27 1B               dec de
142+  CE28 ED B0            ldir
143+  CE2A DD 36 0A 20      ld (ix+10),32                ; stick a space at the end
144+  CE2E              scores_showtable_process0:
145+  CE2E 21 FB CD         ld hl,scores_showtable_tmp
146+  CE31 CD 44 86         call string_print
147+  CE34 C9               ret
148+  CE35
149+  CE35              ;
150+  CE35              ; Displays the high score table at the bottom of the screen
151+  CE35              ;
152+  CE35              scores_showtable:
153+  CE35 21 5E CD         ld hl, scores_table
154+  CE38 CD 07 CE         call scores_showtable_process
155+  CE3B 21 6A CD         ld hl, scores_table+12
156+  CE3E CD 07 CE         call scores_showtable_process
157+  CE41 21 76 CD         ld hl, scores_table+24
158+  CE44 CD 07 CE         call scores_showtable_process
159+  CE47 C9               ret
160+  CE48
161+  CE48              ;
162+  CE48              ; Place to store the current position we're checking
163+  CE48              ;
164+  CE48              scores_highscoretmp:
165+  CE48 00               defb 0
166+  CE49
167+  CE49              ;
168+  CE49              ; Place to store the equal indicator
169+  CE49              ;
170+  CE49              scores_highscoretmp2:
171+  CE49 00               defb 0
172+  CE4A
173+  CE4A              ;
174+  CE4A              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
175+  CE4A              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
176+  CE4A              ;
177+  CE4A              scores_processhighscores:
178+  CE4A 21 48 CE         ld hl,scores_highscoretmp
179+  CE4D 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
180+  CE4F 3E 1D            ld a,29
181+  CE51              scores_processhighscores3:
182+  CE51 21 5E CD         ld hl,scores_table          ; position of first score column
183+  CE54 5F               ld e,a
184+  CE55 16 00            ld d,0
185+  CE57 19               add hl,de
186+  CE58 08               ex af,af'                   ; store a for later
187+  CE59 11 54 CD         ld de,scores_current+2      ; position of current score column
188+  CE5C 3E 01            ld a,1
189+  CE5E 32 49 CE         ld (scores_highscoretmp2),a ; set the equal indicator to 1 - this will be set to zero if a different number is found
190+  CE61 06 06            ld b,6                      ; times to loop
191+  CE63              scores_processhighscores0:
192+  CE63 7E               ld a,(hl)
193+  CE64 4F               ld c,a                      ; get first score column
194+  CE65 1A               ld a,(de)                   ; get first current column
195+  CE66 B9               cp c                        ; compare current with first
196+  CE67 DA 8C CE         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
197+  CE6A CA 75 CE         jp z,scores_processhighscores5  ; if c is equal, then don't clear the equality flag
198+  CE6D 3E 00            ld a,0                      ; this must be bigger, so no need to check further
199+  CE6F 32 49 CE         ld (scores_highscoretmp2),a ; zero the equality indicator
200+  CE72 C3 79 CE         jp scores_processhighscores6
201+  CE75              scores_processhighscores5:
202+  CE75 23               inc hl
203+  CE76 13               inc de                      ; move to next column
204+  CE77 10 EA            djnz scores_processhighscores0 ; loop
205+  CE79              scores_processhighscores6:
206+  CE79 3A 49 CE         ld a,(scores_highscoretmp2)   ; get the equality indicator
207+  CE7C FE 01            cp 1
208+  CE7E CA 8C CE         jp z,scores_processhighscores4 ; if it is equal, not a highscore
209+  CE81 B7               or a                            ; clear the carry flag
210+  CE82 08               ex af,af'                     ; still here, so must be bigger
211+  CE83 32 48 CE         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
212+  CE86 0E 0C            ld c,12
213+  CE88 91               sub c
214+  CE89 D2 51 CE         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
215+  CE8C              scores_processhighscores4
216+  CE8C CD 90 CE         call scores_updatehighscores
217+  CE8F C9               ret
218+  CE90
219+  CE90              ;
220+  CE90              ; Update score table
221+  CE90              ;
222+  CE90              scores_updatehighscores:
223+  CE90 3A 48 CE         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
224+  CE93 FE 00            cp 0
225+  CE95 C8               ret z                       ; if this is 0, didn't get a high score
226+  CE96 FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
227+  CE98 CA CB CE         jp z, scores_updatehighscores3
228+  CE9B                                              ; copy old score over one below, if not first
229+  CE9B 21 5E CD         ld hl,scores_table
230+  CE9E 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
231+  CEA1 19               add hl,de                   ; position of first column
232+  CEA2 2B               dec hl
233+  CEA3 2B               dec hl
234+  CEA4 2B               dec hl
235+  CEA5 E5               push hl
236+  CEA6 11 0C 00         ld de,12
237+  CEA9 19               add hl,de                   ; get position of next score
238+  CEAA 54 5D            ld de,hl
239+  CEAC E1               pop hl                      ; get hl back
240+  CEAD 01 09 00         ld bc,9
241+  CEB0 ED B0            ldir
242+  CEB2 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
243+  CEB4 CA CB CE         jp z,scores_updatehighscores3
244+  CEB7 21 5E CD         ld hl,scores_table
245+  CEBA 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
246+  CEBD 19               add hl,de                   ; position of first column
247+  CEBE E5               push hl
248+  CEBF 11 0C 00         ld de,12
249+  CEC2 19               add hl,de                   ; get position of next score
250+  CEC3 54 5D            ld de,hl
251+  CEC5 E1               pop hl                      ; get hl back
252+  CEC6 01 09 00         ld bc,9
253+  CEC9 ED B0            ldir
254+  CECB              scores_updatehighscores3:
255+  CECB 06 06            ld b,6                      ; now overwrite
256+  CECD 21 5E CD         ld hl,scores_table
257+  CED0 16 00            ld d,0
258+  CED2 5F               ld e,a
259+  CED3 19               add hl,de                   ; position of first column
260+  CED4 08               ex af,af'
261+  CED5 11 54 CD         ld de,scores_current+2      ; position of current score column
262+  CED8              scores_updatehighscores2:
263+  CED8 1A               ld a,(de)
264+  CED9 77               ld (hl),a
265+  CEDA 23               inc hl
266+  CEDB 13               inc de
267+  CEDC 10 FA            djnz scores_updatehighscores2
268+  CEDE 11 09 00         ld de,9
269+  CEE1 ED 52            sbc hl,de
270+  CEE3 54 5D            ld de,hl                    ; get back to start of entry
271+  CEE5 21 5B CD         ld hl,scores_defaultname    ; still need to overwrite the name
272+  CEE8 01 03 00         ld bc,3                      ; 3 chars to copy
273+  CEEB ED B0            ldir
274+  CEED C9               ret
# file closed: game/scores.asm
163   CEEE                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  CEEE              diamonds_tmp:
  2+  CEEE 00               defb 0
  3+  CEEF
  4+  CEEF              diamonds_tmp2:
  5+  CEEF 00               defb 0
  6+  CEF0
  7+  CEF0              ;
  8+  CEF0              ; Holds the number of thousands for the current gem type
  9+  CEF0              ;
 10+  CEF0              diamonds_score:
 11+  CEF0 00               defb 0
 12+  CEF1
 13+  CEF1              ;
 14+  CEF1              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  CEF1              ; Inputs:
 16+  CEF1              ; hl - memory location of gem type
 17+  CEF1              diamonds_twinkle_type:
 18+  CEF1 CD C2 C5         call game_getcurrentframe       ; get current frame number
 19+  CEF4 E6 07            and 7                           ; want a number from 0-7
 20+  CEF6 C6 40            add 64                          ; add to 60 to get attr colour
 21+  CEF8 32 EF CE         ld (diamonds_tmp2),a             ; store the colour
 22+  CEFB              diamonds_twinkle_type0:
 23+  CEFB 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  CEFF 79               ld a,c                          ; load c into a
 25+  CF00 FE FF            cp 255                          ; is this the end?
 26+  CF02 CA 2A CF         jp z,diamonds_twinkle_type1           ; step out if so
 27+  CF05 23               inc hl
 28+  CF06 23               inc hl
 29+  CF07 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  CF08 FE 01            cp 1
 31+  CF0A CA 2B CF         jp z,diamonds_twinkle_type2           ; step out if so
 32+  CF0D CD 6B CF         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  CF10 DC 32 CF         call c,diamonds_collect     ; we collided
 34+  CF13 23               inc hl
 35+  CF14 E5               push hl
 36+  CF15 E5 DD E1         ld ix,hl
 37+  CF18 DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  CF1C 46 FE
 38+  CF1E 3A EF CE         ld a,(diamonds_tmp2)
 39+  CF21 CD AF AA         call screen_setattr
 40+  CF24 E1               pop hl
 41+  CF25 23               inc hl
 42+  CF26 23               inc hl                          ; move to next diamond
 43+  CF27 C3 FB CE         jp diamonds_twinkle_type0
 44+  CF2A              diamonds_twinkle_type1:
 45+  CF2A C9               ret
 46+  CF2B              diamonds_twinkle_type2:
 47+  CF2B 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  CF2C 23               inc hl
 49+  CF2D 23               inc hl
 50+  CF2E 08               ex af,af'
 51+  CF2F C3 FB CE         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  CF32
 53+  CF32              ;
 54+  CF32              ; Collect the diamond we collided with
 55+  CF32              ; Inputs:
 56+  CF32              ; hl - memory location of current diamond, currently on state
 57+  CF32              ; Output:
 58+  CF32              ; a - 70 - for yellow on black
 59+  CF32              diamonds_collect:
 60+  CF32 36 01            ld (hl),1                       ; collected
 61+  CF34 E5               push hl
 62+  CF35 2B               dec hl
 63+  CF36 2B               dec hl
 64+  CF37 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  CF3B CD 67 AA         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  CF3E ED 5B EE CE      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  CF42 16 00            ld d,0
 68+  CF44 21 68 BD         ld hl,sprites
 69+  CF47 19               add hl,de
 70+  CF48 CD 29 AB         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  CF4B E1               pop hl
 72+  CF4C 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  CF4E 32 EF CE         ld (diamonds_tmp2),a
 74+  CF51 D9               exx
 75+  CF52 3A F0 CE         ld a,(diamonds_score)
 76+  CF55 47               ld b,a
 77+  CF56 CD 82 CD         call scores_addthousands
 78+  CF59 3A EE CE         ld a,(diamonds_tmp)
 79+  CF5C FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  CF5E C2 66 CF         jp nz,diamonds_collect0
 81+  CF61 21 25 C6         ld hl,player+13
 82+  CF64 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  CF66              diamonds_collect0:
 84+  CF66 CD 0C B2         call sound_gemcollected
 85+  CF69 D9               exx
 86+  CF6A C9               ret
 87+  CF6B
 88+  CF6B              ;
 89+  CF6B              ; Checks to see if the gem is hitting a player
 90+  CF6B              ; Inputs:
 91+  CF6B              ; bc - coords of diamond we're checking
 92+  CF6B              diamonds_checkforplayer:
 93+  CF6B 78               ld a,b               ; multiply b by 8
 94+  CF6C 07               rlca
 95+  CF6D 07               rlca
 96+  CF6E 07               rlca
 97+  CF6F 47               ld b,a
 98+  CF70 ED 5B 18 C6      ld de,(player)       ; get the player coords
 99+  CF74 7B               ld a,e               ; get the vert coord first
100+  CF75 90               sub b                ; subtract the diamond vertical coord from players
101+  CF76 C6 04            add 4                ; add the max distance
102+  CF78 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  CF7A D0               ret nc               ; if not, hasn't hit
104+  CF7B 79               ld a,c               ; multiply c by 8
105+  CF7C 07               rlca
106+  CF7D 07               rlca
107+  CF7E 07               rlca
108+  CF7F 4F               ld c,a
109+  CF80 7A               ld a,d               ; get the player horiz coord
110+  CF81 91               sub c                ; subtract rock coord
111+  CF82 C6 04            add 4                ; add max distance
112+  CF84 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  CF86 D0               ret nc
114+  CF87 3E 00            ld a,0
115+  CF89 C9               ret
116+  CF8A
117+  CF8A
118+  CF8A              ;
119+  CF8A              ; Initialise diamonds and gems
120+  CF8A              ;
121+  CF8A              diamonds_twinkle
122+  CF8A 21 F0 CE         ld hl,diamonds_score
123+  CF8D 36 02            ld (hl),2         ; store the score we'll add
124+  CF8F 21 EE CE         ld hl,diamonds_tmp
125+  CF92 36 40            ld (hl),64         ; store the location the diamond sprite
126+  CF94 21 E3 B8         ld hl, level_diamonds
127+  CF97 CD F1 CE         call diamonds_twinkle_type
128+  CF9A 21 F0 CE         ld hl,diamonds_score
129+  CF9D 36 01            ld (hl),1         ; store the score we'll add
130+  CF9F 21 EE CE         ld hl,diamonds_tmp
131+  CFA2 36 70            ld (hl),112         ; store the location the gem sprite
132+  CFA4 21 F3 B8         ld hl, level_gems
133+  CFA7 CD F1 CE         call diamonds_twinkle_type
134+  CFAA C9               ret
135+  CFAB
136+  CFAB              ;
137+  CFAB              ; Initialise diamonds and gems
138+  CFAB              ;
139+  CFAB              diamonds_init:
140+  CFAB 21 E3 B8         ld hl, level_diamonds
141+  CFAE CD B8 CF         call diamonds_init_type
142+  CFB1 21 F3 B8         ld hl, level_gems
143+  CFB4 CD B8 CF         call diamonds_init_type
144+  CFB7 C9               ret
145+  CFB8
146+  CFB8              ;
147+  CFB8              ; Initialise diamonds or gems, get memory addresses
148+  CFB8              ; Inputs:
149+  CFB8              ; hl - memory location
150+  CFB8              diamonds_init_type:
151+  CFB8 4E               ld c,(hl)                      ; get coords into c
152+  CFB9 79               ld a,c                          ; load c into add
153+  CFBA FE FF            cp 255                          ; is this the end?
154+  CFBC CA D3 CF         jp z,diamonds_init_type1             ; step out if so
155+  CFBF 23               inc hl
156+  CFC0 46               ld b,(hl)                       ; get coords into b
157+  CFC1 E5               push hl
158+  CFC2 CD 18 AA         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  CFC5 E1               pop hl
160+  CFC6 23               inc hl                          ; move to state
161+  CFC7 36 00            ld (hl),0
162+  CFC9 23               inc hl                          ; move to memory
163+  CFCA 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  CFCE 23               inc hl                          ; move to next diamond
165+  CFCF 23               inc hl
166+  CFD0 C3 B8 CF         jp diamonds_init_type
167+  CFD3              diamonds_init_type1:
168+  CFD3 C9               ret
# file closed: game/diamonds.asm
164   CFD4                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  CFD4              ;
  2+  CFD4              ; Controls when missiles fall
  3+  CFD4              ;
  4+  CFD4              missiles_count:
  5+  CFD4 00               defb 0
  6+  CFD5
  7+  CFD5              ;
  8+  CFD5              ; A structure of falling missiles
  9+  CFD5              ; Assume we'll never have more than 4 falling at any one time
 10+  CFD5              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  CFD5              ;
 12+  CFD5              missiles_falling:
 13+  CFD5 00 00 00         defb 0,0,0
 14+  CFD8 00 00 00         defb 0,0,0
 15+  CFDB 00 00 00         defb 0,0,0
 16+  CFDE 00 00 00         defb 0,0,0
 17+  CFE1
 18+  CFE1              ;
 19+  CFE1              ; The coords of the missile that killed us
 20+  CFE1              ;
 21+  CFE1              missiles_killermissile:
 22+  CFE1 00 00            defb 0,0
 23+  CFE3
 24+  CFE3              ;
 25+  CFE3              ; The speed of the missiles
 26+  CFE3              ;
 27+  CFE3              missiles_speed:
 28+  CFE3 00               defb 0
 29+  CFE4
 30+  CFE4              ;
 31+  CFE4              ; Zeroes the state of each missile
 32+  CFE4              ;
 33+  CFE4              missiles_init:
 34+  CFE4 06 0C            ld b,12
 35+  CFE6 DD 21 6A B8      ld ix,level_missiles
 36+  CFEA              missiles_init0:
 37+  CFEA DD 36 02 00      ld (ix+2),0               ; set the state to zero
 38+  CFEE 11 05 00         ld de,5
 39+  CFF1 DD 19            add ix,de
 40+  CFF3 DD 36 02 00      ld (ix+2),0
 41+  CFF7 DD 19            add ix,de
 42+  CFF9 10 EF            djnz missiles_init0
 43+  CFFB 06 04            ld b,4                  ; reset four falling missiles
 44+  CFFD 21 D5 CF         ld hl,missiles_falling
 45+  D000              missiles_init1:
 46+  D000 36 00            ld (hl),0
 47+  D002 23               inc hl
 48+  D003 36 00            ld (hl),0
 49+  D005 23               inc hl
 50+  D006 36 00            ld (hl),0
 51+  D008 23               inc hl
 52+  D009 10 F5            djnz missiles_init1
 53+  D00B C9               ret
 54+  D00C
 55+  D00C              ;
 56+  D00C              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 57+  D00C              ; Processes any already falling missiles
 58+  D00C              ;
 59+  D00C              missiles_process:
 60+  D00C 3A 23 C6         ld a,(player+11)                        ; check if the player was hit by a missile previously
 61+  D00F FE 03            cp 3
 62+  D011 C2 18 D0         jp nz,missiles_process3                 ; if not, continue
 63+  D014 CD 58 D1         call missiles_zonkplayer
 64+  D017 C9               ret
 65+  D018              missiles_process3:
 66+  D018 3A 27 C6         ld a,(player_location)
 67+  D01B FE 01            cp 1
 68+  D01D C2 8E D0         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 69+  D020 21 25 C6         ld hl,player+13
 70+  D023 7E               ld a,(hl)                               ; check if player has collected a diamond
 71+  D024 FE 01            cp 1
 72+  D026 C2 8E D0         jp nz, missiles_process0                ; don't activate if not
 73+  D029 21 D4 CF         ld hl,missiles_count
 74+  D02C 7E               ld a,(hl)                   ; get the missiles count
 75+  D02D 3C               inc a
 76+  D02E ED 5B E3 CF      ld de,(missiles_speed)
 77+  D032 BB               cp e                                   ; have we reached the count yet
 78+  D033 CA 3A D0         jp z,missiles_process2                 ; if not, don't activate a new one
 79+  D036 77               ld (hl),a                               ; store the updated count, and continue without activating
 80+  D037 C3 8E D0         jp missiles_process0
 81+  D03A              missiles_process2:
 82+  D03A 36 00            ld (hl),0                               ; zero the counter
 83+  D03C 1E 0C            ld e,12
 84+  D03E CD B8 81         call utilities_randomupper              ; get random number from 0 to 11
 85+  D041 11 0A 00         ld de,10
 86+  D044 CD 03 81         call utilities_multiply                 ; multiple random number by 10
 87+  D047 54 5D            ld de,hl                                ; this is the offset for the random missile
 88+  D049 DD 21 6A B8      ld ix,level_missiles                   ; load the location of the missile definitions
 89+  D04D DD 19            add ix,de                               ; get to location of missile
 90+  D04F DD 7E 02         ld a,(ix+2)
 91+  D052 FE 00            cp 0
 92+  D054 CA 64 D0         jp z,missiles_process1                  ; if this missile isn't active, activate it
 93+  D057 11 05 00         ld de,5                                 ; otherwise, check the missile above
 94+  D05A DD 19            add ix,de
 95+  D05C DD 7E 02         ld a,(ix+2)
 96+  D05F FE 00            cp 0
 97+  D061 C2 8E D0         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 98+  D064              missiles_process1:                          ; activate a missile
 99+  D064 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
100+  D068 DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
100+  D06C 46 01
101+  D06E 78               ld a,b
102+  D06F ED 5B F7 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
103+  D073 93               sub e
104+  D074 CD 67 AA         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
105+  D077 C5               push bc
106+  D078 3E 0C            ld a,12                                 ; inactive missile sprite
107+  D07A CD A4 AA         call screen_getblock
108+  D07D CD 29 AB         call sprites_drawsprite                 ; draw the sprite over the old one
109+  D080 C1               pop bc
110+  D081 C5               push bc
111+  D082 3E 14            ld a,20                                 ; active missile sprite
112+  D084 CD A4 AA         call screen_getblock
113+  D087 CD 29 AB         call sprites_drawsprite                 ; draw the sprite over the old one
114+  D08A C1               pop bc
115+  D08B CD 1C D1         call missiles_addmissiletofalling
116+  D08E              missiles_process0:
117+  D08E CD 92 D0         call missiles_fall
118+  D091 C9               ret
119+  D092
120+  D092              ;
121+  D092              ; Processes falling missiles
122+  D092              ;
123+  D092              missiles_fall:
124+  D092 06 04            ld b,4              ; number of possible falling missiles
125+  D094 DD 21 D5 CF      ld ix,missiles_falling
126+  D098              missiles_fall0:
127+  D098 C5               push bc
128+  D099 DD 7E 02         ld a,(ix+2)
129+  D09C FE 00            cp 0
130+  D09E CA FB D0         jp z,missiles_fall1 ; not falling move to next
131+  D0A1 FE 01            cp 1                ; is this ready to fall
132+  D0A3 CA A9 D0         jp z, missiles_fall3
133+  D0A6 C3 15 D1         jp missiles_fall4   ; if not, decrease the countdown
134+  D0A9              missiles_fall3:
135+  D0A9 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
135+  D0AD 46 01
136+  D0AF CD 31 AC         call sprites_scadd  ; get the memory of the coords into de
137+  D0B2 14               inc d               ; add 256 to get next row
138+  D0B3 1A               ld a,(de)           ; get the contents of the next row
139+  D0B4 FE 00            cp 0
140+  D0B6 C2 0E D1         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
141+  D0B9 3E 14            ld a,20                                 ; active missile sprite
142+  D0BB CD A4 AA         call screen_getblock
143+  D0BE CD 29 AB         call sprites_drawsprite                 ; draw the sprite over the old one
144+  D0C1 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
144+  D0C5 46 01
145+  D0C7 0C               inc c               ; move down one pixel
146+  D0C8 DD 71 00 DD      ld (ix),bc          ; store the new coords
146+  D0CC 70 01
147+  D0CE 3E 14            ld a,20                                 ; active missile sprite
148+  D0D0 CD A4 AA         call screen_getblock
149+  D0D3 CD 29 AB         call sprites_drawsprite                 ; draw the sprite
150+  D0D6 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
150+  D0DA 46 01
151+  D0DC 79               ld a,c              ; get the vertical coord into a
152+  D0DD E6 07            and 7               ; divisible by 8?
153+  D0DF FE 00            cp 0
154+  D0E1 C2 FB D0         jp nz,missiles_fall1   ; if not, carry on
155+  D0E4 CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
156+  D0E7 3E 43            ld a,67             ; load magenta
157+  D0E9 CD AF AA         call screen_setattr
158+  D0EC DD 4E 00 DD      ld bc,(ix)
158+  D0F0 46 01
159+  D0F2 CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the attr address into de
160+  D0F5 05               dec b               ; look one square above
161+  D0F6 3E 46            ld a,70             ; load yellow
162+  D0F8 CD AF AA         call screen_setattr
163+  D0FB              missiles_fall1:         ; hl at state
164+  D0FB DD 4E 00 DD      ld bc,(ix)          ; get coords back
164+  D0FF 46 01
165+  D101 CD 3D D1         call missiles_checkforplayer ; check for player
166+  D104 DD 23            inc ix
167+  D106 DD 23            inc ix
168+  D108 DD 23            inc ix              ; get to next missile
169+  D10A C1               pop bc
170+  D10B 10 8B            djnz missiles_fall0
171+  D10D C9               ret
172+  D10E              missiles_fall2:
173+  D10E DD 36 02 00      ld (ix+2),0
174+  D112 C3 FB D0         jp missiles_fall1   ; rejoin the loop
175+  D115              missiles_fall4:
176+  D115 3D               dec a               ; decrease the countdown
177+  D116 DD 77 02         ld (ix+2),a         ; store back
178+  D119 C3 FB D0         jp missiles_fall1   ; do next missile
179+  D11C
180+  D11C              ;
181+  D11C              ; Adds the missile to the structure that tracks falling missile
182+  D11C              ; Inputs:
183+  D11C              ; bc - coords of missile, c vert
184+  D11C              missiles_addmissiletofalling:
185+  D11C C5               push bc             ; store the coords
186+  D11D 11 D5 CF         ld de,missiles_falling
187+  D120 06 04            ld b,4              ; number of possible falling missiles
188+  D122              missiles_addmissiletofalling0:
189+  D122 13               inc de
190+  D123 13               inc de              ; move three along to get the state
191+  D124 1A               ld a,(de)           ; load the state
192+  D125 FE 00            cp 0                ; check if this is not falling
193+  D127 C2 38 D1         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
194+  D12A 3E 19            ld a,25
195+  D12C 12               ld (de),a           ; set the state to pre-falling
196+  D12D 1B               dec de              ; move back coords
197+  D12E C1               pop bc              ; get back coords
198+  D12F 78               ld a,b
199+  D130 12               ld (de),a           ; store the vertical
200+  D131 1B               dec de
201+  D132 79               ld a,c
202+  D133 12               ld (de),a           ; store the horizontal
203+  D134 C5               push bc
204+  D135 C3 3B D1         jp missiles_addmissiletofalling2 ; done
205+  D138              missiles_addmissiletofalling1:
206+  D138 13               inc de              ; move memory along to next rock
207+  D139 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
208+  D13B              missiles_addmissiletofalling2: ; done, return
209+  D13B C1               pop bc              ; to tidy up
210+  D13C C9               ret
211+  D13D
212+  D13D              ;
213+  D13D              ; Checks to see if the missile is hitting a player
214+  D13D              ; Inputs:
215+  D13D              ; bc - coords of missile we're checking
216+  D13D              missiles_checkforplayer:
217+  D13D ED 5B 18 C6      ld de,(player)       ; get the player coords
218+  D141 7B               ld a,e               ; get the vert coord first
219+  D142 91               sub c                ; subtract the missile vertical coord from players
220+  D143 FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
221+  D145 C0               ret nz               ; if not, hasn't hit
222+  D146 7A               ld a,d               ; get the player horiz coord
223+  D147 90               sub b                ; subtract missile coord
224+  D148 C6 07            add 7                ; add max distance
225+  D14A FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
226+  D14C DA 50 D1         jp c,missiles_checkforplayer0
227+  D14F C9               ret
228+  D150              missiles_checkforplayer0:
229+  D150 ED 43 E1 CF      ld (missiles_killermissile),bc; store the coords of the killer missile
230+  D154 CD 47 C7         call player_zonkplayer ; if so, jump out
231+  D157 C9               ret
232+  D158
233+  D158              ;
234+  D158              ; Player has been hit, so draw text over them and mark as dead
235+  D158              ;
236+  D158              missiles_zonkplayer:
237+  D158 CD 35 C7         call player_killplayer      ; mark as dead
238+  D15B ED 4B 18 C6      ld bc,(player)              ; get player coords
239+  D15F CD 57 AA         call screen_getcharcoordsfromscreencoords
240+  D162 0D               dec c
241+  D163 0D               dec c
242+  D164 04               inc b
243+  D165 C5               push bc
244+  D166 3E 42            ld a,66
245+  D168 CD AF AA         call screen_setattr
246+  D16B 0C               inc c
247+  D16C CD AF AA         call screen_setattr
248+  D16F 0C               inc c
249+  D170 CD AF AA         call screen_setattr
250+  D173 0C               inc c
251+  D174 CD AF AA         call screen_setattr
252+  D177 0C               inc c
253+  D178 CD AF AA         call screen_setattr
254+  D17B 0C               inc c
255+  D17C CD AF AA         call screen_setattr
256+  D17F C1               pop bc
257+  D180 ED 5B F7 A8      ld de,(screen_offset)
258+  D184 78               ld a,b
259+  D185 93               sub e
260+  D186 47               ld b,a                      ; subtract the offset
261+  D187 04               inc b
262+  D188 04               inc b                       ; add two for the score rows
263+  D189 ED 43 B7 85      ld (string_zonk),bc         ; set coords of string
264+  D18D 21 B7 85         ld hl,string_zonk
265+  D190 CD 44 86         call string_print
266+  D193 06 14            ld b,20
267+  D195 CD 64 81         call utilities_pauseforframes ; pause
268+  D198 C9               ret
269+  D199
# file closed: game/missiles.asm
165   D199                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  D199              ;
  2+  D199              ; Timer for deciding how fast the trap withdraws
  3+  D199              ;
  4+  D199              thepit_timer:
  5+  D199 00               defb 0
  6+  D19A
  7+  D19A              ;
  8+  D19A              ; Ticks for the trap state. Will count to 3 then reset
  9+  D19A              ;
 10+  D19A              thepit_trapcount:
 11+  D19A 00               defb 0
 12+  D19B
 13+  D19B              ;
 14+  D19B              ; The horizontal coordinate of the current pit trap
 15+  D19B              ;
 16+  D19B              thepit_trapcoord:
 17+  D19B 08               defb 8
 18+  D19C
 19+  D19C              ;
 20+  D19C              ; Initialises the pit
 21+  D19C              ;
 22+  D19C              thepit_init:
 23+  D19C 21 9B D1         ld hl,thepit_trapcoord
 24+  D19F 36 08            ld (hl),8
 25+  D1A1 21 9A D1         ld hl,thepit_trapcount
 26+  D1A4 36 00            ld (hl),0
 27+  D1A6 C9               ret
 28+  D1A7              ;
 29+  D1A7              ; The speed the pit will withdraw
 30+  D1A7              ;
 31+  D1A7              thepit_speed:
 32+  D1A7 00               defb 0
 33+  D1A8
 34+  D1A8              ;
 35+  D1A8              ; Performs per frame processing on the pit room
 36+  D1A8              ;
 37+  D1A8              thepit_process:
 38+  D1A8 3A 27 C6         ld a,(player_location)
 39+  D1AB FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 40+  D1AD C2 17 D2         jp nz,thepit_process0
 41+  D1B0 ED 4B 18 C6      ld bc,(player)                  ; get the player's coords to check if about to fall
 42+  D1B4 3E 08            ld a,8
 43+  D1B6 81               add a,c
 44+  D1B7 4F               ld c,a                          ; look at the square underneath
 45+  D1B8 CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the cell coords
 46+  D1BB CD E5 AA         call screen_ischarempty
 47+  D1BE FE 01            cp 1                            ; check if this is 1=empty
 48+  D1C0 CA 18 D2         jp z,thepit_process2
 49+  D1C3 3A 99 D1         ld a,(thepit_timer)             ; get the timer
 50+  D1C6 3C               inc a
 51+  D1C7 32 99 D1         ld (thepit_timer),a             ; store
 52+  D1CA ED 5B A7 D1      ld de,(thepit_speed)            ; get the speed
 53+  D1CE BB               cp e                           ; have we reached the trigger?
 54+  D1CF C2 17 D2         jp nz, thepit_process0          ; no need to do anything
 55+  D1D2 3E 00            ld a,0
 56+  D1D4 32 99 D1         ld (thepit_timer),a             ; zero the timer and process
 57+  D1D7 3A 9A D1         ld a,(thepit_trapcount)         ; get the current count
 58+  D1DA 3C               inc a
 59+  D1DB 32 9A D1         ld (thepit_trapcount),a         ; reset the trap count
 60+  D1DE FE 04            cp 4                            ; do we need to begin another character?
 61+  D1E0 C2 FF D1         jp nz,thepit_process1           ; if not, draw as normal
 62+  D1E3 3E 00            ld a,0
 63+  D1E5 32 9A D1         ld (thepit_trapcount),a         ; reset the trap count
 64+  D1E8 3A 9B D1         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 65+  D1EB FE 02            cp 2
 66+  D1ED CA 17 D2         jp z,thepit_process0
 67+  D1F0 4F               ld c,a
 68+  D1F1 06 0A            ld b,10
 69+  D1F3 3E 46            ld a,70
 70+  D1F5 CD AF AA         call screen_setattr             ; set the attr of the empty square to yellow on black
 71+  D1F8 3A 9B D1         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 72+  D1FB 3D               dec a
 73+  D1FC 32 9B D1         ld (thepit_trapcoord),a         ; store the reduced coord
 74+  D1FF
 75+  D1FF              thepit_process1:                    ; draw the trapdoor in current position
 76+  D1FF 3A 9B D1         ld a,(thepit_trapcoord)
 77+  D202 FE 02            cp 2
 78+  D204 CA 17 D2         jp z, thepit_process0           ; don't process outside of the pit
 79+  D207 4F               ld c,a
 80+  D208 06 0A            ld b,10                         ; vertical coord will always be the same
 81+  D20A 3A 9A D1         ld a,(thepit_trapcount)         ; get the trap count
 82+  D20D 5F               ld e,a                          ; store in e
 83+  D20E 3E 16            ld a,22                         ; 21 is full trapdoor
 84+  D210 83               add a,e
 85+  D211 CD A4 AA         call screen_getblock
 86+  D214 CD 81 AA         call screen_showchar            ; show the char
 87+  D217
 88+  D217              thepit_process0:
 89+  D217 C9               ret
 90+  D218              thepit_process2:
 91+  D218 CD 4D C7         call player_pitkillplayer
 92+  D21B C9               ret
 93+  D21C
# file closed: game/thepit.asm
166   D21C                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  D21C
  2+  D21C              ;
  3+  D21C              ; Where the monster currently is
  4+  D21C              ;
  5+  D21C              monster_currentcoords:
  6+  D21C 00 00            defb 0,0
  7+  D21E
  8+  D21E              ;
  9+  D21E              ; The start coords of the monster
 10+  D21E              ;
 11+  D21E              monster_initcoords:
 12+  D21E 70 1B            defb 112,27
 13+  D220
 14+  D220              ;
 15+  D220              ; Store the memory location of the current jump position
 16+  D220              ;
 17+  D220              monster_jumppos:
 18+  D220 00 00            defb 0,0
 19+  D222
 20+  D222              ;
 21+  D222              ; The jump table for the monster.
 22+  D222              ;
 23+  D222              monster_jumptable:
 24+  D222 FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,255
 24+  D226 02 02 02 02
 24+  D22A 02 02 01 01
 24+  D22E 01 01 01 FF
 25+  D232
 26+  D232              ;
 27+  D232              ; The vertical direction: 0 up, 1 down
 28+  D232              ;
 29+  D232              monster_jumpdirectionvert:
 30+  D232 00               defb 0
 31+  D233
 32+  D233              ;
 33+  D233              ; The horiz direction: 0 right, 1 left
 34+  D233              ;
 35+  D233              monster_jumpdirectionhoriz:
 36+  D233 00               defb 0
 37+  D234
 38+  D234              ;
 39+  D234              ; Frame offset, 0 or 32
 40+  D234              ;
 41+  D234              monster_frameoffset:
 42+  D234 00               defb 0
 43+  D235
 44+  D235              ;
 45+  D235              ; Monster tick
 46+  D235              ;
 47+  D235              monster_tick:
 48+  D235 00               defb 0
 49+  D236
 50+  D236              ;
 51+  D236              ; The colour of the monster
 52+  D236              ;
 53+  D236              monster_colour:
 54+  D236 06               defb 6
 55+  D237
 56+  D237              ;
 57+  D237              ; Initialises the pit monster
 58+  D237              ;
 59+  D237              monster_init:
 60+  D237 ED 4B 1E D2      ld bc,(monster_initcoords)              ; load the initial coords
 61+  D23B ED 43 1C D2      ld (monster_currentcoords),bc           ; save in current coords
 62+  D23F 21 23 D2         ld hl,monster_jumptable+1
 63+  D242 22 20 D2         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 64+  D245 3E 00            ld a,0
 65+  D247 32 32 D2         ld (monster_jumpdirectionvert),a        ; going up
 66+  D24A 32 34 D2         ld (monster_frameoffset),a
 67+  D24D 32 35 D2         ld (monster_tick),a
 68+  D250 CD DA D2         call monster_draw                       ; the monster
 69+  D253 C9               ret
 70+  D254
 71+  D254              ;
 72+  D254              ; Animate the monster
 73+  D254              ;
 74+  D254              monster_process:
 75+  D254 3A 35 D2         ld a,(monster_tick)                     ; check if we should draw this frame
 76+  D257 FE 01            cp 1
 77+  D259 CA 61 D2         jp z,monster_process6
 78+  D25C 3C               inc a
 79+  D25D 32 35 D2         ld (monster_tick),a                     ; increase the tick and continue
 80+  D260 C9               ret
 81+  D261              monster_process6:
 82+  D261 3E 00            ld a,0
 83+  D263 32 35 D2         ld (monster_tick),a                     ; zero the tick
 84+  D266 CD DA D2         call monster_draw                       ; overwrite the old sprite
 85+  D269 3A 34 D2         ld a,(monster_frameoffset)              ; get the anim frame offset
 86+  D26C EE 20            xor 32                                  ; flip between 0 and 32
 87+  D26E 32 34 D2         ld (monster_frameoffset),a              ; store
 88+  D271 ED 4B 1C D2      ld bc,(monster_currentcoords)           ; get the current coords
 89+  D275 2A 20 D2         ld hl,(monster_jumppos)                 ; get the position in the jump table
 90+  D278 56               ld d,(hl)                               ; get the jump modifier
 91+  D279 3A 32 D2         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 92+  D27C FE 00            cp 0                                    ; if 0, going up, so dec vert
 93+  D27E C2 87 D2         jp nz,monster_process0
 94+  D281 79               ld a,c
 95+  D282 92               sub d
 96+  D283 23               inc hl                                  ; move forward a jump pos
 97+  D284 C3 8A D2         jp monster_process1
 98+  D287              monster_process0:
 99+  D287 79               ld a,c                                   ; going down so inc c
100+  D288 82               add a,d
101+  D289 2B               dec hl                                  ; move back a jump pos
102+  D28A              monster_process1:
103+  D28A 4F               ld c,a                                  ; get the vertical coord back
104+  D28B 7E               ld a,(hl)                               ; check the next jump pos
105+  D28C FE FF            cp 255                                  ; if 255 reverse
106+  D28E CA 97 D2         jp z,monster_process3
107+  D291 22 20 D2         ld (monster_jumppos),hl                 ; store the new pos
108+  D294 C3 A9 D2         jp monster_process2                     ; keep going
109+  D297              monster_process3:
110+  D297 3A 32 D2         ld a,(monster_jumpdirectionvert)        ; get the direction
111+  D29A EE 01            xor 1                                   ; flip it
112+  D29C 32 32 D2         ld (monster_jumpdirectionvert),a        ; store it
113+  D29F FE 01            cp 1
114+  D2A1 CA A9 D2         jp z,monster_process2
115+  D2A4 D9               exx
116+  D2A5 CD ED D2         call monster_colourchange
117+  D2A8 D9               exx
118+  D2A9              monster_process2:
119+  D2A9 3A 33 D2         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
120+  D2AC FE 00            cp 0                                    ; is it right?
121+  D2AE C2 C3 D2         jp nz,monster_process4
122+  D2B1 04               inc b                                   ; 1 pixel right
123+  D2B2 78               ld a,b
124+  D2B3 FE 38            cp 56                                   ; reached the edge of the pit?
125+  D2B5 C2 D2 D2         jp nz,monster_process5
126+  D2B8 3A 33 D2         ld a,(monster_jumpdirectionhoriz)
127+  D2BB EE 01            xor 1
128+  D2BD 32 33 D2         ld (monster_jumpdirectionhoriz),a       ; flip direction
129+  D2C0 C3 D2 D2         jp monster_process5
130+  D2C3              monster_process4:
131+  D2C3 05               dec b                                   ; 1 pixel left
132+  D2C4 78               ld a,b
133+  D2C5 FE 18            cp 24                                   ; reached the edge of the pit?
134+  D2C7 C2 D2 D2         jp nz,monster_process5
135+  D2CA 3A 33 D2         ld a,(monster_jumpdirectionhoriz)
136+  D2CD EE 01            xor 1
137+  D2CF 32 33 D2         ld (monster_jumpdirectionhoriz),a       ; flip direction
138+  D2D2              monster_process5:
139+  D2D2 ED 43 1C D2      ld (monster_currentcoords),bc           ; store the new vertical coords
140+  D2D6 CD DA D2         call monster_draw                       ; finally, draw the monster
141+  D2D9 C9               ret
142+  D2DA
143+  D2DA              ;
144+  D2DA              ; Draw the monster at the current location
145+  D2DA              ;
146+  D2DA              monster_draw:
147+  D2DA ED 4B 1C D2      ld bc,(monster_currentcoords)
148+  D2DE 3A 34 D2         ld a,(monster_frameoffset)
149+  D2E1 11 00 00         ld de,0
150+  D2E4 5F               ld e,a
151+  D2E5 21 7C BF         ld hl,monster_sprite                    ; load the first frame
152+  D2E8 19               add hl,de
153+  D2E9 CD 87 AB         call sprites_draw2by2sprite
154+  D2EC C9               ret
155+  D2ED
156+  D2ED              ;
157+  D2ED              ; Changes the monster colour whenever it reaches the bottom of its jump
158+  D2ED              ;
159+  D2ED              monster_colourchange:
160+  D2ED 3A 36 D2         ld a,(monster_colour)
161+  D2F0 3C               inc a
162+  D2F1 FE 07            cp 7
163+  D2F3 C2 F8 D2         jp nz, monster_colourchange0
164+  D2F6 3E 01            ld a,1
165+  D2F8              monster_colourchange0:
166+  D2F8 32 36 D2         ld (monster_colour),a                   ; save the monster colour
167+  D2FB 3A F7 A8         ld a,(screen_offset)
168+  D2FE FE 00            cp 0
169+  D300 CA 2D D3         jp z,monster_colourchange1
170+  D303 3A 36 D2         ld a,(monster_colour)                   ; get the monster colour
171+  D306 06 06            ld b,6
172+  D308 0E 40            ld c,64
173+  D30A 81               add c                                   ; want this with black background, so add 64
174+  D30B 11 A3 58         ld de,22528+163                         ; attrs here
175+  D30E CD BA A9         call screen_setcolours
176+  D311 3A 36 D2         ld a,(monster_colour)                   ; get the monster colour
177+  D314 06 06            ld b,6
178+  D316 0E 40            ld c,64
179+  D318 81               add c                                   ; want this with black background, so add 64
180+  D319 11 C3 58         ld de,22528+195                         ; attrs here
181+  D31C CD BA A9         call screen_setcolours
182+  D31F 3A 36 D2         ld a,(monster_colour)                   ; get the monster colour
183+  D322 F6 60            or 96
184+  D324 06 06            ld b,6
185+  D326 11 E3 58         ld de,22528+227                         ; attrs here
186+  D329 CD BA A9         call screen_setcolours
187+  D32C C9               ret
188+  D32D              monster_colourchange1:
189+  D32D 3A 36 D2         ld a,(monster_colour)                   ; get the monster colour
190+  D330 06 06            ld b,6
191+  D332 0E 40            ld c,64
192+  D334 81               add c                                   ; want this with black background, so add 64
193+  D335 11 A3 59         ld de,22528+419                         ; attrs here
194+  D338 CD BA A9         call screen_setcolours
195+  D33B 3A 36 D2         ld a,(monster_colour)                   ; get the monster colour
196+  D33E 06 06            ld b,6
197+  D340 0E 40            ld c,64
198+  D342 81               add c                                   ; want this with black background, so add 64
199+  D343 11 C3 59         ld de,22528+451                         ; attrs here
200+  D346 CD BA A9         call screen_setcolours
201+  D349 3A 36 D2         ld a,(monster_colour)                   ; get the monster colour
202+  D34C F6 60            or 96
203+  D34E 06 06            ld b,6
204+  D350 11 E3 59         ld de,22528+483                         ; attrs here
205+  D353 CD BA A9         call screen_setcolours
206+  D356 C9               ret
# file closed: game/monster.asm
167   D357                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  D357
  2+  D357              ;
  3+  D357              ; Array of robot states
  4+  D357              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  D357              robots_robots:
  6+  D357 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  D35B 00 00 00
  7+  D35E 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  D362 00 00 00
  8+  D365 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  D369 00 00 00
  9+  D36C 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  D370 00 00 00
 10+  D373 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  D377 00 00 00
 11+  D37A
 12+  D37A              robots_initcoords:
 13+  D37A 18 E8            defb 24,232
 14+  D37C
 15+  D37C              ;
 16+  D37C              ; When this reaches zero, spawn a new robot
 17+  D37C              ;
 18+  D37C              robots_spawntimer:
 19+  D37C FA               defb 250
 20+  D37D
 21+  D37D              ;
 22+  D37D              ; When this reaches max, change the anim frame
 23+  D37D              ;
 24+  D37D              robots_animtimer:
 25+  D37D 00               defb 0
 26+  D37E
 27+  D37E              ;
 28+  D37E              ; When this reaches max, change move the robot
 29+  D37E              ;
 30+  D37E              robots_movetimer:
 31+  D37E 00               defb 0
 32+  D37F
 33+  D37F
 34+  D37F              ;
 35+  D37F              ; The number of robots active
 36+  D37F              ;
 37+  D37F              robots_numberactive:
 38+  D37F 00               defb 0
 39+  D380
 40+  D380              ;
 41+  D380              ; Tracks which directions a robot can move
 42+  D380              ; up,down,left,right
 43+  D380              robots_canmovedirections:
 44+  D380 00 00 00 00      defb 0,0,0,0
 45+  D384
 46+  D384              ;
 47+  D384              ; The current robot speed
 48+  D384              ;
 49+  D384              robots_robotspeed:
 50+  D384 02               defb 2
 51+  D385
 52+  D385              ;
 53+  D385              ; The current robot spawn speed
 54+  D385              ;
 55+  D385              robots_robotspawnspeed:
 56+  D385 04               defb 4
 57+  D386
 58+  D386              ;
 59+  D386              ; The current max robots
 60+  D386              ;
 61+  D386              robots_robotsmax:
 62+  D386 03               defb 3
 63+  D387
 64+  D387              ;
 65+  D387              ; Initialises the robots
 66+  D387              ;
 67+  D387              robots_init:
 68+  D387 06 23            ld b,35
 69+  D389 DD 21 57 D3      ld ix,robots_robots
 70+  D38D              robots_init0:
 71+  D38D DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 72+  D391 DD 23            inc ix
 73+  D393 10 F8            djnz robots_init0
 74+  D395 3E 00            ld a,0
 75+  D397 32 7F D3         ld (robots_numberactive),a
 76+  D39A 3E FA            ld a,250
 77+  D39C 32 7C D3         ld (robots_spawntimer),a
 78+  D39F                  ; Self writing code
 79+  D39F                  ; Robot speed
 80+  D39F 3A 84 D3         ld a,(robots_robotspeed)
 81+  D3A2 32 58 D4         ld (robots_process7+1),a
 82+  D3A5 3C               inc a
 83+  D3A6 32 88 D4         ld (robots_process6+1),a
 84+  D3A9                  ; Robots max
 85+  D3A9 3A 86 D3         ld a,(robots_robotsmax)
 86+  D3AC 32 C2 D3         ld (robots_spawn+1),a
 87+  D3AF 32 19 D4         ld (robots_process8+1),a
 88+  D3B2 32 46 D4         ld (robots_process0+1),a
 89+  D3B5 3E 04            ld a,4
 90+  D3B7 32 85 D3         ld (robots_robotspawnspeed),a
 91+  D3BA 3A 85 D3         ld a,(robots_robotspawnspeed)
 92+  D3BD 32 2A D4         ld (robots_process10+1),a
 93+  D3C0 C9               ret
 94+  D3C1
 95+  D3C1              ;
 96+  D3C1              ; Spawns a new robot
 97+  D3C1              ; Inputs:
 98+  D3C1              ; ix - pointer to start of robot array entry
 99+  D3C1              ;
100+  D3C1              robots_spawn:
101+  D3C1 06 03            ld b,3                      ;(SELF WRITING CODE)
102+  D3C3 DD 21 57 D3      ld ix,robots_robots
103+  D3C7              robots_spawn0:
104+  D3C7 DD 7E 02         ld a,(ix+2)                 ; get the state
105+  D3CA FE 00            cp 0
106+  D3CC C2 F8 D3         jp nz,robots_spawn1         ; if already active, move on
107+  D3CF ED 4B 7A D3      ld bc,(robots_initcoords)
108+  D3D3 DD 71 00 DD      ld (ix),bc
108+  D3D7 70 01
109+  D3D9 DD 36 02 01      ld (ix+2),1
110+  D3DD DD 36 03 00      ld (ix+3),0
111+  D3E1 DD 36 04 00      ld (ix+4),0
112+  D3E5 DD 36 05 00      ld (ix+5),0
113+  D3E9 DD 36 06 00      ld (ix+6),0
114+  D3ED 3A 7F D3         ld a,(robots_numberactive)
115+  D3F0 3C               inc a
116+  D3F1 32 7F D3         ld (robots_numberactive),a  ; increase the number active
117+  D3F4 CD CC D6         call robots_draw            ; draw initial frame
118+  D3F7 C9               ret
119+  D3F8              robots_spawn1:
120+  D3F8 11 07 00         ld de,7
121+  D3FB DD 19            add ix,de
122+  D3FD 10 C8            djnz robots_spawn0
123+  D3FF C9               ret
124+  D400              ;
125+  D400              ; Kills robot
126+  D400              ; Inputs:
127+  D400              ; ix - pointer to start of robot array entry
128+  D400              ;
129+  D400              robots_kill:
130+  D400 3A 7F D3         ld a,(robots_numberactive)
131+  D403 3D               dec a
132+  D404 32 7F D3         ld (robots_numberactive),a
133+  D407 DD 36 02 00      ld (ix+2),0                     ; set to inactive
134+  D40B C5               push bc
135+  D40C E5               push hl
136+  D40D 06 01            ld b,1
137+  D40F CD 89 CD         call scores_addhundreds
138+  D412 E1               pop hl
139+  D413 C1               pop bc
140+  D414 C9               ret
141+  D415
142+  D415              ;
143+  D415              ; Processes the robots
144+  D415              ;
145+  D415              robots_process:
146+  D415 3A 7F D3         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
147+  D418              robots_process8:
148+  D418 FE 03            cp 3                                    ; 3 is the maximum
149+  D41A CA 45 D4         jp z,robots_process0                    ; if already three, nothing to do
150+  D41D 3A 85 D3         ld a,(robots_robotspawnspeed)                ; now check the spawn speed timer
151+  D420 3D               dec a
152+  D421 32 85 D3         ld (robots_robotspawnspeed),a           ; store the spawn speed timer
153+  D424 FE 00            cp 0
154+  D426 C2 45 D4         jp nz,robots_process0                   ; if it hasn't reached zero yet, just move
155+  D429              robots_process10:
156+  D429 3E 04            ld a,4                                  ; SELF WRITING CODE
157+  D42B 32 85 D3         ld (robots_robotspawnspeed),a                ; reset the spawn speed timer
158+  D42E 3A 7C D3         ld a,(robots_spawntimer)                ; now check the spawn timer
159+  D431 FE 00            cp 0
160+  D433 C2 41 D4         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
161+  D436 3E FA            ld a,250
162+  D438 32 7C D3         ld (robots_spawntimer),a                ; reset the spawn timer
163+  D43B CD C1 D3         call robots_spawn                       ; spawn a robot
164+  D43E C3 45 D4         jp robots_process0                      ; carry on
165+  D441              robots_process1:
166+  D441 3D               dec a
167+  D442 32 7C D3         ld (robots_spawntimer),a                ; decrease the spawn timer and store
168+  D445              robots_process0:
169+  D445 06 03            ld b,3                                  ; max number of robots (SELF WRITING CODE)
170+  D447 DD 21 57 D3      ld ix, robots_robots                    ; point ix at the robot array
171+  D44B              robots_process2:
172+  D44B C5               push bc
173+  D44C DD 7E 02         ld a,(ix+2)                             ; check the state
174+  D44F FE 00            cp 0
175+  D451 CA 6D D4         jp z,robots_process3                    ; if not active, move on
176+  D454 3A 7E D3         ld a,(robots_movetimer)
177+  D457              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
178+  D457 FE 04            cp 4
179+  D459 C2 6D D4         jp nz,robots_process3                   ; can we move this frame
180+  D45C CD CC D6         call robots_draw                        ; draw over existing
181+  D45F CD 92 D4         call robots_move                        ; move the
182+  D462 DD 7E 02         ld a,(ix+2)                             ; get the state again
183+  D465 FE 00            cp 0
184+  D467 CA 6D D4         jp z,robots_process3                    ; move to next if this robot has become inactive
185+  D46A CD CC D6         call robots_draw                        ; draw the new robot
186+  D46D              robots_process3:
187+  D46D C1               pop bc
188+  D46E 11 07 00         ld de,7
189+  D471 DD 19            add ix,de
190+  D473 10 D6            djnz robots_process2
191+  D475 3A 7D D3         ld a,(robots_animtimer)
192+  D478 3C               inc a
193+  D479 FE 08            cp 8
194+  D47B C2 80 D4         jp nz,robots_process4
195+  D47E 3E 00            ld a,0                                  ; reset if we reached max
196+  D480              robots_process4:
197+  D480 32 7D D3         ld (robots_animtimer),a
198+  D483 3A 7E D3         ld a,(robots_movetimer)                 ; increment the robot move timer
199+  D486 3C               inc a
200+  D487              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
201+  D487 FE 05            cp 5                                    ; there is another reference to this number above
202+  D489 C2 8E D4         jp nz,robots_process5
203+  D48C 3E 00            ld a,0
204+  D48E              robots_process5:
205+  D48E 32 7E D3         ld (robots_movetimer),a
206+  D491
207+  D491 C9               ret
208+  D492
209+  D492
210+  D492              ;
211+  D492              ; Moves a robot
212+  D492              ; Inputs:
213+  D492              ; ix - points to first byte of robot in array
214+  D492              robots_move:
215+  D492 DD 7E 02         ld a,(ix+2)                             ; get the state
216+  D495 FE 02            cp 2
217+  D497 CA C8 D4         jp z,robots_move4                       ; don't move if shot, just change the anim
218+  D49A 3A 7D D3         ld a,(robots_animtimer)                 ; get the anim timer
219+  D49D FE 07            cp 7                                    ; compare with 8
220+  D49F C2 B2 D4         jp nz,robots_move1                       ; if even, don't increment frame
221+  D4A2 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
222+  D4A5 06 08            ld b,8
223+  D4A7 80               add a,b                                 ; add to anim frame
224+  D4A8 FE 20            cp 32
225+  D4AA C2 AF D4         jp nz,robots_move0                      ; if not 32, then just store
226+  D4AD 3E 00            ld a,0                                  ; otherwise, reset
227+  D4AF              robots_move0:
228+  D4AF DD 77 04         ld (ix+4),a                             ; store
229+  D4B2              robots_move1:
230+  D4B2 DD 7E 05         ld a,(ix+5)
231+  D4B5 FE 00            cp 0                                    ; are we automoving
232+  D4B7 CA C0 D4         jp z,robots_move2                       ; if not, keep directions
233+  D4BA CD DC D4         call robots_automove
234+  D4BD C3 C4 D4         jp robots_move3
235+  D4C0              robots_move2:
236+  D4C0 CD 11 D5         call robots_checkdirectionsandmove
237+  D4C3 C9               ret
238+  D4C4              robots_move3:
239+  D4C4 CD 15 D7         call robots_checkforplayer              ; check to see if we collided with a player
240+  D4C7 C9               ret
241+  D4C8              robots_move4:
242+  D4C8 DD 7E 04         ld a,(ix+4)
243+  D4CB FE 48            cp 72
244+  D4CD C2 D6 D4         jp nz,robots_move5
245+  D4D0 3E 40            ld a,64
246+  D4D2 DD 77 04         ld (ix+4),a
247+  D4D5 C9               ret
248+  D4D6              robots_move5:
249+  D4D6 3E 48            ld a,72
250+  D4D8 DD 77 04         ld (ix+4),a
251+  D4DB C9               ret
252+  D4DC
253+  D4DC
254+  D4DC              ;
255+  D4DC              ; Processes automove
256+  D4DC              ; Inputs:
257+  D4DC              ; ix - points to the current robot
258+  D4DC              ; a - number of frames left to move
259+  D4DC              robots_automove:
260+  D4DC 3D               dec a
261+  D4DD DD 77 05         ld (ix+5),a                         ; store the decreased frames
262+  D4E0 DD 4E 00 DD      ld bc,(ix)                          ; get coords
262+  D4E4 46 01
263+  D4E6 DD 7E 06         ld a,(ix+6)                         ; get the direction
264+  D4E9 FE 00            cp 0                                ; left
265+  D4EB CA FC D4         jp z,robots_automove1
266+  D4EE FE 02            cp 2                                ; up
267+  D4F0 CA 00 D5         jp z,robots_automove3
268+  D4F3 FE 03            cp 3                                ; down
269+  D4F5 CA 05 D5         jp z,robots_automove4
270+  D4F8 04               inc b                               ; right
271+  D4F9 C3 0A D5         jp robots_automove2
272+  D4FC              robots_automove1:
273+  D4FC 05               dec b
274+  D4FD C3 0A D5         jp robots_automove2
275+  D500              robots_automove3:
276+  D500 0D               dec c
277+  D501 0D               dec c
278+  D502 C3 0A D5         jp robots_automove2
279+  D505              robots_automove4:
280+  D505 0C               inc c
281+  D506 0C               inc c
282+  D507 C3 0A D5         jp robots_automove2
283+  D50A              robots_automove2:
284+  D50A DD 71 00 DD      ld (ix),bc
284+  D50E 70 01
285+  D510 C9               ret
286+  D511
287+  D511              ;
288+  D511              ; Checks if a robot can move in all directions, then picks one and moves there.
289+  D511              ; This looks complicated, but really what it does is:
290+  D511              ; 1) Look at the current direction
291+  D511              ; 2) Randomly determine which orthoganal direction check first
292+  D511              ; 3) If orthogonal can't be moved, keep going in direction we're going
293+  D511              ; 4) Otherwise, back the way we came
294+  D511              ; Inputs:
295+  D511              ; ix - points to the current robot
296+  D511              ;
297+  D511              robots_checkdirectionsandmove:
298+  D511 DD 7E 06         ld a,(ix+6)                 ; get the direction
299+  D514 FE 00            cp 0                        ; left
300+  D516 C2 3D D5         jp nz,robots_checkdirectionsandmove0
301+  D519                  ; random check
302+  D519 CD C2 C5         call game_getcurrentframe
303+  D51C E6 01            and 1                       ; odd or even
304+  D51E CA 2A D5         jp z,robots_checkdirectionsandmove3
305+  D521 CD C3 D5         call robots_checkupthendown ; prefer up over down
306+  D524 FE 01            cp 1
307+  D526 C8               ret z
308+  D527 C3 30 D5         jp robots_checkdirectionsandmove4
309+  D52A              robots_checkdirectionsandmove3:
310+  D52A CD B9 D5         call robots_checkdownthenup ; prefer down over up
311+  D52D FE 01            cp 1
312+  D52F C8               ret z
313+  D530              robots_checkdirectionsandmove4:
314+  D530                  ; check left
315+  D530 CD 55 D6         call robots_checkleftandmove
316+  D533 FE 01            cp 1
317+  D535 C8               ret z                       ; if we moved, don't check again
318+  D536                  ; check right
319+  D536 CD 8E D6         call robots_checkrightandmove
320+  D539 FE 01            cp 1
321+  D53B C8               ret z                       ; if we moved, don't check again
322+  D53C                  ; if we're here and haven't moved...
323+  D53C C9               ret
324+  D53D              robots_checkdirectionsandmove0
325+  D53D FE 01            cp 1                        ; right
326+  D53F C2 66 D5         jp nz,robots_checkdirectionsandmove1
327+  D542                  ; ALREADY MOVING RIGHT
328+  D542                  ; random check
329+  D542 CD C2 C5         call game_getcurrentframe
330+  D545 E6 01            and 1                       ; odd or even
331+  D547 CA 53 D5         jp z,robots_checkdirectionsandmove5
332+  D54A CD B9 D5         call robots_checkdownthenup ; prefer down over up
333+  D54D FE 01            cp 1
334+  D54F C8               ret z
335+  D550 C3 59 D5         jp robots_checkdirectionsandmove6
336+  D553              robots_checkdirectionsandmove5:
337+  D553 CD C3 D5         call robots_checkupthendown ; prefer down over up
338+  D556 FE 01            cp 1
339+  D558 C8               ret z
340+  D559              robots_checkdirectionsandmove6:
341+  D559                  ; check right
342+  D559 CD 8E D6         call robots_checkrightandmove
343+  D55C FE 01            cp 1
344+  D55E C8               ret z                       ; if we moved, don't check again
345+  D55F                  ; check left
346+  D55F CD 55 D6         call robots_checkleftandmove
347+  D562 FE 01            cp 1
348+  D564 C8               ret z                       ; if we moved, don't check again
349+  D565                  ; if we're here and haven't moved...
350+  D565 C9               ret
351+  D566              robots_checkdirectionsandmove1
352+  D566 FE 02            cp 2                        ; up
353+  D568 C2 8F D5         jp nz,robots_checkdirectionsandmove2
354+  D56B                  ; ALREADY MOVING UP
355+  D56B                  ; random check
356+  D56B CD C2 C5         call game_getcurrentframe
357+  D56E E6 01            and 1                       ; odd or even
358+  D570 CA 7C D5         jp z,robots_checkdirectionsandmove7
359+  D573 CD D9 D5         call robots_checkleftthenright ; prefer left over right
360+  D576 FE 01            cp 1
361+  D578 C8               ret z
362+  D579 C3 82 D5         jp robots_checkdirectionsandmove8
363+  D57C              robots_checkdirectionsandmove7:
364+  D57C CD CF D5         call robots_checkrightthenleft ; prefer right over left
365+  D57F FE 01            cp 1
366+  D581 C8               ret z
367+  D582              robots_checkdirectionsandmove8:
368+  D582                  ; check up
369+  D582 CD E5 D5         call robots_checkupandmove
370+  D585 FE 01            cp 1
371+  D587 C8               ret z                       ; if we moved, don't check again
372+  D588                  ; check down
373+  D588 CD 1F D6         call robots_checkdownandmove
374+  D58B FE 01            cp 1
375+  D58D C8               ret z                       ; if we moved, don't check again
376+  D58E                  ; if we're here and haven't moved...
377+  D58E C9               ret
378+  D58F              robots_checkdirectionsandmove2
379+  D58F                  ; ALREADY MOVING DOWN
380+  D58F                  ; random check
381+  D58F CD D1 81         call utilities_randomfromram
382+  D592 E6 01            and 1                       ; odd or even
383+  D594 CA A0 D5         jp z,robots_checkdirectionsandmove9
384+  D597 CD CF D5         call robots_checkrightthenleft ; prefer right over left
385+  D59A FE 01            cp 1
386+  D59C C8               ret z
387+  D59D C3 A6 D5         jp robots_checkdirectionsandmove10
388+  D5A0              robots_checkdirectionsandmove9:
389+  D5A0 CD D9 D5         call robots_checkleftthenright ; prefer left over right
390+  D5A3 FE 01            cp 1
391+  D5A5 C8               ret z
392+  D5A6              robots_checkdirectionsandmove10:
393+  D5A6                  ; check down
394+  D5A6 CD 1F D6         call robots_checkdownandmove
395+  D5A9 FE 01            cp 1
396+  D5AB C8               ret z                       ; if we moved, don't check again
397+  D5AC                  ; check right first
398+  D5AC CD 8E D6         call robots_checkrightandmove
399+  D5AF FE 01            cp 1
400+  D5B1 C8               ret z                       ; if we moved, don't check again
401+  D5B2                  ; check up
402+  D5B2 CD E5 D5         call robots_checkupandmove
403+  D5B5 FE 01            cp 1
404+  D5B7 C8               ret z                       ; if we moved, don't check again
405+  D5B8                  ; if we're here and haven't moved...
406+  D5B8 C9               ret
407+  D5B9
408+  D5B9              ;
409+  D5B9              ; Different orders of checking directions, for pseudo random motion
410+  D5B9              ;
411+  D5B9              robots_checkdownthenup:
412+  D5B9                  ; check down
413+  D5B9 CD 1F D6         call robots_checkdownandmove
414+  D5BC FE 01            cp 1
415+  D5BE C8               ret z                       ; if we moved, don't check again
416+  D5BF                  ; check up
417+  D5BF CD E5 D5         call robots_checkupandmove
418+  D5C2 C9               ret
419+  D5C3
420+  D5C3              robots_checkupthendown:
421+  D5C3                  ; check up
422+  D5C3 CD E5 D5         call robots_checkupandmove
423+  D5C6 FE 01            cp 1
424+  D5C8 C8               ret z
425+  D5C9                  ; check down
426+  D5C9 CD 1F D6         call robots_checkdownandmove
427+  D5CC FE 01            cp 1
428+  D5CE C9               ret
429+  D5CF              robots_checkrightthenleft:
430+  D5CF                  ; check right
431+  D5CF CD 8E D6         call robots_checkrightandmove
432+  D5D2 FE 01            cp 1
433+  D5D4 C8               ret z                       ; if we moved, don't check again
434+  D5D5                  ; check left
435+  D5D5 CD 55 D6         call robots_checkleftandmove
436+  D5D8 C9               ret
437+  D5D9
438+  D5D9              robots_checkleftthenright:
439+  D5D9                  ; check left
440+  D5D9 CD 55 D6         call robots_checkleftandmove
441+  D5DC FE 01            cp 1
442+  D5DE C8               ret z
443+  D5DF                  ; check right
444+  D5DF CD 8E D6         call robots_checkrightandmove
445+  D5E2 FE 01            cp 1
446+  D5E4 C9               ret
447+  D5E5
448+  D5E5              ;
449+  D5E5              ; Checks up for movement
450+  D5E5              ; Outputs:
451+  D5E5              ; a - 1 if have moved
452+  D5E5              robots_checkupandmove:
453+  D5E5                  ; check above
454+  D5E5 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
454+  D5E9 46 01
455+  D5EB 79               ld a,c
456+  D5EC FE 28            cp 40
457+  D5EE D8               ret c
458+  D5EF CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
459+  D5F2 62 6B            ld hl,de                        ; look at cell directly above (subtract 256)
460+  D5F4 25               dec h
461+  D5F5 79               ld a,c
462+  D5F6 0E 08            ld c,8
463+  D5F8 91               sub c
464+  D5F9 4F               ld c,a
465+  D5FA CD 02 C3         call movement_spaceisempty       ; check space is empty
466+  D5FD 7B               ld a,e                          ; check space empty flag
467+  D5FE FE 00            cp 0
468+  D600 CA 1C D6         jp z,robots_checkupandmove0    ; can't move here so return
469+  D603 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
469+  D607 46 01
470+  D609 0D               dec c                       ; move up
471+  D60A 0D               dec c
472+  D60B DD 71 00 DD      ld (ix),bc
472+  D60F 70 01
473+  D611 DD 36 06 02      ld (ix+6),2
474+  D615 DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
475+  D619 3E 01            ld a,1
476+  D61B C9               ret
477+  D61C              robots_checkupandmove0:
478+  D61C 3E 00            ld a,0
479+  D61E C9               ret
480+  D61F
481+  D61F              ;
482+  D61F              ; Checks down for movement
483+  D61F              ; Outputs:
484+  D61F              ; a - 1 if have moved
485+  D61F              robots_checkdownandmove:
486+  D61F                  ; check below
487+  D61F DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
487+  D623 46 01
488+  D625 CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
489+  D628 62 6B            ld hl,de                        ; look at cell directly above (add 256)
490+  D62A 24               inc h
491+  D62B 79               ld a,c
492+  D62C 0E 08            ld c,8
493+  D62E 81               add c
494+  D62F 4F               ld c,a
495+  D630 CD 02 C3         call movement_spaceisempty       ; check space is empty
496+  D633 7B               ld a,e                          ; check space empty flag
497+  D634 FE 00            cp 0
498+  D636 CA 52 D6         jp z,robots_checkdownandmove0    ; can't move here so return
499+  D639 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
499+  D63D 46 01
500+  D63F 0C               inc c                       ; move up
501+  D640 0C               inc c
502+  D641 DD 71 00 DD      ld (ix),bc
502+  D645 70 01
503+  D647 DD 36 06 03      ld (ix+6),3
504+  D64B DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
505+  D64F 3E 01            ld a,1
506+  D651 C9               ret
507+  D652              robots_checkdownandmove0:
508+  D652 3E 00            ld a,0
509+  D654 C9               ret
510+  D655
511+  D655              ;
512+  D655              ; Checks left for movement
513+  D655              ; Outputs:
514+  D655              ; a - 1 if have moved
515+  D655              robots_checkleftandmove:
516+  D655                  ; check below
517+  D655 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
517+  D659 46 01
518+  D65B CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
519+  D65E 62 6B            ld hl,de                        ; look at cell directly to the left (sub 1)
520+  D660 78               ld a,b
521+  D661 06 08            ld b,8
522+  D663 90               sub b                           ; move one cell left
523+  D664 47               ld b,a
524+  D665 2B               dec hl                          ; memory location of cell to the right now in hl
525+  D666 CD 02 C3         call movement_spaceisempty       ; check space is empty
526+  D669 7B               ld a,e                          ; check space empty flag
527+  D66A FE 00            cp 0
528+  D66C CA 8B D6         jp z,robots_checkleftandmove0    ; if zero can't move
529+  D66F DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
529+  D673 46 01
530+  D675 05               dec b
531+  D676 DD 71 00 DD      ld (ix),bc
531+  D67A 70 01
532+  D67C DD 36 06 00      ld (ix+6),0
533+  D680 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
534+  D684 DD 36 03 00      ld (ix+3),0                 ; set to right
535+  D688 3E 01            ld a,1
536+  D68A C9               ret
537+  D68B              robots_checkleftandmove0:
538+  D68B 3E 00            ld a,0
539+  D68D C9               ret
540+  D68E
541+  D68E              ;
542+  D68E              ; Checks right for movement
543+  D68E              ; Outputs:
544+  D68E              ; a - 1 if have moved
545+  D68E              robots_checkrightandmove:
546+  D68E                  ; check below
547+  D68E DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
547+  D692 46 01
548+  D694 78               ld a,b
549+  D695 FE E8            cp 232
550+  D697 CA C9 D6         jp z,robots_checkrightandmove0  ; can't move if at edge
551+  D69A CD 31 AC         call sprites_scadd              ; get the memory location of cell into de
552+  D69D 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
553+  D69F 3E 08            ld a,8
554+  D6A1 80               add b                           ; move one cell right
555+  D6A2 47               ld b,a
556+  D6A3 23               inc hl                          ; memory location of cell to the right now in hl
557+  D6A4 CD 02 C3         call movement_spaceisempty       ; check space is empty
558+  D6A7 7B               ld a,e                          ; check space empty flag
559+  D6A8 FE 00            cp 0
560+  D6AA CA C9 D6         jp z,robots_checkrightandmove0    ; if zero can't move
561+  D6AD DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
561+  D6B1 46 01
562+  D6B3 04               inc b
563+  D6B4 DD 71 00 DD      ld (ix),bc
563+  D6B8 70 01
564+  D6BA DD 36 06 01      ld (ix+6),1
565+  D6BE DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
566+  D6C2 DD 36 03 01      ld (ix+3),1                 ; set to right
567+  D6C6 3E 01            ld a,1
568+  D6C8 C9               ret
569+  D6C9              robots_checkrightandmove0:
570+  D6C9 3E 00            ld a,0
571+  D6CB C9               ret
572+  D6CC
573+  D6CC              ;
574+  D6CC              ; Draws a robot
575+  D6CC              ; Inputs:
576+  D6CC              ; ix - points to first byte of robot in array
577+  D6CC              robots_draw:
578+  D6CC DD 4E 00 DD      ld bc,(ix)
578+  D6D0 46 01
579+  D6D2 21 BC BF         ld hl,robot_sprite                      ; set to the robot sprite
580+  D6D5 DD 7E 02         ld a,(ix+2)                             ; get the state
581+  D6D8 FE 02            cp 2                                    ; is this dying
582+  D6DA CA F5 D6         jp z,robots_draw1
583+  D6DD              robots_draw3:
584+  D6DD DD 7E 03         ld a,(ix+3)                             ; get the direction
585+  D6E0 FE 00            cp 0
586+  D6E2 CA E9 D6         jp z,robots_draw0                       ; if left, nothing to do
587+  D6E5 11 20 00         ld de,32
588+  D6E8 19               add hl,de                               ; add four frames to sprite
589+  D6E9              robots_draw0:
590+  D6E9 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
591+  D6EC 11 00 00         ld de,0
592+  D6EF 5F               ld e,a
593+  D6F0 19               add hl,de                               ; add to base
594+  D6F1 CD 29 AB         call sprites_drawsprite
595+  D6F4 C9               ret
596+  D6F5              ;
597+  D6F5              ; Dying
598+  D6F5              ;
599+  D6F5              robots_draw1:
600+  D6F5 DD 7E 05         ld a,(ix+5)                             ; get anim frames
601+  D6F8 FE 00            cp 0                                    ; if zero this is the first time around
602+  D6FA C2 05 D7         jp nz,robots_draw2
603+  D6FD 3E 18            ld a,24
604+  D6FF DD 77 05         ld (ix+5),a                             ; load up the anim frames
605+  D702 C3 DD D6         jp robots_draw3                         ; return to main loop to draw as normal
606+  D705              robots_draw2:
607+  D705 3D               dec a
608+  D706 DD 77 05         ld (ix+5),a
609+  D709 FE 00            cp 0                                    ; have we reached the end yet
610+  D70B C2 11 D7         jp nz, robots_draw4
611+  D70E CD 00 D4         call robots_kill
612+  D711              robots_draw4:
613+  D711 C3 E9 D6         jp robots_draw0
614+  D714 C9               ret
615+  D715
616+  D715              ;
617+  D715              ; Checks to see if the robot is hitting a player
618+  D715              ; Inputs:
619+  D715              ; ix - memory location of robot we're checking
620+  D715              robots_checkforplayer:
621+  D715 3A 23 C6         ld a,(player+11)     ; get player state
622+  D718 FE 00            cp 0
623+  D71A C0               ret nz               ; if already dying, don't kill again
624+  D71B DD 4E 00 DD      ld bc,(ix)           ; get coords
624+  D71F 46 01
625+  D721 ED 5B 18 C6      ld de,(player)       ; get the player coords
626+  D725 7B               ld a,e               ; get the vert coord first
627+  D726 91               sub c                ; subtract the diamond vertical coord from players
628+  D727 C6 08            add 8                ; add the max distance
629+  D729 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
630+  D72B D0               ret nc               ; if not, hasn't hit
631+  D72C 7A               ld a,d               ; get the player horiz coord
632+  D72D 90               sub b                ; subtract rock coord
633+  D72E C6 08            add 8                ; add max distance
634+  D730 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
635+  D732 D0               ret nc
636+  D733 DD 36 02 00      ld (ix+2),0          ; mark as inactive
637+  D737 CD 53 C7         call player_robotkillplayer ; mark the player as killed
638+  D73A C9               ret
# file closed: game/robots.asm
168   D73B                  include "game\bullet.asm"
# file opened: game/bullet.asm
  1+  D73B              ;
  2+  D73B              ; Current state: x & y coords (screen), direction (0 left, 1 right), state
  3+  D73B              ;
  4+  D73B              bullet_state:
  5+  D73B 00 00 00 00      defb 0,0,0,0
  6+  D73F
  7+  D73F              ;
  8+  D73F              ; Measures if bullet can be fired. Disabled if fire held down
  9+  D73F              ;
 10+  D73F              bullet_enable:
 11+  D73F 00               defb 0
 12+  D740
 13+  D740              ;
 14+  D740              ; Initialise a the bullet
 15+  D740              ;
 16+  D740              bullet_init:
 17+  D740 DD 21 3B D7      ld ix,bullet_state
 18+  D744 DD 36 00 00      ld (ix),0
 19+  D748 DD 36 01 00      ld (ix+1),0
 20+  D74C DD 36 02 00      ld (ix+2),0
 21+  D750 DD 36 03 00      ld (ix+3),0
 22+  D754 C9               ret
 23+  D755
 24+  D755              ;
 25+  D755              ; Shoots the bullet
 26+  D755              ;
 27+  D755              bullet_shoot:
 28+  D755 3E 01            ld a,1
 29+  D757 32 3F D7         ld (bullet_enable),a        ; disable the bullet until fire is release
 30+  D75A DD 21 3B D7      ld ix,bullet_state
 31+  D75E ED 4B 18 C6      ld bc,(player)              ; get the player coords
 32+  D762 3A 1A C6         ld a,(player+2)             ; get the player direction
 33+  D765 FE 01            cp 1                        ; going left?
 34+  D767 CA 75 D7         jp z,bullet_shoot0
 35+  D76A 3E 08            ld a,8
 36+  D76C 80               add a,b                     ; going right so add eight to start coords
 37+  D76D 47               ld b,a
 38+  D76E DD 36 02 01      ld (ix+2),1                 ; set right
 39+  D772 C3 7E D7         jp bullet_shoot1
 40+  D775              bullet_shoot0:
 41+  D775 78               ld a,b
 42+  D776 06 08            ld b,8
 43+  D778 90               sub b
 44+  D779 47               ld b,a                      ; going left so subtract eight to start coords
 45+  D77A DD 36 02 00      ld (ix+2),0                 ; set right
 46+  D77E              bullet_shoot1:
 47+  D77E DD 71 00 DD      ld (ix),bc        ; store coords
 47+  D782 70 01
 48+  D784 DD 36 03 01      ld (ix+3),1       ; set state to 1
 49+  D788 CD DE D7         call bullet_draw ; draw the initial frame
 50+  D78B C9               ret
 51+  D78C
 52+  D78C              ;
 53+  D78C              ; Performs bullet processing
 54+  D78C              ;
 55+  D78C              bullet_process:
 56+  D78C 3A 3E D7         ld a,(bullet_state+3)       ; get the state
 57+  D78F FE 00            cp 0
 58+  D791 C8               ret z                       ; don't draw if this has become inactive
 59+  D792 CD DE D7         call bullet_draw            ; delete current frame
 60+  D795 CD A2 D7         call bullet_move            ; move the bullet
 61+  D798 3A 3E D7         ld a,(bullet_state+3)       ; get the state
 62+  D79B FE 00            cp 0
 63+  D79D C8               ret z                       ; don't draw if this has become inactive
 64+  D79E CD DE D7         call bullet_draw            ; draw new frame
 65+  D7A1 C9               ret
 66+  D7A2
 67+  D7A2              ;
 68+  D7A2              ; Moves the bullet, checking for collisions
 69+  D7A2              ;
 70+  D7A2              bullet_move:
 71+  D7A2 DD 21 3B D7      ld ix,bullet_state
 72+  D7A6 DD 4E 00 DD      ld bc,(ix)
 72+  D7AA 46 01
 73+  D7AC DD 7E 02         ld a,(ix+2)                 ; get the direction
 74+  D7AF FE 00            cp 0                        ; going left?
 75+  D7B1 CA BB D7         jp z,bullet_move0
 76+  D7B4 3E 08            ld a,8
 77+  D7B6 80               add b
 78+  D7B7 47               ld b,a                      ; add 8 since going right
 79+  D7B8 C3 C0 D7         jp bullet_move1
 80+  D7BB              bullet_move0:
 81+  D7BB 78               ld a,b
 82+  D7BC 06 08            ld b,8
 83+  D7BE 90               sub b
 84+  D7BF 47               ld b,a                      ; subtract 8 since going left
 85+  D7C0              bullet_move1:
 86+  D7C0 DD 71 00 DD      ld (ix),bc                  ; store new coords
 86+  D7C4 70 01
 87+  D7C6 C5               push bc
 88+  D7C7 CD EB D7         call bullets_checkforrobot
 89+  D7CA C1               pop bc
 90+  D7CB FE 01            cp 1                        ; if we hit a robot, keep moving
 91+  D7CD C8               ret z
 92+  D7CE CD 31 AC         call sprites_scadd          ; get memory loc of this block into de
 93+  D7D1 21 60 00         ld hl,96
 94+  D7D4 19               add hl,de
 95+  D7D5 7E               ld a,(hl)                   ; get the content
 96+  D7D6 FE 00            cp 0
 97+  D7D8 C8               ret z                       ; if empty, continue
 98+  D7D9 DD 36 03 00      ld (ix+3),0                 ; otherwise, mark bullet as inactive
 99+  D7DD C9               ret
100+  D7DE
101+  D7DE              ;
102+  D7DE              ; Draw the bullet
103+  D7DE              ;
104+  D7DE              bullet_draw:
105+  D7DE ED 4B 3B D7      ld bc,(bullet_state)        ; get coords
106+  D7E2 3E 1B            ld a,27
107+  D7E4 CD A4 AA         call screen_getblock        ; get the block address
108+  D7E7 CD 29 AB         call sprites_drawsprite     ; draw the sprite
109+  D7EA C9               ret
110+  D7EB
111+  D7EB              ;
112+  D7EB              ; Checks to see if the robot is hitting a bullet
113+  D7EB              ; Outputs:
114+  D7EB              ; a = 0 if not robot hit
115+  D7EB              ; a = 1 if robot not hit
116+  D7EB              bullets_checkforrobot:
117+  D7EB 3E 00            ld a,0
118+  D7ED 32 41 D8         ld (bullets_tmp),a
119+  D7F0 3A 86 D3         ld a,(robots_robotsmax) ; robots to check
120+  D7F3 47               ld b,a
121+  D7F4 FD 21 57 D3      ld iy,robots_robots   ; start of robot array
122+  D7F8              bullets_checkforrobot0:
123+  D7F8 C5               push bc
124+  D7F9 FD 7E 02         ld a,(iy+2)             ; get the state
125+  D7FC FE 01            cp 1
126+  D7FE C2 35 D8         jp nz,bullets_checkforrobot1 ; if not active, don't check
127+  D801 FD 5E 00 FD      ld de,(iy)              ; get robot coords
127+  D805 56 01
128+  D807 7A               ld a,d
129+  D808 E6 F8            and 248                 ; get nearest multiple of 8
130+  D80A 57               ld d,a
131+  D80B ED 4B 3B D7      ld bc,(bullet_state)    ; get bullet coords
132+  D80F 7A               ld a,d               ; get the robot horiz coord
133+  D810 90               sub b                ; subtract robot coord
134+  D811 FE 00            cp 0                ; should be the same
135+  D813 CA 1F D8         jp z,bullets_checkforrobot2 ; if not, might have hit, so check the next char along... if matched, check vert
136+  D816 3E 08            ld a,8
137+  D818 82               add a,d
138+  D819 90               sub b                ; check again for the next char along
139+  D81A FE 00            cp 0
140+  D81C C2 35 D8         jp nz,bullets_checkforrobot1 ; if not, haven't hit
141+  D81F              bullets_checkforrobot2:
142+  D81F 7B               ld a,e               ; get the vert coord
143+  D820 91               sub c                ; subtract the bullet vertical coord from robots
144+  D821 C6 04            add 4                ; add the max distance
145+  D823 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
146+  D825 D2 35 D8         jp nc,bullets_checkforrobot1   ; if not, hasn't hit
147+  D828 FD 36 02 02      ld (iy+2),2             ; mark the robot as killed
148+  D82C FD 36 05 00      ld (iy+5),0             ; mark the anim frames as zero
149+  D830 3E 01            ld a,1
150+  D832 32 41 D8         ld (bullets_tmp),a      ; hit the flag to say we killed a robot
151+  D835              bullets_checkforrobot1:
152+  D835 11 07 00         ld de,7
153+  D838 FD 19            add iy,de              ; move to next robot
154+  D83A C1               pop bc
155+  D83B 10 BB            djnz bullets_checkforrobot0
156+  D83D 3A 41 D8         ld a,(bullets_tmp)
157+  D840 C9               ret
158+  D841
159+  D841              bullets_tmp:
160+  D841 00               defb 0
161+  D842
# file closed: game/bullet.asm
169   D842
170   D842              ;===========================================================================
171   D842              ; Stack.
172   D842              ;===========================================================================
173   D842
174   D842              ; Stack: this area is reserved for the stack
175   D842              STACK_SIZE: equ 100    ; in words
176   D842
177   D842              ; Reserve stack space
178   D842 00 00            defw 0  ; WPMEM, 2
179   D844              stack_bottom:
180   D844 00 00 00...      defs    STACK_SIZE*2, 0
181   D90C              stack_top:
182   D90C 00 00            defw 0  ; WPMEM, 2
183   D90E
184   D90E                     SAVESNA "./dist/ThePit.sna", main
185   D90E                     ;SAVETAP "./dist/ThePit.tap", main
# file closed: main.asm
