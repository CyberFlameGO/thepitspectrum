# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000 CD 6B 0D         call $0D6B
  7+  8003 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8005                                      ; bright (64).
  9+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 10+  8008 AF               xor a               ; quick way to load accumulator with zero.
 11+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 12+  800C CD AF 0D         call 3503           ; ROM routine - clears screen, opens chan 2.
 13+  800F
 14+  800F C9               ret
 15+  8010
 16+  8010              ;
 17+  8010              ;   Start coord
 18+  8010              ;   vert c, horiz b
 19+  8010              start_coord:
 20+  8010 18 30            defb 24,48
 21+  8012
# file closed: init.asm
 21   8012                  include "utilities.asm"
# file opened: utilities.asm
  1+  8012              ; ##########################################################################
  2+  8012              ; Print a character
  3+  8012              ; Inputs:
  4+  8012              ; b - x coord
  5+  8012              ; c - y coord
  6+  8012              ; d - character
  7+  8012              ; e - colour
  8+  8012              ; ##########################################################################
  9+  8012              utilities_print_char:
 10+  8012 7B               ld a,e
 11+  8013 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  8016 3E 16            ld a,22
 13+  8018 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8019 78               ld a,b              ; Gets the X co-ordinate
 15+  801A 3D               dec a
 16+  801B D7               rst 16
 17+  801C 79               ld a,c              ; and the Y co-ordinate
 18+  801D D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  801E 7A               ld a,d              ; ASCII code for udg.
 20+  801F D7               rst 16              ; draw block.
 21+  8020 C9               ret
 22+  8021
 23+  8021
 24+  8021              ;Inputs:
 25+  8021              ;     DE and A are factors
 26+  8021              ;Outputs:
 27+  8021              ;     A is not changed
 28+  8021              ;     B is 0
 29+  8021              ;     C is not changed
 30+  8021              ;     DE is not changed
 31+  8021              ;     HL is the product
 32+  8021              ;Time:
 33+  8021              ;     342+6x
 34+  8021              ;
 35+  8021              utilities_multiply:
 36+  8021 06 08            ld b,8          ;7           7
 37+  8023 21 00 00         ld hl,0         ;10         10
 38+  8026 29               add hl,hl     ;11*8       88
 39+  8027 07               rlca          ;4*8        32
 40+  8028 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  802A 19                   add hl,de   ;--         --
 42+  802B 10 F9            djnz $-5      ;13*7+8     99
 43+  802D C9               ret             ;10         10
 44+  802E
 45+  802E              utilities_waitforkey:
 46+  802E 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  8031 36 00            ld (hl),0           ; put null value there.
 48+  8033              utilities_waitforkey0:
 49+  8033 7E               ld a,(hl)           ; new value of LAST K.
 50+  8034 FE 00            cp 0                ; is it still zero?
 51+  8036 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8038 C9               ret                 ; key was pressed.
 53+  8039
 54+  8039              ;
 55+  8039              ; Waits number of frames for keypress. If got, returns 1, if not 0
 56+  8039              ; Inputs:
 57+  8039              ; a - number of frames to waits
 58+  8039              ; Ouputs:
 59+  8039              ; e - 0 not pressed, 1 pressed
 60+  8039              utilities_waitforkey_forframes:
 61+  8039 21 08 5C         ld hl,23560         ; LAST K system variable.
 62+  803C 36 00            ld (hl),0           ; put null value there.
 63+  803E 47               ld b,a              ; number of frames to wait
 64+  803F              utilities_waitforkey_forframes0:
 65+  803F 7E               ld a,(hl)           ; new value of LAST K.
 66+  8040 FE 00            cp 0                ; is it still zero?
 67+  8042 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 68+  8044 1E 01            ld e,1              ; set the pressed flag
 69+  8046 C9               ret                 ; key was pressed.
 70+  8047              utilities_waitforkey_forframes1:
 71+  8047 76               halt                ; wait for frame
 72+  8048 76               halt                ; wait for frame
 73+  8049 10 F4            djnz utilities_waitforkey_forframes0 ; loop again
 74+  804B 1E 00            ld e,0              ; nothing pressed in time
 75+  804D C9               ret
 76+  804E
# file closed: utilities.asm
 22   804E                  include "strings.asm"
# file opened: strings.asm
  1+  804E              string_score1:
  2+  804E 04 00 53 43      defb 4,0,'SCORE1',255
  2+  8052 4F 52 45 31
  2+  8056 FF
  3+  8057              string_scorenumbers1:
  4+  8057 04 01 30 30      defb 4,1,'000000',255
  4+  805B 30 30 30 30
  4+  805F FF
  5+  8060              string_company:
  6+  8060 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  8064 4E 54 55 52
  6+  8068 49 FF
  7+  806A              string_credits:
  8+  806A 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  806E 41 59 45 52
  8+  8072 20 31 FF
  9+  8075              string_score2:
 10+  8075 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8079 4F 52 45 32
 10+  807D FF
 11+  807E              string_scorenumbers2:
 12+  807E 16 01 30 30      defb 22,1,'000000',255
 12+  8082 30 30 30 30
 12+  8086 FF
 13+  8087              string_titlescreen_copyright:
 14+  8087 04 16 7F 20      defb 4,22, 127,' 1982 AW ZILEC ELC LTD',255
 14+  808B 31 39 38 32
 14+  808F 20 41 57 20
 14+  8093 5A 49 4C 45
 14+  8097 43 20 45 4C
 14+  809B 43 20 4C 54
 14+  809F 44 FF
 15+  80A1
 16+  80A1
 17+  80A1              string_alttitlescreen_1:
 18+  80A1 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  80A5 45 44 49 54
 18+  80A9 53 20 31 FF
 19+  80AD              string_alttitlescreen_2:
 20+  80AD 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  80B1 20 20 20 20
 20+  80B5 20 20 20 20
 20+  80B9 20 54 48 45
 20+  80BD 20 4F 42 4A
 20+  80C1 45 43 54 FE
 21+  80C5 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  80C9 20 20 20 20
 21+  80CD 20 20 20 20
 21+  80D1 4F 46 20 54
 21+  80D5 48 49 53 20
 21+  80D9 47 41 4D 45
 21+  80DD FE
 22+  80DE 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  80E2 20 20 20 20
 22+  80E6 20 20 20 49
 22+  80EA 53 20 54 4F
 22+  80EE 20 44 49 47
 22+  80F2 20 44 4F 57
 22+  80F6 4E FE
 23+  80F8 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  80FC 20 20 20 20
 23+  8100 20 20 54 4F
 23+  8104 20 54 48 45
 23+  8108 20 42 4F 54
 23+  810C 54 4F 4D 20
 23+  8110 50 49 54 FE
 24+  8114 00 06 20 20      defb 0,6,'               AND',254
 24+  8118 20 20 20 20
 24+  811C 20 20 20 20
 24+  8120 20 20 20 20
 24+  8124 20 41 4E 44
 24+  8128 FE
 25+  8129 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  812D 20 20 20 20
 25+  8131 20 20 43 4F
 25+  8135 4C 4C 45 43
 25+  8139 54 20 41 54
 25+  813D 20 4C 45 41
 25+  8141 53 54 FE
 26+  8144 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  8148 20 20 20 20
 26+  814C 20 20 20 4F
 26+  8150 4E 45 20 4C
 26+  8154 41 52 47 45
 26+  8158 20 4A 45 57
 26+  815C 45 4C FE
 27+  815F 00 09 20 20      defb 0,9,'              THEN',254
 27+  8163 20 20 20 20
 27+  8167 20 20 20 20
 27+  816B 20 20 20 20
 27+  816F 54 48 45 4E
 27+  8173 FE
 28+  8174 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  8178 20 20 20 20
 28+  817C 20 20 20 52
 28+  8180 45 54 55 52
 28+  8184 4E 20 54 4F
 28+  8188 20 53 48 49
 28+  818C 50 FE
 29+  818E 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  8192 20 20 20 20
 29+  8196 20 20 20 54
 29+  819A 48 52 55 20
 29+  819E 55 50 50 45
 29+  81A2 52 20 50 49
 29+  81A6 54 FF
 30+  81A8              string_alttitlescreen_3:
 31+  81A8 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  81AC 20 20 53 49
 31+  81B0 4E 47 4C 45
 31+  81B4 20 42 4F 4E
 31+  81B8 55 53 20 20
 31+  81BC 35 30 30 30
 31+  81C0 20 50 4F 49
 31+  81C4 4E 54 53 FE
 32+  81C8 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  81CC 20 20 20 20
 32+  81D0 43 4F 4C 4C
 32+  81D4 45 43 54 20
 32+  81D8 31 20 4C 41
 32+  81DC 52 47 45 20
 32+  81E0 4A 45 57 45
 32+  81E4 4C FE
 33+  81E6 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  81EA 20 20 20 20
 33+  81EE 20 41 4E 44
 33+  81F2 20 52 45 54
 33+  81F6 55 52 4E 20
 33+  81FA 54 4F 20 53
 33+  81FE 48 49 50 FE
 34+  8202 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  8206 20 20 44 4F
 34+  820A 55 42 4C 45
 34+  820E 20 42 4F 4E
 34+  8212 55 53 20 20
 34+  8216 31 30 30 30
 34+  821A 30 20 50 4F
 34+  821E 49 4E 54 53
 34+  8222 FE
 35+  8223 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  8227 20 20 43 4F
 35+  822B 4C 4C 45 43
 35+  822F 54 20 41 4C
 35+  8233 4C 20 33 20
 35+  8237 4C 41 52 47
 35+  823B 45 20 4A 45
 35+  823F 57 45 4C 53
 35+  8243 FE
 36+  8244 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  8248 20 20 20 20
 36+  824C 20 4F 52 20
 36+  8250 20 20 41 4C
 36+  8254 4C 20 34 20
 36+  8258 53 4D 41 4C
 36+  825C 4C 20 4A 45
 36+  8260 57 45 4C 53
 36+  8264 FE
 37+  8265 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  8269 20 20 54 52
 37+  826D 49 50 4C 45
 37+  8271 20 42 4F 4E
 37+  8275 55 53 20 20
 37+  8279 31 35 30 30
 37+  827D 30 20 50 4F
 37+  8281 49 4E 54 53
 37+  8285 FE
 38+  8286 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  828A 20 20 20 20
 38+  828E 20 43 4F 4C
 38+  8292 4C 45 43 54
 38+  8296 20 41 4C 4C
 38+  829A 20 37 20 4A
 38+  829E 45 57 45 4C
 38+  82A2 53 FF
 39+  82A4
 40+  82A4              ;
 41+  82A4              ; Prints specified string
 42+  82A4              ; Inputs:
 43+  82A4              ; de: pointer to string
 44+  82A4              ; bc: length of string
 45+  82A4              ;
 46+  82A4              ; Print String Data
 47+  82A4              ; First two bytes of string contain X and Y char position, then the string
 48+  82A4              ; Individual strings are terminated with 0xFE
 49+  82A4              ; End of data is terminated with 0xFF
 50+  82A4              ; HL: Address of string
 51+  82A4              ;
 52+  82A4 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
 53+  82A5 23                                   INC HL                          ; Increase HL to the next memory location
 54+  82A6 56                                   LD D,(HL)                       ; Fetch the Y coordinate
 55+  82A7 23                                   INC HL                          ; Increase HL to the next memory location
 56+  82A8 CD BB 82                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
 57+  82AB 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
 58+  82AC 23                                   INC HL                          ; Increase HL to the next character
 59+  82AD FE FE                                CP 0xFE                         ; Compare with 0xFE
 60+  82AF 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
 61+  82B1 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
 62+  82B2 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
 63+  82B3 CD CB 82                             CALL Print_Char                 ; Print the character
 64+  82B6 E1                                   POP HL                          ; Retrieve HL back off the stack
 65+  82B7 1C                                   INC E                           ; Go to the next screen address
 66+  82B8 18 F1                                JR string_print_0               ; Loop back to print next character
 67+  82BA C9                                   RET
 68+  82BB
 69+  82BB              ; Get screen address
 70+  82BB              ; D = Y character position
 71+  82BB              ; E = X character position
 72+  82BB              ; Returns address in DE
 73+  82BB              ;
 74+  82BB 7A           string_getcharaddress:       LD A,D
 75+  82BC E6 07                                AND %00000111
 76+  82BE 1F                                   RRA
 77+  82BF 1F                                   RRA
 78+  82C0 1F                                   RRA
 79+  82C1 1F                                   RRA
 80+  82C2 B3                                   OR E
 81+  82C3 5F                                   LD E,A
 82+  82C4 7A                                   LD A,D
 83+  82C5 E6 18                                AND %00011000
 84+  82C7 F6 40                                OR %01000000
 85+  82C9 57                                   LD D,A
 86+  82CA C9                                   RET                             ; Returns screen address in DE
 87+  82CB
 88+  82CB              ; Print a single character out
 89+  82CB              ; A:  Character to print
 90+  82CB              ; DE: Screen address to print character at
 91+  82CB              ;
 92+  82CB 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
 93+  82CE 06 00                                LD B,0                          ; Set BC to A
 94+  82D0 4F                                   LD C,A
 95+  82D1 E6 FF                                AND 0xFF                        ; Clear the carry bit
 96+  82D3 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
 97+  82D5 CB 10                                RL B
 98+  82D7 CB 11                                RL C
 99+  82D9 CB 10                                RL B
100+  82DB CB 11                                RL C
101+  82DD CB 10                                RL B
102+  82DF 09                                   ADD HL,BC                       ; Get the character address in HL
103+  82E0 0E 08                                LD C,8                          ; Loop counter
104+  82E2 D5                                   PUSH DE
105+  82E3 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
106+  82E4 12                                   LD (DE),A                       ; Stick A onto the screen
107+  82E5 14                                   INC D                           ; Goto next line on screen
108+  82E6 2C                                   INC L                           ; Goto next byte of character
109+  82E7 0D                                   DEC C                           ; Decrease the loop counter
110+  82E8 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
111+  82EA D1                                   POP DE
112+  82EB C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   82EC                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  82EC              buffer_buffer:
  2+  82EC 00 00 00...      defs 7424                   ; area reserved for screen
  3+  9FEC
  4+  9FEC              buffer_attr_buffer:
  5+  9FEC 00 00 00...      defs 928                    ; attrs buffer area
  6+  A38C
  7+  A38C              buffer_tmp:
  8+  A38C 00 00            defb 0,0                    ; temp area
  9+  A38E
 10+  A38E              buffer_updatedlines:
 11+  A38E FF FF FF...      defs 21,255
 12+  A3A3
 13+  A3A3              buffer_updateall:
 14+  A3A3 00               defb 0
 15+  A3A4
 16+  A3A4              ;
 17+  A3A4              ; Stores a line number in the update list
 18+  A3A4              ; Inputs:
 19+  A3A4              ; a - row number
 20+  A3A4              buffer_marklineforupdate:
 21+  A3A4 5F               ld e,a                          ; store in e
 22+  A3A5 06 15            ld b,21
 23+  A3A7 21 8E A3         ld hl,buffer_updatedlines
 24+  A3AA              buffer_marklineforupdate0:
 25+  A3AA 7E               ld a,(hl)                       ; get the line stored in updated lines
 26+  A3AB BB               cp e                            ; is this the same as the row number passed in?
 27+  A3AC C8               ret z                           ; if so, don't need to do anything
 28+  A3AD FE FF            cp 255                          ; is this 255, ie the end of the buffer
 29+  A3AF C2 B4 A3         jp nz,buffer_marklineforupdate1 ; if not, move to next
 30+  A3B2 73               ld (hl),e                       ; if it is, this spot is empty, so store the row number
 31+  A3B3 C9               ret                             ; and finish
 32+  A3B4              buffer_marklineforupdate1:
 33+  A3B4 23               inc hl
 34+  A3B5 10 F3            djnz buffer_marklineforupdate0
 35+  A3B7 C9               ret
 36+  A3B8
 37+  A3B8              ;
 38+  A3B8              ; Zeroes the updated lines list
 39+  A3B8              ;
 40+  A3B8              buffer_clearlist:
 41+  A3B8 06 15            ld b,21
 42+  A3BA 21 8E A3         ld hl,buffer_updatedlines
 43+  A3BD              buffer_clearlist0:
 44+  A3BD 36 FF            ld (hl),255
 45+  A3BF 23               inc hl
 46+  A3C0 10 FB            djnz buffer_clearlist0
 47+  A3C2 C9               ret
 48+  A3C3
 49+  A3C3              ;
 50+  A3C3              ; Copies the buffer to the screen. Use stack.
 51+  A3C3              ; Inputs:
 52+  A3C3              ; a - row number to display - 0 is first line
 53+  A3C3              ;
 54+  A3C3              buffer_bufferlinetoscreen:
 55+  A3C3 4F               ld c,a                          ; store a
 56+  A3C4 ED 5B F1 A4      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 57+  A3C8 83               add a,e                       ; add the row number
 58+  A3C9 11 00 01         ld de,256
 59+  A3CC CD 21 80         call utilities_multiply
 60+  A3CF 54 5D            ld de,hl
 61+  A3D1 21 EC 82         ld hl,buffer_buffer
 62+  A3D4 19               add hl,de                   ; add the offset
 63+  A3D5 79               ld a,c                      ; get original row back
 64+  A3D6 ED 73 34 A4      ld (buffer_bufferlinetoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
 65+  A3DA D9               exx
 66+  A3DB 47               ld b,a                      ; load the row number into vertical coord
 67+  A3DC 04               inc b
 68+  A3DD 04               inc b                       ; move forward 2 to allow for scores
 69+  A3DE 0E 00            ld c,0                      ; zero horizontal
 70+  A3E0 CD D2 A5         call screen_getcelladdress  ; get the memory into de
 71+  A3E3 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
 72+  A3E6 19               add hl,de
 73+  A3E7              buffer_bufferlinetoscreen0:
 74+  A3E7 D9               exx                         ; hl is now buffer
 75+  A3E8 23               inc hl
 76+  A3E9 23               inc hl                      ; move hl forward 2 to skip first two blocks
 77+  A3EA F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
 78+  A3EB F1               pop af
 79+  A3EC C1               pop bc
 80+  A3ED D1               pop de
 81+  A3EE DD E1            pop ix
 82+  A3F0 D9               exx                         ; hl is now screen
 83+  A3F1 08               ex af,af'
 84+  A3F2 F1               pop af
 85+  A3F3 C1               pop bc
 86+  A3F4 D1               pop de
 87+  A3F5 F9               ld sp,hl                    ; sp pointing at screen
 88+  A3F6 D5               push de
 89+  A3F7 C5               push bc
 90+  A3F8 F5               push af
 91+  A3F9 08               ex af,af'
 92+  A3FA D9               exx                         ; hl is now buffer
 93+  A3FB DD E5            push ix
 94+  A3FD D5               push de
 95+  A3FE C5               push bc
 96+  A3FF F5               push af
 97+  A400 1E 0E            ld e,14                    ; do another fourteen for right hand side
 98+  A402 16 00            ld d,0
 99+  A404 19               add hl,de
100+  A405 F9               ld sp,hl                    ; sp pointing at buffer
101+  A406 F1               pop af
102+  A407 C1               pop bc
103+  A408 D1               pop de
104+  A409 DD E1            pop ix
105+  A40B                  ;pop ix
106+  A40B D9               exx                         ; hl is now screen
107+  A40C 08               ex af,af'
108+  A40D 1E 0E            ld e,14
109+  A40F 16 00            ld d,0
110+  A411 19               add hl,de
111+  A412 F1               pop af
112+  A413 C1               pop bc
113+  A414 D1               pop de
114+  A415                  ;pop iy
115+  A415 F9               ld sp,hl                    ; sp pointing at screen
116+  A416                  ;push iy
117+  A416 D5               push de
118+  A417 C5               push bc
119+  A418 F5               push af
120+  A419 08               ex af,af'
121+  A41A D9               exx                         ; hl is now buffer
122+  A41B DD E5            push ix
123+  A41D D5               push de
124+  A41E C5               push bc
125+  A41F F5               push af
126+  A420 1E 10            ld e,16
127+  A422 16 00            ld d,0
128+  A424 19               add hl,de
129+  A425 D9               exx                         ; hl is now screen
130+  A426 1E 0E            ld e,14
131+  A428 16 00            ld d,0
132+  A42A ED 52            sbc hl,de
133+  A42C 24               inc h
134+  A42D 7C               ld a,h
135+  A42E E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
136+  A430 C2 E7 A3         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
137+  A433              buffer_bufferlinetoscreen1:
138+  A433 31 00 00         ld sp,0
139+  A436 D9               exx
140+  A437 C9               ret
141+  A438
142+  A438              ;
143+  A438              ; Copies the buffer to the screen for updated lines. Use stack.
144+  A438              ; Inputs: none
145+  A438              ;
146+  A438              buffer_buffertoscreen:
147+  A438 3A A3 A3         ld a,(buffer_updateall)      ; get the all update flag
148+  A43B FE 00            cp 0
149+  A43D CA 49 A4         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
150+  A440 CD 6A A4         call buffer_allbuffertoscreen ; otherwise, draw whole screen
151+  A443 21 A3 A3         ld hl,buffer_updateall
152+  A446 36 00            ld (hl),0                    ; reset flag
153+  A448 C9               ret
154+  A449              buffer_buffertoscreen2:
155+  A449 06 15            ld b,21
156+  A44B FD 21 8E A3      ld iy,buffer_updatedlines    ; the location of the updated lines
157+  A44F              buffer_buffertoscreen0:
158+  A44F FD 7E 00         ld a,(iy)
159+  A452 FE FF            cp 255
160+  A454 CA 66 A4         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
161+  A457 C5               push bc
162+  A458 FD E5            push iy
163+  A45A F3               di
164+  A45B CD C3 A3         call buffer_bufferlinetoscreen
165+  A45E FB               ei
166+  A45F FD E1            pop iy
167+  A461 C1               pop bc
168+  A462 FD 23            inc iy
169+  A464 10 E9            djnz buffer_buffertoscreen0
170+  A466              buffer_buffertoscreen1:
171+  A466 CD 7E A4         call buffer_buffertoattrsfast
172+  A469 C9               ret
173+  A46A
174+  A46A              ;
175+  A46A              ; Copies the buffer to the screen. Use stack.
176+  A46A              ; Inputs: none
177+  A46A              ;
178+  A46A              buffer_allbuffertoscreen:
179+  A46A 06 15            ld b,21
180+  A46C 3E 00            ld a,0
181+  A46E              buffer_allbuffertoscreen0:
182+  A46E C5               push bc
183+  A46F F5               push af
184+  A470 F3               di
185+  A471 CD C3 A3         call buffer_bufferlinetoscreen
186+  A474 FB               ei
187+  A475 F1               pop af
188+  A476 C1               pop bc
189+  A477 3C               inc a
190+  A478 10 F4            djnz buffer_allbuffertoscreen0
191+  A47A
192+  A47A CD 7E A4         call buffer_buffertoattrsfast
193+  A47D C9               ret
194+  A47E
195+  A47E              ;
196+  A47E              ; Copies the attrs buffer to screen with the stack
197+  A47E              ;
198+  A47E              buffer_buffertoattrsfast:
199+  A47E ED 73 ED A4      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
200+  A482 3A F1 A4         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
201+  A485 11 20 00         ld de,32
202+  A488 CD 21 80         call utilities_multiply
203+  A48B 54 5D            ld de,hl
204+  A48D 21 EC 9F         ld hl,buffer_attr_buffer
205+  A490 19               add hl,de                       ; add the offset, start of attr buffer now in hl
206+  A491 D9               exx
207+  A492 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
208+  A495 FD 21 8C A3      ld iy,buffer_tmp
209+  A499 FD 36 00 15      ld (iy),21              ; number of times to loop
210+  A49D              buffer_buffertoattrsfast0:
211+  A49D D9               exx                         ; hl is now buffer
212+  A49E 23               inc hl
213+  A49F 23               inc hl                      ; move hl forward 2 to skip first two blocks
214+  A4A0 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
215+  A4A1 F1               pop af
216+  A4A2 C1               pop bc
217+  A4A3 D1               pop de
218+  A4A4 DD E1            pop ix
219+  A4A6 D9               exx                         ; hl is now screen
220+  A4A7 08               ex af,af'
221+  A4A8 F1               pop af
222+  A4A9 C1               pop bc
223+  A4AA D1               pop de
224+  A4AB F9               ld sp,hl                    ; sp pointing at screen
225+  A4AC D5               push de
226+  A4AD C5               push bc
227+  A4AE F5               push af
228+  A4AF 08               ex af,af'
229+  A4B0 D9               exx                         ; hl is now buffer
230+  A4B1 DD E5            push ix
231+  A4B3 D5               push de
232+  A4B4 C5               push bc
233+  A4B5 F5               push af
234+  A4B6 1E 0E            ld e,14                    ; do another fourteen for right hand side
235+  A4B8 16 00            ld d,0
236+  A4BA 19               add hl,de
237+  A4BB F9               ld sp,hl                    ; sp pointing at buffer
238+  A4BC F1               pop af
239+  A4BD C1               pop bc
240+  A4BE D1               pop de
241+  A4BF DD E1            pop ix
242+  A4C1 D9               exx                         ; hl is now screen
243+  A4C2 08               ex af,af'
244+  A4C3 1E 0E            ld e,14
245+  A4C5 16 00            ld d,0
246+  A4C7 19               add hl,de
247+  A4C8 F1               pop af
248+  A4C9 C1               pop bc
249+  A4CA D1               pop de
250+  A4CB F9               ld sp,hl                    ; sp pointing at screen
251+  A4CC D5               push de
252+  A4CD C5               push bc
253+  A4CE F5               push af
254+  A4CF 08               ex af,af'
255+  A4D0 D9               exx                         ; hl is now buffer
256+  A4D1 DD E5            push ix
257+  A4D3 D5               push de
258+  A4D4 C5               push bc
259+  A4D5 F5               push af
260+  A4D6 1E 10            ld e,16
261+  A4D8 16 00            ld d,0
262+  A4DA 19               add hl,de
263+  A4DB D9               exx                         ; hl is now screen
264+  A4DC 11 12 00         ld de,18
265+  A4DF 19               add hl,de
266+  A4E0 FD 7E 00         ld a,(iy)
267+  A4E3 3D               dec a
268+  A4E4 FE 00            cp 0
269+  A4E6 FD 77 00         ld (iy),a
270+  A4E9 C2 9D A4         jp nz,buffer_buffertoattrsfast0 ; do another row
271+  A4EC              buffer_buffertoattrsfast1:
272+  A4EC 31 00 00         ld sp,0
273+  A4EF D9               exx
274+  A4F0 C9               ret
# file closed: screen/buffer.asm
 24   A4F1                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A4F1              screen_offset:
  2+  A4F1 00               defb 0                      ; offset from top of screen in lines
  3+  A4F2
  4+  A4F2              screen_tmp:
  5+  A4F2 00               defb 0                      ; temporary memory
  6+  A4F3
  7+  A4F3              screen_setscorecolours:
  8+  A4F3 21 7F AD         ld hl,score_colours
  9+  A4F6 11 00 58         ld de,22528                     ; attrs here
 10+  A4F9 01 40 00         ld bc,64
 11+  A4FC ED B0            ldir
 12+  A4FE C9               ret
 13+  A4FF
 14+  A4FF              screen_sethighscorecolours:
 15+  A4FF 21 BF AD         ld hl,high_score_colours
 16+  A502 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A505 01 20 00         ld bc,32
 18+  A508 ED B0            ldir
 19+  A50A C9               ret
 20+  A50B
 21+  A50B              ; Draw the screen
 22+  A50B              ; Inputs:
 23+  A50B              ; none
 24+  A50B              ; Notes:
 25+  A50B              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A50B              screen_draw:
 27+  A50B                  ;call clear_screen
 28+  A50B 0E 00            ld c,0                      ; horiz
 29+  A50D 06 00            ld b,0                      ; vert, 0 at top
 30+  A50F DD 21 41 A8      ld ix,level01               ; point ix at level data
 31+  A513 FD 21 EC 9F      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A517              screen_draw0:
 33+  A517 DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A51A C5               push bc                     ; store bc, contains loop count
 35+  A51B CD 59 A6         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A51E 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A51F FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A522 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A525 CD 4E A6         call screen_getblock        ; get the block data into hl
 40+  A528 CD 34 A6         call screen_showchar        ; show this character here
 41+  A52B C1               pop bc                      ; get the loop counter back
 42+  A52C DD 23            inc ix                      ; increment level location
 43+  A52E FD 23            inc iy                      ; increment attr location
 44+  A530 0C               inc c                       ; increment horiz
 45+  A531 79               ld a,c
 46+  A532 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A534 C2 17 A5         jp nz,screen_draw0          ; if not, loop
 48+  A537 0E 00            ld c,0                      ; if so, reset horiz
 49+  A539 04               inc b                       ; increment vertical
 50+  A53A 78               ld a,b
 51+  A53B FE 1D            cp 29                       ; check if at bottom
 52+  A53D C2 17 A5         jp nz,screen_draw0          ; if not, loop
 53+  A540 21 F2 A4         ld hl, screen_tmp
 54+  A543 36 09            ld (hl),9                   ; load the block number into memory
 55+  A545 DD 21 E1 AB      ld ix,level01rocks          ; rock memory
 56+  A549 CD A2 A5         call screen_initobjects     ; draw rocks
 57+  A54C 21 F2 A4         ld hl, screen_tmp
 58+  A54F 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A551 DD 21 E1 AC      ld ix,level01missiles       ; missile memory
 60+  A555 CD A2 A5         call screen_initobjects     ; draw missiles
 61+  A558 21 F2 A4         ld hl, screen_tmp
 62+  A55B 36 08            ld (hl),08                  ; load the block number into memory
 63+  A55D DD 21 5A AD      ld ix,level01diamonds       ; diamond memory
 64+  A561 CD A2 A5         call screen_initobjects     ; draw diamonds
 65+  A564 21 F2 A4         ld hl, screen_tmp
 66+  A567 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A569 DD 21 6A AD      ld ix,level01gems           ; gems memory
 68+  A56D CD A2 A5         call screen_initobjects     ; draw gems
 69+  A570 CD 74 A5         call screen_setuptext       ; draws text on the screen
 70+  A573 C9               ret
 71+  A574
 72+  A574              ;
 73+  A574              ; Sets up text on the screen
 74+  A574              ;
 75+  A574              screen_setuptext:
 76+  A574 CD E4 B6         call scores_showtable
 77+  A577 CD FF A4         call screen_sethighscorecolours
 78+  A57A 21 4E 80         ld hl, string_score1
 79+  A57D CD A4 82         call string_print
 80+  A580 21 57 80         ld hl, string_scorenumbers1
 81+  A583 CD A4 82         call string_print
 82+  A586 21 60 80         ld hl, string_company
 83+  A589 CD A4 82         call string_print
 84+  A58C 21 75 80         ld hl, string_score2
 85+  A58F CD A4 82         call string_print
 86+  A592 21 7E 80         ld hl, string_scorenumbers2
 87+  A595 CD A4 82         call string_print
 88+  A598 21 6A 80         ld hl, string_credits
 89+  A59B CD A4 82         call string_print
 90+  A59E CD F3 A4         call screen_setscorecolours
 91+  A5A1 C9               ret
 92+  A5A2              ;
 93+  A5A2              ; Draw initial object positions
 94+  A5A2              ; Inputs:
 95+  A5A2              ; ix - memory location of objects
 96+  A5A2              ; a - graphic
 97+  A5A2              screen_initobjects:
 98+  A5A2 DD 4E 00         ld c,(ix)                   ; get the horiz coord
 99+  A5A5 79               ld a,c
100+  A5A6 FE FF            cp 255
101+  A5A8 CA D1 A5         jp z,screen_initobjects2
102+  A5AB DD 23            inc ix                      ; move to next
103+  A5AD DD 46 00         ld b,(ix)                   ; get the vert coord
104+  A5B0 DD 23            inc ix
105+  A5B2 CD E3 A5         call screen_getcellattradress ; get the memory address of b,c attr into de
106+  A5B5 D5               push de
107+  A5B6 3A F2 A4         ld a,(screen_tmp)                  ; get the block number back
108+  A5B9 CD 59 A6         call screen_getattr         ; get the memory location for this cell's attr into hl
109+  A5BC D1               pop de
110+  A5BD 7E               ld a,(hl)                   ; get the attr value at the address
111+  A5BE 12               ld (de),a                   ; load the attr into memory
112+  A5BF 3A F2 A4         ld a,(screen_tmp)                  ; get the block number back
113+  A5C2 CD 4E A6         call screen_getblock        ; get the block data into hl
114+  A5C5 CD 34 A6         call screen_showchar        ; show this character here
115+  A5C8
116+  A5C8              screen_initobjects1:
117+  A5C8 DD 23            inc ix                      ; move past state
118+  A5CA DD 23            inc ix
119+  A5CC DD 23            inc ix                      ; move past mem
120+  A5CE C3 A2 A5         jp screen_initobjects
121+  A5D1              screen_initobjects2:
122+  A5D1 C9               ret
123+  A5D2
124+  A5D2
125+  A5D2              ;
126+  A5D2              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
127+  A5D2              ; Inputs:
128+  A5D2              ; bc: coords
129+  A5D2              ; Outputs:
130+  A5D2              ; de: memory location
131+  A5D2              ;
132+  A5D2              screen_getcelladdress:
133+  A5D2 78               ld a,b      ; vertical position.
134+  A5D3 E6 18            and 24      ; which segment, 0, 1 or 2?
135+  A5D5 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
136+  A5D7 57               ld d,a      ; this is our high byte.
137+  A5D8 78               ld a,b      ; what was that vertical position again?
138+  A5D9 E6 07            and 7       ; which row within segment?
139+  A5DB 0F               rrca        ; multiply row by 32.
140+  A5DC 0F               rrca
141+  A5DD 0F               rrca
142+  A5DE 5F               ld e,a      ; low byte.
143+  A5DF 79               ld a,c      ; add on y coordinate.
144+  A5E0 83               add a,e     ; mix with low byte.
145+  A5E1 5F               ld e,a      ; address of screen position in de.
146+  A5E2 C9               ret
147+  A5E3
148+  A5E3              ;
149+  A5E3              ; Calculate buffer address of attribute for character at (b, c).
150+  A5E3              ; Inputs:
151+  A5E3              ; bc: coords
152+  A5E3              ; Outputs:
153+  A5E3              ; de: memory location
154+  A5E3              ;
155+  A5E3              screen_getcellattradress:
156+  A5E3 11 EC 9F         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
157+  A5E6 69               ld l,c      ; x position.
158+  A5E7 26 00            ld h,0      ; 0 h
159+  A5E9 19               add hl,de
160+  A5EA 54 5D            ld de,hl    ; horiz done
161+  A5EC 78               ld a,b      ; do vert
162+  A5ED D5               push de
163+  A5EE C5               push bc
164+  A5EF 11 20 00         ld de,32
165+  A5F2 CD 21 80         call utilities_multiply
166+  A5F5 C1               pop bc
167+  A5F6 D1               pop de
168+  A5F7 19               add hl,de
169+  A5F8 54 5D            ld de,hl    ; vert done
170+  A5FA C9               ret
171+  A5FB
172+  A5FB              ;
173+  A5FB              ; Calculate buffer address of attribute for character at (b, c).
174+  A5FB              ; Inputs:
175+  A5FB              ; bc: coords
176+  A5FB              ; Outputs:
177+  A5FB              ; de: memory location
178+  A5FB              ;
179+  A5FB              screen_getscreenattradress:
180+  A5FB 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
181+  A5FE 69               ld l,c      ; x position.
182+  A5FF 26 00            ld h,0      ; 0 h
183+  A601 19               add hl,de
184+  A602 54 5D            ld de,hl    ; horiz done
185+  A604 78               ld a,b      ; do vert
186+  A605 D5               push de
187+  A606 C5               push bc
188+  A607 11 20 00         ld de,32
189+  A60A CD 21 80         call utilities_multiply
190+  A60D C1               pop bc
191+  A60E D1               pop de
192+  A60F 19               add hl,de
193+  A610 54 5D            ld de,hl    ; vert done
194+  A612 C9               ret
195+  A613
196+  A613              ;
197+  A613              ; Gets the attr memory location for a screen coord
198+  A613              ; Will overwrite bc
199+  A613              ; Inputs:
200+  A613              ; bc - screen coords
201+  A613              ; Outputs:
202+  A613              ; de - memory location
203+  A613              ; bc - character coords
204+  A613              ;
205+  A613              screen_getattraddressfromscreencoords:
206+  A613 78               ld a,b                          ; get the player block coords of current block
207+  A614 E6 F8            and 248                         ; find closest multiple of eight
208+  A616 0F               rrca
209+  A617 0F               rrca
210+  A618 0F               rrca                ; divide by 8
211+  A619 47               ld b,a
212+  A61A 79               ld a,c
213+  A61B 48               ld c,b                         ; swap b and c
214+  A61C E6 F8            and 248
215+  A61E 0F               rrca
216+  A61F 0F               rrca
217+  A620 0F               rrca                ; divide by 8
218+  A621 47               ld b,a
219+  A622 CD E3 A5         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
220+  A625 C9               ret
221+  A626
222+  A626              ;
223+  A626              ; Get buffer address for a character at b,c - b vert
224+  A626              ; Buffer memory is stored as sequential block
225+  A626              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
226+  A626              ; Inputs:
227+  A626              ; bc - coords
228+  A626              ; Outputs:
229+  A626              ; de - memory location of first byte
230+  A626              screen_getbufferaddress:
231+  A626 21 EC 82         ld hl, buffer_buffer    ; first get screen buffer start
232+  A629 50               ld d,b                  ; then work out vertical offset
233+  A62A 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
234+  A62C 19               add hl,de               ; add to base
235+  A62D 59               ld e,c                  ; then add horizontal offset (c)
236+  A62E 16 00            ld d,0
237+  A630 19               add hl,de               ; add to base
238+  A631 54 5D            ld de,hl
239+  A633 C9               ret
240+  A634
241+  A634              ;
242+  A634              ; Display character hl at (b, c) to buffer.
243+  A634              ; Stored sequentially
244+  A634              ; Inputs:
245+  A634              ; hl: block address
246+  A634              ; bc: coords
247+  A634              ;
248+  A634              screen_showchar:
249+  A634 3E 00            ld a,0
250+  A636 E5               push hl
251+  A637 CD 26 A6         call screen_getbufferaddress ; get the current screen buffer pointer
252+  A63A E1               pop hl
253+  A63B 06 08            ld b,8              ; number of pixels high.
254+  A63D              screen_showchar0:
255+  A63D 7E               ld a,(hl)           ; source graphic.
256+  A63E 12               ld (de),a           ; transfer to screen.
257+  A63F 23               inc hl              ; next piece of data.
258+  A640 E5               push hl             ; store hl
259+  A641 62 6B            ld hl,de            ; put de in hl
260+  A643 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
261+  A645 16 00            ld d,0
262+  A647 19               add hl,de              ; add de to hl
263+  A648 54 5D            ld de,hl            ; load back to de
264+  A64A E1               pop hl              ; restore hl
265+  A64B
266+  A64B 10 F0            djnz screen_showchar0 ; repeat
267+  A64D C9               ret
268+  A64E
269+  A64E
270+  A64E              ;
271+  A64E              ; Get cell graphic.
272+  A64E              ; Inputs:
273+  A64E              ; a: block
274+  A64E              ; Outputs:
275+  A64E              ; hl: memory
276+  A64E              ;
277+  A64E              screen_getblock:
278+  A64E 07               rlca                        ; multiply block number by eight.
279+  A64F 07               rlca
280+  A650 07               rlca
281+  A651 5F               ld e,a                      ; displacement to graphic address.
282+  A652 16 00            ld d,0                      ; no high byte.
283+  A654 21 DF AD         ld hl,sprites               ; address of character blocks.
284+  A657 19               add hl,de                   ; point to block.
285+  A658 C9               ret
286+  A659
287+  A659              ;
288+  A659              ; Get cell attribute.
289+  A659              ; Inputs:
290+  A659              ; a: block
291+  A659              ; Outputs:
292+  A659              ; hl: memory
293+  A659              ;
294+  A659              screen_getattr:
295+  A659 5F               ld e,a                      ; displacement to attribute address.
296+  A65A 16 00            ld d,0                      ; no high byte.
297+  A65C 21 57 AE         ld hl,sprite_attrs          ; address of block attributes.
298+  A65F 19               add hl,de                   ; point to attribute.
299+  A660 C9               ret
300+  A661
# file closed: screen/screen.asm
 25   A661                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A661              ;
  2+  A661              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A661              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A661              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A661              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A661              ; routine takes care of all the shifting itself. This means that sprite
  7+  A661              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A661              ; space they would require in pre-shifted form.
  9+  A661              ; Inputs:
 10+  A661              ; hl - sprite data
 11+  A661              ; bc - screen coords
 12+  A661              ;
 13+  A661              sprites_drawsprite7:
 14+  A661 EE 07            xor 7               ; complement last 3 bits.
 15+  A663 3C               inc a               ; add one for luck!
 16+  A664              sprites_drawsprite3:
 17+  A664 CB 11            rl c                ; ...into middle byte...
 18+  A666 CB 12            rl d                ; ...and finally into left character cell.
 19+  A668 3D               dec a               ; count shifts we've done.
 20+  A669 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A66B                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A66B 79               ld a,c              ; left edge of image is currently in e.
 23+  A66C 4A               ld c,d              ; put right edge there instead.
 24+  A66D 57               ld d,a              ; and the left edge back into c.
 25+  A66E 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A670              sprites_drawsprite:
 27+  A670 ED 43 D5 A6      ld (dispx),bc       ; store coords in dispx for now.
 28+  A674 E5               push hl
 29+  A675 CD B3 A6         call sprites_scadd  ; calculate screen address.
 30+  A678 E1               pop hl
 31+  A679 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A67B              sprites_drawsprite1:
 33+  A67B 08               ex af,af'           ; store loop counter.
 34+  A67C D5               push de             ; store screen address.
 35+  A67D 4E               ld c,(hl)           ; first sprite graphic.
 36+  A67E 23               inc hl              ; increment poiinter to sprite data.
 37+  A67F 22 D7 A6         ld (sprtmp),hl      ; store it for later.
 38+  A682 16 00            ld d,0              ; blank right byte for now.
 39+  A684 78               ld a,b              ; b holds y position.
 40+  A685 E6 07            and 7               ; how are we straddling character cells?
 41+  A687 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A689 FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A68B 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A68D A7               and a               ; oops, carry flag is set so clear it.
 45+  A68E              sprites_drawsprite2:
 46+  A68E CB 19            rr c                ; rotate left byte right...
 47+  A690 CB 1A            rr d                ; ...into right byte.
 48+  A692 3D               dec a               ; one less shift to do.
 49+  A693 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A695              sprites_drawsprite0:
 51+  A695 E1               pop hl              ; pop screen address from stack.
 52+  A696 7E               ld a,(hl)           ; what's there already.
 53+  A697 A9               xor c               ; merge in image data.
 54+  A698 77               ld (hl),a           ; place onto screen.
 55+  A699 23               inc hl
 56+  A69A 7E               ld a,(hl)           ; what's already there.
 57+  A69B AA               xor d               ; right edge of sprite image data.
 58+  A69C 77               ld (hl),a           ; plonk it on screen.
 59+  A69D 3A D5 A6         ld a,(dispx)        ; vertical coordinate.
 60+  A6A0 3C               inc a               ; next line down.
 61+  A6A1 32 D5 A6         ld (dispx),a        ; store new position.
 62+  A6A4 2B               dec hl
 63+  A6A5 11 20 00         ld de,32            ; add 32 to get to the next row
 64+  A6A8 19               add hl,de           ; add 32
 65+  A6A9              sprites_drawsprite6:
 66+  A6A9 EB               ex de,hl            ; screen address in de.
 67+  A6AA 2A D7 A6         ld hl,(sprtmp)      ; restore graphic address.
 68+  A6AD 08               ex af,af'           ; restore loop counter.
 69+  A6AE 3D               dec a               ; decrement it.
 70+  A6AF C2 7B A6         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 71+  A6B2 C9               ret                 ; job done.
 72+  A6B3
 73+  A6B3              ;
 74+  A6B3              ; This routine returns a buffer address for (c, b) in de (c vert).
 75+  A6B3              ; For example: 0,0 will be at memory offset 0
 76+  A6B3              ; 1,0 (1 down) will be at memory offset 1
 77+  A6B3              ; 0,7 will be at memory offset 0
 78+  A6B3              ; 9,1 will be at memory offset 8+1
 79+  A6B3              ; 8,0 will be at memory offset 256
 80+  A6B3              ; 9,0 will be at memory offset 257
 81+  A6B3              ; Outputs:
 82+  A6B3              ; de - coords
 83+  A6B3              ;
 84+  A6B3              sprites_scadd:
 85+  A6B3 79               ld a,c               ; calculate vertical offset
 86+  A6B4 E6 F8            and 248             ;  to get nearest multiple of 8
 87+  A6B6 0F               rrca
 88+  A6B7 0F               rrca
 89+  A6B8 0F               rrca                ; divide by 8
 90+  A6B9 67               ld h,a
 91+  A6BA 78               ld a,b               ; calculate horizontal offset
 92+  A6BB E6 F8            and 248             ;  to get nearest multiple of 8
 93+  A6BD 0F               rrca
 94+  A6BE 0F               rrca
 95+  A6BF 0F               rrca                ; divide by 8
 96+  A6C0 6F               ld l,a
 97+  A6C1 C5               push bc             ; store the screen coords
 98+  A6C2 44 4D            ld bc,hl            ; load bc with the character coords
 99+  A6C4 CD 26 A6         call screen_getbufferaddress
100+  A6C7 C1               pop bc              ; get back screen coords, de is now memory of character
101+  A6C8 79               ld a,c              ; now add the vertical within the cell
102+  A6C9 E6 07            and 7
103+  A6CB 0F               rrca                ; multiply by 32.
104+  A6CC 0F               rrca
105+  A6CD 0F               rrca
106+  A6CE 6F               ld l,a
107+  A6CF 26 00            ld h,0
108+  A6D1 19               add hl,de
109+  A6D2 54 5D            ld de,hl
110+  A6D4 C9               ret
111+  A6D5
112+  A6D5 00           dispx   defb 0           ; general-use coordinates.
113+  A6D6 00           dispy   defb 0
114+  A6D7 00           sprtmp  defb 0           ; sprite temporary address.
115+  A6D8
# file closed: screen/sprites.asm
 26   A6D8                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  A6D8              ;
  2+  A6D8              ; Draws the title screen
  3+  A6D8              ;
  4+  A6D8              titlescreen_show:
  5+  A6D8 CD 4F A7         call titlescreen_init
  6+  A6DB CD F9 A6         call titlescreen_drawtitle
  7+  A6DE 3E FA            ld a,250                              ; wait for 200 frames
  8+  A6E0 CD 39 80         call utilities_waitforkey_forframes   ; wait for keypress
  9+  A6E3 7B               ld a,e
 10+  A6E4 FE 01            cp 1                                  ; was anything pressed?
 11+  A6E6 C8               ret z                                 ; end titlescreen if so
 12+  A6E7
 13+  A6E7 CD 65 A7         call titlescreen_alt_init             ; otherwise, draw alt screen
 14+  A6EA CD 15 A7         call titlescreen_alt_drawtitle
 15+  A6ED 3E FA            ld a,250                              ; wait for 200 frames
 16+  A6EF CD 39 80         call utilities_waitforkey_forframes   ; wait for keypress
 17+  A6F2 7B               ld a,e
 18+  A6F3 FE 01            cp 1                                  ; was anything pressed?
 19+  A6F5 C2 D8 A6         jp nz,titlescreen_show                ; start again if not
 20+  A6F8 C9               ret
 21+  A6F9
 22+  A6F9              ;
 23+  A6F9              ; Draws the iconic logo
 24+  A6F9              ;
 25+  A6F9              titlescreen_drawtitle:
 26+  A6F9 06 66            ld b,102              ; number of points
 27+  A6FB DD 21 75 A7      ld ix,titlescreen_logo_data
 28+  A6FF              titlescreen_drawtitle0:
 29+  A6FF C5               push bc
 30+  A700 DD 4E 00         ld c,(ix)                   ; got horiz
 31+  A703 DD 23            inc ix
 32+  A705 DD 46 00         ld b,(ix)                   ; got vert
 33+  A708 DD 23            inc ix
 34+  A70A CD FB A5         call screen_getscreenattradress ; memory in de
 35+  A70D 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 36+  A70E 3E 13            ld a,19
 37+  A710 12               ld (de),a
 38+  A711 C1               pop bc
 39+  A712 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 40+  A714 C9               ret
 41+  A715
 42+  A715              ;
 43+  A715              ; Draws the alternate title screen
 44+  A715              ;
 45+  A715              titlescreen_alt_drawtitle:
 46+  A715 21 A1 80         ld hl,string_alttitlescreen_1
 47+  A718 CD A4 82         call string_print
 48+  A71B 21 AD 80         ld hl,string_alttitlescreen_2
 49+  A71E CD A4 82         call string_print
 50+  A721 21 A8 81         ld hl,string_alttitlescreen_3
 51+  A724 CD A4 82         call string_print
 52+  A727 3E 43            ld a,67
 53+  A729 11 00 58         ld de,22528                         ; top row attrs here
 54+  A72C CD 48 A7         call titlescreen_alt_setcolours
 55+  A72F 3E 46            ld a,70
 56+  A731 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 57+  A734 CD 48 A7         call titlescreen_alt_setcolours
 58+  A737 3E 43            ld a,67
 59+  A739 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 60+  A73C CD 48 A7         call titlescreen_alt_setcolours
 61+  A73F 3E 42            ld a,66
 62+  A741 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 63+  A744 CD 48 A7         call titlescreen_alt_setcolours
 64+  A747 C9               ret
 65+  A748
 66+  A748              titlescreen_alt_setcolours:
 67+  A748 06 20            ld b,32
 68+  A74A              titlescreen_alt_setcolours0:
 69+  A74A 12               ld (de),a
 70+  A74B 13               inc de
 71+  A74C 10 FC            djnz titlescreen_alt_setcolours0
 72+  A74E C9               ret
 73+  A74F
 74+  A74F              ;
 75+  A74F              ; Initialises the screen
 76+  A74F              ;
 77+  A74F              titlescreen_init:
 78+  A74F              ; We want a black screen.
 79+  A74F CD 6B 0D         call $0D6B
 80+  A752 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 81+  A754                                      ; bright (64).
 82+  A754 32 8D 5C         ld (23693),a        ; set our screen colours.
 83+  A757 3E 01            ld a,1              ; 2 is the code for red.
 84+  A759 D3 FE            out (254),a         ; write to port 254.
 85+  A75B CD AF 0D         call 3503           ; ROM routine - clears screen, opens chan 2.
 86+  A75E
 87+  A75E 21 87 80         ld hl,string_titlescreen_copyright
 88+  A761 CD A4 82         call string_print
 89+  A764
 90+  A764 C9               ret
 91+  A765
 92+  A765              ;
 93+  A765              ; Initialises the screen
 94+  A765              ;
 95+  A765              titlescreen_alt_init:
 96+  A765              ; We want a black screen.
 97+  A765 CD 6B 0D         call $0D6B
 98+  A768 3E 47            ld a,71             ; white ink (7) on black paper (0),
 99+  A76A                                      ; bright (64).
100+  A76A 32 8D 5C         ld (23693),a        ; set our screen colours.
101+  A76D 3E 00            ld a,0              ; 2 is the code for red.
102+  A76F D3 FE            out (254),a         ; write to port 254.
103+  A771 CD AF 0D         call 3503           ; ROM routine - clears screen, opens chan 2.
104+  A774
105+  A774 C9               ret
106+  A775
107+  A775              ;
108+  A775              ; Horiz, vert
109+  A775              ;
110+  A775              titlescreen_logo_data:
111+  A775 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
111+  A779 0A 00 0C 00
111+  A77D 0F 00 11 00
111+  A781 12 00 13 00
112+  A785 09 01 0C 01      defb 9,1,12,1,15,1,17,1
112+  A789 0F 01 11 01
113+  A78D 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
113+  A791 0D 02 0E 02
113+  A795 0F 02 11 02
113+  A799 12 02 13 02
114+  A79D 09 03 0C 03      defb 9,3,12,3,15,3,17,3
114+  A7A1 0F 03 11 03
115+  A7A5 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
115+  A7A9 0F 04 11 04
115+  A7AD 12 04 13 04
116+  A7B1 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
116+  A7B5 02 06 03 06
116+  A7B9 04 06 05 06
116+  A7BD 06 06 07 06
116+  A7C1 08 06 09 06
116+  A7C5 0A 06 0B 06
117+  A7C9 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
117+  A7CD 12 06 13 06
117+  A7D1 14 06 15 06
117+  A7D5 16 06 17 06
117+  A7D9 18 06 19 06
117+  A7DD 1A 06 1B 06
118+  A7E1 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20
118+  A7E5 02 09 02 0A
118+  A7E9 02 0B 02 0C
118+  A7ED 02 0D 02 0E
118+  A7F1 02 0F 02 10
118+  A7F5 02 11 02 12
118+  A7F9 02 13 02 14
119+  A7FD 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20
119+  A801 19 09 19 0A
119+  A805 19 0B 19 0C
119+  A809 19 0D 19 0E
119+  A80D 19 0F 19 10
119+  A811 19 11 19 12
119+  A815 19 13 19 14
120+  A819 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
120+  A81D 05 0B 06 0B
120+  A821 07 0B 08 0B
120+  A825 09 0B 0A 0B
120+  A829 0B 0B
121+  A82B 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
121+  A82F 0B 09 0B 0A
122+  A833 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19,16,20
122+  A837 10 10 10 11
122+  A83B 10 12 10 13
122+  A83F 10 14
123+  A841
# file closed: screen/titlescreen.asm
 27   A841
 28   A841                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  A841              ; ###############################################################
  2+  A841              ; Data for level 1
  3+  A841              ; ###############################################################
  4+  A841              level01:
  5+  A841
  6+  A841                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  A841
  8+  A841 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  A845 05 05 05 05
  8+  A849 05 05 05 05
  8+  A84D 05 05 02 01
  8+  A851 01 01 03 05
  8+  A855 05 05 05 05
  8+  A859 05 05 05 05
  8+  A85D 05 05 00 00
  9+  A861 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  A865 05 05 05 05
  9+  A869 05 05 05 05
  9+  A86D 02 01 01 01
  9+  A871 01 01 01 01
  9+  A875 03 05 05 05
  9+  A879 05 05 05 05
  9+  A87D 05 05 00 00
 10+  A881 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  A885 05 05 05 05
 10+  A889 05 05 02 01
 10+  A88D 01 01 01 01
 10+  A891 01 01 01 01
 10+  A895 01 01 03 05
 10+  A899 0D 0D 0D 0D
 10+  A89D 0D 0D 00 00
 11+  A8A1 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  A8A5 01 01 00 01
 11+  A8A9 01 01 01 01
 11+  A8AD 01 01 01 01
 11+  A8B1 01 01 01 01
 11+  A8B5 01 01 01 03
 11+  A8B9 05 05 05 05
 11+  A8BD 05 05 00 00
 12+  A8C1 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  A8C5 04 04 04 04
 12+  A8C9 04 04 01 01
 12+  A8CD 01 01 01 01
 12+  A8D1 01 01 01 01
 12+  A8D5 01 01 01 01
 12+  A8D9 01 01 01 01
 12+  A8DD 00 01 00 00
 13+  A8E1 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  A8E5 04 04 04 04
 13+  A8E9 04 04 04 04
 13+  A8ED 01 01 01 01
 13+  A8F1 01 01 01 01
 13+  A8F5 01 01 01 01
 13+  A8F9 00 00 00 00
 13+  A8FD 00 01 00 00
 14+  A901 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  A905 04 01 01 01
 14+  A909 01 01 04 04
 14+  A90D 04 04 01 01
 14+  A911 01 01 01 01
 14+  A915 01 00 00 00
 14+  A919 00 01 01 01
 14+  A91D 01 01 00 00
 15+  A921 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  A925 04 04 04 04
 15+  A929 04 01 04 04
 15+  A92D 04 04 04 04
 15+  A931 04 04 00 00
 15+  A935 00 00 04 04
 15+  A939 04 04 04 04
 15+  A93D 04 01 00 00
 16+  A941 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  A945 01 04 01 01
 16+  A949 01 01 04 04
 16+  A94D 04 04 04 04
 16+  A951 04 04 00 04
 16+  A955 04 04 04 04
 16+  A959 04 04 04 04
 16+  A95D 04 01 00 00
 17+  A961 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  A965 00 00 00 00
 17+  A969 00 04 04 04
 17+  A96D 04 04 04 04
 17+  A971 04 04 00 04
 17+  A975 04 04 04 04
 17+  A979 04 04 04 04
 17+  A97D 04 01 00 00
 18+  A981 00 00 01 07      defb 00,00,01,07,07,07,07,07,07,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  A985 07 07 07 07
 18+  A989 07 01 04 04
 18+  A98D 04 04 04 04
 18+  A991 04 04 00 04
 18+  A995 04 04 04 04
 18+  A999 04 04 04 04
 18+  A99D 04 01 00 00
 19+  A9A1 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  A9A5 00 00 00 00
 19+  A9A9 00 01 04 04
 19+  A9AD 04 04 04 04
 19+  A9B1 04 04 00 04
 19+  A9B5 04 04 04 04
 19+  A9B9 04 00 00 00
 19+  A9BD 00 01 00 00
 20+  A9C1 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  A9C5 00 00 00 00
 20+  A9C9 00 01 04 04
 20+  A9CD 04 04 04 04
 20+  A9D1 04 04 00 04
 20+  A9D5 04 04 04 04
 20+  A9D9 04 00 04 04
 20+  A9DD 00 01 00 00
 21+  A9E1 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  A9E5 06 06 06 06
 21+  A9E9 06 01 04 04
 21+  A9ED 04 04 04 04
 21+  A9F1 04 04 00 04
 21+  A9F5 04 04 04 04
 21+  A9F9 04 00 04 04
 21+  A9FD 00 01 00 00
 22+  AA01 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  AA05 06 06 06 06
 22+  AA09 06 01 04 00
 22+  AA0D 00 00 00 00
 22+  AA11 00 00 00 00
 22+  AA15 00 00 00 00
 22+  AA19 00 00 04 04
 22+  AA1D 00 01 00 00
 23+  AA21 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  AA25 06 06 06 06
 23+  AA29 06 01 04 00
 23+  AA2D 04 04 04 04
 23+  AA31 04 04 00 04
 23+  AA35 04 04 00 04
 23+  AA39 04 04 04 04
 23+  AA3D 00 01 00 00
 24+  AA41 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  AA45 06 06 06 06
 24+  AA49 06 01 04 00
 24+  AA4D 04 04 04 04
 24+  AA51 04 04 00 04
 24+  AA55 04 04 00 04
 24+  AA59 04 04 04 04
 24+  AA5D 00 01 00 00
 25+  AA61 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  AA65 01 01 01 01
 25+  AA69 01 01 04 00
 25+  AA6D 04 04 04 04
 25+  AA71 04 04 00 04
 25+  AA75 04 04 00 04
 25+  AA79 04 04 04 04
 25+  AA7D 00 01 00 00
 26+  AA81 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  AA85 04 04 04 04
 26+  AA89 04 04 04 00
 26+  AA8D 04 04 04 04
 26+  AA91 04 04 00 04
 26+  AA95 04 04 00 00
 26+  AA99 00 00 04 04
 26+  AA9D 04 01 00 00
 27+  AAA1 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  AAA5 04 04 00 00
 27+  AAA9 00 00 00 00
 27+  AAAD 04 04 04 04
 27+  AAB1 04 04 00 04
 27+  AAB5 04 04 04 04
 27+  AAB9 04 00 04 04
 27+  AABD 04 01 00 00
 28+  AAC1 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  AAC5 04 04 00 04
 28+  AAC9 04 04 04 04
 28+  AACD 04 04 04 04
 28+  AAD1 04 04 00 04
 28+  AAD5 04 04 04 04
 28+  AAD9 04 00 04 04
 28+  AADD 04 01 00 00
 29+  AAE1 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  AAE5 04 04 00 04
 29+  AAE9 04 04 01 01
 29+  AAED 01 01 01 01
 29+  AAF1 01 01 01 01
 29+  AAF5 01 01 01 01
 29+  AAF9 04 00 04 04
 29+  AAFD 04 01 00 00
 30+  AB01 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  AB05 04 04 00 04
 30+  AB09 04 04 01 00
 30+  AB0D 00 00 00 00
 30+  AB11 00 00 00 00
 30+  AB15 00 00 00 01
 30+  AB19 04 00 04 04
 30+  AB1D 04 01 00 00
 31+  AB21 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  AB25 04 04 00 04
 31+  AB29 04 04 01 00
 31+  AB2D 00 00 00 00
 31+  AB31 00 00 00 00
 31+  AB35 00 00 00 01
 31+  AB39 04 00 04 04
 31+  AB3D 04 01 00 00
 32+  AB41 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  AB45 04 04 00 04
 32+  AB49 04 04 01 00
 32+  AB4D 00 00 00 00
 32+  AB51 00 00 00 00
 32+  AB55 00 00 00 01
 32+  AB59 04 00 04 04
 32+  AB5D 04 01 00 00
 33+  AB61 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  AB65 04 04 00 04
 33+  AB69 04 04 04 00
 33+  AB6D 00 00 00 00
 33+  AB71 00 00 00 00
 33+  AB75 00 00 00 04
 33+  AB79 04 04 04 04
 33+  AB7D 04 01 00 00
 34+  AB81 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  AB85 04 04 04 04
 34+  AB89 04 04 01 00
 34+  AB8D 00 00 00 00
 34+  AB91 00 00 00 00
 34+  AB95 00 00 00 01
 34+  AB99 04 04 04 04
 34+  AB9D 04 01 00 00
 35+  ABA1 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  ABA5 04 04 04 04
 35+  ABA9 04 04 01 00
 35+  ABAD 00 00 01 00
 35+  ABB1 00 00 00 01
 35+  ABB5 00 00 00 01
 35+  ABB9 04 04 04 04
 35+  ABBD 04 01 00 00
 36+  ABC1 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  ABC5 01 01 01 01
 36+  ABC9 01 01 01 01
 36+  ABCD 01 01 01 01
 36+  ABD1 01 01 01 01
 36+  ABD5 01 01 01 01
 36+  ABD9 01 01 01 01
 36+  ABDD 01 01 00 00
 37+  ABE1
 38+  ABE1              ; ###############################################################
 39+  ABE1              ; Object data: horiz, vert, state, memh, meml
 40+  ABE1              ; ###############################################################
 41+  ABE1              level01rocks:
 42+  ABE1 09 04 00 00      defb 9,4,0,0,0
 42+  ABE5 00
 43+  ABE6 0C 07 00 00      defb 12,7,0,0,0
 43+  ABEA 00
 44+  ABEB 10 07 00 00      defb 16,7,0,0,0
 44+  ABEF 00
 45+  ABF0 0B 08 00 00      defb 11,8,0,0,0
 45+  ABF4 00
 46+  ABF5 0A 0A 00 00      defb 10,10,0,0,0
 46+  ABF9 00
 47+  ABFA 0C 0A 00 00      defb 12,10,0,0,0
 47+  ABFE 00
 48+  ABFF 0D 09 00 00      defb 13,9,0,0,0
 48+  AC03 00
 49+  AC04 0E 08 00 00      defb 14,8,0,0,0
 49+  AC08 00
 50+  AC09 0F 0B 00 00      defb 15,11,0,0,0
 50+  AC0D 00
 51+  AC0E 0B 0C 00 00      defb 11,12,0,0,0
 51+  AC12 00
 52+  AC13 11 0C 00 00      defb 17,12,0,0,0
 52+  AC17 00
 53+  AC18 13 08 00 00      defb 19,8,0,0,0
 53+  AC1C 00
 54+  AC1D 16 09 00 00      defb 22,9,0,0,0
 54+  AC21 00
 55+  AC22 13 0A 00 00      defb 19,10,0,0,0
 55+  AC26 00
 56+  AC27 15 0A 00 00      defb 21,10,0,0,0
 56+  AC2B 00
 57+  AC2C 15 0C 00 00      defb 21,12,0,0,0
 57+  AC30 00
 58+  AC31 16 0C 00 00      defb 22,12,0,0,0
 58+  AC35 00
 59+  AC36 18 0A 00 00      defb 24,10,0,0,0
 59+  AC3A 00
 60+  AC3B 19 09 00 00      defb 25,9,0,0,0
 60+  AC3F 00
 61+  AC40 1C 09 00 00      defb 28,9,0,0,0
 61+  AC44 00
 62+  AC45 1B 0C 00 00      defb 27,12,0,0,0
 62+  AC49 00
 63+  AC4A 1A 0D 00 00      defb 26,13,0,0,0
 63+  AC4E 00
 64+  AC4F 19 0E 00 00      defb 25,14,0,0,0
 64+  AC53 00
 65+  AC54 19 10 00 00      defb 25,16,0,0,0
 65+  AC58 00
 66+  AC59 1A 11 00 00      defb 26,17,0,0,0
 66+  AC5D 00
 67+  AC5E 1B 11 00 00      defb 27,17,0,0,0
 67+  AC62 00
 68+  AC63 1C 12 00 00      defb 28,18,0,0,0
 68+  AC67 00
 69+  AC68 1A 13 00 00      defb 26,19,0,0,0
 69+  AC6C 00
 70+  AC6D 1B 15 00 00      defb 27,21,0,0,0
 70+  AC71 00
 71+  AC72 1A 17 00 00      defb 26,23,0,0,0
 71+  AC76 00
 72+  AC77 1B 18 00 00      defb 27,24,0,0,0
 72+  AC7B 00
 73+  AC7C 19 18 00 00      defb 25,24,0,0,0
 73+  AC80 00
 74+  AC81 18 17 00 00      defb 24,23,0,0,0
 74+  AC85 00
 75+  AC86 13 14 00 00      defb 19,20,0,0,0
 75+  AC8A 00
 76+  AC8B 14 12 00 00      defb 20,18,0,0,0
 76+  AC8F 00
 77+  AC90 14 10 00 00      defb 20,16,0,0,0
 77+  AC94 00
 78+  AC95 15 10 00 00      defb 21,16,0,0,0
 78+  AC99 00
 79+  AC9A 16 12 00 00      defb 22,18,0,0,0
 79+  AC9E 00
 80+  AC9F 11 14 00 00      defb 17,20,0,0,0
 80+  ACA3 00
 81+  ACA4 0D 11 00 00      defb 13,17,0,0,0
 81+  ACA8 00
 82+  ACA9 0C 13 00 00      defb 12,19,0,0,0
 82+  ACAD 00
 83+  ACAE 0B 13 00 00      defb 11,19,0,0,0
 83+  ACB2 00
 84+  ACB3 0A 11 00 00      defb 10,17,0,0,0
 84+  ACB7 00
 85+  ACB8 05 12 00 00      defb 5,18,0,0,0
 85+  ACBC 00
 86+  ACBD 07 16 00 00      defb 7,22,0,0,0
 86+  ACC1 00
 87+  ACC2 09 17 00 00      defb 9,23,0,0,0
 87+  ACC6 00
 88+  ACC7 07 18 00 00      defb 7,24,0,0,0
 88+  ACCB 00
 89+  ACCC 05 18 00 00      defb 5,24,0,0,0
 89+  ACD0 00
 90+  ACD1 06 19 00 00      defb 6,25,0,0,0
 90+  ACD5 00
 91+  ACD6 08 19 00 00      defb 8,25,0,0,0
 91+  ACDA 00
 92+  ACDB 04 17 00 00      defb 4,23,0,0,0
 92+  ACDF 00
 93+  ACE0 FF               defb 255
 94+  ACE1
 95+  ACE1              level01missiles:
 96+  ACE1 0B 17 00 00      defb 11,23,0,0,0
 96+  ACE5 00
 97+  ACE6 0B 16 00 00      defb 11,22,0,0,0
 97+  ACEA 00
 98+  ACEB 0C 17 00 00      defb 12,23,0,0,0
 98+  ACEF 00
 99+  ACF0 0C 16 00 00      defb 12,22,0,0,0
 99+  ACF4 00
100+  ACF5 0D 17 00 00      defb 13,23,0,0,0
100+  ACF9 00
101+  ACFA 0D 16 00 00      defb 13,22,0,0,0
101+  ACFE 00
102+  ACFF 0E 17 00 00      defb 14,23,0,0,0
102+  AD03 00
103+  AD04 0E 16 00 00      defb 14,22,0,0,0
103+  AD08 00
104+  AD09 0F 17 00 00      defb 15,23,0,0,0
104+  AD0D 00
105+  AD0E 0F 16 00 00      defb 15,22,0,0,0
105+  AD12 00
106+  AD13 10 17 00 00      defb 16,23,0,0,0
106+  AD17 00
107+  AD18 10 16 00 00      defb 16,22,0,0,0
107+  AD1C 00
108+  AD1D 11 17 00 00      defb 17,23,0,0,0
108+  AD21 00
109+  AD22 11 16 00 00      defb 17,22,0,0,0
109+  AD26 00
110+  AD27 12 17 00 00      defb 18,23,0,0,0
110+  AD2B 00
111+  AD2C 12 16 00 00      defb 18,22,0,0,0
111+  AD30 00
112+  AD31 13 17 00 00      defb 19,23,0,0,0
112+  AD35 00
113+  AD36 13 16 00 00      defb 19,22,0,0,0
113+  AD3A 00
114+  AD3B 14 17 00 00      defb 20,23,0,0,0
114+  AD3F 00
115+  AD40 14 16 00 00      defb 20,22,0,0,0
115+  AD44 00
116+  AD45 15 17 00 00      defb 21,23,0,0,0
116+  AD49 00
117+  AD4A 15 16 00 00      defb 21,22,0,0,0
117+  AD4E 00
118+  AD4F 16 17 00 00      defb 22,23,0,0,0
118+  AD53 00
119+  AD54 16 16 00 00      defb 22,22,0,0,0
119+  AD58 00
120+  AD59 FF               defb 255
121+  AD5A
122+  AD5A              level01diamonds:
123+  AD5A 0C 1B 00 00      defb 12,27,0,0,0
123+  AD5E 00
124+  AD5F 10 1B 00 00      defb 16,27,0,0,0
124+  AD63 00
125+  AD64 15 1B 00 00      defb 21,27,0,0,0
125+  AD68 00
126+  AD69 FF               defb 255
127+  AD6A
128+  AD6A              level01gems:
129+  AD6A 12 14 00 00      defb 18,20,0,0,0
129+  AD6E 00
130+  AD6F 06 18 00 00      defb 6,24,0,0,0
130+  AD73 00
131+  AD74 19 17 00 00      defb 25,23,0,0,0
131+  AD78 00
132+  AD79 1C 11 00 00      defb 28,17,0,0,0
132+  AD7D 00
133+  AD7E FF               defb 255
134+  AD7F              ;
135+  AD7F              ; Score area colours
136+  AD7F              ;
137+  AD7F              score_colours:
138+  AD7F 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
138+  AD83 47 47 47 47
138+  AD87 47 47 47 42
138+  AD8B 43 43 43 43
138+  AD8F 43 43 43 43
138+  AD93 42 47 47 47
138+  AD97 47 47 47 47
138+  AD9B 47 47 47 47
139+  AD9F 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
139+  ADA3 47 47 47 47
139+  ADA7 47 47 47 46
139+  ADAB 46 46 46 46
139+  ADAF 46 46 46 46
139+  ADB3 46 47 47 47
139+  ADB7 47 47 47 47
139+  ADBB 47 47 47 47
140+  ADBF
141+  ADBF              high_score_colours:
142+  ADBF 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
142+  ADC3 42 42 47 47
142+  ADC7 47 47 47 47
142+  ADCB 43 43 43 47
142+  ADCF 47 47 47 47
142+  ADD3 47 46 46 46
142+  ADD7 47 47 47 47
142+  ADDB 47 47 00 00
# file closed: leveldata/level01.asm
 29   ADDF                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  ADDF              ; Tiles graphics.
  2+  ADDF              sprites:
  3+  ADDF 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  ADE3 00 00 00 00
  4+  ADE7 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  ADEB FF FF FF FF
  5+  ADEF 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  ADF3 1F 3F 7F FF
  6+  ADF7 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  ADFB F8 FC FE FF
  7+  ADFF 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  AE03 55 AA 55 AA
  8+  AE07 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  AE0B 00 00 00 00
  9+  AE0F FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  AE13 FF FF FF FF
 10+  AE17 FF FF 00 00      defb    255,255,  0,  0,  0,  0,  0,  0   ; 7, trapdoor
 10+  AE1B 00 00 00 00
 11+  AE1F 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  AE23 F1 72 34 18
 12+  AE27 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  AE2B FE FE FF 7E
 13+  AE2F 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  AE33 FE FF 7E 3C
 14+  AE37 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  AE3B 00 00 FF FF
 15+  AE3F 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 12, missile
 15+  AE43 FF 7E 3C 18
 16+  AE47 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  AE4B 00 00 00 00
 17+  AE4F 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  AE53 00 3C 5A 34
 18+  AE57
 19+  AE57              sprite_attrs:
 20+  AE57 46               defb    070 ; 0, space
 21+  AE58 65               defb    101 ; 1, cyan block
 22+  AE59 4D               defb    077 ; 2, slope left
 23+  AE5A 4D               defb    077 ; 3, slope right
 24+  AE5B 46               defb    070 ; 4, dirt
 25+  AE5C 4E               defb    078 ; 5, sky
 26+  AE5D 4C               defb    076 ; 6, slime
 27+  AE5E 42               defb    066 ; 7, trapdoor
 28+  AE5F 46               defb    070 ; 8, diamond
 29+  AE60 42               defb    066 ; 9, rock
 30+  AE61 42               defb    066 ; 10, rock 2
 31+  AE62 49           	defb    073 ; 11, sky, trapdoor
 32+  AE63 43           	defb    067 ; 12, missile
 33+  AE64 4A               defb    074 ; 13, sky, red ink (tank)
 34+  AE65 46               defb    070 ; 14, gem
 35+  AE66
 36+  AE66              player_sprite:
 37+  AE66 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 37+  AE6A 38 3D C3 80
 38+  AE6E 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 38+  AE72 3C 1C 16 32
 39+  AE76 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 39+  AE7A 3C 38 68 4C
 40+  AE7E 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 40+  AE82 1C BC C3 01
 41+  AE86 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 41+  AE8A 3C 3C 64 0C
 42+  AE8E 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 42+  AE92 3C 3C 26 30
 43+  AE96 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 43+  AE9A 1E 5C FD 5F
 44+  AE9E 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 44+  AEA2 4F 8F 19 03
 45+  AEA6 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 45+  AEAA F2 F1 98 C0
 46+  AEAE FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 46+  AEB2 48 08 14 2A
 47+  AEB6
 48+  AEB6              ;
 49+  AEB6              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 50+  AEB6              ;
 51+  AEB6              ship_sprite:
 52+  AEB6 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 52+  AEBA 03 1F 7F FF
 53+  AEBE 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 53+  AEC2 FF FF FF FF
 54+  AEC6 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 54+  AECA FF FF FF FF
 55+  AECE 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 55+  AED2 C0 F8 FE FF
 56+  AED6 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 56+  AEDA 03 03 02 07
 57+  AEDE 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 57+  AEE2 FF 0F 07 83
 58+  AEE6 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 58+  AEEA FF 10 20 C1
 59+  AEEE 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 59+  AEF2 C0 C0 40 E0
 60+  AEF6 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 60+  AEFA 03 03 02 07
 61+  AEFE F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 61+  AF02 FF 08 04 83
 62+  AF06 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 62+  AF0A FF F0 E0 C1
 63+  AF0E CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 63+  AF12 C0 C0 40 E0
 64+  AF16
 65+  AF16              ;
 66+  AF16              ;  First 8 frames are tank, last frame is the gun barrel
 67+  AF16              ;
 68+  AF16              tank_sprite:
 69+  AF16 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 69+  AF1A 7F 00 00 00
 70+  AF1E 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 70+  AF22 FE FF 7F 40
 71+  AF26 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 71+  AF2A 03 FF FF 01
 72+  AF2E 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
 72+  AF32 E0 C0 00 00
 73+  AF36 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
 73+  AF3A F7 E1 7F 3F
 74+  AF3E FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
 74+  AF42 54 16 FF FF
 75+  AF46 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
 75+  AF4A 9B A8 FF FF
 76+  AF4E FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
 76+  AF52 9F AF FE FC
 77+  AF56 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0
 77+  AF5A 1F 00 00 00
# file closed: graphics/graphics.asm
 30   AF5E
 31   AF5E                  include "game\control.asm"
# file opened: game/control.asm
  1+  AF5E              ;
  2+  AF5E              ; Check the keyboard then move
  3+  AF5E              ;
  4+  AF5E              control_keyboard:
  5+  AF5E 3A 3E B3         ld a,(player+5)      ; first, check if the player has pixels left to move
  6+  AF61 FE 00            cp 0
  7+  AF63 CA 6A AF         jp z, control_keyboard5
  8+  AF66 CD 6F B0         call control_automove
  9+  AF69 C9               ret
 10+  AF6A              control_keyboard5:
 11+  AF6A 3A 3F B3         ld a,(player+6)      ; next, check if the player is digging
 12+  AF6D FE 00            cp 0
 13+  AF6F CA 76 AF         jp z, control_keyboard0
 14+  AF72 CD AD AF         call control_dig
 15+  AF75 C9               ret
 16+  AF76              control_keyboard0:
 17+  AF76 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 18+  AF79 ED 78            in a,(c)            ; read keyboard.
 19+  AF7B 47               ld b,a              ; store result in b register.
 20+  AF7C CB 18            rr b                ; check outermost key (q).
 21+  AF7E D2 9D AF         jp nc,control_keyboard1
 22+  AF81 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 23+  AF84 ED 78            in a,(c)            ; read keyboard.
 24+  AF86 47               ld b,a              ; store result in b register.
 25+  AF87 CB 18            rr b                ; check outermost key (a).
 26+  AF89 D2 A1 AF         jp nc,control_keyboard2
 27+  AF8C 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 28+  AF8F ED 78            in a,(c)            ; read keyboard.
 29+  AF91 47               ld b,a              ; store result in b register.
 30+  AF92 CB 18            rr b                ; check outermost key (p).
 31+  AF94 D2 A5 AF         jp nc,control_keyboard3
 32+  AF97 CB 18            rr b                ; check next key.
 33+  AF99 D2 A9 AF         jp nc,control_keyboard4
 34+  AF9C C9               ret
 35+  AF9D              control_keyboard1:
 36+  AF9D CD B8 B0         call control_pl_moveup         ; player up.
 37+  AFA0 C9               ret
 38+  AFA1              control_keyboard2:
 39+  AFA1 CD E7 B0         call control_pl_movedown       ; player down.
 40+  AFA4 C9               ret
 41+  AFA5              control_keyboard3:
 42+  AFA5 CD 44 B1         call control_pl_moveright       ; player left.
 43+  AFA8 C9               ret
 44+  AFA9              control_keyboard4:
 45+  AFA9 CD 14 B1         call control_pl_moveleft       ; player right.
 46+  AFAC C9               ret
 47+  AFAD
 48+  AFAD              ;
 49+  AFAD              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 50+  AFAD              ;
 51+  AFAD              control_dig:
 52+  AFAD ED 4B 39 B3      ld bc,(player)      ; load the current coords into bc
 53+  AFB1 C5               push bc
 54+  AFB2 3A 3B B3         ld a,(player+2)     ; get the direction
 55+  AFB5 FE 01            cp 1                ; left
 56+  AFB7 CA CF AF         jp z,control_dig0
 57+  AFBA FE 02            cp 2                ; right
 58+  AFBC CA E4 AF         jp z,control_dig1
 59+  AFBF FE 03            cp 3                ; down
 60+  AFC1 CA 08 B0         jp z,control_dig5
 61+  AFC4 FE 00            cp 0                ; up
 62+  AFC6 CA F8 AF         jp z,control_dig4
 63+  AFC9 21 3F B3         ld hl,player+6
 64+  AFCC 36 00            ld (hl),0           ; turn off digging
 65+  AFCE C9               ret                 ; return
 66+  AFCF              control_dig0:           ; going left
 67+  AFCF CD B3 A6         call sprites_scadd  ; get the current coord
 68+  AFD2 62 6B            ld hl,de
 69+  AFD4 2B               dec hl              ; move one left
 70+  AFD5 C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
 71+  AFD6 78               ld a,b
 72+  AFD7 06 08            ld b,8
 73+  AFD9 90               sub b
 74+  AFDA 47               ld b,a
 75+  AFDB 79               ld a,c
 76+  AFDC 0E 08            ld c,8
 77+  AFDE 91               sub c
 78+  AFDF 4F               ld c,a
 79+  AFE0 C5               push bc
 80+  AFE1 C3 11 B0         jp control_dig2
 81+  AFE4              control_dig1:
 82+  AFE4 CD B3 A6         call sprites_scadd  ; get the current coord
 83+  AFE7 62 6B            ld hl,de
 84+  AFE9 23               inc hl              ; move one right
 85+  AFEA C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
 86+  AFEB 3E 08            ld a,8
 87+  AFED 80               add a,b
 88+  AFEE 47               ld b,a
 89+  AFEF 79               ld a,c
 90+  AFF0 0E 08            ld c,8
 91+  AFF2 91               sub c
 92+  AFF3 4F               ld c,a
 93+  AFF4 C5               push bc
 94+  AFF5 C3 11 B0         jp control_dig2
 95+  AFF8              control_dig4:
 96+  AFF8 CD B3 A6         call sprites_scadd  ; get the current coord
 97+  AFFB 62 6B            ld hl,de
 98+  AFFD 11 20 00         ld de,32
 99+  B000 ED 52            sbc hl,de             ; move one up
100+  B002 C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
101+  B003 0D               dec c
102+  B004 C5               push bc
103+  B005 C3 29 B0         jp control_dig6
104+  B008              control_dig5:
105+  B008 CD B3 A6         call sprites_scadd  ; get the current coord
106+  B00B 62 6B            ld hl,de
107+  B00D 24               inc h              ; move one down
108+  B00E                                     ; not bothered about working out bc here, since rock will never fall if digging down
109+  B00E C3 11 B0         jp control_dig2
110+  B011              ; Normal (not up) digging
111+  B011              control_dig2:
112+  B011 3A 41 B3         ld a,(player+8)     ; get the number of rows we need to overwrite
113+  B014 47               ld b,a              ; rows to copy over
114+  B015 E5               push hl             ; store the memory location of the first row for later
115+  B016              control_dig3:
116+  B016 CD 58 B0         call control_getpixelrow
117+  B019 77               ld (hl),a           ; load contents into row
118+  B01A 11 20 00         ld de,32
119+  B01D 19               add hl,de           ; move to next row
120+  B01E 10 F6            djnz control_dig3
121+  B020 E1               pop hl              ; get the original memory location back
122+  B021 11 20 00         ld de,32
123+  B024 ED 52            sbc hl,de           ; move to above row, ready for checking for rock
124+  B026 C3 3F B0         jp control_dig10
125+  B029              ; Special case for going up
126+  B029              control_dig6:
127+  B029 3A 41 B3         ld a,(player+8)     ; get the number of rows we need to overwrite
128+  B02C 47               ld b,a              ; rows to copy over
129+  B02D              control_dig7:
130+  B02D CD 58 B0         call control_getpixelrow
131+  B030              control_dig12:
132+  B030 77               ld (hl),a           ; load empty into row
133+  B031 11 20 00         ld de,32
134+  B034 ED 52            sbc hl,de           ; move up to next row
135+  B036 0D               dec c               ; decrease c to track rows
136+  B037 10 F4            djnz control_dig7
137+  B039 79               ld a,c
138+  B03A D6 07            sub 7
139+  B03C C1               pop bc
140+  B03D 4F               ld c,a
141+  B03E C5               push bc             ; store the decreased c coord
142+  B03F              control_dig10:
143+  B03F DD 21 40 B3      ld ix,player+7
144+  B043 DD 7E 00         ld a,(ix)     ; get the dig frame number
145+  B046 3D               dec a
146+  B047 DD 77 00         ld (ix),a
147+  B04A                  ; call the check for rocks above the removed dirt
148+  B04A DD 21 3F B3      ld ix,player+6
149+  B04E DD 7E 00         ld a,(ix)     ; get the dig state
150+  B051 FE 00            cp 0
151+  B053 C1               pop bc
152+  B054 CC 7A B5         call z, rocks_checkforfalling ; make the check if we're no longer digging
153+  B057 C9               ret
154+  B058
155+  B058              ;
156+  B058              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
157+  B058              ; Inputs:
158+  B058              ; hl - memory of pixel row
159+  B058              ; Outputs:
160+  B058              ; a - modified row to write
161+  B058              ;
162+  B058              control_getpixelrow:
163+  B058 3A 40 B3         ld a,(player+7)     ; get the dig frame number
164+  B05B FE 00            cp 0                ; is this the last dig
165+  B05D CA 64 B0         jp z,control_getpixelrow1
166+  B060 7E               ld a,(hl)           ; if not, xor with 255 to flip it
167+  B061 EE FF            xor 255
168+  B063 C9               ret
169+  B064              control_getpixelrow1:
170+  B064 DD 21 3F B3      ld ix,player+6
171+  B068 DD 36 00 00      ld (ix),0           ; turn off digging
172+  B06C 3E 00            ld a,0              ; if it is, load with empty
173+  B06E C9               ret
174+  B06F
175+  B06F              ;
176+  B06F              ; Auto move the player until pixels is zero
177+  B06F              ;
178+  B06F              control_automove:
179+  B06F 5F               ld e,a              ; store the number of pixels left to move in e
180+  B070 ED 4B 39 B3      ld bc,(player)      ; load the current coords into bc
181+  B074 21 3B B3         ld hl,player+2      ; get the direction
182+  B077 7E               ld a,(hl)
183+  B078 FE 03            cp 3                ; down
184+  B07A CA 8E B0         jp z,control_automove3  ; don't need to do anything
185+  B07D FE 00            cp 0                ; going up
186+  B07F CA 9A B0         jp z,control_automove2
187+  B082 FE 01            cp 1                ; going left?
188+  B084 CA A6 B0         jp z,control_automove0
189+  B087 78               ld a,b
190+  B088 3C               inc a               ; if we're going right, increment a twice for two pixels
191+  B089 3C               inc a
192+  B08A 47               ld b,a
193+  B08B C3 AA B0         jp control_automove1
194+  B08E              control_automove3:
195+  B08E 79               ld a,c
196+  B08F 3C               inc a
197+  B090 3C               inc a               ; if we're going down, increment twice
198+  B091 4F               ld c,a
199+  B092 FE 90            cp 144
200+  B094 CC 72 B1         call z, control_scroll_down
201+  B097 C3 AA B0         jp control_automove1
202+  B09A              control_automove2:
203+  B09A 79               ld a,c
204+  B09B 3D               dec a
205+  B09C 3D               dec a               ; if we're going up, decrement twice
206+  B09D 4F               ld c,a
207+  B09E FE 60            cp 96
208+  B0A0 CC 7F B1         call z, control_scroll_up
209+  B0A3 C3 AA B0         jp control_automove1
210+  B0A6              control_automove0:
211+  B0A6 78               ld a,b
212+  B0A7 3D               dec a               ; if we're going left, decrement a twice
213+  B0A8 3D               dec a
214+  B0A9 47               ld b,a
215+  B0AA              control_automove1:
216+  B0AA ED 43 39 B3      ld (player),bc      ; and back to player
217+  B0AE 7B               ld a,e              ; now get the pixel count back
218+  B0AF 3D               dec a               ; decrease by one
219+  B0B0 21 3E B3         ld hl,player+5
220+  B0B3 77               ld (hl),a           ; copy back
221+  B0B4 CD 7F B3         call player_justmoved
222+  B0B7 C9               ret
223+  B0B8
224+  B0B8              ;
225+  B0B8              ; Moves the player up
226+  B0B8              ;
227+  B0B8              control_pl_moveup:
228+  B0B8 C5               push bc
229+  B0B9 ED 4B 39 B3      ld bc,(player)          ; get the current coords, b horiz, c vert
230+  B0BD 79               ld a,c                  ; load c into the acc
231+  B0BE FE 18            cp 24
232+  B0C0 CA E0 B0         jp z,control_pl_moveup0 ; are we at the edge of the screen
233+  B0C3 FE 60            cp 96
234+  B0C5 CC 7F B1         call z, control_scroll_up
235+  B0C8 CD AA B2         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
236+  B0CB F5               push af
237+  B0CC 7B               ld a,e                  ; put e in a
238+  B0CD FE 00            cp 0
239+  B0CF CA DF B0         jp z,control_pl_moveup1 ; don't move if we can't
240+  B0D2 F1               pop af
241+  B0D3 D6 01            sub 1                   ; subtract 1
242+  B0D5 D6 01            sub 1                   ; subtract 1
243+  B0D7 4F               ld c,a                  ; load back to c
244+  B0D8 ED 43 39 B3      ld (player),bc          ; load back to player
245+  B0DC C3 E0 B0         jp control_pl_moveup0
246+  B0DF              control_pl_moveup1:
247+  B0DF F1               pop af                  ; restore af if needed
248+  B0E0              control_pl_moveup0:
249+  B0E0 3E 00            ld a,0
250+  B0E2 32 3B B3         ld (player+2),a        ; set direction to up
251+  B0E5 C1               pop bc
252+  B0E6 C9               ret
253+  B0E7              ;
254+  B0E7              ; Moves the player down
255+  B0E7              ;
256+  B0E7              control_pl_movedown:
257+  B0E7 C5               push bc
258+  B0E8 ED 4B 39 B3      ld bc,(player)          ; get the current coords, b horiz, c vert
259+  B0EC 79               ld a,c                  ; load c into the acc
260+  B0ED FE E0            cp 224
261+  B0EF CA 0D B1         jp z,control_pl_movedown0 ; are we at the edge of the screen
262+  B0F2 FE 80            cp 128
263+  B0F4 CC 72 B1         call z, control_scroll_down
264+  B0F7 CD 82 B2         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
265+  B0FA F5               push af
266+  B0FB 7B               ld a,e                  ; put e in a
267+  B0FC FE 00            cp 0
268+  B0FE CA 0C B1         jp z,control_pl_movedown1 ; don't move if we can't
269+  B101 F1               pop af
270+  B102 3C               inc a                   ; add 1
271+  B103 3C               inc a                   ; add 1
272+  B104 4F               ld c,a                  ; load back to c
273+  B105 ED 43 39 B3      ld (player),bc          ; load back to player
274+  B109 C3 0D B1         jp control_pl_movedown0
275+  B10C              control_pl_movedown1:
276+  B10C F1               pop af                  ; restore af if needed
277+  B10D              control_pl_movedown0:
278+  B10D 3E 03            ld a,3
279+  B10F 32 3B B3         ld (player+2),a        ; set direction to down
280+  B112 C1               pop bc
281+  B113 C9               ret
282+  B114              ;
283+  B114              ; Moves the player left
284+  B114              ;
285+  B114              control_pl_moveleft:
286+  B114 C5               push bc
287+  B115 ED 4B 39 B3      ld bc,(player)          ; get the current coords, b horiz, c vert
288+  B119 78               ld a,b                  ; load b into the acc
289+  B11A FE 10            cp 16
290+  B11C CA 3D B1         jp z,control_pl_moveleft0 ; are we at the edge of the screen
291+  B11F CD 04 B3         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
292+  B122 F5               push af
293+  B123 7B               ld a,e                  ; put e in a
294+  B124 FE 00            cp 0
295+  B126 CA 3C B1         jp z,control_pl_moveleft1 ; don't move if we can't
296+  B129 21 3E B3         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
297+  B12C 3E 03            ld a,3
298+  B12E 77               ld (hl),a
299+  B12F F1               pop af
300+  B130 D6 01            sub 1                    ; subtract 2
301+  B132 D6 01            sub 1
302+  B134 47               ld b,a                  ; load back to c
303+  B135 ED 43 39 B3      ld (player),bc          ; load back to player
304+  B139 C3 3D B1         jp control_pl_moveleft0
305+  B13C              control_pl_moveleft1:
306+  B13C F1               pop af
307+  B13D              control_pl_moveleft0:
308+  B13D 3E 01            ld a,1
309+  B13F 32 3B B3         ld (player+2),a        ; set direction to left
310+  B142 C1               pop bc
311+  B143 C9               ret
312+  B144              ;
313+  B144              ; Moves the player right
314+  B144              ;
315+  B144              control_pl_moveright:
316+  B144 C5               push bc
317+  B145 ED 4B 39 B3      ld bc,(player)          ; get the current coords, b horiz, c vert
318+  B149 78               ld a,b                  ; load b into the acc
319+  B14A FE F0            cp 240
320+  B14C CA 6B B1         jp z,control_pl_moveright0 ; are we at the edge of the screen
321+  B14F CD DC B2         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
322+  B152 F5               push af
323+  B153 7B               ld a,e                  ; put e in a
324+  B154 FE 00            cp 0
325+  B156 CA 6A B1         jp z,control_pl_moveright1 ; don't move if we can't
326+  B159 21 3E B3         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
327+  B15C 3E 03            ld a,3
328+  B15E 77               ld (hl),a
329+  B15F F1               pop af
330+  B160 3C               inc a                   ; add 2
331+  B161 3C               inc a
332+  B162 47               ld b,a                  ; load back to b
333+  B163 ED 43 39 B3      ld (player),bc          ; load back to player
334+  B167 C3 6B B1         jp control_pl_moveright0
335+  B16A              control_pl_moveright1:
336+  B16A F1               pop af                  ; restore af if needed
337+  B16B              control_pl_moveright0:
338+  B16B 3E 02            ld a,2
339+  B16D 32 3B B3         ld (player+2),a        ; set direction to right
340+  B170 C1               pop bc
341+  B171 C9               ret
342+  B172
343+  B172              ;
344+  B172              ; Scrolls the screen down
345+  B172              ;
346+  B172              control_scroll_down:
347+  B172 F5               push af
348+  B173 3E 08            ld a,8
349+  B175 32 F1 A4         ld (screen_offset),a
350+  B178 F1               pop af
351+  B179 21 A3 A3         ld hl,buffer_updateall
352+  B17C 36 01            ld (hl),1         ; flag as screen needing update
353+  B17E C9               ret
354+  B17F
355+  B17F              ;
356+  B17F              ; Scrolls the screen up
357+  B17F              ;
358+  B17F              control_scroll_up:
359+  B17F F5               push af
360+  B180 3E 00            ld a,0
361+  B182 32 F1 A4         ld (screen_offset),a
362+  B185 F1               pop af
363+  B186 21 A3 A3         ld hl,buffer_updateall
364+  B189 36 01            ld (hl),1         ; flag as screen needing update
365+  B18B C9               ret
366+  B18C
367+  B18C
368+  B18C
369+  B18C
# file closed: game/control.asm
 32   B18C                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  B18C              ;
  2+  B18C              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  3+  B18C              ; Inputs:
  4+  B18C              ; hl - memory location of top pixel row
  5+  B18C              ; bc - screen coords, b horiz, c vert
  6+  B18C              ; Outputs:
  7+  B18C              ; e - 0 if not empty, 1 if empty
  8+  B18C              ;
  9+  B18C              movement_spaceisempty:
 10+  B18C 3E 08            ld a,8                          ; 8 rows to check
 11+  B18E              movement_spaceisempty0:
 12+  B18E 08               ex af,af'                       ; store the loop counter
 13+  B18F 7E               ld a,(hl)                       ; get current pixel row
 14+  B190 FE 00            cp 0
 15+  B192 C2 A6 B1         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 16+  B195 79               ld a,c                          ; load the vertical coord
 17+  B196 3C               inc a                           ; next row down
 18+  B197 11 20 00         ld de,32
 19+  B19A 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 20+  B19B 4F               ld c,a                          ; copy vert coord back to c
 21+  B19C 08               ex af,af'                       ; get loop counter back
 22+  B19D 3D               dec a                           ; decrease loop counter
 23+  B19E C2 8E B1         jp nz, movement_spaceisempty0
 24+  B1A1 16 00            ld d,0
 25+  B1A3 1E 01            ld e,1                          ; got to end, so space is empty
 26+  B1A5 C9               ret
 27+  B1A6              movement_spaceisempty1:
 28+  B1A6 16 00            ld d,0
 29+  B1A8 1E 00            ld e,0                          ; returning false, ie space not empty
 30+  B1AA C9               ret
 31+  B1AB
 32+  B1AB              ;
 33+  B1AB              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
 34+  B1AB              ; Inputs:
 35+  B1AB              ; hl - memory location of top pixel row
 36+  B1AB              ; bc - screen coords, b horiz, c vert
 37+  B1AB              ; Outputs:
 38+  B1AB              ; e - 0 if not empty, 1 if empty
 39+  B1AB              ;
 40+  B1AB              movement_linebelowisempty:
 41+  B1AB 7E               ld a,(hl)                       ; get current pixel row
 42+  B1AC FE 00            cp 0
 43+  B1AE C2 B6 B1         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
 44+  B1B1 16 00            ld d,0
 45+  B1B3 1E 01            ld e,1                          ; got to end, so space is empty
 46+  B1B5 C9               ret
 47+  B1B6              movement_linebelowisempty1:
 48+  B1B6 16 00            ld d,0
 49+  B1B8 1E 00            ld e,0                          ; returning false, ie space not empty
 50+  B1BA C9               ret
 51+  B1BB
 52+  B1BB              ;
 53+  B1BB              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
 54+  B1BB              ; Inputs:
 55+  B1BB              ; hl - memory location of top pixel row
 56+  B1BB              ; bc - screen coords, b horiz, c vert
 57+  B1BB              ; Outputs:
 58+  B1BB              ; e - 0 if not empty, 1 if empty
 59+  B1BB              ;
 60+  B1BB              movement_lineaboveisempty:
 61+  B1BB 7E               ld a,(hl)                       ; get current pixel row
 62+  B1BC FE 00            cp 0
 63+  B1BE C2 C6 B1         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
 64+  B1C1 16 00            ld d,0
 65+  B1C3 1E 01            ld e,1                          ; got to end, so space is empty
 66+  B1C5 C9               ret
 67+  B1C6              movement_lineaboveisempty1:
 68+  B1C6 16 00            ld d,0
 69+  B1C8 1E 00            ld e,0                          ; returning false, ie space not empty
 70+  B1CA C9               ret
 71+  B1CB
 72+  B1CB              ;
 73+  B1CB              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
 74+  B1CB              ; Inputs:
 75+  B1CB              ; hl - memory location of top pixel row
 76+  B1CB              ; bc - screen coords, b horiz, c vert
 77+  B1CB              ; Outputs:
 78+  B1CB              ; none - puts player into digging mode
 79+  B1CB              ;
 80+  B1CB              movement_spaceisdiggable:
 81+  B1CB 3E 08            ld a,8                          ; 8 rows to check
 82+  B1CD              movement_spaceisdiggable0:
 83+  B1CD 08               ex af,af'                       ; store the loop counter
 84+  B1CE 7E               ld a,(hl)                       ; get current pixel row
 85+  B1CF FE 00            cp 0
 86+  B1D1 CA E1 B1         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
 87+  B1D4 FE 55            cp 85
 88+  B1D6 CA E1 B1         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
 89+  B1D9 FE AA            cp 170
 90+  B1DB CA E1 B1         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
 91+  B1DE C3 F9 B1         jp movement_spaceisdiggable1     ; otherwise, stop checking
 92+  B1E1              movement_spaceisdiggable2:
 93+  B1E1 79               ld a,c                          ; load the vertical coord
 94+  B1E2 3C               inc a                           ; next row down
 95+  B1E3 11 20 00         ld de,32
 96+  B1E6 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 97+  B1E7 4F               ld c,a                          ; copy vert coord back to c
 98+  B1E8 08               ex af,af'                       ; get loop counter back
 99+  B1E9 3D               dec a                           ; decrease loop counter
100+  B1EA C2 CD B1         jp nz, movement_spaceisdiggable0
101+  B1ED 21 3F B3         ld hl,player+6
102+  B1F0 36 01            ld (hl),1                       ; set the player into digging mode
103+  B1F2 23               inc hl
104+  B1F3 36 05            ld (hl),5                      ; set the number of frame to dig for
105+  B1F5 23               inc hl
106+  B1F6 36 08            ld (hl),8                       ; set the number of pixels to dig
107+  B1F8 C9               ret
108+  B1F9              movement_spaceisdiggable1:
109+  B1F9 21 3F B3         ld hl,player+6
110+  B1FC 36 00            ld (hl),0                       ; set the player out of digging mode
111+  B1FE C9               ret
112+  B1FF
113+  B1FF              ;
114+  B1FF              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
115+  B1FF              ; Inputs:
116+  B1FF              ; hl - memory location of top pixel row
117+  B1FF              ; bc - screen coords, b horiz, c vert
118+  B1FF              ; Outputs:
119+  B1FF              ; none - puts player into digging mode
120+  B1FF              ;
121+  B1FF              movement_spacebelowisdiggable:
122+  B1FF 7E               ld a,(hl)                       ; get first pixel row
123+  B200 FE 55            cp 85
124+  B202 CA 0D B2         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
125+  B205 FE AA            cp 170
126+  B207 CA 0D B2         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
127+  B20A C3 F9 B1         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
128+  B20D              movement_spacebelowisdiggable3:
129+  B20D 3E 08            ld a,8                          ; rows to check
130+  B20F 1E 00            ld e,0                          ; count of rows to dig
131+  B211              movement_spacebelowisdiggable0:
132+  B211 08               ex af,af'                       ; store the loop counter
133+  B212 7E               ld a,(hl)                       ; get current pixel row
134+  B213 FE 55            cp 85
135+  B215 CA 20 B2         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
136+  B218 FE AA            cp 170
137+  B21A CA 20 B2         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
138+  B21D C3 2F B2         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
139+  B220              movement_spacebelowisdiggable4:
140+  B220 1C               inc e                           ; inc count of rows to dig
141+  B221              movement_spacebelowisdiggable2:
142+  B221 79               ld a,c                          ; load the vertical coord
143+  B222 3C               inc a                           ; next row down
144+  B223 D5               push de                         ; need e for later
145+  B224 11 20 00         ld de,32
146+  B227 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
147+  B228 4F               ld c,a                          ; copy vert coord back to c
148+  B229 D1               pop de                          ; get e back
149+  B22A 08               ex af,af'                       ; get loop counter back
150+  B22B 3D               dec a                           ; incease loop counter
151+  B22C C2 11 B2         jp nz, movement_spacebelowisdiggable0
152+  B22F              movement_spacebelowisdiggable5:
153+  B22F 21 3F B3         ld hl,player+6
154+  B232 36 01            ld (hl),1                       ; set the player into digging mode
155+  B234 23               inc hl
156+  B235 36 03            ld (hl),3                      ; set the number of frame to dig for
157+  B237 23               inc hl
158+  B238 73               ld (hl),e                       ; set the number of pixels to dig
159+  B239 C9               ret
160+  B23A              movement_spacebelowisdiggable1:
161+  B23A 21 3F B3         ld hl,player+6
162+  B23D 36 00            ld (hl),0                       ; set the player out of digging mode
163+  B23F C9               ret
164+  B240
165+  B240              ;
166+  B240              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
167+  B240              ; Inputs:
168+  B240              ; hl - memory location of top pixel row
169+  B240              ; bc - screen coords, b horiz, c vert
170+  B240              ; Outputs:
171+  B240              ; none - puts player into digging mode
172+  B240              ;
173+  B240              movement_spaceaboveisdiggable:
174+  B240 7E               ld a,(hl)                       ; get first pixel row
175+  B241 FE 55            cp 85
176+  B243 CA 4E B2         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
177+  B246 FE AA            cp 170
178+  B248 CA 4E B2         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
179+  B24B C3 F9 B1         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
180+  B24E              movement_spaceaboveisdiggable3:
181+  B24E 3E 08            ld a,8                          ; rows to check
182+  B250 1E 00            ld e,0                          ; count of rows to dig
183+  B252              movement_spaceaboveisdiggable0:
184+  B252 08               ex af,af'                       ; store the loop counter
185+  B253 7E               ld a,(hl)                       ; get current pixel row
186+  B254 FE 55            cp 85
187+  B256 CA 61 B2         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
188+  B259 FE AA            cp 170
189+  B25B CA 61 B2         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
190+  B25E C3 71 B2         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
191+  B261              movement_spaceaboveisdiggable4:
192+  B261 1C               inc e                           ; inc count of rows to dig
193+  B262              movement_spaceaboveisdiggable2:
194+  B262 79               ld a,c                          ; load the vertical coord
195+  B263 3D               dec a                           ; next row up
196+  B264 D5               push de                         ; need e for later
197+  B265 11 20 00         ld de,32
198+  B268 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
199+  B26A 4F               ld c,a                          ; copy vert coord back to c
200+  B26B D1               pop de                          ; get e back
201+  B26C 08               ex af,af'                       ; get loop counter back
202+  B26D 3D               dec a                           ; incease loop counter
203+  B26E C2 52 B2         jp nz, movement_spaceaboveisdiggable0
204+  B271              movement_spaceaboveisdiggable5:
205+  B271 21 3F B3         ld hl,player+6
206+  B274 36 01            ld (hl),1                       ; set the player into digging mode
207+  B276 23               inc hl
208+  B277 36 05            ld (hl),5                       ; set the number of frame to dig for
209+  B279 23               inc hl
210+  B27A 73               ld (hl),e                       ; set the number of pixels to dig
211+  B27B C9               ret
212+  B27C              movement_spaceaboveisdiggable1:
213+  B27C 21 3F B3         ld hl,player+6
214+  B27F 36 00            ld (hl),0                       ; set the player out of digging mode
215+  B281 C9               ret
216+  B282
217+  B282              ;
218+  B282              ; Checks if the player can move down
219+  B282              ; Inputs:
220+  B282              ; bc - player coords, b horiz, c vert
221+  B282              ; Outputs:
222+  B282              ; de - 1 can move
223+  B282              movement_checkcanmove_down:
224+  B282 F5               push af
225+  B283 C5               push bc
226+  B284 CD B3 A6         call sprites_scadd              ; get the memory location of cell into de
227+  B287 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
228+  B289 24               inc h                       ; memory location of cell beneath now in hl
229+  B28A CD AB B1         call movement_linebelowisempty       ; check space is empty
230+  B28D 7B               ld a,e                          ; check space empty flag
231+  B28E FE 00            cp 0
232+  B290 CA 99 B2         jp z, movement_checkcanmove_down1 ; can't move
233+  B293 CD 7F B3         call player_justmoved
234+  B296 C1               pop bc
235+  B297 F1               pop af
236+  B298 C9               ret
237+  B299              movement_checkcanmove_down1:
238+  B299 C1               pop bc
239+  B29A CD B3 A6         call sprites_scadd              ; get the memory location of cell into de
240+  B29D 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
241+  B29F 24               inc h
242+  B2A0 C5               push bc
243+  B2A1 CD FF B1         call movement_spacebelowisdiggable    ; can't move here, but can we dig
244+  B2A4 11 00 00         ld de,0
245+  B2A7 C1               pop bc
246+  B2A8 F1               pop af
247+  B2A9 C9               ret
248+  B2AA
249+  B2AA              ;
250+  B2AA              ; Checks if the player can move up
251+  B2AA              ; Inputs:
252+  B2AA              ; bc - player coords, b horiz, c vert
253+  B2AA              ; Outputs:
254+  B2AA              ; de - 1 can move
255+  B2AA              movement_checkcanmove_up:
256+  B2AA F5               push af
257+  B2AB C5               push bc
258+  B2AC CD B3 A6         call sprites_scadd              ; get the memory location of cell into de
259+  B2AF 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
260+  B2B1 11 20 00         ld de,32
261+  B2B4 ED 52            sbc hl,de                       ; memory location of line above now in hl
262+  B2B6 CD BB B1         call movement_lineaboveisempty       ; check space is empty
263+  B2B9 7B               ld a,e                          ; check space empty flag
264+  B2BA FE 00            cp 0
265+  B2BC CA C7 B2         jp z, movement_checkcanmove_up1 ; can't move
266+  B2BF 1E 01            ld e,1
267+  B2C1 CD 7F B3         call player_justmoved
268+  B2C4 C1               pop bc
269+  B2C5 F1               pop af
270+  B2C6 C9               ret
271+  B2C7              movement_checkcanmove_up1:
272+  B2C7 C1               pop bc
273+  B2C8 CD B3 A6         call sprites_scadd              ; get the memory location of cell into de
274+  B2CB 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
275+  B2CD 11 20 00         ld de,32
276+  B2D0 ED 52            sbc hl,de                       ; memory location of line above now in hl
277+  B2D2 C5               push bc
278+  B2D3 CD 40 B2         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
279+  B2D6 11 00 00         ld de,0
280+  B2D9 C1               pop bc
281+  B2DA F1               pop af
282+  B2DB C9               ret
283+  B2DC
284+  B2DC              ;
285+  B2DC              ; Checks if the player can move right
286+  B2DC              ; Inputs:
287+  B2DC              ; bc - player coords, b horiz, c vert
288+  B2DC              ; Outputs:
289+  B2DC              ; de - 1 can move
290+  B2DC              movement_checkcanmove_right:
291+  B2DC F5               push af
292+  B2DD C5               push bc
293+  B2DE CD B3 A6         call sprites_scadd              ; get the memory location of cell into de
294+  B2E1 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
295+  B2E3 23               inc hl                          ; memory location of cell to the right now in hl
296+  B2E4 CD 8C B1         call movement_spaceisempty       ; check space is empty
297+  B2E7 7B               ld a,e                          ; check space empty flag
298+  B2E8 FE 00            cp 0
299+  B2EA CA F3 B2         jp z, movement_checkcanmove_right1 ; can't move
300+  B2ED CD 7F B3         call player_justmoved
301+  B2F0 C1               pop bc
302+  B2F1 F1               pop af
303+  B2F2 C9               ret
304+  B2F3              movement_checkcanmove_right1:
305+  B2F3 C1               pop bc
306+  B2F4 CD B3 A6         call sprites_scadd              ; get the memory location of cell into de
307+  B2F7 62 6B            ld hl,de
308+  B2F9 23               inc hl                          ; memory location of cell to the right now in hl
309+  B2FA C5               push bc
310+  B2FB CD CB B1         call movement_spaceisdiggable    ; can't move here, but can we dig
311+  B2FE 11 00 00         ld de,0
312+  B301 C1               pop bc
313+  B302 F1               pop af
314+  B303 C9               ret
315+  B304
316+  B304              ;
317+  B304              ; Checks if the player can move left
318+  B304              ; Inputs:
319+  B304              ; bc - player coords, b horiz, c vert
320+  B304              ; Outputs:
321+  B304              ; de - 1 can move
322+  B304              movement_checkcanmove_left:
323+  B304 F5               push af
324+  B305 C5               push bc
325+  B306 CD B3 A6         call sprites_scadd              ; get the memory location of cell into de
326+  B309 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
327+  B30B 2B               dec hl                          ; memory location of cell to the right now in hl
328+  B30C CD 8C B1         call movement_spaceisempty       ; check space is empty
329+  B30F 7B               ld a,e                          ; check space empty flag
330+  B310 FE 00            cp 0
331+  B312 CA 1B B3         jp z, movement_checkcanmove_left1 ; can't move
332+  B315 CD 7F B3         call player_justmoved
333+  B318 C1               pop bc
334+  B319 F1               pop af
335+  B31A C9               ret
336+  B31B              movement_checkcanmove_left1:
337+  B31B C1               pop bc
338+  B31C CD B3 A6         call sprites_scadd              ; get the memory location of cell into de
339+  B31F 62 6B            ld hl,de
340+  B321 2B               dec hl                          ; memory location of cell to the right now in hl
341+  B322 C5               push bc
342+  B323 CD CB B1         call movement_spaceisdiggable    ; can't move here, but can we dig
343+  B326 11 00 00         ld de,0
344+  B329 C1               pop bc
345+  B32A F1               pop af
346+  B32B C9               ret
# file closed: game/movement.asm
 33   B32C                  include "game\game.asm"
# file opened: game/game.asm
  1+  B32C              ;
  2+  B32C              ; The current frame count, incremented each frame
  3+  B32C              ;
  4+  B32C              game_framenumber:
  5+  B32C 00               defb    0
  6+  B32D
  7+  B32D              ;
  8+  B32D              ; Increment frame number by 1
  9+  B32D              ;
 10+  B32D              game_incrementframe:
 11+  B32D 3A 2C B3         ld a,(game_framenumber)
 12+  B330 3C               inc a
 13+  B331 32 2C B3         ld (game_framenumber),a
 14+  B334 C9               ret
 15+  B335
 16+  B335              ;
 17+  B335              ; Returns current frame
 18+  B335              ; Outputs:
 19+  B335              ; a - current frame
 20+  B335              ;
 21+  B335              game_getcurrentframe:
 22+  B335 3A 2C B3         ld a,(game_framenumber)
 23+  B338 C9               ret
# file closed: game/game.asm
 34   B339                  include "game\player.asm"
# file opened: game/player.asm
  1+  B339              ;
  2+  B339              ;   Data for current player
  3+  B339              ;   horiz,vert,dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count,move remaining, is digging (0 no), digging count, pixels to dig
  4+  B339              player:
  5+  B339 00 00 02 00      defb    0,0,2,0,1,0,0,0,0
  5+  B33D 01 00 00 00
  5+  B341 00
  6+  B342              ;
  7+  B342              ; Initializes a player
  8+  B342              ;
  9+  B342              player_init:
 10+  B342 ED 4B 10 80      ld bc,(start_coord)
 11+  B346 ED 43 39 B3      ld (player),bc
 12+  B34A C9               ret
 13+  B34B
 14+  B34B              ;
 15+  B34B              ; Draws the player at the current position or deletes them
 16+  B34B              ;
 17+  B34B              player_drawplayer:
 18+  B34B 3A 3B B3         ld a,(player+2)             ; get the current direction
 19+  B34E FE 03            cp 3
 20+  B350 C2 55 B3         jp nz,player_drawplayer0
 21+  B353 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
 22+  B355              player_drawplayer0:
 23+  B355 5F               ld e,a                      ; store in e
 24+  B356 3A 3F B3         ld a,(player+6)             ; get the dig flag
 25+  B359 FE 01            cp 1
 26+  B35B CA 65 B3         jp z,player_drawplayer1    ; get dig frame
 27+  B35E 3A 3C B3         ld a,(player+3)             ; this is normal movement so get the current frame
 28+  B361 83               add a,e
 29+  B362 C3 6A B3         jp player_drawplayer2
 30+  B365              player_drawplayer1
 31+  B365 3A 3B B3         ld a,(player+2)             ; get the current direction again, because want all four
 32+  B368 C6 06            add a,6                     ; add direction to 6 to get frame
 33+  B36A              player_drawplayer2
 34+  B36A 07               rlca
 35+  B36B 07               rlca
 36+  B36C 07               rlca                        ; multiply by eight
 37+  B36D 6F               ld l,a
 38+  B36E 26 00            ld h,0
 39+  B370 11 66 AE         ld de,player_sprite
 40+  B373 19               add hl,de                   ; load hl with the location of the player sprite data
 41+  B374 ED 4B 39 B3      ld bc,(player)              ; load bc with the start coords
 42+  B378 CD 70 A6         call sprites_drawsprite     ; call the routine to draw the sprite
 43+  B37B CD AB B3         call player_storeupdatedlines ; log updated rows
 44+  B37E C9               ret
 45+  B37F
 46+  B37F
 47+  B37F              ;
 48+  B37F              ; Runs after the player just moved. Changes animation frame if required
 49+  B37F              ;
 50+  B37F              player_justmoved:
 51+  B37F D9               exx
 52+  B380 3A 3D B3         ld a,(player+4)             ; get the transition count
 53+  B383 FE 00            cp 0
 54+  B385 CA 8B B3         jp z, player_justmoved2     ; if zero reset and change the frame
 55+  B388 C3 A5 B3         jp player_justmoved1       ; otherwise decrease and continue
 56+  B38B              player_justmoved2:
 57+  B38B                  ; reset and change frame in here
 58+  B38B 3E 01            ld a,1
 59+  B38D 32 3D B3         ld (player+4),a            ; reset back to whatever
 60+  B390 3A 3C B3         ld a,(player+3)             ; load the frame
 61+  B393 FE 03            cp 3                       ; flip between 3 and 0
 62+  B395 C2 9D B3         jp nz, player_justmoved4
 63+  B398 3E 00            ld a,0
 64+  B39A C3 9F B3         jp player_justmoved5
 65+  B39D              player_justmoved4:
 66+  B39D 3E 03            ld a,3
 67+  B39F              player_justmoved5:
 68+  B39F 32 3C B3         ld (player+3),a           ; save back
 69+  B3A2 C3 A9 B3         jp player_justmoved3
 70+  B3A5              player_justmoved1:
 71+  B3A5                  ; decrease count
 72+  B3A5 3D               dec a
 73+  B3A6 32 3D B3         ld (player+4),a
 74+  B3A9              player_justmoved3:
 75+  B3A9 D9               exx;
 76+  B3AA C9               ret
 77+  B3AB
 78+  B3AB              ;
 79+  B3AB              ; Stores the updated rows associated with the player
 80+  B3AB              ;
 81+  B3AB              player_storeupdatedlines:
 82+  B3AB ED 4B 39 B3      ld bc,(player)          ; get the screen coords into bc
 83+  B3AF 79               ld a,c                  ; get the player block coords of current block
 84+  B3B0 E6 F8            and 248                 ; find closest multiple of eight
 85+  B3B2 0F               rrca
 86+  B3B3 0F               rrca
 87+  B3B4 0F               rrca                    ; divide by 8
 88+  B3B5 ED 5B F1 A4      ld de,(screen_offset)          ; load the screen offset, this is in rows
 89+  B3B9 93               sub e
 90+  B3BA F5               push af
 91+  B3BB CD A4 A3         call buffer_marklineforupdate  ; store current row in updated lines
 92+  B3BE F1               pop af
 93+  B3BF 3D               dec a
 94+  B3C0 F5               push af
 95+  B3C1 CD A4 A3         call buffer_marklineforupdate  ; store line above
 96+  B3C4 F1               pop af
 97+  B3C5 3C               inc a
 98+  B3C6 3C               inc a
 99+  B3C7 CD A4 A3         call buffer_marklineforupdate  ; store line beneath
100+  B3CA C9               ret
# file closed: game/player.asm
 35   B3CB                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  B3CB              ;
  2+  B3CB              ; Ship initial position: vert,horiz
  3+  B3CB              ;
  4+  B3CB              ship_initpos:
  5+  B3CB 00 24            defb 0,36
  6+  B3CD              ship_initpos2:
  7+  B3CD 00 00            defb 0,0
  8+  B3CF              ship_frame:
  9+  B3CF 00               defb 0
 10+  B3D0              ;
 11+  B3D0              ; The current memory location
 12+  B3D0              ;
 13+  B3D0              ship_current_sprite:
 14+  B3D0 00 00            defb 0,0
 15+  B3D2
 16+  B3D2              ship_current_coords:
 17+  B3D2 00 00            defb 0,0
 18+  B3D4
 19+  B3D4              ;
 20+  B3D4              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 21+  B3D4              ;
 22+  B3D4              ship_land:
 23+  B3D4 ED 4B CB B3      ld bc,(ship_initpos)
 24+  B3D8 ED 43 CD B3      ld (ship_initpos2),bc        ; save the initial position for later use
 25+  B3DC 1E 00            ld e,0                      ; store a flag to track first time round
 26+  B3DE 06 09            ld b,9                      ; move down 8 pixels
 27+  B3E0              ship_land0:
 28+  B3E0 C5               push bc
 29+  B3E1 7B               ld a,e
 30+  B3E2 D5               push de                     ; store de for next time round
 31+  B3E3 FE 01            cp 1                        ; check first time flag
 32+  B3E5 C2 FA B3         jp nz,ship_land1             ; don't draw over previous one if first time
 33+  B3E8 CD 62 B4         call ship_draw_full         ; delete old one
 34+  B3EB CD 37 B4         call ship_change_frame      ; increment the frame
 35+  B3EE ED 4B CD B3      ld bc,(ship_initpos2)       ; get the current coords
 36+  B3F2 81 C6 01         add c,1                     ; move down one pixels
 37+  B3F5 4F               ld c,a
 38+  B3F6 ED 43 CD B3      ld (ship_initpos2),bc
 39+  B3FA              ship_land1:
 40+  B3FA CD 62 B4         call ship_draw_full         ; draw the ship
 41+  B3FD CD 4C B4         call ship_draw_screen
 42+  B400 D1               pop de
 43+  B401 1E 01            ld e,1
 44+  B403 C1               pop bc
 45+  B404 10 DA            djnz ship_land0             ; repeat for downward movement
 46+  B406                  ; done moving down
 47+  B406                  ; now move across
 48+  B406 CD 4B B3         call player_drawplayer      ; draw player
 49+  B409 CD 62 B4         call ship_draw_full         ; delete old one
 50+  B40C 1E 00            ld e,0                      ; store a flag to track first time round
 51+  B40E 06 14            ld b,20                      ; move back 20 pixels pixels
 52+  B410              ship_land3:
 53+  B410 C5               push bc
 54+  B411 7B               ld a,e
 55+  B412 D5               push de                     ; store de for next time round
 56+  B413 FE 01            cp 1                        ; check first time flag
 57+  B415 C2 2A B4         jp nz,ship_land2             ; don't draw over previous one if first time
 58+  B418 CD 62 B4         call ship_draw_full         ; delete old one
 59+  B41B CD 37 B4         call ship_change_frame      ; increment the frame
 60+  B41E ED 4B CD B3      ld bc,(ship_initpos2)       ; get the current coords
 61+  B422 78               ld a,b
 62+  B423 D6 01            sub 1                       ; move back one pixels
 63+  B425 47               ld b,a
 64+  B426 ED 43 CD B3      ld (ship_initpos2),bc
 65+  B42A              ship_land2:
 66+  B42A CD 62 B4         call ship_draw_full         ; draw the ship
 67+  B42D CD 4C B4         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 68+  B430 D1               pop de
 69+  B431 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 70+  B433 C1               pop bc
 71+  B434 10 DA            djnz ship_land3             ; repeat for vertical movement
 72+  B436 C9               ret
 73+  B437
 74+  B437              ;
 75+  B437              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
 76+  B437              ;
 77+  B437              ship_change_frame:
 78+  B437 F5               push af
 79+  B438 3A CF B3         ld a,(ship_frame)
 80+  B43B FE 00            cp 0
 81+  B43D CA 45 B4         jp z,ship_change_frame0
 82+  B440 3E 00            ld a,0                      ; flip to 0
 83+  B442 C3 47 B4         jp ship_change_frame1
 84+  B445              ship_change_frame0:
 85+  B445 3E 20            ld a,32                      ; flip to 32
 86+  B447              ship_change_frame1:
 87+  B447 32 CF B3         ld (ship_frame),a            ; save the frame
 88+  B44A F1               pop af
 89+  B44B C9               ret
 90+  B44C
 91+  B44C              ship_draw_screen:
 92+  B44C 3E 00            ld a,0
 93+  B44E CD A4 A3         call buffer_marklineforupdate
 94+  B451 3E 01            ld a,1
 95+  B453 CD A4 A3         call buffer_marklineforupdate
 96+  B456 3E 02            ld a,2
 97+  B458 CD A4 A3         call buffer_marklineforupdate   ; mark the first three rows for update
 98+  B45B 76               halt
 99+  B45C F3               di
100+  B45D CD 38 A4         call buffer_buffertoscreen  ; copy buffer to screen
101+  B460 FB               ei                          ; enable interupts
102+  B461 C9               ret
103+  B462
104+  B462              ship_draw_full:
105+  B462 21 B6 AE         ld hl,ship_sprite
106+  B465 ED 4B CD B3      ld bc,(ship_initpos2)         ; load bc with the start coords
107+  B469 22 D0 B3         ld (ship_current_sprite),hl  ; put into memory
108+  B46C ED 43 D2 B3      ld (ship_current_coords),bc  ; put into memory
109+  B470 CD 8F B4         call ship_draw
110+  B473 08               ex af,af'
111+  B474 3A CF B3         ld a,(ship_frame)            ; get the animation frame
112+  B477 16 00            ld d,0
113+  B479 5F               ld e,a
114+  B47A 19               add hl,de
115+  B47B 22 D0 B3         ld (ship_current_sprite),hl  ; put into memory
116+  B47E 08               ex af,af'
117+  B47F ED 4B CD B3      ld bc,(ship_initpos2)         ; load bc with the start coords
118+  B483 81 C6 08         add c,8                      ; move one line down
119+  B486 4F               ld c,a
120+  B487 ED 43 D2 B3      ld (ship_current_coords),bc  ; put into memory
121+  B48B CD 8F B4         call ship_draw
122+  B48E C9               ret
123+  B48F
124+  B48F              ;
125+  B48F              ; Draw the ship
126+  B48F              ; Inputs:
127+  B48F              ; None, all in memory
128+  B48F              ;
129+  B48F              ship_draw:
130+  B48F 3E 04            ld a,4                              ; 4 pieces per half
131+  B491              ship_draw0:
132+  B491 F5               push af
133+  B492 2A D0 B3         ld hl,(ship_current_sprite)
134+  B495 ED 4B D2 B3      ld bc,(ship_current_coords)         ; load bc with the start coords
135+  B499 CD 70 A6         call sprites_drawsprite
136+  B49C 2A D0 B3         ld hl,(ship_current_sprite)
137+  B49F ED 4B D2 B3      ld bc,(ship_current_coords)         ; load bc with the start coords
138+  B4A3 11 08 00         ld de,8
139+  B4A6 19               add hl,de
140+  B4A7 80 C6 08         add b,8
141+  B4AA 47               ld b,a
142+  B4AB 22 D0 B3         ld (ship_current_sprite),hl         ; put into memory
143+  B4AE ED 43 D2 B3      ld (ship_current_coords),bc         ; put into memory
144+  B4B2 F1               pop af
145+  B4B3 3D               dec a
146+  B4B4 FE 00            cp 0
147+  B4B6 C2 91 B4         jp nz,ship_draw0
148+  B4B9
149+  B4B9 C9               ret
150+  B4BA
# file closed: game/ship.asm
 36   B4BA                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  B4BA              ;
  2+  B4BA              ; tank initial position: vert,horiz
  3+  B4BA              ;
  4+  B4BA              tank_initpos:
  5+  B4BA 10 D0            defb 16,208
  6+  B4BC              tank_initpos2:
  7+  B4BC 00 00            defb 0,0
  8+  B4BE              tank_frame:
  9+  B4BE 00               defb 0
 10+  B4BF              tank_anim:
 11+  B4BF 11               defb 17
 12+  B4C0              ;
 13+  B4C0              ; The current memory location
 14+  B4C0              ;
 15+  B4C0              tank_current_sprite:
 16+  B4C0 00 00            defb 0,0
 17+  B4C2
 18+  B4C2              tank_current_coords:
 19+  B4C2 00 00            defb 0,0
 20+  B4C4
 21+  B4C4              ;
 22+  B4C4              ; Initialise the tank
 23+  B4C4              ;
 24+  B4C4              tank_init:
 25+  B4C4 ED 4B BA B4      ld bc,(tank_initpos)
 26+  B4C8 ED 43 BC B4      ld (tank_initpos2),bc       ; save the initial position for later use
 27+  B4CC C9               ret
 28+  B4CD
 29+  B4CD              ;
 30+  B4CD              ;   Draw and move the tank
 31+  B4CD              ;   Start processing at frame 200
 32+  B4CD              ;   Don't move if anim is zero
 33+  B4CD              ;   Decrement frame if moved
 34+  B4CD              ;
 35+  B4CD              tank_process:
 36+  B4CD 3A BF B4         ld a,(tank_anim)
 37+  B4D0 FE 00            cp 0
 38+  B4D2 C8               ret z                       ; return if we've already moved
 39+  B4D3 CD 35 B3         call game_getcurrentframe   ; get the current frame number into a
 40+  B4D6 FE 4B            cp 75
 41+  B4D8 D8               ret c                       ; return if the frame number is below 100
 42+  B4D9 CD E4 B4         call tank_move              ; move tank if not
 43+  B4DC 3A BF B4         ld a,(tank_anim)
 44+  B4DF 3D               dec a
 45+  B4E0 32 BF B4         ld (tank_anim),a            ; decrease the anim count
 46+  B4E3 C9               ret
 47+  B4E4
 48+  B4E4              tank_move:
 49+  B4E4 ED 4B BC B4      ld bc,(tank_initpos2)
 50+  B4E8 C5               push bc
 51+  B4E9 3A BF B4         ld a,(tank_anim)
 52+  B4EC FE 11            cp 17                       ; check first time flag
 53+  B4EE CA 00 B5         jp z,tank_move1             ; don't draw over previous one if first time
 54+  B4F1 CD 05 B5         call tank_draw_full         ; delete old one
 55+  B4F4 ED 4B BC B4      ld bc,(tank_initpos2)       ; get the current coords
 56+  B4F8 78               ld a,b
 57+  B4F9 D6 01            sub 1                       ; move back one pixels
 58+  B4FB 47               ld b,a
 59+  B4FC ED 43 BC B4      ld (tank_initpos2),bc
 60+  B500              tank_move1:
 61+  B500 CD 05 B5         call tank_draw_full         ; draw the tank
 62+  B503 C1               pop bc
 63+  B504 C9               ret
 64+  B505
 65+  B505              tank_draw_full:
 66+  B505 21 16 AF         ld hl,tank_sprite
 67+  B508 ED 4B BC B4      ld bc,(tank_initpos2)         ; load bc with the start coords
 68+  B50C 22 C0 B4         ld (tank_current_sprite),hl  ; put into memory
 69+  B50F ED 43 C2 B4      ld (tank_current_coords),bc  ; put into memory
 70+  B513 CD 3C B5         call tank_draw
 71+  B516 08               ex af,af'
 72+  B517 3A BE B4         ld a,(tank_frame)            ; get the animation frame
 73+  B51A 16 00            ld d,0
 74+  B51C 5F               ld e,a
 75+  B51D 19               add hl,de
 76+  B51E 22 C0 B4         ld (tank_current_sprite),hl  ; put into memory
 77+  B521 08               ex af,af'
 78+  B522 ED 4B BC B4      ld bc,(tank_initpos2)         ; load bc with the start coords
 79+  B526 81 C6 08         add c,8                      ; move one line down
 80+  B529 4F               ld c,a
 81+  B52A ED 43 C2 B4      ld (tank_current_coords),bc  ; put into memory
 82+  B52E CD 3C B5         call tank_draw
 83+  B531 3E 02            ld a,2
 84+  B533 CD A4 A3         call buffer_marklineforupdate
 85+  B536 3E 03            ld a,3
 86+  B538 CD A4 A3         call buffer_marklineforupdate   ; mark the first two rows for update
 87+  B53B C9               ret
 88+  B53C
 89+  B53C              ;
 90+  B53C              ; Draw the tank
 91+  B53C              ; Inputs:
 92+  B53C              ; None, all in memory
 93+  B53C              ;
 94+  B53C              tank_draw:
 95+  B53C 3E 04            ld a,4                              ; 4 pieces per half
 96+  B53E              tank_draw0:
 97+  B53E F5               push af
 98+  B53F 2A C0 B4         ld hl,(tank_current_sprite)
 99+  B542 ED 4B C2 B4      ld bc,(tank_current_coords)         ; load bc with the start coords
100+  B546 CD 70 A6         call sprites_drawsprite
101+  B549 2A C0 B4         ld hl,(tank_current_sprite)
102+  B54C ED 4B C2 B4      ld bc,(tank_current_coords)         ; load bc with the start coords
103+  B550 11 08 00         ld de,8
104+  B553 19               add hl,de
105+  B554 80 C6 08         add b,8
106+  B557 47               ld b,a
107+  B558 22 C0 B4         ld (tank_current_sprite),hl         ; put into memory
108+  B55B ED 43 C2 B4      ld (tank_current_coords),bc         ; put into memory
109+  B55F F1               pop af
110+  B560 3D               dec a
111+  B561 FE 00            cp 0
112+  B563 C2 3E B5         jp nz,tank_draw0
113+  B566
114+  B566 C9               ret
115+  B567
# file closed: game/tank.asm
 37   B567                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  B567              ;
  2+  B567              ; A structure of falling rocks
  3+  B567              ; Assume we'll never have more than 4 falling at any one time
  4+  B567              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  B567              ;
  6+  B567              rocks_falling:
  7+  B567 00 00 00 00      defb 0,0,0,0
  8+  B56B 00 00 00 00      defb 0,0,0,0
  9+  B56F 00 00 00 00      defb 0,0,0,0
 10+  B573 00 00 00 00      defb 0,0,0,0
 11+  B577
 12+  B577              rocks_tmp:
 13+  B577 00               defb 0
 14+  B578
 15+  B578              rocks_tmp2:
 16+  B578 00 00            defb 0,0
 17+  B57A
 18+  B57A              ;
 19+  B57A              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 20+  B57A              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 21+  B57A              ; If the pixel row is not the rock bottom, stop checking.
 22+  B57A              ; Inputs:
 23+  B57A              ; hl- memory location
 24+  B57A              ;
 25+  B57A              rocks_checkforfalling:
 26+  B57A 7E               ld a,(hl)           ; get the pixel row in this memory location
 27+  B57B FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 28+  B57D C2 83 B5         jp nz,rocks_checkforfalling2 ; not a rock, stop
 29+  B580 CD 84 B5         call rocks_addrocktofalling ; mark the rock as falling
 30+  B583              rocks_checkforfalling2:
 31+  B583 C9               ret
 32+  B584
 33+  B584              ;
 34+  B584              ; Adds the rock to the structure that tracks falling rocks
 35+  B584              ; Inputs:
 36+  B584              ; hl - memory location of falling rock graphic
 37+  B584              ; bc - coords of rock, c vert
 38+  B584              rocks_addrocktofalling:
 39+  B584 C5               push bc             ; store the coords
 40+  B585 11 67 B5         ld de,rocks_falling
 41+  B588 06 04            ld b,4              ; number of possible falling rocks
 42+  B58A              rocks_addrocktofalling0:
 43+  B58A 13               inc de
 44+  B58B 13               inc de
 45+  B58C 13               inc de              ; move three along to get the state
 46+  B58D 1A               ld a,(de)           ; load the state
 47+  B58E FE 00            cp 0                ; check if this is not falling
 48+  B590 C2 A5 B5         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 49+  B593 3E 10            ld a,16             ; load the number of frames to wobble
 50+  B595 12               ld (de),a
 51+  B596 1B               dec de              ; move de back to state
 52+  B597 3E 02            ld a,2
 53+  B599 12               ld (de),a           ; set the state to wobbling
 54+  B59A 1B               dec de              ; move back coords
 55+  B59B C1               pop bc              ; get back coords
 56+  B59C 78               ld a,b
 57+  B59D 12               ld (de),a           ; store the vertical
 58+  B59E 1B               dec de
 59+  B59F 79               ld a,c
 60+  B5A0 12               ld (de),a           ; store the horizontal
 61+  B5A1 C5               push bc
 62+  B5A2 C3 A8 B5         jp rocks_addrocktofalling2 ; done
 63+  B5A5              rocks_addrocktofalling1:
 64+  B5A5 13               inc de              ; move memory along to next rock
 65+  B5A6 10 E2            djnz rocks_addrocktofalling0 ; try the next rock
 66+  B5A8              rocks_addrocktofalling2: ; done, return
 67+  B5A8 C1               pop bc              ; to tidy up
 68+  B5A9 C9               ret
 69+  B5AA
 70+  B5AA              ;
 71+  B5AA              ; Processes any falling rocks
 72+  B5AA              ;
 73+  B5AA              rocks_processrocks:
 74+  B5AA DD 21 67 B5      ld ix,rocks_falling
 75+  B5AE 06 04            ld b,4              ; the number of rocks to check
 76+  B5B0              rocks_processrocks0:
 77+  B5B0 C5               push bc             ; store loop count
 78+  B5B1 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 78+  B5B5 46 01
 79+  B5B7 DD 23            inc ix
 80+  B5B9 DD 23            inc ix              ; move to the state
 81+  B5BB DD 7E 00         ld a,(ix)           ; load the state into a
 82+  B5BE FE 00            cp 0
 83+  B5C0 CA E4 B5         jp z,rocks_processrocks3 ; if not falling, check next
 84+  B5C3 FE 02            cp 2
 85+  B5C5 C2 D5 B5         jp nz, rocks_processrocks2
 86+  B5C8                  ; we're wobbling
 87+  B5C8 DD 23            inc ix              ; get frame number for wobble
 88+  B5CA DD 7E 00         ld a,(ix)           ; get wobble frame into a
 89+  B5CD CD 7E B6         call rocks_wobble
 90+  B5D0 DD 23            inc ix              ; increment for next
 91+  B5D2 C3 E8 B5         jp rocks_processrocks1  ; do next rock
 92+  B5D5              rocks_processrocks2:
 93+  B5D5                  ; we're falling
 94+  B5D5 C5               push bc
 95+  B5D6 CD 01 B6         call rocks_fall
 96+  B5D9 C1               pop bc
 97+  B5DA CD EC B5         call rocks_storeupdatedlines
 98+  B5DD DD 23            inc ix
 99+  B5DF DD 23            inc ix              ; inc ix to get to next
100+  B5E1 C3 E8 B5         jp rocks_processrocks1
101+  B5E4              rocks_processrocks3:
102+  B5E4 DD 23            inc ix
103+  B5E6 DD 23            inc ix
104+  B5E8              rocks_processrocks1:
105+  B5E8 C1               pop bc              ; get loop count back
106+  B5E9 10 C5            djnz rocks_processrocks0
107+  B5EB C9               ret
108+  B5EC
109+  B5EC              ;
110+  B5EC              ; Stores the updated rows associated with the rock
111+  B5EC              ; Inputs:
112+  B5EC              ; bc - coords
113+  B5EC              ;
114+  B5EC              rocks_storeupdatedlines:
115+  B5EC 79               ld a,c                  ; get the player block coords of current block
116+  B5ED E6 F8            and 248                 ; find closest multiple of eight
117+  B5EF 0F               rrca
118+  B5F0 0F               rrca
119+  B5F1 0F               rrca                    ; divide by 8
120+  B5F2 ED 5B F1 A4      ld de,(screen_offset)          ; load the screen offset, this is in rows
121+  B5F6 93               sub e
122+  B5F7 F5               push af
123+  B5F8 CD A4 A3         call buffer_marklineforupdate  ; store current row in updated lines
124+  B5FB F1               pop af
125+  B5FC 3C               inc a
126+  B5FD CD A4 A3         call buffer_marklineforupdate  ; store line beneath
127+  B600 C9               ret
128+  B601
129+  B601              ;
130+  B601              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
131+  B601              ; bc - coord of current rock graphic on screen
132+  B601              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
133+  B601              ;
134+  B601              rocks_fall:
135+  B601 DD 2B            dec ix
136+  B603 DD 2B            dec ix              ; decrease ix back to coords
137+  B605 ED 43 78 B5      ld (rocks_tmp2),bc  ; store original coords
138+  B609 3E 03            ld a,3              ; move this number of pixels
139+  B60B              rocks_fall1:
140+  B60B 08               ex af,af'
141+  B60C DD 4E 00 DD      ld bc,(ix)          ; get current coords
141+  B610 46 01
142+  B612 CD B3 A6         call sprites_scadd  ; get the memory of the coords into de
143+  B615 14               inc d               ; add 256 to get next row
144+  B616 1A               ld a,(de)           ; get the contents of the next row
145+  B617 FE 00            cp 0
146+  B619 C2 69 B6         jp nz,rocks_fall3    ; move the rock if the row is empty
147+  B61C 0C               inc c               ; increment the vertical
148+  B61D DD 71 00 DD      ld (ix),bc          ; store the new coords
148+  B621 70 01
149+  B623 79               ld a,c              ; get the vertical coord into a
150+  B624 E6 07            and 7               ; divisible by 8?
151+  B626 FE 00            cp 0
152+  B628 C2 43 B6         jp nz,rocks_fall4   ; if not, carry on
153+  B62B CD 13 A6         call screen_getattraddressfromscreencoords ; get the attr address into de
154+  B62E 62 6B            ld hl,de
155+  B630 36 42            ld (hl),66          ; load this square with the yellow colour
156+  B632 DD 4E 00 DD      ld bc,(ix)
156+  B636 46 01
157+  B638 79               ld a,c              ; get vertical
158+  B639 D6 08            sub 8               ; look up one square
159+  B63B 4F               ld c,a              ; put a back in c
160+  B63C CD 13 A6         call screen_getattraddressfromscreencoords ; get the attr address into de
161+  B63F 62 6B            ld hl,de
162+  B641 36 46            ld (hl),70          ; load this square with the yellow colour
163+  B643              rocks_fall4:
164+  B643 08               ex af,af'
165+  B644 3D               dec a
166+  B645 FE 00            cp 0
167+  B647 C2 0B B6         jp nz,rocks_fall1   ; do another pixel if needed
168+  B64A              rocks_fall2:
169+  B64A 3E 09            ld a,9              ; rock graphic
170+  B64C ED 4B 78 B5      ld bc,(rocks_tmp2)  ; get the original coords
171+  B650 CD 4E A6         call screen_getblock     ; get the memory into hl
172+  B653 CD 70 A6         call sprites_drawsprite  ; draw the sprite - over the top of the current one
173+  B656 3E 09            ld a,9
174+  B658 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
174+  B65C 46 01
175+  B65E CD 4E A6         call screen_getblock     ; get the memory into hl
176+  B661 CD 70 A6         call sprites_drawsprite  ; draw the sprite - over the top of the current one
177+  B664 DD 23            inc ix
178+  B666 DD 23            inc ix                  ; get ix back to state
179+  B668 C9               ret
180+  B669              rocks_fall3:
181+  B669 3E 00            ld a,0              ; set the state to fell
182+  B66B DD 77 02         ld (ix+2),a           ; store the falling state
183+  B66E DD 4E 00 DD      ld bc,(ix)          ; get the coords
183+  B672 46 01
184+  B674 CD 13 A6         call screen_getattraddressfromscreencoords ; get the attr address into de
185+  B677 62 6B            ld hl,de
186+  B679 36 42            ld (hl),66
187+  B67B C3 4A B6         jp rocks_fall2      ; rejoin main loop
188+  B67E
189+  B67E              ;
190+  B67E              ; Wobbles a rocks
191+  B67E              ; Inputs:
192+  B67E              ; bc - coord of current rock graphic on screen
193+  B67E              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
194+  B67E              ; a - wobble frame
195+  B67E              rocks_wobble:
196+  B67E 3A 77 B5         ld a,(rocks_tmp)    ; get the frame toggle
197+  B681 1E 09            ld e,9              ; this is the rock frame
198+  B683 83               add a,e             ; add the frame toggle
199+  B684 C5               push bc
200+  B685 CD 4E A6         call screen_getblock     ; get the memory into hl
201+  B688 CD 70 A6         call sprites_drawsprite  ; draw the sprite - over the top of the current one
202+  B68B 3A 77 B5         ld a,(rocks_tmp)    ; get the frame toggle against
203+  B68E EE 01            xor 1               ; flip to other state
204+  B690 32 77 B5         ld (rocks_tmp),a    ; store
205+  B693 1E 09            ld e,9              ; this is the rock frame
206+  B695 83               add a,e             ; add the frame toggle
207+  B696 CD 4E A6         call screen_getblock     ; get the memory into hl
208+  B699 C1               pop bc
209+  B69A CD 70 A6         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
210+  B69D DD 7E 00         ld a,(ix)           ; get the wobble count back
211+  B6A0 3D               dec a               ; decrease
212+  B6A1 DD 77 00         ld (ix),a           ; store
213+  B6A4 FE 00            cp 0
214+  B6A6 C0               ret nz              ; if we're not at zero, return
215+  B6A7 DD 2B            dec ix              ; otherwise look to state location
216+  B6A9 3E 01            ld a,1              ; set the state to falling
217+  B6AB DD 77 00         ld (ix),a           ; store the falling state
218+  B6AE DD 23            inc ix              ; set ix back to location of wobble count, and we're done
219+  B6B0 C9               ret
220+  B6B1
# file closed: game/rocks.asm
 38   B6B1                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  B6B1              ;
  2+  B6B1              ; The score of the current player
  3+  B6B1              ;
  4+  B6B1              scores_current:
  5+  B6B1 30 30 30 30      defb '000000'
  5+  B6B5 30 30
  6+  B6B7
  7+  B6B7              ;
  8+  B6B7              ; The current high score table
  9+  B6B7              ;
 10+  B6B7              scores_table:
 11+  B6B7 03 17 47 41      defb 3,23,'GAM',255
 11+  B6BB 4D FF
 12+  B6BD 06 17 30 30      defb 6,23,'00000 ',255
 12+  B6C1 30 30 30 20
 12+  B6C5 FF
 13+  B6C6 0C 17 47 41      defb 12,23,'GAM',255
 13+  B6CA 4D FF
 14+  B6CC 0F 17 30 30      defb 15,23,'00000 ',255
 14+  B6D0 30 30 30 20
 14+  B6D4 FF
 15+  B6D5 15 17 47 41      defb 21,23,'GAM',255
 15+  B6D9 4D FF
 16+  B6DB 18 17 30 30      defb 24,23,'00000 ',255
 16+  B6DF 30 30 30 20
 16+  B6E3 FF
 17+  B6E4
 18+  B6E4              ;
 19+  B6E4              ; Displays the high score table at the bottom of the screen
 20+  B6E4              ;
 21+  B6E4              scores_showtable:
 22+  B6E4 21 B7 B6         ld hl, scores_table
 23+  B6E7 CD A4 82         call string_print
 24+  B6EA 21 BD B6         ld hl, scores_table+6
 25+  B6ED CD A4 82         call string_print
 26+  B6F0 21 C6 B6         ld hl, scores_table+15
 27+  B6F3 CD A4 82         call string_print
 28+  B6F6 21 CC B6         ld hl, scores_table+21
 29+  B6F9 CD A4 82         call string_print
 30+  B6FC 21 D5 B6         ld hl, scores_table+30
 31+  B6FF CD A4 82         call string_print
 32+  B702 21 DB B6         ld hl, scores_table+36
 33+  B705 CD A4 82         call string_print
 34+  B708 C9               ret
# file closed: game/scores.asm
 39   B709                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  B709              ;
  2+  B709              ; Changes the attribute of gem and diamond cells based on the frame count
  3+  B709              ; Inputs:
  4+  B709              ; hl - memory location of gem type
  5+  B709              diamonds_twinkle_type:
  6+  B709 CD 35 B3         call game_getcurrentframe       ; get current frame number
  7+  B70C E6 07            and 7                           ; want a number from 0-7
  8+  B70E C6 40            add 64                          ; add to 60 to get attr colour
  9+  B710              diamonds_twinkle_type0:
 10+  B710 4E               ld c,(hl)                      ; get coords into bc
 11+  B711 08               ex af, af'
 12+  B712 79               ld a,c                          ; load c into add
 13+  B713 FE FF            cp 255                          ; is this the end?
 14+  B715 CA 2C B7         jp z,diamonds_twinkle_type1           ; step out if so
 15+  B718 23               inc hl
 16+  B719 23               inc hl
 17+  B71A 7E               ld a,(hl)                       ; check the state, don't process if collection
 18+  B71B FE 01            cp 1
 19+  B71D CA 2C B7         jp z,diamonds_twinkle_type1           ; step out if so
 20+  B720 23               inc hl
 21+  B721 08               ex af,af'
 22+  B722 5E 23 56 2B      ld de,(hl)                      ; get the memory location into de
 23+  B726 12               ld (de),a                       ; set the value of attr
 24+  B727 23               inc hl
 25+  B728 23               inc hl                          ; move to next diamond
 26+  B729 C3 10 B7         jp diamonds_twinkle_type0
 27+  B72C              diamonds_twinkle_type1:
 28+  B72C C9               ret
 29+  B72D
 30+  B72D              ;
 31+  B72D              ; Initialise diamonds and gems
 32+  B72D              ;
 33+  B72D              diamonds_twinkle
 34+  B72D 21 5A AD         ld hl, level01diamonds
 35+  B730 CD 09 B7         call diamonds_twinkle_type
 36+  B733 21 6A AD         ld hl, level01gems
 37+  B736 CD 09 B7         call diamonds_twinkle_type
 38+  B739 C9               ret
 39+  B73A
 40+  B73A              ;
 41+  B73A              ; Initialise diamonds and gems
 42+  B73A              ;
 43+  B73A              diamonds_init:
 44+  B73A 21 5A AD         ld hl, level01diamonds
 45+  B73D CD 47 B7         call diamonds_init_type
 46+  B740 21 6A AD         ld hl, level01gems
 47+  B743 CD 47 B7         call diamonds_init_type
 48+  B746 C9               ret
 49+  B747
 50+  B747              ;
 51+  B747              ; Initialise diamonds or gems, get memory addresses
 52+  B747              ; Inputs:
 53+  B747              ; hl - memory location
 54+  B747              diamonds_init_type:
 55+  B747 4E               ld c,(hl)                      ; get coords into c
 56+  B748 79               ld a,c                          ; load c into add
 57+  B749 FE FF            cp 255                          ; is this the end?
 58+  B74B CA 60 B7         jp z,diamonds_init_type1             ; step out if so
 59+  B74E 23               inc hl
 60+  B74F 46               ld b,(hl)                       ; get coords into b
 61+  B750 E5               push hl
 62+  B751 CD E3 A5         call screen_getcellattradress ; get memory of attr for this diamond into de
 63+  B754 E1               pop hl
 64+  B755 23               inc hl                          ; move to state
 65+  B756 23               inc hl                          ; move to memory
 66+  B757 73 23 72 2B      ld (hl),de                      ; store the memory location
 67+  B75B 23               inc hl                          ; move to next diamond
 68+  B75C 23               inc hl
 69+  B75D C3 47 B7         jp diamonds_init_type
 70+  B760              diamonds_init_type1:
 71+  B760 C9               ret
# file closed: game/diamonds.asm
 40   B761
 41   B761              ;===========================================================================
 42   B761              ; main routine - the code execution starts here.
 43   B761              ; Sets up the new interrupt routine, the memory
 44   B761              ; banks and jumps to the start loop.
 45   B761              ;===========================================================================
 46   B761              main:
 47   B761
 48   B761                  ; Setup stack
 49   B761 31 69 B8         ld sp,stack_top
 50   B764
 51   B764                  ; Draw the title screen
 52   B764 CD D8 A6         call titlescreen_show
 53   B767
 54   B767 CD 00 80         call init_start
 55   B76A CD 0B A5         call screen_draw
 56   B76D CD 6A A4         call buffer_allbuffertoscreen
 57   B770 CD 42 B3         call player_init
 58   B773 CD D4 B3         call ship_land              ; land the ship
 59   B776 CD C4 B4         call tank_init
 60   B779 CD 3A B7         call diamonds_init
 61   B77C
 62   B77C              mloop:
 63   B77C 76               halt
 64   B77D CD 83 B7         call main_loop_processing
 65   B780 C3 7C B7         jp mloop
 66   B783
 67   B783              main_loop_processing:
 68   B783 CD 38 A4         call buffer_buffertoscreen  ; copy buffer to screen
 69   B786 CD B8 A3         call buffer_clearlist       ; zero the updated lines list
 70   B789 CD 4B B3         call player_drawplayer      ; delete player
 71   B78C CD 5E AF         call control_keyboard       ; check keyboard
 72   B78F CD 4B B3         call player_drawplayer      ; draw player
 73   B792 CD CD B4         call tank_process           ; prcoess the tank
 74   B795 CD AA B5         call rocks_processrocks     ; process falling rocks
 75   B798 CD 2D B7         call diamonds_twinkle       ; make the diamonds twinkle
 76   B79B
 77   B79B CD 2D B3         call game_incrementframe    ; increment the game frame
 78   B79E
 79   B79E C9               ret
 80   B79F
 81   B79F              ;===========================================================================
 82   B79F              ; Stack.
 83   B79F              ;===========================================================================
 84   B79F
 85   B79F              ; Stack: this area is reserved for the stack
 86   B79F              STACK_SIZE: equ 100    ; in words
 87   B79F
 88   B79F              ; Reserve stack space
 89   B79F 00 00            defw 0  ; WPMEM, 2
 90   B7A1              stack_bottom:
 91   B7A1 00 00 00...      defs    STACK_SIZE*2, 0
 92   B869              stack_top:
 93   B869 00 00            defw 0  ; WPMEM, 2
 94   B86B
 95   B86B                     SAVESNA "ThePit.sna", main
# file closed: main.asm
