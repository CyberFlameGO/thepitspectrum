# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 67 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 8C A5         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 8D A5         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 27 A4         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD 3A B5         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8051 C9               ret                 ; key was pressed.
 53+  8052
 54+  8052              ;
 55+  8052              ; Waits number of frames for keypress. If got, returns 1, if not 0
 56+  8052              ; Inputs:
 57+  8052              ; a - number of frames to waits
 58+  8052              ; Ouputs:
 59+  8052              ; e - 0 not pressed, 1 pressed
 60+  8052              utilities_waitforkey_forframes:
 61+  8052 21 08 5C         ld hl,23560         ; LAST K system variable.
 62+  8055 36 00            ld (hl),0           ; put null value there.
 63+  8057 47               ld b,a              ; number of frames to wait
 64+  8058              utilities_waitforkey_forframes0:
 65+  8058 7E               ld a,(hl)           ; new value of LAST K.
 66+  8059 FE 00            cp 0                ; is it still zero?
 67+  805B 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 68+  805D 1E 01            ld e,1              ; set the pressed flag
 69+  805F C9               ret                 ; key was pressed.
 70+  8060              utilities_waitforkey_forframes1:
 71+  8060 76               halt                ; wait for frame
 72+  8061 76               halt                ; wait for frame
 73+  8062 10 F4            djnz utilities_waitforkey_forframes0 ; loop again
 74+  8064 1E 00            ld e,0              ; nothing pressed in time
 75+  8066 C9               ret
 76+  8067
 77+  8067              ;
 78+  8067              ; Clears the screen
 79+  8067              ; Inputs:
 80+  8067              ; a - attribute colour
 81+  8067              utilities_clearscreen:
 82+  8067 76               halt
 83+  8068 21 00 58         ld hl,22528         ; attr
 84+  806B 11 01 58         ld de,22529         ; attr+1
 85+  806E 01 FF 02         ld bc,767
 86+  8071 77               ld (hl),a
 87+  8072 ED B0            ldir
 88+  8074
 89+  8074 21 00 40         ld hl, 16384        ;pixels
 90+  8077 11 01 40         ld de, 16385        ;pixels + 1
 91+  807A 01 FF 17         ld bc, 6143         ;pixels area length - 1
 92+  807D 36 00            ld (hl), 0          ;set first byte to '0'
 93+  807F ED B0            ldir                ;copy bytes
 94+  8081
 95+  8081 C9               ret
 96+  8082
# file closed: utilities.asm
 22   8082                  include "strings.asm"
# file opened: strings.asm
  1+  8082              string_score1:
  2+  8082 04 00 53 43      defb 4,0,'SCORE1',255
  2+  8086 4F 52 45 31
  2+  808A FF
  3+  808B              string_scorenumbers1:
  4+  808B 04 01 30 30      defb 4,1,'000000',255
  4+  808F 30 30 30 30
  4+  8093 FF
  5+  8094              string_company:
  6+  8094 0F 00 45 4E      defb 15,0,'ENV',255
  6+  8098 56 FF
  7+  809A              string_credits:
  8+  809A 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  809E 41 59 45 52
  8+  80A2 20 31 FF
  9+  80A5              string_score2:
 10+  80A5 16 00 53 43      defb 22,0,'SCORE2',255
 10+  80A9 4F 52 45 32
 10+  80AD FF
 11+  80AE              string_scorenumbers2:
 12+  80AE 16 01 30 30      defb 22,1,'000000',255
 12+  80B2 30 30 30 30
 12+  80B6 FF
 13+  80B7              string_titlescreen_copyright:
 14+  80B7 04 16 7F 20      defb 4,22, 127,' 1982 AW ZILEC ELC LTD',255
 14+  80BB 31 39 38 32
 14+  80BF 20 41 57 20
 14+  80C3 5A 49 4C 45
 14+  80C7 43 20 45 4C
 14+  80CB 43 20 4C 54
 14+  80CF 44 FF
 15+  80D1
 16+  80D1
 17+  80D1              string_alttitlescreen_1:
 18+  80D1 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  80D5 45 44 49 54
 18+  80D9 53 20 31 FF
 19+  80DD              string_alttitlescreen_2:
 20+  80DD 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  80E1 20 20 20 20
 20+  80E5 20 20 20 20
 20+  80E9 20 54 48 45
 20+  80ED 20 4F 42 4A
 20+  80F1 45 43 54 FE
 21+  80F5 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  80F9 20 20 20 20
 21+  80FD 20 20 20 20
 21+  8101 4F 46 20 54
 21+  8105 48 49 53 20
 21+  8109 47 41 4D 45
 21+  810D FE
 22+  810E 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  8112 20 20 20 20
 22+  8116 20 20 20 49
 22+  811A 53 20 54 4F
 22+  811E 20 44 49 47
 22+  8122 20 44 4F 57
 22+  8126 4E FE
 23+  8128 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  812C 20 20 20 20
 23+  8130 20 20 54 4F
 23+  8134 20 54 48 45
 23+  8138 20 42 4F 54
 23+  813C 54 4F 4D 20
 23+  8140 50 49 54 FE
 24+  8144 00 06 20 20      defb 0,6,'               AND',254
 24+  8148 20 20 20 20
 24+  814C 20 20 20 20
 24+  8150 20 20 20 20
 24+  8154 20 41 4E 44
 24+  8158 FE
 25+  8159 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  815D 20 20 20 20
 25+  8161 20 20 43 4F
 25+  8165 4C 4C 45 43
 25+  8169 54 20 41 54
 25+  816D 20 4C 45 41
 25+  8171 53 54 FE
 26+  8174 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  8178 20 20 20 20
 26+  817C 20 20 20 4F
 26+  8180 4E 45 20 4C
 26+  8184 41 52 47 45
 26+  8188 20 4A 45 57
 26+  818C 45 4C FE
 27+  818F 00 09 20 20      defb 0,9,'              THEN',254
 27+  8193 20 20 20 20
 27+  8197 20 20 20 20
 27+  819B 20 20 20 20
 27+  819F 54 48 45 4E
 27+  81A3 FE
 28+  81A4 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  81A8 20 20 20 20
 28+  81AC 20 20 20 52
 28+  81B0 45 54 55 52
 28+  81B4 4E 20 54 4F
 28+  81B8 20 53 48 49
 28+  81BC 50 FE
 29+  81BE 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  81C2 20 20 20 20
 29+  81C6 20 20 20 54
 29+  81CA 48 52 55 20
 29+  81CE 55 50 50 45
 29+  81D2 52 20 50 49
 29+  81D6 54 FF
 30+  81D8              string_alttitlescreen_3:
 31+  81D8 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  81DC 20 20 53 49
 31+  81E0 4E 47 4C 45
 31+  81E4 20 42 4F 4E
 31+  81E8 55 53 20 20
 31+  81EC 35 30 30 30
 31+  81F0 20 50 4F 49
 31+  81F4 4E 54 53 FE
 32+  81F8 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  81FC 20 20 20 20
 32+  8200 43 4F 4C 4C
 32+  8204 45 43 54 20
 32+  8208 31 20 4C 41
 32+  820C 52 47 45 20
 32+  8210 4A 45 57 45
 32+  8214 4C FE
 33+  8216 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  821A 20 20 20 20
 33+  821E 20 41 4E 44
 33+  8222 20 52 45 54
 33+  8226 55 52 4E 20
 33+  822A 54 4F 20 53
 33+  822E 48 49 50 FE
 34+  8232 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  8236 20 20 44 4F
 34+  823A 55 42 4C 45
 34+  823E 20 42 4F 4E
 34+  8242 55 53 20 20
 34+  8246 31 30 30 30
 34+  824A 30 20 50 4F
 34+  824E 49 4E 54 53
 34+  8252 FE
 35+  8253 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  8257 20 20 43 4F
 35+  825B 4C 4C 45 43
 35+  825F 54 20 41 4C
 35+  8263 4C 20 33 20
 35+  8267 4C 41 52 47
 35+  826B 45 20 4A 45
 35+  826F 57 45 4C 53
 35+  8273 FE
 36+  8274 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  8278 20 20 20 20
 36+  827C 20 4F 52 20
 36+  8280 20 20 41 4C
 36+  8284 4C 20 34 20
 36+  8288 53 4D 41 4C
 36+  828C 4C 20 4A 45
 36+  8290 57 45 4C 53
 36+  8294 FE
 37+  8295 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  8299 20 20 54 52
 37+  829D 49 50 4C 45
 37+  82A1 20 42 4F 4E
 37+  82A5 55 53 20 20
 37+  82A9 31 35 30 30
 37+  82AD 30 20 50 4F
 37+  82B1 49 4E 54 53
 37+  82B5 FE
 38+  82B6 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  82BA 20 20 20 20
 38+  82BE 20 43 4F 4C
 38+  82C2 4C 45 43 54
 38+  82C6 20 41 4C 4C
 38+  82CA 20 37 20 4A
 38+  82CE 45 57 45 4C
 38+  82D2 53 FF
 39+  82D4
 40+  82D4              string_lifescreen_player:
 41+  82D4 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  82D8 4C 41 59 45
 41+  82DC 52 20 31 20
 41+  82E0 FF
 42+  82E1              string_lifescreen_lives:
 43+  82E1 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  82E5 4D 45 4E 20
 43+  82E9 4C 45 46 54
 43+  82ED FF
 44+  82EE              string_lifescreen_lastman:
 45+  82EE 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  82F2 53 54 20 4D
 45+  82F6 41 4E FF
 46+  82F9
 47+  82F9              string_gameoverscreen_gameover:
 48+  82F9 0C 06 47 41      defb 12,6,'GAME OVER',255
 48+  82FD 4D 45 20 4F
 48+  8301 56 45 52 FF
 49+  8305              string_gameoverscreen_copyright:
 50+  8305 05 12 7F 20      defb 5,18,127,' 1982 AW ZILEC ELC LTD',255
 50+  8309 31 39 38 32
 50+  830D 20 41 57 20
 50+  8311 5A 49 4C 45
 50+  8315 43 20 45 4C
 50+  8319 43 20 4C 54
 50+  831D 44 FF
 51+  831F              string_gameoverscreen_bestscores:
 52+  831F 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  8323 53 54 20 53
 52+  8327 43 4F 52 45
 52+  832B 53 20 54 4F
 52+  832F 44 41 59 FF
 53+  8333              string_gameover_credits:
 54+  8333 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  8337 45 44 49 54
 54+  833B 53 20 30 FF
 55+  833F
 56+  833F              ;
 57+  833F              ; Prints specified string
 58+  833F              ; Inputs:
 59+  833F              ; de: pointer to string
 60+  833F              ; bc: length of string
 61+  833F              ;
 62+  833F              ; Print String Data
 63+  833F              ; First two bytes of string contain X and Y char position, then the string
 64+  833F              ; Individual strings are terminated with 0xFE
 65+  833F              ; End of data is terminated with 0xFF
 66+  833F              ; HL: Address of string
 67+  833F              ;
 68+  833F 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
 69+  8340 23                                   INC HL                          ; Increase HL to the next memory location
 70+  8341 56                                   LD D,(HL)                       ; Fetch the Y coordinate
 71+  8342 23                                   INC HL                          ; Increase HL to the next memory location
 72+  8343 CD 56 83                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
 73+  8346 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
 74+  8347 23                                   INC HL                          ; Increase HL to the next character
 75+  8348 FE FE                                CP 0xFE                         ; Compare with 0xFE
 76+  834A 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
 77+  834C D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
 78+  834D E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
 79+  834E CD 66 83                             CALL Print_Char                 ; Print the character
 80+  8351 E1                                   POP HL                          ; Retrieve HL back off the stack
 81+  8352 1C                                   INC E                           ; Go to the next screen address
 82+  8353 18 F1                                JR string_print_0               ; Loop back to print next character
 83+  8355 C9                                   RET
 84+  8356
 85+  8356              ; Get screen address
 86+  8356              ; D = Y character position
 87+  8356              ; E = X character position
 88+  8356              ; Returns address in DE
 89+  8356              ;
 90+  8356 7A           string_getcharaddress:       LD A,D
 91+  8357 E6 07                                AND %00000111
 92+  8359 1F                                   RRA
 93+  835A 1F                                   RRA
 94+  835B 1F                                   RRA
 95+  835C 1F                                   RRA
 96+  835D B3                                   OR E
 97+  835E 5F                                   LD E,A
 98+  835F 7A                                   LD A,D
 99+  8360 E6 18                                AND %00011000
100+  8362 F6 40                                OR %01000000
101+  8364 57                                   LD D,A
102+  8365 C9                                   RET                             ; Returns screen address in DE
103+  8366
104+  8366              ; Print a single character out
105+  8366              ; A:  Character to print
106+  8366              ; DE: Screen address to print character at
107+  8366              ;
108+  8366 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
109+  8369 06 00                                LD B,0                          ; Set BC to A
110+  836B 4F                                   LD C,A
111+  836C E6 FF                                AND 0xFF                        ; Clear the carry bit
112+  836E CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
113+  8370 CB 10                                RL B
114+  8372 CB 11                                RL C
115+  8374 CB 10                                RL B
116+  8376 CB 11                                RL C
117+  8378 CB 10                                RL B
118+  837A 09                                   ADD HL,BC                       ; Get the character address in HL
119+  837B 0E 08                                LD C,8                          ; Loop counter
120+  837D D5                                   PUSH DE
121+  837E 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
122+  837F 12                                   LD (DE),A                       ; Stick A onto the screen
123+  8380 14                                   INC D                           ; Goto next line on screen
124+  8381 2C                                   INC L                           ; Goto next byte of character
125+  8382 0D                                   DEC C                           ; Decrease the loop counter
126+  8383 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
127+  8385 D1                                   POP DE
128+  8386 C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   8387                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  8387              buffer_buffer:
  2+  8387 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A087
  4+  A087              buffer_attr_buffer:
  5+  A087 00 00 00...      defs 928                    ; attrs buffer area
  6+  A427
  7+  A427              buffer_tmp:
  8+  A427 00 00            defb 0,0                    ; temp area
  9+  A429
 10+  A429              buffer_updatedlines:
 11+  A429 FF FF FF...      defs 21,255
 12+  A43E
 13+  A43E              buffer_updateall:
 14+  A43E 00               defb 0
 15+  A43F
 16+  A43F              ;
 17+  A43F              ; Stores a line number in the update list
 18+  A43F              ; Inputs:
 19+  A43F              ; a - row number
 20+  A43F              buffer_marklineforupdate:
 21+  A43F 5F               ld e,a                          ; store in e
 22+  A440 06 15            ld b,21
 23+  A442 21 29 A4         ld hl,buffer_updatedlines
 24+  A445              buffer_marklineforupdate0:
 25+  A445 7E               ld a,(hl)                       ; get the line stored in updated lines
 26+  A446 BB               cp e                            ; is this the same as the row number passed in?
 27+  A447 C8               ret z                           ; if so, don't need to do anything
 28+  A448 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 29+  A44A C2 4F A4         jp nz,buffer_marklineforupdate1 ; if not, move to next
 30+  A44D 73               ld (hl),e                       ; if it is, this spot is empty, so store the row number
 31+  A44E C9               ret                             ; and finish
 32+  A44F              buffer_marklineforupdate1:
 33+  A44F 23               inc hl
 34+  A450 10 F3            djnz buffer_marklineforupdate0
 35+  A452 C9               ret
 36+  A453
 37+  A453              ;
 38+  A453              ; Zeroes the updated lines list
 39+  A453              ;
 40+  A453              buffer_clearlist:
 41+  A453 06 15            ld b,21
 42+  A455 21 29 A4         ld hl,buffer_updatedlines
 43+  A458              buffer_clearlist0:
 44+  A458 36 FF            ld (hl),255
 45+  A45A 23               inc hl
 46+  A45B 10 FB            djnz buffer_clearlist0
 47+  A45D C9               ret
 48+  A45E
 49+  A45E              ;
 50+  A45E              ; Copies the buffer to the screen. Use stack.
 51+  A45E              ; Inputs:
 52+  A45E              ; a - row number to display - 0 is first line
 53+  A45E              ;
 54+  A45E              buffer_bufferlinetoscreen:
 55+  A45E 4F               ld c,a                          ; store a
 56+  A45F ED 5B 8C A5      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 57+  A463 83               add a,e                       ; add the row number
 58+  A464 11 00 01         ld de,256
 59+  A467 CD 3A 80         call utilities_multiply
 60+  A46A 54 5D            ld de,hl
 61+  A46C 21 87 83         ld hl,buffer_buffer
 62+  A46F 19               add hl,de                   ; add the offset
 63+  A470 79               ld a,c                      ; get original row back
 64+  A471 ED 73 CF A4      ld (buffer_bufferlinetoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
 65+  A475 D9               exx
 66+  A476 0E 00            ld c,0                      ; zero horizontal
 67+  A478 47               ld b,a                      ; load the row number into vertical coord
 68+  A479 04               inc b
 69+  A47A 04               inc b                       ; move forward 2 to allow for scores
 70+  A47B CD 73 A6         call screen_getcelladdress  ; get the memory into de
 71+  A47E 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
 72+  A481 19               add hl,de
 73+  A482              buffer_bufferlinetoscreen0:
 74+  A482 D9               exx                         ; hl is now buffer
 75+  A483 23               inc hl
 76+  A484 23               inc hl                      ; move hl forward 2 to skip first two blocks
 77+  A485 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
 78+  A486 F1               pop af
 79+  A487 C1               pop bc
 80+  A488 D1               pop de
 81+  A489 DD E1            pop ix
 82+  A48B D9               exx                         ; hl is now screen
 83+  A48C 08               ex af,af'
 84+  A48D F1               pop af
 85+  A48E C1               pop bc
 86+  A48F D1               pop de
 87+  A490 F9               ld sp,hl                    ; sp pointing at screen
 88+  A491 D5               push de
 89+  A492 C5               push bc
 90+  A493 F5               push af
 91+  A494 08               ex af,af'
 92+  A495 D9               exx                         ; hl is now buffer
 93+  A496 DD E5            push ix
 94+  A498 D5               push de
 95+  A499 C5               push bc
 96+  A49A F5               push af
 97+  A49B 1E 0E            ld e,14                    ; do another fourteen for right hand side
 98+  A49D 16 00            ld d,0
 99+  A49F 19               add hl,de
100+  A4A0 F9               ld sp,hl                    ; sp pointing at buffer
101+  A4A1 F1               pop af
102+  A4A2 C1               pop bc
103+  A4A3 D1               pop de
104+  A4A4 DD E1            pop ix
105+  A4A6                  ;pop ix
106+  A4A6 D9               exx                         ; hl is now screen
107+  A4A7 08               ex af,af'
108+  A4A8 1E 0E            ld e,14
109+  A4AA 16 00            ld d,0
110+  A4AC 19               add hl,de
111+  A4AD F1               pop af
112+  A4AE C1               pop bc
113+  A4AF D1               pop de
114+  A4B0                  ;pop iy
115+  A4B0 F9               ld sp,hl                    ; sp pointing at screen
116+  A4B1                  ;push iy
117+  A4B1 D5               push de
118+  A4B2 C5               push bc
119+  A4B3 F5               push af
120+  A4B4 08               ex af,af'
121+  A4B5 D9               exx                         ; hl is now buffer
122+  A4B6 DD E5            push ix
123+  A4B8 D5               push de
124+  A4B9 C5               push bc
125+  A4BA F5               push af
126+  A4BB 1E 10            ld e,16
127+  A4BD 16 00            ld d,0
128+  A4BF 19               add hl,de
129+  A4C0 D9               exx                         ; hl is now screen
130+  A4C1 1E 0E            ld e,14
131+  A4C3 16 00            ld d,0
132+  A4C5 ED 52            sbc hl,de
133+  A4C7 24               inc h
134+  A4C8 7C               ld a,h
135+  A4C9 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
136+  A4CB C2 82 A4         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
137+  A4CE              buffer_bufferlinetoscreen1:
138+  A4CE 31 00 00         ld sp,0
139+  A4D1 D9               exx
140+  A4D2 C9               ret
141+  A4D3
142+  A4D3              ;
143+  A4D3              ; Copies the buffer to the screen for updated lines. Use stack.
144+  A4D3              ; Inputs: none
145+  A4D3              ;
146+  A4D3              buffer_buffertoscreen:
147+  A4D3 3A 3E A4         ld a,(buffer_updateall)      ; get the all update flag
148+  A4D6 FE 00            cp 0
149+  A4D8 CA E4 A4         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
150+  A4DB CD 05 A5         call buffer_allbuffertoscreen ; otherwise, draw whole screen
151+  A4DE 21 3E A4         ld hl,buffer_updateall
152+  A4E1 36 00            ld (hl),0                    ; reset flag
153+  A4E3 C9               ret
154+  A4E4              buffer_buffertoscreen2:
155+  A4E4 06 15            ld b,21
156+  A4E6 FD 21 29 A4      ld iy,buffer_updatedlines    ; the location of the updated lines
157+  A4EA              buffer_buffertoscreen0:
158+  A4EA FD 7E 00         ld a,(iy)
159+  A4ED FE FF            cp 255
160+  A4EF CA 01 A5         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
161+  A4F2 C5               push bc
162+  A4F3 FD E5            push iy
163+  A4F5 F3               di
164+  A4F6 CD 5E A4         call buffer_bufferlinetoscreen
165+  A4F9 FB               ei
166+  A4FA FD E1            pop iy
167+  A4FC C1               pop bc
168+  A4FD FD 23            inc iy
169+  A4FF 10 E9            djnz buffer_buffertoscreen0
170+  A501              buffer_buffertoscreen1:
171+  A501 CD 19 A5         call buffer_buffertoattrsfast
172+  A504 C9               ret
173+  A505
174+  A505              ;
175+  A505              ; Copies the buffer to the screen. Use stack.
176+  A505              ; Inputs: none
177+  A505              ;
178+  A505              buffer_allbuffertoscreen:
179+  A505 06 15            ld b,21
180+  A507 3E 00            ld a,0
181+  A509              buffer_allbuffertoscreen0:
182+  A509 C5               push bc
183+  A50A F5               push af
184+  A50B F3               di
185+  A50C CD 5E A4         call buffer_bufferlinetoscreen
186+  A50F FB               ei
187+  A510 F1               pop af
188+  A511 C1               pop bc
189+  A512 3C               inc a
190+  A513 10 F4            djnz buffer_allbuffertoscreen0
191+  A515
192+  A515 CD 19 A5         call buffer_buffertoattrsfast
193+  A518 C9               ret
194+  A519
195+  A519              ;
196+  A519              ; Copies the attrs buffer to screen with the stack
197+  A519              ;
198+  A519              buffer_buffertoattrsfast:
199+  A519 ED 73 88 A5      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
200+  A51D 3A 8C A5         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
201+  A520 11 20 00         ld de,32
202+  A523 CD 3A 80         call utilities_multiply
203+  A526 54 5D            ld de,hl
204+  A528 21 87 A0         ld hl,buffer_attr_buffer
205+  A52B 19               add hl,de                       ; add the offset, start of attr buffer now in hl
206+  A52C D9               exx
207+  A52D 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
208+  A530 FD 21 27 A4      ld iy,buffer_tmp
209+  A534 FD 36 00 15      ld (iy),21              ; number of times to loop
210+  A538              buffer_buffertoattrsfast0:
211+  A538 D9               exx                         ; hl is now buffer
212+  A539 23               inc hl
213+  A53A 23               inc hl                      ; move hl forward 2 to skip first two blocks
214+  A53B F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
215+  A53C F1               pop af
216+  A53D C1               pop bc
217+  A53E D1               pop de
218+  A53F DD E1            pop ix
219+  A541 D9               exx                         ; hl is now screen
220+  A542 08               ex af,af'
221+  A543 F1               pop af
222+  A544 C1               pop bc
223+  A545 D1               pop de
224+  A546 F9               ld sp,hl                    ; sp pointing at screen
225+  A547 D5               push de
226+  A548 C5               push bc
227+  A549 F5               push af
228+  A54A 08               ex af,af'
229+  A54B D9               exx                         ; hl is now buffer
230+  A54C DD E5            push ix
231+  A54E D5               push de
232+  A54F C5               push bc
233+  A550 F5               push af
234+  A551 1E 0E            ld e,14                    ; do another fourteen for right hand side
235+  A553 16 00            ld d,0
236+  A555 19               add hl,de
237+  A556 F9               ld sp,hl                    ; sp pointing at buffer
238+  A557 F1               pop af
239+  A558 C1               pop bc
240+  A559 D1               pop de
241+  A55A DD E1            pop ix
242+  A55C D9               exx                         ; hl is now screen
243+  A55D 08               ex af,af'
244+  A55E 1E 0E            ld e,14
245+  A560 16 00            ld d,0
246+  A562 19               add hl,de
247+  A563 F1               pop af
248+  A564 C1               pop bc
249+  A565 D1               pop de
250+  A566 F9               ld sp,hl                    ; sp pointing at screen
251+  A567 D5               push de
252+  A568 C5               push bc
253+  A569 F5               push af
254+  A56A 08               ex af,af'
255+  A56B D9               exx                         ; hl is now buffer
256+  A56C DD E5            push ix
257+  A56E D5               push de
258+  A56F C5               push bc
259+  A570 F5               push af
260+  A571 1E 10            ld e,16
261+  A573 16 00            ld d,0
262+  A575 19               add hl,de
263+  A576 D9               exx                         ; hl is now screen
264+  A577 11 12 00         ld de,18
265+  A57A 19               add hl,de
266+  A57B FD 7E 00         ld a,(iy)
267+  A57E 3D               dec a
268+  A57F FE 00            cp 0
269+  A581 FD 77 00         ld (iy),a
270+  A584 C2 38 A5         jp nz,buffer_buffertoattrsfast0 ; do another row
271+  A587              buffer_buffertoattrsfast1:
272+  A587 31 00 00         ld sp,0
273+  A58A D9               exx
274+  A58B C9               ret
# file closed: screen/buffer.asm
 24   A58C                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A58C              screen_offset:
  2+  A58C 00               defb 0                      ; offset from top of screen in lines
  3+  A58D
  4+  A58D              screen_tmp:
  5+  A58D 00 00            defb 0,0                      ; temporary memory
  6+  A58F
  7+  A58F              screen_setscorecolours:
  8+  A58F 21 CE AE         ld hl,score_colours
  9+  A592 11 00 58         ld de,22528                     ; attrs here
 10+  A595 01 40 00         ld bc,64
 11+  A598 ED B0            ldir
 12+  A59A C9               ret
 13+  A59B
 14+  A59B              screen_sethighscorecolours:
 15+  A59B 21 0E AF         ld hl,high_score_colours
 16+  A59E 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A5A1 01 20 00         ld bc,32
 18+  A5A4 ED B0            ldir
 19+  A5A6 C9               ret
 20+  A5A7
 21+  A5A7              ; Draw the screen
 22+  A5A7              ; Inputs:
 23+  A5A7              ; none
 24+  A5A7              ; Notes:
 25+  A5A7              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A5A7              screen_draw:
 27+  A5A7                  ;call clear_screen
 28+  A5A7 0E 00            ld c,0                      ; horiz
 29+  A5A9 06 00            ld b,0                      ; vert, 0 at top
 30+  A5AB DD 21 90 A9      ld ix,level01               ; point ix at level data
 31+  A5AF FD 21 87 A0      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A5B3              screen_draw0:
 33+  A5B3 DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A5B6 C5               push bc                     ; store bc, contains loop count
 35+  A5B7 CD 16 A7         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A5BA 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A5BB FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A5BE DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A5C1 CD 0B A7         call screen_getblock        ; get the block data into hl
 40+  A5C4 CD F1 A6         call screen_showchar        ; show this character here
 41+  A5C7 C1               pop bc                      ; get the loop counter back
 42+  A5C8 DD 23            inc ix                      ; increment level location
 43+  A5CA FD 23            inc iy                      ; increment attr location
 44+  A5CC 0C               inc c                       ; increment horiz
 45+  A5CD 79               ld a,c
 46+  A5CE FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A5D0 C2 B3 A5         jp nz,screen_draw0          ; if not, loop
 48+  A5D3 0E 00            ld c,0                      ; if so, reset horiz
 49+  A5D5 04               inc b                       ; increment vertical
 50+  A5D6 78               ld a,b
 51+  A5D7 FE 1D            cp 29                       ; check if at bottom
 52+  A5D9 C2 B3 A5         jp nz,screen_draw0          ; if not, loop
 53+  A5DC 21 8D A5         ld hl, screen_tmp
 54+  A5DF 36 09            ld (hl),9                   ; load the block number into memory
 55+  A5E1 DD 21 30 AD      ld ix,level01rocks          ; rock memory
 56+  A5E5 CD 43 A6         call screen_initobjects     ; draw rocks
 57+  A5E8 21 8D A5         ld hl, screen_tmp
 58+  A5EB 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A5ED DD 21 30 AE      ld ix,level01missiles       ; missile memory
 60+  A5F1 CD 43 A6         call screen_initobjects     ; draw missiles
 61+  A5F4 21 8D A5         ld hl, screen_tmp
 62+  A5F7 36 08            ld (hl),08                  ; load the block number into memory
 63+  A5F9 DD 21 A9 AE      ld ix,level01diamonds       ; diamond memory
 64+  A5FD CD 43 A6         call screen_initobjects     ; draw diamonds
 65+  A600 21 8D A5         ld hl, screen_tmp
 66+  A603 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A605 DD 21 B9 AE      ld ix,level01gems           ; gems memory
 68+  A609 CD 43 A6         call screen_initobjects     ; draw gems
 69+  A60C CD 10 A6         call screen_setuptext       ; draws text on the screen
 70+  A60F C9               ret
 71+  A610
 72+  A610              ;
 73+  A610              ; Sets up text on the screen
 74+  A610              ;
 75+  A610              screen_setuptext:
 76+  A610 CD DB B9         call scores_showtable
 77+  A613 CD 9B A5         call screen_sethighscorecolours
 78+  A616 21 82 80         ld hl, string_score1
 79+  A619 CD 3F 83         call string_print
 80+  A61C 21 8B 80         ld hl, string_scorenumbers1
 81+  A61F CD 3F 83         call string_print
 82+  A622 21 94 80         ld hl, string_company
 83+  A625 CD 3F 83         call string_print
 84+  A628 21 A5 80         ld hl, string_score2
 85+  A62B CD 3F 83         call string_print
 86+  A62E 21 AE 80         ld hl, string_scorenumbers2
 87+  A631 CD 3F 83         call string_print
 88+  A634 21 9A 80         ld hl, string_credits
 89+  A637 CD 3F 83         call string_print
 90+  A63A CD 8F A5         call screen_setscorecolours
 91+  A63D C9               ret
 92+  A63E
 93+  A63E              ;
 94+  A63E              ; Sets a line of colours
 95+  A63E              ; Inputs:
 96+  A63E              ; a - colour to set
 97+  A63E              ; b - number to set
 98+  A63E              ; de - start memory location
 99+  A63E              ;
100+  A63E              screen_setcolours:
101+  A63E 12               ld (de),a
102+  A63F 13               inc de
103+  A640 10 FC            djnz screen_setcolours
104+  A642 C9               ret
105+  A643
106+  A643              ;
107+  A643              ; Draw initial object positions
108+  A643              ; Inputs:
109+  A643              ; ix - memory location of objects
110+  A643              ; a - graphic
111+  A643              screen_initobjects:
112+  A643 DD 4E 00         ld c,(ix)                   ; get the horiz coord
113+  A646 79               ld a,c
114+  A647 FE FF            cp 255
115+  A649 CA 72 A6         jp z,screen_initobjects2
116+  A64C DD 23            inc ix                      ; move to next
117+  A64E DD 46 00         ld b,(ix)                   ; get the vert coord
118+  A651 DD 23            inc ix
119+  A653 CD 84 A6         call screen_getcellattradress ; get the memory address of b,c attr into de
120+  A656 D5               push de
121+  A657 3A 8D A5         ld a,(screen_tmp)                  ; get the block number back
122+  A65A CD 16 A7         call screen_getattr         ; get the memory location for this cell's attr into hl
123+  A65D D1               pop de
124+  A65E 7E               ld a,(hl)                   ; get the attr value at the address
125+  A65F 12               ld (de),a                   ; load the attr into memory
126+  A660 3A 8D A5         ld a,(screen_tmp)                  ; get the block number back
127+  A663 CD 0B A7         call screen_getblock        ; get the block data into hl
128+  A666 CD F1 A6         call screen_showchar        ; show this character here
129+  A669
130+  A669              screen_initobjects1:
131+  A669 DD 23            inc ix                      ; move past state
132+  A66B DD 23            inc ix
133+  A66D DD 23            inc ix                      ; move past mem
134+  A66F C3 43 A6         jp screen_initobjects
135+  A672              screen_initobjects2:
136+  A672 C9               ret
137+  A673
138+  A673
139+  A673              ;
140+  A673              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
141+  A673              ; Inputs:
142+  A673              ; bc: coords
143+  A673              ; Outputs:
144+  A673              ; de: memory location
145+  A673              ;
146+  A673              screen_getcelladdress:
147+  A673 78               ld a,b      ; vertical position.
148+  A674 E6 18            and 24      ; which segment, 0, 1 or 2?
149+  A676 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
150+  A678 57               ld d,a      ; this is our high byte.
151+  A679 78               ld a,b      ; what was that vertical position again?
152+  A67A E6 07            and 7       ; which row within segment?
153+  A67C 0F               rrca        ; multiply row by 32.
154+  A67D 0F               rrca
155+  A67E 0F               rrca
156+  A67F 5F               ld e,a      ; low byte.
157+  A680 79               ld a,c      ; add on y coordinate.
158+  A681 83               add a,e     ; mix with low byte.
159+  A682 5F               ld e,a      ; address of screen position in de.
160+  A683 C9               ret
161+  A684
162+  A684              ;
163+  A684              ; Calculate buffer address of attribute for character at (b, c).
164+  A684              ; Inputs:
165+  A684              ; bc: coords
166+  A684              ; Outputs:
167+  A684              ; de: memory location
168+  A684              ;
169+  A684              screen_getcellattradress:
170+  A684 11 87 A0         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
171+  A687 69               ld l,c      ; x position.
172+  A688 26 00            ld h,0      ; 0 h
173+  A68A 19               add hl,de
174+  A68B 54 5D            ld de,hl    ; horiz done
175+  A68D 78               ld a,b      ; do vert
176+  A68E D5               push de
177+  A68F C5               push bc
178+  A690 11 20 00         ld de,32
179+  A693 CD 3A 80         call utilities_multiply
180+  A696 C1               pop bc
181+  A697 D1               pop de
182+  A698 19               add hl,de
183+  A699 54 5D            ld de,hl    ; vert done
184+  A69B C9               ret
185+  A69C
186+  A69C              ;
187+  A69C              ; Calculate buffer address of attribute for character at (b, c).
188+  A69C              ; Inputs:
189+  A69C              ; bc: coords
190+  A69C              ; Outputs:
191+  A69C              ; de: memory location
192+  A69C              ;
193+  A69C              screen_getscreenattradress:
194+  A69C 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
195+  A69F 69               ld l,c      ; x position.
196+  A6A0 26 00            ld h,0      ; 0 h
197+  A6A2 19               add hl,de
198+  A6A3 54 5D            ld de,hl    ; horiz done
199+  A6A5 78               ld a,b      ; do vert
200+  A6A6 D5               push de
201+  A6A7 C5               push bc
202+  A6A8 11 20 00         ld de,32
203+  A6AB CD 3A 80         call utilities_multiply
204+  A6AE C1               pop bc
205+  A6AF D1               pop de
206+  A6B0 19               add hl,de
207+  A6B1 54 5D            ld de,hl    ; vert done
208+  A6B3 C9               ret
209+  A6B4
210+  A6B4              ;
211+  A6B4              ; Gets the attr memory location for a screen coord
212+  A6B4              ; Will overwrite bc
213+  A6B4              ; Inputs:
214+  A6B4              ; bc - screen coords
215+  A6B4              ; Outputs:
216+  A6B4              ; de - memory location
217+  A6B4              ; bc - character coords
218+  A6B4              ;
219+  A6B4              screen_getattraddressfromscreencoords:
220+  A6B4 78               ld a,b                          ; get the player block coords of current block
221+  A6B5 E6 F8            and 248                         ; find closest multiple of eight
222+  A6B7 0F               rrca
223+  A6B8 0F               rrca
224+  A6B9 0F               rrca                ; divide by 8
225+  A6BA 47               ld b,a
226+  A6BB 79               ld a,c
227+  A6BC 48               ld c,b                         ; swap b and c
228+  A6BD E6 F8            and 248
229+  A6BF 0F               rrca
230+  A6C0 0F               rrca
231+  A6C1 0F               rrca                ; divide by 8
232+  A6C2 47               ld b,a
233+  A6C3 CD 84 A6         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
234+  A6C6 C9               ret
235+  A6C7
236+  A6C7
237+  A6C7              ; Gets the nearest cell coords for a screen coord
238+  A6C7              ; Will overwrite bc
239+  A6C7              ; Inputs:
240+  A6C7              ; bc - screen coords
241+  A6C7              ; Outputs:
242+  A6C7              ; bc - character coords
243+  A6C7              ;
244+  A6C7              screen_getcharcoordsfromscreencoords:
245+  A6C7 78               ld a,b                          ; get the player block coords of current block
246+  A6C8 E6 F8            and 248                         ; find closest multiple of eight
247+  A6CA 0F               rrca
248+  A6CB 0F               rrca
249+  A6CC 0F               rrca                ; divide by 8
250+  A6CD 47               ld b,a
251+  A6CE 79               ld a,c
252+  A6CF 48               ld c,b                         ; swap b and c
253+  A6D0 E6 F8            and 248
254+  A6D2 0F               rrca
255+  A6D3 0F               rrca
256+  A6D4 0F               rrca                ; divide by 8
257+  A6D5 47               ld b,a
258+  A6D6 C9               ret
259+  A6D7
260+  A6D7              ; Gets the screen coords for a cell coord
261+  A6D7              ; Will overwrite bc
262+  A6D7              ; Inputs:
263+  A6D7              ; bc - char coords
264+  A6D7              ; Outputs:
265+  A6D7              ; bc - screen coords
266+  A6D7              ;
267+  A6D7              screen_getscreencoordsfromcharcoords:
268+  A6D7 78               ld a,b                          ; get the player block coords of current block
269+  A6D8 07               rlca
270+  A6D9 07               rlca
271+  A6DA 07               rlca                ; multiply by 8
272+  A6DB 47               ld b,a
273+  A6DC 79               ld a,c
274+  A6DD 48               ld c,b                         ; swap b and c
275+  A6DE 07               rlca
276+  A6DF 07               rlca
277+  A6E0 07               rlca                ; divide by 8
278+  A6E1 47               ld b,a
279+  A6E2 C9               ret
280+  A6E3
281+  A6E3              ;
282+  A6E3              ; Get buffer address for a character at b,c - b vert
283+  A6E3              ; Buffer memory is stored as sequential block
284+  A6E3              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
285+  A6E3              ; Inputs:
286+  A6E3              ; bc - coords
287+  A6E3              ; Outputs:
288+  A6E3              ; de - memory location of first byte
289+  A6E3              screen_getbufferaddress:
290+  A6E3 21 87 83         ld hl, buffer_buffer    ; first get screen buffer start
291+  A6E6 50               ld d,b                  ; then work out vertical offset
292+  A6E7 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
293+  A6E9 19               add hl,de               ; add to base
294+  A6EA 59               ld e,c                  ; then add horizontal offset (c)
295+  A6EB 16 00            ld d,0
296+  A6ED 19               add hl,de               ; add to base
297+  A6EE 54 5D            ld de,hl
298+  A6F0 C9               ret
299+  A6F1
300+  A6F1              ;
301+  A6F1              ; Display character hl at (b, c) to buffer.
302+  A6F1              ; Stored sequentially
303+  A6F1              ; Inputs:
304+  A6F1              ; hl: block address
305+  A6F1              ; bc: coords
306+  A6F1              ;
307+  A6F1              screen_showchar:
308+  A6F1 3E 00            ld a,0
309+  A6F3 E5               push hl
310+  A6F4 CD E3 A6         call screen_getbufferaddress ; get the current screen buffer pointer
311+  A6F7 E1               pop hl
312+  A6F8 06 08            ld b,8              ; number of pixels high.
313+  A6FA              screen_showchar0:
314+  A6FA 7E               ld a,(hl)           ; source graphic.
315+  A6FB 12               ld (de),a           ; transfer to screen.
316+  A6FC 23               inc hl              ; next piece of data.
317+  A6FD E5               push hl             ; store hl
318+  A6FE 62 6B            ld hl,de            ; put de in hl
319+  A700 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
320+  A702 16 00            ld d,0
321+  A704 19               add hl,de              ; add de to hl
322+  A705 54 5D            ld de,hl            ; load back to de
323+  A707 E1               pop hl              ; restore hl
324+  A708
325+  A708 10 F0            djnz screen_showchar0 ; repeat
326+  A70A C9               ret
327+  A70B
328+  A70B
329+  A70B              ;
330+  A70B              ; Get cell graphic.
331+  A70B              ; Inputs:
332+  A70B              ; a: block
333+  A70B              ; Outputs:
334+  A70B              ; hl: memory
335+  A70B              ;
336+  A70B              screen_getblock:
337+  A70B 07               rlca                        ; multiply block number by eight.
338+  A70C 07               rlca
339+  A70D 07               rlca
340+  A70E 5F               ld e,a                      ; displacement to graphic address.
341+  A70F 16 00            ld d,0                      ; no high byte.
342+  A711 21 2E AF         ld hl,sprites               ; address of character blocks.
343+  A714 19               add hl,de                   ; point to block.
344+  A715 C9               ret
345+  A716
346+  A716              ;
347+  A716              ; Get cell attribute.
348+  A716              ; Inputs:
349+  A716              ; a: block
350+  A716              ; Outputs:
351+  A716              ; hl: memory
352+  A716              ;
353+  A716              screen_getattr:
354+  A716 5F               ld e,a                      ; displacement to attribute address.
355+  A717 16 00            ld d,0                      ; no high byte.
356+  A719 21 A6 AF         ld hl,sprite_attrs          ; address of block attributes.
357+  A71C 19               add hl,de                   ; point to attribute.
358+  A71D C9               ret
359+  A71E
# file closed: screen/screen.asm
 25   A71E                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A71E              ;
  2+  A71E              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A71E              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A71E              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A71E              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A71E              ; routine takes care of all the shifting itself. This means that sprite
  7+  A71E              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A71E              ; space they would require in pre-shifted form.
  9+  A71E              ; Inputs:
 10+  A71E              ; hl - sprite data
 11+  A71E              ; bc - screen coords
 12+  A71E              ;
 13+  A71E              sprites_drawsprite7:
 14+  A71E EE 07            xor 7               ; complement last 3 bits.
 15+  A720 3C               inc a               ; add one for luck!
 16+  A721              sprites_drawsprite3:
 17+  A721 CB 11            rl c                ; ...into middle byte...
 18+  A723 CB 12            rl d                ; ...and finally into left character cell.
 19+  A725 3D               dec a               ; count shifts we've done.
 20+  A726 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A728                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A728 79               ld a,c              ; left edge of image is currently in e.
 23+  A729 4A               ld c,d              ; put right edge there instead.
 24+  A72A 57               ld d,a              ; and the left edge back into c.
 25+  A72B 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A72D              sprites_drawsprite:
 27+  A72D ED 43 92 A7      ld (dispx),bc       ; store coords in dispx for now.
 28+  A731 E5               push hl
 29+  A732 CD 70 A7         call sprites_scadd  ; calculate screen address.
 30+  A735 E1               pop hl
 31+  A736 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A738              sprites_drawsprite1:
 33+  A738 08               ex af,af'           ; store loop counter.
 34+  A739 D5               push de             ; store screen address.
 35+  A73A 4E               ld c,(hl)           ; first sprite graphic.
 36+  A73B 23               inc hl              ; increment poiinter to sprite data.
 37+  A73C 22 94 A7         ld (sprtmp),hl      ; store it for later.
 38+  A73F 16 00            ld d,0              ; blank right byte for now.
 39+  A741 78               ld a,b              ; b holds y position.
 40+  A742 E6 07            and 7               ; how are we straddling character cells?
 41+  A744 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A746 FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A748 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A74A A7               and a               ; oops, carry flag is set so clear it.
 45+  A74B              sprites_drawsprite2:
 46+  A74B CB 19            rr c                ; rotate left byte right...
 47+  A74D CB 1A            rr d                ; ...into right byte.
 48+  A74F 3D               dec a               ; one less shift to do.
 49+  A750 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A752              sprites_drawsprite0:
 51+  A752 E1               pop hl              ; pop screen address from stack.
 52+  A753 7E               ld a,(hl)           ; what's there already.
 53+  A754 A9               xor c               ; merge in image data.
 54+  A755 77               ld (hl),a           ; place onto screen.
 55+  A756 23               inc hl
 56+  A757 7E               ld a,(hl)           ; what's already there.
 57+  A758 AA               xor d               ; right edge of sprite image data.
 58+  A759 77               ld (hl),a           ; plonk it on screen.
 59+  A75A 3A 92 A7         ld a,(dispx)        ; vertical coordinate.
 60+  A75D 3C               inc a               ; next line down.
 61+  A75E 32 92 A7         ld (dispx),a        ; store new position.
 62+  A761 2B               dec hl
 63+  A762 11 20 00         ld de,32            ; add 32 to get to the next row
 64+  A765 19               add hl,de           ; add 32
 65+  A766              sprites_drawsprite6:
 66+  A766 EB               ex de,hl            ; screen address in de.
 67+  A767 2A 94 A7         ld hl,(sprtmp)      ; restore graphic address.
 68+  A76A 08               ex af,af'           ; restore loop counter.
 69+  A76B 3D               dec a               ; decrement it.
 70+  A76C C2 38 A7         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 71+  A76F C9               ret                 ; job done.
 72+  A770
 73+  A770              ;
 74+  A770              ; This routine returns a buffer address for (c, b) in de (c vert).
 75+  A770              ; For example: 0,0 will be at memory offset 0
 76+  A770              ; 1,0 (1 down) will be at memory offset 1
 77+  A770              ; 0,7 will be at memory offset 0
 78+  A770              ; 9,1 will be at memory offset 8+1
 79+  A770              ; 8,0 will be at memory offset 256
 80+  A770              ; 9,0 will be at memory offset 257
 81+  A770              ; Outputs:
 82+  A770              ; de - coords
 83+  A770              ;
 84+  A770              sprites_scadd:
 85+  A770 79               ld a,c               ; calculate vertical offset
 86+  A771 E6 F8            and 248             ;  to get nearest multiple of 8
 87+  A773 0F               rrca
 88+  A774 0F               rrca
 89+  A775 0F               rrca                ; divide by 8
 90+  A776 67               ld h,a
 91+  A777 78               ld a,b               ; calculate horizontal offset
 92+  A778 E6 F8            and 248             ;  to get nearest multiple of 8
 93+  A77A 0F               rrca
 94+  A77B 0F               rrca
 95+  A77C 0F               rrca                ; divide by 8
 96+  A77D 6F               ld l,a
 97+  A77E C5               push bc             ; store the screen coords
 98+  A77F 44 4D            ld bc,hl            ; load bc with the character coords
 99+  A781 CD E3 A6         call screen_getbufferaddress
100+  A784 C1               pop bc              ; get back screen coords, de is now memory of character
101+  A785 79               ld a,c              ; now add the vertical within the cell
102+  A786 E6 07            and 7
103+  A788 0F               rrca                ; multiply by 32.
104+  A789 0F               rrca
105+  A78A 0F               rrca
106+  A78B 6F               ld l,a
107+  A78C 26 00            ld h,0
108+  A78E 19               add hl,de
109+  A78F 54 5D            ld de,hl
110+  A791 C9               ret
111+  A792
112+  A792 00           dispx   defb 0           ; general-use coordinates.
113+  A793 00           dispy   defb 0
114+  A794 00 00        sprtmp  defb 0,0           ; sprite temporary address.
115+  A796
# file closed: screen/sprites.asm
 26   A796                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  A796              ;
  2+  A796              ; Draws the title screen
  3+  A796              ;
  4+  A796              titlescreen_show:
  5+  A796 CD 0E A8         call titlescreen_init
  6+  A799 CD B7 A7         call titlescreen_drawtitle
  7+  A79C 3E FA            ld a,250                              ; wait for 200 frames
  8+  A79E CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
  9+  A7A1 7B               ld a,e
 10+  A7A2 FE 01            cp 1                                  ; was anything pressed?
 11+  A7A4 C8               ret z                                 ; end titlescreen if so
 12+  A7A5
 13+  A7A5 CD 21 A8         call titlescreen_alt_init             ; otherwise, draw alt screen
 14+  A7A8 CD D3 A7         call titlescreen_alt_drawtitle
 15+  A7AB 3E FA            ld a,250                              ; wait for 200 frames
 16+  A7AD CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 17+  A7B0 7B               ld a,e
 18+  A7B1 FE 01            cp 1                                  ; was anything pressed?
 19+  A7B3 C2 96 A7         jp nz,titlescreen_show                ; start again if not
 20+  A7B6 C9               ret
 21+  A7B7
 22+  A7B7              ;
 23+  A7B7              ; Draws the iconic logo
 24+  A7B7              ;
 25+  A7B7              titlescreen_drawtitle:
 26+  A7B7 06 66            ld b,102              ; number of points
 27+  A7B9 DD 21 2E A8      ld ix,titlescreen_logo_data
 28+  A7BD              titlescreen_drawtitle0:
 29+  A7BD C5               push bc
 30+  A7BE DD 4E 00         ld c,(ix)                   ; got horiz
 31+  A7C1 DD 23            inc ix
 32+  A7C3 DD 46 00         ld b,(ix)                   ; got vert
 33+  A7C6 DD 23            inc ix
 34+  A7C8 CD 9C A6         call screen_getscreenattradress ; memory in de
 35+  A7CB 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 36+  A7CC 3E 13            ld a,19
 37+  A7CE 12               ld (de),a
 38+  A7CF C1               pop bc
 39+  A7D0 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 40+  A7D2 C9               ret
 41+  A7D3
 42+  A7D3              ;
 43+  A7D3              ; Draws the alternate title screen
 44+  A7D3              ;
 45+  A7D3              titlescreen_alt_drawtitle:
 46+  A7D3 21 D1 80         ld hl,string_alttitlescreen_1
 47+  A7D6 CD 3F 83         call string_print
 48+  A7D9 21 DD 80         ld hl,string_alttitlescreen_2
 49+  A7DC CD 3F 83         call string_print
 50+  A7DF 21 D8 81         ld hl,string_alttitlescreen_3
 51+  A7E2 CD 3F 83         call string_print
 52+  A7E5 06 20            ld b,32
 53+  A7E7 3E 43            ld a,67
 54+  A7E9 11 00 58         ld de,22528                         ; top row attrs here
 55+  A7EC CD 3E A6         call screen_setcolours
 56+  A7EF 06 20            ld b,32
 57+  A7F1 3E 46            ld a,70
 58+  A7F3 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 59+  A7F6 CD 3E A6         call screen_setcolours
 60+  A7F9 06 20            ld b,32
 61+  A7FB 3E 43            ld a,67
 62+  A7FD 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 63+  A800 CD 3E A6         call screen_setcolours
 64+  A803 06 20            ld b,32
 65+  A805 3E 42            ld a,66
 66+  A807 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 67+  A80A CD 3E A6         call screen_setcolours
 68+  A80D C9               ret
 69+  A80E
 70+  A80E              ;
 71+  A80E              ; Initialises the screen
 72+  A80E              ;
 73+  A80E              titlescreen_init:
 74+  A80E              ; We want a black screen.
 75+  A80E 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 76+  A810                                      ; bright (64).
 77+  A810 CD 67 80         call utilities_clearscreen
 78+  A813 32 8D 5C         ld (23693),a        ; set our screen colours.
 79+  A816 3E 01            ld a,1              ; 2 is the code for red.
 80+  A818 D3 FE            out (254),a         ; write to port 254.
 81+  A81A
 82+  A81A 21 B7 80         ld hl,string_titlescreen_copyright
 83+  A81D CD 3F 83         call string_print
 84+  A820
 85+  A820 C9               ret
 86+  A821
 87+  A821              ;
 88+  A821              ; Initialises the screen
 89+  A821              ;
 90+  A821              titlescreen_alt_init:
 91+  A821              ; We want a black screen.
 92+  A821 3E 47            ld a,71             ; white ink (7) on black paper (0),
 93+  A823                                      ; bright (64).
 94+  A823 CD 67 80         call utilities_clearscreen
 95+  A826 32 8D 5C         ld (23693),a        ; set our screen colours.
 96+  A829 3E 00            ld a,0              ; 2 is the code for red.
 97+  A82B D3 FE            out (254),a         ; write to port 254.
 98+  A82D
 99+  A82D C9               ret
100+  A82E
101+  A82E              ;
102+  A82E              ; Horiz, vert
103+  A82E              ;
104+  A82E              titlescreen_logo_data:
105+  A82E 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
105+  A832 0A 00 0C 00
105+  A836 0F 00 11 00
105+  A83A 12 00 13 00
106+  A83E 09 01 0C 01      defb 9,1,12,1,15,1,17,1
106+  A842 0F 01 11 01
107+  A846 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
107+  A84A 0D 02 0E 02
107+  A84E 0F 02 11 02
107+  A852 12 02 13 02
108+  A856 09 03 0C 03      defb 9,3,12,3,15,3,17,3
108+  A85A 0F 03 11 03
109+  A85E 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
109+  A862 0F 04 11 04
109+  A866 12 04 13 04
110+  A86A 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
110+  A86E 02 06 03 06
110+  A872 04 06 05 06
110+  A876 06 06 07 06
110+  A87A 08 06 09 06
110+  A87E 0A 06 0B 06
111+  A882 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
111+  A886 12 06 13 06
111+  A88A 14 06 15 06
111+  A88E 16 06 17 06
111+  A892 18 06 19 06
111+  A896 1A 06 1B 06
112+  A89A 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20
112+  A89E 02 09 02 0A
112+  A8A2 02 0B 02 0C
112+  A8A6 02 0D 02 0E
112+  A8AA 02 0F 02 10
112+  A8AE 02 11 02 12
112+  A8B2 02 13 02 14
113+  A8B6 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20
113+  A8BA 19 09 19 0A
113+  A8BE 19 0B 19 0C
113+  A8C2 19 0D 19 0E
113+  A8C6 19 0F 19 10
113+  A8CA 19 11 19 12
113+  A8CE 19 13 19 14
114+  A8D2 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
114+  A8D6 05 0B 06 0B
114+  A8DA 07 0B 08 0B
114+  A8DE 09 0B 0A 0B
114+  A8E2 0B 0B
115+  A8E4 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
115+  A8E8 0B 09 0B 0A
116+  A8EC 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19,16,20
116+  A8F0 10 10 10 11
116+  A8F4 10 12 10 13
116+  A8F8 10 14
117+  A8FA
# file closed: screen/titlescreen.asm
 27   A8FA                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  A8FA              ;
  2+  A8FA              ; Draws the life remaining screen
  3+  A8FA              ;
  4+  A8FA              lifescreen_draw:
  5+  A8FA CD 40 A9         call lifescreen_init
  6+  A8FD
  7+  A8FD 3A 12 B5         ld a,(game_currentplayer)             ; get the current player
  8+  A900 C6 30            add 48                                ; add 48 to get char
  9+  A902 21 DE 82         ld hl,string_lifescreen_player+10
 10+  A905 77               ld (hl),a                             ; load this to the string we're about to show
 11+  A906
 12+  A906 21 D4 82         ld hl,string_lifescreen_player
 13+  A909 CD 3F 83         call string_print
 14+  A90C
 15+  A90C 3A 49 B5         ld a,(player+9)                       ; get the current player lives
 16+  A90F C6 30            add 48                                ; add 48 to get the character
 17+  A911 FE 31            cp 49
 18+  A913 C2 26 A9         jp nz,lifescreen_draw0
 19+  A916 21 EE 82         ld hl,string_lifescreen_lastman
 20+  A919
 21+  A919 06 08            ld b,8
 22+  A91B 3E 0A            ld a,10                                ; set red
 23+  A91D 11 6C 58         ld de,22528+108                        ; attrs here
 24+  A920 CD 3E A6         call screen_setcolours
 25+  A923
 26+  A923 C3 2D A9         jp lifescreen_draw1
 27+  A926              lifescreen_draw0:
 28+  A926 21 E3 82         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  A929 77               ld (hl),a                             ; load this to the string we're about to show
 30+  A92A 21 E1 82         ld hl,string_lifescreen_lives
 31+  A92D              lifescreen_draw1:
 32+  A92D CD 3F 83         call string_print
 33+  A930
 34+  A930 3E 86            ld a,134
 35+  A932 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  A935 06 0A            ld b,10
 37+  A937 CD 3E A6         call screen_setcolours
 38+  A93A
 39+  A93A 3E 64            ld a,100                              ; wait for 200 frames
 40+  A93C CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 41+  A93F
 42+  A93F C9               ret
 43+  A940
 44+  A940              ;
 45+  A940              ; Initialises the screen
 46+  A940              ;
 47+  A940              lifescreen_init:
 48+  A940              ; We want a blue screen.
 49+  A940                  ;call $0D6B
 50+  A940 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 51+  A942                                      ; bright (64).
 52+  A942 CD 67 80         call utilities_clearscreen
 53+  A945 32 8D 5C         ld (23693),a        ; set our screen colours.
 54+  A948 3E 01            ld a,1              ; 1 is the code for blue.
 55+  A94A D3 FE            out (254),a         ; write to port 254.
 56+  A94C                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 57+  A94C
 58+  A94C C9               ret
# file closed: screen/lifescreen.asm
 28   A94D                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  A94D              ;
  2+  A94D              ; Draws the game over screen
  3+  A94D              ;
  4+  A94D              gameover_draw:
  5+  A94D CD 83 A9         call gameover_init
  6+  A950 CD 10 A6         call screen_setuptext       ; show scores
  7+  A953
  8+  A953 21 F9 82         ld hl,string_gameoverscreen_gameover
  9+  A956 CD 3F 83         call string_print
 10+  A959
 11+  A959 21 05 83         ld hl,string_gameoverscreen_copyright
 12+  A95C CD 3F 83         call string_print
 13+  A95F
 14+  A95F 21 33 83         ld hl,string_gameover_credits
 15+  A962 CD 3F 83         call string_print
 16+  A965
 17+  A965 21 1F 83         ld hl,string_gameoverscreen_bestscores
 18+  A968 CD 3F 83         call string_print
 19+  A96B
 20+  A96B 06 20            ld b,32
 21+  A96D 3E 45            ld a,69
 22+  A96F 11 C0 5A         ld de,22528+704                         ; attrs here
 23+  A972 CD 3E A6         call screen_setcolours
 24+  A975
 25+  A975 06 0B            ld b,11
 26+  A977 3E 42            ld a,66
 27+  A979 11 2B 58         ld de,22528+43                         ; attrs here
 28+  A97C CD 3E A6         call screen_setcolours
 29+  A97F
 30+  A97F CD 47 80         call utilities_waitforkey   ; wait for keypress
 31+  A982
 32+  A982 C9               ret
 33+  A983
 34+  A983              ;
 35+  A983              ; Initialises the screen
 36+  A983              ;
 37+  A983              gameover_init:
 38+  A983              ; We want a black screen.
 39+  A983 3E 47            ld a,71             ; white ink (7) on black paper (0),
 40+  A985                                      ; bright (64).
 41+  A985 CD 67 80         call utilities_clearscreen
 42+  A988 32 8D 5C         ld (23693),a        ; set our screen colours.
 43+  A98B 3E 00            ld a,0              ; 2 is the code for red.
 44+  A98D D3 FE            out (254),a         ; write to port 254.
 45+  A98F C9               ret
# file closed: screen/gameover.asm
 29   A990
 30   A990                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  A990              ; ###############################################################
  2+  A990              ; Data for level 1
  3+  A990              ; ###############################################################
  4+  A990              level01:
  5+  A990
  6+  A990                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  A990
  8+  A990 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  A994 05 05 05 05
  8+  A998 05 05 05 05
  8+  A99C 05 05 02 01
  8+  A9A0 01 01 03 05
  8+  A9A4 05 05 05 05
  8+  A9A8 05 05 05 05
  8+  A9AC 05 05 00 00
  9+  A9B0 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  A9B4 05 05 05 05
  9+  A9B8 05 05 05 05
  9+  A9BC 02 01 01 01
  9+  A9C0 01 01 01 01
  9+  A9C4 03 05 05 05
  9+  A9C8 05 05 05 05
  9+  A9CC 05 05 00 00
 10+  A9D0 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  A9D4 05 05 05 05
 10+  A9D8 05 05 02 01
 10+  A9DC 01 01 01 01
 10+  A9E0 01 01 01 01
 10+  A9E4 01 01 03 05
 10+  A9E8 0D 0D 0D 0D
 10+  A9EC 0D 0D 00 00
 11+  A9F0 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  A9F4 01 01 00 01
 11+  A9F8 01 01 01 01
 11+  A9FC 01 01 01 01
 11+  AA00 01 01 01 01
 11+  AA04 01 01 01 03
 11+  AA08 05 05 05 05
 11+  AA0C 05 05 00 00
 12+  AA10 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  AA14 04 04 04 04
 12+  AA18 04 04 01 01
 12+  AA1C 01 01 01 01
 12+  AA20 01 01 01 01
 12+  AA24 01 01 01 01
 12+  AA28 01 01 01 01
 12+  AA2C 00 01 00 00
 13+  AA30 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  AA34 04 04 04 04
 13+  AA38 04 04 04 04
 13+  AA3C 01 01 01 01
 13+  AA40 01 01 01 01
 13+  AA44 01 01 01 01
 13+  AA48 00 00 00 00
 13+  AA4C 00 01 00 00
 14+  AA50 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  AA54 04 01 01 01
 14+  AA58 01 01 04 04
 14+  AA5C 04 04 01 01
 14+  AA60 01 01 01 01
 14+  AA64 01 00 00 00
 14+  AA68 00 01 01 01
 14+  AA6C 01 01 00 00
 15+  AA70 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  AA74 04 04 04 04
 15+  AA78 04 01 04 04
 15+  AA7C 04 04 04 04
 15+  AA80 04 04 00 00
 15+  AA84 00 00 04 04
 15+  AA88 04 04 04 04
 15+  AA8C 04 01 00 00
 16+  AA90 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  AA94 01 04 01 01
 16+  AA98 01 01 04 04
 16+  AA9C 04 04 04 04
 16+  AAA0 04 04 00 04
 16+  AAA4 04 04 04 04
 16+  AAA8 04 04 04 04
 16+  AAAC 04 01 00 00
 17+  AAB0 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  AAB4 00 00 00 00
 17+  AAB8 00 04 04 04
 17+  AABC 04 04 04 04
 17+  AAC0 04 04 00 04
 17+  AAC4 04 04 04 04
 17+  AAC8 04 04 04 04
 17+  AACC 04 01 00 00
 18+  AAD0 00 00 01 07      defb 00,00,01,07,07,07,07,07,07,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  AAD4 07 07 07 07
 18+  AAD8 07 01 04 04
 18+  AADC 04 04 04 04
 18+  AAE0 04 04 00 04
 18+  AAE4 04 04 04 04
 18+  AAE8 04 04 04 04
 18+  AAEC 04 01 00 00
 19+  AAF0 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  AAF4 00 00 00 00
 19+  AAF8 00 01 04 04
 19+  AAFC 04 04 04 04
 19+  AB00 04 04 00 04
 19+  AB04 04 04 04 04
 19+  AB08 04 00 00 00
 19+  AB0C 00 01 00 00
 20+  AB10 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  AB14 00 00 00 00
 20+  AB18 00 01 04 04
 20+  AB1C 04 04 04 04
 20+  AB20 04 04 00 04
 20+  AB24 04 04 04 04
 20+  AB28 04 00 04 04
 20+  AB2C 00 01 00 00
 21+  AB30 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  AB34 06 06 06 06
 21+  AB38 06 01 04 04
 21+  AB3C 04 04 04 04
 21+  AB40 04 04 00 04
 21+  AB44 04 04 04 04
 21+  AB48 04 00 04 04
 21+  AB4C 00 01 00 00
 22+  AB50 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  AB54 06 06 06 06
 22+  AB58 06 01 04 00
 22+  AB5C 00 00 00 00
 22+  AB60 00 00 00 00
 22+  AB64 00 00 00 00
 22+  AB68 00 00 04 04
 22+  AB6C 00 01 00 00
 23+  AB70 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  AB74 06 06 06 06
 23+  AB78 06 01 04 00
 23+  AB7C 04 04 04 04
 23+  AB80 04 04 00 04
 23+  AB84 04 04 00 04
 23+  AB88 04 04 04 04
 23+  AB8C 00 01 00 00
 24+  AB90 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  AB94 06 06 06 06
 24+  AB98 06 01 04 00
 24+  AB9C 04 04 04 04
 24+  ABA0 04 04 00 04
 24+  ABA4 04 04 00 04
 24+  ABA8 04 04 04 04
 24+  ABAC 00 01 00 00
 25+  ABB0 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  ABB4 01 01 01 01
 25+  ABB8 01 01 04 00
 25+  ABBC 04 04 04 04
 25+  ABC0 04 04 00 04
 25+  ABC4 04 04 00 04
 25+  ABC8 04 04 04 04
 25+  ABCC 00 01 00 00
 26+  ABD0 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  ABD4 04 04 04 04
 26+  ABD8 04 04 04 00
 26+  ABDC 04 04 04 04
 26+  ABE0 04 04 00 04
 26+  ABE4 04 04 00 00
 26+  ABE8 00 00 04 04
 26+  ABEC 04 01 00 00
 27+  ABF0 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  ABF4 04 04 00 00
 27+  ABF8 00 00 00 00
 27+  ABFC 04 04 04 04
 27+  AC00 04 04 00 04
 27+  AC04 04 04 04 04
 27+  AC08 04 00 04 04
 27+  AC0C 04 01 00 00
 28+  AC10 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  AC14 04 04 00 04
 28+  AC18 04 04 04 04
 28+  AC1C 04 04 04 04
 28+  AC20 04 04 00 04
 28+  AC24 04 04 04 04
 28+  AC28 04 00 04 04
 28+  AC2C 04 01 00 00
 29+  AC30 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  AC34 04 04 00 04
 29+  AC38 04 04 01 01
 29+  AC3C 01 01 01 01
 29+  AC40 01 01 01 01
 29+  AC44 01 01 01 01
 29+  AC48 04 00 04 04
 29+  AC4C 04 01 00 00
 30+  AC50 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  AC54 04 04 00 04
 30+  AC58 04 04 01 00
 30+  AC5C 00 00 00 00
 30+  AC60 00 00 00 00
 30+  AC64 00 00 00 01
 30+  AC68 04 00 04 04
 30+  AC6C 04 01 00 00
 31+  AC70 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  AC74 04 04 00 04
 31+  AC78 04 04 01 00
 31+  AC7C 00 00 00 00
 31+  AC80 00 00 00 00
 31+  AC84 00 00 00 01
 31+  AC88 04 00 04 04
 31+  AC8C 04 01 00 00
 32+  AC90 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  AC94 04 04 00 04
 32+  AC98 04 04 01 00
 32+  AC9C 00 00 00 00
 32+  ACA0 00 00 00 00
 32+  ACA4 00 00 00 01
 32+  ACA8 04 00 04 04
 32+  ACAC 04 01 00 00
 33+  ACB0 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  ACB4 04 04 00 04
 33+  ACB8 04 04 04 00
 33+  ACBC 00 00 00 00
 33+  ACC0 00 00 00 00
 33+  ACC4 00 00 00 04
 33+  ACC8 04 04 04 04
 33+  ACCC 04 01 00 00
 34+  ACD0 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  ACD4 04 04 04 04
 34+  ACD8 04 04 01 00
 34+  ACDC 00 00 00 00
 34+  ACE0 00 00 00 00
 34+  ACE4 00 00 00 01
 34+  ACE8 04 04 04 04
 34+  ACEC 04 01 00 00
 35+  ACF0 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  ACF4 04 04 04 04
 35+  ACF8 04 04 01 00
 35+  ACFC 00 00 01 00
 35+  AD00 00 00 00 01
 35+  AD04 00 00 00 01
 35+  AD08 04 04 04 04
 35+  AD0C 04 01 00 00
 36+  AD10 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  AD14 01 01 01 01
 36+  AD18 01 01 01 01
 36+  AD1C 01 01 01 01
 36+  AD20 01 01 01 01
 36+  AD24 01 01 01 01
 36+  AD28 01 01 01 01
 36+  AD2C 01 01 00 00
 37+  AD30
 38+  AD30              ; ###############################################################
 39+  AD30              ; Object data: horiz, vert, state, memh, meml
 40+  AD30              ; ###############################################################
 41+  AD30              level01rocks:
 42+  AD30 09 04 00 00      defb 9,4,0,0,0
 42+  AD34 00
 43+  AD35 0C 07 00 00      defb 12,7,0,0,0
 43+  AD39 00
 44+  AD3A 10 07 00 00      defb 16,7,0,0,0
 44+  AD3E 00
 45+  AD3F 0B 08 00 00      defb 11,8,0,0,0
 45+  AD43 00
 46+  AD44 0A 0A 00 00      defb 10,10,0,0,0
 46+  AD48 00
 47+  AD49 0C 0A 00 00      defb 12,10,0,0,0
 47+  AD4D 00
 48+  AD4E 0D 09 00 00      defb 13,9,0,0,0
 48+  AD52 00
 49+  AD53 0E 08 00 00      defb 14,8,0,0,0
 49+  AD57 00
 50+  AD58 0F 0B 00 00      defb 15,11,0,0,0
 50+  AD5C 00
 51+  AD5D 0B 0C 00 00      defb 11,12,0,0,0
 51+  AD61 00
 52+  AD62 11 0C 00 00      defb 17,12,0,0,0
 52+  AD66 00
 53+  AD67 13 08 00 00      defb 19,8,0,0,0
 53+  AD6B 00
 54+  AD6C 16 09 00 00      defb 22,9,0,0,0
 54+  AD70 00
 55+  AD71 13 0A 00 00      defb 19,10,0,0,0
 55+  AD75 00
 56+  AD76 15 0A 00 00      defb 21,10,0,0,0
 56+  AD7A 00
 57+  AD7B 15 0C 00 00      defb 21,12,0,0,0
 57+  AD7F 00
 58+  AD80 16 0C 00 00      defb 22,12,0,0,0
 58+  AD84 00
 59+  AD85 18 0A 00 00      defb 24,10,0,0,0
 59+  AD89 00
 60+  AD8A 19 09 00 00      defb 25,9,0,0,0
 60+  AD8E 00
 61+  AD8F 1C 09 00 00      defb 28,9,0,0,0
 61+  AD93 00
 62+  AD94 1B 0C 00 00      defb 27,12,0,0,0
 62+  AD98 00
 63+  AD99 1A 0D 00 00      defb 26,13,0,0,0
 63+  AD9D 00
 64+  AD9E 19 0E 00 00      defb 25,14,0,0,0
 64+  ADA2 00
 65+  ADA3 19 10 00 00      defb 25,16,0,0,0
 65+  ADA7 00
 66+  ADA8 1A 11 00 00      defb 26,17,0,0,0
 66+  ADAC 00
 67+  ADAD 1B 11 00 00      defb 27,17,0,0,0
 67+  ADB1 00
 68+  ADB2 1C 12 00 00      defb 28,18,0,0,0
 68+  ADB6 00
 69+  ADB7 1A 13 00 00      defb 26,19,0,0,0
 69+  ADBB 00
 70+  ADBC 1B 15 00 00      defb 27,21,0,0,0
 70+  ADC0 00
 71+  ADC1 1A 17 00 00      defb 26,23,0,0,0
 71+  ADC5 00
 72+  ADC6 1B 18 00 00      defb 27,24,0,0,0
 72+  ADCA 00
 73+  ADCB 19 18 00 00      defb 25,24,0,0,0
 73+  ADCF 00
 74+  ADD0 18 17 00 00      defb 24,23,0,0,0
 74+  ADD4 00
 75+  ADD5 13 14 00 00      defb 19,20,0,0,0
 75+  ADD9 00
 76+  ADDA 14 12 00 00      defb 20,18,0,0,0
 76+  ADDE 00
 77+  ADDF 14 10 00 00      defb 20,16,0,0,0
 77+  ADE3 00
 78+  ADE4 15 10 00 00      defb 21,16,0,0,0
 78+  ADE8 00
 79+  ADE9 16 12 00 00      defb 22,18,0,0,0
 79+  ADED 00
 80+  ADEE 11 14 00 00      defb 17,20,0,0,0
 80+  ADF2 00
 81+  ADF3 0D 11 00 00      defb 13,17,0,0,0
 81+  ADF7 00
 82+  ADF8 0C 13 00 00      defb 12,19,0,0,0
 82+  ADFC 00
 83+  ADFD 0B 13 00 00      defb 11,19,0,0,0
 83+  AE01 00
 84+  AE02 0A 11 00 00      defb 10,17,0,0,0
 84+  AE06 00
 85+  AE07 05 12 00 00      defb 5,18,0,0,0
 85+  AE0B 00
 86+  AE0C 07 16 00 00      defb 7,22,0,0,0
 86+  AE10 00
 87+  AE11 09 17 00 00      defb 9,23,0,0,0
 87+  AE15 00
 88+  AE16 07 18 00 00      defb 7,24,0,0,0
 88+  AE1A 00
 89+  AE1B 05 18 00 00      defb 5,24,0,0,0
 89+  AE1F 00
 90+  AE20 06 19 00 00      defb 6,25,0,0,0
 90+  AE24 00
 91+  AE25 08 19 00 00      defb 8,25,0,0,0
 91+  AE29 00
 92+  AE2A 04 17 00 00      defb 4,23,0,0,0
 92+  AE2E 00
 93+  AE2F FF               defb 255
 94+  AE30
 95+  AE30              level01missiles:
 96+  AE30 0B 17 00 00      defb 11,23,0,0,0
 96+  AE34 00
 97+  AE35 0B 16 00 00      defb 11,22,0,0,0
 97+  AE39 00
 98+  AE3A 0C 17 00 00      defb 12,23,0,0,0
 98+  AE3E 00
 99+  AE3F 0C 16 00 00      defb 12,22,0,0,0
 99+  AE43 00
100+  AE44 0D 17 00 00      defb 13,23,0,0,0
100+  AE48 00
101+  AE49 0D 16 00 00      defb 13,22,0,0,0
101+  AE4D 00
102+  AE4E 0E 17 00 00      defb 14,23,0,0,0
102+  AE52 00
103+  AE53 0E 16 00 00      defb 14,22,0,0,0
103+  AE57 00
104+  AE58 0F 17 00 00      defb 15,23,0,0,0
104+  AE5C 00
105+  AE5D 0F 16 00 00      defb 15,22,0,0,0
105+  AE61 00
106+  AE62 10 17 00 00      defb 16,23,0,0,0
106+  AE66 00
107+  AE67 10 16 00 00      defb 16,22,0,0,0
107+  AE6B 00
108+  AE6C 11 17 00 00      defb 17,23,0,0,0
108+  AE70 00
109+  AE71 11 16 00 00      defb 17,22,0,0,0
109+  AE75 00
110+  AE76 12 17 00 00      defb 18,23,0,0,0
110+  AE7A 00
111+  AE7B 12 16 00 00      defb 18,22,0,0,0
111+  AE7F 00
112+  AE80 13 17 00 00      defb 19,23,0,0,0
112+  AE84 00
113+  AE85 13 16 00 00      defb 19,22,0,0,0
113+  AE89 00
114+  AE8A 14 17 00 00      defb 20,23,0,0,0
114+  AE8E 00
115+  AE8F 14 16 00 00      defb 20,22,0,0,0
115+  AE93 00
116+  AE94 15 17 00 00      defb 21,23,0,0,0
116+  AE98 00
117+  AE99 15 16 00 00      defb 21,22,0,0,0
117+  AE9D 00
118+  AE9E 16 17 00 00      defb 22,23,0,0,0
118+  AEA2 00
119+  AEA3 16 16 00 00      defb 22,22,0,0,0
119+  AEA7 00
120+  AEA8 FF               defb 255
121+  AEA9
122+  AEA9              ;
123+  AEA9              ; Diamonds: x,y,state,mem1+mem2
124+  AEA9              ;
125+  AEA9              level01diamonds:
126+  AEA9 0C 1B 00 00      defb 12,27,0,0,0
126+  AEAD 00
127+  AEAE 10 1B 00 00      defb 16,27,0,0,0
127+  AEB2 00
128+  AEB3 15 1B 00 00      defb 21,27,0,0,0
128+  AEB7 00
129+  AEB8 FF               defb 255
130+  AEB9
131+  AEB9              level01gems:
132+  AEB9 12 14 00 00      defb 18,20,0,0,0
132+  AEBD 00
133+  AEBE 06 18 00 00      defb 6,24,0,0,0
133+  AEC2 00
134+  AEC3 19 17 00 00      defb 25,23,0,0,0
134+  AEC7 00
135+  AEC8 1C 11 00 00      defb 28,17,0,0,0
135+  AECC 00
136+  AECD FF               defb 255
137+  AECE              ;
138+  AECE              ; Score area colours
139+  AECE              ;
140+  AECE              score_colours:
141+  AECE 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  AED2 47 47 47 47
141+  AED6 47 47 47 42
141+  AEDA 43 43 43 43
141+  AEDE 43 43 43 43
141+  AEE2 42 47 47 47
141+  AEE6 47 47 47 47
141+  AEEA 47 47 47 47
142+  AEEE 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  AEF2 47 47 47 47
142+  AEF6 47 47 47 46
142+  AEFA 46 46 46 46
142+  AEFE 46 46 46 46
142+  AF02 46 47 47 47
142+  AF06 47 47 47 47
142+  AF0A 47 47 47 47
143+  AF0E
144+  AF0E              high_score_colours:
145+  AF0E 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  AF12 42 42 47 47
145+  AF16 47 47 47 47
145+  AF1A 43 43 43 47
145+  AF1E 47 47 47 47
145+  AF22 47 46 46 46
145+  AF26 47 47 47 47
145+  AF2A 47 47 00 00
# file closed: leveldata/level01.asm
 31   AF2E                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  AF2E              ; Tiles graphics.
  2+  AF2E              sprites:
  3+  AF2E 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  AF32 00 00 00 00
  4+  AF36 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  AF3A FF FF FF FF
  5+  AF3E 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  AF42 1F 3F 7F FF
  6+  AF46 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  AF4A F8 FC FE FF
  7+  AF4E 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  AF52 55 AA 55 AA
  8+  AF56 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  AF5A 00 00 00 00
  9+  AF5E FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  AF62 FF FF FF FF
 10+  AF66 FF FF 00 00      defb    255,255,  0,  0,  0,  0,  0,  0   ; 7, trapdoor
 10+  AF6A 00 00 00 00
 11+  AF6E 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  AF72 F1 72 34 18
 12+  AF76 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  AF7A FE FE FF 7E
 13+  AF7E 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  AF82 FE FF 7E 3C
 14+  AF86 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  AF8A 00 00 FF FF
 15+  AF8E 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 12, missile
 15+  AF92 FF 7E 3C 18
 16+  AF96 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  AF9A 00 00 00 00
 17+  AF9E 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  AFA2 00 3C 5A 34
 18+  AFA6
 19+  AFA6              sprite_attrs:
 20+  AFA6 46               defb    070 ; 0, space
 21+  AFA7 65               defb    101 ; 1, cyan block
 22+  AFA8 4D               defb    077 ; 2, slope left
 23+  AFA9 4D               defb    077 ; 3, slope right
 24+  AFAA 46               defb    070 ; 4, dirt
 25+  AFAB 4E               defb    078 ; 5, sky
 26+  AFAC 4C               defb    076 ; 6, slime
 27+  AFAD 42               defb    066 ; 7, trapdoor
 28+  AFAE 46               defb    070 ; 8, diamond
 29+  AFAF 42               defb    066 ; 9, rock
 30+  AFB0 42               defb    066 ; 10, rock 2
 31+  AFB1 49           	defb    073 ; 11, sky, trapdoor
 32+  AFB2 43           	defb    067 ; 12, missile
 33+  AFB3 4A               defb    074 ; 13, sky, red ink (tank)
 34+  AFB4 46               defb    070 ; 14, gem
 35+  AFB5
 36+  AFB5              player_sprite:
 37+  AFB5 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 37+  AFB9 38 3D C3 80
 38+  AFBD 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 38+  AFC1 3C 1C 16 32
 39+  AFC5 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 39+  AFC9 3C 38 68 4C
 40+  AFCD 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 40+  AFD1 1C BC C3 01
 41+  AFD5 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 41+  AFD9 3C 3C 64 0C
 42+  AFDD 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 42+  AFE1 3C 3C 26 30
 43+  AFE5 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 43+  AFE9 1E 5C FD 5F
 44+  AFED 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 44+  AFF1 4F 8F 19 03
 45+  AFF5 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 45+  AFF9 F2 F1 98 C0
 46+  AFFD FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 46+  B001 48 08 14 2A
 47+  B005 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 47+  B009 38 78 44 C3
 48+  B00D 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 48+  B011 1C 1E 22 C3
 49+  B015
 50+  B015              ;
 51+  B015              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 52+  B015              ;
 53+  B015              ship_sprite:
 54+  B015 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 54+  B019 03 1F 7F FF
 55+  B01D 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 55+  B021 FF FF FF FF
 56+  B025 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 56+  B029 FF FF FF FF
 57+  B02D 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 57+  B031 C0 F8 FE FF
 58+  B035 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 58+  B039 03 03 02 07
 59+  B03D 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 59+  B041 FF 0F 07 83
 60+  B045 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 60+  B049 FF 10 20 C1
 61+  B04D 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 61+  B051 C0 C0 40 E0
 62+  B055 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 62+  B059 03 03 02 07
 63+  B05D F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 63+  B061 FF 08 04 83
 64+  B065 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 64+  B069 FF F0 E0 C1
 65+  B06D CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 65+  B071 C0 C0 40 E0
 66+  B075
 67+  B075              ;
 68+  B075              ;  First 8 frames are tank, last frame is the gun barrel
 69+  B075              ;
 70+  B075              tank_sprite:
 71+  B075 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 71+  B079 7F 00 00 00
 72+  B07D 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 72+  B081 FE FF 7F 40
 73+  B085 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 73+  B089 03 FF FF 01
 74+  B08D 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
 74+  B091 E0 C0 00 00
 75+  B095 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
 75+  B099 F7 E1 7F 3F
 76+  B09D FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
 76+  B0A1 54 16 FF FF
 77+  B0A5 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
 77+  B0A9 9B A8 FF FF
 78+  B0AD FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
 78+  B0B1 9F AF FE FC
 79+  B0B5 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0
 79+  B0B9 1F 00 00 00
# file closed: graphics/graphics.asm
 32   B0BD
 33   B0BD                  include "game\control.asm"
# file opened: game/control.asm
  1+  B0BD              ;
  2+  B0BD              ; Check the keyboard then move
  3+  B0BD              ;
  4+  B0BD              control_keyboard:
  5+  B0BD 3A 4B B5         ld a,(player+11)    ; first, check if player is dying
  6+  B0C0 FE 00            cp 0
  7+  B0C2 C0               ret nz               ; if so, can't move
  8+  B0C3 3A 45 B5         ld a,(player+5)      ; next, check if the player has pixels left to move
  9+  B0C6 FE 00            cp 0
 10+  B0C8 CA CF B0         jp z, control_keyboard5
 11+  B0CB CD D4 B1         call control_automove
 12+  B0CE C9               ret
 13+  B0CF              control_keyboard5:
 14+  B0CF 3A 46 B5         ld a,(player+6)      ; next, check if the player is digging
 15+  B0D2 FE 00            cp 0
 16+  B0D4 CA DB B0         jp z, control_keyboard0
 17+  B0D7 CD 12 B1         call control_dig
 18+  B0DA C9               ret
 19+  B0DB              control_keyboard0:
 20+  B0DB 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 21+  B0DE ED 78            in a,(c)            ; read keyboard.
 22+  B0E0 47               ld b,a              ; store result in b register.
 23+  B0E1 CB 18            rr b                ; check outermost key (q).
 24+  B0E3 D2 02 B1         jp nc,control_keyboard1
 25+  B0E6 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 26+  B0E9 ED 78            in a,(c)            ; read keyboard.
 27+  B0EB 47               ld b,a              ; store result in b register.
 28+  B0EC CB 18            rr b                ; check outermost key (a).
 29+  B0EE D2 06 B1         jp nc,control_keyboard2
 30+  B0F1 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 31+  B0F4 ED 78            in a,(c)            ; read keyboard.
 32+  B0F6 47               ld b,a              ; store result in b register.
 33+  B0F7 CB 18            rr b                ; check outermost key (p).
 34+  B0F9 D2 0A B1         jp nc,control_keyboard3
 35+  B0FC CB 18            rr b                ; check next key.
 36+  B0FE D2 0E B1         jp nc,control_keyboard4
 37+  B101 C9               ret
 38+  B102              control_keyboard1:
 39+  B102 CD 1D B2         call control_pl_moveup         ; player up.
 40+  B105 C9               ret
 41+  B106              control_keyboard2:
 42+  B106 CD 4C B2         call control_pl_movedown       ; player down.
 43+  B109 C9               ret
 44+  B10A              control_keyboard3:
 45+  B10A CD A9 B2         call control_pl_moveright       ; player left.
 46+  B10D C9               ret
 47+  B10E              control_keyboard4:
 48+  B10E CD 79 B2         call control_pl_moveleft       ; player right.
 49+  B111 C9               ret
 50+  B112
 51+  B112              ;
 52+  B112              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 53+  B112              ;
 54+  B112              control_dig:
 55+  B112 ED 4B 40 B5      ld bc,(player)      ; load the current coords into bc
 56+  B116 C5               push bc
 57+  B117 3A 42 B5         ld a,(player+2)     ; get the direction
 58+  B11A FE 01            cp 1                ; left
 59+  B11C CA 34 B1         jp z,control_dig0
 60+  B11F FE 02            cp 2                ; right
 61+  B121 CA 49 B1         jp z,control_dig1
 62+  B124 FE 03            cp 3                ; down
 63+  B126 CA 6D B1         jp z,control_dig5
 64+  B129 FE 00            cp 0                ; up
 65+  B12B CA 5D B1         jp z,control_dig4
 66+  B12E 21 46 B5         ld hl,player+6
 67+  B131 36 00            ld (hl),0           ; turn off digging
 68+  B133 C9               ret                 ; return
 69+  B134              control_dig0:           ; going left
 70+  B134 CD 70 A7         call sprites_scadd  ; get the current coord
 71+  B137 62 6B            ld hl,de
 72+  B139 2B               dec hl              ; move one left
 73+  B13A C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
 74+  B13B 78               ld a,b
 75+  B13C 06 08            ld b,8
 76+  B13E 90               sub b
 77+  B13F 47               ld b,a
 78+  B140 79               ld a,c
 79+  B141 0E 08            ld c,8
 80+  B143 91               sub c
 81+  B144 4F               ld c,a
 82+  B145 C5               push bc
 83+  B146 C3 76 B1         jp control_dig2
 84+  B149              control_dig1:
 85+  B149 CD 70 A7         call sprites_scadd  ; get the current coord
 86+  B14C 62 6B            ld hl,de
 87+  B14E 23               inc hl              ; move one right
 88+  B14F C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
 89+  B150 3E 08            ld a,8
 90+  B152 80               add a,b
 91+  B153 47               ld b,a
 92+  B154 79               ld a,c
 93+  B155 0E 08            ld c,8
 94+  B157 91               sub c
 95+  B158 4F               ld c,a
 96+  B159 C5               push bc
 97+  B15A C3 76 B1         jp control_dig2
 98+  B15D              control_dig4:
 99+  B15D CD 70 A7         call sprites_scadd  ; get the current coord
100+  B160 62 6B            ld hl,de
101+  B162 11 20 00         ld de,32
102+  B165 ED 52            sbc hl,de             ; move one up
103+  B167 C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
104+  B168 0D               dec c
105+  B169 C5               push bc
106+  B16A C3 8E B1         jp control_dig6
107+  B16D              control_dig5:
108+  B16D CD 70 A7         call sprites_scadd  ; get the current coord
109+  B170 62 6B            ld hl,de
110+  B172 24               inc h              ; move one down
111+  B173                                     ; not bothered about working out bc here, since rock will never fall if digging down
112+  B173 C3 76 B1         jp control_dig2
113+  B176              ; Normal (not up) digging
114+  B176              control_dig2:
115+  B176 3A 48 B5         ld a,(player+8)     ; get the number of rows we need to overwrite
116+  B179 47               ld b,a              ; rows to copy over
117+  B17A E5               push hl             ; store the memory location of the first row for later
118+  B17B              control_dig3:
119+  B17B CD BD B1         call control_getpixelrow
120+  B17E 77               ld (hl),a           ; load contents into row
121+  B17F 11 20 00         ld de,32
122+  B182 19               add hl,de           ; move to next row
123+  B183 10 F6            djnz control_dig3
124+  B185 E1               pop hl              ; get the original memory location back
125+  B186 11 20 00         ld de,32
126+  B189 ED 52            sbc hl,de           ; move to above row, ready for checking for rock
127+  B18B C3 A4 B1         jp control_dig10
128+  B18E              ; Special case for going up
129+  B18E              control_dig6:
130+  B18E 3A 48 B5         ld a,(player+8)     ; get the number of rows we need to overwrite
131+  B191 47               ld b,a              ; rows to copy over
132+  B192              control_dig7:
133+  B192 CD BD B1         call control_getpixelrow
134+  B195              control_dig12:
135+  B195 77               ld (hl),a           ; load empty into row
136+  B196 11 20 00         ld de,32
137+  B199 ED 52            sbc hl,de           ; move up to next row
138+  B19B 0D               dec c               ; decrease c to track rows
139+  B19C 10 F4            djnz control_dig7
140+  B19E 79               ld a,c
141+  B19F D6 07            sub 7
142+  B1A1 C1               pop bc
143+  B1A2 4F               ld c,a
144+  B1A3 C5               push bc             ; store the decreased c coord
145+  B1A4              control_dig10:
146+  B1A4 DD 21 47 B5      ld ix,player+7
147+  B1A8 DD 7E 00         ld a,(ix)     ; get the dig frame number
148+  B1AB 3D               dec a
149+  B1AC DD 77 00         ld (ix),a
150+  B1AF                  ; call the check for rocks above the removed dirt
151+  B1AF DD 21 46 B5      ld ix,player+6
152+  B1B3 DD 7E 00         ld a,(ix)     ; get the dig state
153+  B1B6 FE 00            cp 0
154+  B1B8 C1               pop bc
155+  B1B9 CC 4D B8         call z, rocks_checkforfalling ; make the check if we're no longer digging
156+  B1BC C9               ret
157+  B1BD
158+  B1BD              ;
159+  B1BD              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
160+  B1BD              ; Inputs:
161+  B1BD              ; hl - memory of pixel row
162+  B1BD              ; Outputs:
163+  B1BD              ; a - modified row to write
164+  B1BD              ;
165+  B1BD              control_getpixelrow:
166+  B1BD 3A 47 B5         ld a,(player+7)     ; get the dig frame number
167+  B1C0 FE 00            cp 0                ; is this the last dig
168+  B1C2 CA C9 B1         jp z,control_getpixelrow1
169+  B1C5 7E               ld a,(hl)           ; if not, xor with 255 to flip it
170+  B1C6 EE FF            xor 255
171+  B1C8 C9               ret
172+  B1C9              control_getpixelrow1:
173+  B1C9 DD 21 46 B5      ld ix,player+6
174+  B1CD DD 36 00 00      ld (ix),0           ; turn off digging
175+  B1D1 3E 00            ld a,0              ; if it is, load with empty
176+  B1D3 C9               ret
177+  B1D4
178+  B1D4              ;
179+  B1D4              ; Auto move the player until pixels is zero
180+  B1D4              ;
181+  B1D4              control_automove:
182+  B1D4 5F               ld e,a              ; store the number of pixels left to move in e
183+  B1D5 ED 4B 40 B5      ld bc,(player)      ; load the current coords into bc
184+  B1D9 21 42 B5         ld hl,player+2      ; get the direction
185+  B1DC 7E               ld a,(hl)
186+  B1DD FE 03            cp 3                ; down
187+  B1DF CA F3 B1         jp z,control_automove3  ; don't need to do anything
188+  B1E2 FE 00            cp 0                ; going up
189+  B1E4 CA FF B1         jp z,control_automove2
190+  B1E7 FE 01            cp 1                ; going left?
191+  B1E9 CA 0B B2         jp z,control_automove0
192+  B1EC 78               ld a,b
193+  B1ED 3C               inc a               ; if we're going right, increment a twice for two pixels
194+  B1EE 3C               inc a
195+  B1EF 47               ld b,a
196+  B1F0 C3 0F B2         jp control_automove1
197+  B1F3              control_automove3:
198+  B1F3 79               ld a,c
199+  B1F4 3C               inc a
200+  B1F5 3C               inc a               ; if we're going down, increment twice
201+  B1F6 4F               ld c,a
202+  B1F7 FE 90            cp 144
203+  B1F9 CC D7 B2         call z, control_scroll_down
204+  B1FC C3 0F B2         jp control_automove1
205+  B1FF              control_automove2:
206+  B1FF 79               ld a,c
207+  B200 3D               dec a
208+  B201 3D               dec a               ; if we're going up, decrement twice
209+  B202 4F               ld c,a
210+  B203 FE 60            cp 96
211+  B205 CC E4 B2         call z, control_scroll_up
212+  B208 C3 0F B2         jp control_automove1
213+  B20B              control_automove0:
214+  B20B 78               ld a,b
215+  B20C 3D               dec a               ; if we're going left, decrement a twice
216+  B20D 3D               dec a
217+  B20E 47               ld b,a
218+  B20F              control_automove1:
219+  B20F ED 43 40 B5      ld (player),bc      ; and back to player
220+  B213 7B               ld a,e              ; now get the pixel count back
221+  B214 3D               dec a               ; decrease by one
222+  B215 21 45 B5         ld hl,player+5
223+  B218 77               ld (hl),a           ; copy back
224+  B219 CD 46 B6         call player_justmoved
225+  B21C C9               ret
226+  B21D
227+  B21D              ;
228+  B21D              ; Moves the player up
229+  B21D              ;
230+  B21D              control_pl_moveup:
231+  B21D C5               push bc
232+  B21E ED 4B 40 B5      ld bc,(player)          ; get the current coords, b horiz, c vert
233+  B222 79               ld a,c                  ; load c into the acc
234+  B223 FE 18            cp 24
235+  B225 CA 45 B2         jp z,control_pl_moveup0 ; are we at the edge of the screen
236+  B228 FE 60            cp 96
237+  B22A CC E4 B2         call z, control_scroll_up
238+  B22D CD 84 B4         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
239+  B230 F5               push af
240+  B231 7B               ld a,e                  ; put e in a
241+  B232 FE 00            cp 0
242+  B234 CA 44 B2         jp z,control_pl_moveup1 ; don't move if we can't
243+  B237 F1               pop af
244+  B238 D6 01            sub 1                   ; subtract 1
245+  B23A D6 01            sub 1                   ; subtract 1
246+  B23C 4F               ld c,a                  ; load back to c
247+  B23D ED 43 40 B5      ld (player),bc          ; load back to player
248+  B241 C3 45 B2         jp control_pl_moveup0
249+  B244              control_pl_moveup1:
250+  B244 F1               pop af                  ; restore af if needed
251+  B245              control_pl_moveup0:
252+  B245 3E 00            ld a,0
253+  B247 32 42 B5         ld (player+2),a        ; set direction to up
254+  B24A C1               pop bc
255+  B24B C9               ret
256+  B24C              ;
257+  B24C              ; Moves the player down
258+  B24C              ;
259+  B24C              control_pl_movedown:
260+  B24C C5               push bc
261+  B24D ED 4B 40 B5      ld bc,(player)          ; get the current coords, b horiz, c vert
262+  B251 79               ld a,c                  ; load c into the acc
263+  B252 FE E0            cp 224
264+  B254 CA 72 B2         jp z,control_pl_movedown0 ; are we at the edge of the screen
265+  B257 FE 80            cp 128
266+  B259 CC D7 B2         call z, control_scroll_down
267+  B25C CD 58 B4         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
268+  B25F F5               push af
269+  B260 7B               ld a,e                  ; put e in a
270+  B261 FE 00            cp 0
271+  B263 CA 71 B2         jp z,control_pl_movedown1 ; don't move if we can't
272+  B266 F1               pop af
273+  B267 3C               inc a                   ; add 1
274+  B268 3C               inc a                   ; add 1
275+  B269 4F               ld c,a                  ; load back to c
276+  B26A ED 43 40 B5      ld (player),bc          ; load back to player
277+  B26E C3 72 B2         jp control_pl_movedown0
278+  B271              control_pl_movedown1:
279+  B271 F1               pop af                  ; restore af if needed
280+  B272              control_pl_movedown0:
281+  B272 3E 03            ld a,3
282+  B274 32 42 B5         ld (player+2),a        ; set direction to down
283+  B277 C1               pop bc
284+  B278 C9               ret
285+  B279              ;
286+  B279              ; Moves the player left
287+  B279              ;
288+  B279              control_pl_moveleft:
289+  B279 C5               push bc
290+  B27A ED 4B 40 B5      ld bc,(player)          ; get the current coords, b horiz, c vert
291+  B27E 78               ld a,b                  ; load b into the acc
292+  B27F FE 10            cp 16
293+  B281 CA A2 B2         jp z,control_pl_moveleft0 ; are we at the edge of the screen
294+  B284 CD E3 B4         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
295+  B287 F5               push af
296+  B288 7B               ld a,e                  ; put e in a
297+  B289 FE 00            cp 0
298+  B28B CA A1 B2         jp z,control_pl_moveleft1 ; don't move if we can't
299+  B28E 21 45 B5         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
300+  B291 3E 03            ld a,3
301+  B293 77               ld (hl),a
302+  B294 F1               pop af
303+  B295 D6 01            sub 1                    ; subtract 2
304+  B297 D6 01            sub 1
305+  B299 47               ld b,a                  ; load back to c
306+  B29A ED 43 40 B5      ld (player),bc          ; load back to player
307+  B29E C3 A2 B2         jp control_pl_moveleft0
308+  B2A1              control_pl_moveleft1:
309+  B2A1 F1               pop af
310+  B2A2              control_pl_moveleft0:
311+  B2A2 3E 01            ld a,1
312+  B2A4 32 42 B5         ld (player+2),a        ; set direction to left
313+  B2A7 C1               pop bc
314+  B2A8 C9               ret
315+  B2A9              ;
316+  B2A9              ; Moves the player right
317+  B2A9              ;
318+  B2A9              control_pl_moveright:
319+  B2A9 C5               push bc
320+  B2AA ED 4B 40 B5      ld bc,(player)          ; get the current coords, b horiz, c vert
321+  B2AE 78               ld a,b                  ; load b into the acc
322+  B2AF FE F0            cp 240
323+  B2B1 CA D0 B2         jp z,control_pl_moveright0 ; are we at the edge of the screen
324+  B2B4 CD B7 B4         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
325+  B2B7 F5               push af
326+  B2B8 7B               ld a,e                  ; put e in a
327+  B2B9 FE 00            cp 0
328+  B2BB CA CF B2         jp z,control_pl_moveright1 ; don't move if we can't
329+  B2BE 21 45 B5         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
330+  B2C1 3E 03            ld a,3
331+  B2C3 77               ld (hl),a
332+  B2C4 F1               pop af
333+  B2C5 3C               inc a                   ; add 2
334+  B2C6 3C               inc a
335+  B2C7 47               ld b,a                  ; load back to b
336+  B2C8 ED 43 40 B5      ld (player),bc          ; load back to player
337+  B2CC C3 D0 B2         jp control_pl_moveright0
338+  B2CF              control_pl_moveright1:
339+  B2CF F1               pop af                  ; restore af if needed
340+  B2D0              control_pl_moveright0:
341+  B2D0 3E 02            ld a,2
342+  B2D2 32 42 B5         ld (player+2),a        ; set direction to right
343+  B2D5 C1               pop bc
344+  B2D6 C9               ret
345+  B2D7
346+  B2D7              ;
347+  B2D7              ; Scrolls the screen down
348+  B2D7              ;
349+  B2D7              control_scroll_down:
350+  B2D7 F5               push af
351+  B2D8 3E 08            ld a,8
352+  B2DA 32 8C A5         ld (screen_offset),a
353+  B2DD F1               pop af
354+  B2DE 21 3E A4         ld hl,buffer_updateall
355+  B2E1 36 01            ld (hl),1         ; flag as screen needing update
356+  B2E3 C9               ret
357+  B2E4
358+  B2E4              ;
359+  B2E4              ; Scrolls the screen up
360+  B2E4              ;
361+  B2E4              control_scroll_up:
362+  B2E4 F5               push af
363+  B2E5 3E 00            ld a,0
364+  B2E7 32 8C A5         ld (screen_offset),a
365+  B2EA F1               pop af
366+  B2EB 21 3E A4         ld hl,buffer_updateall
367+  B2EE 36 01            ld (hl),1         ; flag as screen needing update
368+  B2F0 C9               ret
369+  B2F1
370+  B2F1
371+  B2F1
372+  B2F1
# file closed: game/control.asm
 34   B2F1                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  B2F1              ;
  2+  B2F1              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  3+  B2F1              ; Inputs:
  4+  B2F1              ; hl - memory location of top pixel row
  5+  B2F1              ; bc - screen coords, b horiz, c vert
  6+  B2F1              ; Outputs:
  7+  B2F1              ; e - 0 if not empty, 1 if empty
  8+  B2F1              ;
  9+  B2F1              movement_spaceisempty:
 10+  B2F1 C5               push bc
 11+  B2F2 E5               push hl
 12+  B2F3 CD 1B B3         call movement_spaceisgem        ; check if space is a gem
 13+  B2F6 E1               pop hl
 14+  B2F7 C1               pop bc
 15+  B2F8 7B               ld a,e
 16+  B2F9 FE 01            cp 1
 17+  B2FB C8               ret z                           ; if e is 1, space is a gem so can move here, return
 18+  B2FC 3E 08            ld a,8                          ; 8 rows to check
 19+  B2FE              movement_spaceisempty0:
 20+  B2FE 08               ex af,af'                       ; store the loop counter
 21+  B2FF 7E               ld a,(hl)                       ; get current pixel row
 22+  B300 FE 00            cp 0
 23+  B302 C2 16 B3         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 24+  B305 79               ld a,c                          ; load the vertical coord
 25+  B306 3C               inc a                           ; next row down
 26+  B307 11 20 00         ld de,32
 27+  B30A 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 28+  B30B 4F               ld c,a                          ; copy vert coord back to c
 29+  B30C 08               ex af,af'                       ; get loop counter back
 30+  B30D 3D               dec a                           ; decrease loop counter
 31+  B30E C2 FE B2         jp nz, movement_spaceisempty0
 32+  B311 16 00            ld d,0
 33+  B313 1E 01            ld e,1                          ; got to end, so space is empty
 34+  B315 C9               ret
 35+  B316              movement_spaceisempty1:
 36+  B316 16 00            ld d,0
 37+  B318 1E 00            ld e,0                          ; returning false, ie space not empty
 38+  B31A C9               ret
 39+  B31B
 40+  B31B              ;
 41+  B31B              ; Check if a space contains a gem
 42+  B31B              ; Inputs:
 43+  B31B              ; bc - screen coords
 44+  B31B              ; Outputs:
 45+  B31B              ; e = 1 if gem
 46+  B31B              movement_spaceisgem:
 47+  B31B CD C7 A6         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 48+  B31E 21 A9 AE         ld hl,level01diamonds           ; check diamonds first
 49+  B321              movement_spaceisgem0:
 50+  B321 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 51+  B325 7B               ld a,e                          ; check for end of data
 52+  B326 FE FF            cp 255
 53+  B328 CA 43 B3         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 54+  B32B 23               inc hl
 55+  B32C 23               inc hl                          ; move to state
 56+  B32D 7E               ld a,(hl)
 57+  B32E 23               inc hl
 58+  B32F 23               inc hl
 59+  B330 23               inc hl                          ; get to next
 60+  B331 FE 01            cp 1                            ; check if collected
 61+  B333 CA 21 B3         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 62+  B336 7B               ld a,e                          ; load e again
 63+  B337 B9               cp c                            ; otherwise, compare c with e
 64+  B338 C2 21 B3         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 65+  B33B 7A               ld a,d                          ; get d coord
 66+  B33C B8               cp b                            ; compare b with d
 67+  B33D C2 21 B3         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 68+  B340 1E 01            ld e,1                          ; otherwise, exit with e = 1
 69+  B342 C9               ret
 70+  B343              movement_spaceisgem1:
 71+  B343 21 B9 AE         ld hl,level01gems              ; check gems
 72+  B346              movement_spaceisgem2:
 73+  B346 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 74+  B34A 7B               ld a,e                          ; check for end of data
 75+  B34B FE FF            cp 255
 76+  B34D CA 68 B3         jp z,movement_spaceisgem3       ; if yes, done with gems
 77+  B350 23               inc hl
 78+  B351 23               inc hl                          ; move to state
 79+  B352 7E               ld a,(hl)
 80+  B353 23               inc hl
 81+  B354 23               inc hl
 82+  B355 23               inc hl                          ; get to next
 83+  B356 FE 01            cp 1                            ; check if collected
 84+  B358 CA 46 B3         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 85+  B35B 7B               ld a,e                          ; load e again
 86+  B35C B9               cp c                            ; otherwise, compare c with e
 87+  B35D C2 46 B3         jp nz,movement_spaceisgem2      ; if different, move to next gem
 88+  B360 7A               ld a,d                          ; get d coord
 89+  B361 B8               cp b                            ; compare b with d
 90+  B362 C2 46 B3         jp nz,movement_spaceisgem2      ; if different, move to next gem
 91+  B365 1E 01            ld e,1                          ; otherwise, exit with e = 1
 92+  B367 C9               ret
 93+  B368              movement_spaceisgem3:
 94+  B368 1E 00            ld e,0                          ; nothing found, return e = 0
 95+  B36A C9               ret
 96+  B36B
 97+  B36B              ;
 98+  B36B              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
 99+  B36B              ; Inputs:
100+  B36B              ; hl - memory location of top pixel row
101+  B36B              ; bc - screen coords, b horiz, c vert
102+  B36B              ; Outputs:
103+  B36B              ; e - 0 if not empty, 1 if empty
104+  B36B              ;
105+  B36B              movement_linebelowisempty:
106+  B36B C5               push bc
107+  B36C E5               push hl
108+  B36D CD 1B B3         call movement_spaceisgem        ; check if space is a gem
109+  B370 E1               pop hl
110+  B371 C1               pop bc
111+  B372 7B               ld a,e
112+  B373 FE 01            cp 1
113+  B375 C8               ret z                           ; if e is 1, space is a gem so can move here, return
114+  B376 7E               ld a,(hl)                       ; get current pixel row
115+  B377 FE 00            cp 0
116+  B379 C2 81 B3         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
117+  B37C 16 00            ld d,0
118+  B37E 1E 01            ld e,1                          ; got to end, so space is empty
119+  B380 C9               ret
120+  B381              movement_linebelowisempty1:
121+  B381 16 00            ld d,0
122+  B383 1E 00            ld e,0                          ; returning false, ie space not empty
123+  B385 C9               ret
124+  B386
125+  B386              ;
126+  B386              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
127+  B386              ; Inputs:
128+  B386              ; hl - memory location of top pixel row
129+  B386              ; bc - screen coords, b horiz, c vert
130+  B386              ; Outputs:
131+  B386              ; e - 0 if not empty, 1 if empty
132+  B386              ;
133+  B386              movement_lineaboveisempty:
134+  B386 C5               push bc
135+  B387 E5               push hl
136+  B388 CD 1B B3         call movement_spaceisgem        ; check if space is a gem
137+  B38B E1               pop hl
138+  B38C C1               pop bc
139+  B38D 7B               ld a,e
140+  B38E FE 01            cp 1
141+  B390 C8               ret z
142+  B391 7E               ld a,(hl)                       ; get current pixel row
143+  B392 FE 00            cp 0
144+  B394 C2 9C B3         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
145+  B397 16 00            ld d,0
146+  B399 1E 01            ld e,1                          ; got to end, so space is empty
147+  B39B C9               ret
148+  B39C              movement_lineaboveisempty1:
149+  B39C 16 00            ld d,0
150+  B39E 1E 00            ld e,0                          ; returning false, ie space not empty
151+  B3A0 C9               ret
152+  B3A1
153+  B3A1              ;
154+  B3A1              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
155+  B3A1              ; Inputs:
156+  B3A1              ; hl - memory location of top pixel row
157+  B3A1              ; bc - screen coords, b horiz, c vert
158+  B3A1              ; Outputs:
159+  B3A1              ; none - puts player into digging mode
160+  B3A1              ;
161+  B3A1              movement_spaceisdiggable:
162+  B3A1 3E 08            ld a,8                          ; 8 rows to check
163+  B3A3              movement_spaceisdiggable0:
164+  B3A3 08               ex af,af'                       ; store the loop counter
165+  B3A4 7E               ld a,(hl)                       ; get current pixel row
166+  B3A5 FE 00            cp 0
167+  B3A7 CA B7 B3         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
168+  B3AA FE 55            cp 85
169+  B3AC CA B7 B3         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
170+  B3AF FE AA            cp 170
171+  B3B1 CA B7 B3         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
172+  B3B4 C3 CF B3         jp movement_spaceisdiggable1     ; otherwise, stop checking
173+  B3B7              movement_spaceisdiggable2:
174+  B3B7 79               ld a,c                          ; load the vertical coord
175+  B3B8 3C               inc a                           ; next row down
176+  B3B9 11 20 00         ld de,32
177+  B3BC 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
178+  B3BD 4F               ld c,a                          ; copy vert coord back to c
179+  B3BE 08               ex af,af'                       ; get loop counter back
180+  B3BF 3D               dec a                           ; decrease loop counter
181+  B3C0 C2 A3 B3         jp nz, movement_spaceisdiggable0
182+  B3C3 21 46 B5         ld hl,player+6
183+  B3C6 36 01            ld (hl),1                       ; set the player into digging mode
184+  B3C8 23               inc hl
185+  B3C9 36 05            ld (hl),5                      ; set the number of frame to dig for
186+  B3CB 23               inc hl
187+  B3CC 36 08            ld (hl),8                       ; set the number of pixels to dig
188+  B3CE C9               ret
189+  B3CF              movement_spaceisdiggable1:
190+  B3CF 21 46 B5         ld hl,player+6
191+  B3D2 36 00            ld (hl),0                       ; set the player out of digging mode
192+  B3D4 C9               ret
193+  B3D5
194+  B3D5              ;
195+  B3D5              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
196+  B3D5              ; Inputs:
197+  B3D5              ; hl - memory location of top pixel row
198+  B3D5              ; bc - screen coords, b horiz, c vert
199+  B3D5              ; Outputs:
200+  B3D5              ; none - puts player into digging mode
201+  B3D5              ;
202+  B3D5              movement_spacebelowisdiggable:
203+  B3D5 7E               ld a,(hl)                       ; get first pixel row
204+  B3D6 FE 55            cp 85
205+  B3D8 CA E3 B3         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
206+  B3DB FE AA            cp 170
207+  B3DD CA E3 B3         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
208+  B3E0 C3 CF B3         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
209+  B3E3              movement_spacebelowisdiggable3:
210+  B3E3 3E 08            ld a,8                          ; rows to check
211+  B3E5 1E 00            ld e,0                          ; count of rows to dig
212+  B3E7              movement_spacebelowisdiggable0:
213+  B3E7 08               ex af,af'                       ; store the loop counter
214+  B3E8 7E               ld a,(hl)                       ; get current pixel row
215+  B3E9 FE 55            cp 85
216+  B3EB CA F6 B3         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
217+  B3EE FE AA            cp 170
218+  B3F0 CA F6 B3         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
219+  B3F3 C3 05 B4         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
220+  B3F6              movement_spacebelowisdiggable4:
221+  B3F6 1C               inc e                           ; inc count of rows to dig
222+  B3F7              movement_spacebelowisdiggable2:
223+  B3F7 79               ld a,c                          ; load the vertical coord
224+  B3F8 3C               inc a                           ; next row down
225+  B3F9 D5               push de                         ; need e for later
226+  B3FA 11 20 00         ld de,32
227+  B3FD 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
228+  B3FE 4F               ld c,a                          ; copy vert coord back to c
229+  B3FF D1               pop de                          ; get e back
230+  B400 08               ex af,af'                       ; get loop counter back
231+  B401 3D               dec a                           ; incease loop counter
232+  B402 C2 E7 B3         jp nz, movement_spacebelowisdiggable0
233+  B405              movement_spacebelowisdiggable5:
234+  B405 21 46 B5         ld hl,player+6
235+  B408 36 01            ld (hl),1                       ; set the player into digging mode
236+  B40A 23               inc hl
237+  B40B 36 03            ld (hl),3                      ; set the number of frame to dig for
238+  B40D 23               inc hl
239+  B40E 73               ld (hl),e                       ; set the number of pixels to dig
240+  B40F C9               ret
241+  B410              movement_spacebelowisdiggable1:
242+  B410 21 46 B5         ld hl,player+6
243+  B413 36 00            ld (hl),0                       ; set the player out of digging mode
244+  B415 C9               ret
245+  B416
246+  B416              ;
247+  B416              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
248+  B416              ; Inputs:
249+  B416              ; hl - memory location of top pixel row
250+  B416              ; bc - screen coords, b horiz, c vert
251+  B416              ; Outputs:
252+  B416              ; none - puts player into digging mode
253+  B416              ;
254+  B416              movement_spaceaboveisdiggable:
255+  B416 7E               ld a,(hl)                       ; get first pixel row
256+  B417 FE 55            cp 85
257+  B419 CA 24 B4         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
258+  B41C FE AA            cp 170
259+  B41E CA 24 B4         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
260+  B421 C3 CF B3         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
261+  B424              movement_spaceaboveisdiggable3:
262+  B424 3E 08            ld a,8                          ; rows to check
263+  B426 1E 00            ld e,0                          ; count of rows to dig
264+  B428              movement_spaceaboveisdiggable0:
265+  B428 08               ex af,af'                       ; store the loop counter
266+  B429 7E               ld a,(hl)                       ; get current pixel row
267+  B42A FE 55            cp 85
268+  B42C CA 37 B4         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
269+  B42F FE AA            cp 170
270+  B431 CA 37 B4         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
271+  B434 C3 47 B4         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
272+  B437              movement_spaceaboveisdiggable4:
273+  B437 1C               inc e                           ; inc count of rows to dig
274+  B438              movement_spaceaboveisdiggable2:
275+  B438 79               ld a,c                          ; load the vertical coord
276+  B439 3D               dec a                           ; next row up
277+  B43A D5               push de                         ; need e for later
278+  B43B 11 20 00         ld de,32
279+  B43E ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
280+  B440 4F               ld c,a                          ; copy vert coord back to c
281+  B441 D1               pop de                          ; get e back
282+  B442 08               ex af,af'                       ; get loop counter back
283+  B443 3D               dec a                           ; incease loop counter
284+  B444 C2 28 B4         jp nz, movement_spaceaboveisdiggable0
285+  B447              movement_spaceaboveisdiggable5:
286+  B447 21 46 B5         ld hl,player+6
287+  B44A 36 01            ld (hl),1                       ; set the player into digging mode
288+  B44C 23               inc hl
289+  B44D 36 05            ld (hl),5                       ; set the number of frame to dig for
290+  B44F 23               inc hl
291+  B450 73               ld (hl),e                       ; set the number of pixels to dig
292+  B451 C9               ret
293+  B452              movement_spaceaboveisdiggable1:
294+  B452 21 46 B5         ld hl,player+6
295+  B455 36 00            ld (hl),0                       ; set the player out of digging mode
296+  B457 C9               ret
297+  B458
298+  B458              ;
299+  B458              ; Checks if the player can move down
300+  B458              ; Inputs:
301+  B458              ; bc - player coords, b horiz, c vert
302+  B458              ; Outputs:
303+  B458              ; de - 1 can move
304+  B458              movement_checkcanmove_down:
305+  B458 F5               push af
306+  B459 C5               push bc
307+  B45A CD 70 A7         call sprites_scadd              ; get the memory location of cell into de
308+  B45D 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
309+  B45F 24               inc h                       ; memory location of cell beneath now in hl
310+  B460 3E 08            ld a,8                       ; look below
311+  B462 81               add c
312+  B463 4F               ld c,a
313+  B464 CD 6B B3         call movement_linebelowisempty       ; check space is empty
314+  B467 7B               ld a,e                          ; check space empty flag
315+  B468 FE 00            cp 0
316+  B46A CA 73 B4         jp z, movement_checkcanmove_down1 ; can't move
317+  B46D CD 46 B6         call player_justmoved
318+  B470 C1               pop bc
319+  B471 F1               pop af
320+  B472 C9               ret
321+  B473              movement_checkcanmove_down1:
322+  B473 C1               pop bc
323+  B474 CD 70 A7         call sprites_scadd              ; get the memory location of cell into de
324+  B477 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
325+  B479 24               inc h
326+  B47A C5               push bc
327+  B47B CD D5 B3         call movement_spacebelowisdiggable    ; can't move here, but can we dig
328+  B47E 11 00 00         ld de,0
329+  B481 C1               pop bc
330+  B482 F1               pop af
331+  B483 C9               ret
332+  B484
333+  B484              ;
334+  B484              ; Checks if the player can move up
335+  B484              ; Inputs:
336+  B484              ; bc - player coords, b horiz, c vert
337+  B484              ; Outputs:
338+  B484              ; de - 1 can move
339+  B484              movement_checkcanmove_up:
340+  B484 F5               push af
341+  B485 C5               push bc
342+  B486 CD 70 A7         call sprites_scadd              ; get the memory location of cell into de
343+  B489 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
344+  B48B 11 20 00         ld de,32
345+  B48E ED 52            sbc hl,de                       ; memory location of line above now in hl
346+  B490 0D               dec c                           ; look above
347+  B491 CD 86 B3         call movement_lineaboveisempty       ; check space is empty
348+  B494 7B               ld a,e                          ; check space empty flag
349+  B495 FE 00            cp 0
350+  B497 CA A2 B4         jp z, movement_checkcanmove_up1 ; can't move
351+  B49A 1E 01            ld e,1
352+  B49C CD 46 B6         call player_justmoved
353+  B49F C1               pop bc
354+  B4A0 F1               pop af
355+  B4A1 C9               ret
356+  B4A2              movement_checkcanmove_up1:
357+  B4A2 C1               pop bc
358+  B4A3 CD 70 A7         call sprites_scadd              ; get the memory location of cell into de
359+  B4A6 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
360+  B4A8 11 20 00         ld de,32
361+  B4AB ED 52            sbc hl,de                       ; memory location of line above now in hl
362+  B4AD C5               push bc
363+  B4AE CD 16 B4         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
364+  B4B1 11 00 00         ld de,0
365+  B4B4 C1               pop bc
366+  B4B5 F1               pop af
367+  B4B6 C9               ret
368+  B4B7
369+  B4B7              ;
370+  B4B7              ; Checks if the player can move right
371+  B4B7              ; Inputs:
372+  B4B7              ; bc - player coords, b horiz, c vert
373+  B4B7              ; Outputs:
374+  B4B7              ; de - 1 can move
375+  B4B7              movement_checkcanmove_right:
376+  B4B7 F5               push af
377+  B4B8 C5               push bc
378+  B4B9 CD 70 A7         call sprites_scadd              ; get the memory location of cell into de
379+  B4BC 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
380+  B4BE 3E 08            ld a,8
381+  B4C0 80               add b                           ; move one cell right
382+  B4C1 47               ld b,a
383+  B4C2 23               inc hl                          ; memory location of cell to the right now in hl
384+  B4C3 CD F1 B2         call movement_spaceisempty       ; check space is empty
385+  B4C6 7B               ld a,e                          ; check space empty flag
386+  B4C7 FE 00            cp 0
387+  B4C9 CA D2 B4         jp z, movement_checkcanmove_right1 ; can't move
388+  B4CC CD 46 B6         call player_justmoved
389+  B4CF C1               pop bc
390+  B4D0 F1               pop af
391+  B4D1 C9               ret
392+  B4D2              movement_checkcanmove_right1:
393+  B4D2 C1               pop bc
394+  B4D3 CD 70 A7         call sprites_scadd              ; get the memory location of cell into de
395+  B4D6 62 6B            ld hl,de
396+  B4D8 23               inc hl                          ; memory location of cell to the right now in hl
397+  B4D9 C5               push bc
398+  B4DA CD A1 B3         call movement_spaceisdiggable    ; can't move here, but can we dig
399+  B4DD 11 00 00         ld de,0
400+  B4E0 C1               pop bc
401+  B4E1 F1               pop af
402+  B4E2 C9               ret
403+  B4E3
404+  B4E3              ;
405+  B4E3              ; Checks if the player can move left
406+  B4E3              ; Inputs:
407+  B4E3              ; bc - player coords, b horiz, c vert
408+  B4E3              ; Outputs:
409+  B4E3              ; de - 1 can move
410+  B4E3              movement_checkcanmove_left:
411+  B4E3 F5               push af
412+  B4E4 C5               push bc
413+  B4E5 CD 70 A7         call sprites_scadd              ; get the memory location of cell into de
414+  B4E8 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
415+  B4EA 78               ld a,b
416+  B4EB 06 08            ld b,8
417+  B4ED 90               sub b                           ; move one cell left
418+  B4EE 47               ld b,a
419+  B4EF 2B               dec hl                          ; memory location of cell to the right now in hl
420+  B4F0 CD F1 B2         call movement_spaceisempty       ; check space is empty
421+  B4F3 7B               ld a,e                          ; check space empty flag
422+  B4F4 FE 00            cp 0
423+  B4F6 CA FF B4         jp z, movement_checkcanmove_left1 ; can't move
424+  B4F9 CD 46 B6         call player_justmoved
425+  B4FC C1               pop bc
426+  B4FD F1               pop af
427+  B4FE C9               ret
428+  B4FF              movement_checkcanmove_left1:
429+  B4FF C1               pop bc
430+  B500 CD 70 A7         call sprites_scadd              ; get the memory location of cell into de
431+  B503 62 6B            ld hl,de
432+  B505 2B               dec hl                          ; memory location of cell to the right now in hl
433+  B506 C5               push bc
434+  B507 CD A1 B3         call movement_spaceisdiggable    ; can't move here, but can we dig
435+  B50A 11 00 00         ld de,0
436+  B50D C1               pop bc
437+  B50E F1               pop af
438+  B50F C9               ret
# file closed: game/movement.asm
 35   B510                  include "game\game.asm"
# file opened: game/game.asm
  1+  B510              ;
  2+  B510              ; The current frame count, incremented each frame
  3+  B510              ;
  4+  B510              game_framenumber:
  5+  B510 00               defb    0
  6+  B511
  7+  B511              ;
  8+  B511              ; The number of players
  9+  B511              ;
 10+  B511              game_numberplayers:
 11+  B511 01               defb 1
 12+  B512
 13+  B512              ;
 14+  B512              ; The current player
 15+  B512              ;
 16+  B512              game_currentplayer:
 17+  B512 01               defb 1
 18+  B513
 19+  B513              ;
 20+  B513              ; The default number of lives
 21+  B513              ;
 22+  B513              game_numberlives:
 23+  B513 04               defb 4
 24+  B514
 25+  B514              ;
 26+  B514              ; Moves to the next player
 27+  B514              ;
 28+  B514              game_changeplayer:
 29+  B514 3A 12 B5         ld a,(game_currentplayer)
 30+  B517 FE 01            cp 1
 31+  B519 C8               ret z                       ; if just one player, no need to change
 32+  B51A 3D               dec a                       ; otherwise decrease by one
 33+  B51B EE 01            xor 1                       ; xor with one to flip
 34+  B51D 3C               inc a                       ; increment
 35+  B51E 21 12 B5         ld hl,game_currentplayer
 36+  B521 77               ld (hl),a                   ; store
 37+  B522 C9               ret
 38+  B523
 39+  B523              ;
 40+  B523              ; Sets the number of players at the start of the game
 41+  B523              ; Inputs:
 42+  B523              ; a - number of players
 43+  B523              game_setnumberofplayers:
 44+  B523 21 11 B5         ld hl,game_numberplayers
 45+  B526 77               ld (hl),a
 46+  B527
 47+  B527              ;
 48+  B527              ; Increment frame number by 1
 49+  B527              ;
 50+  B527              game_incrementframe:
 51+  B527 3A 10 B5         ld a,(game_framenumber)
 52+  B52A FE FF            cp 255
 53+  B52C C2 31 B5         jp nz,game_incrementframe0
 54+  B52F 3E 00            ld a,0
 55+  B531              game_incrementframe0:
 56+  B531 3C               inc a
 57+  B532 32 10 B5         ld (game_framenumber),a
 58+  B535 C9               ret
 59+  B536
 60+  B536              ;
 61+  B536              ; Returns current frame
 62+  B536              ; Outputs:
 63+  B536              ; a - current frame
 64+  B536              ;
 65+  B536              game_getcurrentframe:
 66+  B536 3A 10 B5         ld a,(game_framenumber)
 67+  B539 C9               ret
 68+  B53A
 69+  B53A              ;
 70+  B53A              ; Resets current frame
 71+  B53A              ;
 72+  B53A              game_resetcurrentframe:
 73+  B53A 21 10 B5         ld hl,game_framenumber
 74+  B53D 36 00            ld (hl),0
 75+  B53F C9               ret
# file closed: game/game.asm
 36   B540                  include "game\player.asm"
# file opened: game/player.asm
  1+  B540              ;
  2+  B540              ;   Data for current player
  3+  B540              ;
  4+  B540              player:
  5+  B540 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  B542 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  B545 00               defb    0                   ; auto move remaining (+5)
  8+  B546 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  B549 00               defb    0                   ; lives remaining (+9)
 10+  B54A 00               defb    0                   ; died this life (+10)
 11+  B54B 00 00            defb    0,0                 ; crushed (+11), frames (+12)
 12+  B54D
 13+  B54D              ;
 14+  B54D              ; Score for the current player
 15+  B54D              ;
 16+  B54D              player_score:
 17+  B54D 30 30 30 30      defb '000000'
 17+  B551 30 30
 18+  B553              ;
 19+  B553              ; Initializes a player at start of game
 20+  B553              ; Copy initial coords, copy lives, copy score
 21+  B553              ;
 22+  B553              player_init_gamestart:
 23+  B553 3A 13 B5         ld a,(game_numberlives)
 24+  B556 32 A7 B5         ld (player1_lives),a
 25+  B559 32 A8 B5         ld (player2_lives),a                        ; set the initial number of lives at game start
 26+  B55C C9               ret
 27+  B55D
 28+  B55D              ;
 29+  B55D              ; Initializes a player at start of a life
 30+  B55D              ; Copy initial coords, copy lives, copy score
 31+  B55D              ;
 32+  B55D              player_init_lifestart:
 33+  B55D ED 4B 22 80      ld bc,(init_coord)
 34+  B561 ED 43 40 B5      ld (player),bc
 35+  B565 01 49 B5         ld bc,player+9
 36+  B568 3A A7 B5         ld a,(player1_lives)
 37+  B56B 02               ld (bc),a
 38+  B56C 01 4A B5         ld bc,player+10
 39+  B56F 3E 00            ld a,0
 40+  B571 02               ld (bc),a
 41+  B572 01 4B B5         ld bc,player+11         ; crushed
 42+  B575 3E 00            ld a,0
 43+  B577 02               ld (bc),a
 44+  B578 01 4C B5         ld bc,player+12         ; crush count
 45+  B57B 3E 00            ld a,0
 46+  B57D 02               ld (bc),a
 47+  B57E 01 42 B5         ld bc,player+2         ; frame
 48+  B581 3E 02            ld a,2
 49+  B583 02               ld (bc),a
 50+  B584 01 46 B5         ld bc,player+6         ; frame
 51+  B587 3E 00            ld a,0
 52+  B589 02               ld (bc),a
 53+  B58A 01 45 B5         ld bc,player+5         ; automove
 54+  B58D 3E 00            ld a,0
 55+  B58F 02               ld (bc),a
 56+  B590 CD 8A BA         call diamonds_init      ; initialise gems
 57+  B593 C9               ret
 58+  B594
 59+  B594              ;
 60+  B594              ; Finalises a player at end of a life
 61+  B594              ; Copy lives, copy score
 62+  B594              ;
 63+  B594              player_lifeend:
 64+  B594 01 49 B5         ld bc,player+9
 65+  B597 0A               ld a,(bc)
 66+  B598 01 A7 B5         ld bc,player1_lives
 67+  B59B 02               ld (bc),a
 68+  B59C C9               ret
 69+  B59D
 70+  B59D              ;
 71+  B59D              ; Player just died, subtract a life
 72+  B59D              ;
 73+  B59D              player_died:
 74+  B59D 01 49 B5         ld bc,player+9
 75+  B5A0 0A               ld a,(bc)
 76+  B5A1 3D               dec a
 77+  B5A2 02               ld (bc),a
 78+  B5A3 CD 94 B5         call player_lifeend
 79+  B5A6 C9               ret
 80+  B5A7
 81+  B5A7              ;
 82+  B5A7              ; Player lives
 83+  B5A7              ;
 84+  B5A7              player1_lives:
 85+  B5A7 03               defb 3
 86+  B5A8              player2_lives:
 87+  B5A8 03               defb 3
 88+  B5A9
 89+  B5A9              ;
 90+  B5A9              ; Player scores
 91+  B5A9              ;
 92+  B5A9              player1_score:
 93+  B5A9 30 30 30 30      defb '000000'
 93+  B5AD 30 30
 94+  B5AF              player2_score:
 95+  B5AF 30 30 30 30      defb '000000'
 95+  B5B3 30 30
 96+  B5B5
 97+  B5B5              ;
 98+  B5B5              ; Kills a player this life
 99+  B5B5              ;
100+  B5B5              player_killplayer:
101+  B5B5 21 4A B5         ld hl,player+10
102+  B5B8 36 01            ld (hl),1
103+  B5BA C9               ret
104+  B5BB
105+  B5BB              ;
106+  B5BB              ; Crush a player this life
107+  B5BB              ;
108+  B5BB              player_crushplayer:
109+  B5BB 21 4B B5         ld hl,player+11             ; mark as crushed
110+  B5BE 36 01            ld (hl),1
111+  B5C0 C9               ret
112+  B5C1
113+  B5C1              ;
114+  B5C1              ; Draws the player at the current position or deletes them
115+  B5C1              ;
116+  B5C1              player_drawplayer:
117+  B5C1 3A 42 B5         ld a,(player+2)             ; get the current direction
118+  B5C4 FE 03            cp 3
119+  B5C6 C2 CB B5         jp nz,player_drawplayer0
120+  B5C9 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
121+  B5CB              player_drawplayer0:
122+  B5CB 5F               ld e,a                      ; store in e
123+  B5CC 3A 4B B5         ld a,(player+11)             ; get the dying flag
124+  B5CF FE 01            cp 1
125+  B5D1 CA E3 B5         jp z,player_drawplayer3     ; if it's one, we're being crushed
126+  B5D4              player_drawplayer4:
127+  B5D4 3A 46 B5         ld a,(player+6)             ; get the dig flag
128+  B5D7 FE 01            cp 1
129+  B5D9 CA 2C B6         jp z,player_drawplayer1    ; get dig frame
130+  B5DC 3A 43 B5         ld a,(player+3)             ; this is normal movement so get the current frame
131+  B5DF 83               add a,e
132+  B5E0 C3 31 B6         jp player_drawplayer2
133+  B5E3              player_drawplayer3:
134+  B5E3 21 4C B5         ld hl,player+12
135+  B5E6 7E               ld a,(hl)                  ; crushing, so get the current anim flag
136+  B5E7 FE 00            cp 0
137+  B5E9 C2 F2 B5         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
138+  B5EC 3E 64            ld a,100
139+  B5EE 77               ld (hl),a                   ; otherwise, load up the anim frames
140+  B5EF C3 D4 B5         jp player_drawplayer4       ; and return to the main loop to remove the current frame
141+  B5F2              player_drawplayer5:
142+  B5F2 3D               dec a
143+  B5F3 77               ld (hl),a
144+  B5F4 FE 00            cp 0
145+  B5F6 CC B5 B5         call z,player_killplayer    ; final animation, so kill the player
146+  B5F9 FE 14            cp 20                        ; check if we should move the rock
147+  B5FB C2 0F B6         jp nz,player_drawplayer8
148+  B5FE D9               exx
149+  B5FF 08               ex af,af'
150+  B600 ED 4B 4B B8      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
151+  B604 21 76 AF         ld hl,sprites+72
152+  B607 CD 2D A7         call sprites_drawsprite     ; draw a rock over current
153+  B60A 08               ex af,af'
154+  B60B D9               exx
155+  B60C C3 25 B6         jp player_drawplayer6       ; continue drawing player
156+  B60F              player_drawplayer8:
157+  B60F FE 14            cp 20
158+  B611 D2 25 B6         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
159+  B614 ED 4B 40 B5      ld bc,(player)
160+  B618 CD B4 A6         call screen_getattraddressfromscreencoords ; get the attr address into de
161+  B61B 62 6B            ld hl,de
162+  B61D 36 42            ld (hl),66
163+  B61F 21 76 AF         ld hl,sprites+72            ; otherwise, player is rock
164+  B622 C3 3B B6         jp player_drawplayer7
165+  B625              player_drawplayer6:
166+  B625 E6 01            and 1                       ; check for odd
167+  B627 C6 0A            add 10                      ; add 10, to get either 10 or 11
168+  B629 C3 31 B6         jp player_drawplayer2
169+  B62C              player_drawplayer1:
170+  B62C 3A 42 B5         ld a,(player+2)             ; digging, get the current direction again, because want all four
171+  B62F C6 06            add a,6                     ; add direction to 6 to get frame
172+  B631              player_drawplayer2:
173+  B631 07               rlca
174+  B632 07               rlca
175+  B633 07               rlca                        ; multiply by eight
176+  B634 6F               ld l,a
177+  B635 26 00            ld h,0
178+  B637 11 B5 AF         ld de,player_sprite
179+  B63A 19               add hl,de                   ; load hl with the location of the player sprite data
180+  B63B              player_drawplayer7:
181+  B63B ED 4B 40 B5      ld bc,(player)              ; load bc with the start coords
182+  B63F CD 2D A7         call sprites_drawsprite     ; call the routine to draw the sprite
183+  B642 CD 72 B6         call player_storeupdatedlines ; log updated rows
184+  B645 C9               ret
185+  B646
186+  B646
187+  B646              ;
188+  B646              ; Runs after the player just moved. Changes animation frame if required
189+  B646              ;
190+  B646              player_justmoved:
191+  B646 D9               exx
192+  B647 3A 44 B5         ld a,(player+4)             ; get the transition count
193+  B64A FE 00            cp 0
194+  B64C CA 52 B6         jp z, player_justmoved2     ; if zero reset and change the frame
195+  B64F C3 6C B6         jp player_justmoved1       ; otherwise decrease and continue
196+  B652              player_justmoved2:
197+  B652                  ; reset and change frame in here
198+  B652 3E 01            ld a,1
199+  B654 32 44 B5         ld (player+4),a            ; reset back to whatever
200+  B657 3A 43 B5         ld a,(player+3)             ; load the frame
201+  B65A FE 03            cp 3                       ; flip between 3 and 0
202+  B65C C2 64 B6         jp nz, player_justmoved4
203+  B65F 3E 00            ld a,0
204+  B661 C3 66 B6         jp player_justmoved5
205+  B664              player_justmoved4:
206+  B664 3E 03            ld a,3
207+  B666              player_justmoved5:
208+  B666 32 43 B5         ld (player+3),a           ; save back
209+  B669 C3 70 B6         jp player_justmoved3
210+  B66C              player_justmoved1:
211+  B66C                  ; decrease count
212+  B66C 3D               dec a
213+  B66D 32 44 B5         ld (player+4),a
214+  B670              player_justmoved3:
215+  B670 D9               exx;
216+  B671 C9               ret
217+  B672
218+  B672              ;
219+  B672              ; Stores the updated rows associated with the player
220+  B672              ;
221+  B672              player_storeupdatedlines:
222+  B672 ED 4B 40 B5      ld bc,(player)          ; get the screen coords into bc
223+  B676 79               ld a,c                  ; get the player block coords of current block
224+  B677 E6 F8            and 248                 ; find closest multiple of eight
225+  B679 0F               rrca
226+  B67A 0F               rrca
227+  B67B 0F               rrca                    ; divide by 8
228+  B67C ED 5B 8C A5      ld de,(screen_offset)          ; load the screen offset, this is in rows
229+  B680 93               sub e
230+  B681 F5               push af
231+  B682 CD 3F A4         call buffer_marklineforupdate  ; store current row in updated lines
232+  B685 F1               pop af
233+  B686 3D               dec a
234+  B687 F5               push af
235+  B688 CD 3F A4         call buffer_marklineforupdate  ; store line above
236+  B68B F1               pop af
237+  B68C 3C               inc a
238+  B68D 3C               inc a
239+  B68E CD 3F A4         call buffer_marklineforupdate  ; store line beneath
240+  B691 C9               ret
# file closed: game/player.asm
 37   B692                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  B692              ;
  2+  B692              ; Ship initial position: vert,horiz
  3+  B692              ;
  4+  B692              ship_initpos:
  5+  B692 00 24            defb 0,36
  6+  B694              ship_initpos2:
  7+  B694 00 00            defb 0,0
  8+  B696              ship_frame:
  9+  B696 00               defb 0
 10+  B697              ;
 11+  B697              ; The current memory location
 12+  B697              ;
 13+  B697              ship_current_sprite:
 14+  B697 00 00            defb 0,0
 15+  B699
 16+  B699              ship_current_coords:
 17+  B699 00 00            defb 0,0
 18+  B69B
 19+  B69B              ;
 20+  B69B              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 21+  B69B              ;
 22+  B69B              ship_land:
 23+  B69B ED 4B 92 B6      ld bc,(ship_initpos)
 24+  B69F ED 43 94 B6      ld (ship_initpos2),bc        ; save the initial position for later use
 25+  B6A3 1E 00            ld e,0                      ; store a flag to track first time round
 26+  B6A5 06 09            ld b,9                      ; move down 8 pixels
 27+  B6A7              ship_land0:
 28+  B6A7 C5               push bc
 29+  B6A8 7B               ld a,e
 30+  B6A9 D5               push de                     ; store de for next time round
 31+  B6AA FE 01            cp 1                        ; check first time flag
 32+  B6AC C2 C1 B6         jp nz,ship_land1             ; don't draw over previous one if first time
 33+  B6AF CD 29 B7         call ship_draw_full         ; delete old one
 34+  B6B2 CD FE B6         call ship_change_frame      ; increment the frame
 35+  B6B5 ED 4B 94 B6      ld bc,(ship_initpos2)       ; get the current coords
 36+  B6B9 81 C6 01         add c,1                     ; move down one pixels
 37+  B6BC 4F               ld c,a
 38+  B6BD ED 43 94 B6      ld (ship_initpos2),bc
 39+  B6C1              ship_land1:
 40+  B6C1 CD 29 B7         call ship_draw_full         ; draw the ship
 41+  B6C4 CD 13 B7         call ship_draw_screen
 42+  B6C7 D1               pop de
 43+  B6C8 1E 01            ld e,1
 44+  B6CA C1               pop bc
 45+  B6CB 10 DA            djnz ship_land0             ; repeat for downward movement
 46+  B6CD                  ; done moving down
 47+  B6CD                  ; now move across
 48+  B6CD CD C1 B5         call player_drawplayer      ; draw player
 49+  B6D0 CD 29 B7         call ship_draw_full         ; delete old one
 50+  B6D3 1E 00            ld e,0                      ; store a flag to track first time round
 51+  B6D5 06 14            ld b,20                      ; move back 20 pixels pixels
 52+  B6D7              ship_land3:
 53+  B6D7 C5               push bc
 54+  B6D8 7B               ld a,e
 55+  B6D9 D5               push de                     ; store de for next time round
 56+  B6DA FE 01            cp 1                        ; check first time flag
 57+  B6DC C2 F1 B6         jp nz,ship_land2             ; don't draw over previous one if first time
 58+  B6DF CD 29 B7         call ship_draw_full         ; delete old one
 59+  B6E2 CD FE B6         call ship_change_frame      ; increment the frame
 60+  B6E5 ED 4B 94 B6      ld bc,(ship_initpos2)       ; get the current coords
 61+  B6E9 78               ld a,b
 62+  B6EA D6 01            sub 1                       ; move back one pixels
 63+  B6EC 47               ld b,a
 64+  B6ED ED 43 94 B6      ld (ship_initpos2),bc
 65+  B6F1              ship_land2:
 66+  B6F1 CD 29 B7         call ship_draw_full         ; draw the ship
 67+  B6F4 CD 13 B7         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 68+  B6F7 D1               pop de
 69+  B6F8 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 70+  B6FA C1               pop bc
 71+  B6FB 10 DA            djnz ship_land3             ; repeat for vertical movement
 72+  B6FD C9               ret
 73+  B6FE
 74+  B6FE              ;
 75+  B6FE              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
 76+  B6FE              ;
 77+  B6FE              ship_change_frame:
 78+  B6FE F5               push af
 79+  B6FF 3A 96 B6         ld a,(ship_frame)
 80+  B702 FE 00            cp 0
 81+  B704 CA 0C B7         jp z,ship_change_frame0
 82+  B707 3E 00            ld a,0                      ; flip to 0
 83+  B709 C3 0E B7         jp ship_change_frame1
 84+  B70C              ship_change_frame0:
 85+  B70C 3E 20            ld a,32                      ; flip to 32
 86+  B70E              ship_change_frame1:
 87+  B70E 32 96 B6         ld (ship_frame),a            ; save the frame
 88+  B711 F1               pop af
 89+  B712 C9               ret
 90+  B713
 91+  B713              ship_draw_screen:
 92+  B713 3E 00            ld a,0
 93+  B715 CD 3F A4         call buffer_marklineforupdate
 94+  B718 3E 01            ld a,1
 95+  B71A CD 3F A4         call buffer_marklineforupdate
 96+  B71D 3E 02            ld a,2
 97+  B71F CD 3F A4         call buffer_marklineforupdate   ; mark the first three rows for update
 98+  B722 76               halt
 99+  B723 F3               di
100+  B724 CD D3 A4         call buffer_buffertoscreen  ; copy buffer to screen
101+  B727 FB               ei                          ; enable interupts
102+  B728 C9               ret
103+  B729
104+  B729              ship_draw_full:
105+  B729 21 15 B0         ld hl,ship_sprite
106+  B72C ED 4B 94 B6      ld bc,(ship_initpos2)         ; load bc with the start coords
107+  B730 22 97 B6         ld (ship_current_sprite),hl  ; put into memory
108+  B733 ED 43 99 B6      ld (ship_current_coords),bc  ; put into memory
109+  B737 CD 56 B7         call ship_draw
110+  B73A 08               ex af,af'
111+  B73B 3A 96 B6         ld a,(ship_frame)            ; get the animation frame
112+  B73E 16 00            ld d,0
113+  B740 5F               ld e,a
114+  B741 19               add hl,de
115+  B742 22 97 B6         ld (ship_current_sprite),hl  ; put into memory
116+  B745 08               ex af,af'
117+  B746 ED 4B 94 B6      ld bc,(ship_initpos2)         ; load bc with the start coords
118+  B74A 81 C6 08         add c,8                      ; move one line down
119+  B74D 4F               ld c,a
120+  B74E ED 43 99 B6      ld (ship_current_coords),bc  ; put into memory
121+  B752 CD 56 B7         call ship_draw
122+  B755 C9               ret
123+  B756
124+  B756              ;
125+  B756              ; Draw the ship
126+  B756              ; Inputs:
127+  B756              ; None, all in memory
128+  B756              ;
129+  B756              ship_draw:
130+  B756 3E 04            ld a,4                              ; 4 pieces per half
131+  B758              ship_draw0:
132+  B758 F5               push af
133+  B759 2A 97 B6         ld hl,(ship_current_sprite)
134+  B75C ED 4B 99 B6      ld bc,(ship_current_coords)         ; load bc with the start coords
135+  B760 CD 2D A7         call sprites_drawsprite
136+  B763 2A 97 B6         ld hl,(ship_current_sprite)
137+  B766 ED 4B 99 B6      ld bc,(ship_current_coords)         ; load bc with the start coords
138+  B76A 11 08 00         ld de,8
139+  B76D 19               add hl,de
140+  B76E 80 C6 08         add b,8
141+  B771 47               ld b,a
142+  B772 22 97 B6         ld (ship_current_sprite),hl         ; put into memory
143+  B775 ED 43 99 B6      ld (ship_current_coords),bc         ; put into memory
144+  B779 F1               pop af
145+  B77A 3D               dec a
146+  B77B FE 00            cp 0
147+  B77D C2 58 B7         jp nz,ship_draw0
148+  B780
149+  B780 C9               ret
150+  B781
# file closed: game/ship.asm
 38   B781                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  B781              ;
  2+  B781              ; tank initial position: vert,horiz
  3+  B781              ;
  4+  B781              tank_initpos:
  5+  B781 10 D0            defb 16,208
  6+  B783              tank_initpos2:
  7+  B783 00 00            defb 0,0
  8+  B785              tank_frame:
  9+  B785 00               defb 0
 10+  B786              tank_anim:
 11+  B786 11               defb 17
 12+  B787              ;
 13+  B787              ; The current memory location
 14+  B787              ;
 15+  B787              tank_current_sprite:
 16+  B787 00 00            defb 0,0
 17+  B789
 18+  B789              tank_current_coords:
 19+  B789 00 00            defb 0,0
 20+  B78B
 21+  B78B              ;
 22+  B78B              ; Initialise the tank
 23+  B78B              ;
 24+  B78B              tank_init:
 25+  B78B ED 4B 81 B7      ld bc,(tank_initpos)
 26+  B78F ED 43 83 B7      ld (tank_initpos2),bc       ; save the initial position for later use
 27+  B793 21 85 B7         ld hl,tank_frame
 28+  B796 36 00            ld (hl),0
 29+  B798 21 86 B7         ld hl,tank_anim
 30+  B79B 36 11            ld (hl),17                  ; reset tank
 31+  B79D C9               ret
 32+  B79E
 33+  B79E              ;
 34+  B79E              ;   Draw and move the tank
 35+  B79E              ;   Start processing at frame 200
 36+  B79E              ;   Don't move if anim is zero
 37+  B79E              ;   Decrement frame if moved
 38+  B79E              ;
 39+  B79E              tank_process:
 40+  B79E 3A 86 B7         ld a,(tank_anim)
 41+  B7A1 FE 00            cp 0
 42+  B7A3 C8               ret z                       ; return if we've already moved
 43+  B7A4 CD 36 B5         call game_getcurrentframe   ; get the current frame number into a
 44+  B7A7 FE 4B            cp 75
 45+  B7A9 D8               ret c                       ; return if the frame number is below 100
 46+  B7AA CD B5 B7         call tank_move              ; move tank if not
 47+  B7AD 3A 86 B7         ld a,(tank_anim)
 48+  B7B0 3D               dec a
 49+  B7B1 32 86 B7         ld (tank_anim),a            ; decrease the anim count
 50+  B7B4 C9               ret
 51+  B7B5
 52+  B7B5              tank_move:
 53+  B7B5 ED 4B 83 B7      ld bc,(tank_initpos2)
 54+  B7B9 C5               push bc
 55+  B7BA 3A 86 B7         ld a,(tank_anim)
 56+  B7BD FE 11            cp 17                       ; check first time flag
 57+  B7BF CA D1 B7         jp z,tank_move1             ; don't draw over previous one if first time
 58+  B7C2 CD D6 B7         call tank_draw_full         ; delete old one
 59+  B7C5 ED 4B 83 B7      ld bc,(tank_initpos2)       ; get the current coords
 60+  B7C9 78               ld a,b
 61+  B7CA D6 01            sub 1                       ; move back one pixels
 62+  B7CC 47               ld b,a
 63+  B7CD ED 43 83 B7      ld (tank_initpos2),bc
 64+  B7D1              tank_move1:
 65+  B7D1 CD D6 B7         call tank_draw_full         ; draw the tank
 66+  B7D4 C1               pop bc
 67+  B7D5 C9               ret
 68+  B7D6
 69+  B7D6              tank_draw_full:
 70+  B7D6 21 75 B0         ld hl,tank_sprite
 71+  B7D9 ED 4B 83 B7      ld bc,(tank_initpos2)         ; load bc with the start coords
 72+  B7DD 22 87 B7         ld (tank_current_sprite),hl  ; put into memory
 73+  B7E0 ED 43 89 B7      ld (tank_current_coords),bc  ; put into memory
 74+  B7E4 CD 0D B8         call tank_draw
 75+  B7E7 08               ex af,af'
 76+  B7E8 3A 85 B7         ld a,(tank_frame)            ; get the animation frame
 77+  B7EB 16 00            ld d,0
 78+  B7ED 5F               ld e,a
 79+  B7EE 19               add hl,de
 80+  B7EF 22 87 B7         ld (tank_current_sprite),hl  ; put into memory
 81+  B7F2 08               ex af,af'
 82+  B7F3 ED 4B 83 B7      ld bc,(tank_initpos2)         ; load bc with the start coords
 83+  B7F7 81 C6 08         add c,8                      ; move one line down
 84+  B7FA 4F               ld c,a
 85+  B7FB ED 43 89 B7      ld (tank_current_coords),bc  ; put into memory
 86+  B7FF CD 0D B8         call tank_draw
 87+  B802 3E 02            ld a,2
 88+  B804 CD 3F A4         call buffer_marklineforupdate
 89+  B807 3E 03            ld a,3
 90+  B809 CD 3F A4         call buffer_marklineforupdate   ; mark the first two rows for update
 91+  B80C C9               ret
 92+  B80D
 93+  B80D              ;
 94+  B80D              ; Draw the tank
 95+  B80D              ; Inputs:
 96+  B80D              ; None, all in memory
 97+  B80D              ;
 98+  B80D              tank_draw:
 99+  B80D 3E 04            ld a,4                              ; 4 pieces per half
100+  B80F              tank_draw0:
101+  B80F F5               push af
102+  B810 2A 87 B7         ld hl,(tank_current_sprite)
103+  B813 ED 4B 89 B7      ld bc,(tank_current_coords)         ; load bc with the start coords
104+  B817 CD 2D A7         call sprites_drawsprite
105+  B81A 2A 87 B7         ld hl,(tank_current_sprite)
106+  B81D ED 4B 89 B7      ld bc,(tank_current_coords)         ; load bc with the start coords
107+  B821 11 08 00         ld de,8
108+  B824 19               add hl,de
109+  B825 80 C6 08         add b,8
110+  B828 47               ld b,a
111+  B829 22 87 B7         ld (tank_current_sprite),hl         ; put into memory
112+  B82C ED 43 89 B7      ld (tank_current_coords),bc         ; put into memory
113+  B830 F1               pop af
114+  B831 3D               dec a
115+  B832 FE 00            cp 0
116+  B834 C2 0F B8         jp nz,tank_draw0
117+  B837
118+  B837 C9               ret
119+  B838
# file closed: game/tank.asm
 39   B838                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  B838              ;
  2+  B838              ; A structure of falling rocks
  3+  B838              ; Assume we'll never have more than 4 falling at any one time
  4+  B838              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  B838              ;
  6+  B838              rocks_falling:
  7+  B838 00 00 00 00      defb 0,0,0,0
  8+  B83C 00 00 00 00      defb 0,0,0,0
  9+  B840 00 00 00 00      defb 0,0,0,0
 10+  B844 00 00 00 00      defb 0,0,0,0
 11+  B848
 12+  B848              rocks_tmp:
 13+  B848 00               defb 0
 14+  B849
 15+  B849              rocks_tmp2:
 16+  B849 00 00            defb 0,0
 17+  B84B
 18+  B84B              ;
 19+  B84B              ; Coords of the rock that killed us
 20+  B84B              ;
 21+  B84B              rocks_killerrock:
 22+  B84B 00 00            defb 0,0
 23+  B84D
 24+  B84D              ;
 25+  B84D              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 26+  B84D              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 27+  B84D              ; If the pixel row is not the rock bottom, stop checking.
 28+  B84D              ; Inputs:
 29+  B84D              ; hl- memory location
 30+  B84D              ;
 31+  B84D              rocks_checkforfalling:
 32+  B84D 7E               ld a,(hl)           ; get the pixel row in this memory location
 33+  B84E FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 34+  B850 C2 56 B8         jp nz,rocks_checkforfalling2 ; not a rock, stop
 35+  B853 CD 57 B8         call rocks_addrocktofalling ; mark the rock as falling
 36+  B856              rocks_checkforfalling2:
 37+  B856 C9               ret
 38+  B857
 39+  B857              ;
 40+  B857              ; Adds the rock to the structure that tracks falling rocks
 41+  B857              ; Inputs:
 42+  B857              ; hl - memory location of falling rock graphic
 43+  B857              ; bc - coords of rock, c vert
 44+  B857              rocks_addrocktofalling:
 45+  B857 C5               push bc             ; store the coords
 46+  B858 11 38 B8         ld de,rocks_falling
 47+  B85B 06 04            ld b,4              ; number of possible falling rocks
 48+  B85D              rocks_addrocktofalling0:
 49+  B85D 13               inc de
 50+  B85E 13               inc de
 51+  B85F 13               inc de              ; move three along to get the state
 52+  B860 1A               ld a,(de)           ; load the state
 53+  B861 FE 00            cp 0                ; check if this is not falling
 54+  B863 C2 78 B8         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 55+  B866 3E 10            ld a,16             ; load the number of frames to wobble
 56+  B868 12               ld (de),a
 57+  B869 1B               dec de              ; move de back to state
 58+  B86A 3E 02            ld a,2
 59+  B86C 12               ld (de),a           ; set the state to wobbling
 60+  B86D 1B               dec de              ; move back coords
 61+  B86E C1               pop bc              ; get back coords
 62+  B86F 78               ld a,b
 63+  B870 12               ld (de),a           ; store the vertical
 64+  B871 1B               dec de
 65+  B872 79               ld a,c
 66+  B873 12               ld (de),a           ; store the horizontal
 67+  B874 C5               push bc
 68+  B875 C3 7B B8         jp rocks_addrocktofalling2 ; done
 69+  B878              rocks_addrocktofalling1:
 70+  B878 13               inc de              ; move memory along to next rock
 71+  B879 10 E2            djnz rocks_addrocktofalling0 ; try the next rock
 72+  B87B              rocks_addrocktofalling2: ; done, return
 73+  B87B C1               pop bc              ; to tidy up
 74+  B87C C9               ret
 75+  B87D
 76+  B87D              ;
 77+  B87D              ; Processes any falling rocks
 78+  B87D              ;
 79+  B87D              rocks_processrocks:
 80+  B87D DD 21 38 B8      ld ix,rocks_falling
 81+  B881 06 04            ld b,4              ; the number of rocks to check
 82+  B883              rocks_processrocks0:
 83+  B883 C5               push bc             ; store loop count
 84+  B884 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 84+  B888 46 01
 85+  B88A DD 23            inc ix
 86+  B88C DD 23            inc ix              ; move to the state
 87+  B88E DD 7E 00         ld a,(ix)           ; load the state into a
 88+  B891 FE 00            cp 0
 89+  B893 CA B7 B8         jp z,rocks_processrocks3 ; if not falling, check next
 90+  B896 FE 02            cp 2
 91+  B898 C2 A8 B8         jp nz, rocks_processrocks2
 92+  B89B                  ; we're wobbling
 93+  B89B DD 23            inc ix              ; get frame number for wobble
 94+  B89D DD 7E 00         ld a,(ix)           ; get wobble frame into a
 95+  B8A0 CD 75 B9         call rocks_wobble
 96+  B8A3 DD 23            inc ix              ; increment for next
 97+  B8A5 C3 BB B8         jp rocks_processrocks1  ; do next rock
 98+  B8A8              rocks_processrocks2:
 99+  B8A8                  ; we're falling
100+  B8A8 C5               push bc
101+  B8A9 CD D4 B8         call rocks_fall
102+  B8AC C1               pop bc
103+  B8AD CD BF B8         call rocks_storeupdatedlines
104+  B8B0 DD 23            inc ix
105+  B8B2 DD 23            inc ix              ; inc ix to get to next
106+  B8B4 C3 BB B8         jp rocks_processrocks1
107+  B8B7              rocks_processrocks3:
108+  B8B7 DD 23            inc ix
109+  B8B9 DD 23            inc ix
110+  B8BB              rocks_processrocks1:
111+  B8BB C1               pop bc              ; get loop count back
112+  B8BC 10 C5            djnz rocks_processrocks0
113+  B8BE C9               ret
114+  B8BF
115+  B8BF              ;
116+  B8BF              ; Stores the updated rows associated with the rock
117+  B8BF              ; Inputs:
118+  B8BF              ; bc - coords
119+  B8BF              ;
120+  B8BF              rocks_storeupdatedlines:
121+  B8BF 79               ld a,c                  ; get the player block coords of current block
122+  B8C0 E6 F8            and 248                 ; find closest multiple of eight
123+  B8C2 0F               rrca
124+  B8C3 0F               rrca
125+  B8C4 0F               rrca                    ; divide by 8
126+  B8C5 ED 5B 8C A5      ld de,(screen_offset)          ; load the screen offset, this is in rows
127+  B8C9 93               sub e
128+  B8CA F5               push af
129+  B8CB CD 3F A4         call buffer_marklineforupdate  ; store current row in updated lines
130+  B8CE F1               pop af
131+  B8CF 3C               inc a
132+  B8D0 CD 3F A4         call buffer_marklineforupdate  ; store line beneath
133+  B8D3 C9               ret
134+  B8D4
135+  B8D4              ;
136+  B8D4              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
137+  B8D4              ; bc - coord of current rock graphic on screen
138+  B8D4              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
139+  B8D4              ;
140+  B8D4              rocks_fall:
141+  B8D4 DD 2B            dec ix
142+  B8D6 DD 2B            dec ix              ; decrease ix back to coords
143+  B8D8 ED 43 49 B8      ld (rocks_tmp2),bc  ; store original coords
144+  B8DC 3E 03            ld a,3              ; move this number of pixels
145+  B8DE              rocks_fall1:
146+  B8DE 08               ex af,af'
147+  B8DF DD 4E 00 DD      ld bc,(ix)          ; get current coords
147+  B8E3 46 01
148+  B8E5 CD 70 A7         call sprites_scadd  ; get the memory of the coords into de
149+  B8E8 14               inc d               ; add 256 to get next row
150+  B8E9 1A               ld a,(de)           ; get the contents of the next row
151+  B8EA FE 00            cp 0
152+  B8EC C2 45 B9         jp nz,rocks_fall3    ; move the rock if the row is empty
153+  B8EF 0C               inc c               ; increment the vertical
154+  B8F0 DD 71 00 DD      ld (ix),bc          ; store the new coords
154+  B8F4 70 01
155+  B8F6 79               ld a,c              ; get the vertical coord into a
156+  B8F7 E6 07            and 7               ; divisible by 8?
157+  B8F9 FE 00            cp 0
158+  B8FB C2 16 B9         jp nz,rocks_fall4   ; if not, carry on
159+  B8FE CD B4 A6         call screen_getattraddressfromscreencoords ; get the attr address into de
160+  B901 62 6B            ld hl,de
161+  B903 36 42            ld (hl),66          ; load this square with the yellow colour
162+  B905 DD 4E 00 DD      ld bc,(ix)
162+  B909 46 01
163+  B90B 79               ld a,c              ; get vertical
164+  B90C D6 08            sub 8               ; look up one square
165+  B90E 4F               ld c,a              ; put a back in c
166+  B90F CD B4 A6         call screen_getattraddressfromscreencoords ; get the attr address into de
167+  B912 62 6B            ld hl,de
168+  B914 36 46            ld (hl),70          ; load this square with the yellow colour
169+  B916              rocks_fall4:
170+  B916 08               ex af,af'
171+  B917 3D               dec a
172+  B918 FE 00            cp 0
173+  B91A C2 DE B8         jp nz,rocks_fall1   ; do another pixel if needed
174+  B91D              rocks_fall2:
175+  B91D 3E 09            ld a,9              ; rock graphic
176+  B91F ED 4B 49 B8      ld bc,(rocks_tmp2)  ; get the original coords
177+  B923 CD 0B A7         call screen_getblock     ; get the memory into hl
178+  B926 CD 2D A7         call sprites_drawsprite  ; draw the sprite - over the top of the current one
179+  B929 3E 09            ld a,9
180+  B92B DD 4E 00 DD      ld bc,(ix)          ; get the new coords
180+  B92F 46 01
181+  B931 CD 0B A7         call screen_getblock     ; get the memory into hl
182+  B934 CD 2D A7         call sprites_drawsprite  ; draw the sprite - over the top of the current one
183+  B937 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
183+  B93B 46 01
184+  B93D CD 5A B9         call rocks_checkforplayer ; check to see if we hit a player
185+  B940 DD 23            inc ix
186+  B942 DD 23            inc ix                  ; get ix back to state
187+  B944 C9               ret
188+  B945              rocks_fall3:
189+  B945 3E 00            ld a,0              ; set the state to fell
190+  B947 DD 77 02         ld (ix+2),a           ; store the falling state
191+  B94A DD 4E 00 DD      ld bc,(ix)          ; get the coords
191+  B94E 46 01
192+  B950 CD B4 A6         call screen_getattraddressfromscreencoords ; get the attr address into de
193+  B953 62 6B            ld hl,de
194+  B955 36 42            ld (hl),66
195+  B957 C3 1D B9         jp rocks_fall2      ; rejoin main loop
196+  B95A
197+  B95A              ;
198+  B95A              ; Checks to see if the rock is hitting a player
199+  B95A              ; Inputs:
200+  B95A              ; bc - coords of rock we're checking
201+  B95A              rocks_checkforplayer:
202+  B95A ED 5B 40 B5      ld de,(player)       ; get the player coords
203+  B95E 7B               ld a,e               ; get the vert coord first
204+  B95F 91               sub c                ; subtract the rock vertical coord from players
205+  B960 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
206+  B962 C0               ret nz               ; if not, hasn't hit
207+  B963 7A               ld a,d               ; get the player horiz coord
208+  B964 90               sub b                ; subtract rock coord
209+  B965 C6 07            add 7                ; add max distance
210+  B967 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
211+  B969 DA 6D B9         jp c,rocks_checkforplayer0
212+  B96C C9               ret
213+  B96D              rocks_checkforplayer0:
214+  B96D ED 43 4B B8      ld (rocks_killerrock),bc; store the coords of the killer rock
215+  B971 CD BB B5         call player_crushplayer ; if so, jump out
216+  B974 C9               ret
217+  B975
218+  B975              ;
219+  B975              ; Wobbles a rocks
220+  B975              ; Inputs:
221+  B975              ; bc - coord of current rock graphic on screen
222+  B975              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
223+  B975              ; a - wobble frame
224+  B975              rocks_wobble:
225+  B975 3A 48 B8         ld a,(rocks_tmp)    ; get the frame toggle
226+  B978 1E 09            ld e,9              ; this is the rock frame
227+  B97A 83               add a,e             ; add the frame toggle
228+  B97B C5               push bc
229+  B97C CD 0B A7         call screen_getblock     ; get the memory into hl
230+  B97F CD 2D A7         call sprites_drawsprite  ; draw the sprite - over the top of the current one
231+  B982 3A 48 B8         ld a,(rocks_tmp)    ; get the frame toggle against
232+  B985 EE 01            xor 1               ; flip to other state
233+  B987 32 48 B8         ld (rocks_tmp),a    ; store
234+  B98A 1E 09            ld e,9              ; this is the rock frame
235+  B98C 83               add a,e             ; add the frame toggle
236+  B98D CD 0B A7         call screen_getblock     ; get the memory into hl
237+  B990 C1               pop bc
238+  B991 CD 2D A7         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
239+  B994 DD 7E 00         ld a,(ix)           ; get the wobble count back
240+  B997 3D               dec a               ; decrease
241+  B998 DD 77 00         ld (ix),a           ; store
242+  B99B FE 00            cp 0
243+  B99D C0               ret nz              ; if we're not at zero, return
244+  B99E DD 2B            dec ix              ; otherwise look to state location
245+  B9A0 3E 01            ld a,1              ; set the state to falling
246+  B9A2 DD 77 00         ld (ix),a           ; store the falling state
247+  B9A5 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
248+  B9A7 C9               ret
249+  B9A8
# file closed: game/rocks.asm
 40   B9A8                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  B9A8              ;
  2+  B9A8              ; The score of the current player
  3+  B9A8              ;
  4+  B9A8              scores_current:
  5+  B9A8 30 30 30 30      defb '000000'
  5+  B9AC 30 30
  6+  B9AE
  7+  B9AE              ;
  8+  B9AE              ; The current high score table
  9+  B9AE              ;
 10+  B9AE              scores_table:
 11+  B9AE 03 17 47 41      defb 3,23,'GAM',255
 11+  B9B2 4D FF
 12+  B9B4 06 17 30 30      defb 6,23,'00000 ',255
 12+  B9B8 30 30 30 20
 12+  B9BC FF
 13+  B9BD 0C 17 47 41      defb 12,23,'GAM',255
 13+  B9C1 4D FF
 14+  B9C3 0F 17 30 30      defb 15,23,'00000 ',255
 14+  B9C7 30 30 30 20
 14+  B9CB FF
 15+  B9CC 15 17 47 41      defb 21,23,'GAM',255
 15+  B9D0 4D FF
 16+  B9D2 18 17 30 30      defb 24,23,'00000 ',255
 16+  B9D6 30 30 30 20
 16+  B9DA FF
 17+  B9DB
 18+  B9DB              ;
 19+  B9DB              ; Displays the high score table at the bottom of the screen
 20+  B9DB              ;
 21+  B9DB              scores_showtable:
 22+  B9DB 21 AE B9         ld hl, scores_table
 23+  B9DE CD 3F 83         call string_print
 24+  B9E1 21 B4 B9         ld hl, scores_table+6
 25+  B9E4 CD 3F 83         call string_print
 26+  B9E7 21 BD B9         ld hl, scores_table+15
 27+  B9EA CD 3F 83         call string_print
 28+  B9ED 21 C3 B9         ld hl, scores_table+21
 29+  B9F0 CD 3F 83         call string_print
 30+  B9F3 21 CC B9         ld hl, scores_table+30
 31+  B9F6 CD 3F 83         call string_print
 32+  B9F9 21 D2 B9         ld hl, scores_table+36
 33+  B9FC CD 3F 83         call string_print
 34+  B9FF C9               ret
# file closed: game/scores.asm
 41   BA00                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  BA00              diamonds_tmp:
  2+  BA00 00               defb 0
  3+  BA01
  4+  BA01              ;
  5+  BA01              ; Changes the attribute of gem and diamond cells based on the frame count
  6+  BA01              ; Inputs:
  7+  BA01              ; hl - memory location of gem type
  8+  BA01              diamonds_twinkle_type:
  9+  BA01 CD 36 B5         call game_getcurrentframe       ; get current frame number
 10+  BA04 E6 07            and 7                           ; want a number from 0-7
 11+  BA06 C6 40            add 64                          ; add to 60 to get attr colour
 12+  BA08              diamonds_twinkle_type0:
 13+  BA08 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 14+  BA0C 08               ex af, af'
 15+  BA0D 79               ld a,c                          ; load c into a
 16+  BA0E FE FF            cp 255                          ; is this the end?
 17+  BA10 CA 2D BA         jp z,diamonds_twinkle_type1           ; step out if so
 18+  BA13 23               inc hl
 19+  BA14 23               inc hl
 20+  BA15 7E               ld a,(hl)                       ; check the state, don't process if collected
 21+  BA16 FE 01            cp 1
 22+  BA18 CA 2E BA         jp z,diamonds_twinkle_type2           ; step out if so
 23+  BA1B CD 54 BA         call diamonds_checkforplayer    ; check to see if we've collided with player
 24+  BA1E DC 35 BA         call c,diamonds_collect     ; we collided
 25+  BA21 23               inc hl
 26+  BA22 08               ex af,af'
 27+  BA23 5E 23 56 2B      ld de,(hl)                      ; get the memory location into de
 28+  BA27 12               ld (de),a                       ; set the value of attr
 29+  BA28 23               inc hl
 30+  BA29 23               inc hl                          ; move to next diamond
 31+  BA2A C3 08 BA         jp diamonds_twinkle_type0
 32+  BA2D              diamonds_twinkle_type1:
 33+  BA2D C9               ret
 34+  BA2E              diamonds_twinkle_type2:
 35+  BA2E 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 36+  BA2F 23               inc hl
 37+  BA30 23               inc hl
 38+  BA31 08               ex af,af'
 39+  BA32 C3 08 BA         jp diamonds_twinkle_type0       ; rejoin main loop
 40+  BA35
 41+  BA35              ;
 42+  BA35              ; Collect the diamond we collided with
 43+  BA35              ; Inputs:
 44+  BA35              ; hl - memory location of current diamond, currently on state
 45+  BA35              ; Output:
 46+  BA35              ; a - 70 - for yellow on black
 47+  BA35              diamonds_collect:
 48+  BA35 36 01            ld (hl),1                       ; collected
 49+  BA37 E5               push hl
 50+  BA38 2B               dec hl
 51+  BA39 2B               dec hl
 52+  BA3A 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 53+  BA3E CD D7 A6         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 54+  BA41 ED 5B 00 BA      ld de,(diamonds_tmp)
 55+  BA45 16 00            ld d,0
 56+  BA47 21 2E AF         ld hl,sprites
 57+  BA4A 19               add hl,de
 58+  BA4B CD 2D A7         call sprites_drawsprite     ; call the routine to draw the sprite
 59+  BA4E                  ;call screen_showchar
 60+  BA4E E1               pop hl
 61+  BA4F 08               ex af,af'
 62+  BA50 3E 46            ld a,70
 63+  BA52 08               ex af,af'                       ; make sure a is in the af we'll use for the attr
 64+  BA53 C9               ret
 65+  BA54
 66+  BA54              ;
 67+  BA54              ; Checks to see if the gem is hitting a player
 68+  BA54              ; Inputs:
 69+  BA54              ; bc - coords of diamond we're checking
 70+  BA54              diamonds_checkforplayer:
 71+  BA54 78               ld a,b               ; multiply b by 8
 72+  BA55 07               rlca
 73+  BA56 07               rlca
 74+  BA57 07               rlca
 75+  BA58 47               ld b,a
 76+  BA59 ED 5B 40 B5      ld de,(player)       ; get the player coords
 77+  BA5D 7B               ld a,e               ; get the vert coord first
 78+  BA5E 90               sub b                ; subtract the diamond vertical coord from players
 79+  BA5F C6 04            add 4                ; add the max distance
 80+  BA61 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
 81+  BA63 D0               ret nc               ; if not, hasn't hit
 82+  BA64 79               ld a,c               ; multiply c by 8
 83+  BA65 07               rlca
 84+  BA66 07               rlca
 85+  BA67 07               rlca
 86+  BA68 4F               ld c,a
 87+  BA69 7A               ld a,d               ; get the player horiz coord
 88+  BA6A 91               sub c                ; subtract rock coord
 89+  BA6B C6 04            add 4                ; add max distance
 90+  BA6D FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
 91+  BA6F D0               ret nc
 92+  BA70 3E 00            ld a,0
 93+  BA72 C9               ret
 94+  BA73
 95+  BA73
 96+  BA73              ;
 97+  BA73              ; Initialise diamonds and gems
 98+  BA73              ;
 99+  BA73              diamonds_twinkle
100+  BA73 21 00 BA         ld hl,diamonds_tmp
101+  BA76 36 40            ld (hl),64         ; store the location the diamond sprite
102+  BA78 21 A9 AE         ld hl, level01diamonds
103+  BA7B CD 01 BA         call diamonds_twinkle_type
104+  BA7E 21 00 BA         ld hl,diamonds_tmp
105+  BA81 36 70            ld (hl),112         ; store the location the gem sprite
106+  BA83 21 B9 AE         ld hl, level01gems
107+  BA86 CD 01 BA         call diamonds_twinkle_type
108+  BA89 C9               ret
109+  BA8A
110+  BA8A              ;
111+  BA8A              ; Initialise diamonds and gems
112+  BA8A              ;
113+  BA8A              diamonds_init:
114+  BA8A 21 A9 AE         ld hl, level01diamonds
115+  BA8D CD 97 BA         call diamonds_init_type
116+  BA90 21 B9 AE         ld hl, level01gems
117+  BA93 CD 97 BA         call diamonds_init_type
118+  BA96 C9               ret
119+  BA97
120+  BA97              ;
121+  BA97              ; Initialise diamonds or gems, get memory addresses
122+  BA97              ; Inputs:
123+  BA97              ; hl - memory location
124+  BA97              diamonds_init_type:
125+  BA97 4E               ld c,(hl)                      ; get coords into c
126+  BA98 79               ld a,c                          ; load c into add
127+  BA99 FE FF            cp 255                          ; is this the end?
128+  BA9B CA B2 BA         jp z,diamonds_init_type1             ; step out if so
129+  BA9E 23               inc hl
130+  BA9F 46               ld b,(hl)                       ; get coords into b
131+  BAA0 E5               push hl
132+  BAA1 CD 84 A6         call screen_getcellattradress ; get memory of attr for this diamond into de
133+  BAA4 E1               pop hl
134+  BAA5 23               inc hl                          ; move to state
135+  BAA6 36 00            ld (hl),0
136+  BAA8 23               inc hl                          ; move to memory
137+  BAA9 73 23 72 2B      ld (hl),de                      ; store the memory location
138+  BAAD 23               inc hl                          ; move to next diamond
139+  BAAE 23               inc hl
140+  BAAF C3 97 BA         jp diamonds_init_type
141+  BAB2              diamonds_init_type1:
142+  BAB2 C9               ret
# file closed: game/diamonds.asm
 42   BAB3
 43   BAB3              ;===========================================================================
 44   BAB3              ; main routine - the code execution starts here.
 45   BAB3              ; Sets up the new interrupt routine, the memory
 46   BAB3              ; banks and jumps to the start loop.
 47   BAB3              ;===========================================================================
 48   BAB3              main:
 49   BAB3
 50   BAB3                  ; Draw the title screen
 51   BAB3              main_titlescreen:
 52   BAB3 CD 96 A7         call titlescreen_show
 53   BAB6 CD 53 B5         call player_init_gamestart
 54   BAB9
 55   BAB9              main_lifestart:
 56   BAB9
 57   BAB9 CD 5D B5         call player_init_lifestart
 58   BABC
 59   BABC CD FA A8         call lifescreen_draw        ; show the lives remaining screen
 60   BABF
 61   BABF CD 00 80         call init_start
 62   BAC2 CD A7 A5         call screen_draw
 63   BAC5 CD 05 A5         call buffer_allbuffertoscreen
 64   BAC8
 65   BAC8 CD 9B B6         call ship_land              ; land the ship
 66   BACB CD 8B B7         call tank_init
 67   BACE CD 8A BA         call diamonds_init
 68   BAD1
 69   BAD1
 70   BAD1              mloop:
 71   BAD1 76               halt
 72   BAD2 CD ED BA         call main_loop_processing
 73   BAD5
 74   BAD5 21 4A B5         ld hl,player+10
 75   BAD8 7E               ld a,(hl)                   ; check if the player died this frame
 76   BAD9 FE 01            cp 1
 77   BADB C2 D1 BA         jp nz,mloop
 78   BADE CD 9D B5         call player_died        ; do end of life housekeeping
 79   BAE1 21 49 B5         ld hl,player+9        ; check lives remaining
 80   BAE4 7E               ld a,(hl)
 81   BAE5 FE 00            cp 0
 82   BAE7 CA 09 BB         jp z,main_gameover   ; leave the loop if we're done
 83   BAEA C3 B9 BA         jp main_lifestart
 84   BAED
 85   BAED              main_loop_processing:
 86   BAED CD D3 A4         call buffer_buffertoscreen  ; copy buffer to screen
 87   BAF0 CD 53 A4         call buffer_clearlist       ; zero the updated lines list
 88   BAF3 CD C1 B5         call player_drawplayer      ; delete player
 89   BAF6 CD BD B0         call control_keyboard       ; check keyboard
 90   BAF9 CD C1 B5         call player_drawplayer      ; draw player
 91   BAFC CD 9E B7         call tank_process           ; prcoess the tank
 92   BAFF CD 7D B8         call rocks_processrocks     ; process falling rocks
 93   BB02 CD 73 BA         call diamonds_twinkle       ; make the diamonds twinkle
 94   BB05
 95   BB05 CD 27 B5         call game_incrementframe    ; increment the game frame
 96   BB08
 97   BB08 C9               ret
 98   BB09
 99   BB09              main_gameover:
100   BB09 CD 4D A9         call gameover_draw          ; show the game over screen
101   BB0C C3 B3 BA         jp main_titlescreen         ; go back to title
102   BB0F
103   BB0F              ;===========================================================================
104   BB0F              ; Stack.
105   BB0F              ;===========================================================================
106   BB0F
107   BB0F              ; Stack: this area is reserved for the stack
108   BB0F              STACK_SIZE: equ 100    ; in words
109   BB0F
110   BB0F              ; Reserve stack space
111   BB0F 00 00            defw 0  ; WPMEM, 2
112   BB11              stack_bottom:
113   BB11 00 00 00...      defs    STACK_SIZE*2, 0
114   BBD9              stack_top:
115   BBD9 00 00            defw 0  ; WPMEM, 2
116   BBDB
117   BBDB                     SAVESNA "ThePit.sna", main
# file closed: main.asm
