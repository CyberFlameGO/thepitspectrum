# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 80 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 08 A8         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 09 A8         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 3E A6         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD 89 BD         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 20 0A            jr nz,utilities_waitforkey1           ; yes, so no key pressed.
 52+  8051 01 1F 00         ld bc,31                        ; Kempston joystick port.
 53+  8054 ED 78            in a,(c)                        ; read input.
 54+  8056 E6 10            and 16
 55+  8058 CA 4C 80         jp z,utilities_waitforkey0
 56+  805B              utilities_waitforkey1:
 57+  805B C9               ret                 ; key was pressed.
 58+  805C
 59+  805C              ;
 60+  805C              ; Waits number of frames for keypress. If got, returns 1, if not 0
 61+  805C              ; Inputs:
 62+  805C              ; a - number of frames to waits
 63+  805C              ; Ouputs:
 64+  805C              ; e - 0 not pressed, 1 pressed
 65+  805C              utilities_waitforkey_forframes:
 66+  805C 21 08 5C         ld hl,23560         ; LAST K system variable.
 67+  805F 36 00            ld (hl),0           ; put null value there.
 68+  8061 47               ld b,a              ; number of frames to wait
 69+  8062              utilities_waitforkey_forframes0:
 70+  8062 7E               ld a,(hl)           ; new value of LAST K.
 71+  8063 FE 00            cp 0                ; is it still zero?
 72+  8065 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 73+  8067 1E 01            ld e,1              ; set the pressed flag
 74+  8069 C9               ret                 ; key was pressed.
 75+  806A              utilities_waitforkey_forframes1:
 76+  806A C5               push bc
 77+  806B 01 1F 00         ld bc,31                        ; Kempston joystick port.
 78+  806E ED 78            in a,(c)                        ; read input.
 79+  8070 C1               pop bc
 80+  8071 E6 10            and 16
 81+  8073 CA 79 80         jp z,utilities_waitforkey_forframes2
 82+  8076 1E 01            ld e,1              ; set the pressed flag
 83+  8078 C9               ret                 ; key was pressed.
 84+  8079              utilities_waitforkey_forframes2:
 85+  8079 76               halt                ; wait for frame
 86+  807A 76               halt                ; wait for frame
 87+  807B 10 E5            djnz utilities_waitforkey_forframes0 ; loop again
 88+  807D 1E 00            ld e,0              ; nothing pressed in time
 89+  807F C9               ret
 90+  8080
 91+  8080              ;
 92+  8080              ; Clears the screen
 93+  8080              ; Inputs:
 94+  8080              ; a - attribute colour
 95+  8080              utilities_clearscreen:
 96+  8080 76               halt
 97+  8081 21 00 58         ld hl,22528         ; attr
 98+  8084 11 01 58         ld de,22529         ; attr+1
 99+  8087 01 FF 02         ld bc,767
100+  808A 77               ld (hl),a
101+  808B ED B0            ldir
102+  808D
103+  808D 21 00 40         ld hl, 16384        ;pixels
104+  8090 11 01 40         ld de, 16385        ;pixels + 1
105+  8093 01 FF 17         ld bc, 6143         ;pixels area length - 1
106+  8096 36 00            ld (hl), 0          ;set first byte to '0'
107+  8098 ED B0            ldir                ;copy bytes
108+  809A
109+  809A C9               ret
110+  809B
111+  809B              ;
112+  809B              ; Wait for a number of frames
113+  809B              ; Inputs:
114+  809B              ; b - number of frames
115+  809B              utilities_pauseforframes:
116+  809B 76               halt
117+  809C 10 FD            djnz utilities_pauseforframes
118+  809E C9               ret
119+  809F
120+  809F              utilities_readkey:
121+  809F 21 BF 80         LD HL,utilties_keymap              ; Point HL at the keyboard list
122+  80A2 16 08            LD D,8                                  ; This is the number of ports (rows) to check
123+  80A4 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
124+  80A6              utilities_readkey_0:
125+  80A6 46               LD B,(HL)                               ; Get the keyboard port address from table
126+  80A7 23               INC HL                                  ; Increment to list of keys
127+  80A8 ED 78            IN A,(C)                                ; Read the row of keys in
128+  80AA E6 1F            AND $1F                                     ; We are only interested in the first five bits
129+  80AC 1E 05            LD E,5                                  ; This is the number of keys in the row
130+  80AE              utilities_readkey_1:
131+  80AE CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
132+  80B0 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
133+  80B2 23               INC HL                                  ; Go to next table address
134+  80B3 1D               DEC E                                   ; Decrement key loop counter
135+  80B4 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
136+  80B6 15               DEC D                                   ; Decrement row loop counter
137+  80B7 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
138+  80B9 A7               AND A                                   ; Clear A (no key found)
139+  80BA C3 9F 80         jp utilities_readkey
140+  80BD              utilities_readkey_2:
141+  80BD 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
142+  80BE C9               RET
143+  80BF
144+  80BF              utilties_keymap:
145+  80BF FE 23 5A 58      defb $FE,"#","Z","X","C","V"
145+  80C3 43 56
146+  80C5 FD 41 53 44      defb $FD,"A","S","D","F","G"
146+  80C9 46 47
147+  80CB FB 51 57 45      defb $FB,"Q","W","E","R","T"
147+  80CF 52 54
148+  80D1 F7 31 32 33      defb $F7,"1","2","3","4","5"
148+  80D5 34 35
149+  80D7 EF 30 39 38      defb $EF,"0","9","8","7","6"
149+  80DB 37 36
150+  80DD DF 50 4F 49      defb $DF,"P","O","I","U","Y"
150+  80E1 55 59
151+  80E3 BF 23 4C 4B      defb $BF,"#","L","K","J","H"
151+  80E7 4A 48
152+  80E9 7F 20 23 4D      defb $7F," ","#","M","N","B"
152+  80ED 4E 42
153+  80EF
154+  80EF
155+  80EF              ;
156+  80EF              ; Generates a randomish number in the range 0 to e
157+  80EF              ; Inputs:
158+  80EF              ; e - upper value
159+  80EF              ; Outputs:
160+  80EF              ; a - random number
161+  80EF              utilities_randomupper
162+  80EF 3A 5D BD         ld a,(game_framenumber)
163+  80F2 6F               ld l,a
164+  80F3 26 00            ld h,0
165+  80F5 16 00            ld d,0
166+  80F7 42 4B            ld bc,de
167+  80F9              utilities_randomupper0:
168+  80F9 B7               or a
169+  80FA ED 42            sbc hl,bc
170+  80FC F2 F9 80         jp p,utilities_randomupper0
171+  80FF 09               add hl,bc
172+  8100 01 00 00         ld bc,0
173+  8103 09               add hl,bc
174+  8104 7D               ld a,l
175+  8105 C9               ret
# file closed: utilities.asm
 22   8106                  include "strings.asm"
# file opened: strings.asm
  1+  8106              string_score1:
  2+  8106 04 00 53 43      defb 4,0,'SCORE1',255
  2+  810A 4F 52 45 31
  2+  810E FF
  3+  810F              string_scorenumbers1:
  4+  810F 04 01 30 30      defb 4,1,'000000',255
  4+  8113 30 30 30 30
  4+  8117 FF
  5+  8118              string_company:
  6+  8118 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  811C 4E 54 55 52
  6+  8120 49 FF
  7+  8122              string_credits:
  8+  8122 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  8126 41 59 45 52
  8+  812A 20 31 FF
  9+  812D              string_score2:
 10+  812D 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8131 4F 52 45 32
 10+  8135 FF
 11+  8136              string_scorenumbers2:
 12+  8136 16 01 30 30      defb 22,1,'000000',255
 12+  813A 30 30 30 30
 12+  813E FF
 13+  813F              string_titlescreen_copyright:
 14+  813F 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 14+  8143 39 38 32 20
 14+  8147 20 43 45 4E
 14+  814B 54 55 52 49
 14+  814F 20 49 4E 43
 14+  8153 FF
 15+  8154
 16+  8154
 17+  8154              string_alttitlescreen_1:
 18+  8154 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  8158 45 44 49 54
 18+  815C 53 20 31 FF
 19+  8160              string_alttitlescreen_2:
 20+  8160 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  8164 20 20 20 20
 20+  8168 20 20 20 20
 20+  816C 20 54 48 45
 20+  8170 20 4F 42 4A
 20+  8174 45 43 54 FE
 21+  8178 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  817C 20 20 20 20
 21+  8180 20 20 20 20
 21+  8184 4F 46 20 54
 21+  8188 48 49 53 20
 21+  818C 47 41 4D 45
 21+  8190 FE
 22+  8191 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  8195 20 20 20 20
 22+  8199 20 20 20 49
 22+  819D 53 20 54 4F
 22+  81A1 20 44 49 47
 22+  81A5 20 44 4F 57
 22+  81A9 4E FE
 23+  81AB 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  81AF 20 20 20 20
 23+  81B3 20 20 54 4F
 23+  81B7 20 54 48 45
 23+  81BB 20 42 4F 54
 23+  81BF 54 4F 4D 20
 23+  81C3 50 49 54 FE
 24+  81C7 00 06 20 20      defb 0,6,'               AND',254
 24+  81CB 20 20 20 20
 24+  81CF 20 20 20 20
 24+  81D3 20 20 20 20
 24+  81D7 20 41 4E 44
 24+  81DB FE
 25+  81DC 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  81E0 20 20 20 20
 25+  81E4 20 20 43 4F
 25+  81E8 4C 4C 45 43
 25+  81EC 54 20 41 54
 25+  81F0 20 4C 45 41
 25+  81F4 53 54 FE
 26+  81F7 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  81FB 20 20 20 20
 26+  81FF 20 20 20 4F
 26+  8203 4E 45 20 4C
 26+  8207 41 52 47 45
 26+  820B 20 4A 45 57
 26+  820F 45 4C FE
 27+  8212 00 09 20 20      defb 0,9,'              THEN',254
 27+  8216 20 20 20 20
 27+  821A 20 20 20 20
 27+  821E 20 20 20 20
 27+  8222 54 48 45 4E
 27+  8226 FE
 28+  8227 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  822B 20 20 20 20
 28+  822F 20 20 20 52
 28+  8233 45 54 55 52
 28+  8237 4E 20 54 4F
 28+  823B 20 53 48 49
 28+  823F 50 FE
 29+  8241 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  8245 20 20 20 20
 29+  8249 20 20 20 54
 29+  824D 48 52 55 20
 29+  8251 55 50 50 45
 29+  8255 52 20 50 49
 29+  8259 54 FF
 30+  825B              string_alttitlescreen_3:
 31+  825B 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  825F 20 20 53 49
 31+  8263 4E 47 4C 45
 31+  8267 20 42 4F 4E
 31+  826B 55 53 20 20
 31+  826F 35 30 30 30
 31+  8273 20 50 4F 49
 31+  8277 4E 54 53 FE
 32+  827B 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  827F 20 20 20 20
 32+  8283 43 4F 4C 4C
 32+  8287 45 43 54 20
 32+  828B 31 20 4C 41
 32+  828F 52 47 45 20
 32+  8293 4A 45 57 45
 32+  8297 4C FE
 33+  8299 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  829D 20 20 20 20
 33+  82A1 20 41 4E 44
 33+  82A5 20 52 45 54
 33+  82A9 55 52 4E 20
 33+  82AD 54 4F 20 53
 33+  82B1 48 49 50 FE
 34+  82B5 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  82B9 20 20 44 4F
 34+  82BD 55 42 4C 45
 34+  82C1 20 42 4F 4E
 34+  82C5 55 53 20 20
 34+  82C9 31 30 30 30
 34+  82CD 30 20 50 4F
 34+  82D1 49 4E 54 53
 34+  82D5 FE
 35+  82D6 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  82DA 20 20 43 4F
 35+  82DE 4C 4C 45 43
 35+  82E2 54 20 41 4C
 35+  82E6 4C 20 33 20
 35+  82EA 4C 41 52 47
 35+  82EE 45 20 4A 45
 35+  82F2 57 45 4C 53
 35+  82F6 FE
 36+  82F7 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  82FB 20 20 20 20
 36+  82FF 20 4F 52 20
 36+  8303 20 20 41 4C
 36+  8307 4C 20 34 20
 36+  830B 53 4D 41 4C
 36+  830F 4C 20 4A 45
 36+  8313 57 45 4C 53
 36+  8317 FE
 37+  8318 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  831C 20 20 54 52
 37+  8320 49 50 4C 45
 37+  8324 20 42 4F 4E
 37+  8328 55 53 20 20
 37+  832C 31 35 30 30
 37+  8330 30 20 50 4F
 37+  8334 49 4E 54 53
 37+  8338 FE
 38+  8339 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  833D 20 20 20 20
 38+  8341 20 43 4F 4C
 38+  8345 4C 45 43 54
 38+  8349 20 41 4C 4C
 38+  834D 20 37 20 4A
 38+  8351 45 57 45 4C
 38+  8355 53 FF
 39+  8357
 40+  8357              string_lifescreen_player:
 41+  8357 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  835B 4C 41 59 45
 41+  835F 52 20 31 20
 41+  8363 FF
 42+  8364              string_lifescreen_lives:
 43+  8364 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  8368 4D 45 4E 20
 43+  836C 4C 45 46 54
 43+  8370 FF
 44+  8371              string_lifescreen_lastman:
 45+  8371 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  8375 53 54 20 4D
 45+  8379 41 4E FF
 46+  837C
 47+  837C              string_gameoverscreen_gameover:
 48+  837C 0B 06 47 41      defb 11,6,'GAME OVER',255
 48+  8380 4D 45 20 4F
 48+  8384 56 45 52 FF
 49+  8388              string_gameoverscreen_copyright:
 50+  8388 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 50+  838C 39 38 32 20
 50+  8390 43 45 4E 54
 50+  8394 55 52 49 20
 50+  8398 49 4E 43 FF
 51+  839C              string_gameoverscreen_bestscores:
 52+  839C 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  83A0 53 54 20 53
 52+  83A4 43 4F 52 45
 52+  83A8 53 20 54 4F
 52+  83AC 44 41 59 FF
 53+  83B0              string_gameover_credits:
 54+  83B0 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  83B4 45 44 49 54
 54+  83B8 53 20 30 FF
 55+  83BC
 56+  83BC              string_highscore_congratulations:
 57+  83BC 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 57+  83C0 4E 47 52 41
 57+  83C4 54 55 4C 41
 57+  83C8 54 49 4F 4E
 57+  83CC 53 FF
 58+  83CE              string_highscore_player1:
 59+  83CE 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 59+  83D2 41 59 45 52
 59+  83D6 20 31 FF
 60+  83D9              string_highscore_player2:
 61+  83D9 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 61+  83DD 41 59 45 52
 61+  83E1 20 32 FF
 62+  83E4              string_highscore_youhaveearned:
 63+  83E4 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 63+  83E8 55 20 48 41
 63+  83EC 56 45 20 45
 63+  83F0 41 52 4E 45
 63+  83F4 44 FF
 64+  83F6              string_highscore_place1:
 65+  83F6 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 65+  83FA 45 20 47 52
 65+  83FE 45 41 54 45
 65+  8402 53 54 20 53
 65+  8406 43 4F 52 45
 65+  840A FF
 66+  840B              string_highscore_place2:
 67+  840B 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 67+  840F 45 20 32 4E
 67+  8413 44 20 42 45
 67+  8417 53 54 20 53
 67+  841B 43 4F 52 45
 67+  841F FF
 68+  8420              string_highscore_place3:
 69+  8420 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 69+  8424 45 20 33 52
 69+  8428 44 20 42 45
 69+  842C 53 54 20 53
 69+  8430 43 4F 52 45
 69+  8434 FF
 70+  8435              string_highscore_pleaseenter
 71+  8435 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 71+  8439 43 4F 52 44
 71+  843D 20 59 4F 55
 71+  8441 52 20 49 4E
 71+  8445 49 54 49 41
 71+  8449 4C 53 20 42
 71+  844D 45 4C 4F 57
 71+  8451 FF
 72+  8452
 73+  8452              string_endlevel_youhaveearned:
 74+  8452 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 74+  8456 55 20 48 41
 74+  845A 56 45 20 45
 74+  845E 41 52 4E 45
 74+  8462 44 FF
 75+  8464              string_endlevel_bonus1:
 76+  8464 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 76+  8468 4E 47 4C 45
 76+  846C 20 42 4F 4E
 76+  8470 55 53 FF
 77+  8473              string_endlevel_bonus2:
 78+  8473 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 78+  8477 55 42 4C 45
 78+  847B 20 42 4F 4E
 78+  847F 55 53 FF
 79+  8482              string_endlevel_bonus3:
 80+  8482 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 80+  8486 49 50 4C 45
 80+  848A 20 42 4F 4E
 80+  848E 55 53 FF
 81+  8491              string_endlevel_points1:
 82+  8491 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 82+  8495 30 30 20 50
 82+  8499 4F 49 4E 54
 82+  849D 53 FF
 83+  849F              string_endlevel_points2:
 84+  849F 09 0F 31 30      defb 9,15,'10000 POINTS',255
 84+  84A3 30 30 30 20
 84+  84A7 50 4F 49 4E
 84+  84AB 54 53 FF
 85+  84AE              string_endlevel_points3:
 86+  84AE 09 0F 31 35      defb 9,15,'15000 POINTS',255
 86+  84B2 30 30 30 20
 86+  84B6 50 4F 49 4E
 86+  84BA 54 53 FF
 87+  84BD              string_endlevel_anothergo:
 88+  84BD 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 88+  84C1 56 45 20 41
 88+  84C5 4E 4F 54 48
 88+  84C9 45 52 20 47
 88+  84CD 4F FF
 89+  84CF
 90+  84CF              string_zonk:
 91+  84CF 00 00 5A 4F      defb 0,0,'ZONK!',255
 91+  84D3 4E 4B 21 FF
 92+  84D7
 93+  84D7
 94+  84D7              string_options_title:
 95+  84D7 0D 03 54 48      defb 13,3,'THE PIT',255
 95+  84DB 45 20 50 49
 95+  84DF 54 FF
 96+  84E1              string_options_1player:
 97+  84E1 0A 06 31 2E      defb 10,6,'1. ONE PLAYER',255
 97+  84E5 20 4F 4E 45
 97+  84E9 20 50 4C 41
 97+  84ED 59 45 52 FF
 98+  84F1              string_options_2player:
 99+  84F1 0A 07 32 2E      defb 10,7,'2. TWO PLAYER',255
 99+  84F5 20 54 57 4F
 99+  84F9 20 50 4C 41
 99+  84FD 59 45 52 FF
100+  8501              string_options_keyboard:
101+  8501 0A 08 33 2E      defb 10,8,'3. KEYBOARD',255
101+  8505 20 4B 45 59
101+  8509 42 4F 41 52
101+  850D 44 FF
102+  850F              string_options_joystick:
103+  850F 0A 09 34 2E      defb 10,9,'4. KEMPSTON',255
103+  8513 20 4B 45 4D
103+  8517 50 53 54 4F
103+  851B 4E FF
104+  851D              string_options_start:
105+  851D 0A 0A 35 2E      defb 10,10,'5. START',255
105+  8521 20 53 54 41
105+  8525 52 54 FF
106+  8528              string_options_vanity:
107+  8528 08 16 53 70      defb 8,22,'Spectrum Conversion',254
107+  852C 65 63 74 72
107+  8530 75 6D 20 43
107+  8534 6F 6E 76 65
107+  8538 72 73 69 6F
107+  853C 6E FE
108+  853E 07 17 62 79      defb 7,23,'by Dave Tansley, 2020',255
108+  8542 20 44 61 76
108+  8546 65 20 54 61
108+  854A 6E 73 6C 65
108+  854E 79 2C 20 32
108+  8552 30 32 30 FF
109+  8556
110+  8556              ;
111+  8556              ; Prints specified string
112+  8556              ; Inputs:
113+  8556              ; de: pointer to string
114+  8556              ; bc: length of string
115+  8556              ;
116+  8556              ; Print String Data
117+  8556              ; First two bytes of string contain X and Y char position, then the string
118+  8556              ; Individual strings are terminated with 0xFE
119+  8556              ; End of data is terminated with 0xFF
120+  8556              ; HL: Address of string
121+  8556              ;
122+  8556 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
123+  8557 23                                   INC HL                          ; Increase HL to the next memory location
124+  8558 56                                   LD D,(HL)                       ; Fetch the Y coordinate
125+  8559 23                                   INC HL                          ; Increase HL to the next memory location
126+  855A CD 6D 85                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
127+  855D 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
128+  855E 23                                   INC HL                          ; Increase HL to the next character
129+  855F FE FE                                CP 0xFE                         ; Compare with 0xFE
130+  8561 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
131+  8563 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
132+  8564 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
133+  8565 CD 7D 85                             CALL Print_Char                 ; Print the character
134+  8568 E1                                   POP HL                          ; Retrieve HL back off the stack
135+  8569 1C                                   INC E                           ; Go to the next screen address
136+  856A 18 F1                                JR string_print_0               ; Loop back to print next character
137+  856C C9                                   RET
138+  856D
139+  856D              ; Get screen address
140+  856D              ; D = Y character position
141+  856D              ; E = X character position
142+  856D              ; Returns address in DE
143+  856D              ;
144+  856D 7A           string_getcharaddress:       LD A,D
145+  856E E6 07                                AND %00000111
146+  8570 1F                                   RRA
147+  8571 1F                                   RRA
148+  8572 1F                                   RRA
149+  8573 1F                                   RRA
150+  8574 B3                                   OR E
151+  8575 5F                                   LD E,A
152+  8576 7A                                   LD A,D
153+  8577 E6 18                                AND %00011000
154+  8579 F6 40                                OR %01000000
155+  857B 57                                   LD D,A
156+  857C C9                                   RET                             ; Returns screen address in DE
157+  857D
158+  857D              ; Print a single character out
159+  857D              ; A:  Character to print
160+  857D              ; DE: Screen address to print character at
161+  857D              ;
162+  857D 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
163+  8580 06 00                                LD B,0                          ; Set BC to A
164+  8582 4F                                   LD C,A
165+  8583 E6 FF                                AND 0xFF                        ; Clear the carry bit
166+  8585 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
167+  8587 CB 10                                RL B
168+  8589 CB 11                                RL C
169+  858B CB 10                                RL B
170+  858D CB 11                                RL C
171+  858F CB 10                                RL B
172+  8591 09                                   ADD HL,BC                       ; Get the character address in HL
173+  8592 0E 08                                LD C,8                          ; Loop counter
174+  8594 D5                                   PUSH DE
175+  8595 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
176+  8596 12                                   LD (DE),A                       ; Stick A onto the screen
177+  8597 14                                   INC D                           ; Goto next line on screen
178+  8598 2C                                   INC L                           ; Goto next byte of character
179+  8599 0D                                   DEC C                           ; Decrease the loop counter
180+  859A 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
181+  859C D1                                   POP DE
182+  859D C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   859E                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  859E              buffer_buffer:
  2+  859E 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A29E
  4+  A29E              buffer_attr_buffer:
  5+  A29E 00 00 00...      defs 928                    ; attrs buffer area
  6+  A63E
  7+  A63E              buffer_tmp:
  8+  A63E 00 00            defb 0,0                    ; temp area
  9+  A640
 10+  A640              ;
 11+  A640              ; This list stores lines to be updated by the buffer.
 12+  A640              ; This is done by half line. Lines are encded with.
 13+  A640              ; 00hlllll
 14+  A640              ; Where h is the half of the screen (0 or 1), lllll is the line number
 15+  A640              buffer_updatedlines:
 16+  A640 FF FF FF...      defs 21,255
 17+  A655
 18+  A655              buffer_updateall:
 19+  A655 00               defb 0
 20+  A656
 21+  A656              ;
 22+  A656              ; Stores a line number in the update list
 23+  A656              ; Inputs:
 24+  A656              ; a - row number
 25+  A656              buffer_marklineforupdate:
 26+  A656 FE 15            cp 21
 27+  A658 D0               ret nc                          ; dont store lines that we shouldn't draw
 28+  A659 5F               ld e,a                          ; store in e
 29+  A65A ED 4B 43 AB      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 30+  A65E 79               ld a,c                          ; get the horiz coord
 31+  A65F FE 0F            cp 15
 32+  A661 CA 78 A6         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 33+  A664 FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 34+  A666 CA 78 A6         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 35+  A669 DA 74 A6         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 36+  A66C 78               ld a,b                          ; get the vertical
 37+  A66D 3E 20            ld a,32                         ; set the 6th bit by adding 32
 38+  A66F 83               add a,e
 39+  A670 5F               ld e,a                          ; store this value
 40+  A671 C3 7F A6         jp buffer_marklineforupdate2
 41+  A674              buffer_marklineforupdate4:
 42+  A674 78               ld a,b
 43+  A675 C3 7F A6         jp buffer_marklineforupdate2    ; just get the vertical
 44+  A678              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 45+  A678 CD 83 A6         call buffer_storelineforupdate  ; call store update for e
 46+  A67B 3E 20            ld a,32
 47+  A67D 83               add a,e
 48+  A67E 5F               ld e,a
 49+  A67F              buffer_marklineforupdate2:
 50+  A67F CD 83 A6         call buffer_storelineforupdate  ; call store update for e
 51+  A682 C9               ret
 52+  A683
 53+  A683
 54+  A683              ;
 55+  A683              ; Stores the calculated line and half if needed
 56+  A683              ; Inputs:
 57+  A683              ; e - half/row
 58+  A683              ;
 59+  A683              buffer_storelineforupdate:
 60+  A683 06 15            ld b,21
 61+  A685 21 40 A6         ld hl,buffer_updatedlines
 62+  A688              buffer_storelineforupdate0:
 63+  A688 7E               ld a,(hl)                       ; get the line stored in updated lines
 64+  A689 BB               cp e                            ; is this the same as the row number passed in?
 65+  A68A C8               ret z                           ; if so, don't need to do anything
 66+  A68B FE FF            cp 255                          ; is this 255, ie the end of the buffer
 67+  A68D C2 92 A6         jp nz,buffer_storelineforupdate1 ; if not, move to next
 68+  A690 73               ld (hl),e
 69+  A691 C9               ret
 70+  A692              buffer_storelineforupdate1:
 71+  A692 23               inc hl
 72+  A693 10 F3            djnz buffer_storelineforupdate0
 73+  A695 C9               ret
 74+  A696
 75+  A696              ;
 76+  A696              ; Zeroes the updated lines list
 77+  A696              ;
 78+  A696              buffer_clearlist:
 79+  A696 06 15            ld b,21
 80+  A698 21 40 A6         ld hl,buffer_updatedlines
 81+  A69B              buffer_clearlist0:
 82+  A69B 36 FF            ld (hl),255
 83+  A69D 23               inc hl
 84+  A69E 10 FB            djnz buffer_clearlist0
 85+  A6A0 C9               ret
 86+  A6A1
 87+  A6A1              ;
 88+  A6A1              ; Which half are we displaying? 0 left 1 right
 89+  A6A1              ;
 90+  A6A1              buffer_bufferhalf:
 91+  A6A1 00               defb 0
 92+  A6A2
 93+  A6A2              ;
 94+  A6A2              ; Copies the buffer to the screen. Use stack.
 95+  A6A2              ; Inputs:
 96+  A6A2              ; hl - half/line number to display - 0 is first half, 0 is first line
 97+  A6A2              ;
 98+  A6A2              buffer_bufferlinetoscreen:
 99+  A6A2 7C               ld a,h
100+  A6A3 32 A1 A6         ld (buffer_bufferhalf),a        ; store the half
101+  A6A6 7D               ld a,l
102+  A6A7 4F               ld c,a                          ; store a
103+  A6A8 ED 5B 08 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
104+  A6AC 83               add a,e                       ; add the row number
105+  A6AD 11 00 01         ld de,256
106+  A6B0 CD 3A 80         call utilities_multiply
107+  A6B3 54 5D            ld de,hl
108+  A6B5 21 9E 85         ld hl,buffer_buffer
109+  A6B8 19               add hl,de                   ; add the offset
110+  A6B9 79               ld a,c                      ; get original row back
111+  A6BA ED 73 2D A7      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
112+  A6BE D9               exx
113+  A6BF 0E 00            ld c,0                      ; zero horizontal
114+  A6C1 47               ld b,a                      ; load the row number into vertical coord
115+  A6C2 04               inc b
116+  A6C3 04               inc b                       ; move forward 2 to allow for scores
117+  A6C4 CD F2 A8         call screen_getcelladdress  ; get the memory into de
118+  A6C7 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
119+  A6CA 19               add hl,de
120+  A6CB 3A A1 A6         ld a,(buffer_bufferhalf)    ; get the half
121+  A6CE FE 01            cp 1
122+  A6D0 CA FD A6         jp z,buffer_bufferlinetoscreen4
123+  A6D3              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
124+  A6D3 D9               exx                         ; hl is now buffer
125+  A6D4 23               inc hl
126+  A6D5 23               inc hl                      ; move hl forward 2 to skip first two blocks
127+  A6D6 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
128+  A6D7 F1               pop af
129+  A6D8 C1               pop bc
130+  A6D9 D1               pop de
131+  A6DA DD E1            pop ix
132+  A6DC D9               exx                         ; hl is now screen
133+  A6DD 08               ex af,af'
134+  A6DE F1               pop af
135+  A6DF C1               pop bc
136+  A6E0 D1               pop de
137+  A6E1 F9               ld sp,hl                    ; sp pointing at screen
138+  A6E2 D5               push de
139+  A6E3 C5               push bc
140+  A6E4 F5               push af
141+  A6E5 08               ex af,af'
142+  A6E6 D9               exx                         ; hl is now buffer
143+  A6E7 DD E5            push ix
144+  A6E9 D5               push de
145+  A6EA C5               push bc
146+  A6EB F5               push af
147+  A6EC 11 1E 00         ld de,30                    ; add thirty to get to next line
148+  A6EF 19               add hl,de
149+  A6F0 F9               ld sp,hl                    ; sp pointing at buffer
150+  A6F1 D9               exx                         ; hl is now screen
151+  A6F2 08               ex af,af'
152+  A6F3 24               inc h
153+  A6F4 7C               ld a,h
154+  A6F5 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
155+  A6F7 C2 D3 A6         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
156+  A6FA              buffer_bufferlinetoscreen1:
157+  A6FA C3 2C A7         jp buffer_bufferlinetoscreen3
158+  A6FD              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
159+  A6FD D9               exx                         ; hl is buffer
160+  A6FE 11 10 00         ld de,16
161+  A701 19               add hl,de                   ; move halfway across
162+  A702 D9               exx                         ; hl is screen
163+  A703 11 0E 00         ld de,14
164+  A706 19               add hl,de
165+  A707              buffer_bufferlinetoscreen2:
166+  A707 D9               exx                         ; hl is now buffer
167+  A708 F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
168+  A709 F1               pop af
169+  A70A C1               pop bc
170+  A70B D1               pop de
171+  A70C DD E1            pop ix
172+  A70E D9               exx                         ; hl is now screen
173+  A70F 08               ex af,af'
174+  A710 F1               pop af
175+  A711 C1               pop bc
176+  A712 D1               pop de
177+  A713 F9               ld sp,hl                    ; sp pointing at screen
178+  A714 D5               push de
179+  A715 C5               push bc
180+  A716 F5               push af
181+  A717 08               ex af,af'
182+  A718 D9               exx                         ; hl is now buffer
183+  A719 DD E5            push ix
184+  A71B D5               push de
185+  A71C C5               push bc
186+  A71D F5               push af
187+  A71E 11 20 00         ld de,32                    ; add thirty two to get to next line
188+  A721 19               add hl,de
189+  A722 F9               ld sp,hl                    ; sp pointing at buffer
190+  A723 D9               exx                         ; hl is now screen
191+  A724 08               ex af,af'
192+  A725 24               inc h
193+  A726 7C               ld a,h
194+  A727 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
195+  A729 C2 07 A7         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
196+  A72C              buffer_bufferlinetoscreen3:
197+  A72C 31 00 00         ld sp,0
198+  A72F D9               exx
199+  A730 C9               ret
200+  A731
201+  A731              ;
202+  A731              ; Copies the buffer to the screen for updated lines. Use stack.
203+  A731              ; Inputs: none
204+  A731              ;
205+  A731              buffer_buffertoscreen:
206+  A731 3A 55 A6         ld a,(buffer_updateall)      ; get the all update flag
207+  A734 FE 00            cp 0
208+  A736 CA 42 A7         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
209+  A739 CD 72 A7         call buffer_allbuffertoscreen ; otherwise, draw whole screen
210+  A73C 21 55 A6         ld hl,buffer_updateall
211+  A73F 36 00            ld (hl),0                    ; reset flag
212+  A741 C9               ret
213+  A742              buffer_buffertoscreen2:
214+  A742 06 15            ld b,21
215+  A744 FD 21 40 A6      ld iy,buffer_updatedlines    ; the location of the updated lines
216+  A748              buffer_buffertoscreen0:
217+  A748 FD 7E 00         ld a,(iy)
218+  A74B FE FF            cp 255
219+  A74D CA 71 A7         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
220+  A750 6F               ld l,a
221+  A751 26 00            ld h,0
222+  A753 E6 20            and 32                      ; and with 32 to see if 6th bit is set
223+  A755 FE 20            cp 32                       ; if so, second half of screen
224+  A757 C2 62 A7         jp nz,buffer_buffertoscreen3
225+  A75A 26 01            ld h,1                      ; store half in h
226+  A75C FD 7E 00         ld a,(iy)
227+  A75F D6 20            sub 32                      ; remove 32
228+  A761 6F               ld l,a                      ; stor in line number
229+  A762              buffer_buffertoscreen3:
230+  A762 C5               push bc
231+  A763 FD E5            push iy
232+  A765 F3               di
233+  A766 CD A2 A6         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
234+  A769 FB               ei
235+  A76A FD E1            pop iy
236+  A76C C1               pop bc
237+  A76D FD 23            inc iy
238+  A76F 10 D7            djnz buffer_buffertoscreen0
239+  A771              buffer_buffertoscreen1:
240+  A771                  ;call buffer_buffertoattrsfast
241+  A771 C9               ret
242+  A772
243+  A772              ;
244+  A772              ; Copies the buffer to the screen. Use stack.
245+  A772              ; Inputs: none
246+  A772              ;
247+  A772              buffer_allbuffertoscreen:
248+  A772 06 15            ld b,21
249+  A774 3E 00            ld a,0
250+  A776              buffer_allbuffertoscreen0:
251+  A776 C5               push bc
252+  A777 F5               push af
253+  A778 F3               di
254+  A779 26 00            ld h,0
255+  A77B 6F               ld l,a
256+  A77C CD A2 A6         call buffer_bufferlinetoscreen
257+  A77F FB               ei
258+  A780 F1               pop af
259+  A781 F5               push af
260+  A782 F3               di
261+  A783 26 01            ld h,1
262+  A785 6F               ld l,a
263+  A786 CD A2 A6         call buffer_bufferlinetoscreen
264+  A789 FB               ei
265+  A78A F1               pop af
266+  A78B C1               pop bc
267+  A78C 3C               inc a
268+  A78D 10 E7            djnz buffer_allbuffertoscreen0
269+  A78F F3               di
270+  A790 CD 95 A7         call buffer_buffertoattrsfast
271+  A793 FB               ei
272+  A794 C9               ret
273+  A795
274+  A795              ;
275+  A795              ; Copies the attrs buffer to screen with the stack
276+  A795              ;
277+  A795              buffer_buffertoattrsfast:
278+  A795 ED 73 04 A8      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
279+  A799 3A 08 A8         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
280+  A79C 11 20 00         ld de,32
281+  A79F CD 3A 80         call utilities_multiply
282+  A7A2 54 5D            ld de,hl
283+  A7A4 21 9E A2         ld hl,buffer_attr_buffer
284+  A7A7 19               add hl,de                       ; add the offset, start of attr buffer now in hl
285+  A7A8 D9               exx
286+  A7A9 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
287+  A7AC FD 21 3E A6      ld iy,buffer_tmp
288+  A7B0 FD 36 00 15      ld (iy),21              ; number of times to loop
289+  A7B4              buffer_buffertoattrsfast0:
290+  A7B4 D9               exx                         ; hl is now buffer
291+  A7B5 23               inc hl
292+  A7B6 23               inc hl                      ; move hl forward 2 to skip first two blocks
293+  A7B7 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
294+  A7B8 F1               pop af
295+  A7B9 C1               pop bc
296+  A7BA D1               pop de
297+  A7BB DD E1            pop ix
298+  A7BD D9               exx                         ; hl is now screen
299+  A7BE 08               ex af,af'
300+  A7BF F1               pop af
301+  A7C0 C1               pop bc
302+  A7C1 D1               pop de
303+  A7C2 F9               ld sp,hl                    ; sp pointing at screen
304+  A7C3 D5               push de
305+  A7C4 C5               push bc
306+  A7C5 F5               push af
307+  A7C6 08               ex af,af'
308+  A7C7 D9               exx                         ; hl is now buffer
309+  A7C8 DD E5            push ix
310+  A7CA D5               push de
311+  A7CB C5               push bc
312+  A7CC F5               push af
313+  A7CD 1E 0E            ld e,14                    ; do another fourteen for right hand side
314+  A7CF 16 00            ld d,0
315+  A7D1 19               add hl,de
316+  A7D2 F9               ld sp,hl                    ; sp pointing at buffer
317+  A7D3 F1               pop af
318+  A7D4 C1               pop bc
319+  A7D5 D1               pop de
320+  A7D6 DD E1            pop ix
321+  A7D8 D9               exx                         ; hl is now screen
322+  A7D9 08               ex af,af'
323+  A7DA 1E 0E            ld e,14
324+  A7DC 16 00            ld d,0
325+  A7DE 19               add hl,de
326+  A7DF F1               pop af
327+  A7E0 C1               pop bc
328+  A7E1 D1               pop de
329+  A7E2 F9               ld sp,hl                    ; sp pointing at screen
330+  A7E3 D5               push de
331+  A7E4 C5               push bc
332+  A7E5 F5               push af
333+  A7E6 08               ex af,af'
334+  A7E7 D9               exx                         ; hl is now buffer
335+  A7E8 DD E5            push ix
336+  A7EA D5               push de
337+  A7EB C5               push bc
338+  A7EC F5               push af
339+  A7ED 1E 10            ld e,16
340+  A7EF 16 00            ld d,0
341+  A7F1 19               add hl,de
342+  A7F2 D9               exx                         ; hl is now screen
343+  A7F3 11 12 00         ld de,18
344+  A7F6 19               add hl,de
345+  A7F7 FD 7E 00         ld a,(iy)
346+  A7FA 3D               dec a
347+  A7FB FE 00            cp 0
348+  A7FD FD 77 00         ld (iy),a
349+  A800 C2 B4 A7         jp nz,buffer_buffertoattrsfast0 ; do another row
350+  A803              buffer_buffertoattrsfast1:
351+  A803 31 00 00         ld sp,0
352+  A806 D9               exx
353+  A807 C9               ret
# file closed: screen/buffer.asm
 24   A808                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A808              screen_offset:
  2+  A808 00               defb 0                      ; offset from top of screen in lines
  3+  A809
  4+  A809              screen_tmp:
  5+  A809 00 00            defb 0,0                      ; temporary memory
  6+  A80B
  7+  A80B              screen_setscorecolours:
  8+  A80B 21 56 B5         ld hl,score_colours
  9+  A80E 11 00 58         ld de,22528                     ; attrs here
 10+  A811 01 40 00         ld bc,64
 11+  A814 ED B0            ldir
 12+  A816 C9               ret
 13+  A817
 14+  A817              screen_sethighscorecolours:
 15+  A817 21 96 B5         ld hl,high_score_colours
 16+  A81A 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A81D 01 20 00         ld bc,32
 18+  A820 ED B0            ldir
 19+  A822 C9               ret
 20+  A823
 21+  A823              ; Draw the screen
 22+  A823              ; Inputs:
 23+  A823              ; none
 24+  A823              ; Notes:
 25+  A823              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A823              screen_draw:
 27+  A823                  ;call clear_screen
 28+  A823 0E 00            ld c,0                      ; horiz
 29+  A825 06 00            ld b,0                      ; vert, 0 at top
 30+  A827 DD 21 18 B0      ld ix,level01               ; point ix at level data
 31+  A82B FD 21 9E A2      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A82F              screen_draw0:
 33+  A82F DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A832 C5               push bc                     ; store bc, contains loop count
 35+  A833 CD E0 A9         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A836 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A837 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A83A DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A83D CD A7 A9         call screen_getblock        ; get the block data into hl
 40+  A840 CD 84 A9         call screen_showchar        ; show this character here
 41+  A843 C1               pop bc                      ; get the loop counter back
 42+  A844 DD 23            inc ix                      ; increment level location
 43+  A846 FD 23            inc iy                      ; increment attr location
 44+  A848 0C               inc c                       ; increment horiz
 45+  A849 79               ld a,c
 46+  A84A FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A84C C2 2F A8         jp nz,screen_draw0          ; if not, loop
 48+  A84F 0E 00            ld c,0                      ; if so, reset horiz
 49+  A851 04               inc b                       ; increment vertical
 50+  A852 78               ld a,b
 51+  A853 FE 1D            cp 29                       ; check if at bottom
 52+  A855 C2 2F A8         jp nz,screen_draw0          ; if not, loop
 53+  A858 21 09 A8         ld hl, screen_tmp
 54+  A85B 36 09            ld (hl),9                   ; load the block number into memory
 55+  A85D DD 21 B8 B3      ld ix,level01rocks          ; rock memory
 56+  A861 CD C2 A8         call screen_initobjects     ; draw rocks
 57+  A864 21 09 A8         ld hl, screen_tmp
 58+  A867 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A869 DD 21 B8 B4      ld ix,level01missiles       ; missile memory
 60+  A86D CD C2 A8         call screen_initobjects     ; draw missiles
 61+  A870 21 09 A8         ld hl, screen_tmp
 62+  A873 36 08            ld (hl),08                  ; load the block number into memory
 63+  A875 DD 21 31 B5      ld ix,level01diamonds       ; diamond memory
 64+  A879 CD C2 A8         call screen_initobjects     ; draw diamonds
 65+  A87C 21 09 A8         ld hl, screen_tmp
 66+  A87F 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A881 DD 21 41 B5      ld ix,level01gems           ; gems memory
 68+  A885 CD C2 A8         call screen_initobjects     ; draw gems
 69+  A888 CD 8F A8         call screen_setuptext       ; draws text on the screen
 70+  A88B CD EA C4         call scores_printscores     ; print the current scores
 71+  A88E C9               ret
 72+  A88F
 73+  A88F              ;
 74+  A88F              ; Sets up text on the screen
 75+  A88F              ;
 76+  A88F              screen_setuptext:
 77+  A88F CD 46 C5         call scores_showtable
 78+  A892 CD 17 A8         call screen_sethighscorecolours
 79+  A895 21 06 81         ld hl, string_score1
 80+  A898 CD 56 85         call string_print
 81+  A89B 21 0F 81         ld hl, string_scorenumbers1
 82+  A89E CD 56 85         call string_print
 83+  A8A1 21 18 81         ld hl, string_company
 84+  A8A4 CD 56 85         call string_print
 85+  A8A7 21 2D 81         ld hl, string_score2
 86+  A8AA CD 56 85         call string_print
 87+  A8AD 21 36 81         ld hl, string_scorenumbers2
 88+  A8B0 CD 56 85         call string_print
 89+  A8B3 21 22 81         ld hl, string_credits
 90+  A8B6 CD 56 85         call string_print
 91+  A8B9 CD 0B A8         call screen_setscorecolours
 92+  A8BC C9               ret
 93+  A8BD
 94+  A8BD              ;
 95+  A8BD              ; Sets a line of colours
 96+  A8BD              ; Inputs:
 97+  A8BD              ; a - colour to set
 98+  A8BD              ; b - number to set
 99+  A8BD              ; de - start memory location
100+  A8BD              ;
101+  A8BD              screen_setcolours:
102+  A8BD 12               ld (de),a
103+  A8BE 13               inc de
104+  A8BF 10 FC            djnz screen_setcolours
105+  A8C1 C9               ret
106+  A8C2
107+  A8C2              ;
108+  A8C2              ; Draw initial object positions
109+  A8C2              ; Inputs:
110+  A8C2              ; ix - memory location of objects
111+  A8C2              ; a - graphic
112+  A8C2              screen_initobjects:
113+  A8C2 DD 4E 00         ld c,(ix)                   ; get the horiz coord
114+  A8C5 79               ld a,c
115+  A8C6 FE FF            cp 255
116+  A8C8 CA F1 A8         jp z,screen_initobjects2
117+  A8CB DD 23            inc ix                      ; move to next
118+  A8CD DD 46 00         ld b,(ix)                   ; get the vert coord
119+  A8D0 DD 23            inc ix
120+  A8D2 CD 03 A9         call screen_getcellattradress ; get the memory address of b,c attr into de
121+  A8D5 D5               push de
122+  A8D6 3A 09 A8         ld a,(screen_tmp)                  ; get the block number back
123+  A8D9 CD E0 A9         call screen_getattr         ; get the memory location for this cell's attr into hl
124+  A8DC D1               pop de
125+  A8DD 7E               ld a,(hl)                   ; get the attr value at the address
126+  A8DE 12               ld (de),a                   ; load the attr into memory
127+  A8DF 3A 09 A8         ld a,(screen_tmp)                  ; get the block number back
128+  A8E2 CD A7 A9         call screen_getblock        ; get the block data into hl
129+  A8E5 CD 84 A9         call screen_showchar        ; show this character here
130+  A8E8
131+  A8E8              screen_initobjects1:
132+  A8E8 DD 23            inc ix                      ; move past state
133+  A8EA DD 23            inc ix
134+  A8EC DD 23            inc ix                      ; move past mem
135+  A8EE C3 C2 A8         jp screen_initobjects
136+  A8F1              screen_initobjects2:
137+  A8F1 C9               ret
138+  A8F2
139+  A8F2
140+  A8F2              ;
141+  A8F2              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
142+  A8F2              ; Inputs:
143+  A8F2              ; bc: coords
144+  A8F2              ; Outputs:
145+  A8F2              ; de: memory location
146+  A8F2              ;
147+  A8F2              screen_getcelladdress:
148+  A8F2 78               ld a,b      ; vertical position.
149+  A8F3 E6 18            and 24      ; which segment, 0, 1 or 2?
150+  A8F5 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
151+  A8F7 57               ld d,a      ; this is our high byte.
152+  A8F8 78               ld a,b      ; what was that vertical position again?
153+  A8F9 E6 07            and 7       ; which row within segment?
154+  A8FB 0F               rrca        ; multiply row by 32.
155+  A8FC 0F               rrca
156+  A8FD 0F               rrca
157+  A8FE 5F               ld e,a      ; low byte.
158+  A8FF 79               ld a,c      ; add on y coordinate.
159+  A900 83               add a,e     ; mix with low byte.
160+  A901 5F               ld e,a      ; address of screen position in de.
161+  A902 C9               ret
162+  A903
163+  A903              ;
164+  A903              ; Calculate buffer address of attribute for character at (b, c).
165+  A903              ; Inputs:
166+  A903              ; bc: coords
167+  A903              ; Outputs:
168+  A903              ; de: memory location
169+  A903              ;
170+  A903              screen_getcellattradress:
171+  A903 11 9E A2         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
172+  A906 69               ld l,c      ; x position.
173+  A907 26 00            ld h,0      ; 0 h
174+  A909 19               add hl,de
175+  A90A 54 5D            ld de,hl    ; horiz done
176+  A90C 78               ld a,b      ; do vert
177+  A90D D5               push de
178+  A90E C5               push bc
179+  A90F 11 20 00         ld de,32
180+  A912 CD 3A 80         call utilities_multiply
181+  A915 C1               pop bc
182+  A916 D1               pop de
183+  A917 19               add hl,de
184+  A918 54 5D            ld de,hl    ; vert done
185+  A91A C9               ret
186+  A91B
187+  A91B              ;
188+  A91B              ; Calculate buffer address offset of attribute for character at (b, c).
189+  A91B              ; Inputs:
190+  A91B              ; bc: coords
191+  A91B              ; Outputs:
192+  A91B              ; de: memory location
193+  A91B              ;
194+  A91B              screen_getcellattroffset:
195+  A91B 69               ld l,c      ; x position.
196+  A91C 26 00            ld h,0      ; 0 h
197+  A91E 54 5D            ld de,hl    ; horiz done
198+  A920 78               ld a,b      ; do vert
199+  A921 D5               push de
200+  A922 C5               push bc
201+  A923 11 20 00         ld de,32
202+  A926 CD 3A 80         call utilities_multiply
203+  A929 C1               pop bc
204+  A92A D1               pop de
205+  A92B 19               add hl,de
206+  A92C 54 5D            ld de,hl    ; vert done
207+  A92E C9               ret
208+  A92F
209+  A92F              ;
210+  A92F              ; Calculate buffer address of attribute for character at (b, c).
211+  A92F              ; Inputs:
212+  A92F              ; bc: coords
213+  A92F              ; Outputs:
214+  A92F              ; de: memory location
215+  A92F              ;
216+  A92F              screen_getscreenattradress:
217+  A92F 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
218+  A932 69               ld l,c      ; x position.
219+  A933 26 00            ld h,0      ; 0 h
220+  A935 19               add hl,de
221+  A936 54 5D            ld de,hl    ; horiz done
222+  A938 78               ld a,b      ; do vert
223+  A939 D5               push de
224+  A93A C5               push bc
225+  A93B 11 20 00         ld de,32
226+  A93E CD 3A 80         call utilities_multiply
227+  A941 C1               pop bc
228+  A942 D1               pop de
229+  A943 19               add hl,de
230+  A944 54 5D            ld de,hl    ; vert done
231+  A946 C9               ret
232+  A947
233+  A947              ;
234+  A947              ; Gets the attr memory location for a screen coord
235+  A947              ; Will overwrite bc
236+  A947              ; Inputs:
237+  A947              ; bc - screen coords
238+  A947              ; Outputs:
239+  A947              ; de - memory location
240+  A947              ; bc - character coords
241+  A947              ;
242+  A947              screen_getattraddressfromscreencoords:
243+  A947 78               ld a,b                          ; get the player block coords of current block
244+  A948 E6 F8            and 248                         ; find closest multiple of eight
245+  A94A 0F               rrca
246+  A94B 0F               rrca
247+  A94C 0F               rrca                ; divide by 8
248+  A94D 47               ld b,a
249+  A94E 79               ld a,c
250+  A94F 48               ld c,b                         ; swap b and c
251+  A950 E6 F8            and 248
252+  A952 0F               rrca
253+  A953 0F               rrca
254+  A954 0F               rrca                ; divide by 8
255+  A955 47               ld b,a
256+  A956 CD 03 A9         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
257+  A959 C9               ret
258+  A95A
259+  A95A
260+  A95A              ; Gets the nearest cell coords for a screen coord
261+  A95A              ; Will overwrite bc
262+  A95A              ; Inputs:
263+  A95A              ; bc - screen coords
264+  A95A              ; Outputs:
265+  A95A              ; bc - character coords
266+  A95A              ;
267+  A95A              screen_getcharcoordsfromscreencoords:
268+  A95A 78               ld a,b                          ; get the player block coords of current block
269+  A95B E6 F8            and 248                         ; find closest multiple of eight
270+  A95D 0F               rrca
271+  A95E 0F               rrca
272+  A95F 0F               rrca                ; divide by 8
273+  A960 47               ld b,a
274+  A961 79               ld a,c
275+  A962 48               ld c,b                         ; swap b and c
276+  A963 E6 F8            and 248
277+  A965 0F               rrca
278+  A966 0F               rrca
279+  A967 0F               rrca                ; divide by 8
280+  A968 47               ld b,a
281+  A969 C9               ret
282+  A96A
283+  A96A              ; Gets the screen coords for a cell coord
284+  A96A              ; Will overwrite bc
285+  A96A              ; Inputs:
286+  A96A              ; bc - char coords
287+  A96A              ; Outputs:
288+  A96A              ; bc - screen coords
289+  A96A              ;
290+  A96A              screen_getscreencoordsfromcharcoords:
291+  A96A 78               ld a,b                          ; get the player block coords of current block
292+  A96B 07               rlca
293+  A96C 07               rlca
294+  A96D 07               rlca                ; multiply by 8
295+  A96E 47               ld b,a
296+  A96F 79               ld a,c
297+  A970 48               ld c,b                         ; swap b and c
298+  A971 07               rlca
299+  A972 07               rlca
300+  A973 07               rlca                ; divide by 8
301+  A974 47               ld b,a
302+  A975 C9               ret
303+  A976
304+  A976              ;
305+  A976              ; Get buffer address for a character at b,c - b vert
306+  A976              ; Buffer memory is stored as sequential block
307+  A976              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
308+  A976              ; Inputs:
309+  A976              ; bc - coords
310+  A976              ; Outputs:
311+  A976              ; de - memory location of first byte
312+  A976              screen_getbufferaddress:
313+  A976 21 9E 85         ld hl, buffer_buffer    ; first get screen buffer start
314+  A979 50               ld d,b                  ; then work out vertical offset
315+  A97A 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
316+  A97C 19               add hl,de               ; add to base
317+  A97D 59               ld e,c                  ; then add horizontal offset (c)
318+  A97E 16 00            ld d,0
319+  A980 19               add hl,de               ; add to base
320+  A981 54 5D            ld de,hl
321+  A983 C9               ret
322+  A984
323+  A984              ;
324+  A984              ; Display character hl at (b, c) to buffer.
325+  A984              ; Stored sequentially
326+  A984              ; Inputs:
327+  A984              ; hl: block address
328+  A984              ; bc: coords
329+  A984              ;
330+  A984              screen_showchar:
331+  A984 ED 43 43 AB      ld (origcoords),bc   ; store char coords
332+  A988 3E 00            ld a,0
333+  A98A E5               push hl
334+  A98B CD 76 A9         call screen_getbufferaddress ; get the current screen buffer pointer
335+  A98E E1               pop hl
336+  A98F 06 08            ld b,8              ; number of pixels high.
337+  A991              screen_showchar0:
338+  A991 7E               ld a,(hl)           ; source graphic.
339+  A992 12               ld (de),a           ; transfer to screen.
340+  A993 23               inc hl              ; next piece of data.
341+  A994 E5               push hl             ; store hl
342+  A995 62 6B            ld hl,de            ; put de in hl
343+  A997 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
344+  A999 16 00            ld d,0
345+  A99B 19               add hl,de              ; add de to hl
346+  A99C 54 5D            ld de,hl            ; load back to de
347+  A99E E1               pop hl              ; restore hl
348+  A99F
349+  A99F 10 F0            djnz screen_showchar0 ; repeat
350+  A9A1 2E 01            ld l,1
351+  A9A3 CD F4 AA         call sprites_marklinesforupdatechar
352+  A9A6
353+  A9A6 C9               ret
354+  A9A7
355+  A9A7
356+  A9A7              ;
357+  A9A7              ; Get cell graphic.
358+  A9A7              ; Inputs:
359+  A9A7              ; a: block
360+  A9A7              ; Outputs:
361+  A9A7              ; hl: memory
362+  A9A7              ;
363+  A9A7              screen_getblock:
364+  A9A7 07               rlca                        ; multiply block number by eight.
365+  A9A8 07               rlca
366+  A9A9 07               rlca
367+  A9AA 5F               ld e,a                      ; displacement to graphic address.
368+  A9AB 16 00            ld d,0                      ; no high byte.
369+  A9AD 21 B6 B5         ld hl,sprites               ; address of character blocks.
370+  A9B0 19               add hl,de                   ; point to block.
371+  A9B1 C9               ret
372+  A9B2
373+  A9B2              ;
374+  A9B2              ; Set a the attr of a coord
375+  A9B2              ; Inputs:
376+  A9B2              ; bc - char coords
377+  A9B2              ; a - attr
378+  A9B2              ;
379+  A9B2              screen_setattr:
380+  A9B2 DD E5            push ix
381+  A9B4 C5               push bc
382+  A9B5 08               ex af, af'
383+  A9B6 CD 1B A9         call screen_getcellattroffset   ; get offset into de
384+  A9B9 21 9E A2         ld hl,buffer_attr_buffer
385+  A9BC 19               add hl,de                       ; get the memory location
386+  A9BD 08               ex af, af'                      ; get attr back
387+  A9BE 77               ld (hl),a                         ; set the attr
388+  A9BF 08               ex af, af'                      ; get attr back
389+  A9C0 ED 5B 08 A8      ld de,(screen_offset)           ; get the offset
390+  A9C4 78               ld a,b                          ; get the vertical
391+  A9C5 93               sub e                           ; subtract the offset
392+  A9C6 DA DC A9         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
393+  A9C9 FE 15            cp 21
394+  A9CB D2 DC A9         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
395+  A9CE 47               ld b,a                          ; put the coord back in b
396+  A9CF CD 2F A9         call screen_getscreenattradress ; screen attr address in de
397+  A9D2 21 40 00         ld hl,64                        ; attr memory + two rows for scores
398+  A9D5 19               add hl,de
399+  A9D6 08               ex af, af'                      ; get attr back
400+  A9D7 77               ld (hl),a
401+  A9D8 C1               pop bc
402+  A9D9 DD E1            pop ix
403+  A9DB C9               ret
404+  A9DC              screen_setattr0:
405+  A9DC C1               pop bc
406+  A9DD DD E1            pop ix
407+  A9DF C9               ret
408+  A9E0
409+  A9E0              ;
410+  A9E0              ; Get cell attribute.
411+  A9E0              ; Inputs:
412+  A9E0              ; a: block
413+  A9E0              ; Outputs:
414+  A9E0              ; hl: memory
415+  A9E0              ;
416+  A9E0              screen_getattr:
417+  A9E0 5F               ld e,a                      ; displacement to attribute address.
418+  A9E1 16 00            ld d,0                      ; no high byte.
419+  A9E3 21 96 B6         ld hl,sprite_attrs          ; address of block attributes.
420+  A9E6 19               add hl,de                   ; point to attribute.
421+  A9E7 C9               ret
422+  A9E8
423+  A9E8              ;
424+  A9E8              ; Checks whether a character block has anything in it
425+  A9E8              ; Inputs:
426+  A9E8              ; bc - char coords
427+  A9E8              ; Outputs:
428+  A9E8              ; a - 1, empty
429+  A9E8              screen_ischarempty:
430+  A9E8 CD 76 A9         call screen_getbufferaddress ; get the current screen buffer pointer
431+  A9EB 06 08            ld b,8                      ; check 8 rows
432+  A9ED              screen_ischarempty2:
433+  A9ED 1A               ld a,(de)                   ; check line
434+  A9EE FE 00            cp 0
435+  A9F0 C2 FE A9         jp nz,screen_ischarempty1   ; if not zero, jump out with false
436+  A9F3 21 20 00         ld hl,32
437+  A9F6 19               add hl,de
438+  A9F7 54 5D            ld de,hl                    ; move to next row
439+  A9F9 10 F2            djnz screen_ischarempty2
440+  A9FB              screen_ischarempty0:
441+  A9FB 3E 01            ld a,1
442+  A9FD C9               ret
443+  A9FE              screen_ischarempty1:
444+  A9FE 3E 00            ld a,0
445+  AA00 C9               ret
446+  AA01
447+  AA01              ;
448+  AA01              ; Copies a block from one place to another directly underneath, leaves the original empty
449+  AA01              ; Inputs:
450+  AA01              ; bc - coords of block to copy from
451+  AA01              screen_copyblockdown
452+  AA01 CD 76 A9         call screen_getbufferaddress ; get the current screen buffer pointer for source
453+  AA04 06 08            ld b,8                      ; copy 8 rows
454+  AA06              screen_copyblock0:
455+  AA06 1A               ld a,(de)                    ; get what we're copying
456+  AA07 08               ex af,af'
457+  AA08 3E 00            ld a,0
458+  AA0A 12               ld (de),a                    ; replace with empty
459+  AA0B 08               ex af,af'
460+  AA0C 14               inc d                        ; add 256 to get to the next row
461+  AA0D 12               ld (de),a                    ; copy to the next row
462+  AA0E 15               dec d
463+  AA0F 21 20 00         ld hl,32
464+  AA12 19               add hl,de                       ; return back to source, next row down
465+  AA13 54 5D            ld de,hl
466+  AA15 10 EF            djnz screen_copyblock0
467+  AA17 C9               ret
468+  AA18
469+  AA18              ;
470+  AA18              ; Returns the first byte of a character. Useful for figuring out what's there
471+  AA18              ; Inputs:
472+  AA18              ; bc - coords
473+  AA18              ; Outputs:
474+  AA18              ; a - first byte
475+  AA18              ;
476+  AA18              screen_getcharfirstbyte:
477+  AA18 CD 76 A9         call screen_getbufferaddress ; get the current screen buffer pointer for source
478+  AA1B 1A               ld a,(de)
479+  AA1C C9               ret
480+  AA1D
# file closed: screen/screen.asm
 25   AA1D                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  AA1D              ;
  2+  AA1D              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  AA1D              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  AA1D              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  AA1D              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  AA1D              ; routine takes care of all the shifting itself. This means that sprite
  7+  AA1D              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  AA1D              ; space they would require in pre-shifted form.
  9+  AA1D              ; Inputs:
 10+  AA1D              ; hl - sprite data
 11+  AA1D              ; bc - screen coords
 12+  AA1D              ;
 13+  AA1D              sprites_drawsprite7:
 14+  AA1D EE 07            xor 7               ; complement last 3 bits.
 15+  AA1F 3C               inc a               ; add one for luck!
 16+  AA20              sprites_drawsprite3:
 17+  AA20 CB 11            rl c                ; ...into middle byte...
 18+  AA22 CB 12            rl d                ; ...and finally into left character cell.
 19+  AA24 3D               dec a               ; count shifts we've done.
 20+  AA25 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  AA27                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  AA27 79               ld a,c              ; left edge of image is currently in e.
 23+  AA28 4A               ld c,d              ; put right edge there instead.
 24+  AA29 57               ld d,a              ; and the left edge back into c.
 25+  AA2A 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  AA2C              sprites_drawsprite:
 27+  AA2C ED 43 43 AB      ld (origcoords),bc  ; store coords
 28+  AA30 ED 43 45 AB      ld (dispx),bc       ; store coords in dispx for now.
 29+  AA34 E5               push hl
 30+  AA35 CD 21 AB         call sprites_scadd  ; calculate screen address.
 31+  AA38 E1               pop hl
 32+  AA39 3E 08            ld a,8              ; height of sprite in pixels.
 33+  AA3B              sprites_drawsprite1:
 34+  AA3B 08               ex af,af'           ; store loop counter.
 35+  AA3C D5               push de             ; store screen address.
 36+  AA3D 4E               ld c,(hl)           ; first sprite graphic.
 37+  AA3E 23               inc hl              ; increment poiinter to sprite data.
 38+  AA3F 22 47 AB         ld (sprtmp),hl      ; store it for later.
 39+  AA42 16 00            ld d,0              ; blank right byte for now.
 40+  AA44 78               ld a,b              ; b holds y position.
 41+  AA45 E6 07            and 7               ; how are we straddling character cells?
 42+  AA47 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  AA49 FE 05            cp 5                ; 5 or more right shifts needed?
 44+  AA4B 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  AA4D A7               and a               ; oops, carry flag is set so clear it.
 46+  AA4E              sprites_drawsprite2:
 47+  AA4E CB 19            rr c                ; rotate left byte right...
 48+  AA50 CB 1A            rr d                ; ...into right byte.
 49+  AA52 3D               dec a               ; one less shift to do.
 50+  AA53 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  AA55              sprites_drawsprite0:
 52+  AA55 E1               pop hl              ; pop screen address from stack.
 53+  AA56 7E               ld a,(hl)           ; what's there already.
 54+  AA57 A9               xor c               ; merge in image data.
 55+  AA58 77               ld (hl),a           ; place onto screen.
 56+  AA59 23               inc hl
 57+  AA5A 7E               ld a,(hl)           ; what's already there.
 58+  AA5B AA               xor d               ; right edge of sprite image data.
 59+  AA5C 77               ld (hl),a           ; plonk it on screen.
 60+  AA5D 3A 45 AB         ld a,(dispx)        ; vertical coordinate.
 61+  AA60 3C               inc a               ; next line down.
 62+  AA61 32 45 AB         ld (dispx),a        ; store new position.
 63+  AA64 2B               dec hl
 64+  AA65 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  AA68 19               add hl,de           ; add 32
 66+  AA69              sprites_drawsprite6:
 67+  AA69 EB               ex de,hl            ; screen address in de.
 68+  AA6A 2A 47 AB         ld hl,(sprtmp)      ; restore graphic address.
 69+  AA6D 08               ex af,af'           ; restore loop counter.
 70+  AA6E 3D               dec a               ; decrement it.
 71+  AA6F C2 3B AA         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  AA72 2E 02            ld l,2
 73+  AA74 CD E3 AA         call sprites_marklinesforupdatescreen
 74+  AA77 C9               ret                 ; job done.
 75+  AA78
 76+  AA78              ; Inputs:
 77+  AA78              ; hl - sprite data
 78+  AA78              ; bc - screen coords
 79+  AA78              ;
 80+  AA78              sprites_draw2by2sprite7
 81+  AA78 EE 07            xor 7               ; complement last 3 bits.
 82+  AA7A 3C               inc a               ; add one for luck!
 83+  AA7B              sprites_draw2by2sprite3
 84+  AA7B CB 12            rl d                ; rotate left...
 85+  AA7D CB 11            rl c                ; ...into middle byte...
 86+  AA7F CB 13            rl e                ; ...and finally into left character cell.
 87+  AA81 3D               dec a               ; count shifts we've done.
 88+  AA82 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  AA84                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  AA84 7B               ld a,e              ; left edge of image is currently in e.
 91+  AA85 5A               ld e,d              ; put right edge there instead.
 92+  AA86 51               ld d,c              ; middle bit goes in d.
 93+  AA87 4F               ld c,a              ; and the left edge back into c.
 94+  AA88 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  AA8A              sprites_draw2by2sprite
 96+  AA8A ED 43 43 AB      ld (origcoords),bc  ; store coords
 97+  AA8E ED 43 45 AB      ld (dispx),bc       ; store coords in dispx for now.
 98+  AA92 79               ld a,c
 99+  AA93 32 49 AB         ld (sprtmp0),a         ; store vertical.
100+  AA96 E5               push hl
101+  AA97 CD 21 AB         call sprites_scadd          ; calculate screen address.
102+  AA9A E1               pop hl
103+  AA9B 3E 10            ld a,16             ; height of sprite in pixels.
104+  AA9D              sprites_draw2by2sprite1
105+  AA9D 08               ex af,af'           ; store loop counter.
106+  AA9E D5               push de             ; store screen address.
107+  AA9F 4E               ld c,(hl)           ; first sprite graphic.
108+  AAA0 23               inc hl              ; increment poiinter to sprite data.
109+  AAA1 56               ld d,(hl)           ; next bit of sprite image.
110+  AAA2 23               inc hl              ; point to next row of sprite data.
111+  AAA3 22 47 AB         ld (sprtmp),hl        ; store in tmp0 for later.
112+  AAA6 1E 00            ld e,0              ; blank right byte for now.
113+  AAA8 78               ld a,b              ; b holds y position.
114+  AAA9 E6 07            and 7               ; how are we straddling character cells?
115+  AAAB 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  AAAD FE 05            cp 5                ; 5 or more right shifts needed?
117+  AAAF 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  AAB1 A7               and a               ; oops, carry flag is set so clear it.
119+  AAB2              sprites_draw2by2sprite2
120+  AAB2 CB 19            rr c                ; rotate left byte right...
121+  AAB4 CB 1A            rr d                ; ...through middle byte...
122+  AAB6 CB 1B            rr e                ; ...into right byte.
123+  AAB8 3D               dec a               ; one less shift to do.
124+  AAB9 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  AABB              sprites_draw2by2sprite0
126+  AABB E1               pop hl              ; pop screen address from stack.
127+  AABC 7E               ld a,(hl)           ; what's there already.
128+  AABD A9               xor c               ; merge in image data.
129+  AABE 77               ld (hl),a           ; place onto screen.
130+  AABF 23               inc hl               ; next character cell to right please.
131+  AAC0 7E               ld a,(hl)           ; what's there already.
132+  AAC1 AA               xor d               ; merge with middle bit of image.
133+  AAC2 77               ld (hl),a           ; put back onto screen.
134+  AAC3 23               inc hl              ; next bit of screen area.
135+  AAC4 7E               ld a,(hl)           ; what's already there.
136+  AAC5 AB               xor e               ; right edge of sprite image data.
137+  AAC6 77               ld (hl),a           ; plonk it on screen.
138+  AAC7 3A 49 AB         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  AACA 3C               inc a               ; next line down.
140+  AACB 32 49 AB         ld (sprtmp0),a         ; store new position.
141+  AACE 2B               dec hl
142+  AACF 2B               dec hl
143+  AAD0 11 20 00         ld de,32            ; add 32 to get to the next row
144+  AAD3 19               add hl,de           ; add 32
145+  AAD4              sprites_draw2by2sprite6
146+  AAD4 EB               ex de,hl            ; screen address in de.
147+  AAD5 2A 47 AB         ld hl,(sprtmp)        ; restore graphic address.
148+  AAD8 08               ex af,af'           ; restore loop counter.
149+  AAD9 3D               dec a               ; decrement it.
150+  AADA C2 9D AA         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  AADD 2E 03            ld l,3
152+  AADF CD E3 AA         call sprites_marklinesforupdatescreen
153+  AAE2 C9               ret                 ; job done.
154+  AAE3
155+  AAE3              ;
156+  AAE3              ; Marks lines for update with screen coords
157+  AAE3              ; Inputs:
158+  AAE3              ; l - number to update
159+  AAE3              ;
160+  AAE3              sprites_marklinesforupdatescreen:
161+  AAE3 F5               push af
162+  AAE4 ED 4B 43 AB      ld bc,(origcoords)
163+  AAE8 CD 5A A9         call screen_getcharcoordsfromscreencoords
164+  AAEB ED 43 43 AB      ld (origcoords),bc
165+  AAEF CD FE AA         call sprites_marklinesforupdate
166+  AAF2 F1               pop af
167+  AAF3 C9               ret
168+  AAF4
169+  AAF4              ;
170+  AAF4              ; Marks lines for update with char coords
171+  AAF4              ; Inputs:
172+  AAF4              ; l - number to update
173+  AAF4              ;
174+  AAF4              sprites_marklinesforupdatechar:
175+  AAF4 F5               push af
176+  AAF5 ED 43 43 AB      ld (origcoords),bc
177+  AAF9 CD FE AA         call sprites_marklinesforupdate
178+  AAFC F1               pop af
179+  AAFD C9               ret
180+  AAFE
181+  AAFE              ;
182+  AAFE              ; Marks lines for update
183+  AAFE              ; Inputs:
184+  AAFE              ; l - number to update
185+  AAFE              ;
186+  AAFE              sprites_marklinesforupdate:
187+  AAFE ED 4B 43 AB      ld bc,(origcoords)
188+  AB02 ED 5B 08 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
189+  AB06 78               ld a,b
190+  AB07 93               sub e
191+  AB08 47               ld b,a
192+  AB09 7D               ld a,l                          ; get loop counter
193+  AB0A              sprites_marklinesforupdate0:
194+  AB0A C5               push bc
195+  AB0B 08               ex af,af'                     ; store loop counter
196+  AB0C 78               ld a,b
197+  AB0D CD 56 A6         call buffer_marklineforupdate ; mark this line for update
198+  AB10 ED 4B 43 AB      ld bc,(origcoords)            ; move the coords for the next line
199+  AB14 04               inc b
200+  AB15 ED 43 43 AB      ld (origcoords),bc
201+  AB19 C1               pop bc
202+  AB1A 04               inc b
203+  AB1B 08               ex af,af'                     ; restore loop counter
204+  AB1C 3D               dec a
205+  AB1D C2 0A AB         jp nz,sprites_marklinesforupdate0
206+  AB20 C9               ret
207+  AB21
208+  AB21              ;
209+  AB21              ; This routine returns a buffer address for (c, b) in de (c vert).
210+  AB21              ; For example: 0,0 will be at memory offset 0
211+  AB21              ; 1,0 (1 down) will be at memory offset 1
212+  AB21              ; 0,7 will be at memory offset 0
213+  AB21              ; 9,1 will be at memory offset 8+1
214+  AB21              ; 8,0 will be at memory offset 256
215+  AB21              ; 9,0 will be at memory offset 257
216+  AB21              ; Outputs:
217+  AB21              ; de - coords
218+  AB21              ;
219+  AB21              sprites_scadd:
220+  AB21 79               ld a,c               ; calculate vertical offset
221+  AB22 E6 F8            and 248             ;  to get nearest multiple of 8
222+  AB24 0F               rrca
223+  AB25 0F               rrca
224+  AB26 0F               rrca                ; divide by 8
225+  AB27 67               ld h,a
226+  AB28 78               ld a,b               ; calculate horizontal offset
227+  AB29 E6 F8            and 248             ;  to get nearest multiple of 8
228+  AB2B 0F               rrca
229+  AB2C 0F               rrca
230+  AB2D 0F               rrca                ; divide by 8
231+  AB2E 6F               ld l,a
232+  AB2F C5               push bc             ; store the screen coords
233+  AB30 44 4D            ld bc,hl            ; load bc with the character coords
234+  AB32 CD 76 A9         call screen_getbufferaddress
235+  AB35 C1               pop bc              ; get back screen coords, de is now memory of character
236+  AB36 79               ld a,c              ; now add the vertical within the cell
237+  AB37 E6 07            and 7
238+  AB39 0F               rrca                ; multiply by 32.
239+  AB3A 0F               rrca
240+  AB3B 0F               rrca
241+  AB3C 6F               ld l,a
242+  AB3D 26 00            ld h,0
243+  AB3F 19               add hl,de
244+  AB40 54 5D            ld de,hl
245+  AB42 C9               ret
246+  AB43
247+  AB43 00 00        origcoords   defb 0,0           ; general-use coordinates.
248+  AB45
249+  AB45 00           dispx   defb 0           ; general-use coordinates.
250+  AB46 00           dispy   defb 0
251+  AB47 00 00        sprtmp  defb 0,0           ; sprite temporary address.
252+  AB49 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
253+  AB4B
# file closed: screen/sprites.asm
 26   AB4B                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AB4B              ;
  2+  AB4B              ; Draws the title screen
  3+  AB4B              ;
  4+  AB4B              titlescreen_show:
  5+  AB4B CD DD AB         call titlescreen_init
  6+  AB4E CD 86 AB         call titlescreen_drawtitle
  7+  AB51 3A 62 BD         ld a,(game_control)
  8+  AB54 FE 00            cp 0
  9+  AB56 CA 5E AB         jp z,titlescreen_show1
 10+  AB59 06 32            ld b,50
 11+  AB5B CD 9B 80         call utilities_pauseforframes         ; pause for a second
 12+  AB5E              titlescreen_show1:
 13+  AB5E 3E FA            ld a,250                              ; wait for 200 frames
 14+  AB60 CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 15+  AB63 7B               ld a,e
 16+  AB64 FE 01            cp 1                                  ; was anything pressed?
 17+  AB66 C8               ret z                                 ; end titlescreen if so
 18+  AB67
 19+  AB67 CD F0 AB         call titlescreen_alt_init             ; otherwise, draw alt screen
 20+  AB6A CD A2 AB         call titlescreen_alt_drawtitle
 21+  AB6D 3A 62 BD         ld a,(game_control)
 22+  AB70 FE 00            cp 0
 23+  AB72 CA 7A AB         jp z,titlescreen_show0
 24+  AB75 06 32            ld b,50
 25+  AB77 CD 9B 80         call utilities_pauseforframes         ; pause for a second if joystick
 26+  AB7A              titlescreen_show0:
 27+  AB7A 3E FA            ld a,250                              ; wait for 200 frames
 28+  AB7C CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 29+  AB7F 7B               ld a,e
 30+  AB80 FE 01            cp 1                                  ; was anything pressed?
 31+  AB82 C2 4B AB         jp nz,titlescreen_show                ; start again if not
 32+  AB85 C9               ret
 33+  AB86
 34+  AB86              ;
 35+  AB86              ; Draws the iconic logo
 36+  AB86              ;
 37+  AB86              titlescreen_drawtitle:
 38+  AB86 06 67            ld b,103              ; number of points
 39+  AB88 DD 21 FD AB      ld ix,titlescreen_logo_data
 40+  AB8C              titlescreen_drawtitle0:
 41+  AB8C C5               push bc
 42+  AB8D DD 4E 00         ld c,(ix)                   ; got horiz
 43+  AB90 DD 23            inc ix
 44+  AB92 DD 46 00         ld b,(ix)                   ; got vert
 45+  AB95 DD 23            inc ix
 46+  AB97 CD 2F A9         call screen_getscreenattradress ; memory in de
 47+  AB9A 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 48+  AB9B 3E 13            ld a,19
 49+  AB9D 12               ld (de),a
 50+  AB9E C1               pop bc
 51+  AB9F 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 52+  ABA1 C9               ret
 53+  ABA2
 54+  ABA2              ;
 55+  ABA2              ; Draws the alternate title screen
 56+  ABA2              ;
 57+  ABA2              titlescreen_alt_drawtitle:
 58+  ABA2 21 54 81         ld hl,string_alttitlescreen_1
 59+  ABA5 CD 56 85         call string_print
 60+  ABA8 21 60 81         ld hl,string_alttitlescreen_2
 61+  ABAB CD 56 85         call string_print
 62+  ABAE 21 5B 82         ld hl,string_alttitlescreen_3
 63+  ABB1 CD 56 85         call string_print
 64+  ABB4 06 20            ld b,32
 65+  ABB6 3E 43            ld a,67
 66+  ABB8 11 00 58         ld de,22528                         ; top row attrs here
 67+  ABBB CD BD A8         call screen_setcolours
 68+  ABBE 06 20            ld b,32
 69+  ABC0 3E 46            ld a,70
 70+  ABC2 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 71+  ABC5 CD BD A8         call screen_setcolours
 72+  ABC8 06 20            ld b,32
 73+  ABCA 3E 43            ld a,67
 74+  ABCC 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 75+  ABCF CD BD A8         call screen_setcolours
 76+  ABD2 06 20            ld b,32
 77+  ABD4 3E 42            ld a,66
 78+  ABD6 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 79+  ABD9 CD BD A8         call screen_setcolours
 80+  ABDC C9               ret
 81+  ABDD
 82+  ABDD              ;
 83+  ABDD              ; Initialises the screen
 84+  ABDD              ;
 85+  ABDD              titlescreen_init:
 86+  ABDD              ; We want a black screen.
 87+  ABDD 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 88+  ABDF                                      ; bright (64).
 89+  ABDF CD 80 80         call utilities_clearscreen
 90+  ABE2 32 8D 5C         ld (23693),a        ; set our screen colours.
 91+  ABE5 3E 01            ld a,1              ; 2 is the code for red.
 92+  ABE7 D3 FE            out (254),a         ; write to port 254.
 93+  ABE9
 94+  ABE9 21 3F 81         ld hl,string_titlescreen_copyright
 95+  ABEC CD 56 85         call string_print
 96+  ABEF
 97+  ABEF C9               ret
 98+  ABF0
 99+  ABF0              ;
100+  ABF0              ; Initialises the screen
101+  ABF0              ;
102+  ABF0              titlescreen_alt_init:
103+  ABF0              ; We want a black screen.
104+  ABF0 3E 47            ld a,71             ; white ink (7) on black paper (0),
105+  ABF2                                      ; bright (64).
106+  ABF2 CD 80 80         call utilities_clearscreen
107+  ABF5 32 8D 5C         ld (23693),a        ; set our screen colours.
108+  ABF8 3E 00            ld a,0              ; 2 is the code for red.
109+  ABFA D3 FE            out (254),a         ; write to port 254.
110+  ABFC
111+  ABFC C9               ret
112+  ABFD
113+  ABFD              ;
114+  ABFD              ; Horiz, vert
115+  ABFD              ;
116+  ABFD              titlescreen_logo_data:
117+  ABFD 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
117+  AC01 0A 00 0C 00
117+  AC05 0F 00 11 00
117+  AC09 12 00 13 00
118+  AC0D 09 01 0C 01      defb 9,1,12,1,15,1,17,1
118+  AC11 0F 01 11 01
119+  AC15 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
119+  AC19 0D 02 0E 02
119+  AC1D 0F 02 11 02
119+  AC21 12 02 13 02
120+  AC25 09 03 0C 03      defb 9,3,12,3,15,3,17,3
120+  AC29 0F 03 11 03
121+  AC2D 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
121+  AC31 0F 04 11 04
121+  AC35 12 04 13 04
122+  AC39 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
122+  AC3D 02 06 03 06
122+  AC41 04 06 05 06
122+  AC45 06 06 07 06
122+  AC49 08 06 09 06
122+  AC4D 0A 06 0B 06
123+  AC51 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
123+  AC55 12 06 13 06
123+  AC59 14 06 15 06
123+  AC5D 16 06 17 06
123+  AC61 18 06 19 06
123+  AC65 1A 06 1B 06
124+  AC69 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
124+  AC6D 02 09 02 0A
124+  AC71 02 0B 02 0C
124+  AC75 02 0D 02 0E
124+  AC79 02 0F 02 10
124+  AC7D 02 11 02 12
124+  AC81 02 13 02 14
124+  AC85 02 15
125+  AC87 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
125+  AC8B 19 09 19 0A
125+  AC8F 19 0B 19 0C
125+  AC93 19 0D 19 0E
125+  AC97 19 0F 19 10
125+  AC9B 19 11 19 12
125+  AC9F 19 13 19 14
125+  ACA3 19 15
126+  ACA5 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
126+  ACA9 05 0B 06 0B
126+  ACAD 07 0B 08 0B
126+  ACB1 09 0B 0A 0B
126+  ACB5 0B 0B
127+  ACB7 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
127+  ACBB 0B 09 0B 0A
128+  ACBF 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
128+  ACC3 10 10 10 11
128+  ACC7 10 12 10 13
129+  ACCB
# file closed: screen/titlescreen.asm
 27   ACCB                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ACCB              ;
  2+  ACCB              ; Draws the life remaining screen
  3+  ACCB              ;
  4+  ACCB              lifescreen_draw:
  5+  ACCB CD 1E AD         call lifescreen_init
  6+  ACCE
  7+  ACCE 3A 5F BD         ld a,(game_currentplayer)             ; get the current player
  8+  ACD1 C6 30            add 48                                ; add 48 to get char
  9+  ACD3 21 61 83         ld hl,string_lifescreen_player+10
 10+  ACD6 77               ld (hl),a                             ; load this to the string we're about to show
 11+  ACD7
 12+  ACD7 21 57 83         ld hl,string_lifescreen_player
 13+  ACDA CD 56 85         call string_print
 14+  ACDD
 15+  ACDD 3A 9F BD         ld a,(player+9)                       ; get the current player lives
 16+  ACE0 C6 30            add 48                                ; add 48 to get the character
 17+  ACE2 FE 31            cp 49
 18+  ACE4 C2 F7 AC         jp nz,lifescreen_draw0
 19+  ACE7 21 71 83         ld hl,string_lifescreen_lastman
 20+  ACEA
 21+  ACEA 06 08            ld b,8
 22+  ACEC 3E 0A            ld a,10                                ; set red
 23+  ACEE 11 6C 58         ld de,22528+108                        ; attrs here
 24+  ACF1 CD BD A8         call screen_setcolours
 25+  ACF4
 26+  ACF4 C3 FE AC         jp lifescreen_draw1
 27+  ACF7              lifescreen_draw0:
 28+  ACF7 21 66 83         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  ACFA 77               ld (hl),a                             ; load this to the string we're about to show
 30+  ACFB 21 64 83         ld hl,string_lifescreen_lives
 31+  ACFE              lifescreen_draw1:
 32+  ACFE CD 56 85         call string_print
 33+  AD01
 34+  AD01 3E 86            ld a,134
 35+  AD03 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AD06 06 0A            ld b,10
 37+  AD08 CD BD A8         call screen_setcolours
 38+  AD0B 3A 62 BD         ld a,(game_control)
 39+  AD0E FE 00            cp 0
 40+  AD10 CA 18 AD         jp z,lifescreen_draw2
 41+  AD13 06 32            ld b,50
 42+  AD15 CD 9B 80         call utilities_pauseforframes         ; pause for a second if joystick
 43+  AD18              lifescreen_draw2:
 44+  AD18 3E 64            ld a,100                              ; wait for 200 frames
 45+  AD1A CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 46+  AD1D
 47+  AD1D C9               ret
 48+  AD1E
 49+  AD1E              ;
 50+  AD1E              ; Initialises the screen
 51+  AD1E              ;
 52+  AD1E              lifescreen_init:
 53+  AD1E              ; We want a blue screen.
 54+  AD1E                  ;call $0D6B
 55+  AD1E 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 56+  AD20                                      ; bright (64).
 57+  AD20 CD 80 80         call utilities_clearscreen
 58+  AD23 32 8D 5C         ld (23693),a        ; set our screen colours.
 59+  AD26 3E 01            ld a,1              ; 1 is the code for blue.
 60+  AD28 D3 FE            out (254),a         ; write to port 254.
 61+  AD2A                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 62+  AD2A
 63+  AD2A C9               ret
# file closed: screen/lifescreen.asm
 28   AD2B                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AD2B              ;
  2+  AD2B              ; Draws the game over screen
  3+  AD2B              ;
  4+  AD2B              gameover_draw:
  5+  AD2B CD 5A C5         call scores_processhighscores
  6+  AD2E
  7+  AD2E              gameover_draw0:
  8+  AD2E CD 6E AD         call gameover_enterhighscores
  9+  AD31
 10+  AD31 CD 0C AE         call gameover_init
 11+  AD34
 12+  AD34 21 7C 83         ld hl,string_gameoverscreen_gameover
 13+  AD37 CD 56 85         call string_print
 14+  AD3A
 15+  AD3A 21 88 83         ld hl,string_gameoverscreen_copyright
 16+  AD3D CD 56 85         call string_print
 17+  AD40
 18+  AD40 CD 51 AD         call gameover_commontext
 19+  AD43
 20+  AD43 06 0B            ld b,11
 21+  AD45 3E 42            ld a,66
 22+  AD47 11 2B 58         ld de,22528+43                         ; attrs here
 23+  AD4A CD BD A8         call screen_setcolours
 24+  AD4D CD 47 80         call utilities_waitforkey   ; wait for keypress
 25+  AD50
 26+  AD50 C9               ret
 27+  AD51
 28+  AD51              ;
 29+  AD51              ; Draws text shared by the game over and high score screens
 30+  AD51              ;
 31+  AD51              gameover_commontext:
 32+  AD51 CD 8F A8         call screen_setuptext       ; show scores
 33+  AD54 CD EA C4         call scores_printscores     ; print the current scores
 34+  AD57
 35+  AD57 21 B0 83         ld hl,string_gameover_credits
 36+  AD5A CD 56 85         call string_print
 37+  AD5D
 38+  AD5D 21 9C 83         ld hl,string_gameoverscreen_bestscores
 39+  AD60 CD 56 85         call string_print
 40+  AD63
 41+  AD63 06 20            ld b,32
 42+  AD65 3E 45            ld a,69
 43+  AD67 11 C0 5A         ld de,22528+704                         ; attrs here
 44+  AD6A CD BD A8         call screen_setcolours
 45+  AD6D
 46+  AD6D C9               ret
 47+  AD6E
 48+  AD6E              ;
 49+  AD6E              ; If required, enter highscore
 50+  AD6E              ;
 51+  AD6E              gameover_enterhighscores:
 52+  AD6E                  ; check if we need to enter initial
 53+  AD6E 3A 59 C5         ld a,(scores_highscoretmp)
 54+  AD71 FE 00            cp 0
 55+  AD73 C8               ret z
 56+  AD74 CD A2 AD         call gameover_enterhighscores_init
 57+  AD77 3A 59 C5         ld a,(scores_highscoretmp)
 58+  AD7A 3D               dec a
 59+  AD7B 3D               dec a
 60+  AD7C 3D               dec a                                   ; get high score location back to position of name
 61+  AD7D 16 00            ld d,0
 62+  AD7F 5F               ld e,a
 63+  AD80 21 6F C4         ld hl,scores_table
 64+  AD83 19               add hl,de                               ; load memory into hl
 65+  AD84 08               ex af,af'
 66+  AD85 06 0F            ld b,15
 67+  AD87 CD 9B 80         call utilities_pauseforframes           ; pause for a little bit
 68+  AD8A 06 03            ld b,3                                  ; collect three chars
 69+  AD8C              gameover_draw2:
 70+  AD8C C5               push bc
 71+  AD8D E5               push hl
 72+  AD8E CD 9F 80         call utilities_readkey               ; get key into a
 73+  AD91 E1               pop hl
 74+  AD92 77               ld (hl),a
 75+  AD93 23               inc hl
 76+  AD94 E5               push hl
 77+  AD95 CD 46 C5         call scores_showtable
 78+  AD98 E1               pop hl
 79+  AD99 06 0F            ld b,15
 80+  AD9B CD 9B 80         call utilities_pauseforframes
 81+  AD9E C1               pop bc
 82+  AD9F 10 EB            djnz gameover_draw2
 83+  ADA1 C9               ret
 84+  ADA2
 85+  ADA2              ;
 86+  ADA2              ; Displays the screen text for high score entry
 87+  ADA2              ;
 88+  ADA2              gameover_enterhighscores_init:
 89+  ADA2
 90+  ADA2 CD 0C AE         call gameover_init
 91+  ADA5 CD 51 AD         call gameover_commontext
 92+  ADA8
 93+  ADA8 21 BC 83         ld hl,string_highscore_congratulations
 94+  ADAB CD 56 85         call string_print
 95+  ADAE
 96+  ADAE 3A 5F BD         ld a,(game_currentplayer)
 97+  ADB1 FE 01            cp 1
 98+  ADB3 21 CE 83         ld hl,string_highscore_player1
 99+  ADB6 C3 BC AD         jp gameover_enterhighscores_init1
100+  ADB9              gameover_enterhighscores_init0:
101+  ADB9 21 D9 83         ld hl,string_highscore_player2
102+  ADBC              gameover_enterhighscores_init1:
103+  ADBC CD 56 85         call string_print
104+  ADBF 06 60            ld b,96
105+  ADC1 3E 43            ld a,67
106+  ADC3 11 A0 58         ld de,22528+160                         ; attrs here
107+  ADC6 CD BD A8         call screen_setcolours
108+  ADC9
109+  ADC9 21 E4 83         ld hl,string_highscore_youhaveearned
110+  ADCC CD 56 85         call string_print
111+  ADCF
112+  ADCF 3A 59 C5         ld a,(scores_highscoretmp)
113+  ADD2 FE 05            cp 5
114+  ADD4 CA E2 AD         jp z, gameover_enterhighscores_init2    ; first place
115+  ADD7 FE 11            cp 17
116+  ADD9 CA E8 AD         jp z, gameover_enterhighscores_init3    ; 2nd place
117+  ADDC 21 20 84         ld hl,string_highscore_place3           ; 3rd place
118+  ADDF C3 EE AD         jp gameover_enterhighscores_init4
119+  ADE2              gameover_enterhighscores_init2
120+  ADE2 21 F6 83         ld hl,string_highscore_place1
121+  ADE5 C3 EE AD         jp gameover_enterhighscores_init4
122+  ADE8              gameover_enterhighscores_init3
123+  ADE8 21 0B 84         ld hl,string_highscore_place2
124+  ADEB C3 EE AD         jp gameover_enterhighscores_init4
125+  ADEE              gameover_enterhighscores_init4
126+  ADEE CD 56 85         call string_print
127+  ADF1
128+  ADF1 06 60            ld b,96
129+  ADF3 3E 42            ld a,66
130+  ADF5 11 40 59         ld de,22528+320                         ; attrs here
131+  ADF8 CD BD A8         call screen_setcolours
132+  ADFB
133+  ADFB 21 35 84         ld hl,string_highscore_pleaseenter
134+  ADFE CD 56 85         call string_print
135+  AE01
136+  AE01 06 60            ld b,96
137+  AE03 3E 46            ld a,70
138+  AE05 11 E0 59         ld de,22528+480                         ; attrs here
139+  AE08 CD BD A8         call screen_setcolours
140+  AE0B C9               ret
141+  AE0C
142+  AE0C              ;
143+  AE0C              ; Initialises the screen
144+  AE0C              ;
145+  AE0C              gameover_init:
146+  AE0C              ; We want a black screen.
147+  AE0C 3E 47            ld a,71             ; white ink (7) on black paper (0),
148+  AE0E                                      ; bright (64).
149+  AE0E CD 80 80         call utilities_clearscreen
150+  AE11 32 8D 5C         ld (23693),a        ; set our screen colours.
151+  AE14 3E 00            ld a,0              ; 2 is the code for red.
152+  AE16 D3 FE            out (254),a         ; write to port 254.
153+  AE18 C9               ret
# file closed: screen/gameover.asm
 29   AE19                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AE19              ;
  2+  AE19              ; Draws the level transition screen
  3+  AE19              ;
  4+  AE19              endlevel_draw:
  5+  AE19 CD 14 AF         call endlevel_init
  6+  AE1C CD FD AE         call endlevel_commontext
  7+  AE1F
  8+  AE1F 21 BC 83         ld hl,string_highscore_congratulations
  9+  AE22 CD 56 85         call string_print
 10+  AE25
 11+  AE25 3A 5F BD         ld a,(game_currentplayer)
 12+  AE28 FE 01            cp 1
 13+  AE2A 21 CE 83         ld hl,string_highscore_player1
 14+  AE2D C3 33 AE         jp endlevel_init1
 15+  AE30              endlevel_init0:
 16+  AE30 21 D9 83         ld hl,string_highscore_player2
 17+  AE33              endlevel_init1:
 18+  AE33 CD 56 85         call string_print
 19+  AE36
 20+  AE36 21 52 84         ld hl,string_endlevel_youhaveearned
 21+  AE39 CD 56 85         call string_print
 22+  AE3C
 23+  AE3C CD 9C AE         call endlevel_workoutbonus
 24+  AE3F D5               push de
 25+  AE40 08               ex af,af'                               ; store the a value for later
 26+  AE41 CD 56 85         call string_print
 27+  AE44 D1               pop de
 28+  AE45 62 6B            ld hl,de                                ; get the points text into de
 29+  AE47 CD 56 85         call string_print
 30+  AE4A
 31+  AE4A 21 BD 84         ld hl, string_endlevel_anothergo
 32+  AE4D CD 56 85         call string_print
 33+  AE50
 34+  AE50 06 20            ld b,32
 35+  AE52 3E 23            ld a,35
 36+  AE54 11 60 59         ld de,22528+352                         ; attrs here
 37+  AE57 CD BD A8         call screen_setcolours
 38+  AE5A
 39+  AE5A 06 20            ld b,32
 40+  AE5C 3E 25            ld a,37
 41+  AE5E 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AE61 CD BD A8         call screen_setcolours
 43+  AE64
 44+  AE64 06 20            ld b,32
 45+  AE66 3E 23            ld a,35
 46+  AE68 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AE6B CD BD A8         call screen_setcolours
 48+  AE6E
 49+  AE6E 06 20            ld b,32
 50+  AE70 3E 22            ld a,34
 51+  AE72 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AE75 CD BD A8         call screen_setcolours
 53+  AE78
 54+  AE78 08               ex af,af'                               ; get back a value with bonus type
 55+  AE79 06 14            ld b,20
 56+  AE7B CD 9B 80         call utilities_pauseforframes
 57+  AE7E
 58+  AE7E 47               ld b,a                      ; put the bonus count in b
 59+  AE7F              endlevel_init2:
 60+  AE7F C5               push bc
 61+  AE80 06 01            ld b,1
 62+  AE82 CD 93 C4         call scores_addthousands
 63+  AE85 CD 5B BE         call player_recordcurrentstate
 64+  AE88 CD AA C4         call scores_printscore     ; print the current scores
 65+  AE8B 06 0A            ld b,10
 66+  AE8D CD 9B 80         call utilities_pauseforframes
 67+  AE90 C1               pop bc
 68+  AE91 10 EC            djnz endlevel_init2
 69+  AE93
 70+  AE93 CD 8F BD         call game_increasedifficulty ; move the difficulty up a level
 71+  AE96
 72+  AE96 3E 64            ld a,100                              ; wait for 200 frames
 73+  AE98 CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 74+  AE9B
 75+  AE9B C9               ret
 76+  AE9C
 77+  AE9C              ;
 78+  AE9C              ; Works out the bonus
 79+  AE9C              ; Outputs:
 80+  AE9C              ; a = 15 (all seven)
 81+  AE9C              ; a = 10 (3 large or 4 small)
 82+  AE9C              ; a = 5 (1 large diamond)
 83+  AE9C              ; hl - pointer to bonus text
 84+  AE9C              ; de - pointer to points text
 85+  AE9C              ;
 86+  AE9C              endlevel_workoutbonus:
 87+  AE9C 21 33 B5         ld hl,level01diamonds+2     ; location of state of first diamond
 88+  AE9F 06 03            ld b,3                      ; number to check
 89+  AEA1 16 00            ld d,0                      ; zero diamond count
 90+  AEA3              endlevel_workoutbonus0:
 91+  AEA3 7E               ld a,(hl)                   ; get state
 92+  AEA4 FE 01            cp 1
 93+  AEA6 C2 AA AE         jp nz,endlevel_workoutbonus1 ; if not, move on
 94+  AEA9 14               inc d                       ; increment diamond count
 95+  AEAA              endlevel_workoutbonus1:
 96+  AEAA 23               inc hl
 97+  AEAB 23               inc hl
 98+  AEAC 23               inc hl
 99+  AEAD 23               inc hl
100+  AEAE 23               inc hl                      ; get to next state
101+  AEAF 10 F2            djnz endlevel_workoutbonus0
102+  AEB1
103+  AEB1 21 43 B5         ld hl,level01gems+2     ; location of state of first gem
104+  AEB4 06 04            ld b,4                      ; number to check
105+  AEB6 1E 00            ld e,0                      ; zero gem count
106+  AEB8              endlevel_workoutbonus2:
107+  AEB8 7E               ld a,(hl)                   ; get state
108+  AEB9 FE 01            cp 1
109+  AEBB C2 BF AE         jp nz,endlevel_workoutbonus3 ; if not, move on
110+  AEBE 1C               inc e                       ; increment diamond count
111+  AEBF              endlevel_workoutbonus3:
112+  AEBF 23               inc hl
113+  AEC0 23               inc hl
114+  AEC1 23               inc hl
115+  AEC2 23               inc hl
116+  AEC3 23               inc hl                     ; get to next state
117+  AEC4 10 F2            djnz endlevel_workoutbonus2
118+  AEC6
119+  AEC6 7A               ld a,d
120+  AEC7 83               add e
121+  AEC8 FE 07            cp 7                        ; check for max bonus
122+  AECA C2 D6 AE         jp nz,endlevel_workoutbonus4 ;
123+  AECD 3E 0F            ld a,15
124+  AECF 21 82 84         ld hl, string_endlevel_bonus3
125+  AED2 11 AE 84         ld de, string_endlevel_points3
126+  AED5 C9               ret                         ; return with bonus of 15
127+  AED6              endlevel_workoutbonus4:
128+  AED6 7A               ld a,d                      ; check for for diamonds
129+  AED7 FE 03            cp 3
130+  AED9 C2 E5 AE         jp nz,endlevel_workoutbonus5
131+  AEDC 3E 0A            ld a,10
132+  AEDE 21 73 84         ld hl, string_endlevel_bonus2
133+  AEE1 11 9F 84         ld de, string_endlevel_points2
134+  AEE4 C9               ret                         ; return with bonus of ten
135+  AEE5              endlevel_workoutbonus5:
136+  AEE5 7B               ld a,e                      ; check for four gems
137+  AEE6 FE 04            cp 4
138+  AEE8 C2 F4 AE         jp nz,endlevel_workoutbonus6
139+  AEEB 3E 0A            ld a,10
140+  AEED 21 73 84         ld hl, string_endlevel_bonus2
141+  AEF0 11 9F 84         ld de, string_endlevel_points2
142+  AEF3 C9               ret                         ; return with bonus of 10
143+  AEF4              endlevel_workoutbonus6:
144+  AEF4 3E 05            ld a,5                      ; otherwise, bonus is 5
145+  AEF6 21 64 84         ld hl, string_endlevel_bonus1
146+  AEF9 11 91 84         ld de, string_endlevel_points1
147+  AEFC C9               ret
148+  AEFD
149+  AEFD              ;
150+  AEFD              ; Draws text shared by the game over and high score screens
151+  AEFD              ;
152+  AEFD              endlevel_commontext:
153+  AEFD CD 8F A8         call screen_setuptext       ; show scores
154+  AF00 CD EA C4         call scores_printscores     ; print the current scores
155+  AF03
156+  AF03 21 9C 83         ld hl,string_gameoverscreen_bestscores
157+  AF06 CD 56 85         call string_print
158+  AF09
159+  AF09 06 20            ld b,32
160+  AF0B 3E 45            ld a,69
161+  AF0D 11 C0 5A         ld de,22528+704                         ; attrs here
162+  AF10 CD BD A8         call screen_setcolours
163+  AF13
164+  AF13 C9               ret
165+  AF14
166+  AF14              ;
167+  AF14              ; Initialises the screen
168+  AF14              ;
169+  AF14              endlevel_init:
170+  AF14              ; We want a green screen.
171+  AF14 3E 21            ld a,33             ; white ink (7) on black paper (0),
172+  AF16                                      ; bright (64).
173+  AF16 CD 80 80         call utilities_clearscreen
174+  AF19 32 8D 5C         ld (23693),a        ; set our screen colours.
175+  AF1C 3E 00            ld a,0              ; 2 is the code for red.
176+  AF1E D3 FE            out (254),a         ; write to port 254.
177+  AF20 C9               ret
# file closed: screen/endlevel.asm
 30   AF21                  include "screen\options.asm"
# file opened: screen/options.asm
  1+  AF21              ;
  2+  AF21              ; Show the options screen
  3+  AF21              ;
  4+  AF21              options_show:
  5+  AF21 CD BC AF         call options_init
  6+  AF24
  7+  AF24 21 D7 84         ld hl,string_options_title
  8+  AF27 CD 56 85         call string_print
  9+  AF2A 21 E1 84         ld hl,string_options_1player
 10+  AF2D CD 56 85         call string_print
 11+  AF30 21 F1 84         ld hl,string_options_2player
 12+  AF33 CD 56 85         call string_print
 13+  AF36 21 01 85         ld hl,string_options_keyboard
 14+  AF39 CD 56 85         call string_print
 15+  AF3C 21 0F 85         ld hl,string_options_joystick
 16+  AF3F CD 56 85         call string_print
 17+  AF42 21 1D 85         ld hl,string_options_start
 18+  AF45 CD 56 85         call string_print
 19+  AF48 21 28 85         ld hl,string_options_vanity
 20+  AF4B CD 56 85         call string_print
 21+  AF4E
 22+  AF4E 3A 5E BD         ld a,(game_numberplayers)
 23+  AF51 FE 01            cp 1
 24+  AF53 C2 5C AF         jp nz,options_show0
 25+  AF56 11 CA 58         ld de,22528+202                         ; top row attrs here
 26+  AF59 C3 5F AF         jp options_show1
 27+  AF5C              options_show0:
 28+  AF5C 11 EA 58         ld de,22528+234                         ; top row attrs here
 29+  AF5F              options_show1:
 30+  AF5F 06 0D            ld b,13
 31+  AF61 3E C7            ld a,199
 32+  AF63 CD BD A8         call screen_setcolours                  ; highlight current player
 33+  AF66
 34+  AF66 3A 62 BD         ld a,(game_control)
 35+  AF69 FE 00            cp 0
 36+  AF6B C2 74 AF         jp nz,options_show6
 37+  AF6E 11 0A 59         ld de,22528+266                         ; top row attrs here
 38+  AF71 C3 77 AF         jp options_show7
 39+  AF74              options_show6:
 40+  AF74 11 2A 59         ld de,22528+298                         ; top row attrs here
 41+  AF77              options_show7:
 42+  AF77 06 0D            ld b,13
 43+  AF79 3E C7            ld a,199
 44+  AF7B CD BD A8         call screen_setcolours                  ; highlight current control
 45+  AF7E              options_show8:
 46+  AF7E CD 9F 80         call utilities_readkey
 47+  AF81 FE 31            cp 49                                   ; was 1 pressed
 48+  AF83 C2 8E AF         jp nz,options_show2
 49+  AF86 21 5E BD         ld hl,game_numberplayers
 50+  AF89 36 01            ld (hl),1
 51+  AF8B C3 21 AF         jp options_show
 52+  AF8E              options_show2:
 53+  AF8E FE 32            cp 50                                   ; was 2 pressed
 54+  AF90 C2 9B AF         jp nz,options_show3
 55+  AF93 21 5E BD         ld hl,game_numberplayers
 56+  AF96 36 02            ld (hl),2
 57+  AF98 C3 21 AF         jp options_show
 58+  AF9B              options_show3:
 59+  AF9B FE 33            cp 51                                   ; was 3 pressed
 60+  AF9D C2 A8 AF         jp nz,options_show4
 61+  AFA0 21 62 BD         ld hl,game_control
 62+  AFA3 36 00            ld (hl),0
 63+  AFA5 C3 21 AF         jp options_show
 64+  AFA8              options_show4:
 65+  AFA8 FE 34            cp 52                                   ; was 4 pressed
 66+  AFAA C2 B5 AF         jp nz,options_show5
 67+  AFAD 21 62 BD         ld hl,game_control
 68+  AFB0 36 01            ld (hl),1
 69+  AFB2 C3 21 AF         jp options_show
 70+  AFB5              options_show5:
 71+  AFB5 FE 35            cp 53                                   ; was 5 pressed
 72+  AFB7 C8               ret z                                   ; exit if so
 73+  AFB8 C3 7E AF         jp options_show8                         ; otherwise, jump to top
 74+  AFBB C9               ret
 75+  AFBC
 76+  AFBC              ;
 77+  AFBC              ; Initialise the options screen
 78+  AFBC              ;
 79+  AFBC              options_init:
 80+  AFBC 3E 47            ld a,71             ; white ink (7) on black paper (0),
 81+  AFBE                                      ; bright (64).
 82+  AFBE CD 80 80         call utilities_clearscreen
 83+  AFC1 32 8D 5C         ld (23693),a        ; set our screen colours.
 84+  AFC4 3E 00            ld a,0              ; 2 is the code for red.
 85+  AFC6 D3 FE            out (254),a         ; write to port 254.
 86+  AFC8
 87+  AFC8 C9               ret
 88+  AFC9 C9               ret
# file closed: screen/options.asm
 31   AFCA
 32   AFCA                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  AFCA              sound_gemcollected:
  2+  AFCA 21 C8 00         ld hl,200 ; pitch.
  3+  AFCD 11 3E 00         ld de,62 ; duration.
  4+  AFD0 CD B5 03         call 949 ; ROM beeper routine.
  5+  AFD3 C9               ret
  6+  AFD4
  7+  AFD4              sound_pitchbend:
  8+  AFD4 21 F4 01         ld hl,500 ; starting pitch.
  9+  AFD7 06 FA            ld b,250 ; length of pitch bend.
 10+  AFD9              sound_pitchbend0:
 11+  AFD9 C5                push bc
 12+  AFDA E5               push hl ; store pitch.
 13+  AFDB 11 01 00         ld de,1 ; very short duration.
 14+  AFDE CD B5 03         call 949 ; ROM beeper routine.
 15+  AFE1 E1               pop hl ; restore pitch.
 16+  AFE2 23               inc hl ; pitch going up.
 17+  AFE3 C1               pop bc
 18+  AFE4 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  AFE6 C9               ret
 20+  AFE7
 21+  AFE7              sound_rockfell:
 22+  AFE7 08               ex af,af'
 23+  AFE8 1E 32            ld e,50 ; repeat 250 times.
 24+  AFEA 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  AFED D5           sound_rockfell2 push de
 26+  AFEE 06 20            ld b,32 ; length of step.
 27+  AFF0 C5           sound_rockfell0 push bc
 28+  AFF1 7E               ld a,(hl) ; next "random" number.
 29+  AFF2 23               inc hl ; pointer.
 30+  AFF3 E6 F8            and 248 ; we want a black border.
 31+  AFF5 D3 FE            out (254),a ; write to speaker.
 32+  AFF7 7B               ld a,e ; as e gets smaller...
 33+  AFF8 2F               cpl ; ...we increase the delay.
 34+  AFF9 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  AFFA 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  AFFC C1               pop bc
 37+  AFFD 10 F1            djnz sound_rockfell0 ; next step.
 38+  AFFF D1               pop de
 39+  B000 7B               ld a,e
 40+  B001 D6 18            sub 24 ; size of step.
 41+  B003 FE 1E            cp 30 ; end of range.
 42+  B005 CA 16 B0         jp z,sound_rockfell5
 43+  B008 DA 16 B0         jp c, sound_rockfell5
 44+  B00B 5F               ld e,a
 45+  B00C 2F               cpl
 46+  B00D 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  B00F 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  B011 3D               dec a
 49+  B012 20 F9            jr nz,sound_rockfell3
 50+  B014 18 D7            jr sound_rockfell2
 51+  B016              sound_rockfell5
 52+  B016 08               ex af,af'
 53+  B017 C9               ret
 54+  B018
# file closed: sound/sound.asm
 33   B018
 34   B018                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  B018              ; ###############################################################
  2+  B018              ; Data for level 1
  3+  B018              ; ###############################################################
  4+  B018              level01:
  5+  B018
  6+  B018                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  B018
  8+  B018 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  B01C 05 05 05 05
  8+  B020 05 05 05 05
  8+  B024 05 05 02 01
  8+  B028 01 01 03 05
  8+  B02C 05 05 05 05
  8+  B030 05 05 05 05
  8+  B034 05 05 00 00
  9+  B038 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  B03C 05 05 05 05
  9+  B040 05 05 05 05
  9+  B044 02 01 01 01
  9+  B048 01 01 01 01
  9+  B04C 03 05 05 05
  9+  B050 05 05 05 05
  9+  B054 05 05 00 00
 10+  B058 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  B05C 05 05 05 05
 10+  B060 05 05 02 01
 10+  B064 01 01 01 01
 10+  B068 01 01 01 01
 10+  B06C 01 01 03 05
 10+  B070 0D 0D 0D 0D
 10+  B074 0D 0D 00 00
 11+  B078 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  B07C 01 01 00 01
 11+  B080 01 01 01 01
 11+  B084 01 01 01 01
 11+  B088 01 01 01 01
 11+  B08C 01 01 01 03
 11+  B090 05 05 05 05
 11+  B094 05 05 00 00
 12+  B098 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  B09C 04 04 04 04
 12+  B0A0 04 04 01 01
 12+  B0A4 01 01 01 01
 12+  B0A8 01 01 01 01
 12+  B0AC 01 01 01 01
 12+  B0B0 01 01 01 01
 12+  B0B4 00 01 00 00
 13+  B0B8 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  B0BC 04 04 04 04
 13+  B0C0 04 04 04 04
 13+  B0C4 01 01 01 01
 13+  B0C8 01 01 01 01
 13+  B0CC 01 01 01 01
 13+  B0D0 00 00 00 00
 13+  B0D4 00 01 00 00
 14+  B0D8 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  B0DC 04 01 01 01
 14+  B0E0 01 01 04 04
 14+  B0E4 04 04 01 01
 14+  B0E8 01 01 01 01
 14+  B0EC 01 00 00 00
 14+  B0F0 00 01 01 01
 14+  B0F4 01 01 00 00
 15+  B0F8 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  B0FC 04 04 04 04
 15+  B100 04 01 04 04
 15+  B104 04 04 04 04
 15+  B108 04 04 00 00
 15+  B10C 00 00 04 04
 15+  B110 04 04 04 04
 15+  B114 04 01 00 00
 16+  B118 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  B11C 01 04 01 01
 16+  B120 01 01 04 04
 16+  B124 04 04 04 04
 16+  B128 04 04 00 04
 16+  B12C 04 04 04 04
 16+  B130 04 04 04 04
 16+  B134 04 01 00 00
 17+  B138 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  B13C 00 00 00 00
 17+  B140 00 04 04 04
 17+  B144 04 04 04 04
 17+  B148 04 04 00 04
 17+  B14C 04 04 04 04
 17+  B150 04 04 04 04
 17+  B154 04 01 00 00
 18+  B158 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  B15C 15 15 15 15
 18+  B160 15 01 04 04
 18+  B164 04 04 04 04
 18+  B168 04 04 00 04
 18+  B16C 04 04 04 04
 18+  B170 04 04 04 04
 18+  B174 04 01 00 00
 19+  B178 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B17C 00 00 00 00
 19+  B180 00 01 04 04
 19+  B184 04 04 04 04
 19+  B188 04 04 00 04
 19+  B18C 04 04 04 04
 19+  B190 04 00 00 00
 19+  B194 00 01 00 00
 20+  B198 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B19C 00 00 00 00
 20+  B1A0 00 01 04 04
 20+  B1A4 04 04 04 04
 20+  B1A8 04 04 00 04
 20+  B1AC 04 04 04 04
 20+  B1B0 04 00 04 04
 20+  B1B4 00 01 00 00
 21+  B1B8 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B1BC 06 06 06 06
 21+  B1C0 06 01 04 04
 21+  B1C4 04 04 04 04
 21+  B1C8 04 04 00 04
 21+  B1CC 04 04 04 04
 21+  B1D0 04 00 04 04
 21+  B1D4 00 01 00 00
 22+  B1D8 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B1DC 1A 1A 1A 1A
 22+  B1E0 1A 01 04 00
 22+  B1E4 00 00 00 00
 22+  B1E8 00 00 00 00
 22+  B1EC 00 00 00 00
 22+  B1F0 00 00 04 04
 22+  B1F4 00 01 00 00
 23+  B1F8 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B1FC 1A 1A 1A 1A
 23+  B200 1A 01 04 00
 23+  B204 04 04 04 04
 23+  B208 04 04 00 04
 23+  B20C 04 04 00 04
 23+  B210 04 04 04 04
 23+  B214 00 01 00 00
 24+  B218 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B21C 1A 1A 1A 1A
 24+  B220 1A 01 04 00
 24+  B224 04 04 04 04
 24+  B228 04 04 00 04
 24+  B22C 04 04 00 04
 24+  B230 04 04 04 04
 24+  B234 00 01 00 00
 25+  B238 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B23C 01 01 01 01
 25+  B240 01 01 04 00
 25+  B244 04 04 04 04
 25+  B248 04 04 00 04
 25+  B24C 04 04 00 04
 25+  B250 04 04 04 04
 25+  B254 00 01 00 00
 26+  B258 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B25C 04 04 04 04
 26+  B260 04 04 04 00
 26+  B264 04 04 04 04
 26+  B268 04 04 00 04
 26+  B26C 04 04 00 00
 26+  B270 00 00 04 04
 26+  B274 04 01 00 00
 27+  B278 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B27C 04 04 00 00
 27+  B280 00 00 00 00
 27+  B284 04 04 04 04
 27+  B288 04 04 00 04
 27+  B28C 04 04 04 04
 27+  B290 04 00 04 04
 27+  B294 04 01 00 00
 28+  B298 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B29C 04 04 00 04
 28+  B2A0 04 04 04 04
 28+  B2A4 04 04 04 04
 28+  B2A8 04 04 00 04
 28+  B2AC 04 04 04 04
 28+  B2B0 04 00 04 04
 28+  B2B4 04 01 00 00
 29+  B2B8 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B2BC 04 04 00 04
 29+  B2C0 04 04 01 01
 29+  B2C4 01 01 01 01
 29+  B2C8 01 01 01 01
 29+  B2CC 01 01 01 01
 29+  B2D0 04 00 04 04
 29+  B2D4 04 01 00 00
 30+  B2D8 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B2DC 04 04 00 04
 30+  B2E0 04 04 01 00
 30+  B2E4 00 00 00 00
 30+  B2E8 00 00 00 00
 30+  B2EC 00 00 00 01
 30+  B2F0 04 00 04 04
 30+  B2F4 04 01 00 00
 31+  B2F8 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B2FC 04 04 00 04
 31+  B300 04 04 01 00
 31+  B304 00 00 00 00
 31+  B308 00 00 00 00
 31+  B30C 00 00 00 01
 31+  B310 04 00 04 04
 31+  B314 04 01 00 00
 32+  B318 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B31C 04 04 00 04
 32+  B320 04 04 01 00
 32+  B324 00 00 00 00
 32+  B328 00 00 00 00
 32+  B32C 00 00 00 01
 32+  B330 04 00 04 04
 32+  B334 04 01 00 00
 33+  B338 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B33C 04 04 00 04
 33+  B340 04 04 04 00
 33+  B344 00 00 00 00
 33+  B348 00 00 00 00
 33+  B34C 00 00 00 04
 33+  B350 04 04 04 04
 33+  B354 04 01 00 00
 34+  B358 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B35C 04 04 04 04
 34+  B360 04 04 01 00
 34+  B364 00 00 00 00
 34+  B368 00 00 00 00
 34+  B36C 00 00 00 01
 34+  B370 04 04 04 04
 34+  B374 04 01 00 00
 35+  B378 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B37C 04 04 04 04
 35+  B380 04 04 01 00
 35+  B384 00 00 01 00
 35+  B388 00 00 00 01
 35+  B38C 00 00 00 01
 35+  B390 04 04 04 04
 35+  B394 04 01 00 00
 36+  B398 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B39C 01 01 01 01
 36+  B3A0 01 01 01 01
 36+  B3A4 01 01 01 01
 36+  B3A8 01 01 01 01
 36+  B3AC 01 01 01 01
 36+  B3B0 01 01 01 01
 36+  B3B4 01 01 00 00
 37+  B3B8
 38+  B3B8              ; ###############################################################
 39+  B3B8              ; Object data: horiz, vert, state, memh, meml
 40+  B3B8              ; ###############################################################
 41+  B3B8              level01rocks:
 42+  B3B8 09 04 00 00      defb 9,4,0,0,0
 42+  B3BC 00
 43+  B3BD 0C 07 00 00      defb 12,7,0,0,0
 43+  B3C1 00
 44+  B3C2 10 07 00 00      defb 16,7,0,0,0
 44+  B3C6 00
 45+  B3C7 0B 08 00 00      defb 11,8,0,0,0
 45+  B3CB 00
 46+  B3CC 0A 0A 00 00      defb 10,10,0,0,0
 46+  B3D0 00
 47+  B3D1 0C 0A 00 00      defb 12,10,0,0,0
 47+  B3D5 00
 48+  B3D6 0D 09 00 00      defb 13,9,0,0,0
 48+  B3DA 00
 49+  B3DB 0E 08 00 00      defb 14,8,0,0,0
 49+  B3DF 00
 50+  B3E0 0F 0B 00 00      defb 15,11,0,0,0
 50+  B3E4 00
 51+  B3E5 0B 0C 00 00      defb 11,12,0,0,0
 51+  B3E9 00
 52+  B3EA 11 0C 00 00      defb 17,12,0,0,0
 52+  B3EE 00
 53+  B3EF 13 08 00 00      defb 19,8,0,0,0
 53+  B3F3 00
 54+  B3F4 16 09 00 00      defb 22,9,0,0,0
 54+  B3F8 00
 55+  B3F9 13 0A 00 00      defb 19,10,0,0,0
 55+  B3FD 00
 56+  B3FE 15 0A 00 00      defb 21,10,0,0,0
 56+  B402 00
 57+  B403 15 0C 00 00      defb 21,12,0,0,0
 57+  B407 00
 58+  B408 16 0C 00 00      defb 22,12,0,0,0
 58+  B40C 00
 59+  B40D 18 0A 00 00      defb 24,10,0,0,0
 59+  B411 00
 60+  B412 19 09 00 00      defb 25,9,0,0,0
 60+  B416 00
 61+  B417 1C 09 00 00      defb 28,9,0,0,0
 61+  B41B 00
 62+  B41C 1B 0C 00 00      defb 27,12,0,0,0
 62+  B420 00
 63+  B421 1A 0D 00 00      defb 26,13,0,0,0
 63+  B425 00
 64+  B426 19 0E 00 00      defb 25,14,0,0,0
 64+  B42A 00
 65+  B42B 19 10 00 00      defb 25,16,0,0,0
 65+  B42F 00
 66+  B430 1A 11 00 00      defb 26,17,0,0,0
 66+  B434 00
 67+  B435 1B 11 00 00      defb 27,17,0,0,0
 67+  B439 00
 68+  B43A 1C 12 00 00      defb 28,18,0,0,0
 68+  B43E 00
 69+  B43F 1A 13 00 00      defb 26,19,0,0,0
 69+  B443 00
 70+  B444 1B 15 00 00      defb 27,21,0,0,0
 70+  B448 00
 71+  B449 1A 17 00 00      defb 26,23,0,0,0
 71+  B44D 00
 72+  B44E 1B 18 00 00      defb 27,24,0,0,0
 72+  B452 00
 73+  B453 19 18 00 00      defb 25,24,0,0,0
 73+  B457 00
 74+  B458 18 17 00 00      defb 24,23,0,0,0
 74+  B45C 00
 75+  B45D 13 14 00 00      defb 19,20,0,0,0
 75+  B461 00
 76+  B462 14 12 00 00      defb 20,18,0,0,0
 76+  B466 00
 77+  B467 14 10 00 00      defb 20,16,0,0,0
 77+  B46B 00
 78+  B46C 15 10 00 00      defb 21,16,0,0,0
 78+  B470 00
 79+  B471 16 12 00 00      defb 22,18,0,0,0
 79+  B475 00
 80+  B476 11 14 00 00      defb 17,20,0,0,0
 80+  B47A 00
 81+  B47B 0D 11 00 00      defb 13,17,0,0,0
 81+  B47F 00
 82+  B480 0C 13 00 00      defb 12,19,0,0,0
 82+  B484 00
 83+  B485 0B 13 00 00      defb 11,19,0,0,0
 83+  B489 00
 84+  B48A 0A 11 00 00      defb 10,17,0,0,0
 84+  B48E 00
 85+  B48F 05 12 00 00      defb 5,18,0,0,0
 85+  B493 00
 86+  B494 07 16 00 00      defb 7,22,0,0,0
 86+  B498 00
 87+  B499 09 16 00 00      defb 9,22,0,0,0
 87+  B49D 00
 88+  B49E 07 18 00 00      defb 7,24,0,0,0
 88+  B4A2 00
 89+  B4A3 05 18 00 00      defb 5,24,0,0,0
 89+  B4A7 00
 90+  B4A8 06 19 00 00      defb 6,25,0,0,0
 90+  B4AC 00
 91+  B4AD 08 19 00 00      defb 8,25,0,0,0
 91+  B4B1 00
 92+  B4B2 04 17 00 00      defb 4,23,0,0,0
 92+  B4B6 00
 93+  B4B7 FF               defb 255
 94+  B4B8
 95+  B4B8              level01missiles:
 96+  B4B8 0B 17 00 00      defb 11,23,0,0,0
 96+  B4BC 00
 97+  B4BD 0B 16 00 00      defb 11,22,0,0,0
 97+  B4C1 00
 98+  B4C2 0C 17 00 00      defb 12,23,0,0,0
 98+  B4C6 00
 99+  B4C7 0C 16 00 00      defb 12,22,0,0,0
 99+  B4CB 00
100+  B4CC 0D 17 00 00      defb 13,23,0,0,0
100+  B4D0 00
101+  B4D1 0D 16 00 00      defb 13,22,0,0,0
101+  B4D5 00
102+  B4D6 0E 17 00 00      defb 14,23,0,0,0
102+  B4DA 00
103+  B4DB 0E 16 00 00      defb 14,22,0,0,0
103+  B4DF 00
104+  B4E0 0F 17 00 00      defb 15,23,0,0,0
104+  B4E4 00
105+  B4E5 0F 16 00 00      defb 15,22,0,0,0
105+  B4E9 00
106+  B4EA 10 17 00 00      defb 16,23,0,0,0
106+  B4EE 00
107+  B4EF 10 16 00 00      defb 16,22,0,0,0
107+  B4F3 00
108+  B4F4 11 17 00 00      defb 17,23,0,0,0
108+  B4F8 00
109+  B4F9 11 16 00 00      defb 17,22,0,0,0
109+  B4FD 00
110+  B4FE 12 17 00 00      defb 18,23,0,0,0
110+  B502 00
111+  B503 12 16 00 00      defb 18,22,0,0,0
111+  B507 00
112+  B508 13 17 00 00      defb 19,23,0,0,0
112+  B50C 00
113+  B50D 13 16 00 00      defb 19,22,0,0,0
113+  B511 00
114+  B512 14 17 00 00      defb 20,23,0,0,0
114+  B516 00
115+  B517 14 16 00 00      defb 20,22,0,0,0
115+  B51B 00
116+  B51C 15 17 00 00      defb 21,23,0,0,0
116+  B520 00
117+  B521 15 16 00 00      defb 21,22,0,0,0
117+  B525 00
118+  B526 16 17 00 00      defb 22,23,0,0,0
118+  B52A 00
119+  B52B 16 16 00 00      defb 22,22,0,0,0
119+  B52F 00
120+  B530 FF               defb 255
121+  B531
122+  B531              ;
123+  B531              ; Diamonds: x,y,state,mem1+mem2
124+  B531              ;
125+  B531              level01diamonds:
126+  B531 0C 1B 00 00      defb 12,27,0,0,0
126+  B535 00
127+  B536 10 1B 00 00      defb 16,27,0,0,0
127+  B53A 00
128+  B53B 15 1B 00 00      defb 21,27,0,0,0
128+  B53F 00
129+  B540 FF               defb 255
130+  B541
131+  B541              level01gems:
132+  B541 12 14 00 00      defb 18,20,0,0,0
132+  B545 00
133+  B546 06 18 00 00      defb 6,24,0,0,0
133+  B54A 00
134+  B54B 19 17 00 00      defb 25,23,0,0,0
134+  B54F 00
135+  B550 1C 11 00 00      defb 28,17,0,0,0
135+  B554 00
136+  B555 FF               defb 255
137+  B556              ;
138+  B556              ; Score area colours
139+  B556              ;
140+  B556              score_colours:
141+  B556 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  B55A 47 47 47 47
141+  B55E 47 47 47 42
141+  B562 43 43 43 43
141+  B566 43 43 43 43
141+  B56A 42 47 47 47
141+  B56E 47 47 47 47
141+  B572 47 47 47 47
142+  B576 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  B57A 47 47 47 47
142+  B57E 47 47 47 46
142+  B582 46 46 46 46
142+  B586 46 46 46 46
142+  B58A 46 47 47 47
142+  B58E 47 47 47 47
142+  B592 47 47 47 47
143+  B596
144+  B596              high_score_colours:
145+  B596 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  B59A 42 42 47 47
145+  B59E 47 47 47 47
145+  B5A2 43 43 43 47
145+  B5A6 47 47 47 47
145+  B5AA 47 46 46 46
145+  B5AE 47 47 47 47
145+  B5B2 47 47 00 00
# file closed: leveldata/level01.asm
 35   B5B6                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B5B6              ; Tiles graphics.
  2+  B5B6              sprites:
  3+  B5B6 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B5BA 00 00 00 00
  4+  B5BE FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B5C2 FF FF FF FF
  5+  B5C6 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B5CA 1F 3F 7F FF
  6+  B5CE 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B5D2 F8 FC FE FF
  7+  B5D6 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B5DA 55 AA 55 AA
  8+  B5DE 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B5E2 00 00 00 00
  9+  B5E6 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 6, slime block
  9+  B5EA 00 00 00 00
 10+  B5EE 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  B5F2 00 00 00 00
 11+  B5F6 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B5FA F1 72 34 18
 12+  B5FE 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B602 FE FE FF 7E
 13+  B606 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B60A FE FF 7E 3C
 14+  B60E 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B612 00 00 FF FF
 15+  B616 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  B61A FF 42 24 18
 16+  B61E 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B622 00 00 00 00
 17+  B626 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B62A 00 3C 5A 34
 18+  B62E FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  B632 FD FE FD FE
 19+  B636 F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  B63A F4 F8 F4 F8
 20+  B63E D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  B642 D0 E0 D0 E0
 21+  B646 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  B64A 40 80 40 80
 22+  B64E 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  B652 ED 00 00 00
 23+  B656 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  B65A FF 7E 3C 18
 24+  B65E FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  B662 00 00 00 00
 25+  B666 FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  B66A 00 00 00 00
 26+  B66E F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  B672 00 00 00 00
 27+  B676 C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  B67A 00 00 00 00
 28+  B67E 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  B682 00 00 00 00
 29+  B686 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  B68A FF FF FF FF
 30+  B68E 00 00 00 66  	defb    0,  0,  0,102,  0,  0,  0,  0     ; 27, bullet
 30+  B692 00 00 00 00
 31+  B696
 32+  B696
 33+  B696              sprite_attrs:
 34+  B696 46               defb    070 ; 0, space
 35+  B697 4D               defb    077 ; 1, cyan block
 36+  B698 4D               defb    077 ; 2, slope left
 37+  B699 4D               defb    077 ; 3, slope right
 38+  B69A 46               defb    070 ; 4, dirt
 39+  B69B 4E               defb    078 ; 5, sky
 40+  B69C 66               defb    102 ; 6, slime
 41+  B69D 42               defb    066 ; 7, trapdoor
 42+  B69E 46               defb    070 ; 8, diamond
 43+  B69F 42               defb    066 ; 9, rock
 44+  B6A0 42               defb    066 ; 10, rock 2
 45+  B6A1 49           	defb    073 ; 11, sky, trapdoor
 46+  B6A2 43           	defb    067 ; 12, missile
 47+  B6A3 4A               defb    074 ; 13, sky, red ink (tank)
 48+  B6A4 46               defb    070 ; 14, gem
 49+  B6A5 4D               defb    077 ; 15, damaged mountain
 50+  B6A6 4D               defb    077 ; 16, damaged mountain 2
 51+  B6A7 4D               defb    077 ; 17, damaged mountain 3
 52+  B6A8 4D               defb    077 ; 18, damaged mountain 4
 53+  B6A9 00           	defb 	000 ; 19, tank missile (not used
 54+  B6AA 43           	defb    067 ; 20, missile active
 55+  B6AB 42           	defb	066	; 21, the pit 1
 56+  B6AC 42           	defb	066	; 22, the pit 2
 57+  B6AD 42           	defb	066	; 23, the pit 3
 58+  B6AE 42           	defb	066	; 24, the pit 4
 59+  B6AF 42           	defb	066	; 25, the pit 5
 60+  B6B0 64           	defb    100 ; 26, slime, green on green
 61+  B6B1 46           	defb 	070 ; 27, bullet
 62+  B6B2
 63+  B6B2
 64+  B6B2              player_sprite:
 65+  B6B2 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 65+  B6B6 38 3D C3 80
 66+  B6BA 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 66+  B6BE 3C 1C 16 32
 67+  B6C2 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 67+  B6C6 3C 38 68 4C
 68+  B6CA 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 68+  B6CE 1C BC C3 01
 69+  B6D2 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 69+  B6D6 3C 3C 64 0C
 70+  B6DA 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 70+  B6DE 3C 3C 26 30
 71+  B6E2 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 71+  B6E6 1E 5C FD 5F
 72+  B6EA 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 72+  B6EE 4F 8F 19 03
 73+  B6F2 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 73+  B6F6 F2 F1 98 C0
 74+  B6FA FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 74+  B6FE 48 08 14 2A
 75+  B702 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 75+  B706 38 78 44 C3
 76+  B70A 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 76+  B70E 1C 1E 22 C3
 77+  B712 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 77+  B716 6F 45 E1 9B
 78+  B71A 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 78+  B71E F6 A2 87 D9
 79+  B722
 80+  B722              ;
 81+  B722              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 82+  B722              ;
 83+  B722              ship_sprite:
 84+  B722 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 84+  B726 03 1F 7F FF
 85+  B72A 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 85+  B72E FF FF FF FF
 86+  B732 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 86+  B736 FF FF FF FF
 87+  B73A 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 87+  B73E C0 F8 FE FF
 88+  B742 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 88+  B746 03 03 02 07
 89+  B74A 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 89+  B74E FF 0F 07 83
 90+  B752 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 90+  B756 FF 10 20 C1
 91+  B75A 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 91+  B75E C0 C0 40 E0
 92+  B762 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 92+  B766 03 03 02 07
 93+  B76A F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 93+  B76E FF 08 04 83
 94+  B772 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 94+  B776 FF F0 E0 C1
 95+  B77A CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 95+  B77E C0 C0 40 E0
 96+  B782
 97+  B782              ;
 98+  B782              ;  First 8 frames are tank, last frame is the gun barrel
 99+  B782              ;
100+  B782              tank_sprite:
101+  B782 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
101+  B786 7F 00 00 00
102+  B78A 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
102+  B78E FE FF 7F 40
103+  B792 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
103+  B796 03 FF FF 01
104+  B79A 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
104+  B79E E0 C0 00 00
105+  B7A2 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
105+  B7A6 F7 E1 7F 3F
106+  B7AA FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
106+  B7AE 54 16 FF FF
107+  B7B2 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
107+  B7B6 9B A8 FF FF
108+  B7BA FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
108+  B7BE 9F AF FE FC
109+  B7C2 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
109+  B7C6 1F 00 00 00
110+  B7CA
111+  B7CA              monster_sprite:
112+  B7CA 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  B7CE 0B D0 16 68
113+  B7D2 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
113+  B7D6 35 AC 7F FE
114+  B7DA FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
114+  B7DE 8F F1 8F F1
115+  B7E2 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
115+  B7E6 18 18 00 00
116+  B7EA 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
116+  B7EE 0B D0 16 68
117+  B7F2 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
117+  B7F6 F5 AF FF FF
118+  B7FA BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
118+  B7FE 0F F0 0F F0
119+  B802 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
119+  B806 00 00 00 00
120+  B80A
121+  B80A              robot_sprite:
122+  B80A 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
122+  B80E CE 12 22 66
123+  B812 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
123+  B816 4E 12 24 6C
124+  B81A 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
124+  B81E 4E 32 63 03
125+  B822 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
125+  B826 CE 0A 09 1B
126+  B82A 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
126+  B82E 73 48 44 66
127+  B832 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
127+  B836 72 48 24 36
128+  B83A 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
128+  B83E 72 4C C6 C0
129+  B842 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
129+  B846 73 50 90 D8
130+  B84A 38 A9 BA 7C  	defb     56,169,186,124, 56, 42, 38, 96     ; dead 1
130+  B84E 38 2A 26 60
131+  B852 1C 95 5D 3E  	defb	 28,149, 93, 62, 28, 84,100,  6		; dead 2
131+  B856 1C 54 64 06
# file closed: graphics/graphics.asm
 36   B85A
 37   B85A                  include "game\control.asm"
# file opened: game/control.asm
  1+  B85A              ;
  2+  B85A              ; Check the preferred input method then move
  3+  B85A              ;
  4+  B85A              control_input:
  5+  B85A 3A A1 BD         ld a,(player+11)    ; first, check if player is dying
  6+  B85D FE 04            cp 4                ; is the player falling
  7+  B85F CC 29 B9         call z, control_fall
  8+  B862 FE 05            cp 5                ; is the player fighting
  9+  B864 CC 16 B9         call z, control_fight
 10+  B867 3A A1 BD         ld a,(player+11)    ; first, check if player is dying
 11+  B86A FE 00            cp 0
 12+  B86C C0               ret nz               ; if so, can't move
 13+  B86D 3A 9B BD         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  B870 FE 00            cp 0
 15+  B872 CA 79 B8         jp z, control_input0
 16+  B875 CD 07 BA         call control_automove
 17+  B878 C9               ret
 18+  B879              control_input0:
 19+  B879 3A 9C BD         ld a,(player+6)      ; next, check if the player is digging
 20+  B87C FE 00            cp 0
 21+  B87E CA 85 B8         jp z, control_input1
 22+  B881 CD 45 B9         call control_dig
 23+  B884 C9               ret
 24+  B885              control_input1:
 25+  B885 3A 62 BD         ld a,(game_control)
 26+  B888 FE 00            cp 0                ; is this keyboard
 27+  B88A C2 91 B8         jp nz,control_input2
 28+  B88D CD 95 B8         call control_keyboard
 29+  B890 C9               ret
 30+  B891              control_input2:
 31+  B891                  ; do joystick
 32+  B891 CD DB B8         call control_joystick
 33+  B894 C9               ret
 34+  B895
 35+  B895              ;
 36+  B895              ; Check the keyboard
 37+  B895              ;
 38+  B895              control_keyboard:
 39+  B895 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 40+  B898 ED 78            in a,(c)            ; read keyboard.
 41+  B89A 47               ld b,a              ; store result in b register.
 42+  B89B CB 18            rr b                ; check outermost key (q).
 43+  B89D D2 C7 B8         jp nc,control_keyboard1
 44+  B8A0 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 45+  B8A3 ED 78            in a,(c)            ; read keyboard.
 46+  B8A5 47               ld b,a              ; store result in b register.
 47+  B8A6 CB 18            rr b                ; check outermost key (a).
 48+  B8A8 D2 CB B8         jp nc,control_keyboard2
 49+  B8AB 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 50+  B8AE ED 78            in a,(c)            ; read keyboard.
 51+  B8B0 47               ld b,a              ; store result in b register.
 52+  B8B1 CB 18            rr b                ; check outermost key (p).
 53+  B8B3 D2 CF B8         jp nc,control_keyboard3
 54+  B8B6 CB 18            rr b                ; check next key.
 55+  B8B8 D2 D3 B8         jp nc,control_keyboard4
 56+  B8BB 01 FE 7F         ld bc,32766         ; port for keyboard row b-space.
 57+  B8BE ED 78            in a,(c)            ; read keyboard.
 58+  B8C0 47               ld b,a              ; store result in b register.
 59+  B8C1 CB 18            rr b                ; check outermost key (space).
 60+  B8C3 D2 D7 B8         jp nc,control_keyboard5
 61+  B8C6 C9               ret
 62+  B8C7              control_keyboard1:
 63+  B8C7 CD 50 BA         call control_pl_moveup         ; player up.
 64+  B8CA C9               ret
 65+  B8CB              control_keyboard2:
 66+  B8CB CD 7D BA         call control_pl_movedown       ; player down.
 67+  B8CE C9               ret
 68+  B8CF              control_keyboard3:
 69+  B8CF CD D9 BA         call control_pl_moveright       ; player left.
 70+  B8D2 C9               ret
 71+  B8D3              control_keyboard4:
 72+  B8D3 CD A9 BA         call control_pl_moveleft       ; player right.
 73+  B8D6 C9               ret
 74+  B8D7              control_keyboard5:
 75+  B8D7 CD 07 BB         call control_pl_fire       ; player fire.
 76+  B8DA C9               ret
 77+  B8DB
 78+  B8DB              ;
 79+  B8DB              ; Check the joystick
 80+  B8DB              ;
 81+  B8DB              control_joystick:
 82+  B8DB 01 1F 00         ld bc,31                        ; Kempston joystick port.
 83+  B8DE ED 78            in a,(c)                        ; read input.
 84+  B8E0 E6 02            and 2                           ; check "left" bit.
 85+  B8E2 C2 0A B9         jp nz,control_joystick3       ; move left.
 86+  B8E5 ED 78            in a,(c)                        ; read input.
 87+  B8E7 E6 01            and 1                           ; test "right" bit.
 88+  B8E9 C2 0E B9         jp nz,control_joystick4       ; move right.
 89+  B8EC ED 78            in a,(c)                        ; read input.
 90+  B8EE E6 08            and 8                           ; check "up" bit.
 91+  B8F0 C2 02 B9         jp nz,control_joystick1       ; move up.
 92+  B8F3 ED 78            in a,(c)                        ; read input.
 93+  B8F5 E6 04            and 4                           ; check "down" bit.
 94+  B8F7 C2 06 B9         jp nz,control_joystick2       ; move down.
 95+  B8FA ED 78            in a,(c)                        ; read input.
 96+  B8FC E6 10            and 16                          ; try the fire bit.
 97+  B8FE C2 12 B9         jp nz,control_joystick5       ; fire pressed.
 98+  B901 C9               ret
 99+  B902              control_joystick1:
100+  B902 CD 50 BA         call control_pl_moveup         ; player up.
101+  B905 C9               ret
102+  B906              control_joystick2:
103+  B906 CD 7D BA         call control_pl_movedown       ; player down.
104+  B909 C9               ret
105+  B90A              control_joystick3:
106+  B90A CD A9 BA         call control_pl_moveleft       ; player left.
107+  B90D C9               ret
108+  B90E              control_joystick4:
109+  B90E CD D9 BA         call control_pl_moveright       ; player right.
110+  B911 C9               ret
111+  B912              control_joystick5:
112+  B912 CD 07 BB         call control_pl_fire
113+  B915 C9               ret
114+  B916
115+  B916              ;
116+  B916              ; Fights the player - just flips the players anim frame
117+  B916              ;
118+  B916              control_fight:
119+  B916 3A 99 BD         ld a,(player+3)             ; load the frame
120+  B919 FE 0C            cp 12                       ; flip between 12 and 13
121+  B91B CA 23 B9         jp z,control_fight0
122+  B91E 3E 0C            ld a,12
123+  B920 C3 25 B9         jp control_fight1
124+  B923              control_fight0:
125+  B923 3E 0D            ld a,13
126+  B925              control_fight1:
127+  B925 32 99 BD         ld (player+3),a           ; save back
128+  B928 C9               ret
129+  B929
130+  B929              ;
131+  B929              ; Falls the player
132+  B929              ;
133+  B929              control_fall:
134+  B929 ED 4B 96 BD      ld bc,(player)              ; get coords
135+  B92D 0C               inc c
136+  B92E ED 43 96 BD      ld (player),bc
137+  B932 3A 99 BD         ld a,(player+3)             ; load the frame
138+  B935 FE 03            cp 3                       ; flip between 3 and 0
139+  B937 C2 3F B9         jp nz, control_fall0
140+  B93A 3E 00            ld a,0
141+  B93C C3 41 B9         jp control_fall1
142+  B93F              control_fall0:
143+  B93F 3E 03            ld a,3
144+  B941              control_fall1:
145+  B941 32 99 BD         ld (player+3),a           ; save back
146+  B944 C9               ret
147+  B945
148+  B945              ;
149+  B945              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
150+  B945              ;
151+  B945              control_dig:
152+  B945 ED 4B 96 BD      ld bc,(player)      ; load the current coords into bc
153+  B949 C5               push bc
154+  B94A 3A 98 BD         ld a,(player+2)     ; get the direction
155+  B94D FE 01            cp 1                ; left
156+  B94F CA 67 B9         jp z,control_dig0
157+  B952 FE 02            cp 2                ; right
158+  B954 CA 7C B9         jp z,control_dig1
159+  B957 FE 03            cp 3                ; down
160+  B959 CA A0 B9         jp z,control_dig5
161+  B95C FE 00            cp 0                ; up
162+  B95E CA 90 B9         jp z,control_dig4
163+  B961 21 9C BD         ld hl,player+6
164+  B964 36 00            ld (hl),0           ; turn off digging
165+  B966 C9               ret                 ; return
166+  B967              control_dig0:           ; going left
167+  B967 CD 21 AB         call sprites_scadd  ; get the current coord
168+  B96A 62 6B            ld hl,de
169+  B96C 2B               dec hl              ; move one left
170+  B96D C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
171+  B96E 78               ld a,b
172+  B96F 06 08            ld b,8
173+  B971 90               sub b
174+  B972 47               ld b,a
175+  B973 79               ld a,c
176+  B974 0E 08            ld c,8
177+  B976 91               sub c
178+  B977 4F               ld c,a
179+  B978 C5               push bc
180+  B979 C3 A9 B9         jp control_dig2
181+  B97C              control_dig1:
182+  B97C CD 21 AB         call sprites_scadd  ; get the current coord
183+  B97F 62 6B            ld hl,de
184+  B981 23               inc hl              ; move one right
185+  B982 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
186+  B983 3E 08            ld a,8
187+  B985 80               add a,b
188+  B986 47               ld b,a
189+  B987 79               ld a,c
190+  B988 0E 08            ld c,8
191+  B98A 91               sub c
192+  B98B 4F               ld c,a
193+  B98C C5               push bc
194+  B98D C3 A9 B9         jp control_dig2
195+  B990              control_dig4:
196+  B990 CD 21 AB         call sprites_scadd  ; get the current coord
197+  B993 62 6B            ld hl,de
198+  B995 11 20 00         ld de,32
199+  B998 ED 52            sbc hl,de             ; move one up
200+  B99A C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
201+  B99B 0D               dec c
202+  B99C C5               push bc
203+  B99D C3 C1 B9         jp control_dig6
204+  B9A0              control_dig5:
205+  B9A0 CD 21 AB         call sprites_scadd  ; get the current coord
206+  B9A3 62 6B            ld hl,de
207+  B9A5 24               inc h              ; move one down
208+  B9A6                                     ; not bothered about working out bc here, since rock will never fall if digging down
209+  B9A6 C3 A9 B9         jp control_dig2
210+  B9A9              ; Normal (not up) digging
211+  B9A9              control_dig2:
212+  B9A9 3A 9E BD         ld a,(player+8)     ; get the number of rows we need to overwrite
213+  B9AC 47               ld b,a              ; rows to copy over
214+  B9AD E5               push hl             ; store the memory location of the first row for later
215+  B9AE              control_dig3:
216+  B9AE CD F0 B9         call control_getpixelrow
217+  B9B1 77               ld (hl),a           ; load contents into row
218+  B9B2 11 20 00         ld de,32
219+  B9B5 19               add hl,de           ; move to next row
220+  B9B6 10 F6            djnz control_dig3
221+  B9B8 E1               pop hl              ; get the original memory location back
222+  B9B9 11 20 00         ld de,32
223+  B9BC ED 52            sbc hl,de           ; move to above row, ready for checking for rock
224+  B9BE C3 D7 B9         jp control_dig10
225+  B9C1              ; Special case for going up
226+  B9C1              control_dig6:
227+  B9C1 3A 9E BD         ld a,(player+8)     ; get the number of rows we need to overwrite
228+  B9C4 47               ld b,a              ; rows to copy over
229+  B9C5              control_dig7:
230+  B9C5 CD F0 B9         call control_getpixelrow
231+  B9C8              control_dig12:
232+  B9C8 77               ld (hl),a           ; load empty into row
233+  B9C9 11 20 00         ld de,32
234+  B9CC ED 52            sbc hl,de           ; move up to next row
235+  B9CE 0D               dec c               ; decrease c to track rows
236+  B9CF 10 F4            djnz control_dig7
237+  B9D1 79               ld a,c
238+  B9D2 D6 07            sub 7
239+  B9D4 C1               pop bc
240+  B9D5 4F               ld c,a
241+  B9D6 C5               push bc             ; store the decreased c coord
242+  B9D7              control_dig10:
243+  B9D7 DD 21 9D BD      ld ix,player+7
244+  B9DB DD 7E 00         ld a,(ix)     ; get the dig frame number
245+  B9DE 3D               dec a
246+  B9DF DD 77 00         ld (ix),a
247+  B9E2                  ; call the check for rocks above the removed dirt
248+  B9E2 DD 21 9C BD      ld ix,player+6
249+  B9E6 DD 7E 00         ld a,(ix)     ; get the dig state
250+  B9E9 FE 00            cp 0
251+  B9EB C1               pop bc
252+  B9EC CC 05 C3         call z, rocks_checkforfalling ; make the check if we're no longer digging
253+  B9EF C9               ret
254+  B9F0
255+  B9F0              ;
256+  B9F0              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
257+  B9F0              ; Inputs:
258+  B9F0              ; hl - memory of pixel row
259+  B9F0              ; Outputs:
260+  B9F0              ; a - modified row to write
261+  B9F0              ;
262+  B9F0              control_getpixelrow:
263+  B9F0 3A 9D BD         ld a,(player+7)     ; get the dig frame number
264+  B9F3 FE 00            cp 0                ; is this the last dig
265+  B9F5 CA FC B9         jp z,control_getpixelrow1
266+  B9F8 7E               ld a,(hl)           ; if not, xor with 255 to flip it
267+  B9F9 EE FF            xor 255
268+  B9FB C9               ret
269+  B9FC              control_getpixelrow1:
270+  B9FC DD 21 9C BD      ld ix,player+6
271+  BA00 DD 36 00 00      ld (ix),0           ; turn off digging
272+  BA04 3E 00            ld a,0              ; if it is, load with empty
273+  BA06 C9               ret
274+  BA07
275+  BA07              ;
276+  BA07              ; Auto move the player until pixels is zero
277+  BA07              ;
278+  BA07              control_automove:
279+  BA07 5F               ld e,a              ; store the number of pixels left to move in e
280+  BA08 ED 4B 96 BD      ld bc,(player)      ; load the current coords into bc
281+  BA0C 21 98 BD         ld hl,player+2      ; get the direction
282+  BA0F 7E               ld a,(hl)
283+  BA10 FE 03            cp 3                ; down
284+  BA12 CA 26 BA         jp z,control_automove3  ; don't need to do anything
285+  BA15 FE 00            cp 0                ; going up
286+  BA17 CA 32 BA         jp z,control_automove2
287+  BA1A FE 01            cp 1                ; going left?
288+  BA1C CA 3E BA         jp z,control_automove0
289+  BA1F 78               ld a,b
290+  BA20 3C               inc a               ; if we're going right, increment a twice for two pixels
291+  BA21 3C               inc a
292+  BA22 47               ld b,a
293+  BA23 C3 42 BA         jp control_automove1
294+  BA26              control_automove3:
295+  BA26 79               ld a,c
296+  BA27 3C               inc a
297+  BA28 3C               inc a               ; if we're going down, increment twice
298+  BA29 4F               ld c,a
299+  BA2A FE 90            cp 144
300+  BA2C CC 1D BB         call z, control_scroll_down
301+  BA2F C3 42 BA         jp control_automove1
302+  BA32              control_automove2:
303+  BA32 79               ld a,c
304+  BA33 3D               dec a
305+  BA34 3D               dec a               ; if we're going up, decrement twice
306+  BA35 4F               ld c,a
307+  BA36 FE 60            cp 96
308+  BA38 CC 2A BB         call z, control_scroll_up
309+  BA3B C3 42 BA         jp control_automove1
310+  BA3E              control_automove0:
311+  BA3E 78               ld a,b
312+  BA3F 3D               dec a               ; if we're going left, decrement a twice
313+  BA40 3D               dec a
314+  BA41 47               ld b,a
315+  BA42              control_automove1:
316+  BA42 ED 43 96 BD      ld (player),bc      ; and back to player
317+  BA46 7B               ld a,e              ; now get the pixel count back
318+  BA47 3D               dec a               ; decrease by one
319+  BA48 21 9B BD         ld hl,player+5
320+  BA4B 77               ld (hl),a           ; copy back
321+  BA4C CD 8F BF         call player_justmoved
322+  BA4F C9               ret
323+  BA50
324+  BA50              ;
325+  BA50              ; Moves the player up
326+  BA50              ;
327+  BA50              control_pl_moveup:
328+  BA50 C5               push bc
329+  BA51 ED 4B 96 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
330+  BA55 79               ld a,c                  ; load c into the acc
331+  BA56 FE 18            cp 24
332+  BA58 CA 76 BA         jp z,control_pl_moveup0 ; are we at the edge of the screen
333+  BA5B FE 60            cp 96
334+  BA5D CC 2A BB         call z, control_scroll_up
335+  BA60 CD D1 BC         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
336+  BA63 F5               push af
337+  BA64 7B               ld a,e                  ; put e in a
338+  BA65 FE 00            cp 0
339+  BA67 CA 75 BA         jp z,control_pl_moveup1 ; don't move if we can't
340+  BA6A F1               pop af
341+  BA6B D6 01            sub 1                   ; subtract 1
342+  BA6D                  ;sub 1                   ; subtract 1
343+  BA6D 4F               ld c,a                  ; load back to c
344+  BA6E ED 43 96 BD      ld (player),bc          ; load back to player
345+  BA72 C3 76 BA         jp control_pl_moveup0
346+  BA75              control_pl_moveup1:
347+  BA75 F1               pop af                  ; restore af if needed
348+  BA76              control_pl_moveup0:
349+  BA76 3E 00            ld a,0
350+  BA78 32 98 BD         ld (player+2),a        ; set direction to up
351+  BA7B C1               pop bc
352+  BA7C C9               ret
353+  BA7D              ;
354+  BA7D              ; Moves the player down
355+  BA7D              ;
356+  BA7D              control_pl_movedown:
357+  BA7D C5               push bc
358+  BA7E ED 4B 96 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
359+  BA82 79               ld a,c                  ; load c into the acc
360+  BA83 FE E0            cp 224
361+  BA85 CA A2 BA         jp z,control_pl_movedown0 ; are we at the edge of the screen
362+  BA88 FE 80            cp 128
363+  BA8A CC 1D BB         call z, control_scroll_down
364+  BA8D CD A5 BC         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
365+  BA90 F5               push af
366+  BA91 7B               ld a,e                  ; put e in a
367+  BA92 FE 00            cp 0
368+  BA94 CA A1 BA         jp z,control_pl_movedown1 ; don't move if we can't
369+  BA97 F1               pop af
370+  BA98 3C               inc a                   ; add 1
371+  BA99                  ;inc a                   ; add 1
372+  BA99 4F               ld c,a                  ; load back to c
373+  BA9A ED 43 96 BD      ld (player),bc          ; load back to player
374+  BA9E C3 A2 BA         jp control_pl_movedown0
375+  BAA1              control_pl_movedown1:
376+  BAA1 F1               pop af                  ; restore af if needed
377+  BAA2              control_pl_movedown0:
378+  BAA2 3E 03            ld a,3
379+  BAA4 32 98 BD         ld (player+2),a        ; set direction to down
380+  BAA7 C1               pop bc
381+  BAA8 C9               ret
382+  BAA9              ;
383+  BAA9              ; Moves the player left
384+  BAA9              ;
385+  BAA9              control_pl_moveleft:
386+  BAA9 C5               push bc
387+  BAAA ED 4B 96 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
388+  BAAE 78               ld a,b                  ; load b into the acc
389+  BAAF FE 10            cp 16
390+  BAB1 CA D2 BA         jp z,control_pl_moveleft0 ; are we at the edge of the screen
391+  BAB4 CD 30 BD         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
392+  BAB7 F5               push af
393+  BAB8 7B               ld a,e                  ; put e in a
394+  BAB9 FE 00            cp 0
395+  BABB CA D1 BA         jp z,control_pl_moveleft1 ; don't move if we can't
396+  BABE 21 9B BD         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
397+  BAC1 3E 03            ld a,3
398+  BAC3 77               ld (hl),a
399+  BAC4 F1               pop af
400+  BAC5 D6 01            sub 1                    ; subtract 2
401+  BAC7 D6 01            sub 1
402+  BAC9 47               ld b,a                  ; load back to c
403+  BACA ED 43 96 BD      ld (player),bc          ; load back to player
404+  BACE C3 D2 BA         jp control_pl_moveleft0
405+  BAD1              control_pl_moveleft1:
406+  BAD1 F1               pop af
407+  BAD2              control_pl_moveleft0:
408+  BAD2 3E 01            ld a,1
409+  BAD4 32 98 BD         ld (player+2),a        ; set direction to left
410+  BAD7 C1               pop bc
411+  BAD8 C9               ret
412+  BAD9              ;
413+  BAD9              ; Moves the player right
414+  BAD9              ;
415+  BAD9              control_pl_moveright:
416+  BAD9 C5               push bc
417+  BADA ED 4B 96 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
418+  BADE 78               ld a,b                  ; load b into the acc
419+  BADF FE F0            cp 240
420+  BAE1 CA 00 BB         jp z,control_pl_moveright0 ; are we at the edge of the screen
421+  BAE4 CD 04 BD         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
422+  BAE7 F5               push af
423+  BAE8 7B               ld a,e                  ; put e in a
424+  BAE9 FE 00            cp 0
425+  BAEB CA FF BA         jp z,control_pl_moveright1 ; don't move if we can't
426+  BAEE 21 9B BD         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
427+  BAF1 3E 03            ld a,3
428+  BAF3 77               ld (hl),a
429+  BAF4 F1               pop af
430+  BAF5 3C               inc a                   ; add 2
431+  BAF6 3C               inc a
432+  BAF7 47               ld b,a                  ; load back to b
433+  BAF8 ED 43 96 BD      ld (player),bc          ; load back to player
434+  BAFC C3 00 BB         jp control_pl_moveright0
435+  BAFF              control_pl_moveright1:
436+  BAFF F1               pop af                  ; restore af if needed
437+  BB00              control_pl_moveright0:
438+  BB00 3E 02            ld a,2
439+  BB02 32 98 BD         ld (player+2),a        ; set direction to right
440+  BB05 C1               pop bc
441+  BB06 C9               ret
442+  BB07
443+  BB07              ;
444+  BB07              ; Player fires
445+  BB07              ;
446+  BB07              control_pl_fire:
447+  BB07 3A 98 BD         ld a,(player+2)         ; get player direction
448+  BB0A FE 00            cp 0
449+  BB0C C8               ret z
450+  BB0D FE 03            cp 3
451+  BB0F C8               ret z                   ; if up or down, don't fire
452+  BB10 3A 7D CD         ld a,(bullet_state+3)       ; get the state
453+  BB13 FE 01            cp 1
454+  BB15 C8               ret z                   ; if currently firing, don't fire
455+  BB16 CD 7E CD         call bullet_init        ; initialise the bullet
456+  BB19 CD 93 CD         call bullet_shoot       ; shoot the bullet
457+  BB1C C9               ret
458+  BB1D
459+  BB1D              ;
460+  BB1D              ; Scrolls the screen down
461+  BB1D              ;
462+  BB1D              control_scroll_down:
463+  BB1D F5               push af
464+  BB1E 3E 08            ld a,8
465+  BB20 32 08 A8         ld (screen_offset),a
466+  BB23 F1               pop af
467+  BB24 21 55 A6         ld hl,buffer_updateall
468+  BB27 36 01            ld (hl),1         ; flag as screen needing update
469+  BB29 C9               ret
470+  BB2A
471+  BB2A              ;
472+  BB2A              ; Scrolls the screen up
473+  BB2A              ;
474+  BB2A              control_scroll_up:
475+  BB2A F5               push af
476+  BB2B 3E 00            ld a,0
477+  BB2D 32 08 A8         ld (screen_offset),a
478+  BB30 F1               pop af
479+  BB31 21 55 A6         ld hl,buffer_updateall
480+  BB34 36 01            ld (hl),1         ; flag as screen needing update
481+  BB36 C9               ret
482+  BB37
483+  BB37
484+  BB37
485+  BB37
# file closed: game/control.asm
 38   BB37                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  BB37              ;
  2+  BB37              ; The number of frames to dig for
  3+  BB37              ;
  4+  BB37              movement_numberdigframes:
  5+  BB37 0A               defb 10
  6+  BB38
  7+  BB38              ;
  8+  BB38              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  BB38              ; Inputs:
 10+  BB38              ; hl - memory location of top pixel row
 11+  BB38              ; bc - screen coords, b horiz, c vert
 12+  BB38              ; Outputs:
 13+  BB38              ; e - 0 if not empty, 1 if empty
 14+  BB38              ;
 15+  BB38              movement_spaceisempty:
 16+  BB38 C5               push bc
 17+  BB39 E5               push hl
 18+  BB3A CD 62 BB         call movement_spaceisgem        ; check if space is a gem
 19+  BB3D E1               pop hl
 20+  BB3E C1               pop bc
 21+  BB3F 7B               ld a,e
 22+  BB40 FE 01            cp 1
 23+  BB42 C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  BB43 3E 08            ld a,8                          ; 8 rows to check
 25+  BB45              movement_spaceisempty0:
 26+  BB45 08               ex af,af'                       ; store the loop counter
 27+  BB46 7E               ld a,(hl)                       ; get current pixel row
 28+  BB47 FE 00            cp 0
 29+  BB49 C2 5D BB         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  BB4C 79               ld a,c                          ; load the vertical coord
 31+  BB4D 3C               inc a                           ; next row down
 32+  BB4E 11 20 00         ld de,32
 33+  BB51 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  BB52 4F               ld c,a                          ; copy vert coord back to c
 35+  BB53 08               ex af,af'                       ; get loop counter back
 36+  BB54 3D               dec a                           ; decrease loop counter
 37+  BB55 C2 45 BB         jp nz, movement_spaceisempty0
 38+  BB58 16 00            ld d,0
 39+  BB5A 1E 01            ld e,1                          ; got to end, so space is empty
 40+  BB5C C9               ret
 41+  BB5D              movement_spaceisempty1:
 42+  BB5D 16 00            ld d,0
 43+  BB5F 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  BB61 C9               ret
 45+  BB62
 46+  BB62              ;
 47+  BB62              ; Check if a space contains a gem
 48+  BB62              ; Inputs:
 49+  BB62              ; bc - screen coords
 50+  BB62              ; Outputs:
 51+  BB62              ; e = 1 if gem
 52+  BB62              movement_spaceisgem:
 53+  BB62 CD 5A A9         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  BB65 21 31 B5         ld hl,level01diamonds           ; check diamonds first
 55+  BB68              movement_spaceisgem0:
 56+  BB68 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  BB6C 7B               ld a,e                          ; check for end of data
 58+  BB6D FE FF            cp 255
 59+  BB6F CA 8A BB         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  BB72 23               inc hl
 61+  BB73 23               inc hl                          ; move to state
 62+  BB74 7E               ld a,(hl)
 63+  BB75 23               inc hl
 64+  BB76 23               inc hl
 65+  BB77 23               inc hl                          ; get to next
 66+  BB78 FE 01            cp 1                            ; check if collected
 67+  BB7A CA 68 BB         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  BB7D 7B               ld a,e                          ; load e again
 69+  BB7E B9               cp c                            ; otherwise, compare c with e
 70+  BB7F C2 68 BB         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  BB82 7A               ld a,d                          ; get d coord
 72+  BB83 B8               cp b                            ; compare b with d
 73+  BB84 C2 68 BB         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  BB87 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  BB89 C9               ret
 76+  BB8A              movement_spaceisgem1:
 77+  BB8A 21 41 B5         ld hl,level01gems              ; check gems
 78+  BB8D              movement_spaceisgem2:
 79+  BB8D 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  BB91 7B               ld a,e                          ; check for end of data
 81+  BB92 FE FF            cp 255
 82+  BB94 CA AF BB         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  BB97 23               inc hl
 84+  BB98 23               inc hl                          ; move to state
 85+  BB99 7E               ld a,(hl)
 86+  BB9A 23               inc hl
 87+  BB9B 23               inc hl
 88+  BB9C 23               inc hl                          ; get to next
 89+  BB9D FE 01            cp 1                            ; check if collected
 90+  BB9F CA 8D BB         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  BBA2 7B               ld a,e                          ; load e again
 92+  BBA3 B9               cp c                            ; otherwise, compare c with e
 93+  BBA4 C2 8D BB         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  BBA7 7A               ld a,d                          ; get d coord
 95+  BBA8 B8               cp b                            ; compare b with d
 96+  BBA9 C2 8D BB         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  BBAC 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  BBAE C9               ret
 99+  BBAF              movement_spaceisgem3:
100+  BBAF 1E 00            ld e,0                          ; nothing found, return e = 0
101+  BBB1 C9               ret
102+  BBB2
103+  BBB2              ;
104+  BBB2              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  BBB2              ; Inputs:
106+  BBB2              ; hl - memory location of top pixel row
107+  BBB2              ; bc - screen coords, b horiz, c vert
108+  BBB2              ; Outputs:
109+  BBB2              ; e - 0 if not empty, 1 if empty
110+  BBB2              ;
111+  BBB2              movement_linebelowisempty:
112+  BBB2 C5               push bc
113+  BBB3 E5               push hl
114+  BBB4 CD 62 BB         call movement_spaceisgem        ; check if space is a gem
115+  BBB7 E1               pop hl
116+  BBB8 C1               pop bc
117+  BBB9 7B               ld a,e
118+  BBBA FE 01            cp 1
119+  BBBC C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  BBBD 7E               ld a,(hl)                       ; get current pixel row
121+  BBBE FE 00            cp 0
122+  BBC0 C2 C8 BB         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  BBC3 16 00            ld d,0
124+  BBC5 1E 01            ld e,1                          ; got to end, so space is empty
125+  BBC7 C9               ret
126+  BBC8              movement_linebelowisempty1:
127+  BBC8 16 00            ld d,0
128+  BBCA 1E 00            ld e,0                          ; returning false, ie space not empty
129+  BBCC C9               ret
130+  BBCD
131+  BBCD              ;
132+  BBCD              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  BBCD              ; Inputs:
134+  BBCD              ; hl - memory location of top pixel row
135+  BBCD              ; bc - screen coords, b horiz, c vert
136+  BBCD              ; Outputs:
137+  BBCD              ; e - 0 if not empty, 1 if empty
138+  BBCD              ;
139+  BBCD              movement_lineaboveisempty:
140+  BBCD C5               push bc
141+  BBCE E5               push hl
142+  BBCF CD 62 BB         call movement_spaceisgem        ; check if space is a gem
143+  BBD2 E1               pop hl
144+  BBD3 C1               pop bc
145+  BBD4 7B               ld a,e
146+  BBD5 FE 01            cp 1
147+  BBD7 C8               ret z
148+  BBD8 7E               ld a,(hl)                       ; get current pixel row
149+  BBD9 FE 00            cp 0
150+  BBDB C2 E3 BB         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  BBDE 16 00            ld d,0
152+  BBE0 1E 01            ld e,1                          ; got to end, so space is empty
153+  BBE2 C9               ret
154+  BBE3              movement_lineaboveisempty1:
155+  BBE3 16 00            ld d,0
156+  BBE5 1E 00            ld e,0                          ; returning false, ie space not empty
157+  BBE7 C9               ret
158+  BBE8
159+  BBE8              ;
160+  BBE8              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  BBE8              ; Inputs:
162+  BBE8              ; hl - memory location of top pixel row
163+  BBE8              ; bc - screen coords, b horiz, c vert
164+  BBE8              ; Outputs:
165+  BBE8              ; none - puts player into digging mode
166+  BBE8              ;
167+  BBE8              movement_spaceisdiggable:
168+  BBE8 3E 08            ld a,8                          ; 8 rows to check
169+  BBEA              movement_spaceisdiggable0:
170+  BBEA 08               ex af,af'                       ; store the loop counter
171+  BBEB 7E               ld a,(hl)                       ; get current pixel row
172+  BBEC FE 00            cp 0
173+  BBEE CA FE BB         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  BBF1 FE 55            cp 85
175+  BBF3 CA FE BB         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  BBF6 FE AA            cp 170
177+  BBF8 CA FE BB         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  BBFB C3 18 BC         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  BBFE              movement_spaceisdiggable2:
180+  BBFE 79               ld a,c                          ; load the vertical coord
181+  BBFF 3C               inc a                           ; next row down
182+  BC00 11 20 00         ld de,32
183+  BC03 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  BC04 4F               ld c,a                          ; copy vert coord back to c
185+  BC05 08               ex af,af'                       ; get loop counter back
186+  BC06 3D               dec a                           ; decrease loop counter
187+  BC07 C2 EA BB         jp nz, movement_spaceisdiggable0
188+  BC0A 21 9C BD         ld hl,player+6
189+  BC0D 36 01            ld (hl),1                       ; set the player into digging mode
190+  BC0F 23               inc hl
191+  BC10 3A 37 BB         ld a,(movement_numberdigframes)
192+  BC13 77               ld (hl),a                       ; set the number of frame to dig for
193+  BC14 23               inc hl
194+  BC15 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  BC17 C9               ret
196+  BC18              movement_spaceisdiggable1:
197+  BC18 21 9C BD         ld hl,player+6
198+  BC1B 36 00            ld (hl),0                       ; set the player out of digging mode
199+  BC1D C9               ret
200+  BC1E
201+  BC1E              ;
202+  BC1E              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
203+  BC1E              ; Inputs:
204+  BC1E              ; hl - memory location of top pixel row
205+  BC1E              ; bc - screen coords, b horiz, c vert
206+  BC1E              ; Outputs:
207+  BC1E              ; none - puts player into digging mode
208+  BC1E              ;
209+  BC1E              movement_spacebelowisdiggable:
210+  BC1E 7E               ld a,(hl)                       ; get first pixel row
211+  BC1F FE 55            cp 85
212+  BC21 CA 2C BC         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
213+  BC24 FE AA            cp 170
214+  BC26 CA 2C BC         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
215+  BC29 C3 18 BC         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
216+  BC2C              movement_spacebelowisdiggable3:
217+  BC2C 3E 08            ld a,8                          ; rows to check
218+  BC2E 1E 00            ld e,0                          ; count of rows to dig
219+  BC30              movement_spacebelowisdiggable0:
220+  BC30 08               ex af,af'                       ; store the loop counter
221+  BC31 7E               ld a,(hl)                       ; get current pixel row
222+  BC32 FE 55            cp 85
223+  BC34 CA 3F BC         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
224+  BC37 FE AA            cp 170
225+  BC39 CA 3F BC         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
226+  BC3C C3 4E BC         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
227+  BC3F              movement_spacebelowisdiggable4:
228+  BC3F 1C               inc e                           ; inc count of rows to dig
229+  BC40              movement_spacebelowisdiggable2:
230+  BC40 79               ld a,c                          ; load the vertical coord
231+  BC41 3C               inc a                           ; next row down
232+  BC42 D5               push de                         ; need e for later
233+  BC43 11 20 00         ld de,32
234+  BC46 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
235+  BC47 4F               ld c,a                          ; copy vert coord back to c
236+  BC48 D1               pop de                          ; get e back
237+  BC49 08               ex af,af'                       ; get loop counter back
238+  BC4A 3D               dec a                           ; incease loop counter
239+  BC4B C2 30 BC         jp nz, movement_spacebelowisdiggable0
240+  BC4E              movement_spacebelowisdiggable5:
241+  BC4E 21 9C BD         ld hl,player+6
242+  BC51 36 01            ld (hl),1                       ; set the player into digging mode
243+  BC53 23               inc hl
244+  BC54 3A 37 BB         ld a,(movement_numberdigframes)
245+  BC57 77               ld (hl),a                       ; set the number of frame to dig for
246+  BC58 23               inc hl
247+  BC59 73               ld (hl),e                       ; set the number of pixels to dig
248+  BC5A C9               ret
249+  BC5B              movement_spacebelowisdiggable1:
250+  BC5B 21 9C BD         ld hl,player+6
251+  BC5E 36 00            ld (hl),0                       ; set the player out of digging mode
252+  BC60 C9               ret
253+  BC61
254+  BC61              ;
255+  BC61              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
256+  BC61              ; Inputs:
257+  BC61              ; hl - memory location of top pixel row
258+  BC61              ; bc - screen coords, b horiz, c vert
259+  BC61              ; Outputs:
260+  BC61              ; none - puts player into digging mode
261+  BC61              ;
262+  BC61              movement_spaceaboveisdiggable:
263+  BC61 7E               ld a,(hl)                       ; get first pixel row
264+  BC62 FE 55            cp 85
265+  BC64 CA 6F BC         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
266+  BC67 FE AA            cp 170
267+  BC69 CA 6F BC         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
268+  BC6C C3 18 BC         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
269+  BC6F              movement_spaceaboveisdiggable3:
270+  BC6F 3E 08            ld a,8                          ; rows to check
271+  BC71 1E 00            ld e,0                          ; count of rows to dig
272+  BC73              movement_spaceaboveisdiggable0:
273+  BC73 08               ex af,af'                       ; store the loop counter
274+  BC74 7E               ld a,(hl)                       ; get current pixel row
275+  BC75 FE 55            cp 85
276+  BC77 CA 82 BC         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
277+  BC7A FE AA            cp 170
278+  BC7C CA 82 BC         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
279+  BC7F C3 92 BC         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
280+  BC82              movement_spaceaboveisdiggable4:
281+  BC82 1C               inc e                           ; inc count of rows to dig
282+  BC83              movement_spaceaboveisdiggable2:
283+  BC83 79               ld a,c                          ; load the vertical coord
284+  BC84 3D               dec a                           ; next row up
285+  BC85 D5               push de                         ; need e for later
286+  BC86 11 20 00         ld de,32
287+  BC89 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
288+  BC8B 4F               ld c,a                          ; copy vert coord back to c
289+  BC8C D1               pop de                          ; get e back
290+  BC8D 08               ex af,af'                       ; get loop counter back
291+  BC8E 3D               dec a                           ; incease loop counter
292+  BC8F C2 73 BC         jp nz, movement_spaceaboveisdiggable0
293+  BC92              movement_spaceaboveisdiggable5:
294+  BC92 21 9C BD         ld hl,player+6
295+  BC95 36 01            ld (hl),1                       ; set the player into digging mode
296+  BC97 23               inc hl
297+  BC98 3A 37 BB         ld a,(movement_numberdigframes)
298+  BC9B 77               ld (hl),a                       ; set the number of frame to dig for
299+  BC9C 23               inc hl
300+  BC9D 73               ld (hl),e                       ; set the number of pixels to dig
301+  BC9E C9               ret
302+  BC9F              movement_spaceaboveisdiggable1:
303+  BC9F 21 9C BD         ld hl,player+6
304+  BCA2 36 00            ld (hl),0                       ; set the player out of digging mode
305+  BCA4 C9               ret
306+  BCA5
307+  BCA5              ;
308+  BCA5              ; Checks if the player can move down
309+  BCA5              ; Inputs:
310+  BCA5              ; bc - player coords, b horiz, c vert
311+  BCA5              ; Outputs:
312+  BCA5              ; de - 1 can move
313+  BCA5              movement_checkcanmove_down:
314+  BCA5 F5               push af
315+  BCA6 C5               push bc
316+  BCA7 CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
317+  BCAA 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
318+  BCAC 24               inc h                       ; memory location of cell beneath now in hl
319+  BCAD 3E 08            ld a,8                       ; look below
320+  BCAF 81               add c
321+  BCB0 4F               ld c,a
322+  BCB1 CD B2 BB         call movement_linebelowisempty       ; check space is empty
323+  BCB4 7B               ld a,e                          ; check space empty flag
324+  BCB5 FE 00            cp 0
325+  BCB7 CA C0 BC         jp z, movement_checkcanmove_down1 ; can't move
326+  BCBA CD 8F BF         call player_justmoved
327+  BCBD C1               pop bc
328+  BCBE F1               pop af
329+  BCBF C9               ret
330+  BCC0              movement_checkcanmove_down1:
331+  BCC0 C1               pop bc
332+  BCC1 CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
333+  BCC4 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
334+  BCC6 24               inc h
335+  BCC7 C5               push bc
336+  BCC8 CD 1E BC         call movement_spacebelowisdiggable    ; can't move here, but can we dig
337+  BCCB 11 00 00         ld de,0
338+  BCCE C1               pop bc
339+  BCCF F1               pop af
340+  BCD0 C9               ret
341+  BCD1
342+  BCD1              ;
343+  BCD1              ; Checks if the player can move up
344+  BCD1              ; Inputs:
345+  BCD1              ; bc - player coords, b horiz, c vert
346+  BCD1              ; Outputs:
347+  BCD1              ; de - 1 can move
348+  BCD1              movement_checkcanmove_up:
349+  BCD1 F5               push af
350+  BCD2 C5               push bc
351+  BCD3 CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
352+  BCD6 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
353+  BCD8 11 20 00         ld de,32
354+  BCDB ED 52            sbc hl,de                       ; memory location of line above now in hl
355+  BCDD 0D               dec c                           ; look above
356+  BCDE CD CD BB         call movement_lineaboveisempty       ; check space is empty
357+  BCE1 7B               ld a,e                          ; check space empty flag
358+  BCE2 FE 00            cp 0
359+  BCE4 CA EF BC         jp z, movement_checkcanmove_up1 ; can't move
360+  BCE7 1E 01            ld e,1
361+  BCE9 CD 8F BF         call player_justmoved
362+  BCEC C1               pop bc
363+  BCED F1               pop af
364+  BCEE C9               ret
365+  BCEF              movement_checkcanmove_up1:
366+  BCEF C1               pop bc
367+  BCF0 CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
368+  BCF3 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
369+  BCF5 11 20 00         ld de,32
370+  BCF8 ED 52            sbc hl,de                       ; memory location of line above now in hl
371+  BCFA C5               push bc
372+  BCFB CD 61 BC         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
373+  BCFE 11 00 00         ld de,0
374+  BD01 C1               pop bc
375+  BD02 F1               pop af
376+  BD03 C9               ret
377+  BD04
378+  BD04              ;
379+  BD04              ; Checks if the player can move right
380+  BD04              ; Inputs:
381+  BD04              ; bc - player coords, b horiz, c vert
382+  BD04              ; Outputs:
383+  BD04              ; de - 1 can move
384+  BD04              movement_checkcanmove_right:
385+  BD04 F5               push af
386+  BD05 C5               push bc
387+  BD06 CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
388+  BD09 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
389+  BD0B 3E 08            ld a,8
390+  BD0D 80               add b                           ; move one cell right
391+  BD0E 47               ld b,a
392+  BD0F 23               inc hl                          ; memory location of cell to the right now in hl
393+  BD10 CD 38 BB         call movement_spaceisempty       ; check space is empty
394+  BD13 7B               ld a,e                          ; check space empty flag
395+  BD14 FE 00            cp 0
396+  BD16 CA 1F BD         jp z, movement_checkcanmove_right1 ; can't move
397+  BD19 CD 8F BF         call player_justmoved
398+  BD1C C1               pop bc
399+  BD1D F1               pop af
400+  BD1E C9               ret
401+  BD1F              movement_checkcanmove_right1:
402+  BD1F C1               pop bc
403+  BD20 CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
404+  BD23 62 6B            ld hl,de
405+  BD25 23               inc hl                          ; memory location of cell to the right now in hl
406+  BD26 C5               push bc
407+  BD27 CD E8 BB         call movement_spaceisdiggable    ; can't move here, but can we dig
408+  BD2A 11 00 00         ld de,0
409+  BD2D C1               pop bc
410+  BD2E F1               pop af
411+  BD2F C9               ret
412+  BD30
413+  BD30              ;
414+  BD30              ; Checks if the player can move left
415+  BD30              ; Inputs:
416+  BD30              ; bc - player coords, b horiz, c vert
417+  BD30              ; Outputs:
418+  BD30              ; de - 1 can move
419+  BD30              movement_checkcanmove_left:
420+  BD30 F5               push af
421+  BD31 C5               push bc
422+  BD32 CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
423+  BD35 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
424+  BD37 78               ld a,b
425+  BD38 06 08            ld b,8
426+  BD3A 90               sub b                           ; move one cell left
427+  BD3B 47               ld b,a
428+  BD3C 2B               dec hl                          ; memory location of cell to the right now in hl
429+  BD3D CD 38 BB         call movement_spaceisempty       ; check space is empty
430+  BD40 7B               ld a,e                          ; check space empty flag
431+  BD41 FE 00            cp 0
432+  BD43 CA 4C BD         jp z, movement_checkcanmove_left1 ; can't move
433+  BD46 CD 8F BF         call player_justmoved
434+  BD49 C1               pop bc
435+  BD4A F1               pop af
436+  BD4B C9               ret
437+  BD4C              movement_checkcanmove_left1:
438+  BD4C C1               pop bc
439+  BD4D CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
440+  BD50 62 6B            ld hl,de
441+  BD52 2B               dec hl                          ; memory location of cell to the right now in hl
442+  BD53 C5               push bc
443+  BD54 CD E8 BB         call movement_spaceisdiggable    ; can't move here, but can we dig
444+  BD57 11 00 00         ld de,0
445+  BD5A C1               pop bc
446+  BD5B F1               pop af
447+  BD5C C9               ret
# file closed: game/movement.asm
 39   BD5D                  include "game\game.asm"
# file opened: game/game.asm
  1+  BD5D              ;
  2+  BD5D              ; The current frame count, incremented each frame
  3+  BD5D              ;
  4+  BD5D              game_framenumber:
  5+  BD5D 00               defb    0
  6+  BD5E
  7+  BD5E              ;
  8+  BD5E              ; The number of players
  9+  BD5E              ;
 10+  BD5E              game_numberplayers:
 11+  BD5E 01               defb 1
 12+  BD5F
 13+  BD5F              ;
 14+  BD5F              ; The current player
 15+  BD5F              ;
 16+  BD5F              game_currentplayer:
 17+  BD5F 01               defb 1
 18+  BD60
 19+  BD60              ;
 20+  BD60              ; The default number of lives
 21+  BD60              ;
 22+  BD60              game_numberlives:
 23+  BD60 04               defb 4
 24+  BD61
 25+  BD61              ;
 26+  BD61              ; The current difficulty
 27+  BD61              ;
 28+  BD61              game_difficulty:
 29+  BD61 00               defb 0
 30+  BD62
 31+  BD62              ;
 32+  BD62              ; Control method: 0 for keyboard, 1 for kempston
 33+  BD62              ;
 34+  BD62              game_control:
 35+  BD62 00               defb 0
 36+  BD63
 37+  BD63              ;
 38+  BD63              ; Moves to the next player
 39+  BD63              ;
 40+  BD63              game_changeplayer:
 41+  BD63 3A 5F BD         ld a,(game_currentplayer)
 42+  BD66 FE 01            cp 1
 43+  BD68 C8               ret z                       ; if just one player, no need to change
 44+  BD69 3D               dec a                       ; otherwise decrease by one
 45+  BD6A EE 01            xor 1                       ; xor with one to flip
 46+  BD6C 3C               inc a                       ; increment
 47+  BD6D 21 5F BD         ld hl,game_currentplayer
 48+  BD70 77               ld (hl),a                   ; store
 49+  BD71 C9               ret
 50+  BD72
 51+  BD72              ;
 52+  BD72              ; Sets the number of players at the start of the game
 53+  BD72              ; Inputs:
 54+  BD72              ; a - number of players
 55+  BD72              game_setnumberofplayers:
 56+  BD72 21 5E BD         ld hl,game_numberplayers
 57+  BD75 77               ld (hl),a
 58+  BD76
 59+  BD76              ;
 60+  BD76              ; Increment frame number by 1
 61+  BD76              ;
 62+  BD76              game_incrementframe:
 63+  BD76 3A 5D BD         ld a,(game_framenumber)
 64+  BD79 FE FF            cp 255
 65+  BD7B C2 80 BD         jp nz,game_incrementframe0
 66+  BD7E 3E 00            ld a,0
 67+  BD80              game_incrementframe0:
 68+  BD80 3C               inc a
 69+  BD81 32 5D BD         ld (game_framenumber),a
 70+  BD84 C9               ret
 71+  BD85
 72+  BD85              ;
 73+  BD85              ; Returns current frame
 74+  BD85              ; Outputs:
 75+  BD85              ; a - current frame
 76+  BD85              ;
 77+  BD85              game_getcurrentframe:
 78+  BD85 3A 5D BD         ld a,(game_framenumber)
 79+  BD88 C9               ret
 80+  BD89
 81+  BD89              ;
 82+  BD89              ; Resets current frame
 83+  BD89              ;
 84+  BD89              game_resetcurrentframe:
 85+  BD89 21 5D BD         ld hl,game_framenumber
 86+  BD8C 36 00            ld (hl),0
 87+  BD8E C9               ret
 88+  BD8F
 89+  BD8F              ;
 90+  BD8F              ; Increases the current difficulty
 91+  BD8F              ;
 92+  BD8F              game_increasedifficulty:
 93+  BD8F 3A 61 BD         ld a,(game_difficulty)
 94+  BD92 3C               inc a
 95+  BD93 32 61 BD         ld (game_difficulty),a
# file closed: game/game.asm
 40   BD96                  include "game\player.asm"
# file opened: game/player.asm
  1+  BD96              ;
  2+  BD96              ;   Data for current player
  3+  BD96              ;
  4+  BD96              player:
  5+  BD96 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  BD98 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  BD9B 00               defb    0                   ; auto move remaining (+5)
  8+  BD9C 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  BD9F 00               defb    0                   ; lives remaining (+9)
 10+  BDA0 00               defb    0                   ; died this life (+10)
 11+  BDA1 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  BDA3 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  BDA4 00               defb    0                   ; difficulty (+14)
 14+  BDA5
 15+  BDA5              player_location:
 16+  BDA5 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 17+  BDA6
 18+  BDA6              ;
 19+  BDA6              ; Works out which part of the screen the player is in
 20+  BDA6              ; Pit is between 3,9 and 8,9
 21+  BDA6              ; Diamond cavern is between 11,22 and 22,28
 22+  BDA6              ;
 23+  BDA6              player_getlocation:
 24+  BDA6 ED 4B 96 BD      ld bc,(player)              ; get screen coords
 25+  BDAA CD 5A A9         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 26+  BDAD 78               ld a,b                      ; check for pit first
 27+  BDAE FE 09            cp 9                        ; if not on this row, not in the pit
 28+  BDB0 C2 BF BD         jp nz,player_getlocation0
 29+  BDB3 79               ld a,c                      ; check horizontal
 30+  BDB4 FE 09            cp 9
 31+  BDB6 D2 BF BD         jp nc, player_getlocation0  ; if more than 9, not in the pit
 32+  BDB9 21 A5 BD         ld hl,player_location
 33+  BDBC 36 02            ld (hl),2                   ; load location with 2, the pit
 34+  BDBE C9               ret                         ; done
 35+  BDBF              player_getlocation0:            ; check for diamond cavern
 36+  BDBF 78               ld a,b                      ; first check vertical
 37+  BDC0 FE 16            cp 22                       ; if above row 22, then not in cavern
 38+  BDC2 DA D6 BD         jp c,player_getlocation1
 39+  BDC5 79               ld a,c                      ; get the horizontal next
 40+  BDC6 FE 0B            cp 11
 41+  BDC8 DA D6 BD         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 42+  BDCB FE 16            cp 22
 43+  BDCD D2 D6 BD         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 44+  BDD0 21 A5 BD         ld hl,player_location
 45+  BDD3 36 01            ld (hl),1                   ; load location with 1, the cavern
 46+  BDD5 C9               ret
 47+  BDD6              player_getlocation1:
 48+  BDD6 21 A5 BD         ld hl,player_location
 49+  BDD9 36 00            ld (hl),0                   ; load location with 2, the pit
 50+  BDDB C9               ret                         ; done
 51+  BDDC
 52+  BDDC
 53+  BDDC              ;
 54+  BDDC              ; Initializes a player at start of game
 55+  BDDC              ; Copy initial coords, copy lives, copy score
 56+  BDDC              ;
 57+  BDDC              player_init_gamestart:
 58+  BDDC 3A 60 BD         ld a,(game_numberlives)
 59+  BDDF 32 8B BE         ld (player1_lives),a
 60+  BDE2 32 8C BE         ld (player2_lives),a                        ; set the initial number of lives at game start
 61+  BDE5
 62+  BDE5 21 8F BE         ld hl,player1_score+2
 63+  BDE8 06 06            ld b,6
 64+  BDEA              player_init_gamestart0:
 65+  BDEA 36 30            ld (hl),48
 66+  BDEC 23               inc hl
 67+  BDED 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 68+  BDEF 21 98 BE         ld hl,player2_score+2
 69+  BDF2 06 06            ld b,6
 70+  BDF4              player_init_gamestart1:
 71+  BDF4 36 30            ld (hl),48
 72+  BDF6 23               inc hl
 73+  BDF7 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 74+  BDF9 3E 00            ld a,0
 75+  BDFB 32 9F BE         ld (player1_difficulty),a
 76+  BDFE 32 A0 BE         ld (player2_difficulty),a                   ; set player difficulties to zero
 77+  BE01 C9               ret
 78+  BE02
 79+  BE02              ;
 80+  BE02              ; Initializes a player at start of a life
 81+  BE02              ; Copy initial coords, copy lives, copy score
 82+  BE02              ;
 83+  BE02              player_init_lifestart:
 84+  BE02 21 9B BD         ld hl,player+5
 85+  BE05 06 09            ld b,9                      ; initialise 9 properties
 86+  BE07              player_init_lifestart2:
 87+  BE07 36 00            ld (hl),0
 88+  BE09 23               inc hl
 89+  BE0A 10 FB            djnz player_init_lifestart2
 90+  BE0C
 91+  BE0C 21 98 BD         ld hl,player+2              ; initialise some properties
 92+  BE0F 36 02            ld (hl),2
 93+  BE11 23               inc hl
 94+  BE12 36 00            ld (hl),0
 95+  BE14 23               inc hl
 96+  BE15 36 01            ld (hl),1
 97+  BE17
 98+  BE17 ED 4B 22 80      ld bc,(init_coord)
 99+  BE1B ED 43 96 BD      ld (player),bc
100+  BE1F 01 9F BD         ld bc,player+9
101+  BE22 3A 8B BE         ld a,(player1_lives)
102+  BE25 02               ld (bc),a
103+  BE26
104+  BE26 CD A2 C6         call diamonds_init      ; initialise gems
105+  BE29
106+  BE29 01 06 00         ld bc,6
107+  BE2C 11 65 C4         ld de,scores_current+2
108+  BE2F 3A 5F BD         ld a,(game_currentplayer)
109+  BE32 FE 01            cp 1
110+  BE34 C2 43 BE         jp nz,player_init_lifestart0
111+  BE37 3A 9F BE         ld a,(player1_difficulty)       ; initialise player 1 difficulty
112+  BE3A 32 61 BD         ld (game_difficulty),a
113+  BE3D 21 8F BE         ld hl,player1_score+2           ; itialise player 1 scores
114+  BE40 C3 4C BE         jp player_init_lifestart1
115+  BE43              player_init_lifestart0:
116+  BE43 3A A0 BE         ld a,(player2_difficulty)       ; initialise player 2 difficulty
117+  BE46 32 61 BD         ld (game_difficulty),a
118+  BE49 21 98 BE         ld hl,player2_score+2           ; initialise player 2 scores
119+  BE4C              player_init_lifestart1:
120+  BE4C ED B0            ldir
121+  BE4E C9               ret
122+  BE4F
123+  BE4F              ;
124+  BE4F              ; Finalises a player at end of a life
125+  BE4F              ; Copy lives, copy score
126+  BE4F              ;
127+  BE4F              player_lifeend:
128+  BE4F 01 9F BD         ld bc,player+9
129+  BE52 0A               ld a,(bc)
130+  BE53 01 8B BE         ld bc,player1_lives
131+  BE56 02               ld (bc),a
132+  BE57 CD 5B BE         call player_recordcurrentstate
133+  BE5A C9               ret
134+  BE5B
135+  BE5B              ;
136+  BE5B              ; Copies the current score and difficulty in the current player
137+  BE5B              ;
138+  BE5B              player_recordcurrentstate:
139+  BE5B 01 06 00         ld bc,6                  ; copy current score back to correct player
140+  BE5E 21 65 C4         ld hl,scores_current+2
141+  BE61 3A 5F BD         ld a,(game_currentplayer)
142+  BE64 FE 01            cp 1
143+  BE66 C2 75 BE         jp nz,player_recordcurrentstate0
144+  BE69 3A 61 BD         ld a,(game_difficulty)
145+  BE6C 32 9F BE         ld (player1_difficulty),a       ; store difficulty
146+  BE6F 11 8F BE         ld de,player1_score+2
147+  BE72 C3 7E BE         jp player_recordcurrentstate1
148+  BE75              player_recordcurrentstate0:         ; do player 2
149+  BE75 3A 61 BD         ld a,(game_difficulty)
150+  BE78 32 A0 BE         ld (player2_difficulty),a       ; store difficulty
151+  BE7B 11 98 BE         ld de,player2_score+2
152+  BE7E              player_recordcurrentstate1:
153+  BE7E ED B0            ldir
154+  BE80 C9               ret
155+  BE81
156+  BE81              ;
157+  BE81              ; Player just died, subtract a life
158+  BE81              ;
159+  BE81              player_died:
160+  BE81 01 9F BD         ld bc,player+9
161+  BE84 0A               ld a,(bc)
162+  BE85 3D               dec a
163+  BE86 02               ld (bc),a
164+  BE87 CD 4F BE         call player_lifeend
165+  BE8A C9               ret
166+  BE8B
167+  BE8B              ;
168+  BE8B              ; Player lives
169+  BE8B              ;
170+  BE8B              player1_lives:
171+  BE8B 03               defb 3
172+  BE8C              player2_lives:
173+  BE8C 03               defb 3
174+  BE8D
175+  BE8D              ;
176+  BE8D              ; Player scores
177+  BE8D              ;
178+  BE8D              player1_score:
179+  BE8D 04 01 30 30      defb 4,1,'000000',255
179+  BE91 30 30 30 30
179+  BE95 FF
180+  BE96              player2_score:
181+  BE96 16 01 30 30      defb 22,1,'000000',255
181+  BE9A 30 30 30 30
181+  BE9E FF
182+  BE9F
183+  BE9F              ;
184+  BE9F              ; Player difficulties
185+  BE9F              ;
186+  BE9F              player1_difficulty:
187+  BE9F 00               defb 0
188+  BEA0              player2_difficulty:
189+  BEA0 00               defb 0
190+  BEA1
191+  BEA1              ;
192+  BEA1              ; Kills a player this life
193+  BEA1              ;
194+  BEA1              player_killplayer:
195+  BEA1 21 A0 BD         ld hl,player+10
196+  BEA4 36 01            ld (hl),1
197+  BEA6 C9               ret
198+  BEA7
199+  BEA7              ;
200+  BEA7              ; Crush a player this life
201+  BEA7              ;
202+  BEA7              player_crushplayer:
203+  BEA7 21 A1 BD         ld hl,player+11             ; mark as crushed
204+  BEAA 36 01            ld (hl),1
205+  BEAC C9               ret
206+  BEAD
207+  BEAD              player_tankkillplayer
208+  BEAD 21 A1 BD         ld hl,player+11             ; mark as tanked
209+  BEB0 36 02            ld (hl),2
210+  BEB2 C9               ret
211+  BEB3
212+  BEB3              player_zonkplayer
213+  BEB3 21 A1 BD         ld hl,player+11             ; mark as zonked (missile)
214+  BEB6 36 03            ld (hl),3
215+  BEB8 C9               ret
216+  BEB9
217+  BEB9              player_pitkillplayer
218+  BEB9 21 A1 BD         ld hl,player+11             ; mark as pit killed
219+  BEBC 36 04            ld (hl),4
220+  BEBE C9               ret
221+  BEBF
222+  BEBF              player_robotkillplayer
223+  BEBF 21 A1 BD         ld hl,player+11             ; mark as robot killed
224+  BEC2 36 05            ld (hl),5
225+  BEC4 C9               ret
226+  BEC5
227+  BEC5              ;
228+  BEC5              ; Draws the player at the current position or deletes them
229+  BEC5              ;
230+  BEC5              player_drawplayer:
231+  BEC5 3A 98 BD         ld a,(player+2)             ; get the current direction
232+  BEC8 FE 03            cp 3
233+  BECA C2 CF BE         jp nz,player_drawplayer0
234+  BECD 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
235+  BECF              player_drawplayer0:             ; DYING CHECKS
236+  BECF 5F               ld e,a                      ; store in e
237+  BED0 3A A1 BD         ld a,(player+11)             ; get the dying flag
238+  BED3 FE 01            cp 1
239+  BED5 CA 0F BF         jp z,player_drawplayer3     ; if it's one, we're being crushed
240+  BED8 FE 04            cp 4
241+  BEDA CA 57 BF         jp z,player_drawplayer9     ; player is falling into the pit
242+  BEDD FE 05            cp 5
243+  BEDF CA 73 BF         jp z,player_drawplayer12    ; player has been killed by a robot
244+  BEE2              player_drawplayer4:             ; CHECK FOR DIGGING
245+  BEE2 3A 9C BD         ld a,(player+6)             ; get the dig flag
246+  BEE5 FE 01            cp 1
247+  BEE7 CA F8 BE         jp z,player_drawplayer1    ; get dig frame
248+  BEEA 3A 99 BD         ld a,(player+3)             ; this is normal movement so get the current frame
249+  BEED 83               add a,e
250+  BEEE C3 FD BE         jp player_drawplayer2
251+  BEF1              player_drawplayer6:             ; GETTING THE DIG FRAM
252+  BEF1 E6 01            and 1                       ; check for odd
253+  BEF3 C6 0A            add 10                      ; add 10, to get either 10 or 11
254+  BEF5 C3 FD BE         jp player_drawplayer2
255+  BEF8              player_drawplayer1:             ; GET THE NORMAL FRAME
256+  BEF8 3A 98 BD         ld a,(player+2)             ; digging, get the current direction again, because want all four
257+  BEFB C6 06            add a,6                     ; add direction to 6 to get frame
258+  BEFD              player_drawplayer2:             ; WORK OUT THE FRAME
259+  BEFD 07               rlca
260+  BEFE 07               rlca
261+  BEFF 07               rlca                        ; multiply by eight
262+  BF00 6F               ld l,a
263+  BF01 26 00            ld h,0
264+  BF03 11 B2 B6         ld de,player_sprite
265+  BF06 19               add hl,de                   ; load hl with the location of the player sprite data
266+  BF07              player_drawplayer7:             ; DRAW THE PlAYER
267+  BF07 ED 4B 96 BD      ld bc,(player)              ; load bc with the start coords
268+  BF0B CD 2C AA         call sprites_drawsprite     ; call the routine to draw the sprite
269+  BF0E                  ;call player_storeupdatedlines ; log updated rows
270+  BF0E C9               ret
271+  BF0F              ;
272+  BF0F              ; CRUSHING
273+  BF0F              ;
274+  BF0F              player_drawplayer3:
275+  BF0F 21 A2 BD         ld hl,player+12
276+  BF12 7E               ld a,(hl)                  ; crushing, so get the current anim flag
277+  BF13 FE 00            cp 0
278+  BF15 C2 1E BF         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
279+  BF18 3E 64            ld a,100
280+  BF1A 77               ld (hl),a                   ; otherwise, load up the anim frames
281+  BF1B C3 E2 BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
282+  BF1E              player_drawplayer5:
283+  BF1E 3D               dec a
284+  BF1F 77               ld (hl),a
285+  BF20 FE 00            cp 0
286+  BF22 CC A1 BE         call z,player_killplayer     ; final animation, so kill the player
287+  BF25 FE 0A            cp 10                         ; play the sound
288+  BF27 CC E7 AF         call z, sound_rockfell
289+  BF2A FE 14            cp 20                        ; check if we should move the rock
290+  BF2C C2 40 BF         jp nz,player_drawplayer8
291+  BF2F D9               exx
292+  BF30 F5               push af
293+  BF31 ED 4B 03 C3      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
294+  BF35 21 FE B5         ld hl,sprites+72
295+  BF38 CD 2C AA         call sprites_drawsprite     ; draw a rock over current
296+  BF3B F1               pop af
297+  BF3C D9               exx
298+  BF3D C3 F1 BE         jp player_drawplayer6       ; continue drawing player
299+  BF40              player_drawplayer8:
300+  BF40 FE 14            cp 20
301+  BF42 D2 F1 BE         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
302+  BF45 ED 4B 96 BD      ld bc,(player)
303+  BF49 CD 5A A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
304+  BF4C 3E 42            ld a,66             ; load red
305+  BF4E CD B2 A9         call screen_setattr
306+  BF51 21 FE B5         ld hl,sprites+72            ; otherwise, player is rock
307+  BF54 C3 07 BF         jp player_drawplayer7
308+  BF57              ;
309+  BF57              ; FALLING
310+  BF57              ;
311+  BF57              player_drawplayer9:             ; player is falling into the pit
312+  BF57 21 A2 BD         ld hl,player+12
313+  BF5A 7E               ld a,(hl)                   ; get the frames
314+  BF5B FE 00            cp 0
315+  BF5D C2 66 BF         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
316+  BF60 3E 50            ld a,80
317+  BF62 77               ld (hl),a                   ; otherwise, load up the anim frames
318+  BF63 C3 E2 BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
319+  BF66              player_drawplayer10:
320+  BF66 3D               dec a
321+  BF67 77               ld (hl),a
322+  BF68 FE 00            cp 0
323+  BF6A CC A1 BE         call z,player_killplayer     ; final frame, so kill the player
324+  BF6D 3A 99 BD         ld a,(player+3)
325+  BF70 C3 FD BE         jp player_drawplayer2
326+  BF73              ;
327+  BF73              ; ROBOT KILLED
328+  BF73              ;
329+  BF73              player_drawplayer12:
330+  BF73 21 A2 BD         ld hl,player+12
331+  BF76 7E               ld a,(hl)                   ; get the frames
332+  BF77 FE 00            cp 0
333+  BF79 C2 82 BF         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
334+  BF7C 3E C8            ld a,200
335+  BF7E 77               ld (hl),a                   ; otherwise, load up the anim frames
336+  BF7F C3 E2 BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
337+  BF82              player_drawplayer13:
338+  BF82 3D               dec a
339+  BF83 77               ld (hl),a
340+  BF84 FE 00            cp 0
341+  BF86 CC A1 BE         call z,player_killplayer     ; final frame, so kill the player
342+  BF89 3A 99 BD         ld a,(player+3)
343+  BF8C C3 FD BE         jp player_drawplayer2
344+  BF8F
345+  BF8F              ;
346+  BF8F              ; Runs after the player just moved. Changes animation frame if required
347+  BF8F              ;
348+  BF8F              player_justmoved:
349+  BF8F D9               exx
350+  BF90 3A 9A BD         ld a,(player+4)             ; get the transition count
351+  BF93 FE 00            cp 0
352+  BF95 CA 9B BF         jp z, player_justmoved2     ; if zero reset and change the frame
353+  BF98 C3 B5 BF         jp player_justmoved1       ; otherwise decrease and continue
354+  BF9B              player_justmoved2:
355+  BF9B                  ; reset and change frame in here
356+  BF9B 3E 01            ld a,1
357+  BF9D 32 9A BD         ld (player+4),a            ; reset back to whatever
358+  BFA0 3A 99 BD         ld a,(player+3)             ; load the frame
359+  BFA3 FE 03            cp 3                       ; flip between 3 and 0
360+  BFA5 C2 AD BF         jp nz, player_justmoved4
361+  BFA8 3E 00            ld a,0
362+  BFAA C3 AF BF         jp player_justmoved5
363+  BFAD              player_justmoved4:
364+  BFAD 3E 03            ld a,3
365+  BFAF              player_justmoved5:
366+  BFAF 32 99 BD         ld (player+3),a           ; save back
367+  BFB2 C3 B9 BF         jp player_justmoved3
368+  BFB5              player_justmoved1:
369+  BFB5                  ; decrease count
370+  BFB5 3D               dec a
371+  BFB6 32 9A BD         ld (player+4),a
372+  BFB9              player_justmoved3:
373+  BFB9 D9               exx;
374+  BFBA C9               ret
375+  BFBB
376+  BFBB              ;
377+  BFBB              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
378+  BFBB              ; Outputs:
379+  BFBB              ; a - 1 for completed level
380+  BFBB              player_checkforexit:
381+  BFBB ED 4B 96 BD      ld bc,(player)                 ; get player coords
382+  BFBF ED 5B 22 80      ld de,(init_coord)             ; get start coords
383+  BFC3 78               ld a,b
384+  BFC4 BA               cp d                         ; compare horiz
385+  BFC5 C2 D0 BF         jp nz,player_checkforexit1
386+  BFC8 79               ld a,c
387+  BFC9 BB               cp e                        ; compare vert
388+  BFCA C2 D0 BF         jp nz,player_checkforexit1
389+  BFCD              player_checkforexit0:
390+  BFCD 3E 01            ld a,1                       ; hasn't completed
391+  BFCF C9               ret
392+  BFD0              player_checkforexit1:
393+  BFD0 3E 00            ld a,0                       ; has completed
394+  BFD2 C9               ret
# file closed: game/player.asm
 41   BFD3                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  BFD3              ;
  2+  BFD3              ; Ship initial position: vert,horiz
  3+  BFD3              ;
  4+  BFD3              ship_initpos:
  5+  BFD3 00 24            defb 0,36
  6+  BFD5              ship_initpos2:
  7+  BFD5 00 00            defb 0,0
  8+  BFD7              ship_frame:
  9+  BFD7 00               defb 0
 10+  BFD8              ;
 11+  BFD8              ; The current memory location
 12+  BFD8              ;
 13+  BFD8              ship_current_sprite:
 14+  BFD8 00 00            defb 0,0
 15+  BFDA
 16+  BFDA              ship_current_coords:
 17+  BFDA 00 00            defb 0,0
 18+  BFDC
 19+  BFDC              ship_process:
 20+  BFDC 3A A1 BD         ld a,(player+11)
 21+  BFDF FE 02            cp 2                        ; has the player been killed by tank?
 22+  BFE1 C0               ret nz                      ; do nothing if not
 23+  BFE2 CD 2A BB         call control_scroll_up           ; make sure the screen is on the top screen
 24+  BFE5 CD 54 C0         call ship_takeoff           ; bye bye
 25+  BFE8 CD A1 BE         call player_killplayer      ; killed
 26+  BFEB 06 32            ld b,50
 27+  BFED CD 9B 80         call utilities_pauseforframes
 28+  BFF0 C9               ret
 29+  BFF1
 30+  BFF1              ;
 31+  BFF1              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  BFF1              ;
 33+  BFF1              ship_land:
 34+  BFF1 ED 4B D3 BF      ld bc,(ship_initpos)
 35+  BFF5 ED 43 D5 BF      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  BFF9 1E 00            ld e,0                      ; store a flag to track first time round
 37+  BFFB 06 09            ld b,9                      ; move down 8 pixels
 38+  BFFD              ship_land0:
 39+  BFFD C5               push bc
 40+  BFFE 7B               ld a,e
 41+  BFFF D5               push de                     ; store de for next time round
 42+  C000 FE 01            cp 1                        ; check first time flag
 43+  C002 C2 17 C0         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  C005 CD 9C C0         call ship_draw_full         ; delete old one
 45+  C008 CD 80 C0         call ship_change_frame      ; increment the frame
 46+  C00B ED 4B D5 BF      ld bc,(ship_initpos2)       ; get the current coords
 47+  C00F 81 C6 01         add c,1                     ; move down one pixels
 48+  C012 4F               ld c,a
 49+  C013 ED 43 D5 BF      ld (ship_initpos2),bc
 50+  C017              ship_land1:
 51+  C017 CD 9C C0         call ship_draw_full         ; draw the ship
 52+  C01A CD 95 C0         call ship_draw_screen
 53+  C01D D1               pop de
 54+  C01E 1E 01            ld e,1
 55+  C020 C1               pop bc
 56+  C021 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  C023                  ; done moving down
 58+  C023                  ; now move across
 59+  C023 CD C5 BE         call player_drawplayer      ; draw player
 60+  C026 CD 9C C0         call ship_draw_full         ; delete old one
 61+  C029 1E 00            ld e,0                      ; store a flag to track first time round
 62+  C02B 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  C02D              ship_land3:
 64+  C02D C5               push bc
 65+  C02E 7B               ld a,e
 66+  C02F D5               push de                     ; store de for next time round
 67+  C030 FE 01            cp 1                        ; check first time flag
 68+  C032 C2 47 C0         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  C035 CD 9C C0         call ship_draw_full         ; delete old one
 70+  C038 CD 80 C0         call ship_change_frame      ; increment the frame
 71+  C03B ED 4B D5 BF      ld bc,(ship_initpos2)       ; get the current coords
 72+  C03F 78               ld a,b
 73+  C040 D6 01            sub 1                       ; move back one pixels
 74+  C042 47               ld b,a
 75+  C043 ED 43 D5 BF      ld (ship_initpos2),bc
 76+  C047              ship_land2:
 77+  C047 CD 9C C0         call ship_draw_full         ; draw the ship
 78+  C04A CD 95 C0         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  C04D D1               pop de
 80+  C04E 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  C050 C1               pop bc
 82+  C051 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  C053 C9               ret
 84+  C054
 85+  C054              ;
 86+  C054              ;   Take off the ship
 87+  C054              ;
 88+  C054              ship_takeoff:
 89+  C054 1E 01            ld e,1                      ; store a flag to track first time round
 90+  C056 06 08            ld b,8                      ; move up 8 pixels
 91+  C058              ship_takeoff0:
 92+  C058 C5               push bc
 93+  C059 7B               ld a,e
 94+  C05A D5               push de                     ; store de for next time round
 95+  C05B FE 01            cp 1                        ; check first time flag
 96+  C05D C2 73 C0         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  C060 ED 4B D5 BF      ld bc,(ship_initpos2)       ; get the current coords
 98+  C064 CD 9C C0         call ship_draw_full         ; delete old one
 99+  C067 CD 80 C0         call ship_change_frame      ; increment the frame
100+  C06A ED 4B D5 BF      ld bc,(ship_initpos2)       ; get the current coords
101+  C06E 0D               dec c                       ; move up one pixels
102+  C06F ED 43 D5 BF      ld (ship_initpos2),bc
103+  C073              ship_takeoff1:
104+  C073 CD 9C C0         call ship_draw_full         ; draw the ship
105+  C076 CD 95 C0         call ship_draw_screen
106+  C079 D1               pop de
107+  C07A 1E 01            ld e,1
108+  C07C C1               pop bc
109+  C07D 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  C07F                  ; done moving up
111+  C07F C9               ret
112+  C080
113+  C080              ;
114+  C080              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  C080              ;
116+  C080              ship_change_frame:
117+  C080 F5               push af
118+  C081 3A D7 BF         ld a,(ship_frame)
119+  C084 FE 00            cp 0
120+  C086 CA 8E C0         jp z,ship_change_frame0
121+  C089 3E 00            ld a,0                      ; flip to 0
122+  C08B C3 90 C0         jp ship_change_frame1
123+  C08E              ship_change_frame0:
124+  C08E 3E 20            ld a,32                      ; flip to 32
125+  C090              ship_change_frame1:
126+  C090 32 D7 BF         ld (ship_frame),a            ; save the frame
127+  C093 F1               pop af
128+  C094 C9               ret
129+  C095
130+  C095              ship_draw_screen:
131+  C095 76               halt
132+  C096 F3               di
133+  C097 CD 31 A7         call buffer_buffertoscreen  ; copy buffer to screen
134+  C09A FB               ei                          ; enable interupts
135+  C09B C9               ret
136+  C09C
137+  C09C              ship_draw_full:
138+  C09C 21 22 B7         ld hl,ship_sprite
139+  C09F ED 4B D5 BF      ld bc,(ship_initpos2)         ; load bc with the start coords
140+  C0A3 22 D8 BF         ld (ship_current_sprite),hl  ; put into memory
141+  C0A6 ED 43 DA BF      ld (ship_current_coords),bc  ; put into memory
142+  C0AA CD C9 C0         call ship_draw
143+  C0AD 08               ex af,af'
144+  C0AE 3A D7 BF         ld a,(ship_frame)            ; get the animation frame
145+  C0B1 16 00            ld d,0
146+  C0B3 5F               ld e,a
147+  C0B4 19               add hl,de
148+  C0B5 22 D8 BF         ld (ship_current_sprite),hl  ; put into memory
149+  C0B8 08               ex af,af'
150+  C0B9 ED 4B D5 BF      ld bc,(ship_initpos2)         ; load bc with the start coords
151+  C0BD 81 C6 08         add c,8                      ; move one line down
152+  C0C0 4F               ld c,a
153+  C0C1 ED 43 DA BF      ld (ship_current_coords),bc  ; put into memory
154+  C0C5 CD C9 C0         call ship_draw
155+  C0C8 C9               ret
156+  C0C9
157+  C0C9              ;
158+  C0C9              ; Draw the ship
159+  C0C9              ; Inputs:
160+  C0C9              ; None, all in memory
161+  C0C9              ;
162+  C0C9              ship_draw:
163+  C0C9 3E 04            ld a,4                              ; 4 pieces per half
164+  C0CB              ship_draw0:
165+  C0CB F5               push af
166+  C0CC 2A D8 BF         ld hl,(ship_current_sprite)
167+  C0CF ED 4B DA BF      ld bc,(ship_current_coords)         ; load bc with the start coords
168+  C0D3 CD 2C AA         call sprites_drawsprite
169+  C0D6 2A D8 BF         ld hl,(ship_current_sprite)
170+  C0D9 ED 4B DA BF      ld bc,(ship_current_coords)         ; load bc with the start coords
171+  C0DD 11 08 00         ld de,8
172+  C0E0 19               add hl,de
173+  C0E1 80 C6 08         add b,8
174+  C0E4 47               ld b,a
175+  C0E5 22 D8 BF         ld (ship_current_sprite),hl         ; put into memory
176+  C0E8 ED 43 DA BF      ld (ship_current_coords),bc         ; put into memory
177+  C0EC F1               pop af
178+  C0ED 3D               dec a
179+  C0EE FE 00            cp 0
180+  C0F0 C2 CB C0         jp nz,ship_draw0
181+  C0F3
182+  C0F3 C9               ret
183+  C0F4
# file closed: game/ship.asm
 42   C0F4                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  C0F4              ;
  2+  C0F4              ; tank initial position: vert,horiz
  3+  C0F4              ;
  4+  C0F4              tank_initpos:
  5+  C0F4 10 D0            defb 16,208
  6+  C0F6              tank_initpos2:
  7+  C0F6 00 00            defb 0,0
  8+  C0F8              tank_frame:
  9+  C0F8 00               defb 0
 10+  C0F9              tank_anim:
 11+  C0F9 11               defb 17
 12+  C0FA
 13+  C0FA              ;
 14+  C0FA              ; The damage countdown
 15+  C0FA              ;
 16+  C0FA              tank_currentdamage:
 17+  C0FA F0               defb 240
 18+  C0FB
 19+  C0FB              ;
 20+  C0FB              ; The damage coordinate
 21+  C0FB              ;
 22+  C0FB              tank_currentdamagecoord:
 23+  C0FB 16 02            defb 22,2
 24+  C0FD
 25+  C0FD              ;
 26+  C0FD              ; Controls when the tank shoots
 27+  C0FD              ;
 28+  C0FD              tank_count:
 29+  C0FD 00               defb 0
 30+  C0FE
 31+  C0FE              ;
 32+  C0FE              ; Holds the block number of the current damage sprite
 33+  C0FE              ;
 34+  C0FE              tank_damageframe:
 35+  C0FE 00               defb 0
 36+  C0FF
 37+  C0FF              ;
 38+  C0FF              ; The current memory location
 39+  C0FF              ;
 40+  C0FF              tank_current_sprite:
 41+  C0FF 00 00            defb 0,0
 42+  C101
 43+  C101              tank_current_coords:
 44+  C101 00 00            defb 0,0
 45+  C103
 46+  C103              ;
 47+  C103              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  C103              ;
 49+  C103              tank_missile_displayed:
 50+  C103 00               defb 0
 51+  C104
 52+  C104              ;
 53+  C104              ; Initialise the tank
 54+  C104              ;
 55+  C104              tank_init:
 56+  C104 ED 4B F4 C0      ld bc,(tank_initpos)
 57+  C108 ED 43 F6 C0      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  C10C 21 F8 C0         ld hl,tank_frame
 59+  C10F 36 00            ld (hl),0
 60+  C111 21 F9 C0         ld hl,tank_anim
 61+  C114 36 11            ld (hl),17
 62+  C116 21 FE C0         ld hl,tank_damageframe              ; reset tank
 63+  C119 36 00            ld (hl),0
 64+  C11B 21 FD C0         ld hl,tank_count
 65+  C11E 36 00            ld (hl),0
 66+  C120 21 FA C0         ld hl,tank_currentdamage
 67+  C123 36 F0            ld (hl),240
 68+  C125 21 FB C0         ld hl,tank_currentdamagecoord
 69+  C128 36 16            ld (hl),22
 70+  C12A 23               inc hl
 71+  C12B 36 02            ld (hl),2
 72+  C12D 21 03 C1         ld hl,tank_missile_displayed
 73+  C130 36 00            ld (hl),0
 74+  C132
 75+  C132 C9               ret
 76+  C133
 77+  C133              ;
 78+  C133              ;   Draw and move the tank
 79+  C133              ;   Start processing at frame 200
 80+  C133              ;   Don't move if anim is zero
 81+  C133              ;   Decrement frame if moved
 82+  C133              ;
 83+  C133              tank_process:
 84+  C133 3A F9 C0         ld a,(tank_anim)
 85+  C136 FE 00            cp 0
 86+  C138 C2 3F C1         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  C13B CD 50 C1         call tank_fire
 88+  C13E C9               ret
 89+  C13F              tank_process0:
 90+  C13F CD 85 BD         call game_getcurrentframe   ; get the current frame number into a
 91+  C142 FE 4B            cp 75
 92+  C144 D8               ret c                       ; return if the frame number is below 100
 93+  C145 CD 76 C2         call tank_move              ; move tank if not
 94+  C148 3A F9 C0         ld a,(tank_anim)
 95+  C14B 3D               dec a
 96+  C14C 32 F9 C0         ld (tank_anim),a            ; decrease the anim count
 97+  C14F C9               ret
 98+  C150
 99+  C150              ;
100+  C150              ; Fires the tank
101+  C150              ;
102+  C150              tank_fire:
103+  C150 3A FD C0         ld a,(tank_count)            ; if not, don't do anything
104+  C153 3C               inc a                        ; increment
105+  C154 FE 32            cp 50                        ; have we reached fifty
106+  C156 C2 5B C1         jp nz,tank_fire0
107+  C159 3E 00            ld a,0                       ; reset if reached fifty
108+  C15B              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  C15B 32 FD C0         ld (tank_count),a            ; store tank count
110+  C15E FE 00            cp 0
111+  C160 CA 81 C1         jp z,tank_fire7              ; If this is zero, fire
112+  C163 3A 03 C1         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  C166 FE 00            cp 0
114+  C168 C8               ret z                       ; don't do anything if not
115+  C169 CD 30 C2         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  C16C 3E 00            ld a,0                       ; reset the flag
117+  C16E 32 03 C1         ld (tank_missile_displayed),a
118+  C171 3E 02            ld a,2
119+  C173 ED 4B FB C0      ld bc,(tank_currentdamagecoord)
120+  C177 0C               inc c
121+  C178 0C               inc c
122+  C179 ED 43 43 AB      ld (origcoords),bc
123+  C17D CD 56 A6         call buffer_marklineforupdate
124+  C180 C9               ret                        ; only shoot if we're on 0
125+  C181              tank_fire7:
126+  C181 3A FA C0         ld a,(tank_currentdamage)    ; get the damage countdown
127+  C184 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
128+  C186 C2 BC C1         jp nz,tank_fire1            ; not, so just do a normal frame
129+  C189 ED 4B FB C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
130+  C18D 79               ld a,c
131+  C18E FE 0A            cp 10
132+  C190 C2 97 C1         jp nz, tank_fire6
133+  C193 CD 68 C2         call tank_killedbytank      ; we're through, so the player has died. Kill them.
134+  C196 C9               ret                         ; return if we're through the mountain
135+  C197              tank_fire6:
136+  C197 3E 0F            ld a,15
137+  C199 32 FE C0         ld (tank_damageframe),a     ; reset the damage frame
138+  C19C 21 B6 B5         ld hl,sprites               ; location of the empty block
139+  C19F CD 84 A9         call screen_showchar        ; show this character here
140+  C1A2 ED 4B FB C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
141+  C1A6 05               dec b                       ; look one above
142+  C1A7 CD E8 A9         call screen_ischarempty     ; check if it is empty
143+  C1AA ED 4B FB C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
144+  C1AE FE 01            cp 1
145+  C1B0 C2 F3 C1         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
146+  C1B3 ED 4B FB C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  C1B7 0D               dec c
148+  C1B8 ED 43 FB C0      ld (tank_currentdamagecoord),bc ; store the coord
149+  C1BC              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
150+  C1BC ED 4B FB C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
151+  C1C0 3A FA C0         ld a,(tank_currentdamage)    ; get the damage countdown
152+  C1C3 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
153+  C1C5 C2 D0 C1         jp nz, tank_fire5
154+  C1C8 CD 18 AA         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
155+  C1CB FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
156+  C1CD C2 11 C2         jp nz,tank_fire3            ; if it's a slope, handle this differently
157+  C1D0              tank_fire5:
158+  C1D0 3A FE C0         ld a,(tank_damageframe)
159+  C1D3 CD A7 A9         call screen_getblock        ; get the block data into hl
160+  C1D6 CD 84 A9         call screen_showchar        ; show this character here
161+  C1D9 3A FE C0         ld a,(tank_damageframe)
162+  C1DC 3C               inc a
163+  C1DD 32 FE C0         ld (tank_damageframe),a     ; increment the damage block and store
164+  C1E0 3A FA C0         ld a,(tank_currentdamage)    ; get the damage countdown
165+  C1E3 3D               dec a
166+  C1E4 3D               dec a
167+  C1E5 32 FA C0         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
168+  C1E8 3A 03 C1         ld a,(tank_missile_displayed) ; is the missile displaying?
169+  C1EB FE 00            cp 0
170+  C1ED CC 30 C2         call z, tank_missilegraphic
171+  C1F0 C3 1A C2         jp tank_fire4
172+  C1F3              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
173+  C1F3 05               dec b
174+  C1F4 C5               push bc
175+  C1F5 CD 01 AA         call screen_copyblockdown       ; copy the block down
176+  C1F8 ED 4B FB C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
177+  C1FC C1               pop bc                      ; get the coord we just checked back
178+  C1FD 78               ld a,b
179+  C1FE FE 00            cp 0
180+  C200 CA BC C1         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
181+  C203 C5               push bc
182+  C204 05               dec b
183+  C205 CD E8 A9         call screen_ischarempty     ; check if it is empty
184+  C208 C1               pop bc
185+  C209 FE 01            cp 1                        ; if empty
186+  C20B C2 F3 C1         jp nz, tank_fire2            ; copy another one down
187+  C20E C3 BC C1         jp tank_fire1               ; otherwise, return to main thread
188+  C211              tank_fire3:                      ; dealing with slopes
189+  C211 3A FA C0         ld a,(tank_currentdamage)    ; get the damage countdown
190+  C214 06 08            ld b,8
191+  C216 90               sub b                        ; special case for slopes
192+  C217 32 FA C0         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
193+  C21A              tank_fire4:                     ; TIDY UP
194+  C21A ED 4B FB C0      ld bc,(tank_currentdamagecoord)
195+  C21E ED 43 43 AB      ld (origcoords),bc
196+  C222 CD 56 A6         call buffer_marklineforupdate
197+  C225 3E 01            ld a,1
198+  C227 CD 56 A6         call buffer_marklineforupdate
199+  C22A 3E 02            ld a,2
200+  C22C CD 56 A6         call buffer_marklineforupdate
201+  C22F C9               ret
202+  C230
203+  C230              ;
204+  C230              ; Displays or hides the missile graphic, and changes the gun
205+  C230              ;
206+  C230              tank_missilegraphic:
207+  C230 3A 03 C1         ld a,(tank_missile_displayed)
208+  C233 FE 00            cp 0
209+  C235 C2 3D C2         jp nz,tank_missilegraphic0
210+  C238 3E 13            ld a,19
211+  C23A C3 3F C2         jp tank_missilegraphic1
212+  C23D              tank_missilegraphic0:
213+  C23D 3E 00            ld a,0
214+  C23F              tank_missilegraphic1:
215+  C23F 32 03 C1         ld (tank_missile_displayed),a ; store the flipped graphic
216+  C242 ED 4B FB C0      ld bc,(tank_currentdamagecoord)
217+  C246 0C               inc c
218+  C247 0C               inc c                   ; print the graphic 2 spaces right
219+  C248 CD A7 A9         call screen_getblock        ; get the block data into hl
220+  C24B CD 84 A9         call screen_showchar        ; show this character here
221+  C24E 06 02            ld b,2
222+  C250 0E 18            ld c,24                     ; set gunbarrel coords
223+  C252 11 00 00         ld de,0
224+  C255 21 82 B7         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
225+  C258 3A 03 C1         ld a,(tank_missile_displayed)
226+  C25B FE 00            cp 0
227+  C25D CA 63 C2         jp z,tank_missilegraphic2
228+  C260 11 40 00         ld de,64
229+  C263              tank_missilegraphic2:
230+  C263 19               add hl,de                   ; work out missile graphic
231+  C264 CD 84 A9         call screen_showchar        ; show this character here
232+  C267 C9               ret
233+  C268
234+  C268              ;
235+  C268              ; Deal with the player being killed by the tank
236+  C268              ;
237+  C268              tank_killedbytank:
238+  C268 ED 4B FB C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
239+  C26C 21 B6 B5         ld hl,sprites                   ; empty sprite
240+  C26F CD 84 A9         call screen_showchar            ; hide the last piece of dirt
241+  C272 CD AD BE         call player_tankkillplayer
242+  C275 C9               ret
243+  C276
244+  C276              tank_move:
245+  C276 ED 4B F6 C0      ld bc,(tank_initpos2)
246+  C27A C5               push bc
247+  C27B 3A F9 C0         ld a,(tank_anim)
248+  C27E FE 11            cp 17                       ; check first time flag
249+  C280 CA 92 C2         jp z,tank_move1             ; don't draw over previous one if first time
250+  C283 CD 97 C2         call tank_draw_full         ; delete old one
251+  C286 ED 4B F6 C0      ld bc,(tank_initpos2)       ; get the current coords
252+  C28A 78               ld a,b
253+  C28B D6 01            sub 1                       ; move back one pixels
254+  C28D 47               ld b,a
255+  C28E ED 43 F6 C0      ld (tank_initpos2),bc
256+  C292              tank_move1:
257+  C292 CD 97 C2         call tank_draw_full         ; draw the tank
258+  C295 C1               pop bc
259+  C296 C9               ret
260+  C297
261+  C297              tank_draw_full:
262+  C297 21 82 B7         ld hl,tank_sprite
263+  C29A ED 4B F6 C0      ld bc,(tank_initpos2)         ; load bc with the start coords
264+  C29E 22 FF C0         ld (tank_current_sprite),hl  ; put into memory
265+  C2A1 ED 43 01 C1      ld (tank_current_coords),bc  ; put into memory
266+  C2A5 CD C4 C2         call tank_draw
267+  C2A8 08               ex af,af'
268+  C2A9 3A F8 C0         ld a,(tank_frame)            ; get the animation frame
269+  C2AC 16 00            ld d,0
270+  C2AE 5F               ld e,a
271+  C2AF 19               add hl,de
272+  C2B0 22 FF C0         ld (tank_current_sprite),hl  ; put into memory
273+  C2B3 08               ex af,af'
274+  C2B4 ED 4B F6 C0      ld bc,(tank_initpos2)         ; load bc with the start coords
275+  C2B8 81 C6 08         add c,8                      ; move one line down
276+  C2BB 4F               ld c,a
277+  C2BC ED 43 01 C1      ld (tank_current_coords),bc  ; put into memory
278+  C2C0 CD C4 C2         call tank_draw
279+  C2C3 C9               ret
280+  C2C4
281+  C2C4              ;
282+  C2C4              ; Draw the tank
283+  C2C4              ; Inputs:
284+  C2C4              ; None, all in memory
285+  C2C4              ;
286+  C2C4              tank_draw:
287+  C2C4 3E 04            ld a,4                              ; 4 pieces per half
288+  C2C6              tank_draw0:
289+  C2C6 F5               push af
290+  C2C7 2A FF C0         ld hl,(tank_current_sprite)
291+  C2CA ED 4B 01 C1      ld bc,(tank_current_coords)         ; load bc with the start coords
292+  C2CE CD 2C AA         call sprites_drawsprite
293+  C2D1 2A FF C0         ld hl,(tank_current_sprite)
294+  C2D4 ED 4B 01 C1      ld bc,(tank_current_coords)         ; load bc with the start coords
295+  C2D8 11 08 00         ld de,8
296+  C2DB 19               add hl,de
297+  C2DC 80 C6 08         add b,8
298+  C2DF 47               ld b,a
299+  C2E0 22 FF C0         ld (tank_current_sprite),hl         ; put into memory
300+  C2E3 ED 43 01 C1      ld (tank_current_coords),bc         ; put into memory
301+  C2E7 F1               pop af
302+  C2E8 3D               dec a
303+  C2E9 FE 00            cp 0
304+  C2EB C2 C6 C2         jp nz,tank_draw0
305+  C2EE
306+  C2EE C9               ret
307+  C2EF
# file closed: game/tank.asm
 43   C2EF                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  C2EF              ;
  2+  C2EF              ; A structure of falling rocks
  3+  C2EF              ; Assume we'll never have more than 4 falling at any one time
  4+  C2EF              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  C2EF              ;
  6+  C2EF              rocks_falling:
  7+  C2EF 00 00 00 00      defb 0,0,0,0
  8+  C2F3 00 00 00 00      defb 0,0,0,0
  9+  C2F7 00 00 00 00      defb 0,0,0,0
 10+  C2FB 00 00 00 00      defb 0,0,0,0
 11+  C2FF
 12+  C2FF              rocks_tmp:
 13+  C2FF 00               defb 0
 14+  C300
 15+  C300              rocks_tmp2:
 16+  C300 00 00            defb 0,0
 17+  C302
 18+  C302              ;
 19+  C302              ; The number of frames to wobble for
 20+  C302              ; Must always be 10 more than the number of frames a player digs
 21+  C302              ;
 22+  C302              rocks_numberofframestowobble:
 23+  C302 14               defb 20
 24+  C303
 25+  C303              ;
 26+  C303              ; Coords of the rock that killed us
 27+  C303              ;
 28+  C303              rocks_killerrock:
 29+  C303 00 00            defb 0,0
 30+  C305
 31+  C305              ;
 32+  C305              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  C305              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  C305              ; If the pixel row is not the rock bottom, stop checking.
 35+  C305              ; Inputs:
 36+  C305              ; hl- memory location
 37+  C305              ;
 38+  C305              rocks_checkforfalling:
 39+  C305 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  C306 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  C308 C2 0E C3         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  C30B CD 0F C3         call rocks_addrocktofalling ; mark the rock as falling
 43+  C30E              rocks_checkforfalling2:
 44+  C30E C9               ret
 45+  C30F
 46+  C30F              ;
 47+  C30F              ; Adds the rock to the structure that tracks falling rocks
 48+  C30F              ; Inputs:
 49+  C30F              ; hl - memory location of falling rock graphic
 50+  C30F              ; bc - coords of rock, c vert
 51+  C30F              rocks_addrocktofalling:
 52+  C30F C5               push bc             ; store the coords
 53+  C310 11 EF C2         ld de,rocks_falling
 54+  C313 06 04            ld b,4              ; number of possible falling rocks
 55+  C315              rocks_addrocktofalling0:
 56+  C315 13               inc de
 57+  C316                  ;inc de
 58+  C316 13               inc de              ; move three along to get the state
 59+  C317 1A               ld a,(de)           ; load the state
 60+  C318 FE 00            cp 0                ; check if this is not falling
 61+  C31A C2 31 C3         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  C31D 13               inc de              ; move to frame
 63+  C31E 3A 02 C3         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  C321 12               ld (de),a
 65+  C322 1B               dec de              ; move de back to state
 66+  C323 3E 02            ld a,2
 67+  C325 12               ld (de),a           ; set the state to wobbling
 68+  C326 1B               dec de              ; move back coords
 69+  C327 C1               pop bc              ; get back coords
 70+  C328 78               ld a,b
 71+  C329 12               ld (de),a           ; store the vertical
 72+  C32A 1B               dec de
 73+  C32B 79               ld a,c
 74+  C32C 12               ld (de),a           ; store the horizontal
 75+  C32D C5               push bc
 76+  C32E C3 35 C3         jp rocks_addrocktofalling2 ; done
 77+  C331              rocks_addrocktofalling1:
 78+  C331 13               inc de
 79+  C332 13               inc de              ; move memory along to next rock
 80+  C333 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  C335              rocks_addrocktofalling2: ; done, return
 82+  C335 C1               pop bc              ; to tidy up
 83+  C336 C9               ret
 84+  C337
 85+  C337              ;
 86+  C337              ; Processes any falling rocks
 87+  C337              ;
 88+  C337              rocks_processrocks:
 89+  C337 DD 21 EF C2      ld ix,rocks_falling
 90+  C33B 06 04            ld b,4              ; the number of rocks to check
 91+  C33D              rocks_processrocks0:
 92+  C33D C5               push bc             ; store loop count
 93+  C33E DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  C342 46 01
 94+  C344 DD 23            inc ix
 95+  C346 DD 23            inc ix              ; move to the state
 96+  C348 DD 7E 00         ld a,(ix)           ; load the state into a
 97+  C34B FE 00            cp 0
 98+  C34D CA 6E C3         jp z,rocks_processrocks3 ; if not falling, check next
 99+  C350 FE 02            cp 2
100+  C352 C2 62 C3         jp nz, rocks_processrocks2
101+  C355                  ; we're wobbling
102+  C355 DD 23            inc ix              ; get frame number for wobble
103+  C357 DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  C35A CD 31 C4         call rocks_wobble
105+  C35D DD 23            inc ix              ; increment for next
106+  C35F C3 72 C3         jp rocks_processrocks1  ; do next rock
107+  C362              rocks_processrocks2:
108+  C362                  ; we're falling
109+  C362 C5               push bc
110+  C363 CD 76 C3         call rocks_fall
111+  C366 C1               pop bc
112+  C367 DD 23            inc ix
113+  C369 DD 23            inc ix              ; inc ix to get to next
114+  C36B C3 72 C3         jp rocks_processrocks1
115+  C36E              rocks_processrocks3:
116+  C36E DD 23            inc ix
117+  C370 DD 23            inc ix
118+  C372              rocks_processrocks1:
119+  C372 C1               pop bc              ; get loop count back
120+  C373 10 C8            djnz rocks_processrocks0
121+  C375 C9               ret
122+  C376
123+  C376              ;
124+  C376              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  C376              ; bc - coord of current rock graphic on screen
126+  C376              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  C376              ;
128+  C376              rocks_fall:
129+  C376 DD 2B            dec ix
130+  C378 DD 2B            dec ix              ; decrease ix back to coords
131+  C37A ED 43 00 C3      ld (rocks_tmp2),bc  ; store original coords
132+  C37E 3E 03            ld a,3              ; move this number of pixels
133+  C380              rocks_fall1:
134+  C380 32 FF C2         ld (rocks_tmp),a    ; store loop counter
135+  C383 DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  C387 46 01
136+  C389 CD 21 AB         call sprites_scadd  ; get the memory of the coords into de
137+  C38C 14               inc d               ; add 256 to get next row
138+  C38D 1A               ld a,(de)           ; get the contents of the next row
139+  C38E FE 00            cp 0
140+  C390 C2 F0 C3         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  C393 0C               inc c               ; increment the vertical
142+  C394 DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  C398 70 01
143+  C39A 79               ld a,c              ; get the vertical coord into a
144+  C39B E6 07            and 7               ; divisible by 8?
145+  C39D FE 00            cp 0
146+  C39F C2 BC C3         jp nz,rocks_fall4   ; if not, carry on
147+  C3A2 CD 5A A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  C3A5 3E 42            ld a,66             ; load red
149+  C3A7 CD B2 A9         call screen_setattr
150+  C3AA DD 4E 00 DD      ld bc,(ix)
150+  C3AE 46 01
151+  C3B0 79               ld a,c              ; get vertical
152+  C3B1 D6 08            sub 8               ; look up one square
153+  C3B3 4F               ld c,a              ; put a back in c
154+  C3B4 CD 5A A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  C3B7 3E 46            ld a,70             ; load yellow
156+  C3B9 CD B2 A9         call screen_setattr
157+  C3BC              rocks_fall4:
158+  C3BC 3A FF C2         ld a,(rocks_tmp)    ; get the loop counter
159+  C3BF 3D               dec a
160+  C3C0 FE 00            cp 0
161+  C3C2 C2 80 C3         jp nz,rocks_fall1   ; do another pixel if needed
162+  C3C5              rocks_fall2:
163+  C3C5 3E 09            ld a,9              ; rock graphic
164+  C3C7 ED 4B 00 C3      ld bc,(rocks_tmp2)  ; get the original coords
165+  C3CB CD A7 A9         call screen_getblock     ; get the memory into hl
166+  C3CE CD 2C AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  C3D1 3E 09            ld a,9
168+  C3D3 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  C3D7 46 01
169+  C3D9 CD A7 A9         call screen_getblock     ; get the memory into hl
170+  C3DC CD 2C AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  C3DF DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  C3E3 46 01
172+  C3E5 CD 16 C4         call rocks_checkforplayer ; check to see if we hit a player
173+  C3E8 DD 23            inc ix
174+  C3EA DD 23            inc ix                  ; get ix back to state
175+  C3EC CD 06 C4         call rocks_makesound
176+  C3EF C9               ret
177+  C3F0              rocks_fall3:
178+  C3F0 3E 00            ld a,0              ; set the state to fell
179+  C3F2 DD 77 02         ld (ix+2),a           ; store the falling state
180+  C3F5 DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  C3F9 46 01
181+  C3FB CD 5A A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  C3FE 3E 42            ld a,66             ; load magenta
183+  C400 CD B2 A9         call screen_setattr
184+  C403 C3 C5 C3         jp rocks_fall2      ; rejoin main loop
185+  C406
186+  C406              ;
187+  C406              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  C406              ;
189+  C406              rocks_makesound:
190+  C406 DD 7E 00         ld a,(ix)           ; get the state
191+  C409 FE 00            cp 0
192+  C40B C0               ret nz              ; if we haven't fallen, don't do anything
193+  C40C 21 A1 BD         ld hl,player+11
194+  C40F 7E               ld a,(hl)
195+  C410 FE 01            cp 1
196+  C412 C4 E7 AF         call nz, sound_rockfell ; only make sound if didn't kill player
197+  C415 C9               ret
198+  C416
199+  C416              ;
200+  C416              ; Checks to see if the rock is hitting a player
201+  C416              ; Inputs:
202+  C416              ; bc - coords of rock we're checking
203+  C416              rocks_checkforplayer:
204+  C416 ED 5B 96 BD      ld de,(player)       ; get the player coords
205+  C41A 7B               ld a,e               ; get the vert coord first
206+  C41B 91               sub c                ; subtract the rock vertical coord from players
207+  C41C FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  C41E C0               ret nz               ; if not, hasn't hit
209+  C41F 7A               ld a,d               ; get the player horiz coord
210+  C420 90               sub b                ; subtract rock coord
211+  C421 C6 07            add 7                ; add max distance
212+  C423 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  C425 DA 29 C4         jp c,rocks_checkforplayer0
214+  C428 C9               ret
215+  C429              rocks_checkforplayer0:
216+  C429 ED 43 03 C3      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  C42D CD A7 BE         call player_crushplayer ; if so, jump out
218+  C430 C9               ret
219+  C431
220+  C431              ;
221+  C431              ; Wobbles a rocks
222+  C431              ; Inputs:
223+  C431              ; bc - coord of current rock graphic on screen
224+  C431              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  C431              ; a - wobble frame
226+  C431              rocks_wobble:
227+  C431 DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  C434 E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  C436 1E 09            ld e,9              ; this is the rock frame
230+  C438 83               add a,e             ; add the frame toggle
231+  C439 C5               push bc
232+  C43A CD A7 A9         call screen_getblock     ; get the memory into hl
233+  C43D CD 2C AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  C440 DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  C443 3D               dec a               ; decrease
236+  C444 DD 77 00         ld (ix),a           ; store
237+  C447 E6 01            and 1
238+  C449 1E 09            ld e,9              ; this is the rock frame
239+  C44B 83               add a,e             ; add the frame toggle
240+  C44C CD A7 A9         call screen_getblock     ; get the memory into hl
241+  C44F C1               pop bc
242+  C450 CD 2C AA         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  C453 DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  C456 FE 00            cp 0
245+  C458 C0               ret nz              ; if we're not at zero, return
246+  C459 DD 2B            dec ix              ; otherwise look to state location
247+  C45B 3E 01            ld a,1              ; set the state to falling
248+  C45D DD 77 00         ld (ix),a           ; store the falling state
249+  C460 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  C462 C9               ret
251+  C463
# file closed: game/rocks.asm
 44   C463                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  C463              ;
  2+  C463              ; The score of the current player
  3+  C463              ;
  4+  C463              scores_current:
  5+  C463 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  C467 30 30 30 30
  5+  C46B FF
  6+  C46C
  7+  C46C              scores_defaultname:
  8+  C46C 2D 2D 2D         defb '---'
  9+  C46F
 10+  C46F              ;
 11+  C46F              ; The current high score table
 12+  C46F              ;
 13+  C46F              scores_table:
 14+  C46F 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  C473 4D 30 30 30
 14+  C477 30 30 30 FF
 15+  C47B 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  C47F 4D 30 30 30
 15+  C483 30 30 30 FF
 16+  C487 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  C48B 4D 30 30 30
 16+  C48F 30 30 30 FF
 17+  C493
 18+  C493              ;
 19+  C493              ; Add thousands to the score
 20+  C493              ; Inputs:
 21+  C493              ; b - number to add
 22+  C493              ;
 23+  C493              scores_addthousands:
 24+  C493 21 67 C4         ld hl,scores_current+4
 25+  C496 CD F7 C4         call scores_update
 26+  C499 C9               ret
 27+  C49A
 28+  C49A              ;
 29+  C49A              ; Add hundreds to the score
 30+  C49A              ; Inputs:
 31+  C49A              ; b - number to add
 32+  C49A              ;
 33+  C49A              scores_addhundreds:
 34+  C49A 21 68 C4         ld hl,scores_current+5
 35+  C49D CD F7 C4         call scores_update
 36+  C4A0 C9               ret
 37+  C4A1
 38+  C4A1              ;
 39+  C4A1              ; Temporary area for printing scores
 40+  C4A1              ;
 41+  C4A1              scores_printscore_tmp:
 42+  C4A1 00 00 00 00      defb 0,0,0,0,0,0,0,0,255
 42+  C4A5 00 00 00 00
 42+  C4A9 FF
 43+  C4AA
 44+  C4AA              ;
 45+  C4AA              ; Prints the score to screen
 46+  C4AA              ;
 47+  C4AA              scores_printscore:
 48+  C4AA 3A 5F BD         ld a,(game_currentplayer)   ; get current player
 49+  C4AD 21 63 C4         ld hl,scores_current
 50+  C4B0 FE 01            cp 1
 51+  C4B2 C2 BA C4         jp nz, score_printscore0    ; if not player 1
 52+  C4B5 36 04            ld (hl),4       ; set position for player 1
 53+  C4B7 C3 BC C4         jp score_printscore1
 54+  C4BA              score_printscore0:
 55+  C4BA 36 16            ld (hl),22       ; set position for player 2
 56+  C4BC              score_printscore1:
 57+  C4BC CD C0 C4         call score_printscoreformatted
 58+  C4BF C9               ret
 59+  C4C0
 60+  C4C0              ;
 61+  C4C0              ; Formats a score and prints to the top screen
 62+  C4C0              ; Inputs:
 63+  C4C0              ; hl - where is the score
 64+  C4C0              score_printscoreformatted:
 65+  C4C0 01 08 00         ld bc,8
 66+  C4C3 11 A1 C4         ld de,scores_printscore_tmp
 67+  C4C6 ED B0            ldir                        ; copy to temp
 68+  C4C8 21 A1 C4         ld hl,scores_printscore_tmp
 69+  C4CB E5 DD E1         ld ix,hl
 70+  C4CE DD 7E 02         ld a,(ix+2)
 71+  C4D1 FE 30            cp 48                   ; is it a leading zero?
 72+  C4D3 C2 E6 C4         jp nz,score_printscore2
 73+  C4D6 DD 36 02 20      ld (ix+2),32              ; load it with a space
 74+  C4DA DD 7E 03         ld a,(ix+3)
 75+  C4DD FE 30            cp 48                   ; is it a leading zero?
 76+  C4DF C2 E6 C4         jp nz,score_printscore2
 77+  C4E2 DD 36 03 20      ld (ix+3),32              ; load it with a space
 78+  C4E6              score_printscore2:
 79+  C4E6 CD 56 85         call string_print
 80+  C4E9 C9               ret
 81+  C4EA
 82+  C4EA              ;
 83+  C4EA              ; Prints both scores to screen
 84+  C4EA              ;
 85+  C4EA              scores_printscores:
 86+  C4EA 21 8D BE         ld hl,player1_score
 87+  C4ED CD C0 C4         call score_printscoreformatted
 88+  C4F0 21 96 BE         ld hl,player2_score
 89+  C4F3 CD C0 C4         call score_printscoreformatted
 90+  C4F6 C9               ret
 91+  C4F7
 92+  C4F7              ;
 93+  C4F7              ; Updates the current score.
 94+  C4F7              ; Inputs:
 95+  C4F7              ; hl - memory location of the score column
 96+  C4F7              ; b - number to add
 97+  C4F7              ;
 98+  C4F7              scores_update:
 99+  C4F7 7E               ld a,(hl)           ; current value of digit.
100+  C4F8 80               add a,b             ; add points to this digit.
101+  C4F9 77               ld (hl),a           ; place new digit back in string.
102+  C4FA FE 3A            cp 58               ; more than ASCII value '9'?
103+  C4FC D8               ret c               ; no - relax.
104+  C4FD D6 0A            sub 10              ; subtract 10.
105+  C4FF 77               ld (hl),a           ; put new character back in string.
106+  C500              scores_update0:
107+  C500 2B               dec hl              ; previous character in string.
108+  C501 34               inc (hl)            ; up this by one.
109+  C502 7E               ld a,(hl)           ; what's the new value?
110+  C503 FE 3A            cp 58               ; gone past ASCII nine?
111+  C505 D8               ret c               ; no, scoring done.
112+  C506 D6 0A            sub 10              ; down by ten.
113+  C508 77               ld (hl),a           ; put it back
114+  C509 C3 00 C5         jp scores_update0   ; go round again.
115+  C50C
116+  C50C
117+  C50C              ;
118+  C50C              ; Temporary area to store score
119+  C50C              ;
120+  C50C              scores_showtable_tmp:
121+  C50C 00 00 00 00      defb 0,0,0,0,0,0,0,0,0,0,0,255
121+  C510 00 00 00 00
121+  C514 00 00 00 FF
122+  C518
123+  C518              ;
124+  C518              ; Processes a score
125+  C518              ; Inputs:
126+  C518              ; hl - location on table
127+  C518              ;
128+  C518              scores_showtable_process:
129+  C518 01 0B 00         ld bc,11                     ; copy this many
130+  C51B 11 0C C5         ld de,scores_showtable_tmp
131+  C51E ED B0            ldir
132+  C520 DD 21 0C C5      ld ix,scores_showtable_tmp   ; decide whether to show five or six numbers
133+  C524 DD 7E 05         ld a,(ix+5)
134+  C527 FE 30            cp 48                        ; is this a zero?
135+  C529 C2 3F C5         jp nz,scores_showtable_process0 ; if not, show the whole thing
136+  C52C 01 05 00         ld bc,5                      ; copy this many
137+  C52F DD E5 E1         ld hl,ix
138+  C532 11 06 00         ld de,6
139+  C535 19               add hl,de                    ; move to second digit
140+  C536 54 5D            ld de,hl
141+  C538 1B               dec de
142+  C539 ED B0            ldir
143+  C53B DD 36 0A 20      ld (ix+10),32                ; stick a space at the end
144+  C53F              scores_showtable_process0:
145+  C53F 21 0C C5         ld hl,scores_showtable_tmp
146+  C542 CD 56 85         call string_print
147+  C545 C9               ret
148+  C546
149+  C546              ;
150+  C546              ; Displays the high score table at the bottom of the screen
151+  C546              ;
152+  C546              scores_showtable:
153+  C546 21 6F C4         ld hl, scores_table
154+  C549 CD 18 C5         call scores_showtable_process
155+  C54C 21 7B C4         ld hl, scores_table+12
156+  C54F CD 18 C5         call scores_showtable_process
157+  C552 21 87 C4         ld hl, scores_table+24
158+  C555 CD 18 C5         call scores_showtable_process
159+  C558 C9               ret
160+  C559
161+  C559              ;
162+  C559              ; Place to store the current position we're checking
163+  C559              ;
164+  C559              scores_highscoretmp:
165+  C559 00               defb 0
166+  C55A
167+  C55A              ;
168+  C55A              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
169+  C55A              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
170+  C55A              ;
171+  C55A              scores_processhighscores:
172+  C55A 21 59 C5         ld hl,scores_highscoretmp
173+  C55D 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
174+  C55F 3E 1D            ld a,29
175+  C561              scores_processhighscores3:
176+  C561 21 6F C4         ld hl,scores_table          ; position of first score column
177+  C564 5F               ld e,a
178+  C565 16 00            ld d,0
179+  C567 19               add hl,de
180+  C568 08               ex af,af'                   ; store a for later
181+  C569 11 65 C4         ld de,scores_current+2      ; position of current score column
182+  C56C 06 06            ld b,6                      ; times to loop
183+  C56E              scores_processhighscores0:
184+  C56E 7E               ld a,(hl)
185+  C56F 4F               ld c,a                      ; get first score column
186+  C570 1A               ld a,(de)                   ; get first current column
187+  C571 B9               cp c                        ; compare current with first
188+  C572 DA 83 C5         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
189+  C575 23               inc hl
190+  C576 13               inc de                      ; move to next column
191+  C577 10 F5            djnz scores_processhighscores0 ; loop
192+  C579 08               ex af,af'                     ; still here, so must be bigger
193+  C57A 32 59 C5         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
194+  C57D 0E 0C            ld c,12
195+  C57F 91               sub c
196+  C580 D2 61 C5         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
197+  C583              scores_processhighscores4
198+  C583 CD 87 C5         call scores_updatehighscores
199+  C586 C9               ret
200+  C587
201+  C587              ;
202+  C587              ; Update score table
203+  C587              ;
204+  C587              scores_updatehighscores:
205+  C587 3A 59 C5         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
206+  C58A FE 00            cp 0
207+  C58C C8               ret z                       ; if this is 0, didn't get a high score
208+  C58D FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
209+  C58F CA C2 C5         jp z, scores_updatehighscores3
210+  C592                                              ; copy old score over one below, if not first
211+  C592 21 6F C4         ld hl,scores_table
212+  C595 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
213+  C598 19               add hl,de                   ; position of first column
214+  C599 2B               dec hl
215+  C59A 2B               dec hl
216+  C59B 2B               dec hl
217+  C59C E5               push hl
218+  C59D 11 0C 00         ld de,12
219+  C5A0 19               add hl,de                   ; get position of next score
220+  C5A1 54 5D            ld de,hl
221+  C5A3 E1               pop hl                      ; get hl back
222+  C5A4 01 09 00         ld bc,9
223+  C5A7 ED B0            ldir
224+  C5A9 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
225+  C5AB CA C2 C5         jp z,scores_updatehighscores3
226+  C5AE 21 6F C4         ld hl,scores_table
227+  C5B1 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
228+  C5B4 19               add hl,de                   ; position of first column
229+  C5B5 E5               push hl
230+  C5B6 11 0C 00         ld de,12
231+  C5B9 19               add hl,de                   ; get position of next score
232+  C5BA 54 5D            ld de,hl
233+  C5BC E1               pop hl                      ; get hl back
234+  C5BD 01 09 00         ld bc,9
235+  C5C0 ED B0            ldir
236+  C5C2              scores_updatehighscores3:
237+  C5C2 06 06            ld b,6                      ; now overwrite
238+  C5C4 21 6F C4         ld hl,scores_table
239+  C5C7 16 00            ld d,0
240+  C5C9 5F               ld e,a
241+  C5CA 19               add hl,de                   ; position of first column
242+  C5CB 08               ex af,af'
243+  C5CC 11 65 C4         ld de,scores_current+2      ; position of current score column
244+  C5CF              scores_updatehighscores2:
245+  C5CF 1A               ld a,(de)
246+  C5D0 77               ld (hl),a
247+  C5D1 23               inc hl
248+  C5D2 13               inc de
249+  C5D3 10 FA            djnz scores_updatehighscores2
250+  C5D5 11 09 00         ld de,9
251+  C5D8 ED 52            sbc hl,de
252+  C5DA 54 5D            ld de,hl                    ; get back to start of entry
253+  C5DC 21 6C C4         ld hl,scores_defaultname    ; still need to overwrite the name
254+  C5DF 01 03 00         ld bc,3                      ; 3 chars to copy
255+  C5E2 ED B0            ldir
256+  C5E4 C9               ret
# file closed: game/scores.asm
 45   C5E5                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  C5E5              diamonds_tmp:
  2+  C5E5 00               defb 0
  3+  C5E6
  4+  C5E6              diamonds_tmp2:
  5+  C5E6 00               defb 0
  6+  C5E7
  7+  C5E7              ;
  8+  C5E7              ; Holds the number of thousands for the current gem type
  9+  C5E7              ;
 10+  C5E7              diamonds_score:
 11+  C5E7 00               defb 0
 12+  C5E8
 13+  C5E8              ;
 14+  C5E8              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  C5E8              ; Inputs:
 16+  C5E8              ; hl - memory location of gem type
 17+  C5E8              diamonds_twinkle_type:
 18+  C5E8 CD 85 BD         call game_getcurrentframe       ; get current frame number
 19+  C5EB E6 07            and 7                           ; want a number from 0-7
 20+  C5ED C6 40            add 64                          ; add to 60 to get attr colour
 21+  C5EF 32 E6 C5         ld (diamonds_tmp2),a             ; store the colour
 22+  C5F2              diamonds_twinkle_type0:
 23+  C5F2 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  C5F6 79               ld a,c                          ; load c into a
 25+  C5F7 FE FF            cp 255                          ; is this the end?
 26+  C5F9 CA 21 C6         jp z,diamonds_twinkle_type1           ; step out if so
 27+  C5FC 23               inc hl
 28+  C5FD 23               inc hl
 29+  C5FE 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  C5FF FE 01            cp 1
 31+  C601 CA 22 C6         jp z,diamonds_twinkle_type2           ; step out if so
 32+  C604 CD 62 C6         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  C607 DC 29 C6         call c,diamonds_collect     ; we collided
 34+  C60A 23               inc hl
 35+  C60B E5               push hl
 36+  C60C E5 DD E1         ld ix,hl
 37+  C60F DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  C613 46 FE
 38+  C615 3A E6 C5         ld a,(diamonds_tmp2)
 39+  C618 CD B2 A9         call screen_setattr
 40+  C61B E1               pop hl
 41+  C61C 23               inc hl
 42+  C61D 23               inc hl                          ; move to next diamond
 43+  C61E C3 F2 C5         jp diamonds_twinkle_type0
 44+  C621              diamonds_twinkle_type1:
 45+  C621 C9               ret
 46+  C622              diamonds_twinkle_type2:
 47+  C622 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  C623 23               inc hl
 49+  C624 23               inc hl
 50+  C625 08               ex af,af'
 51+  C626 C3 F2 C5         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  C629
 53+  C629              ;
 54+  C629              ; Collect the diamond we collided with
 55+  C629              ; Inputs:
 56+  C629              ; hl - memory location of current diamond, currently on state
 57+  C629              ; Output:
 58+  C629              ; a - 70 - for yellow on black
 59+  C629              diamonds_collect:
 60+  C629 36 01            ld (hl),1                       ; collected
 61+  C62B E5               push hl
 62+  C62C 2B               dec hl
 63+  C62D 2B               dec hl
 64+  C62E 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  C632 CD 6A A9         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  C635 ED 5B E5 C5      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  C639 16 00            ld d,0
 68+  C63B 21 B6 B5         ld hl,sprites
 69+  C63E 19               add hl,de
 70+  C63F CD 2C AA         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  C642 E1               pop hl
 72+  C643 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  C645 32 E6 C5         ld (diamonds_tmp2),a
 74+  C648 D9               exx
 75+  C649 3A E7 C5         ld a,(diamonds_score)
 76+  C64C 47               ld b,a
 77+  C64D CD 93 C4         call scores_addthousands
 78+  C650 3A E5 C5         ld a,(diamonds_tmp)
 79+  C653 FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  C655 C2 5D C6         jp nz,diamonds_collect0
 81+  C658 21 A3 BD         ld hl,player+13
 82+  C65B 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  C65D              diamonds_collect0:
 84+  C65D CD CA AF         call sound_gemcollected
 85+  C660 D9               exx
 86+  C661 C9               ret
 87+  C662
 88+  C662              ;
 89+  C662              ; Checks to see if the gem is hitting a player
 90+  C662              ; Inputs:
 91+  C662              ; bc - coords of diamond we're checking
 92+  C662              diamonds_checkforplayer:
 93+  C662 78               ld a,b               ; multiply b by 8
 94+  C663 07               rlca
 95+  C664 07               rlca
 96+  C665 07               rlca
 97+  C666 47               ld b,a
 98+  C667 ED 5B 96 BD      ld de,(player)       ; get the player coords
 99+  C66B 7B               ld a,e               ; get the vert coord first
100+  C66C 90               sub b                ; subtract the diamond vertical coord from players
101+  C66D C6 04            add 4                ; add the max distance
102+  C66F FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  C671 D0               ret nc               ; if not, hasn't hit
104+  C672 79               ld a,c               ; multiply c by 8
105+  C673 07               rlca
106+  C674 07               rlca
107+  C675 07               rlca
108+  C676 4F               ld c,a
109+  C677 7A               ld a,d               ; get the player horiz coord
110+  C678 91               sub c                ; subtract rock coord
111+  C679 C6 04            add 4                ; add max distance
112+  C67B FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  C67D D0               ret nc
114+  C67E 3E 00            ld a,0
115+  C680 C9               ret
116+  C681
117+  C681
118+  C681              ;
119+  C681              ; Initialise diamonds and gems
120+  C681              ;
121+  C681              diamonds_twinkle
122+  C681 21 E7 C5         ld hl,diamonds_score
123+  C684 36 02            ld (hl),2         ; store the score we'll add
124+  C686 21 E5 C5         ld hl,diamonds_tmp
125+  C689 36 40            ld (hl),64         ; store the location the diamond sprite
126+  C68B 21 31 B5         ld hl, level01diamonds
127+  C68E CD E8 C5         call diamonds_twinkle_type
128+  C691 21 E7 C5         ld hl,diamonds_score
129+  C694 36 01            ld (hl),1         ; store the score we'll add
130+  C696 21 E5 C5         ld hl,diamonds_tmp
131+  C699 36 70            ld (hl),112         ; store the location the gem sprite
132+  C69B 21 41 B5         ld hl, level01gems
133+  C69E CD E8 C5         call diamonds_twinkle_type
134+  C6A1 C9               ret
135+  C6A2
136+  C6A2              ;
137+  C6A2              ; Initialise diamonds and gems
138+  C6A2              ;
139+  C6A2              diamonds_init:
140+  C6A2 21 31 B5         ld hl, level01diamonds
141+  C6A5 CD AF C6         call diamonds_init_type
142+  C6A8 21 41 B5         ld hl, level01gems
143+  C6AB CD AF C6         call diamonds_init_type
144+  C6AE C9               ret
145+  C6AF
146+  C6AF              ;
147+  C6AF              ; Initialise diamonds or gems, get memory addresses
148+  C6AF              ; Inputs:
149+  C6AF              ; hl - memory location
150+  C6AF              diamonds_init_type:
151+  C6AF 4E               ld c,(hl)                      ; get coords into c
152+  C6B0 79               ld a,c                          ; load c into add
153+  C6B1 FE FF            cp 255                          ; is this the end?
154+  C6B3 CA CA C6         jp z,diamonds_init_type1             ; step out if so
155+  C6B6 23               inc hl
156+  C6B7 46               ld b,(hl)                       ; get coords into b
157+  C6B8 E5               push hl
158+  C6B9 CD 1B A9         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  C6BC E1               pop hl
160+  C6BD 23               inc hl                          ; move to state
161+  C6BE 36 00            ld (hl),0
162+  C6C0 23               inc hl                          ; move to memory
163+  C6C1 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  C6C5 23               inc hl                          ; move to next diamond
165+  C6C6 23               inc hl
166+  C6C7 C3 AF C6         jp diamonds_init_type
167+  C6CA              diamonds_init_type1:
168+  C6CA C9               ret
# file closed: game/diamonds.asm
 46   C6CB                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  C6CB              ;
  2+  C6CB              ; Controls when missiles fall
  3+  C6CB              ;
  4+  C6CB              missiles_count:
  5+  C6CB 00               defb 0
  6+  C6CC
  7+  C6CC              ;
  8+  C6CC              ; A structure of falling missiles
  9+  C6CC              ; Assume we'll never have more than 4 falling at any one time
 10+  C6CC              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  C6CC              ;
 12+  C6CC              missiles_falling:
 13+  C6CC 00 00 00         defb 0,0,0
 14+  C6CF 00 00 00         defb 0,0,0
 15+  C6D2 00 00 00         defb 0,0,0
 16+  C6D5 00 00 00         defb 0,0,0
 17+  C6D8
 18+  C6D8              ;
 19+  C6D8              ; The coords of the missile that killed us
 20+  C6D8              ;
 21+  C6D8              missiles_killermissile:
 22+  C6D8 00 00            defb 0,0
 23+  C6DA
 24+  C6DA              ;
 25+  C6DA              ; Zeroes the state of each missile
 26+  C6DA              ;
 27+  C6DA              missiles_init:
 28+  C6DA 06 0C            ld b,12
 29+  C6DC DD 21 B8 B4      ld ix,level01missiles
 30+  C6E0              missiles_init0:
 31+  C6E0 DD 36 02 00      ld (ix+2),0               ; set the state to zero
 32+  C6E4 11 05 00         ld de,5
 33+  C6E7 DD 19            add ix,de
 34+  C6E9 DD 36 02 00      ld (ix+2),0
 35+  C6ED DD 19            add ix,de
 36+  C6EF 10 EF            djnz missiles_init0
 37+  C6F1 06 04            ld b,4                  ; reset four falling missiles
 38+  C6F3 21 CC C6         ld hl,missiles_falling
 39+  C6F6              missiles_init1:
 40+  C6F6 36 00            ld (hl),0
 41+  C6F8 23               inc hl
 42+  C6F9 36 00            ld (hl),0
 43+  C6FB 23               inc hl
 44+  C6FC 36 00            ld (hl),0
 45+  C6FE 23               inc hl
 46+  C6FF 10 F5            djnz missiles_init1
 47+  C701 C9               ret
 48+  C702
 49+  C702              ;
 50+  C702              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 51+  C702              ; Processes any already falling missiles
 52+  C702              ;
 53+  C702              missiles_process:
 54+  C702 3A A1 BD         ld a,(player+11)                        ; check if the player was hit by a missile previously
 55+  C705 FE 03            cp 3
 56+  C707 C2 0E C7         jp nz,missiles_process3                 ; if not, continue
 57+  C70A CD 4B C8         call missiles_zonkplayer
 58+  C70D C9               ret
 59+  C70E              missiles_process3:
 60+  C70E 3A A5 BD         ld a,(player_location)
 61+  C711 FE 01            cp 1
 62+  C713 C2 81 C7         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 63+  C716 21 A3 BD         ld hl,player+13
 64+  C719 7E               ld a,(hl)                               ; check if player has collected a diamond
 65+  C71A FE 01            cp 1
 66+  C71C C2 81 C7         jp nz, missiles_process0                ; don't activate if not
 67+  C71F 21 CB C6         ld hl,missiles_count
 68+  C722 7E               ld a,(hl)                   ; get the missiles count
 69+  C723 3C               inc a
 70+  C724 FE 32            cp 50                                   ; have we reached the count yet
 71+  C726 CA 2D C7         jp z,missiles_process2                 ; if not, don't activate a new one
 72+  C729 77               ld (hl),a                               ; store the updated count, and continue without activating
 73+  C72A C3 81 C7         jp missiles_process0
 74+  C72D              missiles_process2:
 75+  C72D 36 00            ld (hl),0                               ; zero the counter
 76+  C72F 1E 0C            ld e,12
 77+  C731 CD EF 80         call utilities_randomupper              ; get random number from 0 to 11
 78+  C734 11 0A 00         ld de,10
 79+  C737 CD 3A 80         call utilities_multiply                 ; multiple random number by 10
 80+  C73A 54 5D            ld de,hl                                ; this is the offset for the random missile
 81+  C73C DD 21 B8 B4      ld ix,level01missiles                   ; load the location of the missile definitions
 82+  C740 DD 19            add ix,de                               ; get to location of missile
 83+  C742 DD 7E 02         ld a,(ix+2)
 84+  C745 FE 00            cp 0
 85+  C747 CA 57 C7         jp z,missiles_process1                  ; if this missile isn't active, activate it
 86+  C74A 11 05 00         ld de,5                                 ; otherwise, check the missile above
 87+  C74D DD 19            add ix,de
 88+  C74F DD 7E 02         ld a,(ix+2)
 89+  C752 FE 00            cp 0
 90+  C754 C2 81 C7         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 91+  C757              missiles_process1:                          ; activate a missile
 92+  C757 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
 93+  C75B DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
 93+  C75F 46 01
 94+  C761 78               ld a,b
 95+  C762 ED 5B 08 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
 96+  C766 93               sub e
 97+  C767 CD 6A A9         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
 98+  C76A C5               push bc
 99+  C76B 3E 0C            ld a,12                                 ; inactive missile sprite
100+  C76D CD A7 A9         call screen_getblock
101+  C770 CD 2C AA         call sprites_drawsprite                 ; draw the sprite over the old one
102+  C773 C1               pop bc
103+  C774 C5               push bc
104+  C775 3E 14            ld a,20                                 ; active missile sprite
105+  C777 CD A7 A9         call screen_getblock
106+  C77A CD 2C AA         call sprites_drawsprite                 ; draw the sprite over the old one
107+  C77D C1               pop bc
108+  C77E CD 0F C8         call missiles_addmissiletofalling
109+  C781              missiles_process0:
110+  C781 CD 85 C7         call missiles_fall
111+  C784 C9               ret
112+  C785
113+  C785              ;
114+  C785              ; Processes falling missiles
115+  C785              ;
116+  C785              missiles_fall:
117+  C785 06 04            ld b,4              ; number of possible falling missiles
118+  C787 DD 21 CC C6      ld ix,missiles_falling
119+  C78B              missiles_fall0:
120+  C78B C5               push bc
121+  C78C DD 7E 02         ld a,(ix+2)
122+  C78F FE 00            cp 0
123+  C791 CA EE C7         jp z,missiles_fall1 ; not falling move to next
124+  C794 FE 01            cp 1                ; is this ready to fall
125+  C796 CA 9C C7         jp z, missiles_fall3
126+  C799 C3 08 C8         jp missiles_fall4   ; if not, decrease the countdown
127+  C79C              missiles_fall3:
128+  C79C DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
128+  C7A0 46 01
129+  C7A2 CD 21 AB         call sprites_scadd  ; get the memory of the coords into de
130+  C7A5 14               inc d               ; add 256 to get next row
131+  C7A6 1A               ld a,(de)           ; get the contents of the next row
132+  C7A7 FE 00            cp 0
133+  C7A9 C2 01 C8         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
134+  C7AC 3E 14            ld a,20                                 ; active missile sprite
135+  C7AE CD A7 A9         call screen_getblock
136+  C7B1 CD 2C AA         call sprites_drawsprite                 ; draw the sprite over the old one
137+  C7B4 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
137+  C7B8 46 01
138+  C7BA 0C               inc c               ; move down one pixel
139+  C7BB DD 71 00 DD      ld (ix),bc          ; store the new coords
139+  C7BF 70 01
140+  C7C1 3E 14            ld a,20                                 ; active missile sprite
141+  C7C3 CD A7 A9         call screen_getblock
142+  C7C6 CD 2C AA         call sprites_drawsprite                 ; draw the sprite
143+  C7C9 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
143+  C7CD 46 01
144+  C7CF 79               ld a,c              ; get the vertical coord into a
145+  C7D0 E6 07            and 7               ; divisible by 8?
146+  C7D2 FE 00            cp 0
147+  C7D4 C2 EE C7         jp nz,missiles_fall1   ; if not, carry on
148+  C7D7 CD 5A A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
149+  C7DA 3E 43            ld a,67             ; load magenta
150+  C7DC CD B2 A9         call screen_setattr
151+  C7DF DD 4E 00 DD      ld bc,(ix)
151+  C7E3 46 01
152+  C7E5 CD 5A A9         call screen_getcharcoordsfromscreencoords ; get the attr address into de
153+  C7E8 05               dec b               ; look one square above
154+  C7E9 3E 46            ld a,70             ; load yellow
155+  C7EB CD B2 A9         call screen_setattr
156+  C7EE              missiles_fall1:         ; hl at state
157+  C7EE DD 4E 00 DD      ld bc,(ix)          ; get coords back
157+  C7F2 46 01
158+  C7F4 CD 30 C8         call missiles_checkforplayer ; check for player
159+  C7F7 DD 23            inc ix
160+  C7F9 DD 23            inc ix
161+  C7FB DD 23            inc ix              ; get to next missile
162+  C7FD C1               pop bc
163+  C7FE 10 8B            djnz missiles_fall0
164+  C800 C9               ret
165+  C801              missiles_fall2:
166+  C801 DD 36 02 00      ld (ix+2),0
167+  C805 C3 EE C7         jp missiles_fall1   ; rejoin the loop
168+  C808              missiles_fall4:
169+  C808 3D               dec a               ; decrease the countdown
170+  C809 DD 77 02         ld (ix+2),a         ; store back
171+  C80C C3 EE C7         jp missiles_fall1   ; do next missile
172+  C80F
173+  C80F              ;
174+  C80F              ; Adds the missile to the structure that tracks falling missile
175+  C80F              ; Inputs:
176+  C80F              ; bc - coords of missile, c vert
177+  C80F              missiles_addmissiletofalling:
178+  C80F C5               push bc             ; store the coords
179+  C810 11 CC C6         ld de,missiles_falling
180+  C813 06 04            ld b,4              ; number of possible falling missiles
181+  C815              missiles_addmissiletofalling0:
182+  C815 13               inc de
183+  C816 13               inc de              ; move three along to get the state
184+  C817 1A               ld a,(de)           ; load the state
185+  C818 FE 00            cp 0                ; check if this is not falling
186+  C81A C2 2B C8         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
187+  C81D 3E 19            ld a,25
188+  C81F 12               ld (de),a           ; set the state to pre-falling
189+  C820 1B               dec de              ; move back coords
190+  C821 C1               pop bc              ; get back coords
191+  C822 78               ld a,b
192+  C823 12               ld (de),a           ; store the vertical
193+  C824 1B               dec de
194+  C825 79               ld a,c
195+  C826 12               ld (de),a           ; store the horizontal
196+  C827 C5               push bc
197+  C828 C3 2E C8         jp missiles_addmissiletofalling2 ; done
198+  C82B              missiles_addmissiletofalling1:
199+  C82B 13               inc de              ; move memory along to next rock
200+  C82C 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
201+  C82E              missiles_addmissiletofalling2: ; done, return
202+  C82E C1               pop bc              ; to tidy up
203+  C82F C9               ret
204+  C830
205+  C830              ;
206+  C830              ; Checks to see if the missile is hitting a player
207+  C830              ; Inputs:
208+  C830              ; bc - coords of missile we're checking
209+  C830              missiles_checkforplayer:
210+  C830 ED 5B 96 BD      ld de,(player)       ; get the player coords
211+  C834 7B               ld a,e               ; get the vert coord first
212+  C835 91               sub c                ; subtract the missile vertical coord from players
213+  C836 FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
214+  C838 C0               ret nz               ; if not, hasn't hit
215+  C839 7A               ld a,d               ; get the player horiz coord
216+  C83A 90               sub b                ; subtract missile coord
217+  C83B C6 07            add 7                ; add max distance
218+  C83D FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
219+  C83F DA 43 C8         jp c,missiles_checkforplayer0
220+  C842 C9               ret
221+  C843              missiles_checkforplayer0:
222+  C843 ED 43 D8 C6      ld (missiles_killermissile),bc; store the coords of the killer missile
223+  C847 CD B3 BE         call player_zonkplayer ; if so, jump out
224+  C84A C9               ret
225+  C84B
226+  C84B              ;
227+  C84B              ; Player has been hit, so draw text over them and mark as dead
228+  C84B              ;
229+  C84B              missiles_zonkplayer:
230+  C84B CD A1 BE         call player_killplayer      ; mark as dead
231+  C84E ED 4B 96 BD      ld bc,(player)              ; get player coords
232+  C852 CD 5A A9         call screen_getcharcoordsfromscreencoords
233+  C855 0D               dec c
234+  C856 0D               dec c
235+  C857 04               inc b
236+  C858 C5               push bc
237+  C859 3E 42            ld a,66
238+  C85B CD B2 A9         call screen_setattr
239+  C85E 0C               inc c
240+  C85F CD B2 A9         call screen_setattr
241+  C862 0C               inc c
242+  C863 CD B2 A9         call screen_setattr
243+  C866 0C               inc c
244+  C867 CD B2 A9         call screen_setattr
245+  C86A 0C               inc c
246+  C86B CD B2 A9         call screen_setattr
247+  C86E C1               pop bc
248+  C86F ED 5B 08 A8      ld de,(screen_offset)
249+  C873 78               ld a,b
250+  C874 93               sub e
251+  C875 47               ld b,a                      ; subtract the offset
252+  C876 04               inc b
253+  C877 04               inc b                       ; add two for the score rows
254+  C878 ED 43 CF 84      ld (string_zonk),bc         ; set coords of string
255+  C87C 21 CF 84         ld hl,string_zonk
256+  C87F CD 56 85         call string_print
257+  C882 06 14            ld b,20
258+  C884 CD 9B 80         call utilities_pauseforframes ; pause
259+  C887 C9               ret
260+  C888
# file closed: game/missiles.asm
 47   C888                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  C888              ;
  2+  C888              ; Timer for deciding how fast the trap withdraws
  3+  C888              ;
  4+  C888              thepit_timer:
  5+  C888 00               defb 0
  6+  C889
  7+  C889              ;
  8+  C889              ; Ticks for the trap state. Will count to 3 then reset
  9+  C889              ;
 10+  C889              thepit_trapcount:
 11+  C889 00               defb 0
 12+  C88A
 13+  C88A              ;
 14+  C88A              ; The horizontal coordinate of the current pit trap
 15+  C88A              ;
 16+  C88A              thepit_trapcoord:
 17+  C88A 08               defb 8
 18+  C88B
 19+  C88B              ;
 20+  C88B              ; Initialises the pit
 21+  C88B              ;
 22+  C88B              thepit_init:
 23+  C88B 21 8A C8         ld hl,thepit_trapcoord
 24+  C88E 36 08            ld (hl),8
 25+  C890 21 89 C8         ld hl,thepit_trapcount
 26+  C893 36 00            ld (hl),0
 27+  C895 C9               ret
 28+  C896
 29+  C896              ;
 30+  C896              ; Performs per frame processing on the pit room
 31+  C896              ;
 32+  C896              thepit_process:
 33+  C896 3A A5 BD         ld a,(player_location)
 34+  C899 FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 35+  C89B C2 F7 C8         jp nz,thepit_process0
 36+  C89E ED 4B 96 BD      ld bc,(player)                  ; get the player's coords to check if about to fall
 37+  C8A2 3E 08            ld a,8
 38+  C8A4 81               add a,c
 39+  C8A5 4F               ld c,a                          ; look at the square underneath
 40+  C8A6 CD 5A A9         call screen_getcharcoordsfromscreencoords ; get the cell coords
 41+  C8A9 CD E8 A9         call screen_ischarempty
 42+  C8AC FE 01            cp 1                            ; check if this is 1=empty
 43+  C8AE CA F8 C8         jp z,thepit_process2
 44+  C8B1 3A 88 C8         ld a,(thepit_timer)             ; get the timer
 45+  C8B4 3C               inc a
 46+  C8B5 32 88 C8         ld (thepit_timer),a             ; store
 47+  C8B8 FE 02            cp 2                           ; have we reached the trigger?
 48+  C8BA C2 F7 C8         jp nz, thepit_process0          ; no need to do anything
 49+  C8BD 3E 00            ld a,0
 50+  C8BF 32 88 C8         ld (thepit_timer),a             ; zero the timer and process
 51+  C8C2 3A 89 C8         ld a,(thepit_trapcount)         ; get the current count
 52+  C8C5 3C               inc a
 53+  C8C6 32 89 C8         ld (thepit_trapcount),a         ; reset the trap count
 54+  C8C9 FE 04            cp 4                            ; do we need to begin another character?
 55+  C8CB C2 DF C8         jp nz,thepit_process1           ; if not, draw as normal
 56+  C8CE 3E 00            ld a,0
 57+  C8D0 32 89 C8         ld (thepit_trapcount),a         ; reset the trap count
 58+  C8D3 3A 8A C8         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 59+  C8D6 FE 02            cp 2
 60+  C8D8 CA F7 C8         jp z,thepit_process0
 61+  C8DB 3D               dec a
 62+  C8DC 32 8A C8         ld (thepit_trapcoord),a         ; store the reduced coord
 63+  C8DF
 64+  C8DF              thepit_process1:                    ; draw the trapdoor in current position
 65+  C8DF 3A 8A C8         ld a,(thepit_trapcoord)
 66+  C8E2 FE 02            cp 2
 67+  C8E4 CA F7 C8         jp z, thepit_process0           ; don't process outside of the pit
 68+  C8E7 4F               ld c,a
 69+  C8E8 06 0A            ld b,10                         ; vertical coord will always be the same
 70+  C8EA 3A 89 C8         ld a,(thepit_trapcount)         ; get the trap count
 71+  C8ED 5F               ld e,a                          ; store in e
 72+  C8EE 3E 16            ld a,22                         ; 21 is full trapdoor
 73+  C8F0 83               add a,e
 74+  C8F1 CD A7 A9         call screen_getblock
 75+  C8F4 CD 84 A9         call screen_showchar            ; show the char
 76+  C8F7
 77+  C8F7              thepit_process0:
 78+  C8F7 C9               ret
 79+  C8F8              thepit_process2:
 80+  C8F8 CD B9 BE         call player_pitkillplayer
 81+  C8FB C9               ret
 82+  C8FC
# file closed: game/thepit.asm
 48   C8FC                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  C8FC
  2+  C8FC              ;
  3+  C8FC              ; Where the monster currently is
  4+  C8FC              ;
  5+  C8FC              monster_currentcoords:
  6+  C8FC 00 00            defb 0,0
  7+  C8FE
  8+  C8FE              ;
  9+  C8FE              ; The start coords of the monster
 10+  C8FE              ;
 11+  C8FE              monster_initcoords:
 12+  C8FE 70 1B            defb 112,27
 13+  C900
 14+  C900              ;
 15+  C900              ; Store the memory location of the current jump position
 16+  C900              ;
 17+  C900              monster_jumppos:
 18+  C900 00 00            defb 0,0
 19+  C902
 20+  C902              ;
 21+  C902              ; The jump table for the monster.
 22+  C902              ;
 23+  C902              monster_jumptable:
 24+  C902 FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  C906 02 02 02 02
 24+  C90A 02 02 01 01
 24+  C90E 01 01 01 01
 24+  C912 FF
 25+  C913
 26+  C913              ;
 27+  C913              ; The vertical direction: 0 up, 1 down
 28+  C913              ;
 29+  C913              monster_jumpdirectionvert:
 30+  C913 00               defb 0
 31+  C914
 32+  C914              ;
 33+  C914              ; The horiz direction: 0 right, 1 left
 34+  C914              ;
 35+  C914              monster_jumpdirectionhoriz:
 36+  C914 00               defb 0
 37+  C915
 38+  C915              ;
 39+  C915              ; Frame offset, 0 or 32
 40+  C915              ;
 41+  C915              monster_frameoffset:
 42+  C915 00               defb 0
 43+  C916
 44+  C916              ;
 45+  C916              ; Monster tick
 46+  C916              ;
 47+  C916              monster_tick:
 48+  C916 00               defb 0
 49+  C917
 50+  C917              ;
 51+  C917              ; Initialises the pit monster
 52+  C917              ;
 53+  C917              monster_init:
 54+  C917 ED 4B FE C8      ld bc,(monster_initcoords)              ; load the initial coords
 55+  C91B ED 43 FC C8      ld (monster_currentcoords),bc           ; save in current coords
 56+  C91F 21 03 C9         ld hl,monster_jumptable+1
 57+  C922 22 00 C9         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 58+  C925 3E 00            ld a,0
 59+  C927 32 13 C9         ld (monster_jumpdirectionvert),a        ; going up
 60+  C92A 32 15 C9         ld (monster_frameoffset),a
 61+  C92D 32 16 C9         ld (monster_tick),a
 62+  C930 CD B0 C9         call monster_draw                       ; the monster
 63+  C933 C9               ret
 64+  C934
 65+  C934              ;
 66+  C934              ; Animate the monster
 67+  C934              ;
 68+  C934              monster_process:
 69+  C934 3A 16 C9         ld a,(monster_tick)                     ; check if we should draw this frame
 70+  C937 FE 01            cp 1
 71+  C939 CA 41 C9         jp z,monster_process6
 72+  C93C 3C               inc a
 73+  C93D 32 16 C9         ld (monster_tick),a                     ; increase the tick and continue
 74+  C940 C9               ret
 75+  C941              monster_process6:
 76+  C941 3E 00            ld a,0
 77+  C943 32 16 C9         ld (monster_tick),a                     ; zero the tick
 78+  C946 CD B0 C9         call monster_draw                       ; overwrite the old sprite
 79+  C949 3A 15 C9         ld a,(monster_frameoffset)              ; get the anim frame offset
 80+  C94C EE 20            xor 32                                  ; flip between 0 and 32
 81+  C94E 32 15 C9         ld (monster_frameoffset),a              ; store
 82+  C951 ED 4B FC C8      ld bc,(monster_currentcoords)           ; get the current coords
 83+  C955 2A 00 C9         ld hl,(monster_jumppos)                 ; get the position in the jump table
 84+  C958 56               ld d,(hl)                               ; get the jump modifier
 85+  C959 3A 13 C9         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 86+  C95C FE 00            cp 0                                    ; if 0, going up, so dec vert
 87+  C95E C2 67 C9         jp nz,monster_process0
 88+  C961 79               ld a,c
 89+  C962 92               sub d
 90+  C963 23               inc hl                                  ; move forward a jump pos
 91+  C964 C3 6A C9         jp monster_process1
 92+  C967              monster_process0:
 93+  C967 79               ld a,c                                   ; going down so inc c
 94+  C968 82               add a,d
 95+  C969 2B               dec hl                                  ; move back a jump pos
 96+  C96A              monster_process1:
 97+  C96A 4F               ld c,a                                  ; get the vertical coord back
 98+  C96B 7E               ld a,(hl)                               ; check the next jump pos
 99+  C96C FE FF            cp 255                                  ; if 255 reverse
100+  C96E CA 77 C9         jp z,monster_process3
101+  C971 22 00 C9         ld (monster_jumppos),hl                 ; store the new pos
102+  C974 C3 7F C9         jp monster_process2                     ; keep going
103+  C977              monster_process3:
104+  C977 3A 13 C9         ld a,(monster_jumpdirectionvert)        ; get the direction
105+  C97A EE 01            xor 1                                   ; flip it
106+  C97C 32 13 C9         ld (monster_jumpdirectionvert),a        ; store it
107+  C97F              monster_process2:
108+  C97F 3A 14 C9         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
109+  C982 FE 00            cp 0                                    ; is it right?
110+  C984 C2 99 C9         jp nz,monster_process4
111+  C987 04               inc b                                   ; 1 pixel right
112+  C988 78               ld a,b
113+  C989 FE 38            cp 56                                   ; reached the edge of the pit?
114+  C98B C2 A8 C9         jp nz,monster_process5
115+  C98E 3A 14 C9         ld a,(monster_jumpdirectionhoriz)
116+  C991 EE 01            xor 1
117+  C993 32 14 C9         ld (monster_jumpdirectionhoriz),a       ; flip direction
118+  C996 C3 A8 C9         jp monster_process5
119+  C999              monster_process4:
120+  C999 05               dec b                                   ; 1 pixel left
121+  C99A 78               ld a,b
122+  C99B FE 18            cp 24                                   ; reached the edge of the pit?
123+  C99D C2 A8 C9         jp nz,monster_process5
124+  C9A0 3A 14 C9         ld a,(monster_jumpdirectionhoriz)
125+  C9A3 EE 01            xor 1
126+  C9A5 32 14 C9         ld (monster_jumpdirectionhoriz),a       ; flip direction
127+  C9A8              monster_process5:
128+  C9A8 ED 43 FC C8      ld (monster_currentcoords),bc           ; store the new vertical coords
129+  C9AC CD B0 C9         call monster_draw                       ; finally, draw the monster
130+  C9AF C9               ret
131+  C9B0
132+  C9B0              ;
133+  C9B0              ; Draw the monster at the current location
134+  C9B0              ;
135+  C9B0              monster_draw:
136+  C9B0 ED 4B FC C8      ld bc,(monster_currentcoords)
137+  C9B4 3A 15 C9         ld a,(monster_frameoffset)
138+  C9B7 11 00 00         ld de,0
139+  C9BA 5F               ld e,a
140+  C9BB 21 CA B7         ld hl,monster_sprite                    ; load the first frame
141+  C9BE 19               add hl,de
142+  C9BF CD 8A AA         call sprites_draw2by2sprite
143+  C9C2 C9               ret
# file closed: game/monster.asm
 49   C9C3                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  C9C3
  2+  C9C3              ;
  3+  C9C3              ; Array of robot states
  4+  C9C3              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  C9C3              robots_robots:
  6+  C9C3 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  C9C7 00 00 00
  7+  C9CA 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  C9CE 00 00 00
  8+  C9D1 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  C9D5 00 00 00
  9+  C9D8 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  C9DC 00 00 00
 10+  C9DF 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  C9E3 00 00 00
 11+  C9E6
 12+  C9E6              robots_initcoords:
 13+  C9E6 18 E8            defb 24,232
 14+  C9E8
 15+  C9E8              ;
 16+  C9E8              ; When this reaches zero, spawn a new robot
 17+  C9E8              ;
 18+  C9E8              robots_spawntimer:
 19+  C9E8 FA               defb 250
 20+  C9E9
 21+  C9E9              ;
 22+  C9E9              ; When this reaches max, change the anim frame
 23+  C9E9              ;
 24+  C9E9              robots_animtimer:
 25+  C9E9 00               defb 0
 26+  C9EA
 27+  C9EA              ;
 28+  C9EA              ; When this reaches max, change move the robot
 29+  C9EA              ;
 30+  C9EA              robots_movetimer:
 31+  C9EA 00               defb 0
 32+  C9EB
 33+  C9EB
 34+  C9EB              ;
 35+  C9EB              ; The number of robots active
 36+  C9EB              ;
 37+  C9EB              robots_numberactive:
 38+  C9EB 00               defb 0
 39+  C9EC
 40+  C9EC              ;
 41+  C9EC              ; Tracks which directions a robot can move
 42+  C9EC              ; up,down,left,right
 43+  C9EC              robots_canmovedirections:
 44+  C9EC 00 00 00 00      defb 0,0,0,0
 45+  C9F0
 46+  C9F0              ;
 47+  C9F0              ; The current robot speed
 48+  C9F0              ;
 49+  C9F0              robots_robotspeed:
 50+  C9F0 02               defb 2
 51+  C9F1
 52+  C9F1              ;
 53+  C9F1              ; The current max robots
 54+  C9F1              ;
 55+  C9F1              robots_robotsmax:
 56+  C9F1 02               defb 2
 57+  C9F2
 58+  C9F2              ;
 59+  C9F2              ; Initialises the robots
 60+  C9F2              ;
 61+  C9F2              robots_init:
 62+  C9F2 06 23            ld b,35
 63+  C9F4 DD 21 C3 C9      ld ix,robots_robots
 64+  C9F8              robots_init0:
 65+  C9F8 DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 66+  C9FC DD 23            inc ix
 67+  C9FE 10 F8            djnz robots_init0
 68+  CA00 3E 00            ld a,0
 69+  CA02 32 EB C9         ld (robots_numberactive),a
 70+  CA05 3E FA            ld a,250
 71+  CA07 32 E8 C9         ld (robots_spawntimer),a
 72+  CA0A                  ; Self writing code
 73+  CA0A                  ; Robot speed
 74+  CA0A 3A F0 C9         ld a,(robots_robotspeed)
 75+  CA0D 32 A7 CA         ld (robots_process7+1),a
 76+  CA10 3C               inc a
 77+  CA11 32 D7 CA         ld (robots_process6+1),a
 78+  CA14                  ; Robots max
 79+  CA14 3A F1 C9         ld a,(robots_robotsmax)
 80+  CA17 32 22 CA         ld (robots_spawn+1),a
 81+  CA1A 32 79 CA         ld (robots_process8+1),a
 82+  CA1D 32 95 CA         ld (robots_process0+1),a
 83+  CA20 C9               ret
 84+  CA21
 85+  CA21              ;
 86+  CA21              ; Spawns a new robot
 87+  CA21              ; Inputs:
 88+  CA21              ; ix - pointer to start of robot array entry
 89+  CA21              ;
 90+  CA21              robots_spawn:
 91+  CA21 06 03            ld b,3                      ;(SELF WRITING CODE)
 92+  CA23 DD 21 C3 C9      ld ix,robots_robots
 93+  CA27              robots_spawn0:
 94+  CA27 DD 7E 02         ld a,(ix+2)                 ; get the state
 95+  CA2A FE 00            cp 0
 96+  CA2C C2 58 CA         jp nz,robots_spawn1         ; if already active, move on
 97+  CA2F ED 4B E6 C9      ld bc,(robots_initcoords)
 98+  CA33 DD 71 00 DD      ld (ix),bc
 98+  CA37 70 01
 99+  CA39 DD 36 02 01      ld (ix+2),1
100+  CA3D DD 36 03 00      ld (ix+3),0
101+  CA41 DD 36 04 00      ld (ix+4),0
102+  CA45 DD 36 05 00      ld (ix+5),0
103+  CA49 DD 36 06 00      ld (ix+6),0
104+  CA4D 3A EB C9         ld a,(robots_numberactive)
105+  CA50 3C               inc a
106+  CA51 32 EB C9         ld (robots_numberactive),a  ; increase the number active
107+  CA54 CD 0B CD         call robots_draw            ; draw initial frame
108+  CA57 C9               ret
109+  CA58              robots_spawn1:
110+  CA58 11 07 00         ld de,7
111+  CA5B DD 19            add ix,de
112+  CA5D 10 C8            djnz robots_spawn0
113+  CA5F C9               ret
114+  CA60              ;
115+  CA60              ; Kills robot
116+  CA60              ; Inputs:
117+  CA60              ; ix - pointer to start of robot array entry
118+  CA60              ;
119+  CA60              robots_kill:
120+  CA60 3A EB C9         ld a,(robots_numberactive)
121+  CA63 3D               dec a
122+  CA64 32 EB C9         ld (robots_numberactive),a
123+  CA67 DD 36 02 00      ld (ix+2),0                     ; set to inactive
124+  CA6B C5               push bc
125+  CA6C E5               push hl
126+  CA6D 06 01            ld b,1
127+  CA6F CD 9A C4         call scores_addhundreds
128+  CA72 E1               pop hl
129+  CA73 C1               pop bc
130+  CA74 C9               ret
131+  CA75
132+  CA75              ;
133+  CA75              ; Processes the robots
134+  CA75              ;
135+  CA75              robots_process:
136+  CA75 3A EB C9         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
137+  CA78              robots_process8:
138+  CA78 FE 03            cp 3                                    ; 3 is the maximum
139+  CA7A CA 94 CA         jp z,robots_process0                    ; if already three, nothing to do
140+  CA7D 3A E8 C9         ld a,(robots_spawntimer)                ; now check the spawn timer
141+  CA80 FE 00            cp 0
142+  CA82 C2 90 CA         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
143+  CA85 3E FA            ld a,250
144+  CA87 32 E8 C9         ld (robots_spawntimer),a                ; reset the spawn timer
145+  CA8A CD 21 CA         call robots_spawn                       ; spawn a robot
146+  CA8D C3 94 CA         jp robots_process0                      ; carry on
147+  CA90              robots_process1:
148+  CA90 3D               dec a
149+  CA91 32 E8 C9         ld (robots_spawntimer),a                ; decrease the spawn timer and store
150+  CA94              robots_process0:
151+  CA94 06 03            ld b,3                                  ; max number of robots (SELF WRITING CODE)
152+  CA96 DD 21 C3 C9      ld ix, robots_robots                    ; point ix at the robot array
153+  CA9A              robots_process2:
154+  CA9A C5               push bc
155+  CA9B DD 7E 02         ld a,(ix+2)                             ; check the state
156+  CA9E FE 00            cp 0
157+  CAA0 CA BC CA         jp z,robots_process3                    ; if not active, move on
158+  CAA3 3A EA C9         ld a,(robots_movetimer)
159+  CAA6              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
160+  CAA6 FE 04            cp 4
161+  CAA8 C2 BC CA         jp nz,robots_process3                   ; can we move this frame
162+  CAAB CD 0B CD         call robots_draw                        ; draw over existing
163+  CAAE CD E1 CA         call robots_move                        ; move the
164+  CAB1 DD 7E 02         ld a,(ix+2)                             ; get the state again
165+  CAB4 FE 00            cp 0
166+  CAB6 CA BC CA         jp z,robots_process3                    ; move to next if this robot has become inactive
167+  CAB9 CD 0B CD         call robots_draw                        ; draw the new robot
168+  CABC              robots_process3:
169+  CABC C1               pop bc
170+  CABD 11 07 00         ld de,7
171+  CAC0 DD 19            add ix,de
172+  CAC2 10 D6            djnz robots_process2
173+  CAC4 3A E9 C9         ld a,(robots_animtimer)
174+  CAC7 3C               inc a
175+  CAC8 FE 08            cp 8
176+  CACA C2 CF CA         jp nz,robots_process4
177+  CACD 3E 00            ld a,0                                  ; reset if we reached max
178+  CACF              robots_process4:
179+  CACF 32 E9 C9         ld (robots_animtimer),a
180+  CAD2 3A EA C9         ld a,(robots_movetimer)                 ; increment the robot move timer
181+  CAD5 3C               inc a
182+  CAD6              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
183+  CAD6 FE 05            cp 5                                    ; there is another reference to this number above
184+  CAD8 C2 DD CA         jp nz,robots_process5
185+  CADB 3E 00            ld a,0
186+  CADD              robots_process5:
187+  CADD 32 EA C9         ld (robots_movetimer),a
188+  CAE0
189+  CAE0 C9               ret
190+  CAE1
191+  CAE1
192+  CAE1              ;
193+  CAE1              ; Moves a robot
194+  CAE1              ; Inputs:
195+  CAE1              ; ix - points to first byte of robot in array
196+  CAE1              robots_move:
197+  CAE1 DD 7E 02         ld a,(ix+2)                             ; get the state
198+  CAE4 FE 02            cp 2
199+  CAE6 CA 17 CB         jp z,robots_move4                       ; don't move if shot, just change the anim
200+  CAE9 3A E9 C9         ld a,(robots_animtimer)                 ; get the anim timer
201+  CAEC FE 07            cp 7                                    ; compare with 8
202+  CAEE C2 01 CB         jp nz,robots_move1                       ; if even, don't increment frame
203+  CAF1 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
204+  CAF4 06 08            ld b,8
205+  CAF6 80               add a,b                                 ; add to anim frame
206+  CAF7 FE 20            cp 32
207+  CAF9 C2 FE CA         jp nz,robots_move0                      ; if not 32, then just store
208+  CAFC 3E 00            ld a,0                                  ; otherwise, reset
209+  CAFE              robots_move0:
210+  CAFE DD 77 04         ld (ix+4),a                             ; store
211+  CB01              robots_move1:
212+  CB01 DD 7E 05         ld a,(ix+5)
213+  CB04 FE 00            cp 0                                    ; are we automoving
214+  CB06 CA 0F CB         jp z,robots_move2                       ; if not, keep directions
215+  CB09 CD 2B CB         call robots_automove
216+  CB0C C3 13 CB         jp robots_move3
217+  CB0F              robots_move2:
218+  CB0F CD 5E CB         call robots_checkdirectionsandmove
219+  CB12 C9               ret
220+  CB13              robots_move3:
221+  CB13 CD 54 CD         call robots_checkforplayer              ; check to see if we collided with a player
222+  CB16 C9               ret
223+  CB17              robots_move4:
224+  CB17 DD 7E 04         ld a,(ix+4)
225+  CB1A FE 48            cp 72
226+  CB1C C2 25 CB         jp nz,robots_move5
227+  CB1F 3E 40            ld a,64
228+  CB21 DD 77 04         ld (ix+4),a
229+  CB24 C9               ret
230+  CB25              robots_move5:
231+  CB25 3E 48            ld a,72
232+  CB27 DD 77 04         ld (ix+4),a
233+  CB2A C9               ret
234+  CB2B
235+  CB2B
236+  CB2B              ;
237+  CB2B              ; Processes automove
238+  CB2B              ; Inputs:
239+  CB2B              ; ix - points to the current robot
240+  CB2B              ; a - number of frames left to move
241+  CB2B              robots_automove:
242+  CB2B 3D               dec a
243+  CB2C DD 77 05         ld (ix+5),a                         ; store the decreased frames
244+  CB2F DD 4E 00 DD      ld bc,(ix)                          ; get coords
244+  CB33 46 01
245+  CB35 DD 7E 06         ld a,(ix+6)                         ; get the direction
246+  CB38 FE 00            cp 0                                ; left
247+  CB3A CA 4B CB         jp z,robots_automove1
248+  CB3D FE 02            cp 2                                ; up
249+  CB3F CA 4F CB         jp z,robots_automove3
250+  CB42 FE 03            cp 3                                ; down
251+  CB44 CA 53 CB         jp z,robots_automove4
252+  CB47 04               inc b                               ; right
253+  CB48 C3 57 CB         jp robots_automove2
254+  CB4B              robots_automove1:
255+  CB4B 05               dec b
256+  CB4C C3 57 CB         jp robots_automove2
257+  CB4F              robots_automove3:
258+  CB4F 0D               dec c
259+  CB50 C3 57 CB         jp robots_automove2
260+  CB53              robots_automove4:
261+  CB53 0C               inc c
262+  CB54 C3 57 CB         jp robots_automove2
263+  CB57              robots_automove2:
264+  CB57 DD 71 00 DD      ld (ix),bc
264+  CB5B 70 01
265+  CB5D C9               ret
266+  CB5E
267+  CB5E              ;
268+  CB5E              ; Checks if a robot can move in all directions, then picks one and moves there.
269+  CB5E              ; This looks complicated, but really what it does is:
270+  CB5E              ; 1) Look at the current direction
271+  CB5E              ; 2) Randomly determine which orthoganal direction check first
272+  CB5E              ; 3) If orthogonal can't be moved, keep going in direction we're going
273+  CB5E              ; 4) Otherwise, back the way we came
274+  CB5E              ; Inputs:
275+  CB5E              ; ix - points to the current robot
276+  CB5E              ;
277+  CB5E              robots_checkdirectionsandmove:
278+  CB5E DD 7E 06         ld a,(ix+6)                 ; get the direction
279+  CB61 FE 00            cp 0                        ; left
280+  CB63 C2 8A CB         jp nz,robots_checkdirectionsandmove0
281+  CB66                  ; random check
282+  CB66 CD 85 BD         call game_getcurrentframe
283+  CB69 E6 01            and 1                       ; odd or even
284+  CB6B CA 77 CB         jp z,robots_checkdirectionsandmove3
285+  CB6E CD 10 CC         call robots_checkupthendown ; prefer up over down
286+  CB71 FE 01            cp 1
287+  CB73 C8               ret z
288+  CB74 C3 7D CB         jp robots_checkdirectionsandmove4
289+  CB77              robots_checkdirectionsandmove3:
290+  CB77 CD 06 CC         call robots_checkdownthenup ; prefer down over up
291+  CB7A FE 01            cp 1
292+  CB7C C8               ret z
293+  CB7D              robots_checkdirectionsandmove4:
294+  CB7D                  ; check left
295+  CB7D CD 94 CC         call robots_checkleftandmove
296+  CB80 FE 01            cp 1
297+  CB82 C8               ret z                       ; if we moved, don't check again
298+  CB83                  ; check right
299+  CB83 CD CD CC         call robots_checkrightandmove
300+  CB86 FE 01            cp 1
301+  CB88 C8               ret z                       ; if we moved, don't check again
302+  CB89                  ; if we're here and haven't moved...
303+  CB89 C9               ret
304+  CB8A              robots_checkdirectionsandmove0
305+  CB8A FE 01            cp 1                        ; right
306+  CB8C C2 B3 CB         jp nz,robots_checkdirectionsandmove1
307+  CB8F                  ; ALREADY MOVING RIGHT
308+  CB8F                  ; random check
309+  CB8F CD 85 BD         call game_getcurrentframe
310+  CB92 E6 01            and 1                       ; odd or even
311+  CB94 CA A0 CB         jp z,robots_checkdirectionsandmove5
312+  CB97 CD 06 CC         call robots_checkdownthenup ; prefer down over up
313+  CB9A FE 01            cp 1
314+  CB9C C8               ret z
315+  CB9D C3 A6 CB         jp robots_checkdirectionsandmove6
316+  CBA0              robots_checkdirectionsandmove5:
317+  CBA0 CD 10 CC         call robots_checkupthendown ; prefer down over up
318+  CBA3 FE 01            cp 1
319+  CBA5 C8               ret z
320+  CBA6              robots_checkdirectionsandmove6:
321+  CBA6                  ; check right
322+  CBA6 CD CD CC         call robots_checkrightandmove
323+  CBA9 FE 01            cp 1
324+  CBAB C8               ret z                       ; if we moved, don't check again
325+  CBAC                  ; check left
326+  CBAC CD 94 CC         call robots_checkleftandmove
327+  CBAF FE 01            cp 1
328+  CBB1 C8               ret z                       ; if we moved, don't check again
329+  CBB2                  ; if we're here and haven't moved...
330+  CBB2 C9               ret
331+  CBB3              robots_checkdirectionsandmove1
332+  CBB3 FE 02            cp 2                        ; up
333+  CBB5 C2 DC CB         jp nz,robots_checkdirectionsandmove2
334+  CBB8                  ; ALREADY MOVING UP
335+  CBB8                  ; random check
336+  CBB8 CD 85 BD         call game_getcurrentframe
337+  CBBB E6 01            and 1                       ; odd or even
338+  CBBD CA C9 CB         jp z,robots_checkdirectionsandmove7
339+  CBC0 CD 26 CC         call robots_checkleftthenright ; prefer left over right
340+  CBC3 FE 01            cp 1
341+  CBC5 C8               ret z
342+  CBC6 C3 CF CB         jp robots_checkdirectionsandmove8
343+  CBC9              robots_checkdirectionsandmove7:
344+  CBC9 CD 1C CC         call robots_checkrightthenleft ; prefer right over left
345+  CBCC FE 01            cp 1
346+  CBCE C8               ret z
347+  CBCF              robots_checkdirectionsandmove8:
348+  CBCF                  ; check up
349+  CBCF CD 32 CC         call robots_checkupandmove
350+  CBD2 FE 01            cp 1
351+  CBD4 C8               ret z                       ; if we moved, don't check again
352+  CBD5                  ; check down
353+  CBD5 CD 67 CC         call robots_checkdownandmove
354+  CBD8 FE 01            cp 1
355+  CBDA C8               ret z                       ; if we moved, don't check again
356+  CBDB                  ; if we're here and haven't moved...
357+  CBDB C9               ret
358+  CBDC              robots_checkdirectionsandmove2
359+  CBDC                  ; ALREADY MOVING DOWN
360+  CBDC                  ; random check
361+  CBDC CD 85 BD         call game_getcurrentframe
362+  CBDF E6 01            and 1                       ; odd or even
363+  CBE1 CA ED CB         jp z,robots_checkdirectionsandmove9
364+  CBE4 CD 1C CC         call robots_checkrightthenleft ; prefer right over left
365+  CBE7 FE 01            cp 1
366+  CBE9 C8               ret z
367+  CBEA C3 F3 CB         jp robots_checkdirectionsandmove10
368+  CBED              robots_checkdirectionsandmove9:
369+  CBED CD 26 CC         call robots_checkleftthenright ; prefer left over right
370+  CBF0 FE 01            cp 1
371+  CBF2 C8               ret z
372+  CBF3              robots_checkdirectionsandmove10:
373+  CBF3                  ; check down
374+  CBF3 CD 67 CC         call robots_checkdownandmove
375+  CBF6 FE 01            cp 1
376+  CBF8 C8               ret z                       ; if we moved, don't check again
377+  CBF9                  ; check right first
378+  CBF9 CD CD CC         call robots_checkrightandmove
379+  CBFC FE 01            cp 1
380+  CBFE C8               ret z                       ; if we moved, don't check again
381+  CBFF                  ; check up
382+  CBFF CD 32 CC         call robots_checkupandmove
383+  CC02 FE 01            cp 1
384+  CC04 C8               ret z                       ; if we moved, don't check again
385+  CC05                  ; if we're here and haven't moved...
386+  CC05 C9               ret
387+  CC06
388+  CC06              ;
389+  CC06              ; Different orders of checking directions, for pseudo random motion
390+  CC06              ;
391+  CC06              robots_checkdownthenup:
392+  CC06                  ; check down
393+  CC06 CD 67 CC         call robots_checkdownandmove
394+  CC09 FE 01            cp 1
395+  CC0B C8               ret z                       ; if we moved, don't check again
396+  CC0C                  ; check up
397+  CC0C CD 32 CC         call robots_checkupandmove
398+  CC0F C9               ret
399+  CC10
400+  CC10              robots_checkupthendown:
401+  CC10                  ; check up
402+  CC10 CD 32 CC         call robots_checkupandmove
403+  CC13 FE 01            cp 1
404+  CC15 C8               ret z
405+  CC16                  ; check down
406+  CC16 CD 67 CC         call robots_checkdownandmove
407+  CC19 FE 01            cp 1
408+  CC1B C9               ret
409+  CC1C              robots_checkrightthenleft:
410+  CC1C                  ; check right
411+  CC1C CD CD CC         call robots_checkrightandmove
412+  CC1F FE 01            cp 1
413+  CC21 C8               ret z                       ; if we moved, don't check again
414+  CC22                  ; check left
415+  CC22 CD 94 CC         call robots_checkleftandmove
416+  CC25 C9               ret
417+  CC26
418+  CC26              robots_checkleftthenright:
419+  CC26                  ; check left
420+  CC26 CD 94 CC         call robots_checkleftandmove
421+  CC29 FE 01            cp 1
422+  CC2B C8               ret z
423+  CC2C                  ; check right
424+  CC2C CD CD CC         call robots_checkrightandmove
425+  CC2F FE 01            cp 1
426+  CC31 C9               ret
427+  CC32
428+  CC32              ;
429+  CC32              ; Checks up for movement
430+  CC32              ; Outputs:
431+  CC32              ; a - 1 if have moved
432+  CC32              robots_checkupandmove:
433+  CC32                  ; check above
434+  CC32 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
434+  CC36 46 01
435+  CC38 79               ld a,c
436+  CC39 FE 20            cp 32
437+  CC3B D8               ret c
438+  CC3C CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
439+  CC3F 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
440+  CC41 11 20 00         ld de,32
441+  CC44 ED 52            sbc hl,de                       ; memory location of line above now in hl
442+  CC46 7E               ld a,(hl)                       ; get the contents of the line
443+  CC47 FE 00            cp 0
444+  CC49 C2 64 CC         jp nz,robots_checkupandmove0    ; can't move here so return
445+  CC4C DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
445+  CC50 46 01
446+  CC52 0D               dec c                       ; move up
447+  CC53 DD 71 00 DD      ld (ix),bc
447+  CC57 70 01
448+  CC59 DD 36 06 02      ld (ix+6),2
449+  CC5D DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
450+  CC61 3E 01            ld a,1
451+  CC63 C9               ret
452+  CC64              robots_checkupandmove0:
453+  CC64 3E 00            ld a,0
454+  CC66 C9               ret
455+  CC67
456+  CC67              ;
457+  CC67              ; Checks down for movement
458+  CC67              ; Outputs:
459+  CC67              ; a - 1 if have moved
460+  CC67              robots_checkdownandmove:
461+  CC67                  ; check below
462+  CC67 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
462+  CC6B 46 01
463+  CC6D CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
464+  CC70 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
465+  CC72 24               inc h                       ; memory location of cell beneath now in hl
466+  CC73 7E               ld a,(hl)                       ; get the contents of the line
467+  CC74 FE 00            cp 0
468+  CC76 C2 91 CC         jp nz,robots_checkdownandmove0    ; can't move here so return
469+  CC79 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
469+  CC7D 46 01
470+  CC7F 0C               inc c                       ; move up
471+  CC80 DD 71 00 DD      ld (ix),bc
471+  CC84 70 01
472+  CC86 DD 36 06 03      ld (ix+6),3
473+  CC8A DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
474+  CC8E 3E 01            ld a,1
475+  CC90 C9               ret
476+  CC91              robots_checkdownandmove0:
477+  CC91 3E 00            ld a,0
478+  CC93 C9               ret
479+  CC94
480+  CC94              ;
481+  CC94              ; Checks left for movement
482+  CC94              ; Outputs:
483+  CC94              ; a - 1 if have moved
484+  CC94              robots_checkleftandmove:
485+  CC94                  ; check below
486+  CC94 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
486+  CC98 46 01
487+  CC9A CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
488+  CC9D 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
489+  CC9F 78               ld a,b
490+  CCA0 06 08            ld b,8
491+  CCA2 90               sub b                           ; move one cell left
492+  CCA3 47               ld b,a
493+  CCA4 2B               dec hl                          ; memory location of cell to the right now in hl
494+  CCA5 CD 38 BB         call movement_spaceisempty       ; check space is empty
495+  CCA8 7B               ld a,e                          ; check space empty flag
496+  CCA9 FE 00            cp 0
497+  CCAB CA CA CC         jp z,robots_checkleftandmove0    ; if zero can't move
498+  CCAE DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
498+  CCB2 46 01
499+  CCB4 05               dec b
500+  CCB5 DD 71 00 DD      ld (ix),bc
500+  CCB9 70 01
501+  CCBB DD 36 06 00      ld (ix+6),0
502+  CCBF DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
503+  CCC3 DD 36 03 00      ld (ix+3),0                 ; set to right
504+  CCC7 3E 01            ld a,1
505+  CCC9 C9               ret
506+  CCCA              robots_checkleftandmove0:
507+  CCCA 3E 00            ld a,0
508+  CCCC C9               ret
509+  CCCD
510+  CCCD              ;
511+  CCCD              ; Checks right for movement
512+  CCCD              ; Outputs:
513+  CCCD              ; a - 1 if have moved
514+  CCCD              robots_checkrightandmove:
515+  CCCD                  ; check below
516+  CCCD DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
516+  CCD1 46 01
517+  CCD3 78               ld a,b
518+  CCD4 FE E8            cp 232
519+  CCD6 CA 08 CD         jp z,robots_checkrightandmove0  ; can't move if at edge
520+  CCD9 CD 21 AB         call sprites_scadd              ; get the memory location of cell into de
521+  CCDC 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
522+  CCDE 3E 08            ld a,8
523+  CCE0 80               add b                           ; move one cell right
524+  CCE1 47               ld b,a
525+  CCE2 23               inc hl                          ; memory location of cell to the right now in hl
526+  CCE3 CD 38 BB         call movement_spaceisempty       ; check space is empty
527+  CCE6 7B               ld a,e                          ; check space empty flag
528+  CCE7 FE 00            cp 0
529+  CCE9 CA 08 CD         jp z,robots_checkrightandmove0    ; if zero can't move
530+  CCEC DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
530+  CCF0 46 01
531+  CCF2 04               inc b
532+  CCF3 DD 71 00 DD      ld (ix),bc
532+  CCF7 70 01
533+  CCF9 DD 36 06 01      ld (ix+6),1
534+  CCFD DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
535+  CD01 DD 36 03 01      ld (ix+3),1                 ; set to right
536+  CD05 3E 01            ld a,1
537+  CD07 C9               ret
538+  CD08              robots_checkrightandmove0:
539+  CD08 3E 00            ld a,0
540+  CD0A C9               ret
541+  CD0B
542+  CD0B              ;
543+  CD0B              ; Draws a robot
544+  CD0B              ; Inputs:
545+  CD0B              ; ix - points to first byte of robot in array
546+  CD0B              robots_draw:
547+  CD0B DD 4E 00 DD      ld bc,(ix)
547+  CD0F 46 01
548+  CD11 21 0A B8         ld hl,robot_sprite                      ; set to the robot sprite
549+  CD14 DD 7E 02         ld a,(ix+2)                             ; get the state
550+  CD17 FE 02            cp 2                                    ; is this dying
551+  CD19 CA 34 CD         jp z,robots_draw1
552+  CD1C              robots_draw3:
553+  CD1C DD 7E 03         ld a,(ix+3)                             ; get the direction
554+  CD1F FE 00            cp 0
555+  CD21 CA 28 CD         jp z,robots_draw0                       ; if left, nothing to do
556+  CD24 11 20 00         ld de,32
557+  CD27 19               add hl,de                               ; add four frames to sprite
558+  CD28              robots_draw0:
559+  CD28 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
560+  CD2B 11 00 00         ld de,0
561+  CD2E 5F               ld e,a
562+  CD2F 19               add hl,de                               ; add to base
563+  CD30 CD 2C AA         call sprites_drawsprite
564+  CD33 C9               ret
565+  CD34              ;
566+  CD34              ; Dying
567+  CD34              ;
568+  CD34              robots_draw1:
569+  CD34 DD 7E 05         ld a,(ix+5)                             ; get anim frames
570+  CD37 FE 00            cp 0                                    ; if zero this is the first time around
571+  CD39 C2 44 CD         jp nz,robots_draw2
572+  CD3C 3E 18            ld a,24
573+  CD3E DD 77 05         ld (ix+5),a                             ; load up the anim frames
574+  CD41 C3 1C CD         jp robots_draw3                         ; return to main loop to draw as normal
575+  CD44              robots_draw2:
576+  CD44 3D               dec a
577+  CD45 DD 77 05         ld (ix+5),a
578+  CD48 FE 00            cp 0                                    ; have we reached the end yet
579+  CD4A C2 50 CD         jp nz, robots_draw4
580+  CD4D CD 60 CA         call robots_kill
581+  CD50              robots_draw4:
582+  CD50 C3 28 CD         jp robots_draw0
583+  CD53 C9               ret
584+  CD54
585+  CD54              ;
586+  CD54              ; Checks to see if the robot is hitting a player
587+  CD54              ; Inputs:
588+  CD54              ; ix - memory location of robot we're checking
589+  CD54              robots_checkforplayer:
590+  CD54 3A A1 BD         ld a,(player+11)     ; get player state
591+  CD57 FE 00            cp 0
592+  CD59 C0               ret nz               ; if already dying, don't kill again
593+  CD5A DD 4E 00 DD      ld bc,(ix)           ; get coords
593+  CD5E 46 01
594+  CD60 ED 5B 96 BD      ld de,(player)       ; get the player coords
595+  CD64 7B               ld a,e               ; get the vert coord first
596+  CD65 91               sub c                ; subtract the diamond vertical coord from players
597+  CD66 C6 08            add 8                ; add the max distance
598+  CD68 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
599+  CD6A D0               ret nc               ; if not, hasn't hit
600+  CD6B 7A               ld a,d               ; get the player horiz coord
601+  CD6C 90               sub b                ; subtract rock coord
602+  CD6D C6 08            add 8                ; add max distance
603+  CD6F FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
604+  CD71 D0               ret nc
605+  CD72 DD 36 02 00      ld (ix+2),0          ; mark as inactive
606+  CD76 CD BF BE         call player_robotkillplayer ; mark the player as killed
607+  CD79 C9               ret
# file closed: game/robots.asm
 50   CD7A                  include "game\bullet.asm"
# file opened: game/bullet.asm
  1+  CD7A              ;
  2+  CD7A              ; Current state: x & y coords (screen), direction (0 left, 1 right), state
  3+  CD7A              ;
  4+  CD7A              bullet_state:
  5+  CD7A 00 00 00 00      defb 0,0,0,0
  6+  CD7E
  7+  CD7E              ;
  8+  CD7E              ; Initialise a the bullet
  9+  CD7E              ;
 10+  CD7E              bullet_init:
 11+  CD7E DD 21 7A CD      ld ix,bullet_state
 12+  CD82 DD 36 00 00      ld (ix),0
 13+  CD86 DD 36 01 00      ld (ix+1),0
 14+  CD8A DD 36 02 00      ld (ix+2),0
 15+  CD8E DD 36 03 00      ld (ix+3),0
 16+  CD92 C9               ret
 17+  CD93
 18+  CD93              ;
 19+  CD93              ; Shoots the bullet
 20+  CD93              ;
 21+  CD93              bullet_shoot:
 22+  CD93 DD 21 7A CD      ld ix,bullet_state
 23+  CD97 ED 4B 96 BD      ld bc,(player)              ; get the player coords
 24+  CD9B 3A 98 BD         ld a,(player+2)             ; get the player direction
 25+  CD9E FE 01            cp 1                        ; going left?
 26+  CDA0 CA AE CD         jp z,bullet_shoot0
 27+  CDA3 3E 08            ld a,8
 28+  CDA5 80               add a,b                     ; going right so add eight to start coords
 29+  CDA6 47               ld b,a
 30+  CDA7 DD 36 02 01      ld (ix+2),1                 ; set right
 31+  CDAB C3 B7 CD         jp bullet_shoot1
 32+  CDAE              bullet_shoot0:
 33+  CDAE 78               ld a,b
 34+  CDAF 06 08            ld b,8
 35+  CDB1 90               sub b
 36+  CDB2 47               ld b,a                      ; going left so subtract eight to start coords
 37+  CDB3 DD 36 02 00      ld (ix+2),0                 ; set right
 38+  CDB7              bullet_shoot1:
 39+  CDB7 DD 71 00 DD      ld (ix),bc        ; store coords
 39+  CDBB 70 01
 40+  CDBD DD 36 03 01      ld (ix+3),1       ; set state to 1
 41+  CDC1 CD 17 CE         call bullet_draw ; draw the initial frame
 42+  CDC4 C9               ret
 43+  CDC5
 44+  CDC5              ;
 45+  CDC5              ; Performs bullet processing
 46+  CDC5              ;
 47+  CDC5              bullet_process:
 48+  CDC5 3A 7D CD         ld a,(bullet_state+3)       ; get the state
 49+  CDC8 FE 00            cp 0
 50+  CDCA C8               ret z                       ; don't draw if this has become inactive
 51+  CDCB CD 17 CE         call bullet_draw            ; delete current frame
 52+  CDCE CD DB CD         call bullet_move            ; move the bullet
 53+  CDD1 3A 7D CD         ld a,(bullet_state+3)       ; get the state
 54+  CDD4 FE 00            cp 0
 55+  CDD6 C8               ret z                       ; don't draw if this has become inactive
 56+  CDD7 CD 17 CE         call bullet_draw            ; draw new frame
 57+  CDDA C9               ret
 58+  CDDB
 59+  CDDB              ;
 60+  CDDB              ; Moves the bullet, checking for collisions
 61+  CDDB              ;
 62+  CDDB              bullet_move:
 63+  CDDB DD 21 7A CD      ld ix,bullet_state
 64+  CDDF DD 4E 00 DD      ld bc,(ix)
 64+  CDE3 46 01
 65+  CDE5 DD 7E 02         ld a,(ix+2)                 ; get the direction
 66+  CDE8 FE 00            cp 0                        ; going left?
 67+  CDEA CA F4 CD         jp z,bullet_move0
 68+  CDED 3E 08            ld a,8
 69+  CDEF 80               add b
 70+  CDF0 47               ld b,a                      ; add 8 since going right
 71+  CDF1 C3 F9 CD         jp bullet_move1
 72+  CDF4              bullet_move0:
 73+  CDF4 78               ld a,b
 74+  CDF5 06 08            ld b,8
 75+  CDF7 90               sub b
 76+  CDF8 47               ld b,a                      ; subtract 8 since going left
 77+  CDF9              bullet_move1:
 78+  CDF9 DD 71 00 DD      ld (ix),bc                  ; store new coords
 78+  CDFD 70 01
 79+  CDFF C5               push bc
 80+  CE00 CD 24 CE         call bullets_checkforrobot
 81+  CE03 C1               pop bc
 82+  CE04 FE 01            cp 1                        ; if we hit a robot, keep moving
 83+  CE06 C8               ret z
 84+  CE07 CD 21 AB         call sprites_scadd          ; get memory loc of this block into de
 85+  CE0A 21 60 00         ld hl,96
 86+  CE0D 19               add hl,de
 87+  CE0E 7E               ld a,(hl)                   ; get the content
 88+  CE0F FE 00            cp 0
 89+  CE11 C8               ret z                       ; if empty, continue
 90+  CE12 DD 36 03 00      ld (ix+3),0                 ; otherwise, mark bullet as inactive
 91+  CE16 C9               ret
 92+  CE17
 93+  CE17              ;
 94+  CE17              ; Draw the bullet
 95+  CE17              ;
 96+  CE17              bullet_draw:
 97+  CE17 ED 4B 7A CD      ld bc,(bullet_state)        ; get coords
 98+  CE1B 3E 1B            ld a,27
 99+  CE1D CD A7 A9         call screen_getblock        ; get the block address
100+  CE20 CD 2C AA         call sprites_drawsprite     ; draw the sprite
101+  CE23 C9               ret
102+  CE24
103+  CE24              ;
104+  CE24              ; Checks to see if the robot is hitting a bullet
105+  CE24              ; Outputs:
106+  CE24              ; a = 0 if not robot hit
107+  CE24              ; a = 1 if robot not hit
108+  CE24              bullets_checkforrobot:
109+  CE24 3E 00            ld a,0
110+  CE26 32 7A CE         ld (bullets_tmp),a
111+  CE29 3A F1 C9         ld a,(robots_robotsmax) ; robots to check
112+  CE2C 47               ld b,a
113+  CE2D FD 21 C3 C9      ld iy,robots_robots   ; start of robot array
114+  CE31              bullets_checkforrobot0:
115+  CE31 C5               push bc
116+  CE32 FD 7E 02         ld a,(iy+2)             ; get the state
117+  CE35 FE 01            cp 1
118+  CE37 C2 6E CE         jp nz,bullets_checkforrobot1 ; if not active, don't check
119+  CE3A FD 5E 00 FD      ld de,(iy)              ; get robot coords
119+  CE3E 56 01
120+  CE40 7A               ld a,d
121+  CE41 E6 F8            and 248                 ; get nearest multiple of 8
122+  CE43 57               ld d,a
123+  CE44 ED 4B 7A CD      ld bc,(bullet_state)    ; get bullet coords
124+  CE48 7A               ld a,d               ; get the player horiz coord
125+  CE49 90               sub b                ; subtract robot coord
126+  CE4A FE 00            cp 0                ; should be the same
127+  CE4C C2 58 CE         jp nz,bullets_checkforrobot2 ; if not, might have hit, so check the next char along... if matched, check vert
128+  CE4F 3E 08            ld a,8
129+  CE51 82               add a,d
130+  CE52 90               sub b                ; check again for the next char along
131+  CE53 FE 00            cp 0
132+  CE55 C2 6E CE         jp nz,bullets_checkforrobot1 ; if not, haven't hit
133+  CE58              bullets_checkforrobot2:
134+  CE58 7B               ld a,e               ; get the vert coord
135+  CE59 91               sub c                ; subtract the bullet vertical coord from robots
136+  CE5A C6 04            add 4                ; add the max distance
137+  CE5C FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
138+  CE5E D2 6E CE         jp nc,bullets_checkforrobot1   ; if not, hasn't hit
139+  CE61 FD 36 02 02      ld (iy+2),2             ; mark the robot as killed
140+  CE65 FD 36 05 00      ld (iy+5),0             ; mark the anim frames as zero
141+  CE69 3E 01            ld a,1
142+  CE6B 32 7A CE         ld (bullets_tmp),a      ; hit the flag to say we killed a robot
143+  CE6E              bullets_checkforrobot1:
144+  CE6E 11 07 00         ld de,7
145+  CE71 FD 19            add iy,de              ; move to next robot
146+  CE73 C1               pop bc
147+  CE74 10 BB            djnz bullets_checkforrobot0
148+  CE76 3A 7A CE         ld a,(bullets_tmp)
149+  CE79 C9               ret
150+  CE7A
151+  CE7A              bullets_tmp:
152+  CE7A 00               defb 0
153+  CE7B
# file closed: game/bullet.asm
 51   CE7B
 52   CE7B              ;===========================================================================
 53   CE7B              ; main routine - the code execution starts here.
 54   CE7B              ; Sets up the new interrupt routine, the memory
 55   CE7B              ; banks and jumps to the start loop.
 56   CE7B              ;===========================================================================
 57   CE7B              main:
 58   CE7B CD 21 AF         call options_show
 59   CE7E
 60   CE7E                  ; Draw the title screen
 61   CE7E              main_titlescreen:
 62   CE7E CD 4B AB         call titlescreen_show
 63   CE81 CD DC BD         call player_init_gamestart
 64   CE84
 65   CE84              main_lifestart:
 66   CE84
 67   CE84 CD 02 BE         call player_init_lifestart
 68   CE87
 69   CE87 CD CB AC         call lifescreen_draw        ; show the lives remaining screen
 70   CE8A
 71   CE8A CD 00 80         call init_start
 72   CE8D CD 23 A8         call screen_draw
 73   CE90 CD 72 A7         call buffer_allbuffertoscreen
 74   CE93
 75   CE93 CD DA C6         call missiles_init
 76   CE96 CD F1 BF         call ship_land              ; land the ship
 77   CE99 CD 04 C1         call tank_init
 78   CE9C CD A2 C6         call diamonds_init
 79   CE9F CD 8B C8         call thepit_init
 80   CEA2 CD 17 C9         call monster_init
 81   CEA5 CD F2 C9         call robots_init
 82   CEA8 CD 7E CD         call bullet_init
 83   CEAB
 84   CEAB              mloop:
 85   CEAB                  ;halt
 86   CEAB CD DF CE         call main_loop_processing
 87   CEAE
 88   CEAE                  ;
 89   CEAE                  ; Check if the player died
 90   CEAE                  ;
 91   CEAE 21 A0 BD         ld hl,player+10
 92   CEB1 7E               ld a,(hl)                   ; check if the player died this frame
 93   CEB2 FE 01            cp 1
 94   CEB4 C2 CB CE         jp nz,mloop0
 95   CEB7 CD 81 BE         call player_died        ; do end of life housekeeping
 96   CEBA 06 28            ld b,40
 97   CEBC CD 9B 80         call utilities_pauseforframes
 98   CEBF 21 9F BD         ld hl,player+9        ; check lives remaining
 99   CEC2 7E               ld a,(hl)
100   CEC3 FE 00            cp 0
101   CEC5 CA 13 CF         jp z,main_gameover   ; leave the loop if we're done
102   CEC8 C3 84 CE         jp main_lifestart    ; otherwise, start a new life
103   CECB              mloop0:
104   CECB                  ;
105   CECB                  ; Check if the player completed the level
106   CECB                  ;
107   CECB 21 A3 BD         ld hl,player+13
108   CECE 7E               ld a,(hl)
109   CECF FE 01            cp 1
110   CED1 C2 AB CE         jp nz,mloop
111   CED4 CD BB BF         call player_checkforexit
112   CED7 FE 01            cp 1                        ; look at return, if 1, level has been completed
113   CED9 CA 19 CF         jp z,main_endlevel          ; jump to level transition screen
114   CEDC C3 AB CE         jp mloop                ; start the loop again
115   CEDF
116   CEDF
117   CEDF              main_loop_processing:
118   CEDF
119   CEDF CD 31 A7         call buffer_buffertoscreen  ; copy buffer to screen
120   CEE2 CD 96 A6         call buffer_clearlist       ; zero the updated lines list
121   CEE5 CD A6 BD         call player_getlocation     ; figure out where the player is
122   CEE8 CD C5 BE         call player_drawplayer      ; delete player
123   CEEB CD 5A B8         call control_input          ; check input
124   CEEE CD C5 BE         call player_drawplayer      ; draw player
125   CEF1 CD 33 C1         call tank_process           ; prcoess the tank
126   CEF4 CD DC BF         call ship_process           ; proces the ship
127   CEF7 CD 37 C3         call rocks_processrocks     ; process falling rocks
128   CEFA CD 96 C8         call thepit_process         ; process the pit trap
129   CEFD CD 02 C7         call missiles_process       ; process missiles
130   CF00 CD 34 C9         call monster_process        ; process monster
131   CF03 CD 75 CA         call robots_process         ; process robots
132   CF06 CD C5 CD         call bullet_process         ; process the bullet
133   CF09 CD 81 C6         call diamonds_twinkle       ; make the diamonds twinkle
134   CF0C CD AA C4         call scores_printscore      ; update the score on screen
135   CF0F CD 76 BD         call game_incrementframe    ; increment the game frame
136   CF12
137   CF12 C9               ret
138   CF13
139   CF13              main_gameover:
140   CF13 CD 2B AD         call gameover_draw          ; show the game over screen
141   CF16 C3 7E CE         jp main_titlescreen         ; go back to title
142   CF19
143   CF19              main_endlevel:
144   CF19 CD 5B BE         call player_recordcurrentstate
145   CF1C CD 19 AE         call endlevel_draw          ; show the end level screen
146   CF1F C3 84 CE         jp main_lifestart           ; start a new life
147   CF22
148   CF22              ;===========================================================================
149   CF22              ; Stack.
150   CF22              ;===========================================================================
151   CF22
152   CF22              ; Stack: this area is reserved for the stack
153   CF22              STACK_SIZE: equ 100    ; in words
154   CF22
155   CF22              ; Reserve stack space
156   CF22 00 00            defw 0  ; WPMEM, 2
157   CF24              stack_bottom:
158   CF24 00 00 00...      defs    STACK_SIZE*2, 0
159   CFEC              stack_top:
160   CFEC 00 00            defw 0  ; WPMEM, 2
161   CFEE
162   CFEE                     SAVESNA "ThePit.sna", main
# file closed: main.asm
