# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 67 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 70 A7         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 71 A7         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 A6 A5         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD 94 BB         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8051 C9               ret                 ; key was pressed.
 53+  8052
 54+  8052              ;
 55+  8052              ; Waits number of frames for keypress. If got, returns 1, if not 0
 56+  8052              ; Inputs:
 57+  8052              ; a - number of frames to waits
 58+  8052              ; Ouputs:
 59+  8052              ; e - 0 not pressed, 1 pressed
 60+  8052              utilities_waitforkey_forframes:
 61+  8052 21 08 5C         ld hl,23560         ; LAST K system variable.
 62+  8055 36 00            ld (hl),0           ; put null value there.
 63+  8057 47               ld b,a              ; number of frames to wait
 64+  8058              utilities_waitforkey_forframes0:
 65+  8058 7E               ld a,(hl)           ; new value of LAST K.
 66+  8059 FE 00            cp 0                ; is it still zero?
 67+  805B 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 68+  805D 1E 01            ld e,1              ; set the pressed flag
 69+  805F C9               ret                 ; key was pressed.
 70+  8060              utilities_waitforkey_forframes1:
 71+  8060 76               halt                ; wait for frame
 72+  8061 76               halt                ; wait for frame
 73+  8062 10 F4            djnz utilities_waitforkey_forframes0 ; loop again
 74+  8064 1E 00            ld e,0              ; nothing pressed in time
 75+  8066 C9               ret
 76+  8067
 77+  8067              ;
 78+  8067              ; Clears the screen
 79+  8067              ; Inputs:
 80+  8067              ; a - attribute colour
 81+  8067              utilities_clearscreen:
 82+  8067 76               halt
 83+  8068 21 00 58         ld hl,22528         ; attr
 84+  806B 11 01 58         ld de,22529         ; attr+1
 85+  806E 01 FF 02         ld bc,767
 86+  8071 77               ld (hl),a
 87+  8072 ED B0            ldir
 88+  8074
 89+  8074 21 00 40         ld hl, 16384        ;pixels
 90+  8077 11 01 40         ld de, 16385        ;pixels + 1
 91+  807A 01 FF 17         ld bc, 6143         ;pixels area length - 1
 92+  807D 36 00            ld (hl), 0          ;set first byte to '0'
 93+  807F ED B0            ldir                ;copy bytes
 94+  8081
 95+  8081 C9               ret
 96+  8082
 97+  8082              ;
 98+  8082              ; Wait for a number of frames
 99+  8082              ; Inputs:
100+  8082              ; b - number of frames
101+  8082              utilities_pauseforframes:
102+  8082 76               halt
103+  8083 10 FD            djnz utilities_pauseforframes
104+  8085 C9               ret
105+  8086
106+  8086              utilities_readkey:
107+  8086 21 A6 80         LD HL,utilties_keymap              ; Point HL at the keyboard list
108+  8089 16 08            LD D,8                                  ; This is the number of ports (rows) to check
109+  808B 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
110+  808D              utilities_readkey_0:
111+  808D 46               LD B,(HL)                               ; Get the keyboard port address from table
112+  808E 23               INC HL                                  ; Increment to list of keys
113+  808F ED 78            IN A,(C)                                ; Read the row of keys in
114+  8091 E6 1F            AND $1F                                     ; We are only interested in the first five bits
115+  8093 1E 05            LD E,5                                  ; This is the number of keys in the row
116+  8095              utilities_readkey_1:
117+  8095 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
118+  8097 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
119+  8099 23               INC HL                                  ; Go to next table address
120+  809A 1D               DEC E                                   ; Decrement key loop counter
121+  809B 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
122+  809D 15               DEC D                                   ; Decrement row loop counter
123+  809E 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
124+  80A0 A7               AND A                                   ; Clear A (no key found)
125+  80A1 C3 86 80         jp utilities_readkey
126+  80A4              utilities_readkey_2:
127+  80A4 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
128+  80A5 C9               RET
129+  80A6
130+  80A6              utilties_keymap:
131+  80A6 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
131+  80AA 43 56
132+  80AC FD 41 53 44      defb $FD,"A","S","D","F","G"
132+  80B0 46 47
133+  80B2 FB 51 57 45      defb $FB,"Q","W","E","R","T"
133+  80B6 52 54
134+  80B8 F7 31 32 33      defb $F7,"1","2","3","4","5"
134+  80BC 34 35
135+  80BE EF 30 39 38      defb $EF,"0","9","8","7","6"
135+  80C2 37 36
136+  80C4 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
136+  80C8 55 59
137+  80CA BF 23 4C 4B      defb $BF,"#","L","K","J","H"
137+  80CE 4A 48
138+  80D0 7F 20 23 4D      defb $7F," ","#","M","N","B"
138+  80D4 4E 42
139+  80D6
140+  80D6
141+  80D6              ;
142+  80D6              ; Generates a randomish number in the range 0 to e
143+  80D6              ; Inputs:
144+  80D6              ; e - upper value
145+  80D6              ; Outputs:
146+  80D6              ; a - random number
147+  80D6              utilities_randomupper
148+  80D6 3A 6A BB         ld a,(game_framenumber)
149+  80D9 6F               ld l,a
150+  80DA 26 00            ld h,0
151+  80DC 16 00            ld d,0
152+  80DE 42 4B            ld bc,de
153+  80E0              utilities_randomupper0:
154+  80E0 B7               or a
155+  80E1 ED 42            sbc hl,bc
156+  80E3 F2 E0 80         jp p,utilities_randomupper0
157+  80E6 09               add hl,bc
158+  80E7 01 00 00         ld bc,0
159+  80EA 09               add hl,bc
160+  80EB 7D               ld a,l
161+  80EC C9               ret
# file closed: utilities.asm
 22   80ED                  include "strings.asm"
# file opened: strings.asm
  1+  80ED              string_score1:
  2+  80ED 04 00 53 43      defb 4,0,'SCORE1',255
  2+  80F1 4F 52 45 31
  2+  80F5 FF
  3+  80F6              string_scorenumbers1:
  4+  80F6 04 01 30 30      defb 4,1,'000000',255
  4+  80FA 30 30 30 30
  4+  80FE FF
  5+  80FF              string_company:
  6+  80FF 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  8103 4E 54 55 52
  6+  8107 49 FF
  7+  8109              string_credits:
  8+  8109 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  810D 41 59 45 52
  8+  8111 20 31 FF
  9+  8114              string_score2:
 10+  8114 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8118 4F 52 45 32
 10+  811C FF
 11+  811D              string_scorenumbers2:
 12+  811D 16 01 30 30      defb 22,1,'000000',255
 12+  8121 30 30 30 30
 12+  8125 FF
 13+  8126              string_titlescreen_copyright:
 14+  8126 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 14+  812A 39 38 32 20
 14+  812E 20 43 45 4E
 14+  8132 54 55 52 49
 14+  8136 20 49 4E 43
 14+  813A FF
 15+  813B
 16+  813B
 17+  813B              string_alttitlescreen_1:
 18+  813B 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  813F 45 44 49 54
 18+  8143 53 20 31 FF
 19+  8147              string_alttitlescreen_2:
 20+  8147 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  814B 20 20 20 20
 20+  814F 20 20 20 20
 20+  8153 20 54 48 45
 20+  8157 20 4F 42 4A
 20+  815B 45 43 54 FE
 21+  815F 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  8163 20 20 20 20
 21+  8167 20 20 20 20
 21+  816B 4F 46 20 54
 21+  816F 48 49 53 20
 21+  8173 47 41 4D 45
 21+  8177 FE
 22+  8178 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  817C 20 20 20 20
 22+  8180 20 20 20 49
 22+  8184 53 20 54 4F
 22+  8188 20 44 49 47
 22+  818C 20 44 4F 57
 22+  8190 4E FE
 23+  8192 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  8196 20 20 20 20
 23+  819A 20 20 54 4F
 23+  819E 20 54 48 45
 23+  81A2 20 42 4F 54
 23+  81A6 54 4F 4D 20
 23+  81AA 50 49 54 FE
 24+  81AE 00 06 20 20      defb 0,6,'               AND',254
 24+  81B2 20 20 20 20
 24+  81B6 20 20 20 20
 24+  81BA 20 20 20 20
 24+  81BE 20 41 4E 44
 24+  81C2 FE
 25+  81C3 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  81C7 20 20 20 20
 25+  81CB 20 20 43 4F
 25+  81CF 4C 4C 45 43
 25+  81D3 54 20 41 54
 25+  81D7 20 4C 45 41
 25+  81DB 53 54 FE
 26+  81DE 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  81E2 20 20 20 20
 26+  81E6 20 20 20 4F
 26+  81EA 4E 45 20 4C
 26+  81EE 41 52 47 45
 26+  81F2 20 4A 45 57
 26+  81F6 45 4C FE
 27+  81F9 00 09 20 20      defb 0,9,'              THEN',254
 27+  81FD 20 20 20 20
 27+  8201 20 20 20 20
 27+  8205 20 20 20 20
 27+  8209 54 48 45 4E
 27+  820D FE
 28+  820E 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  8212 20 20 20 20
 28+  8216 20 20 20 52
 28+  821A 45 54 55 52
 28+  821E 4E 20 54 4F
 28+  8222 20 53 48 49
 28+  8226 50 FE
 29+  8228 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  822C 20 20 20 20
 29+  8230 20 20 20 54
 29+  8234 48 52 55 20
 29+  8238 55 50 50 45
 29+  823C 52 20 50 49
 29+  8240 54 FF
 30+  8242              string_alttitlescreen_3:
 31+  8242 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  8246 20 20 53 49
 31+  824A 4E 47 4C 45
 31+  824E 20 42 4F 4E
 31+  8252 55 53 20 20
 31+  8256 35 30 30 30
 31+  825A 20 50 4F 49
 31+  825E 4E 54 53 FE
 32+  8262 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  8266 20 20 20 20
 32+  826A 43 4F 4C 4C
 32+  826E 45 43 54 20
 32+  8272 31 20 4C 41
 32+  8276 52 47 45 20
 32+  827A 4A 45 57 45
 32+  827E 4C FE
 33+  8280 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  8284 20 20 20 20
 33+  8288 20 41 4E 44
 33+  828C 20 52 45 54
 33+  8290 55 52 4E 20
 33+  8294 54 4F 20 53
 33+  8298 48 49 50 FE
 34+  829C 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  82A0 20 20 44 4F
 34+  82A4 55 42 4C 45
 34+  82A8 20 42 4F 4E
 34+  82AC 55 53 20 20
 34+  82B0 31 30 30 30
 34+  82B4 30 20 50 4F
 34+  82B8 49 4E 54 53
 34+  82BC FE
 35+  82BD 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  82C1 20 20 43 4F
 35+  82C5 4C 4C 45 43
 35+  82C9 54 20 41 4C
 35+  82CD 4C 20 33 20
 35+  82D1 4C 41 52 47
 35+  82D5 45 20 4A 45
 35+  82D9 57 45 4C 53
 35+  82DD FE
 36+  82DE 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  82E2 20 20 20 20
 36+  82E6 20 4F 52 20
 36+  82EA 20 20 41 4C
 36+  82EE 4C 20 34 20
 36+  82F2 53 4D 41 4C
 36+  82F6 4C 20 4A 45
 36+  82FA 57 45 4C 53
 36+  82FE FE
 37+  82FF 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  8303 20 20 54 52
 37+  8307 49 50 4C 45
 37+  830B 20 42 4F 4E
 37+  830F 55 53 20 20
 37+  8313 31 35 30 30
 37+  8317 30 20 50 4F
 37+  831B 49 4E 54 53
 37+  831F FE
 38+  8320 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  8324 20 20 20 20
 38+  8328 20 43 4F 4C
 38+  832C 4C 45 43 54
 38+  8330 20 41 4C 4C
 38+  8334 20 37 20 4A
 38+  8338 45 57 45 4C
 38+  833C 53 FF
 39+  833E
 40+  833E              string_lifescreen_player:
 41+  833E 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  8342 4C 41 59 45
 41+  8346 52 20 31 20
 41+  834A FF
 42+  834B              string_lifescreen_lives:
 43+  834B 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  834F 4D 45 4E 20
 43+  8353 4C 45 46 54
 43+  8357 FF
 44+  8358              string_lifescreen_lastman:
 45+  8358 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  835C 53 54 20 4D
 45+  8360 41 4E FF
 46+  8363
 47+  8363              string_gameoverscreen_gameover:
 48+  8363 0B 06 47 41      defb 11,6,'GAME OVER',255
 48+  8367 4D 45 20 4F
 48+  836B 56 45 52 FF
 49+  836F              string_gameoverscreen_copyright:
 50+  836F 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 50+  8373 39 38 32 20
 50+  8377 43 45 4E 54
 50+  837B 55 52 49 20
 50+  837F 49 4E 43 FF
 51+  8383              string_gameoverscreen_bestscores:
 52+  8383 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  8387 53 54 20 53
 52+  838B 43 4F 52 45
 52+  838F 53 20 54 4F
 52+  8393 44 41 59 FF
 53+  8397              string_gameover_credits:
 54+  8397 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  839B 45 44 49 54
 54+  839F 53 20 30 FF
 55+  83A3
 56+  83A3              string_highscore_congratulations:
 57+  83A3 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 57+  83A7 4E 47 52 41
 57+  83AB 54 55 4C 41
 57+  83AF 54 49 4F 4E
 57+  83B3 53 FF
 58+  83B5              string_highscore_player1:
 59+  83B5 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 59+  83B9 41 59 45 52
 59+  83BD 20 31 FF
 60+  83C0              string_highscore_player2:
 61+  83C0 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 61+  83C4 41 59 45 52
 61+  83C8 20 32 FF
 62+  83CB              string_highscore_youhaveearned:
 63+  83CB 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 63+  83CF 55 20 48 41
 63+  83D3 56 45 20 45
 63+  83D7 41 52 4E 45
 63+  83DB 44 FF
 64+  83DD              string_highscore_place1:
 65+  83DD 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 65+  83E1 45 20 47 52
 65+  83E5 45 41 54 45
 65+  83E9 53 54 20 53
 65+  83ED 43 4F 52 45
 65+  83F1 FF
 66+  83F2              string_highscore_place2:
 67+  83F2 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 67+  83F6 45 20 32 4E
 67+  83FA 44 20 42 45
 67+  83FE 53 54 20 53
 67+  8402 43 4F 52 45
 67+  8406 FF
 68+  8407              string_highscore_place3:
 69+  8407 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 69+  840B 45 20 33 52
 69+  840F 44 20 42 45
 69+  8413 53 54 20 53
 69+  8417 43 4F 52 45
 69+  841B FF
 70+  841C              string_highscore_pleaseenter
 71+  841C 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 71+  8420 43 4F 52 44
 71+  8424 20 59 4F 55
 71+  8428 52 20 49 4E
 71+  842C 49 54 49 41
 71+  8430 4C 53 20 42
 71+  8434 45 4C 4F 57
 71+  8438 FF
 72+  8439
 73+  8439              string_endlevel_youhaveearned:
 74+  8439 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 74+  843D 55 20 48 41
 74+  8441 56 45 20 45
 74+  8445 41 52 4E 45
 74+  8449 44 FF
 75+  844B              string_endlevel_bonus1:
 76+  844B 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 76+  844F 4E 47 4C 45
 76+  8453 20 42 4F 4E
 76+  8457 55 53 FF
 77+  845A              string_endlevel_bonus2:
 78+  845A 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 78+  845E 55 42 4C 45
 78+  8462 20 42 4F 4E
 78+  8466 55 53 FF
 79+  8469              string_endlevel_bonus3:
 80+  8469 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 80+  846D 49 50 4C 45
 80+  8471 20 42 4F 4E
 80+  8475 55 53 FF
 81+  8478              string_endlevel_points1:
 82+  8478 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 82+  847C 30 30 20 50
 82+  8480 4F 49 4E 54
 82+  8484 53 FF
 83+  8486              string_endlevel_points2:
 84+  8486 09 0F 31 30      defb 9,15,'10000 POINTS',255
 84+  848A 30 30 30 20
 84+  848E 50 4F 49 4E
 84+  8492 54 53 FF
 85+  8495              string_endlevel_points3:
 86+  8495 09 0F 31 35      defb 9,15,'15000 POINTS',255
 86+  8499 30 30 30 20
 86+  849D 50 4F 49 4E
 86+  84A1 54 53 FF
 87+  84A4              string_endlevel_anothergo:
 88+  84A4 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 88+  84A8 56 45 20 41
 88+  84AC 4E 4F 54 48
 88+  84B0 45 52 20 47
 88+  84B4 4F FF
 89+  84B6
 90+  84B6              string_zonk:
 91+  84B6 00 00 5A 4F      defb 0,0,'ZONK!',255
 91+  84BA 4E 4B 21 FF
 92+  84BE              ;
 93+  84BE              ; Prints specified string
 94+  84BE              ; Inputs:
 95+  84BE              ; de: pointer to string
 96+  84BE              ; bc: length of string
 97+  84BE              ;
 98+  84BE              ; Print String Data
 99+  84BE              ; First two bytes of string contain X and Y char position, then the string
100+  84BE              ; Individual strings are terminated with 0xFE
101+  84BE              ; End of data is terminated with 0xFF
102+  84BE              ; HL: Address of string
103+  84BE              ;
104+  84BE 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
105+  84BF 23                                   INC HL                          ; Increase HL to the next memory location
106+  84C0 56                                   LD D,(HL)                       ; Fetch the Y coordinate
107+  84C1 23                                   INC HL                          ; Increase HL to the next memory location
108+  84C2 CD D5 84                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
109+  84C5 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
110+  84C6 23                                   INC HL                          ; Increase HL to the next character
111+  84C7 FE FE                                CP 0xFE                         ; Compare with 0xFE
112+  84C9 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
113+  84CB D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
114+  84CC E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
115+  84CD CD E5 84                             CALL Print_Char                 ; Print the character
116+  84D0 E1                                   POP HL                          ; Retrieve HL back off the stack
117+  84D1 1C                                   INC E                           ; Go to the next screen address
118+  84D2 18 F1                                JR string_print_0               ; Loop back to print next character
119+  84D4 C9                                   RET
120+  84D5
121+  84D5              ; Get screen address
122+  84D5              ; D = Y character position
123+  84D5              ; E = X character position
124+  84D5              ; Returns address in DE
125+  84D5              ;
126+  84D5 7A           string_getcharaddress:       LD A,D
127+  84D6 E6 07                                AND %00000111
128+  84D8 1F                                   RRA
129+  84D9 1F                                   RRA
130+  84DA 1F                                   RRA
131+  84DB 1F                                   RRA
132+  84DC B3                                   OR E
133+  84DD 5F                                   LD E,A
134+  84DE 7A                                   LD A,D
135+  84DF E6 18                                AND %00011000
136+  84E1 F6 40                                OR %01000000
137+  84E3 57                                   LD D,A
138+  84E4 C9                                   RET                             ; Returns screen address in DE
139+  84E5
140+  84E5              ; Print a single character out
141+  84E5              ; A:  Character to print
142+  84E5              ; DE: Screen address to print character at
143+  84E5              ;
144+  84E5 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
145+  84E8 06 00                                LD B,0                          ; Set BC to A
146+  84EA 4F                                   LD C,A
147+  84EB E6 FF                                AND 0xFF                        ; Clear the carry bit
148+  84ED CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
149+  84EF CB 10                                RL B
150+  84F1 CB 11                                RL C
151+  84F3 CB 10                                RL B
152+  84F5 CB 11                                RL C
153+  84F7 CB 10                                RL B
154+  84F9 09                                   ADD HL,BC                       ; Get the character address in HL
155+  84FA 0E 08                                LD C,8                          ; Loop counter
156+  84FC D5                                   PUSH DE
157+  84FD 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
158+  84FE 12                                   LD (DE),A                       ; Stick A onto the screen
159+  84FF 14                                   INC D                           ; Goto next line on screen
160+  8500 2C                                   INC L                           ; Goto next byte of character
161+  8501 0D                                   DEC C                           ; Decrease the loop counter
162+  8502 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
163+  8504 D1                                   POP DE
164+  8505 C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   8506                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  8506              buffer_buffer:
  2+  8506 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A206
  4+  A206              buffer_attr_buffer:
  5+  A206 00 00 00...      defs 928                    ; attrs buffer area
  6+  A5A6
  7+  A5A6              buffer_tmp:
  8+  A5A6 00 00            defb 0,0                    ; temp area
  9+  A5A8
 10+  A5A8              ;
 11+  A5A8              ; This list stores lines to be updated by the buffer.
 12+  A5A8              ; This is done by half line. Lines are encded with.
 13+  A5A8              ; 00hlllll
 14+  A5A8              ; Where h is the half of the screen (0 or 1), lllll is the line number
 15+  A5A8              buffer_updatedlines:
 16+  A5A8 FF FF FF...      defs 21,255
 17+  A5BD
 18+  A5BD              buffer_updateall:
 19+  A5BD 00               defb 0
 20+  A5BE
 21+  A5BE              ;
 22+  A5BE              ; Stores a line number in the update list
 23+  A5BE              ; Inputs:
 24+  A5BE              ; a - row number
 25+  A5BE              buffer_marklineforupdate:
 26+  A5BE FE 15            cp 21
 27+  A5C0 D0               ret nc                          ; dont store lines that we shouldn't draw
 28+  A5C1 5F               ld e,a                          ; store in e
 29+  A5C2 ED 4B AB AA      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 30+  A5C6 79               ld a,c                          ; get the horiz coord
 31+  A5C7 FE 0F            cp 15
 32+  A5C9 CA E0 A5         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 33+  A5CC FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 34+  A5CE CA E0 A5         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 35+  A5D1 DA DC A5         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 36+  A5D4 78               ld a,b                          ; get the vertical
 37+  A5D5 3E 20            ld a,32                         ; set the 6th bit by adding 32
 38+  A5D7 83               add a,e
 39+  A5D8 5F               ld e,a                          ; store this value
 40+  A5D9 C3 E7 A5         jp buffer_marklineforupdate2
 41+  A5DC              buffer_marklineforupdate4:
 42+  A5DC 78               ld a,b
 43+  A5DD C3 E7 A5         jp buffer_marklineforupdate2    ; just get the vertical
 44+  A5E0              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 45+  A5E0 CD EB A5         call buffer_storelineforupdate  ; call store update for e
 46+  A5E3 3E 20            ld a,32
 47+  A5E5 83               add a,e
 48+  A5E6 5F               ld e,a
 49+  A5E7              buffer_marklineforupdate2:
 50+  A5E7 CD EB A5         call buffer_storelineforupdate  ; call store update for e
 51+  A5EA C9               ret
 52+  A5EB
 53+  A5EB
 54+  A5EB              ;
 55+  A5EB              ; Stores the calculated line and half if needed
 56+  A5EB              ; Inputs:
 57+  A5EB              ; e - half/row
 58+  A5EB              ;
 59+  A5EB              buffer_storelineforupdate:
 60+  A5EB 06 15            ld b,21
 61+  A5ED 21 A8 A5         ld hl,buffer_updatedlines
 62+  A5F0              buffer_storelineforupdate0:
 63+  A5F0 7E               ld a,(hl)                       ; get the line stored in updated lines
 64+  A5F1 BB               cp e                            ; is this the same as the row number passed in?
 65+  A5F2 C8               ret z                           ; if so, don't need to do anything
 66+  A5F3 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 67+  A5F5 C2 FA A5         jp nz,buffer_storelineforupdate1 ; if not, move to next
 68+  A5F8 73               ld (hl),e
 69+  A5F9 C9               ret
 70+  A5FA              buffer_storelineforupdate1:
 71+  A5FA 23               inc hl
 72+  A5FB 10 F3            djnz buffer_storelineforupdate0
 73+  A5FD C9               ret
 74+  A5FE
 75+  A5FE              ;
 76+  A5FE              ; Zeroes the updated lines list
 77+  A5FE              ;
 78+  A5FE              buffer_clearlist:
 79+  A5FE 06 15            ld b,21
 80+  A600 21 A8 A5         ld hl,buffer_updatedlines
 81+  A603              buffer_clearlist0:
 82+  A603 36 FF            ld (hl),255
 83+  A605 23               inc hl
 84+  A606 10 FB            djnz buffer_clearlist0
 85+  A608 C9               ret
 86+  A609
 87+  A609              ;
 88+  A609              ; Which half are we displaying? 0 left 1 right
 89+  A609              ;
 90+  A609              buffer_bufferhalf:
 91+  A609 00               defb 0
 92+  A60A
 93+  A60A              ;
 94+  A60A              ; Copies the buffer to the screen. Use stack.
 95+  A60A              ; Inputs:
 96+  A60A              ; hl - half/line number to display - 0 is first half, 0 is first line
 97+  A60A              ;
 98+  A60A              buffer_bufferlinetoscreen:
 99+  A60A 7C               ld a,h
100+  A60B 32 09 A6         ld (buffer_bufferhalf),a        ; store the half
101+  A60E 7D               ld a,l
102+  A60F 4F               ld c,a                          ; store a
103+  A610 ED 5B 70 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
104+  A614 83               add a,e                       ; add the row number
105+  A615 11 00 01         ld de,256
106+  A618 CD 3A 80         call utilities_multiply
107+  A61B 54 5D            ld de,hl
108+  A61D 21 06 85         ld hl,buffer_buffer
109+  A620 19               add hl,de                   ; add the offset
110+  A621 79               ld a,c                      ; get original row back
111+  A622 ED 73 95 A6      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
112+  A626 D9               exx
113+  A627 0E 00            ld c,0                      ; zero horizontal
114+  A629 47               ld b,a                      ; load the row number into vertical coord
115+  A62A 04               inc b
116+  A62B 04               inc b                       ; move forward 2 to allow for scores
117+  A62C CD 5A A8         call screen_getcelladdress  ; get the memory into de
118+  A62F 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
119+  A632 19               add hl,de
120+  A633 3A 09 A6         ld a,(buffer_bufferhalf)    ; get the half
121+  A636 FE 01            cp 1
122+  A638 CA 65 A6         jp z,buffer_bufferlinetoscreen4
123+  A63B              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
124+  A63B D9               exx                         ; hl is now buffer
125+  A63C 23               inc hl
126+  A63D 23               inc hl                      ; move hl forward 2 to skip first two blocks
127+  A63E F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
128+  A63F F1               pop af
129+  A640 C1               pop bc
130+  A641 D1               pop de
131+  A642 DD E1            pop ix
132+  A644 D9               exx                         ; hl is now screen
133+  A645 08               ex af,af'
134+  A646 F1               pop af
135+  A647 C1               pop bc
136+  A648 D1               pop de
137+  A649 F9               ld sp,hl                    ; sp pointing at screen
138+  A64A D5               push de
139+  A64B C5               push bc
140+  A64C F5               push af
141+  A64D 08               ex af,af'
142+  A64E D9               exx                         ; hl is now buffer
143+  A64F DD E5            push ix
144+  A651 D5               push de
145+  A652 C5               push bc
146+  A653 F5               push af
147+  A654 11 1E 00         ld de,30                    ; add thirty to get to next line
148+  A657 19               add hl,de
149+  A658 F9               ld sp,hl                    ; sp pointing at buffer
150+  A659 D9               exx                         ; hl is now screen
151+  A65A 08               ex af,af'
152+  A65B 24               inc h
153+  A65C 7C               ld a,h
154+  A65D E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
155+  A65F C2 3B A6         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
156+  A662              buffer_bufferlinetoscreen1:
157+  A662 C3 94 A6         jp buffer_bufferlinetoscreen3
158+  A665              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
159+  A665 D9               exx                         ; hl is buffer
160+  A666 11 10 00         ld de,16
161+  A669 19               add hl,de                   ; move halfway across
162+  A66A D9               exx                         ; hl is screen
163+  A66B 11 0E 00         ld de,14
164+  A66E 19               add hl,de
165+  A66F              buffer_bufferlinetoscreen2:
166+  A66F D9               exx                         ; hl is now buffer
167+  A670 F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
168+  A671 F1               pop af
169+  A672 C1               pop bc
170+  A673 D1               pop de
171+  A674 DD E1            pop ix
172+  A676 D9               exx                         ; hl is now screen
173+  A677 08               ex af,af'
174+  A678 F1               pop af
175+  A679 C1               pop bc
176+  A67A D1               pop de
177+  A67B F9               ld sp,hl                    ; sp pointing at screen
178+  A67C D5               push de
179+  A67D C5               push bc
180+  A67E F5               push af
181+  A67F 08               ex af,af'
182+  A680 D9               exx                         ; hl is now buffer
183+  A681 DD E5            push ix
184+  A683 D5               push de
185+  A684 C5               push bc
186+  A685 F5               push af
187+  A686 11 20 00         ld de,32                    ; add thirty two to get to next line
188+  A689 19               add hl,de
189+  A68A F9               ld sp,hl                    ; sp pointing at buffer
190+  A68B D9               exx                         ; hl is now screen
191+  A68C 08               ex af,af'
192+  A68D 24               inc h
193+  A68E 7C               ld a,h
194+  A68F E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
195+  A691 C2 6F A6         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
196+  A694              buffer_bufferlinetoscreen3:
197+  A694 31 00 00         ld sp,0
198+  A697 D9               exx
199+  A698 C9               ret
200+  A699
201+  A699              ;
202+  A699              ; Copies the buffer to the screen for updated lines. Use stack.
203+  A699              ; Inputs: none
204+  A699              ;
205+  A699              buffer_buffertoscreen:
206+  A699 3A BD A5         ld a,(buffer_updateall)      ; get the all update flag
207+  A69C FE 00            cp 0
208+  A69E CA AA A6         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
209+  A6A1 CD DA A6         call buffer_allbuffertoscreen ; otherwise, draw whole screen
210+  A6A4 21 BD A5         ld hl,buffer_updateall
211+  A6A7 36 00            ld (hl),0                    ; reset flag
212+  A6A9 C9               ret
213+  A6AA              buffer_buffertoscreen2:
214+  A6AA 06 15            ld b,21
215+  A6AC FD 21 A8 A5      ld iy,buffer_updatedlines    ; the location of the updated lines
216+  A6B0              buffer_buffertoscreen0:
217+  A6B0 FD 7E 00         ld a,(iy)
218+  A6B3 FE FF            cp 255
219+  A6B5 CA D9 A6         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
220+  A6B8 6F               ld l,a
221+  A6B9 26 00            ld h,0
222+  A6BB E6 20            and 32                      ; and with 32 to see if 6th bit is set
223+  A6BD FE 20            cp 32                       ; if so, second half of screen
224+  A6BF C2 CA A6         jp nz,buffer_buffertoscreen3
225+  A6C2 26 01            ld h,1                      ; store half in h
226+  A6C4 FD 7E 00         ld a,(iy)
227+  A6C7 D6 20            sub 32                      ; remove 32
228+  A6C9 6F               ld l,a                      ; stor in line number
229+  A6CA              buffer_buffertoscreen3:
230+  A6CA C5               push bc
231+  A6CB FD E5            push iy
232+  A6CD F3               di
233+  A6CE CD 0A A6         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
234+  A6D1 FB               ei
235+  A6D2 FD E1            pop iy
236+  A6D4 C1               pop bc
237+  A6D5 FD 23            inc iy
238+  A6D7 10 D7            djnz buffer_buffertoscreen0
239+  A6D9              buffer_buffertoscreen1:
240+  A6D9                  ;call buffer_buffertoattrsfast
241+  A6D9 C9               ret
242+  A6DA
243+  A6DA              ;
244+  A6DA              ; Copies the buffer to the screen. Use stack.
245+  A6DA              ; Inputs: none
246+  A6DA              ;
247+  A6DA              buffer_allbuffertoscreen:
248+  A6DA 06 15            ld b,21
249+  A6DC 3E 00            ld a,0
250+  A6DE              buffer_allbuffertoscreen0:
251+  A6DE C5               push bc
252+  A6DF F5               push af
253+  A6E0 F3               di
254+  A6E1 26 00            ld h,0
255+  A6E3 6F               ld l,a
256+  A6E4 CD 0A A6         call buffer_bufferlinetoscreen
257+  A6E7 FB               ei
258+  A6E8 F1               pop af
259+  A6E9 F5               push af
260+  A6EA F3               di
261+  A6EB 26 01            ld h,1
262+  A6ED 6F               ld l,a
263+  A6EE CD 0A A6         call buffer_bufferlinetoscreen
264+  A6F1 FB               ei
265+  A6F2 F1               pop af
266+  A6F3 C1               pop bc
267+  A6F4 3C               inc a
268+  A6F5 10 E7            djnz buffer_allbuffertoscreen0
269+  A6F7 F3               di
270+  A6F8 CD FD A6         call buffer_buffertoattrsfast
271+  A6FB FB               ei
272+  A6FC C9               ret
273+  A6FD
274+  A6FD              ;
275+  A6FD              ; Copies the attrs buffer to screen with the stack
276+  A6FD              ;
277+  A6FD              buffer_buffertoattrsfast:
278+  A6FD ED 73 6C A7      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
279+  A701 3A 70 A7         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
280+  A704 11 20 00         ld de,32
281+  A707 CD 3A 80         call utilities_multiply
282+  A70A 54 5D            ld de,hl
283+  A70C 21 06 A2         ld hl,buffer_attr_buffer
284+  A70F 19               add hl,de                       ; add the offset, start of attr buffer now in hl
285+  A710 D9               exx
286+  A711 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
287+  A714 FD 21 A6 A5      ld iy,buffer_tmp
288+  A718 FD 36 00 15      ld (iy),21              ; number of times to loop
289+  A71C              buffer_buffertoattrsfast0:
290+  A71C D9               exx                         ; hl is now buffer
291+  A71D 23               inc hl
292+  A71E 23               inc hl                      ; move hl forward 2 to skip first two blocks
293+  A71F F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
294+  A720 F1               pop af
295+  A721 C1               pop bc
296+  A722 D1               pop de
297+  A723 DD E1            pop ix
298+  A725 D9               exx                         ; hl is now screen
299+  A726 08               ex af,af'
300+  A727 F1               pop af
301+  A728 C1               pop bc
302+  A729 D1               pop de
303+  A72A F9               ld sp,hl                    ; sp pointing at screen
304+  A72B D5               push de
305+  A72C C5               push bc
306+  A72D F5               push af
307+  A72E 08               ex af,af'
308+  A72F D9               exx                         ; hl is now buffer
309+  A730 DD E5            push ix
310+  A732 D5               push de
311+  A733 C5               push bc
312+  A734 F5               push af
313+  A735 1E 0E            ld e,14                    ; do another fourteen for right hand side
314+  A737 16 00            ld d,0
315+  A739 19               add hl,de
316+  A73A F9               ld sp,hl                    ; sp pointing at buffer
317+  A73B F1               pop af
318+  A73C C1               pop bc
319+  A73D D1               pop de
320+  A73E DD E1            pop ix
321+  A740 D9               exx                         ; hl is now screen
322+  A741 08               ex af,af'
323+  A742 1E 0E            ld e,14
324+  A744 16 00            ld d,0
325+  A746 19               add hl,de
326+  A747 F1               pop af
327+  A748 C1               pop bc
328+  A749 D1               pop de
329+  A74A F9               ld sp,hl                    ; sp pointing at screen
330+  A74B D5               push de
331+  A74C C5               push bc
332+  A74D F5               push af
333+  A74E 08               ex af,af'
334+  A74F D9               exx                         ; hl is now buffer
335+  A750 DD E5            push ix
336+  A752 D5               push de
337+  A753 C5               push bc
338+  A754 F5               push af
339+  A755 1E 10            ld e,16
340+  A757 16 00            ld d,0
341+  A759 19               add hl,de
342+  A75A D9               exx                         ; hl is now screen
343+  A75B 11 12 00         ld de,18
344+  A75E 19               add hl,de
345+  A75F FD 7E 00         ld a,(iy)
346+  A762 3D               dec a
347+  A763 FE 00            cp 0
348+  A765 FD 77 00         ld (iy),a
349+  A768 C2 1C A7         jp nz,buffer_buffertoattrsfast0 ; do another row
350+  A76B              buffer_buffertoattrsfast1:
351+  A76B 31 00 00         ld sp,0
352+  A76E D9               exx
353+  A76F C9               ret
# file closed: screen/buffer.asm
 24   A770                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A770              screen_offset:
  2+  A770 00               defb 0                      ; offset from top of screen in lines
  3+  A771
  4+  A771              screen_tmp:
  5+  A771 00 00            defb 0,0                      ; temporary memory
  6+  A773
  7+  A773              screen_setscorecolours:
  8+  A773 21 E9 B3         ld hl,score_colours
  9+  A776 11 00 58         ld de,22528                     ; attrs here
 10+  A779 01 40 00         ld bc,64
 11+  A77C ED B0            ldir
 12+  A77E C9               ret
 13+  A77F
 14+  A77F              screen_sethighscorecolours:
 15+  A77F 21 29 B4         ld hl,high_score_colours
 16+  A782 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A785 01 20 00         ld bc,32
 18+  A788 ED B0            ldir
 19+  A78A C9               ret
 20+  A78B
 21+  A78B              ; Draw the screen
 22+  A78B              ; Inputs:
 23+  A78B              ; none
 24+  A78B              ; Notes:
 25+  A78B              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A78B              screen_draw:
 27+  A78B                  ;call clear_screen
 28+  A78B 0E 00            ld c,0                      ; horiz
 29+  A78D 06 00            ld b,0                      ; vert, 0 at top
 30+  A78F DD 21 AB AE      ld ix,level01               ; point ix at level data
 31+  A793 FD 21 06 A2      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A797              screen_draw0:
 33+  A797 DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A79A C5               push bc                     ; store bc, contains loop count
 35+  A79B CD 48 A9         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A79E 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A79F FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A7A2 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A7A5 CD 0F A9         call screen_getblock        ; get the block data into hl
 40+  A7A8 CD EC A8         call screen_showchar        ; show this character here
 41+  A7AB C1               pop bc                      ; get the loop counter back
 42+  A7AC DD 23            inc ix                      ; increment level location
 43+  A7AE FD 23            inc iy                      ; increment attr location
 44+  A7B0 0C               inc c                       ; increment horiz
 45+  A7B1 79               ld a,c
 46+  A7B2 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A7B4 C2 97 A7         jp nz,screen_draw0          ; if not, loop
 48+  A7B7 0E 00            ld c,0                      ; if so, reset horiz
 49+  A7B9 04               inc b                       ; increment vertical
 50+  A7BA 78               ld a,b
 51+  A7BB FE 1D            cp 29                       ; check if at bottom
 52+  A7BD C2 97 A7         jp nz,screen_draw0          ; if not, loop
 53+  A7C0 21 71 A7         ld hl, screen_tmp
 54+  A7C3 36 09            ld (hl),9                   ; load the block number into memory
 55+  A7C5 DD 21 4B B2      ld ix,level01rocks          ; rock memory
 56+  A7C9 CD 2A A8         call screen_initobjects     ; draw rocks
 57+  A7CC 21 71 A7         ld hl, screen_tmp
 58+  A7CF 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A7D1 DD 21 4B B3      ld ix,level01missiles       ; missile memory
 60+  A7D5 CD 2A A8         call screen_initobjects     ; draw missiles
 61+  A7D8 21 71 A7         ld hl, screen_tmp
 62+  A7DB 36 08            ld (hl),08                  ; load the block number into memory
 63+  A7DD DD 21 C4 B3      ld ix,level01diamonds       ; diamond memory
 64+  A7E1 CD 2A A8         call screen_initobjects     ; draw diamonds
 65+  A7E4 21 71 A7         ld hl, screen_tmp
 66+  A7E7 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A7E9 DD 21 D4 B3      ld ix,level01gems           ; gems memory
 68+  A7ED CD 2A A8         call screen_initobjects     ; draw gems
 69+  A7F0 CD F7 A7         call screen_setuptext       ; draws text on the screen
 70+  A7F3 CD 94 C2         call scores_printscores     ; print the current scores
 71+  A7F6 C9               ret
 72+  A7F7
 73+  A7F7              ;
 74+  A7F7              ; Sets up text on the screen
 75+  A7F7              ;
 76+  A7F7              screen_setuptext:
 77+  A7F7 CD B6 C2         call scores_showtable
 78+  A7FA CD 7F A7         call screen_sethighscorecolours
 79+  A7FD 21 ED 80         ld hl, string_score1
 80+  A800 CD BE 84         call string_print
 81+  A803 21 F6 80         ld hl, string_scorenumbers1
 82+  A806 CD BE 84         call string_print
 83+  A809 21 FF 80         ld hl, string_company
 84+  A80C CD BE 84         call string_print
 85+  A80F 21 14 81         ld hl, string_score2
 86+  A812 CD BE 84         call string_print
 87+  A815 21 1D 81         ld hl, string_scorenumbers2
 88+  A818 CD BE 84         call string_print
 89+  A81B 21 09 81         ld hl, string_credits
 90+  A81E CD BE 84         call string_print
 91+  A821 CD 73 A7         call screen_setscorecolours
 92+  A824 C9               ret
 93+  A825
 94+  A825              ;
 95+  A825              ; Sets a line of colours
 96+  A825              ; Inputs:
 97+  A825              ; a - colour to set
 98+  A825              ; b - number to set
 99+  A825              ; de - start memory location
100+  A825              ;
101+  A825              screen_setcolours:
102+  A825 12               ld (de),a
103+  A826 13               inc de
104+  A827 10 FC            djnz screen_setcolours
105+  A829 C9               ret
106+  A82A
107+  A82A              ;
108+  A82A              ; Draw initial object positions
109+  A82A              ; Inputs:
110+  A82A              ; ix - memory location of objects
111+  A82A              ; a - graphic
112+  A82A              screen_initobjects:
113+  A82A DD 4E 00         ld c,(ix)                   ; get the horiz coord
114+  A82D 79               ld a,c
115+  A82E FE FF            cp 255
116+  A830 CA 59 A8         jp z,screen_initobjects2
117+  A833 DD 23            inc ix                      ; move to next
118+  A835 DD 46 00         ld b,(ix)                   ; get the vert coord
119+  A838 DD 23            inc ix
120+  A83A CD 6B A8         call screen_getcellattradress ; get the memory address of b,c attr into de
121+  A83D D5               push de
122+  A83E 3A 71 A7         ld a,(screen_tmp)                  ; get the block number back
123+  A841 CD 48 A9         call screen_getattr         ; get the memory location for this cell's attr into hl
124+  A844 D1               pop de
125+  A845 7E               ld a,(hl)                   ; get the attr value at the address
126+  A846 12               ld (de),a                   ; load the attr into memory
127+  A847 3A 71 A7         ld a,(screen_tmp)                  ; get the block number back
128+  A84A CD 0F A9         call screen_getblock        ; get the block data into hl
129+  A84D CD EC A8         call screen_showchar        ; show this character here
130+  A850
131+  A850              screen_initobjects1:
132+  A850 DD 23            inc ix                      ; move past state
133+  A852 DD 23            inc ix
134+  A854 DD 23            inc ix                      ; move past mem
135+  A856 C3 2A A8         jp screen_initobjects
136+  A859              screen_initobjects2:
137+  A859 C9               ret
138+  A85A
139+  A85A
140+  A85A              ;
141+  A85A              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
142+  A85A              ; Inputs:
143+  A85A              ; bc: coords
144+  A85A              ; Outputs:
145+  A85A              ; de: memory location
146+  A85A              ;
147+  A85A              screen_getcelladdress:
148+  A85A 78               ld a,b      ; vertical position.
149+  A85B E6 18            and 24      ; which segment, 0, 1 or 2?
150+  A85D C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
151+  A85F 57               ld d,a      ; this is our high byte.
152+  A860 78               ld a,b      ; what was that vertical position again?
153+  A861 E6 07            and 7       ; which row within segment?
154+  A863 0F               rrca        ; multiply row by 32.
155+  A864 0F               rrca
156+  A865 0F               rrca
157+  A866 5F               ld e,a      ; low byte.
158+  A867 79               ld a,c      ; add on y coordinate.
159+  A868 83               add a,e     ; mix with low byte.
160+  A869 5F               ld e,a      ; address of screen position in de.
161+  A86A C9               ret
162+  A86B
163+  A86B              ;
164+  A86B              ; Calculate buffer address of attribute for character at (b, c).
165+  A86B              ; Inputs:
166+  A86B              ; bc: coords
167+  A86B              ; Outputs:
168+  A86B              ; de: memory location
169+  A86B              ;
170+  A86B              screen_getcellattradress:
171+  A86B 11 06 A2         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
172+  A86E 69               ld l,c      ; x position.
173+  A86F 26 00            ld h,0      ; 0 h
174+  A871 19               add hl,de
175+  A872 54 5D            ld de,hl    ; horiz done
176+  A874 78               ld a,b      ; do vert
177+  A875 D5               push de
178+  A876 C5               push bc
179+  A877 11 20 00         ld de,32
180+  A87A CD 3A 80         call utilities_multiply
181+  A87D C1               pop bc
182+  A87E D1               pop de
183+  A87F 19               add hl,de
184+  A880 54 5D            ld de,hl    ; vert done
185+  A882 C9               ret
186+  A883
187+  A883              ;
188+  A883              ; Calculate buffer address offset of attribute for character at (b, c).
189+  A883              ; Inputs:
190+  A883              ; bc: coords
191+  A883              ; Outputs:
192+  A883              ; de: memory location
193+  A883              ;
194+  A883              screen_getcellattroffset:
195+  A883 69               ld l,c      ; x position.
196+  A884 26 00            ld h,0      ; 0 h
197+  A886 54 5D            ld de,hl    ; horiz done
198+  A888 78               ld a,b      ; do vert
199+  A889 D5               push de
200+  A88A C5               push bc
201+  A88B 11 20 00         ld de,32
202+  A88E CD 3A 80         call utilities_multiply
203+  A891 C1               pop bc
204+  A892 D1               pop de
205+  A893 19               add hl,de
206+  A894 54 5D            ld de,hl    ; vert done
207+  A896 C9               ret
208+  A897
209+  A897              ;
210+  A897              ; Calculate buffer address of attribute for character at (b, c).
211+  A897              ; Inputs:
212+  A897              ; bc: coords
213+  A897              ; Outputs:
214+  A897              ; de: memory location
215+  A897              ;
216+  A897              screen_getscreenattradress:
217+  A897 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
218+  A89A 69               ld l,c      ; x position.
219+  A89B 26 00            ld h,0      ; 0 h
220+  A89D 19               add hl,de
221+  A89E 54 5D            ld de,hl    ; horiz done
222+  A8A0 78               ld a,b      ; do vert
223+  A8A1 D5               push de
224+  A8A2 C5               push bc
225+  A8A3 11 20 00         ld de,32
226+  A8A6 CD 3A 80         call utilities_multiply
227+  A8A9 C1               pop bc
228+  A8AA D1               pop de
229+  A8AB 19               add hl,de
230+  A8AC 54 5D            ld de,hl    ; vert done
231+  A8AE C9               ret
232+  A8AF
233+  A8AF              ;
234+  A8AF              ; Gets the attr memory location for a screen coord
235+  A8AF              ; Will overwrite bc
236+  A8AF              ; Inputs:
237+  A8AF              ; bc - screen coords
238+  A8AF              ; Outputs:
239+  A8AF              ; de - memory location
240+  A8AF              ; bc - character coords
241+  A8AF              ;
242+  A8AF              screen_getattraddressfromscreencoords:
243+  A8AF 78               ld a,b                          ; get the player block coords of current block
244+  A8B0 E6 F8            and 248                         ; find closest multiple of eight
245+  A8B2 0F               rrca
246+  A8B3 0F               rrca
247+  A8B4 0F               rrca                ; divide by 8
248+  A8B5 47               ld b,a
249+  A8B6 79               ld a,c
250+  A8B7 48               ld c,b                         ; swap b and c
251+  A8B8 E6 F8            and 248
252+  A8BA 0F               rrca
253+  A8BB 0F               rrca
254+  A8BC 0F               rrca                ; divide by 8
255+  A8BD 47               ld b,a
256+  A8BE CD 6B A8         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
257+  A8C1 C9               ret
258+  A8C2
259+  A8C2
260+  A8C2              ; Gets the nearest cell coords for a screen coord
261+  A8C2              ; Will overwrite bc
262+  A8C2              ; Inputs:
263+  A8C2              ; bc - screen coords
264+  A8C2              ; Outputs:
265+  A8C2              ; bc - character coords
266+  A8C2              ;
267+  A8C2              screen_getcharcoordsfromscreencoords:
268+  A8C2 78               ld a,b                          ; get the player block coords of current block
269+  A8C3 E6 F8            and 248                         ; find closest multiple of eight
270+  A8C5 0F               rrca
271+  A8C6 0F               rrca
272+  A8C7 0F               rrca                ; divide by 8
273+  A8C8 47               ld b,a
274+  A8C9 79               ld a,c
275+  A8CA 48               ld c,b                         ; swap b and c
276+  A8CB E6 F8            and 248
277+  A8CD 0F               rrca
278+  A8CE 0F               rrca
279+  A8CF 0F               rrca                ; divide by 8
280+  A8D0 47               ld b,a
281+  A8D1 C9               ret
282+  A8D2
283+  A8D2              ; Gets the screen coords for a cell coord
284+  A8D2              ; Will overwrite bc
285+  A8D2              ; Inputs:
286+  A8D2              ; bc - char coords
287+  A8D2              ; Outputs:
288+  A8D2              ; bc - screen coords
289+  A8D2              ;
290+  A8D2              screen_getscreencoordsfromcharcoords:
291+  A8D2 78               ld a,b                          ; get the player block coords of current block
292+  A8D3 07               rlca
293+  A8D4 07               rlca
294+  A8D5 07               rlca                ; multiply by 8
295+  A8D6 47               ld b,a
296+  A8D7 79               ld a,c
297+  A8D8 48               ld c,b                         ; swap b and c
298+  A8D9 07               rlca
299+  A8DA 07               rlca
300+  A8DB 07               rlca                ; divide by 8
301+  A8DC 47               ld b,a
302+  A8DD C9               ret
303+  A8DE
304+  A8DE              ;
305+  A8DE              ; Get buffer address for a character at b,c - b vert
306+  A8DE              ; Buffer memory is stored as sequential block
307+  A8DE              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
308+  A8DE              ; Inputs:
309+  A8DE              ; bc - coords
310+  A8DE              ; Outputs:
311+  A8DE              ; de - memory location of first byte
312+  A8DE              screen_getbufferaddress:
313+  A8DE 21 06 85         ld hl, buffer_buffer    ; first get screen buffer start
314+  A8E1 50               ld d,b                  ; then work out vertical offset
315+  A8E2 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
316+  A8E4 19               add hl,de               ; add to base
317+  A8E5 59               ld e,c                  ; then add horizontal offset (c)
318+  A8E6 16 00            ld d,0
319+  A8E8 19               add hl,de               ; add to base
320+  A8E9 54 5D            ld de,hl
321+  A8EB C9               ret
322+  A8EC
323+  A8EC              ;
324+  A8EC              ; Display character hl at (b, c) to buffer.
325+  A8EC              ; Stored sequentially
326+  A8EC              ; Inputs:
327+  A8EC              ; hl: block address
328+  A8EC              ; bc: coords
329+  A8EC              ;
330+  A8EC              screen_showchar:
331+  A8EC ED 43 AB AA      ld (origcoords),bc   ; store char coords
332+  A8F0 3E 00            ld a,0
333+  A8F2 E5               push hl
334+  A8F3 CD DE A8         call screen_getbufferaddress ; get the current screen buffer pointer
335+  A8F6 E1               pop hl
336+  A8F7 06 08            ld b,8              ; number of pixels high.
337+  A8F9              screen_showchar0:
338+  A8F9 7E               ld a,(hl)           ; source graphic.
339+  A8FA 12               ld (de),a           ; transfer to screen.
340+  A8FB 23               inc hl              ; next piece of data.
341+  A8FC E5               push hl             ; store hl
342+  A8FD 62 6B            ld hl,de            ; put de in hl
343+  A8FF 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
344+  A901 16 00            ld d,0
345+  A903 19               add hl,de              ; add de to hl
346+  A904 54 5D            ld de,hl            ; load back to de
347+  A906 E1               pop hl              ; restore hl
348+  A907
349+  A907 10 F0            djnz screen_showchar0 ; repeat
350+  A909 2E 01            ld l,1
351+  A90B CD 5C AA         call sprites_marklinesforupdatechar
352+  A90E
353+  A90E C9               ret
354+  A90F
355+  A90F
356+  A90F              ;
357+  A90F              ; Get cell graphic.
358+  A90F              ; Inputs:
359+  A90F              ; a: block
360+  A90F              ; Outputs:
361+  A90F              ; hl: memory
362+  A90F              ;
363+  A90F              screen_getblock:
364+  A90F 07               rlca                        ; multiply block number by eight.
365+  A910 07               rlca
366+  A911 07               rlca
367+  A912 5F               ld e,a                      ; displacement to graphic address.
368+  A913 16 00            ld d,0                      ; no high byte.
369+  A915 21 49 B4         ld hl,sprites               ; address of character blocks.
370+  A918 19               add hl,de                   ; point to block.
371+  A919 C9               ret
372+  A91A
373+  A91A              ;
374+  A91A              ; Set a the attr of a coord
375+  A91A              ; Inputs:
376+  A91A              ; bc - char coords
377+  A91A              ; a - attr
378+  A91A              ;
379+  A91A              screen_setattr:
380+  A91A DD E5            push ix
381+  A91C C5               push bc
382+  A91D 08               ex af, af'
383+  A91E CD 83 A8         call screen_getcellattroffset   ; get offset into de
384+  A921 21 06 A2         ld hl,buffer_attr_buffer
385+  A924 19               add hl,de                       ; get the memory location
386+  A925 08               ex af, af'                      ; get attr back
387+  A926 77               ld (hl),a                         ; set the attr
388+  A927 08               ex af, af'                      ; get attr back
389+  A928 ED 5B 70 A7      ld de,(screen_offset)           ; get the offset
390+  A92C 78               ld a,b                          ; get the vertical
391+  A92D 93               sub e                           ; subtract the offset
392+  A92E DA 44 A9         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
393+  A931 FE 15            cp 21
394+  A933 D2 44 A9         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
395+  A936 47               ld b,a                          ; put the coord back in b
396+  A937 CD 97 A8         call screen_getscreenattradress ; screen attr address in de
397+  A93A 21 40 00         ld hl,64                        ; attr memory + two rows for scores
398+  A93D 19               add hl,de
399+  A93E 08               ex af, af'                      ; get attr back
400+  A93F 77               ld (hl),a
401+  A940 C1               pop bc
402+  A941 DD E1            pop ix
403+  A943 C9               ret
404+  A944              screen_setattr0:
405+  A944 C1               pop bc
406+  A945 DD E1            pop ix
407+  A947 C9               ret
408+  A948
409+  A948              ;
410+  A948              ; Get cell attribute.
411+  A948              ; Inputs:
412+  A948              ; a: block
413+  A948              ; Outputs:
414+  A948              ; hl: memory
415+  A948              ;
416+  A948              screen_getattr:
417+  A948 5F               ld e,a                      ; displacement to attribute address.
418+  A949 16 00            ld d,0                      ; no high byte.
419+  A94B 21 21 B5         ld hl,sprite_attrs          ; address of block attributes.
420+  A94E 19               add hl,de                   ; point to attribute.
421+  A94F C9               ret
422+  A950
423+  A950              ;
424+  A950              ; Checks whether a character block has anything in it
425+  A950              ; Inputs:
426+  A950              ; bc - char coords
427+  A950              ; Outputs:
428+  A950              ; a - 1, empty
429+  A950              screen_ischarempty:
430+  A950 CD DE A8         call screen_getbufferaddress ; get the current screen buffer pointer
431+  A953 06 08            ld b,8                      ; check 8 rows
432+  A955              screen_ischarempty2:
433+  A955 1A               ld a,(de)                   ; check line
434+  A956 FE 00            cp 0
435+  A958 C2 66 A9         jp nz,screen_ischarempty1   ; if not zero, jump out with false
436+  A95B 21 20 00         ld hl,32
437+  A95E 19               add hl,de
438+  A95F 54 5D            ld de,hl                    ; move to next row
439+  A961 10 F2            djnz screen_ischarempty2
440+  A963              screen_ischarempty0:
441+  A963 3E 01            ld a,1
442+  A965 C9               ret
443+  A966              screen_ischarempty1:
444+  A966 3E 00            ld a,0
445+  A968 C9               ret
446+  A969
447+  A969              ;
448+  A969              ; Copies a block from one place to another directly underneath, leaves the original empty
449+  A969              ; Inputs:
450+  A969              ; bc - coords of block to copy from
451+  A969              screen_copyblockdown
452+  A969 CD DE A8         call screen_getbufferaddress ; get the current screen buffer pointer for source
453+  A96C 06 08            ld b,8                      ; copy 8 rows
454+  A96E              screen_copyblock0:
455+  A96E 1A               ld a,(de)                    ; get what we're copying
456+  A96F 08               ex af,af'
457+  A970 3E 00            ld a,0
458+  A972 12               ld (de),a                    ; replace with empty
459+  A973 08               ex af,af'
460+  A974 14               inc d                        ; add 256 to get to the next row
461+  A975 12               ld (de),a                    ; copy to the next row
462+  A976 15               dec d
463+  A977 21 20 00         ld hl,32
464+  A97A 19               add hl,de                       ; return back to source, next row down
465+  A97B 54 5D            ld de,hl
466+  A97D 10 EF            djnz screen_copyblock0
467+  A97F C9               ret
468+  A980
469+  A980              ;
470+  A980              ; Returns the first byte of a character. Useful for figuring out what's there
471+  A980              ; Inputs:
472+  A980              ; bc - coords
473+  A980              ; Outputs:
474+  A980              ; a - first byte
475+  A980              ;
476+  A980              screen_getcharfirstbyte:
477+  A980 CD DE A8         call screen_getbufferaddress ; get the current screen buffer pointer for source
478+  A983 1A               ld a,(de)
479+  A984 C9               ret
480+  A985
# file closed: screen/screen.asm
 25   A985                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A985              ;
  2+  A985              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A985              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A985              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A985              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A985              ; routine takes care of all the shifting itself. This means that sprite
  7+  A985              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A985              ; space they would require in pre-shifted form.
  9+  A985              ; Inputs:
 10+  A985              ; hl - sprite data
 11+  A985              ; bc - screen coords
 12+  A985              ;
 13+  A985              sprites_drawsprite7:
 14+  A985 EE 07            xor 7               ; complement last 3 bits.
 15+  A987 3C               inc a               ; add one for luck!
 16+  A988              sprites_drawsprite3:
 17+  A988 CB 11            rl c                ; ...into middle byte...
 18+  A98A CB 12            rl d                ; ...and finally into left character cell.
 19+  A98C 3D               dec a               ; count shifts we've done.
 20+  A98D 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A98F                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A98F 79               ld a,c              ; left edge of image is currently in e.
 23+  A990 4A               ld c,d              ; put right edge there instead.
 24+  A991 57               ld d,a              ; and the left edge back into c.
 25+  A992 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A994              sprites_drawsprite:
 27+  A994 ED 43 AB AA      ld (origcoords),bc  ; store coords
 28+  A998 ED 43 AD AA      ld (dispx),bc       ; store coords in dispx for now.
 29+  A99C E5               push hl
 30+  A99D CD 89 AA         call sprites_scadd  ; calculate screen address.
 31+  A9A0 E1               pop hl
 32+  A9A1 3E 08            ld a,8              ; height of sprite in pixels.
 33+  A9A3              sprites_drawsprite1:
 34+  A9A3 08               ex af,af'           ; store loop counter.
 35+  A9A4 D5               push de             ; store screen address.
 36+  A9A5 4E               ld c,(hl)           ; first sprite graphic.
 37+  A9A6 23               inc hl              ; increment poiinter to sprite data.
 38+  A9A7 22 AF AA         ld (sprtmp),hl      ; store it for later.
 39+  A9AA 16 00            ld d,0              ; blank right byte for now.
 40+  A9AC 78               ld a,b              ; b holds y position.
 41+  A9AD E6 07            and 7               ; how are we straddling character cells?
 42+  A9AF 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  A9B1 FE 05            cp 5                ; 5 or more right shifts needed?
 44+  A9B3 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  A9B5 A7               and a               ; oops, carry flag is set so clear it.
 46+  A9B6              sprites_drawsprite2:
 47+  A9B6 CB 19            rr c                ; rotate left byte right...
 48+  A9B8 CB 1A            rr d                ; ...into right byte.
 49+  A9BA 3D               dec a               ; one less shift to do.
 50+  A9BB 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  A9BD              sprites_drawsprite0:
 52+  A9BD E1               pop hl              ; pop screen address from stack.
 53+  A9BE 7E               ld a,(hl)           ; what's there already.
 54+  A9BF A9               xor c               ; merge in image data.
 55+  A9C0 77               ld (hl),a           ; place onto screen.
 56+  A9C1 23               inc hl
 57+  A9C2 7E               ld a,(hl)           ; what's already there.
 58+  A9C3 AA               xor d               ; right edge of sprite image data.
 59+  A9C4 77               ld (hl),a           ; plonk it on screen.
 60+  A9C5 3A AD AA         ld a,(dispx)        ; vertical coordinate.
 61+  A9C8 3C               inc a               ; next line down.
 62+  A9C9 32 AD AA         ld (dispx),a        ; store new position.
 63+  A9CC 2B               dec hl
 64+  A9CD 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  A9D0 19               add hl,de           ; add 32
 66+  A9D1              sprites_drawsprite6:
 67+  A9D1 EB               ex de,hl            ; screen address in de.
 68+  A9D2 2A AF AA         ld hl,(sprtmp)      ; restore graphic address.
 69+  A9D5 08               ex af,af'           ; restore loop counter.
 70+  A9D6 3D               dec a               ; decrement it.
 71+  A9D7 C2 A3 A9         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  A9DA 2E 02            ld l,2
 73+  A9DC CD 4B AA         call sprites_marklinesforupdatescreen
 74+  A9DF C9               ret                 ; job done.
 75+  A9E0
 76+  A9E0              ; Inputs:
 77+  A9E0              ; hl - sprite data
 78+  A9E0              ; bc - screen coords
 79+  A9E0              ;
 80+  A9E0              sprites_draw2by2sprite7
 81+  A9E0 EE 07            xor 7               ; complement last 3 bits.
 82+  A9E2 3C               inc a               ; add one for luck!
 83+  A9E3              sprites_draw2by2sprite3
 84+  A9E3 CB 12            rl d                ; rotate left...
 85+  A9E5 CB 11            rl c                ; ...into middle byte...
 86+  A9E7 CB 13            rl e                ; ...and finally into left character cell.
 87+  A9E9 3D               dec a               ; count shifts we've done.
 88+  A9EA 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  A9EC                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  A9EC 7B               ld a,e              ; left edge of image is currently in e.
 91+  A9ED 5A               ld e,d              ; put right edge there instead.
 92+  A9EE 51               ld d,c              ; middle bit goes in d.
 93+  A9EF 4F               ld c,a              ; and the left edge back into c.
 94+  A9F0 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  A9F2              sprites_draw2by2sprite
 96+  A9F2 ED 43 AB AA      ld (origcoords),bc  ; store coords
 97+  A9F6 ED 43 AD AA      ld (dispx),bc       ; store coords in dispx for now.
 98+  A9FA 79               ld a,c
 99+  A9FB 32 B1 AA         ld (sprtmp0),a         ; store vertical.
100+  A9FE E5               push hl
101+  A9FF CD 89 AA         call sprites_scadd          ; calculate screen address.
102+  AA02 E1               pop hl
103+  AA03 3E 10            ld a,16             ; height of sprite in pixels.
104+  AA05              sprites_draw2by2sprite1
105+  AA05 08               ex af,af'           ; store loop counter.
106+  AA06 D5               push de             ; store screen address.
107+  AA07 4E               ld c,(hl)           ; first sprite graphic.
108+  AA08 23               inc hl              ; increment poiinter to sprite data.
109+  AA09 56               ld d,(hl)           ; next bit of sprite image.
110+  AA0A 23               inc hl              ; point to next row of sprite data.
111+  AA0B 22 AF AA         ld (sprtmp),hl        ; store in tmp0 for later.
112+  AA0E 1E 00            ld e,0              ; blank right byte for now.
113+  AA10 78               ld a,b              ; b holds y position.
114+  AA11 E6 07            and 7               ; how are we straddling character cells?
115+  AA13 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  AA15 FE 05            cp 5                ; 5 or more right shifts needed?
117+  AA17 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  AA19 A7               and a               ; oops, carry flag is set so clear it.
119+  AA1A              sprites_draw2by2sprite2
120+  AA1A CB 19            rr c                ; rotate left byte right...
121+  AA1C CB 1A            rr d                ; ...through middle byte...
122+  AA1E CB 1B            rr e                ; ...into right byte.
123+  AA20 3D               dec a               ; one less shift to do.
124+  AA21 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  AA23              sprites_draw2by2sprite0
126+  AA23 E1               pop hl              ; pop screen address from stack.
127+  AA24 7E               ld a,(hl)           ; what's there already.
128+  AA25 A9               xor c               ; merge in image data.
129+  AA26 77               ld (hl),a           ; place onto screen.
130+  AA27 23               inc hl               ; next character cell to right please.
131+  AA28 7E               ld a,(hl)           ; what's there already.
132+  AA29 AA               xor d               ; merge with middle bit of image.
133+  AA2A 77               ld (hl),a           ; put back onto screen.
134+  AA2B 23               inc hl              ; next bit of screen area.
135+  AA2C 7E               ld a,(hl)           ; what's already there.
136+  AA2D AB               xor e               ; right edge of sprite image data.
137+  AA2E 77               ld (hl),a           ; plonk it on screen.
138+  AA2F 3A B1 AA         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  AA32 3C               inc a               ; next line down.
140+  AA33 32 B1 AA         ld (sprtmp0),a         ; store new position.
141+  AA36 2B               dec hl
142+  AA37 2B               dec hl
143+  AA38 11 20 00         ld de,32            ; add 32 to get to the next row
144+  AA3B 19               add hl,de           ; add 32
145+  AA3C              sprites_draw2by2sprite6
146+  AA3C EB               ex de,hl            ; screen address in de.
147+  AA3D 2A AF AA         ld hl,(sprtmp)        ; restore graphic address.
148+  AA40 08               ex af,af'           ; restore loop counter.
149+  AA41 3D               dec a               ; decrement it.
150+  AA42 C2 05 AA         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  AA45 2E 03            ld l,3
152+  AA47 CD 4B AA         call sprites_marklinesforupdatescreen
153+  AA4A C9               ret                 ; job done.
154+  AA4B
155+  AA4B              ;
156+  AA4B              ; Marks lines for update with screen coords
157+  AA4B              ; Inputs:
158+  AA4B              ; l - number to update
159+  AA4B              ;
160+  AA4B              sprites_marklinesforupdatescreen:
161+  AA4B F5               push af
162+  AA4C ED 4B AB AA      ld bc,(origcoords)
163+  AA50 CD C2 A8         call screen_getcharcoordsfromscreencoords
164+  AA53 ED 43 AB AA      ld (origcoords),bc
165+  AA57 CD 66 AA         call sprites_marklinesforupdate
166+  AA5A F1               pop af
167+  AA5B C9               ret
168+  AA5C
169+  AA5C              ;
170+  AA5C              ; Marks lines for update with char coords
171+  AA5C              ; Inputs:
172+  AA5C              ; l - number to update
173+  AA5C              ;
174+  AA5C              sprites_marklinesforupdatechar:
175+  AA5C F5               push af
176+  AA5D ED 43 AB AA      ld (origcoords),bc
177+  AA61 CD 66 AA         call sprites_marklinesforupdate
178+  AA64 F1               pop af
179+  AA65 C9               ret
180+  AA66
181+  AA66              ;
182+  AA66              ; Marks lines for update
183+  AA66              ; Inputs:
184+  AA66              ; l - number to update
185+  AA66              ;
186+  AA66              sprites_marklinesforupdate:
187+  AA66 ED 4B AB AA      ld bc,(origcoords)
188+  AA6A ED 5B 70 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
189+  AA6E 78               ld a,b
190+  AA6F 93               sub e
191+  AA70 47               ld b,a
192+  AA71 7D               ld a,l                          ; get loop counter
193+  AA72              sprites_marklinesforupdate0:
194+  AA72 C5               push bc
195+  AA73 08               ex af,af'                     ; store loop counter
196+  AA74 78               ld a,b
197+  AA75 CD BE A5         call buffer_marklineforupdate ; mark this line for update
198+  AA78 ED 4B AB AA      ld bc,(origcoords)            ; move the coords for the next line
199+  AA7C 04               inc b
200+  AA7D ED 43 AB AA      ld (origcoords),bc
201+  AA81 C1               pop bc
202+  AA82 04               inc b
203+  AA83 08               ex af,af'                     ; restore loop counter
204+  AA84 3D               dec a
205+  AA85 C2 72 AA         jp nz,sprites_marklinesforupdate0
206+  AA88 C9               ret
207+  AA89
208+  AA89              ;
209+  AA89              ; This routine returns a buffer address for (c, b) in de (c vert).
210+  AA89              ; For example: 0,0 will be at memory offset 0
211+  AA89              ; 1,0 (1 down) will be at memory offset 1
212+  AA89              ; 0,7 will be at memory offset 0
213+  AA89              ; 9,1 will be at memory offset 8+1
214+  AA89              ; 8,0 will be at memory offset 256
215+  AA89              ; 9,0 will be at memory offset 257
216+  AA89              ; Outputs:
217+  AA89              ; de - coords
218+  AA89              ;
219+  AA89              sprites_scadd:
220+  AA89 79               ld a,c               ; calculate vertical offset
221+  AA8A E6 F8            and 248             ;  to get nearest multiple of 8
222+  AA8C 0F               rrca
223+  AA8D 0F               rrca
224+  AA8E 0F               rrca                ; divide by 8
225+  AA8F 67               ld h,a
226+  AA90 78               ld a,b               ; calculate horizontal offset
227+  AA91 E6 F8            and 248             ;  to get nearest multiple of 8
228+  AA93 0F               rrca
229+  AA94 0F               rrca
230+  AA95 0F               rrca                ; divide by 8
231+  AA96 6F               ld l,a
232+  AA97 C5               push bc             ; store the screen coords
233+  AA98 44 4D            ld bc,hl            ; load bc with the character coords
234+  AA9A CD DE A8         call screen_getbufferaddress
235+  AA9D C1               pop bc              ; get back screen coords, de is now memory of character
236+  AA9E 79               ld a,c              ; now add the vertical within the cell
237+  AA9F E6 07            and 7
238+  AAA1 0F               rrca                ; multiply by 32.
239+  AAA2 0F               rrca
240+  AAA3 0F               rrca
241+  AAA4 6F               ld l,a
242+  AAA5 26 00            ld h,0
243+  AAA7 19               add hl,de
244+  AAA8 54 5D            ld de,hl
245+  AAAA C9               ret
246+  AAAB
247+  AAAB 00 00        origcoords   defb 0,0           ; general-use coordinates.
248+  AAAD
249+  AAAD 00           dispx   defb 0           ; general-use coordinates.
250+  AAAE 00           dispy   defb 0
251+  AAAF 00 00        sprtmp  defb 0,0           ; sprite temporary address.
252+  AAB1 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
253+  AAB3
# file closed: screen/sprites.asm
 26   AAB3                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AAB3              ;
  2+  AAB3              ; Draws the title screen
  3+  AAB3              ;
  4+  AAB3              titlescreen_show:
  5+  AAB3 CD 2B AB         call titlescreen_init
  6+  AAB6 CD D4 AA         call titlescreen_drawtitle
  7+  AAB9 3E FA            ld a,250                              ; wait for 200 frames
  8+  AABB CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
  9+  AABE 7B               ld a,e
 10+  AABF FE 01            cp 1                                  ; was anything pressed?
 11+  AAC1 C8               ret z                                 ; end titlescreen if so
 12+  AAC2
 13+  AAC2 CD 3E AB         call titlescreen_alt_init             ; otherwise, draw alt screen
 14+  AAC5 CD F0 AA         call titlescreen_alt_drawtitle
 15+  AAC8 3E FA            ld a,250                              ; wait for 200 frames
 16+  AACA CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 17+  AACD 7B               ld a,e
 18+  AACE FE 01            cp 1                                  ; was anything pressed?
 19+  AAD0 C2 B3 AA         jp nz,titlescreen_show                ; start again if not
 20+  AAD3 C9               ret
 21+  AAD4
 22+  AAD4              ;
 23+  AAD4              ; Draws the iconic logo
 24+  AAD4              ;
 25+  AAD4              titlescreen_drawtitle:
 26+  AAD4 06 67            ld b,103              ; number of points
 27+  AAD6 DD 21 4B AB      ld ix,titlescreen_logo_data
 28+  AADA              titlescreen_drawtitle0:
 29+  AADA C5               push bc
 30+  AADB DD 4E 00         ld c,(ix)                   ; got horiz
 31+  AADE DD 23            inc ix
 32+  AAE0 DD 46 00         ld b,(ix)                   ; got vert
 33+  AAE3 DD 23            inc ix
 34+  AAE5 CD 97 A8         call screen_getscreenattradress ; memory in de
 35+  AAE8 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 36+  AAE9 3E 13            ld a,19
 37+  AAEB 12               ld (de),a
 38+  AAEC C1               pop bc
 39+  AAED 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 40+  AAEF C9               ret
 41+  AAF0
 42+  AAF0              ;
 43+  AAF0              ; Draws the alternate title screen
 44+  AAF0              ;
 45+  AAF0              titlescreen_alt_drawtitle:
 46+  AAF0 21 3B 81         ld hl,string_alttitlescreen_1
 47+  AAF3 CD BE 84         call string_print
 48+  AAF6 21 47 81         ld hl,string_alttitlescreen_2
 49+  AAF9 CD BE 84         call string_print
 50+  AAFC 21 42 82         ld hl,string_alttitlescreen_3
 51+  AAFF CD BE 84         call string_print
 52+  AB02 06 20            ld b,32
 53+  AB04 3E 43            ld a,67
 54+  AB06 11 00 58         ld de,22528                         ; top row attrs here
 55+  AB09 CD 25 A8         call screen_setcolours
 56+  AB0C 06 20            ld b,32
 57+  AB0E 3E 46            ld a,70
 58+  AB10 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 59+  AB13 CD 25 A8         call screen_setcolours
 60+  AB16 06 20            ld b,32
 61+  AB18 3E 43            ld a,67
 62+  AB1A 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 63+  AB1D CD 25 A8         call screen_setcolours
 64+  AB20 06 20            ld b,32
 65+  AB22 3E 42            ld a,66
 66+  AB24 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 67+  AB27 CD 25 A8         call screen_setcolours
 68+  AB2A C9               ret
 69+  AB2B
 70+  AB2B              ;
 71+  AB2B              ; Initialises the screen
 72+  AB2B              ;
 73+  AB2B              titlescreen_init:
 74+  AB2B              ; We want a black screen.
 75+  AB2B 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 76+  AB2D                                      ; bright (64).
 77+  AB2D CD 67 80         call utilities_clearscreen
 78+  AB30 32 8D 5C         ld (23693),a        ; set our screen colours.
 79+  AB33 3E 01            ld a,1              ; 2 is the code for red.
 80+  AB35 D3 FE            out (254),a         ; write to port 254.
 81+  AB37
 82+  AB37 21 26 81         ld hl,string_titlescreen_copyright
 83+  AB3A CD BE 84         call string_print
 84+  AB3D
 85+  AB3D C9               ret
 86+  AB3E
 87+  AB3E              ;
 88+  AB3E              ; Initialises the screen
 89+  AB3E              ;
 90+  AB3E              titlescreen_alt_init:
 91+  AB3E              ; We want a black screen.
 92+  AB3E 3E 47            ld a,71             ; white ink (7) on black paper (0),
 93+  AB40                                      ; bright (64).
 94+  AB40 CD 67 80         call utilities_clearscreen
 95+  AB43 32 8D 5C         ld (23693),a        ; set our screen colours.
 96+  AB46 3E 00            ld a,0              ; 2 is the code for red.
 97+  AB48 D3 FE            out (254),a         ; write to port 254.
 98+  AB4A
 99+  AB4A C9               ret
100+  AB4B
101+  AB4B              ;
102+  AB4B              ; Horiz, vert
103+  AB4B              ;
104+  AB4B              titlescreen_logo_data:
105+  AB4B 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
105+  AB4F 0A 00 0C 00
105+  AB53 0F 00 11 00
105+  AB57 12 00 13 00
106+  AB5B 09 01 0C 01      defb 9,1,12,1,15,1,17,1
106+  AB5F 0F 01 11 01
107+  AB63 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
107+  AB67 0D 02 0E 02
107+  AB6B 0F 02 11 02
107+  AB6F 12 02 13 02
108+  AB73 09 03 0C 03      defb 9,3,12,3,15,3,17,3
108+  AB77 0F 03 11 03
109+  AB7B 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
109+  AB7F 0F 04 11 04
109+  AB83 12 04 13 04
110+  AB87 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
110+  AB8B 02 06 03 06
110+  AB8F 04 06 05 06
110+  AB93 06 06 07 06
110+  AB97 08 06 09 06
110+  AB9B 0A 06 0B 06
111+  AB9F 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
111+  ABA3 12 06 13 06
111+  ABA7 14 06 15 06
111+  ABAB 16 06 17 06
111+  ABAF 18 06 19 06
111+  ABB3 1A 06 1B 06
112+  ABB7 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
112+  ABBB 02 09 02 0A
112+  ABBF 02 0B 02 0C
112+  ABC3 02 0D 02 0E
112+  ABC7 02 0F 02 10
112+  ABCB 02 11 02 12
112+  ABCF 02 13 02 14
112+  ABD3 02 15
113+  ABD5 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
113+  ABD9 19 09 19 0A
113+  ABDD 19 0B 19 0C
113+  ABE1 19 0D 19 0E
113+  ABE5 19 0F 19 10
113+  ABE9 19 11 19 12
113+  ABED 19 13 19 14
113+  ABF1 19 15
114+  ABF3 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
114+  ABF7 05 0B 06 0B
114+  ABFB 07 0B 08 0B
114+  ABFF 09 0B 0A 0B
114+  AC03 0B 0B
115+  AC05 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
115+  AC09 0B 09 0B 0A
116+  AC0D 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
116+  AC11 10 10 10 11
116+  AC15 10 12 10 13
117+  AC19
# file closed: screen/titlescreen.asm
 27   AC19                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  AC19              ;
  2+  AC19              ; Draws the life remaining screen
  3+  AC19              ;
  4+  AC19              lifescreen_draw:
  5+  AC19 CD 5F AC         call lifescreen_init
  6+  AC1C
  7+  AC1C 3A 6C BB         ld a,(game_currentplayer)             ; get the current player
  8+  AC1F C6 30            add 48                                ; add 48 to get char
  9+  AC21 21 48 83         ld hl,string_lifescreen_player+10
 10+  AC24 77               ld (hl),a                             ; load this to the string we're about to show
 11+  AC25
 12+  AC25 21 3E 83         ld hl,string_lifescreen_player
 13+  AC28 CD BE 84         call string_print
 14+  AC2B
 15+  AC2B 3A A3 BB         ld a,(player+9)                       ; get the current player lives
 16+  AC2E C6 30            add 48                                ; add 48 to get the character
 17+  AC30 FE 31            cp 49
 18+  AC32 C2 45 AC         jp nz,lifescreen_draw0
 19+  AC35 21 58 83         ld hl,string_lifescreen_lastman
 20+  AC38
 21+  AC38 06 08            ld b,8
 22+  AC3A 3E 0A            ld a,10                                ; set red
 23+  AC3C 11 6C 58         ld de,22528+108                        ; attrs here
 24+  AC3F CD 25 A8         call screen_setcolours
 25+  AC42
 26+  AC42 C3 4C AC         jp lifescreen_draw1
 27+  AC45              lifescreen_draw0:
 28+  AC45 21 4D 83         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  AC48 77               ld (hl),a                             ; load this to the string we're about to show
 30+  AC49 21 4B 83         ld hl,string_lifescreen_lives
 31+  AC4C              lifescreen_draw1:
 32+  AC4C CD BE 84         call string_print
 33+  AC4F
 34+  AC4F 3E 86            ld a,134
 35+  AC51 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AC54 06 0A            ld b,10
 37+  AC56 CD 25 A8         call screen_setcolours
 38+  AC59
 39+  AC59 3E 64            ld a,100                              ; wait for 200 frames
 40+  AC5B CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 41+  AC5E
 42+  AC5E C9               ret
 43+  AC5F
 44+  AC5F              ;
 45+  AC5F              ; Initialises the screen
 46+  AC5F              ;
 47+  AC5F              lifescreen_init:
 48+  AC5F              ; We want a blue screen.
 49+  AC5F                  ;call $0D6B
 50+  AC5F 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 51+  AC61                                      ; bright (64).
 52+  AC61 CD 67 80         call utilities_clearscreen
 53+  AC64 32 8D 5C         ld (23693),a        ; set our screen colours.
 54+  AC67 3E 01            ld a,1              ; 1 is the code for blue.
 55+  AC69 D3 FE            out (254),a         ; write to port 254.
 56+  AC6B                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 57+  AC6B
 58+  AC6B C9               ret
# file closed: screen/lifescreen.asm
 28   AC6C                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AC6C              ;
  2+  AC6C              ; Draws the game over screen
  3+  AC6C              ;
  4+  AC6C              gameover_draw:
  5+  AC6C CD CA C2         call scores_processhighscores
  6+  AC6F
  7+  AC6F              gameover_draw0:
  8+  AC6F CD AF AC         call gameover_enterhighscores
  9+  AC72
 10+  AC72 CD 4D AD         call gameover_init
 11+  AC75
 12+  AC75 21 63 83         ld hl,string_gameoverscreen_gameover
 13+  AC78 CD BE 84         call string_print
 14+  AC7B
 15+  AC7B 21 6F 83         ld hl,string_gameoverscreen_copyright
 16+  AC7E CD BE 84         call string_print
 17+  AC81
 18+  AC81 CD 92 AC         call gameover_commontext
 19+  AC84
 20+  AC84 06 0B            ld b,11
 21+  AC86 3E 42            ld a,66
 22+  AC88 11 2B 58         ld de,22528+43                         ; attrs here
 23+  AC8B CD 25 A8         call screen_setcolours
 24+  AC8E CD 47 80         call utilities_waitforkey   ; wait for keypress
 25+  AC91
 26+  AC91 C9               ret
 27+  AC92
 28+  AC92              ;
 29+  AC92              ; Draws text shared by the game over and high score screens
 30+  AC92              ;
 31+  AC92              gameover_commontext:
 32+  AC92 CD F7 A7         call screen_setuptext       ; show scores
 33+  AC95 CD 94 C2         call scores_printscores     ; print the current scores
 34+  AC98
 35+  AC98 21 97 83         ld hl,string_gameover_credits
 36+  AC9B CD BE 84         call string_print
 37+  AC9E
 38+  AC9E 21 83 83         ld hl,string_gameoverscreen_bestscores
 39+  ACA1 CD BE 84         call string_print
 40+  ACA4
 41+  ACA4 06 20            ld b,32
 42+  ACA6 3E 45            ld a,69
 43+  ACA8 11 C0 5A         ld de,22528+704                         ; attrs here
 44+  ACAB CD 25 A8         call screen_setcolours
 45+  ACAE
 46+  ACAE C9               ret
 47+  ACAF
 48+  ACAF              ;
 49+  ACAF              ; If required, enter highscore
 50+  ACAF              ;
 51+  ACAF              gameover_enterhighscores:
 52+  ACAF                  ; check if we need to enter initial
 53+  ACAF 3A C9 C2         ld a,(scores_highscoretmp)
 54+  ACB2 FE 00            cp 0
 55+  ACB4 C8               ret z
 56+  ACB5 CD E3 AC         call gameover_enterhighscores_init
 57+  ACB8 3A C9 C2         ld a,(scores_highscoretmp)
 58+  ACBB 3D               dec a
 59+  ACBC 3D               dec a
 60+  ACBD 3D               dec a                                   ; get high score location back to position of name
 61+  ACBE 16 00            ld d,0
 62+  ACC0 5F               ld e,a
 63+  ACC1 21 50 C2         ld hl,scores_table
 64+  ACC4 19               add hl,de                               ; load memory into hl
 65+  ACC5 08               ex af,af'
 66+  ACC6 06 0F            ld b,15
 67+  ACC8 CD 82 80         call utilities_pauseforframes           ; pause for a little bit
 68+  ACCB 06 03            ld b,3                                  ; collect three chars
 69+  ACCD              gameover_draw2:
 70+  ACCD C5               push bc
 71+  ACCE E5               push hl
 72+  ACCF CD 86 80         call utilities_readkey               ; get key into a
 73+  ACD2 E1               pop hl
 74+  ACD3 77               ld (hl),a
 75+  ACD4 23               inc hl
 76+  ACD5 E5               push hl
 77+  ACD6 CD B6 C2         call scores_showtable
 78+  ACD9 E1               pop hl
 79+  ACDA 06 0F            ld b,15
 80+  ACDC CD 82 80         call utilities_pauseforframes
 81+  ACDF C1               pop bc
 82+  ACE0 10 EB            djnz gameover_draw2
 83+  ACE2 C9               ret
 84+  ACE3
 85+  ACE3              ;
 86+  ACE3              ; Displays the screen text for high score entry
 87+  ACE3              ;
 88+  ACE3              gameover_enterhighscores_init:
 89+  ACE3
 90+  ACE3 CD 4D AD         call gameover_init
 91+  ACE6 CD 92 AC         call gameover_commontext
 92+  ACE9
 93+  ACE9 21 A3 83         ld hl,string_highscore_congratulations
 94+  ACEC CD BE 84         call string_print
 95+  ACEF
 96+  ACEF 3A 6C BB         ld a,(game_currentplayer)
 97+  ACF2 FE 01            cp 1
 98+  ACF4 21 B5 83         ld hl,string_highscore_player1
 99+  ACF7 C3 FD AC         jp gameover_enterhighscores_init1
100+  ACFA              gameover_enterhighscores_init0:
101+  ACFA 21 C0 83         ld hl,string_highscore_player2
102+  ACFD              gameover_enterhighscores_init1:
103+  ACFD CD BE 84         call string_print
104+  AD00 06 60            ld b,96
105+  AD02 3E 43            ld a,67
106+  AD04 11 A0 58         ld de,22528+160                         ; attrs here
107+  AD07 CD 25 A8         call screen_setcolours
108+  AD0A
109+  AD0A 21 CB 83         ld hl,string_highscore_youhaveearned
110+  AD0D CD BE 84         call string_print
111+  AD10
112+  AD10 3A C9 C2         ld a,(scores_highscoretmp)
113+  AD13 FE 05            cp 5
114+  AD15 CA 23 AD         jp z, gameover_enterhighscores_init2    ; first place
115+  AD18 FE 11            cp 17
116+  AD1A CA 29 AD         jp z, gameover_enterhighscores_init3    ; 2nd place
117+  AD1D 21 07 84         ld hl,string_highscore_place3           ; 3rd place
118+  AD20 C3 2F AD         jp gameover_enterhighscores_init4
119+  AD23              gameover_enterhighscores_init2
120+  AD23 21 DD 83         ld hl,string_highscore_place1
121+  AD26 C3 2F AD         jp gameover_enterhighscores_init4
122+  AD29              gameover_enterhighscores_init3
123+  AD29 21 F2 83         ld hl,string_highscore_place2
124+  AD2C C3 2F AD         jp gameover_enterhighscores_init4
125+  AD2F              gameover_enterhighscores_init4
126+  AD2F CD BE 84         call string_print
127+  AD32
128+  AD32 06 60            ld b,96
129+  AD34 3E 42            ld a,66
130+  AD36 11 40 59         ld de,22528+320                         ; attrs here
131+  AD39 CD 25 A8         call screen_setcolours
132+  AD3C
133+  AD3C 21 1C 84         ld hl,string_highscore_pleaseenter
134+  AD3F CD BE 84         call string_print
135+  AD42
136+  AD42 06 60            ld b,96
137+  AD44 3E 46            ld a,70
138+  AD46 11 E0 59         ld de,22528+480                         ; attrs here
139+  AD49 CD 25 A8         call screen_setcolours
140+  AD4C C9               ret
141+  AD4D
142+  AD4D              ;
143+  AD4D              ; Initialises the screen
144+  AD4D              ;
145+  AD4D              gameover_init:
146+  AD4D              ; We want a black screen.
147+  AD4D 3E 47            ld a,71             ; white ink (7) on black paper (0),
148+  AD4F                                      ; bright (64).
149+  AD4F CD 67 80         call utilities_clearscreen
150+  AD52 32 8D 5C         ld (23693),a        ; set our screen colours.
151+  AD55 3E 00            ld a,0              ; 2 is the code for red.
152+  AD57 D3 FE            out (254),a         ; write to port 254.
153+  AD59 C9               ret
# file closed: screen/gameover.asm
 29   AD5A                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AD5A              ;
  2+  AD5A              ; Draws the level transition screen
  3+  AD5A              ;
  4+  AD5A              endlevel_draw:
  5+  AD5A CD 50 AE         call endlevel_init
  6+  AD5D CD 39 AE         call endlevel_commontext
  7+  AD60
  8+  AD60 21 A3 83         ld hl,string_highscore_congratulations
  9+  AD63 CD BE 84         call string_print
 10+  AD66
 11+  AD66 3A 6C BB         ld a,(game_currentplayer)
 12+  AD69 FE 01            cp 1
 13+  AD6B 21 B5 83         ld hl,string_highscore_player1
 14+  AD6E C3 74 AD         jp endlevel_init1
 15+  AD71              endlevel_init0:
 16+  AD71 21 C0 83         ld hl,string_highscore_player2
 17+  AD74              endlevel_init1:
 18+  AD74 CD BE 84         call string_print
 19+  AD77
 20+  AD77 21 39 84         ld hl,string_endlevel_youhaveearned
 21+  AD7A CD BE 84         call string_print
 22+  AD7D
 23+  AD7D CD D8 AD         call endlevel_workoutbonus
 24+  AD80 D5               push de
 25+  AD81 08               ex af,af'                               ; store the a value for later
 26+  AD82 CD BE 84         call string_print
 27+  AD85 D1               pop de
 28+  AD86 62 6B            ld hl,de                                ; get the points text into de
 29+  AD88 CD BE 84         call string_print
 30+  AD8B
 31+  AD8B 21 A4 84         ld hl, string_endlevel_anothergo
 32+  AD8E CD BE 84         call string_print
 33+  AD91
 34+  AD91 06 20            ld b,32
 35+  AD93 3E 23            ld a,35
 36+  AD95 11 60 59         ld de,22528+352                         ; attrs here
 37+  AD98 CD 25 A8         call screen_setcolours
 38+  AD9B
 39+  AD9B 06 20            ld b,32
 40+  AD9D 3E 25            ld a,37
 41+  AD9F 11 A0 59         ld de,22528+416                         ; attrs here
 42+  ADA2 CD 25 A8         call screen_setcolours
 43+  ADA5
 44+  ADA5 06 20            ld b,32
 45+  ADA7 3E 23            ld a,35
 46+  ADA9 11 E0 59         ld de,22528+480                         ; attrs here
 47+  ADAC CD 25 A8         call screen_setcolours
 48+  ADAF
 49+  ADAF 06 20            ld b,32
 50+  ADB1 3E 22            ld a,34
 51+  ADB3 11 40 5A         ld de,22528+576                         ; attrs here
 52+  ADB6 CD 25 A8         call screen_setcolours
 53+  ADB9
 54+  ADB9 08               ex af,af'                               ; get back a value with bonus type
 55+  ADBA 06 14            ld b,20
 56+  ADBC CD 82 80         call utilities_pauseforframes
 57+  ADBF
 58+  ADBF 47               ld b,a                      ; put the bonus count in b
 59+  ADC0              endlevel_init2:
 60+  ADC0 C5               push bc
 61+  ADC1 06 01            ld b,1
 62+  ADC3 CD 74 C2         call scores_addthousands
 63+  ADC6 CD 4A BC         call player_recordcurrentscore
 64+  ADC9 CD 94 C2         call scores_printscores     ; print the current scores
 65+  ADCC 06 0A            ld b,10
 66+  ADCE CD 82 80         call utilities_pauseforframes
 67+  ADD1 C1               pop bc
 68+  ADD2 10 EC            djnz endlevel_init2
 69+  ADD4
 70+  ADD4 CD 47 80         call utilities_waitforkey   ; wait for keypress
 71+  ADD7
 72+  ADD7 C9               ret
 73+  ADD8
 74+  ADD8              ;
 75+  ADD8              ; Works out the bonus
 76+  ADD8              ; Outputs:
 77+  ADD8              ; a = 15 (all seven)
 78+  ADD8              ; a = 10 (3 large or 4 small)
 79+  ADD8              ; a = 5 (1 large diamond)
 80+  ADD8              ; hl - pointer to bonus text
 81+  ADD8              ; de - pointer to points text
 82+  ADD8              ;
 83+  ADD8              endlevel_workoutbonus:
 84+  ADD8 21 C6 B3         ld hl,level01diamonds+2     ; location of state of first diamond
 85+  ADDB 06 03            ld b,3                      ; number to check
 86+  ADDD 16 00            ld d,0                      ; zero diamond count
 87+  ADDF              endlevel_workoutbonus0:
 88+  ADDF 7E               ld a,(hl)                   ; get state
 89+  ADE0 FE 01            cp 1
 90+  ADE2 C2 E6 AD         jp nz,endlevel_workoutbonus1 ; if not, move on
 91+  ADE5 14               inc d                       ; increment diamond count
 92+  ADE6              endlevel_workoutbonus1:
 93+  ADE6 23               inc hl
 94+  ADE7 23               inc hl
 95+  ADE8 23               inc hl
 96+  ADE9 23               inc hl
 97+  ADEA 23               inc hl                      ; get to next state
 98+  ADEB 10 F2            djnz endlevel_workoutbonus0
 99+  ADED
100+  ADED 21 D6 B3         ld hl,level01gems+2     ; location of state of first gem
101+  ADF0 06 04            ld b,4                      ; number to check
102+  ADF2 1E 00            ld e,0                      ; zero gem count
103+  ADF4              endlevel_workoutbonus2:
104+  ADF4 7E               ld a,(hl)                   ; get state
105+  ADF5 FE 01            cp 1
106+  ADF7 C2 FB AD         jp nz,endlevel_workoutbonus3 ; if not, move on
107+  ADFA 1C               inc e                       ; increment diamond count
108+  ADFB              endlevel_workoutbonus3:
109+  ADFB 23               inc hl
110+  ADFC 23               inc hl
111+  ADFD 23               inc hl
112+  ADFE 23               inc hl
113+  ADFF 23               inc hl                     ; get to next state
114+  AE00 10 F2            djnz endlevel_workoutbonus2
115+  AE02
116+  AE02 7A               ld a,d
117+  AE03 83               add e
118+  AE04 FE 07            cp 7                        ; check for max bonus
119+  AE06 C2 12 AE         jp nz,endlevel_workoutbonus4 ;
120+  AE09 3E 0F            ld a,15
121+  AE0B 21 69 84         ld hl, string_endlevel_bonus3
122+  AE0E 11 95 84         ld de, string_endlevel_points3
123+  AE11 C9               ret                         ; return with bonus of 15
124+  AE12              endlevel_workoutbonus4:
125+  AE12 7A               ld a,d                      ; check for for diamonds
126+  AE13 FE 03            cp 3
127+  AE15 C2 21 AE         jp nz,endlevel_workoutbonus5
128+  AE18 3E 0A            ld a,10
129+  AE1A 21 5A 84         ld hl, string_endlevel_bonus2
130+  AE1D 11 86 84         ld de, string_endlevel_points2
131+  AE20 C9               ret                         ; return with bonus of ten
132+  AE21              endlevel_workoutbonus5:
133+  AE21 7B               ld a,e                      ; check for four gems
134+  AE22 FE 04            cp 4
135+  AE24 C2 30 AE         jp nz,endlevel_workoutbonus6
136+  AE27 3E 0A            ld a,10
137+  AE29 21 5A 84         ld hl, string_endlevel_bonus2
138+  AE2C 11 86 84         ld de, string_endlevel_points2
139+  AE2F C9               ret                         ; return with bonus of 10
140+  AE30              endlevel_workoutbonus6:
141+  AE30 3E 05            ld a,5                      ; otherwise, bonus is 5
142+  AE32 21 4B 84         ld hl, string_endlevel_bonus1
143+  AE35 11 78 84         ld de, string_endlevel_points1
144+  AE38 C9               ret
145+  AE39
146+  AE39              ;
147+  AE39              ; Draws text shared by the game over and high score screens
148+  AE39              ;
149+  AE39              endlevel_commontext:
150+  AE39 CD F7 A7         call screen_setuptext       ; show scores
151+  AE3C CD 94 C2         call scores_printscores     ; print the current scores
152+  AE3F
153+  AE3F 21 83 83         ld hl,string_gameoverscreen_bestscores
154+  AE42 CD BE 84         call string_print
155+  AE45
156+  AE45 06 20            ld b,32
157+  AE47 3E 45            ld a,69
158+  AE49 11 C0 5A         ld de,22528+704                         ; attrs here
159+  AE4C CD 25 A8         call screen_setcolours
160+  AE4F
161+  AE4F C9               ret
162+  AE50
163+  AE50              ;
164+  AE50              ; Initialises the screen
165+  AE50              ;
166+  AE50              endlevel_init:
167+  AE50              ; We want a green screen.
168+  AE50 3E 21            ld a,33             ; white ink (7) on black paper (0),
169+  AE52                                      ; bright (64).
170+  AE52 CD 67 80         call utilities_clearscreen
171+  AE55 32 8D 5C         ld (23693),a        ; set our screen colours.
172+  AE58 3E 00            ld a,0              ; 2 is the code for red.
173+  AE5A D3 FE            out (254),a         ; write to port 254.
174+  AE5C C9               ret
# file closed: screen/endlevel.asm
 30   AE5D
 31   AE5D                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  AE5D              sound_gemcollected:
  2+  AE5D 21 C8 00         ld hl,200 ; pitch.
  3+  AE60 11 3E 00         ld de,62 ; duration.
  4+  AE63 CD B5 03         call 949 ; ROM beeper routine.
  5+  AE66 C9               ret
  6+  AE67
  7+  AE67              sound_pitchbend:
  8+  AE67 21 F4 01         ld hl,500 ; starting pitch.
  9+  AE6A 06 FA            ld b,250 ; length of pitch bend.
 10+  AE6C              sound_pitchbend0:
 11+  AE6C C5                push bc
 12+  AE6D E5               push hl ; store pitch.
 13+  AE6E 11 01 00         ld de,1 ; very short duration.
 14+  AE71 CD B5 03         call 949 ; ROM beeper routine.
 15+  AE74 E1               pop hl ; restore pitch.
 16+  AE75 23               inc hl ; pitch going up.
 17+  AE76 C1               pop bc
 18+  AE77 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  AE79 C9               ret
 20+  AE7A
 21+  AE7A              sound_rockfell:
 22+  AE7A 08               ex af,af'
 23+  AE7B 1E 32            ld e,50 ; repeat 250 times.
 24+  AE7D 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  AE80 D5           sound_rockfell2 push de
 26+  AE81 06 20            ld b,32 ; length of step.
 27+  AE83 C5           sound_rockfell0 push bc
 28+  AE84 7E               ld a,(hl) ; next "random" number.
 29+  AE85 23               inc hl ; pointer.
 30+  AE86 E6 F8            and 248 ; we want a black border.
 31+  AE88 D3 FE            out (254),a ; write to speaker.
 32+  AE8A 7B               ld a,e ; as e gets smaller...
 33+  AE8B 2F               cpl ; ...we increase the delay.
 34+  AE8C 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  AE8D 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  AE8F C1               pop bc
 37+  AE90 10 F1            djnz sound_rockfell0 ; next step.
 38+  AE92 D1               pop de
 39+  AE93 7B               ld a,e
 40+  AE94 D6 18            sub 24 ; size of step.
 41+  AE96 FE 1E            cp 30 ; end of range.
 42+  AE98 CA A9 AE         jp z,sound_rockfell5
 43+  AE9B DA A9 AE         jp c, sound_rockfell5
 44+  AE9E 5F               ld e,a
 45+  AE9F 2F               cpl
 46+  AEA0 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  AEA2 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  AEA4 3D               dec a
 49+  AEA5 20 F9            jr nz,sound_rockfell3
 50+  AEA7 18 D7            jr sound_rockfell2
 51+  AEA9              sound_rockfell5
 52+  AEA9 08               ex af,af'
 53+  AEAA C9               ret
 54+  AEAB
# file closed: sound/sound.asm
 32   AEAB
 33   AEAB                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  AEAB              ; ###############################################################
  2+  AEAB              ; Data for level 1
  3+  AEAB              ; ###############################################################
  4+  AEAB              level01:
  5+  AEAB
  6+  AEAB                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  AEAB
  8+  AEAB 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  AEAF 05 05 05 05
  8+  AEB3 05 05 05 05
  8+  AEB7 05 05 02 01
  8+  AEBB 01 01 03 05
  8+  AEBF 05 05 05 05
  8+  AEC3 05 05 05 05
  8+  AEC7 05 05 00 00
  9+  AECB 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  AECF 05 05 05 05
  9+  AED3 05 05 05 05
  9+  AED7 02 01 01 01
  9+  AEDB 01 01 01 01
  9+  AEDF 03 05 05 05
  9+  AEE3 05 05 05 05
  9+  AEE7 05 05 00 00
 10+  AEEB 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  AEEF 05 05 05 05
 10+  AEF3 05 05 02 01
 10+  AEF7 01 01 01 01
 10+  AEFB 01 01 01 01
 10+  AEFF 01 01 03 05
 10+  AF03 0D 0D 0D 0D
 10+  AF07 0D 0D 00 00
 11+  AF0B 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  AF0F 01 01 00 01
 11+  AF13 01 01 01 01
 11+  AF17 01 01 01 01
 11+  AF1B 01 01 01 01
 11+  AF1F 01 01 01 03
 11+  AF23 05 05 05 05
 11+  AF27 05 05 00 00
 12+  AF2B 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  AF2F 04 04 04 04
 12+  AF33 04 04 01 01
 12+  AF37 01 01 01 01
 12+  AF3B 01 01 01 01
 12+  AF3F 01 01 01 01
 12+  AF43 01 01 01 01
 12+  AF47 00 01 00 00
 13+  AF4B 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  AF4F 04 04 04 04
 13+  AF53 04 04 04 04
 13+  AF57 01 01 01 01
 13+  AF5B 01 01 01 01
 13+  AF5F 01 01 01 01
 13+  AF63 00 00 00 00
 13+  AF67 00 01 00 00
 14+  AF6B 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  AF6F 04 01 01 01
 14+  AF73 01 01 04 04
 14+  AF77 04 04 01 01
 14+  AF7B 01 01 01 01
 14+  AF7F 01 00 00 00
 14+  AF83 00 01 01 01
 14+  AF87 01 01 00 00
 15+  AF8B 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  AF8F 04 04 04 04
 15+  AF93 04 01 04 04
 15+  AF97 04 04 04 04
 15+  AF9B 04 04 00 00
 15+  AF9F 00 00 04 04
 15+  AFA3 04 04 04 04
 15+  AFA7 04 01 00 00
 16+  AFAB 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  AFAF 01 04 01 01
 16+  AFB3 01 01 04 04
 16+  AFB7 04 04 04 04
 16+  AFBB 04 04 00 04
 16+  AFBF 04 04 04 04
 16+  AFC3 04 04 04 04
 16+  AFC7 04 01 00 00
 17+  AFCB 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  AFCF 00 00 00 00
 17+  AFD3 00 04 04 04
 17+  AFD7 04 04 04 04
 17+  AFDB 04 04 00 04
 17+  AFDF 04 04 04 04
 17+  AFE3 04 04 04 04
 17+  AFE7 04 01 00 00
 18+  AFEB 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  AFEF 15 15 15 15
 18+  AFF3 15 01 04 04
 18+  AFF7 04 04 04 04
 18+  AFFB 04 04 00 04
 18+  AFFF 04 04 04 04
 18+  B003 04 04 04 04
 18+  B007 04 01 00 00
 19+  B00B 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B00F 00 00 00 00
 19+  B013 00 01 04 04
 19+  B017 04 04 04 04
 19+  B01B 04 04 00 04
 19+  B01F 04 04 04 04
 19+  B023 04 00 00 00
 19+  B027 00 01 00 00
 20+  B02B 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B02F 00 00 00 00
 20+  B033 00 01 04 04
 20+  B037 04 04 04 04
 20+  B03B 04 04 00 04
 20+  B03F 04 04 04 04
 20+  B043 04 00 04 04
 20+  B047 00 01 00 00
 21+  B04B 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B04F 06 06 06 06
 21+  B053 06 01 04 04
 21+  B057 04 04 04 04
 21+  B05B 04 04 00 04
 21+  B05F 04 04 04 04
 21+  B063 04 00 04 04
 21+  B067 00 01 00 00
 22+  B06B 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B06F 1A 1A 1A 1A
 22+  B073 1A 01 04 00
 22+  B077 00 00 00 00
 22+  B07B 00 00 00 00
 22+  B07F 00 00 00 00
 22+  B083 00 00 04 04
 22+  B087 00 01 00 00
 23+  B08B 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B08F 1A 1A 1A 1A
 23+  B093 1A 01 04 00
 23+  B097 04 04 04 04
 23+  B09B 04 04 00 04
 23+  B09F 04 04 00 04
 23+  B0A3 04 04 04 04
 23+  B0A7 00 01 00 00
 24+  B0AB 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B0AF 1A 1A 1A 1A
 24+  B0B3 1A 01 04 00
 24+  B0B7 04 04 04 04
 24+  B0BB 04 04 00 04
 24+  B0BF 04 04 00 04
 24+  B0C3 04 04 04 04
 24+  B0C7 00 01 00 00
 25+  B0CB 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B0CF 01 01 01 01
 25+  B0D3 01 01 04 00
 25+  B0D7 04 04 04 04
 25+  B0DB 04 04 00 04
 25+  B0DF 04 04 00 04
 25+  B0E3 04 04 04 04
 25+  B0E7 00 01 00 00
 26+  B0EB 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B0EF 04 04 04 04
 26+  B0F3 04 04 04 00
 26+  B0F7 04 04 04 04
 26+  B0FB 04 04 00 04
 26+  B0FF 04 04 00 00
 26+  B103 00 00 04 04
 26+  B107 04 01 00 00
 27+  B10B 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B10F 04 04 00 00
 27+  B113 00 00 00 00
 27+  B117 04 04 04 04
 27+  B11B 04 04 00 04
 27+  B11F 04 04 04 04
 27+  B123 04 00 04 04
 27+  B127 04 01 00 00
 28+  B12B 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B12F 04 04 00 04
 28+  B133 04 04 04 04
 28+  B137 04 04 04 04
 28+  B13B 04 04 00 04
 28+  B13F 04 04 04 04
 28+  B143 04 00 04 04
 28+  B147 04 01 00 00
 29+  B14B 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B14F 04 04 00 04
 29+  B153 04 04 01 01
 29+  B157 01 01 01 01
 29+  B15B 01 01 01 01
 29+  B15F 01 01 01 01
 29+  B163 04 00 04 04
 29+  B167 04 01 00 00
 30+  B16B 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B16F 04 04 00 04
 30+  B173 04 04 01 00
 30+  B177 00 00 00 00
 30+  B17B 00 00 00 00
 30+  B17F 00 00 00 01
 30+  B183 04 00 04 04
 30+  B187 04 01 00 00
 31+  B18B 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B18F 04 04 00 04
 31+  B193 04 04 01 00
 31+  B197 00 00 00 00
 31+  B19B 00 00 00 00
 31+  B19F 00 00 00 01
 31+  B1A3 04 00 04 04
 31+  B1A7 04 01 00 00
 32+  B1AB 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B1AF 04 04 00 04
 32+  B1B3 04 04 01 00
 32+  B1B7 00 00 00 00
 32+  B1BB 00 00 00 00
 32+  B1BF 00 00 00 01
 32+  B1C3 04 00 04 04
 32+  B1C7 04 01 00 00
 33+  B1CB 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B1CF 04 04 00 04
 33+  B1D3 04 04 04 00
 33+  B1D7 00 00 00 00
 33+  B1DB 00 00 00 00
 33+  B1DF 00 00 00 04
 33+  B1E3 04 04 04 04
 33+  B1E7 04 01 00 00
 34+  B1EB 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B1EF 04 04 04 04
 34+  B1F3 04 04 01 00
 34+  B1F7 00 00 00 00
 34+  B1FB 00 00 00 00
 34+  B1FF 00 00 00 01
 34+  B203 04 04 04 04
 34+  B207 04 01 00 00
 35+  B20B 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B20F 04 04 04 04
 35+  B213 04 04 01 00
 35+  B217 00 00 01 00
 35+  B21B 00 00 00 01
 35+  B21F 00 00 00 01
 35+  B223 04 04 04 04
 35+  B227 04 01 00 00
 36+  B22B 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B22F 01 01 01 01
 36+  B233 01 01 01 01
 36+  B237 01 01 01 01
 36+  B23B 01 01 01 01
 36+  B23F 01 01 01 01
 36+  B243 01 01 01 01
 36+  B247 01 01 00 00
 37+  B24B
 38+  B24B              ; ###############################################################
 39+  B24B              ; Object data: horiz, vert, state, memh, meml
 40+  B24B              ; ###############################################################
 41+  B24B              level01rocks:
 42+  B24B 09 04 00 00      defb 9,4,0,0,0
 42+  B24F 00
 43+  B250 0C 07 00 00      defb 12,7,0,0,0
 43+  B254 00
 44+  B255 10 07 00 00      defb 16,7,0,0,0
 44+  B259 00
 45+  B25A 0B 08 00 00      defb 11,8,0,0,0
 45+  B25E 00
 46+  B25F 0A 0A 00 00      defb 10,10,0,0,0
 46+  B263 00
 47+  B264 0C 0A 00 00      defb 12,10,0,0,0
 47+  B268 00
 48+  B269 0D 09 00 00      defb 13,9,0,0,0
 48+  B26D 00
 49+  B26E 0E 08 00 00      defb 14,8,0,0,0
 49+  B272 00
 50+  B273 0F 0B 00 00      defb 15,11,0,0,0
 50+  B277 00
 51+  B278 0B 0C 00 00      defb 11,12,0,0,0
 51+  B27C 00
 52+  B27D 11 0C 00 00      defb 17,12,0,0,0
 52+  B281 00
 53+  B282 13 08 00 00      defb 19,8,0,0,0
 53+  B286 00
 54+  B287 16 09 00 00      defb 22,9,0,0,0
 54+  B28B 00
 55+  B28C 13 0A 00 00      defb 19,10,0,0,0
 55+  B290 00
 56+  B291 15 0A 00 00      defb 21,10,0,0,0
 56+  B295 00
 57+  B296 15 0C 00 00      defb 21,12,0,0,0
 57+  B29A 00
 58+  B29B 16 0C 00 00      defb 22,12,0,0,0
 58+  B29F 00
 59+  B2A0 18 0A 00 00      defb 24,10,0,0,0
 59+  B2A4 00
 60+  B2A5 19 09 00 00      defb 25,9,0,0,0
 60+  B2A9 00
 61+  B2AA 1C 09 00 00      defb 28,9,0,0,0
 61+  B2AE 00
 62+  B2AF 1B 0C 00 00      defb 27,12,0,0,0
 62+  B2B3 00
 63+  B2B4 1A 0D 00 00      defb 26,13,0,0,0
 63+  B2B8 00
 64+  B2B9 19 0E 00 00      defb 25,14,0,0,0
 64+  B2BD 00
 65+  B2BE 19 10 00 00      defb 25,16,0,0,0
 65+  B2C2 00
 66+  B2C3 1A 11 00 00      defb 26,17,0,0,0
 66+  B2C7 00
 67+  B2C8 1B 11 00 00      defb 27,17,0,0,0
 67+  B2CC 00
 68+  B2CD 1C 12 00 00      defb 28,18,0,0,0
 68+  B2D1 00
 69+  B2D2 1A 13 00 00      defb 26,19,0,0,0
 69+  B2D6 00
 70+  B2D7 1B 15 00 00      defb 27,21,0,0,0
 70+  B2DB 00
 71+  B2DC 1A 17 00 00      defb 26,23,0,0,0
 71+  B2E0 00
 72+  B2E1 1B 18 00 00      defb 27,24,0,0,0
 72+  B2E5 00
 73+  B2E6 19 18 00 00      defb 25,24,0,0,0
 73+  B2EA 00
 74+  B2EB 18 17 00 00      defb 24,23,0,0,0
 74+  B2EF 00
 75+  B2F0 13 14 00 00      defb 19,20,0,0,0
 75+  B2F4 00
 76+  B2F5 14 12 00 00      defb 20,18,0,0,0
 76+  B2F9 00
 77+  B2FA 14 10 00 00      defb 20,16,0,0,0
 77+  B2FE 00
 78+  B2FF 15 10 00 00      defb 21,16,0,0,0
 78+  B303 00
 79+  B304 16 12 00 00      defb 22,18,0,0,0
 79+  B308 00
 80+  B309 11 14 00 00      defb 17,20,0,0,0
 80+  B30D 00
 81+  B30E 0D 11 00 00      defb 13,17,0,0,0
 81+  B312 00
 82+  B313 0C 13 00 00      defb 12,19,0,0,0
 82+  B317 00
 83+  B318 0B 13 00 00      defb 11,19,0,0,0
 83+  B31C 00
 84+  B31D 0A 11 00 00      defb 10,17,0,0,0
 84+  B321 00
 85+  B322 05 12 00 00      defb 5,18,0,0,0
 85+  B326 00
 86+  B327 07 16 00 00      defb 7,22,0,0,0
 86+  B32B 00
 87+  B32C 09 16 00 00      defb 9,22,0,0,0
 87+  B330 00
 88+  B331 07 18 00 00      defb 7,24,0,0,0
 88+  B335 00
 89+  B336 05 18 00 00      defb 5,24,0,0,0
 89+  B33A 00
 90+  B33B 06 19 00 00      defb 6,25,0,0,0
 90+  B33F 00
 91+  B340 08 19 00 00      defb 8,25,0,0,0
 91+  B344 00
 92+  B345 04 17 00 00      defb 4,23,0,0,0
 92+  B349 00
 93+  B34A FF               defb 255
 94+  B34B
 95+  B34B              level01missiles:
 96+  B34B 0B 17 00 00      defb 11,23,0,0,0
 96+  B34F 00
 97+  B350 0B 16 00 00      defb 11,22,0,0,0
 97+  B354 00
 98+  B355 0C 17 00 00      defb 12,23,0,0,0
 98+  B359 00
 99+  B35A 0C 16 00 00      defb 12,22,0,0,0
 99+  B35E 00
100+  B35F 0D 17 00 00      defb 13,23,0,0,0
100+  B363 00
101+  B364 0D 16 00 00      defb 13,22,0,0,0
101+  B368 00
102+  B369 0E 17 00 00      defb 14,23,0,0,0
102+  B36D 00
103+  B36E 0E 16 00 00      defb 14,22,0,0,0
103+  B372 00
104+  B373 0F 17 00 00      defb 15,23,0,0,0
104+  B377 00
105+  B378 0F 16 00 00      defb 15,22,0,0,0
105+  B37C 00
106+  B37D 10 17 00 00      defb 16,23,0,0,0
106+  B381 00
107+  B382 10 16 00 00      defb 16,22,0,0,0
107+  B386 00
108+  B387 11 17 00 00      defb 17,23,0,0,0
108+  B38B 00
109+  B38C 11 16 00 00      defb 17,22,0,0,0
109+  B390 00
110+  B391 12 17 00 00      defb 18,23,0,0,0
110+  B395 00
111+  B396 12 16 00 00      defb 18,22,0,0,0
111+  B39A 00
112+  B39B 13 17 00 00      defb 19,23,0,0,0
112+  B39F 00
113+  B3A0 13 16 00 00      defb 19,22,0,0,0
113+  B3A4 00
114+  B3A5 14 17 00 00      defb 20,23,0,0,0
114+  B3A9 00
115+  B3AA 14 16 00 00      defb 20,22,0,0,0
115+  B3AE 00
116+  B3AF 15 17 00 00      defb 21,23,0,0,0
116+  B3B3 00
117+  B3B4 15 16 00 00      defb 21,22,0,0,0
117+  B3B8 00
118+  B3B9 16 17 00 00      defb 22,23,0,0,0
118+  B3BD 00
119+  B3BE 16 16 00 00      defb 22,22,0,0,0
119+  B3C2 00
120+  B3C3 FF               defb 255
121+  B3C4
122+  B3C4              ;
123+  B3C4              ; Diamonds: x,y,state,mem1+mem2
124+  B3C4              ;
125+  B3C4              level01diamonds:
126+  B3C4 0C 1B 00 00      defb 12,27,0,0,0
126+  B3C8 00
127+  B3C9 10 1B 00 00      defb 16,27,0,0,0
127+  B3CD 00
128+  B3CE 15 1B 00 00      defb 21,27,0,0,0
128+  B3D2 00
129+  B3D3 FF               defb 255
130+  B3D4
131+  B3D4              level01gems:
132+  B3D4 12 14 00 00      defb 18,20,0,0,0
132+  B3D8 00
133+  B3D9 06 18 00 00      defb 6,24,0,0,0
133+  B3DD 00
134+  B3DE 19 17 00 00      defb 25,23,0,0,0
134+  B3E2 00
135+  B3E3 1C 11 00 00      defb 28,17,0,0,0
135+  B3E7 00
136+  B3E8 FF               defb 255
137+  B3E9              ;
138+  B3E9              ; Score area colours
139+  B3E9              ;
140+  B3E9              score_colours:
141+  B3E9 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  B3ED 47 47 47 47
141+  B3F1 47 47 47 42
141+  B3F5 43 43 43 43
141+  B3F9 43 43 43 43
141+  B3FD 42 47 47 47
141+  B401 47 47 47 47
141+  B405 47 47 47 47
142+  B409 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  B40D 47 47 47 47
142+  B411 47 47 47 46
142+  B415 46 46 46 46
142+  B419 46 46 46 46
142+  B41D 46 47 47 47
142+  B421 47 47 47 47
142+  B425 47 47 47 47
143+  B429
144+  B429              high_score_colours:
145+  B429 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  B42D 42 42 47 47
145+  B431 47 47 47 47
145+  B435 43 43 43 47
145+  B439 47 47 47 47
145+  B43D 47 46 46 46
145+  B441 47 47 47 47
145+  B445 47 47 00 00
# file closed: leveldata/level01.asm
 34   B449                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B449              ; Tiles graphics.
  2+  B449              sprites:
  3+  B449 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B44D 00 00 00 00
  4+  B451 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B455 FF FF FF FF
  5+  B459 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B45D 1F 3F 7F FF
  6+  B461 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B465 F8 FC FE FF
  7+  B469 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B46D 55 AA 55 AA
  8+  B471 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B475 00 00 00 00
  9+  B479 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  B47D FF FF FF FF
 10+  B481 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  B485 00 00 00 00
 11+  B489 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B48D F1 72 34 18
 12+  B491 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B495 FE FE FF 7E
 13+  B499 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B49D FE FF 7E 3C
 14+  B4A1 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B4A5 00 00 FF FF
 15+  B4A9 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  B4AD FF 42 24 18
 16+  B4B1 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B4B5 00 00 00 00
 17+  B4B9 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B4BD 00 3C 5A 34
 18+  B4C1 FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  B4C5 FD FE FD FE
 19+  B4C9 F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  B4CD F4 F8 F4 F8
 20+  B4D1 D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  B4D5 D0 E0 D0 E0
 21+  B4D9 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  B4DD 40 80 40 80
 22+  B4E1 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  B4E5 ED 00 00 00
 23+  B4E9 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  B4ED FF 7E 3C 18
 24+  B4F1 FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  B4F5 00 00 00 00
 25+  B4F9 FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  B4FD 00 00 00 00
 26+  B501 F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  B505 00 00 00 00
 27+  B509 C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  B50D 00 00 00 00
 28+  B511 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  B515 00 00 00 00
 29+  B519 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  B51D FF FF FF FF
 30+  B521
 31+  B521
 32+  B521              sprite_attrs:
 33+  B521 46               defb    070 ; 0, space
 34+  B522 4D               defb    077 ; 1, cyan block
 35+  B523 4D               defb    077 ; 2, slope left
 36+  B524 4D               defb    077 ; 3, slope right
 37+  B525 46               defb    070 ; 4, dirt
 38+  B526 4E               defb    078 ; 5, sky
 39+  B527 4C               defb    076 ; 6, slime
 40+  B528 42               defb    066 ; 7, trapdoor
 41+  B529 46               defb    070 ; 8, diamond
 42+  B52A 42               defb    066 ; 9, rock
 43+  B52B 42               defb    066 ; 10, rock 2
 44+  B52C 49           	defb    073 ; 11, sky, trapdoor
 45+  B52D 43           	defb    067 ; 12, missile
 46+  B52E 4A               defb    074 ; 13, sky, red ink (tank)
 47+  B52F 46               defb    070 ; 14, gem
 48+  B530 4D               defb    077 ; 15, damaged mountain
 49+  B531 4D               defb    077 ; 16, damaged mountain 2
 50+  B532 4D               defb    077 ; 17, damaged mountain 3
 51+  B533 4D               defb    077 ; 18, damaged mountain 4
 52+  B534 00           	defb 	000 ; 19, tank missile (not used
 53+  B535 43           	defb    067 ; 20, missile active
 54+  B536 42           	defb	066	; 21, the pit 1
 55+  B537 42           	defb	066	; 22, the pit 2
 56+  B538 42           	defb	066	; 23, the pit 3
 57+  B539 42           	defb	066	; 24, the pit 4
 58+  B53A 42           	defb	066	; 25, the pit 5
 59+  B53B 64           	defb    100 ; 26, slime, green on green
 60+  B53C
 61+  B53C
 62+  B53C              player_sprite:
 63+  B53C 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 63+  B540 38 3D C3 80
 64+  B544 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 64+  B548 3C 1C 16 32
 65+  B54C 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 65+  B550 3C 38 68 4C
 66+  B554 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 66+  B558 1C BC C3 01
 67+  B55C 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 67+  B560 3C 3C 64 0C
 68+  B564 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 68+  B568 3C 3C 26 30
 69+  B56C 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 69+  B570 1E 5C FD 5F
 70+  B574 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 70+  B578 4F 8F 19 03
 71+  B57C 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 71+  B580 F2 F1 98 C0
 72+  B584 FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 72+  B588 48 08 14 2A
 73+  B58C 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 73+  B590 38 78 44 C3
 74+  B594 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 74+  B598 1C 1E 22 C3
 75+  B59C 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 75+  B5A0 6F 45 E1 9B
 76+  B5A4 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 76+  B5A8 F6 A2 87 D9
 77+  B5AC
 78+  B5AC              ;
 79+  B5AC              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 80+  B5AC              ;
 81+  B5AC              ship_sprite:
 82+  B5AC 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 82+  B5B0 03 1F 7F FF
 83+  B5B4 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 83+  B5B8 FF FF FF FF
 84+  B5BC F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 84+  B5C0 FF FF FF FF
 85+  B5C4 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 85+  B5C8 C0 F8 FE FF
 86+  B5CC B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 86+  B5D0 03 03 02 07
 87+  B5D4 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 87+  B5D8 FF 0F 07 83
 88+  B5DC 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 88+  B5E0 FF 10 20 C1
 89+  B5E4 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 89+  B5E8 C0 C0 40 E0
 90+  B5EC 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 90+  B5F0 03 03 02 07
 91+  B5F4 F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 91+  B5F8 FF 08 04 83
 92+  B5FC F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 92+  B600 FF F0 E0 C1
 93+  B604 CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 93+  B608 C0 C0 40 E0
 94+  B60C
 95+  B60C              ;
 96+  B60C              ;  First 8 frames are tank, last frame is the gun barrel
 97+  B60C              ;
 98+  B60C              tank_sprite:
 99+  B60C 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 99+  B610 7F 00 00 00
100+  B614 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
100+  B618 FE FF 7F 40
101+  B61C FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
101+  B620 03 FF FF 01
102+  B624 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
102+  B628 E0 C0 00 00
103+  B62C 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
103+  B630 F7 E1 7F 3F
104+  B634 FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
104+  B638 54 16 FF FF
105+  B63C FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
105+  B640 9B A8 FF FF
106+  B644 FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
106+  B648 9F AF FE FC
107+  B64C 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
107+  B650 1F 00 00 00
108+  B654
109+  B654              monster_sprite:
110+  B654 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
110+  B658 0B D0 16 68
111+  B65C 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
111+  B660 35 AC 7F FE
112+  B664 FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
112+  B668 8F F1 8F F1
113+  B66C 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
113+  B670 18 18 00 00
114+  B674 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
114+  B678 0B D0 16 68
115+  B67C 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
115+  B680 F5 AF FF FF
116+  B684 BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
116+  B688 0F F0 0F F0
117+  B68C 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
117+  B690 00 00 00 00
118+  B694
119+  B694              robot_sprite:
120+  B694 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
120+  B698 CE 12 22 66
121+  B69C 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
121+  B6A0 4E 12 24 6C
122+  B6A4 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
122+  B6A8 4E 32 63 03
123+  B6AC 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
123+  B6B0 CE 0A 09 1B
124+  B6B4 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
124+  B6B8 73 48 44 66
125+  B6BC 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
125+  B6C0 72 48 24 36
126+  B6C4 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
126+  B6C8 72 4C C6 C0
127+  B6CC 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
127+  B6D0 73 50 90 D8
# file closed: graphics/graphics.asm
 35   B6D4
 36   B6D4                  include "game\control.asm"
# file opened: game/control.asm
  1+  B6D4              ;
  2+  B6D4              ; Check the keyboard then move
  3+  B6D4              ;
  4+  B6D4              control_keyboard:
  5+  B6D4 3A A5 BB         ld a,(player+11)    ; first, check if player is dying
  6+  B6D7 FE 04            cp 4                ; is the player falling
  7+  B6D9 CC 49 B7         call z, control_fall
  8+  B6DC FE 05            cp 5                ; is the player fighting
  9+  B6DE CC 36 B7         call z, control_fight
 10+  B6E1 3A A5 BB         ld a,(player+11)    ; first, check if player is dying
 11+  B6E4 FE 00            cp 0
 12+  B6E6 C0               ret nz               ; if so, can't move
 13+  B6E7 3A 9F BB         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  B6EA FE 00            cp 0
 15+  B6EC CA F3 B6         jp z, control_keyboard5
 16+  B6EF CD 27 B8         call control_automove
 17+  B6F2 C9               ret
 18+  B6F3              control_keyboard5:
 19+  B6F3 3A A0 BB         ld a,(player+6)      ; next, check if the player is digging
 20+  B6F6 FE 00            cp 0
 21+  B6F8 CA FF B6         jp z, control_keyboard0
 22+  B6FB CD 65 B7         call control_dig
 23+  B6FE C9               ret
 24+  B6FF              control_keyboard0:
 25+  B6FF 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 26+  B702 ED 78            in a,(c)            ; read keyboard.
 27+  B704 47               ld b,a              ; store result in b register.
 28+  B705 CB 18            rr b                ; check outermost key (q).
 29+  B707 D2 26 B7         jp nc,control_keyboard1
 30+  B70A 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 31+  B70D ED 78            in a,(c)            ; read keyboard.
 32+  B70F 47               ld b,a              ; store result in b register.
 33+  B710 CB 18            rr b                ; check outermost key (a).
 34+  B712 D2 2A B7         jp nc,control_keyboard2
 35+  B715 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 36+  B718 ED 78            in a,(c)            ; read keyboard.
 37+  B71A 47               ld b,a              ; store result in b register.
 38+  B71B CB 18            rr b                ; check outermost key (p).
 39+  B71D D2 2E B7         jp nc,control_keyboard3
 40+  B720 CB 18            rr b                ; check next key.
 41+  B722 D2 32 B7         jp nc,control_keyboard4
 42+  B725 C9               ret
 43+  B726              control_keyboard1:
 44+  B726 CD 70 B8         call control_pl_moveup         ; player up.
 45+  B729 C9               ret
 46+  B72A              control_keyboard2:
 47+  B72A CD 9F B8         call control_pl_movedown       ; player down.
 48+  B72D C9               ret
 49+  B72E              control_keyboard3:
 50+  B72E CD FC B8         call control_pl_moveright       ; player left.
 51+  B731 C9               ret
 52+  B732              control_keyboard4:
 53+  B732 CD CC B8         call control_pl_moveleft       ; player right.
 54+  B735 C9               ret
 55+  B736
 56+  B736
 57+  B736              ;
 58+  B736              ; Fights the player - just flips the players anim frame
 59+  B736              ;
 60+  B736              control_fight:
 61+  B736 3A 9D BB         ld a,(player+3)             ; load the frame
 62+  B739 FE 0C            cp 12                       ; flip between 12 and 13
 63+  B73B CA 43 B7         jp z,control_fight0
 64+  B73E 3E 0C            ld a,12
 65+  B740 C3 45 B7         jp control_fight1
 66+  B743              control_fight0:
 67+  B743 3E 0D            ld a,13
 68+  B745              control_fight1:
 69+  B745 32 9D BB         ld (player+3),a           ; save back
 70+  B748 C9               ret
 71+  B749
 72+  B749              ;
 73+  B749              ; Falls the player
 74+  B749              ;
 75+  B749              control_fall:
 76+  B749 ED 4B 9A BB      ld bc,(player)              ; get coords
 77+  B74D 0C               inc c
 78+  B74E ED 43 9A BB      ld (player),bc
 79+  B752 3A 9D BB         ld a,(player+3)             ; load the frame
 80+  B755 FE 03            cp 3                       ; flip between 3 and 0
 81+  B757 C2 5F B7         jp nz, control_fall0
 82+  B75A 3E 00            ld a,0
 83+  B75C C3 61 B7         jp control_fall1
 84+  B75F              control_fall0:
 85+  B75F 3E 03            ld a,3
 86+  B761              control_fall1:
 87+  B761 32 9D BB         ld (player+3),a           ; save back
 88+  B764 C9               ret
 89+  B765
 90+  B765              ;
 91+  B765              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 92+  B765              ;
 93+  B765              control_dig:
 94+  B765 ED 4B 9A BB      ld bc,(player)      ; load the current coords into bc
 95+  B769 C5               push bc
 96+  B76A 3A 9C BB         ld a,(player+2)     ; get the direction
 97+  B76D FE 01            cp 1                ; left
 98+  B76F CA 87 B7         jp z,control_dig0
 99+  B772 FE 02            cp 2                ; right
100+  B774 CA 9C B7         jp z,control_dig1
101+  B777 FE 03            cp 3                ; down
102+  B779 CA C0 B7         jp z,control_dig5
103+  B77C FE 00            cp 0                ; up
104+  B77E CA B0 B7         jp z,control_dig4
105+  B781 21 A0 BB         ld hl,player+6
106+  B784 36 00            ld (hl),0           ; turn off digging
107+  B786 C9               ret                 ; return
108+  B787              control_dig0:           ; going left
109+  B787 CD 89 AA         call sprites_scadd  ; get the current coord
110+  B78A 62 6B            ld hl,de
111+  B78C 2B               dec hl              ; move one left
112+  B78D C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
113+  B78E 78               ld a,b
114+  B78F 06 08            ld b,8
115+  B791 90               sub b
116+  B792 47               ld b,a
117+  B793 79               ld a,c
118+  B794 0E 08            ld c,8
119+  B796 91               sub c
120+  B797 4F               ld c,a
121+  B798 C5               push bc
122+  B799 C3 C9 B7         jp control_dig2
123+  B79C              control_dig1:
124+  B79C CD 89 AA         call sprites_scadd  ; get the current coord
125+  B79F 62 6B            ld hl,de
126+  B7A1 23               inc hl              ; move one right
127+  B7A2 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
128+  B7A3 3E 08            ld a,8
129+  B7A5 80               add a,b
130+  B7A6 47               ld b,a
131+  B7A7 79               ld a,c
132+  B7A8 0E 08            ld c,8
133+  B7AA 91               sub c
134+  B7AB 4F               ld c,a
135+  B7AC C5               push bc
136+  B7AD C3 C9 B7         jp control_dig2
137+  B7B0              control_dig4:
138+  B7B0 CD 89 AA         call sprites_scadd  ; get the current coord
139+  B7B3 62 6B            ld hl,de
140+  B7B5 11 20 00         ld de,32
141+  B7B8 ED 52            sbc hl,de             ; move one up
142+  B7BA C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
143+  B7BB 0D               dec c
144+  B7BC C5               push bc
145+  B7BD C3 E1 B7         jp control_dig6
146+  B7C0              control_dig5:
147+  B7C0 CD 89 AA         call sprites_scadd  ; get the current coord
148+  B7C3 62 6B            ld hl,de
149+  B7C5 24               inc h              ; move one down
150+  B7C6                                     ; not bothered about working out bc here, since rock will never fall if digging down
151+  B7C6 C3 C9 B7         jp control_dig2
152+  B7C9              ; Normal (not up) digging
153+  B7C9              control_dig2:
154+  B7C9 3A A2 BB         ld a,(player+8)     ; get the number of rows we need to overwrite
155+  B7CC 47               ld b,a              ; rows to copy over
156+  B7CD E5               push hl             ; store the memory location of the first row for later
157+  B7CE              control_dig3:
158+  B7CE CD 10 B8         call control_getpixelrow
159+  B7D1 77               ld (hl),a           ; load contents into row
160+  B7D2 11 20 00         ld de,32
161+  B7D5 19               add hl,de           ; move to next row
162+  B7D6 10 F6            djnz control_dig3
163+  B7D8 E1               pop hl              ; get the original memory location back
164+  B7D9 11 20 00         ld de,32
165+  B7DC ED 52            sbc hl,de           ; move to above row, ready for checking for rock
166+  B7DE C3 F7 B7         jp control_dig10
167+  B7E1              ; Special case for going up
168+  B7E1              control_dig6:
169+  B7E1 3A A2 BB         ld a,(player+8)     ; get the number of rows we need to overwrite
170+  B7E4 47               ld b,a              ; rows to copy over
171+  B7E5              control_dig7:
172+  B7E5 CD 10 B8         call control_getpixelrow
173+  B7E8              control_dig12:
174+  B7E8 77               ld (hl),a           ; load empty into row
175+  B7E9 11 20 00         ld de,32
176+  B7EC ED 52            sbc hl,de           ; move up to next row
177+  B7EE 0D               dec c               ; decrease c to track rows
178+  B7EF 10 F4            djnz control_dig7
179+  B7F1 79               ld a,c
180+  B7F2 D6 07            sub 7
181+  B7F4 C1               pop bc
182+  B7F5 4F               ld c,a
183+  B7F6 C5               push bc             ; store the decreased c coord
184+  B7F7              control_dig10:
185+  B7F7 DD 21 A1 BB      ld ix,player+7
186+  B7FB DD 7E 00         ld a,(ix)     ; get the dig frame number
187+  B7FE 3D               dec a
188+  B7FF DD 77 00         ld (ix),a
189+  B802                  ; call the check for rocks above the removed dirt
190+  B802 DD 21 A0 BB      ld ix,player+6
191+  B806 DD 7E 00         ld a,(ix)     ; get the dig state
192+  B809 FE 00            cp 0
193+  B80B C1               pop bc
194+  B80C CC E6 C0         call z, rocks_checkforfalling ; make the check if we're no longer digging
195+  B80F C9               ret
196+  B810
197+  B810              ;
198+  B810              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
199+  B810              ; Inputs:
200+  B810              ; hl - memory of pixel row
201+  B810              ; Outputs:
202+  B810              ; a - modified row to write
203+  B810              ;
204+  B810              control_getpixelrow:
205+  B810 3A A1 BB         ld a,(player+7)     ; get the dig frame number
206+  B813 FE 00            cp 0                ; is this the last dig
207+  B815 CA 1C B8         jp z,control_getpixelrow1
208+  B818 7E               ld a,(hl)           ; if not, xor with 255 to flip it
209+  B819 EE FF            xor 255
210+  B81B C9               ret
211+  B81C              control_getpixelrow1:
212+  B81C DD 21 A0 BB      ld ix,player+6
213+  B820 DD 36 00 00      ld (ix),0           ; turn off digging
214+  B824 3E 00            ld a,0              ; if it is, load with empty
215+  B826 C9               ret
216+  B827
217+  B827              ;
218+  B827              ; Auto move the player until pixels is zero
219+  B827              ;
220+  B827              control_automove:
221+  B827 5F               ld e,a              ; store the number of pixels left to move in e
222+  B828 ED 4B 9A BB      ld bc,(player)      ; load the current coords into bc
223+  B82C 21 9C BB         ld hl,player+2      ; get the direction
224+  B82F 7E               ld a,(hl)
225+  B830 FE 03            cp 3                ; down
226+  B832 CA 46 B8         jp z,control_automove3  ; don't need to do anything
227+  B835 FE 00            cp 0                ; going up
228+  B837 CA 52 B8         jp z,control_automove2
229+  B83A FE 01            cp 1                ; going left?
230+  B83C CA 5E B8         jp z,control_automove0
231+  B83F 78               ld a,b
232+  B840 3C               inc a               ; if we're going right, increment a twice for two pixels
233+  B841 3C               inc a
234+  B842 47               ld b,a
235+  B843 C3 62 B8         jp control_automove1
236+  B846              control_automove3:
237+  B846 79               ld a,c
238+  B847 3C               inc a
239+  B848 3C               inc a               ; if we're going down, increment twice
240+  B849 4F               ld c,a
241+  B84A FE 90            cp 144
242+  B84C CC 2A B9         call z, control_scroll_down
243+  B84F C3 62 B8         jp control_automove1
244+  B852              control_automove2:
245+  B852 79               ld a,c
246+  B853 3D               dec a
247+  B854 3D               dec a               ; if we're going up, decrement twice
248+  B855 4F               ld c,a
249+  B856 FE 60            cp 96
250+  B858 CC 37 B9         call z, control_scroll_up
251+  B85B C3 62 B8         jp control_automove1
252+  B85E              control_automove0:
253+  B85E 78               ld a,b
254+  B85F 3D               dec a               ; if we're going left, decrement a twice
255+  B860 3D               dec a
256+  B861 47               ld b,a
257+  B862              control_automove1:
258+  B862 ED 43 9A BB      ld (player),bc      ; and back to player
259+  B866 7B               ld a,e              ; now get the pixel count back
260+  B867 3D               dec a               ; decrease by one
261+  B868 21 9F BB         ld hl,player+5
262+  B86B 77               ld (hl),a           ; copy back
263+  B86C CD 70 BD         call player_justmoved
264+  B86F C9               ret
265+  B870
266+  B870              ;
267+  B870              ; Moves the player up
268+  B870              ;
269+  B870              control_pl_moveup:
270+  B870 C5               push bc
271+  B871 ED 4B 9A BB      ld bc,(player)          ; get the current coords, b horiz, c vert
272+  B875 79               ld a,c                  ; load c into the acc
273+  B876 FE 18            cp 24
274+  B878 CA 98 B8         jp z,control_pl_moveup0 ; are we at the edge of the screen
275+  B87B FE 60            cp 96
276+  B87D CC 37 B9         call z, control_scroll_up
277+  B880 CD DE BA         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
278+  B883 F5               push af
279+  B884 7B               ld a,e                  ; put e in a
280+  B885 FE 00            cp 0
281+  B887 CA 97 B8         jp z,control_pl_moveup1 ; don't move if we can't
282+  B88A F1               pop af
283+  B88B D6 01            sub 1                   ; subtract 1
284+  B88D D6 01            sub 1                   ; subtract 1
285+  B88F 4F               ld c,a                  ; load back to c
286+  B890 ED 43 9A BB      ld (player),bc          ; load back to player
287+  B894 C3 98 B8         jp control_pl_moveup0
288+  B897              control_pl_moveup1:
289+  B897 F1               pop af                  ; restore af if needed
290+  B898              control_pl_moveup0:
291+  B898 3E 00            ld a,0
292+  B89A 32 9C BB         ld (player+2),a        ; set direction to up
293+  B89D C1               pop bc
294+  B89E C9               ret
295+  B89F              ;
296+  B89F              ; Moves the player down
297+  B89F              ;
298+  B89F              control_pl_movedown:
299+  B89F C5               push bc
300+  B8A0 ED 4B 9A BB      ld bc,(player)          ; get the current coords, b horiz, c vert
301+  B8A4 79               ld a,c                  ; load c into the acc
302+  B8A5 FE E0            cp 224
303+  B8A7 CA C5 B8         jp z,control_pl_movedown0 ; are we at the edge of the screen
304+  B8AA FE 80            cp 128
305+  B8AC CC 2A B9         call z, control_scroll_down
306+  B8AF CD B2 BA         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
307+  B8B2 F5               push af
308+  B8B3 7B               ld a,e                  ; put e in a
309+  B8B4 FE 00            cp 0
310+  B8B6 CA C4 B8         jp z,control_pl_movedown1 ; don't move if we can't
311+  B8B9 F1               pop af
312+  B8BA 3C               inc a                   ; add 1
313+  B8BB 3C               inc a                   ; add 1
314+  B8BC 4F               ld c,a                  ; load back to c
315+  B8BD ED 43 9A BB      ld (player),bc          ; load back to player
316+  B8C1 C3 C5 B8         jp control_pl_movedown0
317+  B8C4              control_pl_movedown1:
318+  B8C4 F1               pop af                  ; restore af if needed
319+  B8C5              control_pl_movedown0:
320+  B8C5 3E 03            ld a,3
321+  B8C7 32 9C BB         ld (player+2),a        ; set direction to down
322+  B8CA C1               pop bc
323+  B8CB C9               ret
324+  B8CC              ;
325+  B8CC              ; Moves the player left
326+  B8CC              ;
327+  B8CC              control_pl_moveleft:
328+  B8CC C5               push bc
329+  B8CD ED 4B 9A BB      ld bc,(player)          ; get the current coords, b horiz, c vert
330+  B8D1 78               ld a,b                  ; load b into the acc
331+  B8D2 FE 10            cp 16
332+  B8D4 CA F5 B8         jp z,control_pl_moveleft0 ; are we at the edge of the screen
333+  B8D7 CD 3D BB         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
334+  B8DA F5               push af
335+  B8DB 7B               ld a,e                  ; put e in a
336+  B8DC FE 00            cp 0
337+  B8DE CA F4 B8         jp z,control_pl_moveleft1 ; don't move if we can't
338+  B8E1 21 9F BB         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
339+  B8E4 3E 03            ld a,3
340+  B8E6 77               ld (hl),a
341+  B8E7 F1               pop af
342+  B8E8 D6 01            sub 1                    ; subtract 2
343+  B8EA D6 01            sub 1
344+  B8EC 47               ld b,a                  ; load back to c
345+  B8ED ED 43 9A BB      ld (player),bc          ; load back to player
346+  B8F1 C3 F5 B8         jp control_pl_moveleft0
347+  B8F4              control_pl_moveleft1:
348+  B8F4 F1               pop af
349+  B8F5              control_pl_moveleft0:
350+  B8F5 3E 01            ld a,1
351+  B8F7 32 9C BB         ld (player+2),a        ; set direction to left
352+  B8FA C1               pop bc
353+  B8FB C9               ret
354+  B8FC              ;
355+  B8FC              ; Moves the player right
356+  B8FC              ;
357+  B8FC              control_pl_moveright:
358+  B8FC C5               push bc
359+  B8FD ED 4B 9A BB      ld bc,(player)          ; get the current coords, b horiz, c vert
360+  B901 78               ld a,b                  ; load b into the acc
361+  B902 FE F0            cp 240
362+  B904 CA 23 B9         jp z,control_pl_moveright0 ; are we at the edge of the screen
363+  B907 CD 11 BB         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
364+  B90A F5               push af
365+  B90B 7B               ld a,e                  ; put e in a
366+  B90C FE 00            cp 0
367+  B90E CA 22 B9         jp z,control_pl_moveright1 ; don't move if we can't
368+  B911 21 9F BB         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
369+  B914 3E 03            ld a,3
370+  B916 77               ld (hl),a
371+  B917 F1               pop af
372+  B918 3C               inc a                   ; add 2
373+  B919 3C               inc a
374+  B91A 47               ld b,a                  ; load back to b
375+  B91B ED 43 9A BB      ld (player),bc          ; load back to player
376+  B91F C3 23 B9         jp control_pl_moveright0
377+  B922              control_pl_moveright1:
378+  B922 F1               pop af                  ; restore af if needed
379+  B923              control_pl_moveright0:
380+  B923 3E 02            ld a,2
381+  B925 32 9C BB         ld (player+2),a        ; set direction to right
382+  B928 C1               pop bc
383+  B929 C9               ret
384+  B92A
385+  B92A              ;
386+  B92A              ; Scrolls the screen down
387+  B92A              ;
388+  B92A              control_scroll_down:
389+  B92A F5               push af
390+  B92B 3E 08            ld a,8
391+  B92D 32 70 A7         ld (screen_offset),a
392+  B930 F1               pop af
393+  B931 21 BD A5         ld hl,buffer_updateall
394+  B934 36 01            ld (hl),1         ; flag as screen needing update
395+  B936 C9               ret
396+  B937
397+  B937              ;
398+  B937              ; Scrolls the screen up
399+  B937              ;
400+  B937              control_scroll_up:
401+  B937 F5               push af
402+  B938 3E 00            ld a,0
403+  B93A 32 70 A7         ld (screen_offset),a
404+  B93D F1               pop af
405+  B93E 21 BD A5         ld hl,buffer_updateall
406+  B941 36 01            ld (hl),1         ; flag as screen needing update
407+  B943 C9               ret
408+  B944
409+  B944
410+  B944
411+  B944
# file closed: game/control.asm
 37   B944                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  B944              ;
  2+  B944              ; The number of frames to dig for
  3+  B944              ;
  4+  B944              movement_numberdigframes:
  5+  B944 0A               defb 10
  6+  B945
  7+  B945              ;
  8+  B945              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  B945              ; Inputs:
 10+  B945              ; hl - memory location of top pixel row
 11+  B945              ; bc - screen coords, b horiz, c vert
 12+  B945              ; Outputs:
 13+  B945              ; e - 0 if not empty, 1 if empty
 14+  B945              ;
 15+  B945              movement_spaceisempty:
 16+  B945 C5               push bc
 17+  B946 E5               push hl
 18+  B947 CD 6F B9         call movement_spaceisgem        ; check if space is a gem
 19+  B94A E1               pop hl
 20+  B94B C1               pop bc
 21+  B94C 7B               ld a,e
 22+  B94D FE 01            cp 1
 23+  B94F C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  B950 3E 08            ld a,8                          ; 8 rows to check
 25+  B952              movement_spaceisempty0:
 26+  B952 08               ex af,af'                       ; store the loop counter
 27+  B953 7E               ld a,(hl)                       ; get current pixel row
 28+  B954 FE 00            cp 0
 29+  B956 C2 6A B9         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  B959 79               ld a,c                          ; load the vertical coord
 31+  B95A 3C               inc a                           ; next row down
 32+  B95B 11 20 00         ld de,32
 33+  B95E 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  B95F 4F               ld c,a                          ; copy vert coord back to c
 35+  B960 08               ex af,af'                       ; get loop counter back
 36+  B961 3D               dec a                           ; decrease loop counter
 37+  B962 C2 52 B9         jp nz, movement_spaceisempty0
 38+  B965 16 00            ld d,0
 39+  B967 1E 01            ld e,1                          ; got to end, so space is empty
 40+  B969 C9               ret
 41+  B96A              movement_spaceisempty1:
 42+  B96A 16 00            ld d,0
 43+  B96C 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  B96E C9               ret
 45+  B96F
 46+  B96F              ;
 47+  B96F              ; Check if a space contains a gem
 48+  B96F              ; Inputs:
 49+  B96F              ; bc - screen coords
 50+  B96F              ; Outputs:
 51+  B96F              ; e = 1 if gem
 52+  B96F              movement_spaceisgem:
 53+  B96F CD C2 A8         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  B972 21 C4 B3         ld hl,level01diamonds           ; check diamonds first
 55+  B975              movement_spaceisgem0:
 56+  B975 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  B979 7B               ld a,e                          ; check for end of data
 58+  B97A FE FF            cp 255
 59+  B97C CA 97 B9         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  B97F 23               inc hl
 61+  B980 23               inc hl                          ; move to state
 62+  B981 7E               ld a,(hl)
 63+  B982 23               inc hl
 64+  B983 23               inc hl
 65+  B984 23               inc hl                          ; get to next
 66+  B985 FE 01            cp 1                            ; check if collected
 67+  B987 CA 75 B9         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  B98A 7B               ld a,e                          ; load e again
 69+  B98B B9               cp c                            ; otherwise, compare c with e
 70+  B98C C2 75 B9         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  B98F 7A               ld a,d                          ; get d coord
 72+  B990 B8               cp b                            ; compare b with d
 73+  B991 C2 75 B9         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  B994 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  B996 C9               ret
 76+  B997              movement_spaceisgem1:
 77+  B997 21 D4 B3         ld hl,level01gems              ; check gems
 78+  B99A              movement_spaceisgem2:
 79+  B99A 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  B99E 7B               ld a,e                          ; check for end of data
 81+  B99F FE FF            cp 255
 82+  B9A1 CA BC B9         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  B9A4 23               inc hl
 84+  B9A5 23               inc hl                          ; move to state
 85+  B9A6 7E               ld a,(hl)
 86+  B9A7 23               inc hl
 87+  B9A8 23               inc hl
 88+  B9A9 23               inc hl                          ; get to next
 89+  B9AA FE 01            cp 1                            ; check if collected
 90+  B9AC CA 9A B9         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  B9AF 7B               ld a,e                          ; load e again
 92+  B9B0 B9               cp c                            ; otherwise, compare c with e
 93+  B9B1 C2 9A B9         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  B9B4 7A               ld a,d                          ; get d coord
 95+  B9B5 B8               cp b                            ; compare b with d
 96+  B9B6 C2 9A B9         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  B9B9 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  B9BB C9               ret
 99+  B9BC              movement_spaceisgem3:
100+  B9BC 1E 00            ld e,0                          ; nothing found, return e = 0
101+  B9BE C9               ret
102+  B9BF
103+  B9BF              ;
104+  B9BF              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  B9BF              ; Inputs:
106+  B9BF              ; hl - memory location of top pixel row
107+  B9BF              ; bc - screen coords, b horiz, c vert
108+  B9BF              ; Outputs:
109+  B9BF              ; e - 0 if not empty, 1 if empty
110+  B9BF              ;
111+  B9BF              movement_linebelowisempty:
112+  B9BF C5               push bc
113+  B9C0 E5               push hl
114+  B9C1 CD 6F B9         call movement_spaceisgem        ; check if space is a gem
115+  B9C4 E1               pop hl
116+  B9C5 C1               pop bc
117+  B9C6 7B               ld a,e
118+  B9C7 FE 01            cp 1
119+  B9C9 C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  B9CA 7E               ld a,(hl)                       ; get current pixel row
121+  B9CB FE 00            cp 0
122+  B9CD C2 D5 B9         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  B9D0 16 00            ld d,0
124+  B9D2 1E 01            ld e,1                          ; got to end, so space is empty
125+  B9D4 C9               ret
126+  B9D5              movement_linebelowisempty1:
127+  B9D5 16 00            ld d,0
128+  B9D7 1E 00            ld e,0                          ; returning false, ie space not empty
129+  B9D9 C9               ret
130+  B9DA
131+  B9DA              ;
132+  B9DA              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  B9DA              ; Inputs:
134+  B9DA              ; hl - memory location of top pixel row
135+  B9DA              ; bc - screen coords, b horiz, c vert
136+  B9DA              ; Outputs:
137+  B9DA              ; e - 0 if not empty, 1 if empty
138+  B9DA              ;
139+  B9DA              movement_lineaboveisempty:
140+  B9DA C5               push bc
141+  B9DB E5               push hl
142+  B9DC CD 6F B9         call movement_spaceisgem        ; check if space is a gem
143+  B9DF E1               pop hl
144+  B9E0 C1               pop bc
145+  B9E1 7B               ld a,e
146+  B9E2 FE 01            cp 1
147+  B9E4 C8               ret z
148+  B9E5 7E               ld a,(hl)                       ; get current pixel row
149+  B9E6 FE 00            cp 0
150+  B9E8 C2 F0 B9         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  B9EB 16 00            ld d,0
152+  B9ED 1E 01            ld e,1                          ; got to end, so space is empty
153+  B9EF C9               ret
154+  B9F0              movement_lineaboveisempty1:
155+  B9F0 16 00            ld d,0
156+  B9F2 1E 00            ld e,0                          ; returning false, ie space not empty
157+  B9F4 C9               ret
158+  B9F5
159+  B9F5              ;
160+  B9F5              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  B9F5              ; Inputs:
162+  B9F5              ; hl - memory location of top pixel row
163+  B9F5              ; bc - screen coords, b horiz, c vert
164+  B9F5              ; Outputs:
165+  B9F5              ; none - puts player into digging mode
166+  B9F5              ;
167+  B9F5              movement_spaceisdiggable:
168+  B9F5 3E 08            ld a,8                          ; 8 rows to check
169+  B9F7              movement_spaceisdiggable0:
170+  B9F7 08               ex af,af'                       ; store the loop counter
171+  B9F8 7E               ld a,(hl)                       ; get current pixel row
172+  B9F9 FE 00            cp 0
173+  B9FB CA 0B BA         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  B9FE FE 55            cp 85
175+  BA00 CA 0B BA         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  BA03 FE AA            cp 170
177+  BA05 CA 0B BA         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  BA08 C3 25 BA         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  BA0B              movement_spaceisdiggable2:
180+  BA0B 79               ld a,c                          ; load the vertical coord
181+  BA0C 3C               inc a                           ; next row down
182+  BA0D 11 20 00         ld de,32
183+  BA10 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  BA11 4F               ld c,a                          ; copy vert coord back to c
185+  BA12 08               ex af,af'                       ; get loop counter back
186+  BA13 3D               dec a                           ; decrease loop counter
187+  BA14 C2 F7 B9         jp nz, movement_spaceisdiggable0
188+  BA17 21 A0 BB         ld hl,player+6
189+  BA1A 36 01            ld (hl),1                       ; set the player into digging mode
190+  BA1C 23               inc hl
191+  BA1D 3A 44 B9         ld a,(movement_numberdigframes)
192+  BA20 77               ld (hl),a                       ; set the number of frame to dig for
193+  BA21 23               inc hl
194+  BA22 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  BA24 C9               ret
196+  BA25              movement_spaceisdiggable1:
197+  BA25 21 A0 BB         ld hl,player+6
198+  BA28 36 00            ld (hl),0                       ; set the player out of digging mode
199+  BA2A C9               ret
200+  BA2B
201+  BA2B              ;
202+  BA2B              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
203+  BA2B              ; Inputs:
204+  BA2B              ; hl - memory location of top pixel row
205+  BA2B              ; bc - screen coords, b horiz, c vert
206+  BA2B              ; Outputs:
207+  BA2B              ; none - puts player into digging mode
208+  BA2B              ;
209+  BA2B              movement_spacebelowisdiggable:
210+  BA2B 7E               ld a,(hl)                       ; get first pixel row
211+  BA2C FE 55            cp 85
212+  BA2E CA 39 BA         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
213+  BA31 FE AA            cp 170
214+  BA33 CA 39 BA         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
215+  BA36 C3 25 BA         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
216+  BA39              movement_spacebelowisdiggable3:
217+  BA39 3E 08            ld a,8                          ; rows to check
218+  BA3B 1E 00            ld e,0                          ; count of rows to dig
219+  BA3D              movement_spacebelowisdiggable0:
220+  BA3D 08               ex af,af'                       ; store the loop counter
221+  BA3E 7E               ld a,(hl)                       ; get current pixel row
222+  BA3F FE 55            cp 85
223+  BA41 CA 4C BA         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
224+  BA44 FE AA            cp 170
225+  BA46 CA 4C BA         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
226+  BA49 C3 5B BA         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
227+  BA4C              movement_spacebelowisdiggable4:
228+  BA4C 1C               inc e                           ; inc count of rows to dig
229+  BA4D              movement_spacebelowisdiggable2:
230+  BA4D 79               ld a,c                          ; load the vertical coord
231+  BA4E 3C               inc a                           ; next row down
232+  BA4F D5               push de                         ; need e for later
233+  BA50 11 20 00         ld de,32
234+  BA53 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
235+  BA54 4F               ld c,a                          ; copy vert coord back to c
236+  BA55 D1               pop de                          ; get e back
237+  BA56 08               ex af,af'                       ; get loop counter back
238+  BA57 3D               dec a                           ; incease loop counter
239+  BA58 C2 3D BA         jp nz, movement_spacebelowisdiggable0
240+  BA5B              movement_spacebelowisdiggable5:
241+  BA5B 21 A0 BB         ld hl,player+6
242+  BA5E 36 01            ld (hl),1                       ; set the player into digging mode
243+  BA60 23               inc hl
244+  BA61 3A 44 B9         ld a,(movement_numberdigframes)
245+  BA64 77               ld (hl),a                       ; set the number of frame to dig for
246+  BA65 23               inc hl
247+  BA66 73               ld (hl),e                       ; set the number of pixels to dig
248+  BA67 C9               ret
249+  BA68              movement_spacebelowisdiggable1:
250+  BA68 21 A0 BB         ld hl,player+6
251+  BA6B 36 00            ld (hl),0                       ; set the player out of digging mode
252+  BA6D C9               ret
253+  BA6E
254+  BA6E              ;
255+  BA6E              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
256+  BA6E              ; Inputs:
257+  BA6E              ; hl - memory location of top pixel row
258+  BA6E              ; bc - screen coords, b horiz, c vert
259+  BA6E              ; Outputs:
260+  BA6E              ; none - puts player into digging mode
261+  BA6E              ;
262+  BA6E              movement_spaceaboveisdiggable:
263+  BA6E 7E               ld a,(hl)                       ; get first pixel row
264+  BA6F FE 55            cp 85
265+  BA71 CA 7C BA         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
266+  BA74 FE AA            cp 170
267+  BA76 CA 7C BA         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
268+  BA79 C3 25 BA         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
269+  BA7C              movement_spaceaboveisdiggable3:
270+  BA7C 3E 08            ld a,8                          ; rows to check
271+  BA7E 1E 00            ld e,0                          ; count of rows to dig
272+  BA80              movement_spaceaboveisdiggable0:
273+  BA80 08               ex af,af'                       ; store the loop counter
274+  BA81 7E               ld a,(hl)                       ; get current pixel row
275+  BA82 FE 55            cp 85
276+  BA84 CA 8F BA         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
277+  BA87 FE AA            cp 170
278+  BA89 CA 8F BA         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
279+  BA8C C3 9F BA         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
280+  BA8F              movement_spaceaboveisdiggable4:
281+  BA8F 1C               inc e                           ; inc count of rows to dig
282+  BA90              movement_spaceaboveisdiggable2:
283+  BA90 79               ld a,c                          ; load the vertical coord
284+  BA91 3D               dec a                           ; next row up
285+  BA92 D5               push de                         ; need e for later
286+  BA93 11 20 00         ld de,32
287+  BA96 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
288+  BA98 4F               ld c,a                          ; copy vert coord back to c
289+  BA99 D1               pop de                          ; get e back
290+  BA9A 08               ex af,af'                       ; get loop counter back
291+  BA9B 3D               dec a                           ; incease loop counter
292+  BA9C C2 80 BA         jp nz, movement_spaceaboveisdiggable0
293+  BA9F              movement_spaceaboveisdiggable5:
294+  BA9F 21 A0 BB         ld hl,player+6
295+  BAA2 36 01            ld (hl),1                       ; set the player into digging mode
296+  BAA4 23               inc hl
297+  BAA5 3A 44 B9         ld a,(movement_numberdigframes)
298+  BAA8 77               ld (hl),a                       ; set the number of frame to dig for
299+  BAA9 23               inc hl
300+  BAAA 73               ld (hl),e                       ; set the number of pixels to dig
301+  BAAB C9               ret
302+  BAAC              movement_spaceaboveisdiggable1:
303+  BAAC 21 A0 BB         ld hl,player+6
304+  BAAF 36 00            ld (hl),0                       ; set the player out of digging mode
305+  BAB1 C9               ret
306+  BAB2
307+  BAB2              ;
308+  BAB2              ; Checks if the player can move down
309+  BAB2              ; Inputs:
310+  BAB2              ; bc - player coords, b horiz, c vert
311+  BAB2              ; Outputs:
312+  BAB2              ; de - 1 can move
313+  BAB2              movement_checkcanmove_down:
314+  BAB2 F5               push af
315+  BAB3 C5               push bc
316+  BAB4 CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
317+  BAB7 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
318+  BAB9 24               inc h                       ; memory location of cell beneath now in hl
319+  BABA 3E 08            ld a,8                       ; look below
320+  BABC 81               add c
321+  BABD 4F               ld c,a
322+  BABE CD BF B9         call movement_linebelowisempty       ; check space is empty
323+  BAC1 7B               ld a,e                          ; check space empty flag
324+  BAC2 FE 00            cp 0
325+  BAC4 CA CD BA         jp z, movement_checkcanmove_down1 ; can't move
326+  BAC7 CD 70 BD         call player_justmoved
327+  BACA C1               pop bc
328+  BACB F1               pop af
329+  BACC C9               ret
330+  BACD              movement_checkcanmove_down1:
331+  BACD C1               pop bc
332+  BACE CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
333+  BAD1 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
334+  BAD3 24               inc h
335+  BAD4 C5               push bc
336+  BAD5 CD 2B BA         call movement_spacebelowisdiggable    ; can't move here, but can we dig
337+  BAD8 11 00 00         ld de,0
338+  BADB C1               pop bc
339+  BADC F1               pop af
340+  BADD C9               ret
341+  BADE
342+  BADE              ;
343+  BADE              ; Checks if the player can move up
344+  BADE              ; Inputs:
345+  BADE              ; bc - player coords, b horiz, c vert
346+  BADE              ; Outputs:
347+  BADE              ; de - 1 can move
348+  BADE              movement_checkcanmove_up:
349+  BADE F5               push af
350+  BADF C5               push bc
351+  BAE0 CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
352+  BAE3 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
353+  BAE5 11 20 00         ld de,32
354+  BAE8 ED 52            sbc hl,de                       ; memory location of line above now in hl
355+  BAEA 0D               dec c                           ; look above
356+  BAEB CD DA B9         call movement_lineaboveisempty       ; check space is empty
357+  BAEE 7B               ld a,e                          ; check space empty flag
358+  BAEF FE 00            cp 0
359+  BAF1 CA FC BA         jp z, movement_checkcanmove_up1 ; can't move
360+  BAF4 1E 01            ld e,1
361+  BAF6 CD 70 BD         call player_justmoved
362+  BAF9 C1               pop bc
363+  BAFA F1               pop af
364+  BAFB C9               ret
365+  BAFC              movement_checkcanmove_up1:
366+  BAFC C1               pop bc
367+  BAFD CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
368+  BB00 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
369+  BB02 11 20 00         ld de,32
370+  BB05 ED 52            sbc hl,de                       ; memory location of line above now in hl
371+  BB07 C5               push bc
372+  BB08 CD 6E BA         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
373+  BB0B 11 00 00         ld de,0
374+  BB0E C1               pop bc
375+  BB0F F1               pop af
376+  BB10 C9               ret
377+  BB11
378+  BB11              ;
379+  BB11              ; Checks if the player can move right
380+  BB11              ; Inputs:
381+  BB11              ; bc - player coords, b horiz, c vert
382+  BB11              ; Outputs:
383+  BB11              ; de - 1 can move
384+  BB11              movement_checkcanmove_right:
385+  BB11 F5               push af
386+  BB12 C5               push bc
387+  BB13 CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
388+  BB16 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
389+  BB18 3E 08            ld a,8
390+  BB1A 80               add b                           ; move one cell right
391+  BB1B 47               ld b,a
392+  BB1C 23               inc hl                          ; memory location of cell to the right now in hl
393+  BB1D CD 45 B9         call movement_spaceisempty       ; check space is empty
394+  BB20 7B               ld a,e                          ; check space empty flag
395+  BB21 FE 00            cp 0
396+  BB23 CA 2C BB         jp z, movement_checkcanmove_right1 ; can't move
397+  BB26 CD 70 BD         call player_justmoved
398+  BB29 C1               pop bc
399+  BB2A F1               pop af
400+  BB2B C9               ret
401+  BB2C              movement_checkcanmove_right1:
402+  BB2C C1               pop bc
403+  BB2D CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
404+  BB30 62 6B            ld hl,de
405+  BB32 23               inc hl                          ; memory location of cell to the right now in hl
406+  BB33 C5               push bc
407+  BB34 CD F5 B9         call movement_spaceisdiggable    ; can't move here, but can we dig
408+  BB37 11 00 00         ld de,0
409+  BB3A C1               pop bc
410+  BB3B F1               pop af
411+  BB3C C9               ret
412+  BB3D
413+  BB3D              ;
414+  BB3D              ; Checks if the player can move left
415+  BB3D              ; Inputs:
416+  BB3D              ; bc - player coords, b horiz, c vert
417+  BB3D              ; Outputs:
418+  BB3D              ; de - 1 can move
419+  BB3D              movement_checkcanmove_left:
420+  BB3D F5               push af
421+  BB3E C5               push bc
422+  BB3F CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
423+  BB42 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
424+  BB44 78               ld a,b
425+  BB45 06 08            ld b,8
426+  BB47 90               sub b                           ; move one cell left
427+  BB48 47               ld b,a
428+  BB49 2B               dec hl                          ; memory location of cell to the right now in hl
429+  BB4A CD 45 B9         call movement_spaceisempty       ; check space is empty
430+  BB4D 7B               ld a,e                          ; check space empty flag
431+  BB4E FE 00            cp 0
432+  BB50 CA 59 BB         jp z, movement_checkcanmove_left1 ; can't move
433+  BB53 CD 70 BD         call player_justmoved
434+  BB56 C1               pop bc
435+  BB57 F1               pop af
436+  BB58 C9               ret
437+  BB59              movement_checkcanmove_left1:
438+  BB59 C1               pop bc
439+  BB5A CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
440+  BB5D 62 6B            ld hl,de
441+  BB5F 2B               dec hl                          ; memory location of cell to the right now in hl
442+  BB60 C5               push bc
443+  BB61 CD F5 B9         call movement_spaceisdiggable    ; can't move here, but can we dig
444+  BB64 11 00 00         ld de,0
445+  BB67 C1               pop bc
446+  BB68 F1               pop af
447+  BB69 C9               ret
# file closed: game/movement.asm
 38   BB6A                  include "game\game.asm"
# file opened: game/game.asm
  1+  BB6A              ;
  2+  BB6A              ; The current frame count, incremented each frame
  3+  BB6A              ;
  4+  BB6A              game_framenumber:
  5+  BB6A 00               defb    0
  6+  BB6B
  7+  BB6B              ;
  8+  BB6B              ; The number of players
  9+  BB6B              ;
 10+  BB6B              game_numberplayers:
 11+  BB6B 01               defb 1
 12+  BB6C
 13+  BB6C              ;
 14+  BB6C              ; The current player
 15+  BB6C              ;
 16+  BB6C              game_currentplayer:
 17+  BB6C 01               defb 1
 18+  BB6D
 19+  BB6D              ;
 20+  BB6D              ; The default number of lives
 21+  BB6D              ;
 22+  BB6D              game_numberlives:
 23+  BB6D 04               defb 4
 24+  BB6E
 25+  BB6E              ;
 26+  BB6E              ; Moves to the next player
 27+  BB6E              ;
 28+  BB6E              game_changeplayer:
 29+  BB6E 3A 6C BB         ld a,(game_currentplayer)
 30+  BB71 FE 01            cp 1
 31+  BB73 C8               ret z                       ; if just one player, no need to change
 32+  BB74 3D               dec a                       ; otherwise decrease by one
 33+  BB75 EE 01            xor 1                       ; xor with one to flip
 34+  BB77 3C               inc a                       ; increment
 35+  BB78 21 6C BB         ld hl,game_currentplayer
 36+  BB7B 77               ld (hl),a                   ; store
 37+  BB7C C9               ret
 38+  BB7D
 39+  BB7D              ;
 40+  BB7D              ; Sets the number of players at the start of the game
 41+  BB7D              ; Inputs:
 42+  BB7D              ; a - number of players
 43+  BB7D              game_setnumberofplayers:
 44+  BB7D 21 6B BB         ld hl,game_numberplayers
 45+  BB80 77               ld (hl),a
 46+  BB81
 47+  BB81              ;
 48+  BB81              ; Increment frame number by 1
 49+  BB81              ;
 50+  BB81              game_incrementframe:
 51+  BB81 3A 6A BB         ld a,(game_framenumber)
 52+  BB84 FE FF            cp 255
 53+  BB86 C2 8B BB         jp nz,game_incrementframe0
 54+  BB89 3E 00            ld a,0
 55+  BB8B              game_incrementframe0:
 56+  BB8B 3C               inc a
 57+  BB8C 32 6A BB         ld (game_framenumber),a
 58+  BB8F C9               ret
 59+  BB90
 60+  BB90              ;
 61+  BB90              ; Returns current frame
 62+  BB90              ; Outputs:
 63+  BB90              ; a - current frame
 64+  BB90              ;
 65+  BB90              game_getcurrentframe:
 66+  BB90 3A 6A BB         ld a,(game_framenumber)
 67+  BB93 C9               ret
 68+  BB94
 69+  BB94              ;
 70+  BB94              ; Resets current frame
 71+  BB94              ;
 72+  BB94              game_resetcurrentframe:
 73+  BB94 21 6A BB         ld hl,game_framenumber
 74+  BB97 36 00            ld (hl),0
 75+  BB99 C9               ret
# file closed: game/game.asm
 39   BB9A                  include "game\player.asm"
# file opened: game/player.asm
  1+  BB9A              ;
  2+  BB9A              ;   Data for current player
  3+  BB9A              ;
  4+  BB9A              player:
  5+  BB9A 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  BB9C 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  BB9F 00               defb    0                   ; auto move remaining (+5)
  8+  BBA0 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  BBA3 00               defb    0                   ; lives remaining (+9)
 10+  BBA4 00               defb    0                   ; died this life (+10)
 11+  BBA5 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  BBA7 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  BBA8
 14+  BBA8              player_location:
 15+  BBA8 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 16+  BBA9
 17+  BBA9              ;
 18+  BBA9              ; Works out which part of the screen the player is in
 19+  BBA9              ; Pit is between 3,9 and 8,9
 20+  BBA9              ; Diamond cavern is between 11,22 and 22,28
 21+  BBA9              ;
 22+  BBA9              player_getlocation:
 23+  BBA9 ED 4B 9A BB      ld bc,(player)              ; get screen coords
 24+  BBAD CD C2 A8         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 25+  BBB0 78               ld a,b                      ; check for pit first
 26+  BBB1 FE 09            cp 9                        ; if not on this row, not in the pit
 27+  BBB3 C2 C2 BB         jp nz,player_getlocation0
 28+  BBB6 79               ld a,c                      ; check horizontal
 29+  BBB7 FE 09            cp 9
 30+  BBB9 D2 C2 BB         jp nc, player_getlocation0  ; if more than 9, not in the pit
 31+  BBBC 21 A8 BB         ld hl,player_location
 32+  BBBF 36 02            ld (hl),2                   ; load location with 2, the pit
 33+  BBC1 C9               ret                         ; done
 34+  BBC2              player_getlocation0:            ; check for diamond cavern
 35+  BBC2 78               ld a,b                      ; first check vertical
 36+  BBC3 FE 16            cp 22                       ; if above row 22, then not in cavern
 37+  BBC5 DA D9 BB         jp c,player_getlocation1
 38+  BBC8 79               ld a,c                      ; get the horizontal next
 39+  BBC9 FE 0B            cp 11
 40+  BBCB DA D9 BB         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 41+  BBCE FE 16            cp 22
 42+  BBD0 D2 D9 BB         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 43+  BBD3 21 A8 BB         ld hl,player_location
 44+  BBD6 36 01            ld (hl),1                   ; load location with 1, the cavern
 45+  BBD8 C9               ret
 46+  BBD9              player_getlocation1:
 47+  BBD9 21 A8 BB         ld hl,player_location
 48+  BBDC 36 00            ld (hl),0                   ; load location with 2, the pit
 49+  BBDE C9               ret                         ; done
 50+  BBDF
 51+  BBDF
 52+  BBDF              ;
 53+  BBDF              ; Initializes a player at start of game
 54+  BBDF              ; Copy initial coords, copy lives, copy score
 55+  BBDF              ;
 56+  BBDF              player_init_gamestart:
 57+  BBDF 3A 6D BB         ld a,(game_numberlives)
 58+  BBE2 32 6E BC         ld (player1_lives),a
 59+  BBE5 32 6F BC         ld (player2_lives),a                        ; set the initial number of lives at game start
 60+  BBE8
 61+  BBE8 21 72 BC         ld hl,player1_score+2
 62+  BBEB 06 06            ld b,6
 63+  BBED              player_init_gamestart0:
 64+  BBED 36 30            ld (hl),48
 65+  BBEF 23               inc hl
 66+  BBF0 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 67+  BBF2 21 7B BC         ld hl,player2_score+2
 68+  BBF5 06 06            ld b,6
 69+  BBF7              player_init_gamestart1:
 70+  BBF7 36 30            ld (hl),48
 71+  BBF9 23               inc hl
 72+  BBFA 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 73+  BBFC C9               ret
 74+  BBFD
 75+  BBFD              ;
 76+  BBFD              ; Initializes a player at start of a life
 77+  BBFD              ; Copy initial coords, copy lives, copy score
 78+  BBFD              ;
 79+  BBFD              player_init_lifestart:
 80+  BBFD 21 9F BB         ld hl,player+5
 81+  BC00 06 09            ld b,9                      ; initialise 9 properties
 82+  BC02              player_init_lifestart2:
 83+  BC02 36 00            ld (hl),0
 84+  BC04 23               inc hl
 85+  BC05 10 FB            djnz player_init_lifestart2
 86+  BC07
 87+  BC07 21 9C BB         ld hl,player+2              ; initialise some properties
 88+  BC0A 36 02            ld (hl),2
 89+  BC0C 23               inc hl
 90+  BC0D 36 00            ld (hl),0
 91+  BC0F 23               inc hl
 92+  BC10 36 01            ld (hl),1
 93+  BC12
 94+  BC12 ED 4B 22 80      ld bc,(init_coord)
 95+  BC16 ED 43 9A BB      ld (player),bc
 96+  BC1A 01 A3 BB         ld bc,player+9
 97+  BC1D 3A 6E BC         ld a,(player1_lives)
 98+  BC20 02               ld (bc),a
 99+  BC21
100+  BC21 CD 12 C4         call diamonds_init      ; initialise gems
101+  BC24
102+  BC24 01 06 00         ld bc,6
103+  BC27 11 46 C2         ld de,scores_current+2
104+  BC2A 3A 6C BB         ld a,(game_currentplayer)
105+  BC2D FE 01            cp 1
106+  BC2F C2 38 BC         jp nz,player_init_lifestart0
107+  BC32 21 72 BC         ld hl,player1_score+2
108+  BC35 C3 3B BC         jp player_init_lifestart1
109+  BC38              player_init_lifestart0:
110+  BC38 21 7B BC         ld hl,player2_score+2
111+  BC3B              player_init_lifestart1:
112+  BC3B ED B0            ldir
113+  BC3D C9               ret
114+  BC3E
115+  BC3E              ;
116+  BC3E              ; Finalises a player at end of a life
117+  BC3E              ; Copy lives, copy score
118+  BC3E              ;
119+  BC3E              player_lifeend:
120+  BC3E 01 A3 BB         ld bc,player+9
121+  BC41 0A               ld a,(bc)
122+  BC42 01 6E BC         ld bc,player1_lives
123+  BC45 02               ld (bc),a
124+  BC46 CD 4A BC         call player_recordcurrentscore
125+  BC49 C9               ret
126+  BC4A
127+  BC4A              ;
128+  BC4A              ; Copies the current score in the current
129+  BC4A              ;
130+  BC4A              player_recordcurrentscore:
131+  BC4A 01 06 00         ld bc,6                  ; copy current score back to correct player
132+  BC4D 21 46 C2         ld hl,scores_current+2
133+  BC50 3A 6C BB         ld a,(game_currentplayer)
134+  BC53 FE 01            cp 1
135+  BC55 C2 5E BC         jp nz,player_lifeend0
136+  BC58 11 72 BC         ld de,player1_score+2
137+  BC5B C3 61 BC         jp player_lifeend1
138+  BC5E              player_lifeend0:
139+  BC5E 11 7B BC         ld de,player2_score+2
140+  BC61              player_lifeend1:
141+  BC61 ED B0            ldir
142+  BC63 C9               ret
143+  BC64
144+  BC64              ;
145+  BC64              ; Player just died, subtract a life
146+  BC64              ;
147+  BC64              player_died:
148+  BC64 01 A3 BB         ld bc,player+9
149+  BC67 0A               ld a,(bc)
150+  BC68 3D               dec a
151+  BC69 02               ld (bc),a
152+  BC6A CD 3E BC         call player_lifeend
153+  BC6D C9               ret
154+  BC6E
155+  BC6E              ;
156+  BC6E              ; Player lives
157+  BC6E              ;
158+  BC6E              player1_lives:
159+  BC6E 03               defb 3
160+  BC6F              player2_lives:
161+  BC6F 03               defb 3
162+  BC70
163+  BC70              ;
164+  BC70              ; Player scores
165+  BC70              ;
166+  BC70              player1_score:
167+  BC70 04 01 30 30      defb 4,1,'000000',255
167+  BC74 30 30 30 30
167+  BC78 FF
168+  BC79              player2_score:
169+  BC79 16 01 30 30      defb 22,1,'000000',255
169+  BC7D 30 30 30 30
169+  BC81 FF
170+  BC82
171+  BC82              ;
172+  BC82              ; Kills a player this life
173+  BC82              ;
174+  BC82              player_killplayer:
175+  BC82 21 A4 BB         ld hl,player+10
176+  BC85 36 01            ld (hl),1
177+  BC87 C9               ret
178+  BC88
179+  BC88              ;
180+  BC88              ; Crush a player this life
181+  BC88              ;
182+  BC88              player_crushplayer:
183+  BC88 21 A5 BB         ld hl,player+11             ; mark as crushed
184+  BC8B 36 01            ld (hl),1
185+  BC8D C9               ret
186+  BC8E
187+  BC8E              player_tankkillplayer
188+  BC8E 21 A5 BB         ld hl,player+11             ; mark as tanked
189+  BC91 36 02            ld (hl),2
190+  BC93 C9               ret
191+  BC94
192+  BC94              player_zonkplayer
193+  BC94 21 A5 BB         ld hl,player+11             ; mark as zonked (missile)
194+  BC97 36 03            ld (hl),3
195+  BC99 C9               ret
196+  BC9A
197+  BC9A              player_pitkillplayer
198+  BC9A 21 A5 BB         ld hl,player+11             ; mark as pit killed
199+  BC9D 36 04            ld (hl),4
200+  BC9F C9               ret
201+  BCA0
202+  BCA0              player_robotkillplayer
203+  BCA0 21 A5 BB         ld hl,player+11             ; mark as robot killed
204+  BCA3 36 05            ld (hl),5
205+  BCA5 C9               ret
206+  BCA6
207+  BCA6              ;
208+  BCA6              ; Draws the player at the current position or deletes them
209+  BCA6              ;
210+  BCA6              player_drawplayer:
211+  BCA6 3A 9C BB         ld a,(player+2)             ; get the current direction
212+  BCA9 FE 03            cp 3
213+  BCAB C2 B0 BC         jp nz,player_drawplayer0
214+  BCAE 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
215+  BCB0              player_drawplayer0:             ; DYING CHECKS
216+  BCB0 5F               ld e,a                      ; store in e
217+  BCB1 3A A5 BB         ld a,(player+11)             ; get the dying flag
218+  BCB4 FE 01            cp 1
219+  BCB6 CA F0 BC         jp z,player_drawplayer3     ; if it's one, we're being crushed
220+  BCB9 FE 04            cp 4
221+  BCBB CA 38 BD         jp z,player_drawplayer9     ; player is falling into the pit
222+  BCBE FE 05            cp 5
223+  BCC0 CA 54 BD         jp z,player_drawplayer12    ; player has been killed by a robot
224+  BCC3              player_drawplayer4:             ; CHECK FOR DIGGING
225+  BCC3 3A A0 BB         ld a,(player+6)             ; get the dig flag
226+  BCC6 FE 01            cp 1
227+  BCC8 CA D9 BC         jp z,player_drawplayer1    ; get dig frame
228+  BCCB 3A 9D BB         ld a,(player+3)             ; this is normal movement so get the current frame
229+  BCCE 83               add a,e
230+  BCCF C3 DE BC         jp player_drawplayer2
231+  BCD2              player_drawplayer6:             ; GETTING THE DIG FRAM
232+  BCD2 E6 01            and 1                       ; check for odd
233+  BCD4 C6 0A            add 10                      ; add 10, to get either 10 or 11
234+  BCD6 C3 DE BC         jp player_drawplayer2
235+  BCD9              player_drawplayer1:             ; GET THE NORMAL FRAME
236+  BCD9 3A 9C BB         ld a,(player+2)             ; digging, get the current direction again, because want all four
237+  BCDC C6 06            add a,6                     ; add direction to 6 to get frame
238+  BCDE              player_drawplayer2:             ; WORK OUT THE FRAME
239+  BCDE 07               rlca
240+  BCDF 07               rlca
241+  BCE0 07               rlca                        ; multiply by eight
242+  BCE1 6F               ld l,a
243+  BCE2 26 00            ld h,0
244+  BCE4 11 3C B5         ld de,player_sprite
245+  BCE7 19               add hl,de                   ; load hl with the location of the player sprite data
246+  BCE8              player_drawplayer7:             ; DRAW THE PlAYER
247+  BCE8 ED 4B 9A BB      ld bc,(player)              ; load bc with the start coords
248+  BCEC CD 94 A9         call sprites_drawsprite     ; call the routine to draw the sprite
249+  BCEF                  ;call player_storeupdatedlines ; log updated rows
250+  BCEF C9               ret
251+  BCF0              ;
252+  BCF0              ; CRUSHING
253+  BCF0              ;
254+  BCF0              player_drawplayer3:
255+  BCF0 21 A6 BB         ld hl,player+12
256+  BCF3 7E               ld a,(hl)                  ; crushing, so get the current anim flag
257+  BCF4 FE 00            cp 0
258+  BCF6 C2 FF BC         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
259+  BCF9 3E 64            ld a,100
260+  BCFB 77               ld (hl),a                   ; otherwise, load up the anim frames
261+  BCFC C3 C3 BC         jp player_drawplayer4       ; and return to the main loop to remove the current frame
262+  BCFF              player_drawplayer5:
263+  BCFF 3D               dec a
264+  BD00 77               ld (hl),a
265+  BD01 FE 00            cp 0
266+  BD03 CC 82 BC         call z,player_killplayer     ; final animation, so kill the player
267+  BD06 FE 0A            cp 10                         ; play the sound
268+  BD08 CC 7A AE         call z, sound_rockfell
269+  BD0B FE 14            cp 20                        ; check if we should move the rock
270+  BD0D C2 21 BD         jp nz,player_drawplayer8
271+  BD10 D9               exx
272+  BD11 F5               push af
273+  BD12 ED 4B E4 C0      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
274+  BD16 21 91 B4         ld hl,sprites+72
275+  BD19 CD 94 A9         call sprites_drawsprite     ; draw a rock over current
276+  BD1C F1               pop af
277+  BD1D D9               exx
278+  BD1E C3 D2 BC         jp player_drawplayer6       ; continue drawing player
279+  BD21              player_drawplayer8:
280+  BD21 FE 14            cp 20
281+  BD23 D2 D2 BC         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
282+  BD26 ED 4B 9A BB      ld bc,(player)
283+  BD2A CD C2 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
284+  BD2D 3E 42            ld a,66             ; load red
285+  BD2F CD 1A A9         call screen_setattr
286+  BD32 21 91 B4         ld hl,sprites+72            ; otherwise, player is rock
287+  BD35 C3 E8 BC         jp player_drawplayer7
288+  BD38              ;
289+  BD38              ; FALLING
290+  BD38              ;
291+  BD38              player_drawplayer9:             ; player is falling into the pit
292+  BD38 21 A6 BB         ld hl,player+12
293+  BD3B 7E               ld a,(hl)                   ; get the frames
294+  BD3C FE 00            cp 0
295+  BD3E C2 47 BD         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
296+  BD41 3E 50            ld a,80
297+  BD43 77               ld (hl),a                   ; otherwise, load up the anim frames
298+  BD44 C3 C3 BC         jp player_drawplayer4       ; and return to the main loop to remove the current frame
299+  BD47              player_drawplayer10:
300+  BD47 3D               dec a
301+  BD48 77               ld (hl),a
302+  BD49 FE 00            cp 0
303+  BD4B CC 82 BC         call z,player_killplayer     ; final frame, so kill the player
304+  BD4E 3A 9D BB         ld a,(player+3)
305+  BD51 C3 DE BC         jp player_drawplayer2
306+  BD54              ;
307+  BD54              ; ROBOT KILLED
308+  BD54              ;
309+  BD54              player_drawplayer12:
310+  BD54 21 A6 BB         ld hl,player+12
311+  BD57 7E               ld a,(hl)                   ; get the frames
312+  BD58 FE 00            cp 0
313+  BD5A C2 63 BD         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
314+  BD5D 3E C8            ld a,200
315+  BD5F 77               ld (hl),a                   ; otherwise, load up the anim frames
316+  BD60 C3 C3 BC         jp player_drawplayer4       ; and return to the main loop to remove the current frame
317+  BD63              player_drawplayer13:
318+  BD63 3D               dec a
319+  BD64 77               ld (hl),a
320+  BD65 FE 00            cp 0
321+  BD67 CC 82 BC         call z,player_killplayer     ; final frame, so kill the player
322+  BD6A 3A 9D BB         ld a,(player+3)
323+  BD6D C3 DE BC         jp player_drawplayer2
324+  BD70
325+  BD70              ;
326+  BD70              ; Runs after the player just moved. Changes animation frame if required
327+  BD70              ;
328+  BD70              player_justmoved:
329+  BD70 D9               exx
330+  BD71 3A 9E BB         ld a,(player+4)             ; get the transition count
331+  BD74 FE 00            cp 0
332+  BD76 CA 7C BD         jp z, player_justmoved2     ; if zero reset and change the frame
333+  BD79 C3 96 BD         jp player_justmoved1       ; otherwise decrease and continue
334+  BD7C              player_justmoved2:
335+  BD7C                  ; reset and change frame in here
336+  BD7C 3E 01            ld a,1
337+  BD7E 32 9E BB         ld (player+4),a            ; reset back to whatever
338+  BD81 3A 9D BB         ld a,(player+3)             ; load the frame
339+  BD84 FE 03            cp 3                       ; flip between 3 and 0
340+  BD86 C2 8E BD         jp nz, player_justmoved4
341+  BD89 3E 00            ld a,0
342+  BD8B C3 90 BD         jp player_justmoved5
343+  BD8E              player_justmoved4:
344+  BD8E 3E 03            ld a,3
345+  BD90              player_justmoved5:
346+  BD90 32 9D BB         ld (player+3),a           ; save back
347+  BD93 C3 9A BD         jp player_justmoved3
348+  BD96              player_justmoved1:
349+  BD96                  ; decrease count
350+  BD96 3D               dec a
351+  BD97 32 9E BB         ld (player+4),a
352+  BD9A              player_justmoved3:
353+  BD9A D9               exx;
354+  BD9B C9               ret
355+  BD9C
356+  BD9C              ;
357+  BD9C              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
358+  BD9C              ; Outputs:
359+  BD9C              ; a - 1 for completed level
360+  BD9C              player_checkforexit:
361+  BD9C ED 4B 9A BB      ld bc,(player)                 ; get player coords
362+  BDA0 ED 5B 22 80      ld de,(init_coord)             ; get start coords
363+  BDA4 78               ld a,b
364+  BDA5 BA               cp d                         ; compare horiz
365+  BDA6 C2 B1 BD         jp nz,player_checkforexit1
366+  BDA9 79               ld a,c
367+  BDAA BB               cp e                        ; compare vert
368+  BDAB C2 B1 BD         jp nz,player_checkforexit1
369+  BDAE              player_checkforexit0:
370+  BDAE 3E 01            ld a,1                       ; hasn't completed
371+  BDB0 C9               ret
372+  BDB1              player_checkforexit1:
373+  BDB1 3E 00            ld a,0                       ; has completed
374+  BDB3 C9               ret
# file closed: game/player.asm
 40   BDB4                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  BDB4              ;
  2+  BDB4              ; Ship initial position: vert,horiz
  3+  BDB4              ;
  4+  BDB4              ship_initpos:
  5+  BDB4 00 24            defb 0,36
  6+  BDB6              ship_initpos2:
  7+  BDB6 00 00            defb 0,0
  8+  BDB8              ship_frame:
  9+  BDB8 00               defb 0
 10+  BDB9              ;
 11+  BDB9              ; The current memory location
 12+  BDB9              ;
 13+  BDB9              ship_current_sprite:
 14+  BDB9 00 00            defb 0,0
 15+  BDBB
 16+  BDBB              ship_current_coords:
 17+  BDBB 00 00            defb 0,0
 18+  BDBD
 19+  BDBD              ship_process:
 20+  BDBD 3A A5 BB         ld a,(player+11)
 21+  BDC0 FE 02            cp 2                        ; has the player been killed by tank?
 22+  BDC2 C0               ret nz                      ; do nothing if not
 23+  BDC3 CD 37 B9         call control_scroll_up           ; make sure the screen is on the top screen
 24+  BDC6 CD 35 BE         call ship_takeoff           ; bye bye
 25+  BDC9 CD 82 BC         call player_killplayer      ; killed
 26+  BDCC 06 32            ld b,50
 27+  BDCE CD 82 80         call utilities_pauseforframes
 28+  BDD1 C9               ret
 29+  BDD2
 30+  BDD2              ;
 31+  BDD2              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  BDD2              ;
 33+  BDD2              ship_land:
 34+  BDD2 ED 4B B4 BD      ld bc,(ship_initpos)
 35+  BDD6 ED 43 B6 BD      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  BDDA 1E 00            ld e,0                      ; store a flag to track first time round
 37+  BDDC 06 09            ld b,9                      ; move down 8 pixels
 38+  BDDE              ship_land0:
 39+  BDDE C5               push bc
 40+  BDDF 7B               ld a,e
 41+  BDE0 D5               push de                     ; store de for next time round
 42+  BDE1 FE 01            cp 1                        ; check first time flag
 43+  BDE3 C2 F8 BD         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  BDE6 CD 7D BE         call ship_draw_full         ; delete old one
 45+  BDE9 CD 61 BE         call ship_change_frame      ; increment the frame
 46+  BDEC ED 4B B6 BD      ld bc,(ship_initpos2)       ; get the current coords
 47+  BDF0 81 C6 01         add c,1                     ; move down one pixels
 48+  BDF3 4F               ld c,a
 49+  BDF4 ED 43 B6 BD      ld (ship_initpos2),bc
 50+  BDF8              ship_land1:
 51+  BDF8 CD 7D BE         call ship_draw_full         ; draw the ship
 52+  BDFB CD 76 BE         call ship_draw_screen
 53+  BDFE D1               pop de
 54+  BDFF 1E 01            ld e,1
 55+  BE01 C1               pop bc
 56+  BE02 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  BE04                  ; done moving down
 58+  BE04                  ; now move across
 59+  BE04 CD A6 BC         call player_drawplayer      ; draw player
 60+  BE07 CD 7D BE         call ship_draw_full         ; delete old one
 61+  BE0A 1E 00            ld e,0                      ; store a flag to track first time round
 62+  BE0C 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  BE0E              ship_land3:
 64+  BE0E C5               push bc
 65+  BE0F 7B               ld a,e
 66+  BE10 D5               push de                     ; store de for next time round
 67+  BE11 FE 01            cp 1                        ; check first time flag
 68+  BE13 C2 28 BE         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  BE16 CD 7D BE         call ship_draw_full         ; delete old one
 70+  BE19 CD 61 BE         call ship_change_frame      ; increment the frame
 71+  BE1C ED 4B B6 BD      ld bc,(ship_initpos2)       ; get the current coords
 72+  BE20 78               ld a,b
 73+  BE21 D6 01            sub 1                       ; move back one pixels
 74+  BE23 47               ld b,a
 75+  BE24 ED 43 B6 BD      ld (ship_initpos2),bc
 76+  BE28              ship_land2:
 77+  BE28 CD 7D BE         call ship_draw_full         ; draw the ship
 78+  BE2B CD 76 BE         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  BE2E D1               pop de
 80+  BE2F 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  BE31 C1               pop bc
 82+  BE32 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  BE34 C9               ret
 84+  BE35
 85+  BE35              ;
 86+  BE35              ;   Take off the ship
 87+  BE35              ;
 88+  BE35              ship_takeoff:
 89+  BE35 1E 01            ld e,1                      ; store a flag to track first time round
 90+  BE37 06 08            ld b,8                      ; move up 8 pixels
 91+  BE39              ship_takeoff0:
 92+  BE39 C5               push bc
 93+  BE3A 7B               ld a,e
 94+  BE3B D5               push de                     ; store de for next time round
 95+  BE3C FE 01            cp 1                        ; check first time flag
 96+  BE3E C2 54 BE         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  BE41 ED 4B B6 BD      ld bc,(ship_initpos2)       ; get the current coords
 98+  BE45 CD 7D BE         call ship_draw_full         ; delete old one
 99+  BE48 CD 61 BE         call ship_change_frame      ; increment the frame
100+  BE4B ED 4B B6 BD      ld bc,(ship_initpos2)       ; get the current coords
101+  BE4F 0D               dec c                       ; move up one pixels
102+  BE50 ED 43 B6 BD      ld (ship_initpos2),bc
103+  BE54              ship_takeoff1:
104+  BE54 CD 7D BE         call ship_draw_full         ; draw the ship
105+  BE57 CD 76 BE         call ship_draw_screen
106+  BE5A D1               pop de
107+  BE5B 1E 01            ld e,1
108+  BE5D C1               pop bc
109+  BE5E 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  BE60                  ; done moving up
111+  BE60 C9               ret
112+  BE61
113+  BE61              ;
114+  BE61              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  BE61              ;
116+  BE61              ship_change_frame:
117+  BE61 F5               push af
118+  BE62 3A B8 BD         ld a,(ship_frame)
119+  BE65 FE 00            cp 0
120+  BE67 CA 6F BE         jp z,ship_change_frame0
121+  BE6A 3E 00            ld a,0                      ; flip to 0
122+  BE6C C3 71 BE         jp ship_change_frame1
123+  BE6F              ship_change_frame0:
124+  BE6F 3E 20            ld a,32                      ; flip to 32
125+  BE71              ship_change_frame1:
126+  BE71 32 B8 BD         ld (ship_frame),a            ; save the frame
127+  BE74 F1               pop af
128+  BE75 C9               ret
129+  BE76
130+  BE76              ship_draw_screen:
131+  BE76 76               halt
132+  BE77 F3               di
133+  BE78 CD 99 A6         call buffer_buffertoscreen  ; copy buffer to screen
134+  BE7B FB               ei                          ; enable interupts
135+  BE7C C9               ret
136+  BE7D
137+  BE7D              ship_draw_full:
138+  BE7D 21 AC B5         ld hl,ship_sprite
139+  BE80 ED 4B B6 BD      ld bc,(ship_initpos2)         ; load bc with the start coords
140+  BE84 22 B9 BD         ld (ship_current_sprite),hl  ; put into memory
141+  BE87 ED 43 BB BD      ld (ship_current_coords),bc  ; put into memory
142+  BE8B CD AA BE         call ship_draw
143+  BE8E 08               ex af,af'
144+  BE8F 3A B8 BD         ld a,(ship_frame)            ; get the animation frame
145+  BE92 16 00            ld d,0
146+  BE94 5F               ld e,a
147+  BE95 19               add hl,de
148+  BE96 22 B9 BD         ld (ship_current_sprite),hl  ; put into memory
149+  BE99 08               ex af,af'
150+  BE9A ED 4B B6 BD      ld bc,(ship_initpos2)         ; load bc with the start coords
151+  BE9E 81 C6 08         add c,8                      ; move one line down
152+  BEA1 4F               ld c,a
153+  BEA2 ED 43 BB BD      ld (ship_current_coords),bc  ; put into memory
154+  BEA6 CD AA BE         call ship_draw
155+  BEA9 C9               ret
156+  BEAA
157+  BEAA              ;
158+  BEAA              ; Draw the ship
159+  BEAA              ; Inputs:
160+  BEAA              ; None, all in memory
161+  BEAA              ;
162+  BEAA              ship_draw:
163+  BEAA 3E 04            ld a,4                              ; 4 pieces per half
164+  BEAC              ship_draw0:
165+  BEAC F5               push af
166+  BEAD 2A B9 BD         ld hl,(ship_current_sprite)
167+  BEB0 ED 4B BB BD      ld bc,(ship_current_coords)         ; load bc with the start coords
168+  BEB4 CD 94 A9         call sprites_drawsprite
169+  BEB7 2A B9 BD         ld hl,(ship_current_sprite)
170+  BEBA ED 4B BB BD      ld bc,(ship_current_coords)         ; load bc with the start coords
171+  BEBE 11 08 00         ld de,8
172+  BEC1 19               add hl,de
173+  BEC2 80 C6 08         add b,8
174+  BEC5 47               ld b,a
175+  BEC6 22 B9 BD         ld (ship_current_sprite),hl         ; put into memory
176+  BEC9 ED 43 BB BD      ld (ship_current_coords),bc         ; put into memory
177+  BECD F1               pop af
178+  BECE 3D               dec a
179+  BECF FE 00            cp 0
180+  BED1 C2 AC BE         jp nz,ship_draw0
181+  BED4
182+  BED4 C9               ret
183+  BED5
# file closed: game/ship.asm
 41   BED5                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  BED5              ;
  2+  BED5              ; tank initial position: vert,horiz
  3+  BED5              ;
  4+  BED5              tank_initpos:
  5+  BED5 10 D0            defb 16,208
  6+  BED7              tank_initpos2:
  7+  BED7 00 00            defb 0,0
  8+  BED9              tank_frame:
  9+  BED9 00               defb 0
 10+  BEDA              tank_anim:
 11+  BEDA 11               defb 17
 12+  BEDB
 13+  BEDB              ;
 14+  BEDB              ; The damage countdown
 15+  BEDB              ;
 16+  BEDB              tank_currentdamage:
 17+  BEDB F0               defb 240
 18+  BEDC
 19+  BEDC              ;
 20+  BEDC              ; The damage coordinate
 21+  BEDC              ;
 22+  BEDC              tank_currentdamagecoord:
 23+  BEDC 16 02            defb 22,2
 24+  BEDE
 25+  BEDE              ;
 26+  BEDE              ; Controls when the tank shoots
 27+  BEDE              ;
 28+  BEDE              tank_count:
 29+  BEDE 00               defb 0
 30+  BEDF
 31+  BEDF              ;
 32+  BEDF              ; Holds the block number of the current damage sprite
 33+  BEDF              ;
 34+  BEDF              tank_damageframe:
 35+  BEDF 00               defb 0
 36+  BEE0
 37+  BEE0              ;
 38+  BEE0              ; The current memory location
 39+  BEE0              ;
 40+  BEE0              tank_current_sprite:
 41+  BEE0 00 00            defb 0,0
 42+  BEE2
 43+  BEE2              tank_current_coords:
 44+  BEE2 00 00            defb 0,0
 45+  BEE4
 46+  BEE4              ;
 47+  BEE4              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  BEE4              ;
 49+  BEE4              tank_missile_displayed:
 50+  BEE4 00               defb 0
 51+  BEE5
 52+  BEE5              ;
 53+  BEE5              ; Initialise the tank
 54+  BEE5              ;
 55+  BEE5              tank_init:
 56+  BEE5 ED 4B D5 BE      ld bc,(tank_initpos)
 57+  BEE9 ED 43 D7 BE      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  BEED 21 D9 BE         ld hl,tank_frame
 59+  BEF0 36 00            ld (hl),0
 60+  BEF2 21 DA BE         ld hl,tank_anim
 61+  BEF5 36 11            ld (hl),17
 62+  BEF7 21 DF BE         ld hl,tank_damageframe              ; reset tank
 63+  BEFA 36 00            ld (hl),0
 64+  BEFC 21 DE BE         ld hl,tank_count
 65+  BEFF 36 00            ld (hl),0
 66+  BF01 21 DB BE         ld hl,tank_currentdamage
 67+  BF04 36 F0            ld (hl),240
 68+  BF06 21 DC BE         ld hl,tank_currentdamagecoord
 69+  BF09 36 16            ld (hl),22
 70+  BF0B 23               inc hl
 71+  BF0C 36 02            ld (hl),2
 72+  BF0E 21 E4 BE         ld hl,tank_missile_displayed
 73+  BF11 36 00            ld (hl),0
 74+  BF13
 75+  BF13 C9               ret
 76+  BF14
 77+  BF14              ;
 78+  BF14              ;   Draw and move the tank
 79+  BF14              ;   Start processing at frame 200
 80+  BF14              ;   Don't move if anim is zero
 81+  BF14              ;   Decrement frame if moved
 82+  BF14              ;
 83+  BF14              tank_process:
 84+  BF14 3A DA BE         ld a,(tank_anim)
 85+  BF17 FE 00            cp 0
 86+  BF19 C2 20 BF         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  BF1C CD 31 BF         call tank_fire
 88+  BF1F C9               ret
 89+  BF20              tank_process0:
 90+  BF20 CD 90 BB         call game_getcurrentframe   ; get the current frame number into a
 91+  BF23 FE 4B            cp 75
 92+  BF25 D8               ret c                       ; return if the frame number is below 100
 93+  BF26 CD 57 C0         call tank_move              ; move tank if not
 94+  BF29 3A DA BE         ld a,(tank_anim)
 95+  BF2C 3D               dec a
 96+  BF2D 32 DA BE         ld (tank_anim),a            ; decrease the anim count
 97+  BF30 C9               ret
 98+  BF31
 99+  BF31              ;
100+  BF31              ; Fires the tank
101+  BF31              ;
102+  BF31              tank_fire:
103+  BF31 3A DE BE         ld a,(tank_count)            ; if not, don't do anything
104+  BF34 3C               inc a                        ; increment
105+  BF35 FE 32            cp 50                        ; have we reached fifty
106+  BF37 C2 3C BF         jp nz,tank_fire0
107+  BF3A 3E 00            ld a,0                       ; reset if reached fifty
108+  BF3C              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  BF3C 32 DE BE         ld (tank_count),a            ; store tank count
110+  BF3F FE 00            cp 0
111+  BF41 CA 62 BF         jp z,tank_fire7              ; If this is zero, fire
112+  BF44 3A E4 BE         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  BF47 FE 00            cp 0
114+  BF49 C8               ret z                       ; don't do anything if not
115+  BF4A CD 11 C0         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  BF4D 3E 00            ld a,0                       ; reset the flag
117+  BF4F 32 E4 BE         ld (tank_missile_displayed),a
118+  BF52 3E 02            ld a,2
119+  BF54 ED 4B DC BE      ld bc,(tank_currentdamagecoord)
120+  BF58 0C               inc c
121+  BF59 0C               inc c
122+  BF5A ED 43 AB AA      ld (origcoords),bc
123+  BF5E CD BE A5         call buffer_marklineforupdate
124+  BF61 C9               ret                        ; only shoot if we're on 0
125+  BF62              tank_fire7:
126+  BF62 3A DB BE         ld a,(tank_currentdamage)    ; get the damage countdown
127+  BF65 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
128+  BF67 C2 9D BF         jp nz,tank_fire1            ; not, so just do a normal frame
129+  BF6A ED 4B DC BE      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
130+  BF6E 79               ld a,c
131+  BF6F FE 0A            cp 10
132+  BF71 C2 78 BF         jp nz, tank_fire6
133+  BF74 CD 49 C0         call tank_killedbytank      ; we're through, so the player has died. Kill them.
134+  BF77 C9               ret                         ; return if we're through the mountain
135+  BF78              tank_fire6:
136+  BF78 3E 0F            ld a,15
137+  BF7A 32 DF BE         ld (tank_damageframe),a     ; reset the damage frame
138+  BF7D 21 49 B4         ld hl,sprites               ; location of the empty block
139+  BF80 CD EC A8         call screen_showchar        ; show this character here
140+  BF83 ED 4B DC BE      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
141+  BF87 05               dec b                       ; look one above
142+  BF88 CD 50 A9         call screen_ischarempty     ; check if it is empty
143+  BF8B ED 4B DC BE      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
144+  BF8F FE 01            cp 1
145+  BF91 C2 D4 BF         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
146+  BF94 ED 4B DC BE      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  BF98 0D               dec c
148+  BF99 ED 43 DC BE      ld (tank_currentdamagecoord),bc ; store the coord
149+  BF9D              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
150+  BF9D ED 4B DC BE      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
151+  BFA1 3A DB BE         ld a,(tank_currentdamage)    ; get the damage countdown
152+  BFA4 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
153+  BFA6 C2 B1 BF         jp nz, tank_fire5
154+  BFA9 CD 80 A9         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
155+  BFAC FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
156+  BFAE C2 F2 BF         jp nz,tank_fire3            ; if it's a slope, handle this differently
157+  BFB1              tank_fire5:
158+  BFB1 3A DF BE         ld a,(tank_damageframe)
159+  BFB4 CD 0F A9         call screen_getblock        ; get the block data into hl
160+  BFB7 CD EC A8         call screen_showchar        ; show this character here
161+  BFBA 3A DF BE         ld a,(tank_damageframe)
162+  BFBD 3C               inc a
163+  BFBE 32 DF BE         ld (tank_damageframe),a     ; increment the damage block and store
164+  BFC1 3A DB BE         ld a,(tank_currentdamage)    ; get the damage countdown
165+  BFC4 3D               dec a
166+  BFC5 3D               dec a
167+  BFC6 32 DB BE         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
168+  BFC9 3A E4 BE         ld a,(tank_missile_displayed) ; is the missile displaying?
169+  BFCC FE 00            cp 0
170+  BFCE CC 11 C0         call z, tank_missilegraphic
171+  BFD1 C3 FB BF         jp tank_fire4
172+  BFD4              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
173+  BFD4 05               dec b
174+  BFD5 C5               push bc
175+  BFD6 CD 69 A9         call screen_copyblockdown       ; copy the block down
176+  BFD9 ED 4B DC BE      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
177+  BFDD C1               pop bc                      ; get the coord we just checked back
178+  BFDE 78               ld a,b
179+  BFDF FE 00            cp 0
180+  BFE1 CA 9D BF         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
181+  BFE4 C5               push bc
182+  BFE5 05               dec b
183+  BFE6 CD 50 A9         call screen_ischarempty     ; check if it is empty
184+  BFE9 C1               pop bc
185+  BFEA FE 01            cp 1                        ; if empty
186+  BFEC C2 D4 BF         jp nz, tank_fire2            ; copy another one down
187+  BFEF C3 9D BF         jp tank_fire1               ; otherwise, return to main thread
188+  BFF2              tank_fire3:                      ; dealing with slopes
189+  BFF2 3A DB BE         ld a,(tank_currentdamage)    ; get the damage countdown
190+  BFF5 06 08            ld b,8
191+  BFF7 90               sub b                        ; special case for slopes
192+  BFF8 32 DB BE         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
193+  BFFB              tank_fire4:                     ; TIDY UP
194+  BFFB ED 4B DC BE      ld bc,(tank_currentdamagecoord)
195+  BFFF ED 43 AB AA      ld (origcoords),bc
196+  C003 CD BE A5         call buffer_marklineforupdate
197+  C006 3E 01            ld a,1
198+  C008 CD BE A5         call buffer_marklineforupdate
199+  C00B 3E 02            ld a,2
200+  C00D CD BE A5         call buffer_marklineforupdate
201+  C010 C9               ret
202+  C011
203+  C011              ;
204+  C011              ; Displays or hides the missile graphic, and changes the gun
205+  C011              ;
206+  C011              tank_missilegraphic:
207+  C011 3A E4 BE         ld a,(tank_missile_displayed)
208+  C014 FE 00            cp 0
209+  C016 C2 1E C0         jp nz,tank_missilegraphic0
210+  C019 3E 13            ld a,19
211+  C01B C3 20 C0         jp tank_missilegraphic1
212+  C01E              tank_missilegraphic0:
213+  C01E 3E 00            ld a,0
214+  C020              tank_missilegraphic1:
215+  C020 32 E4 BE         ld (tank_missile_displayed),a ; store the flipped graphic
216+  C023 ED 4B DC BE      ld bc,(tank_currentdamagecoord)
217+  C027 0C               inc c
218+  C028 0C               inc c                   ; print the graphic 2 spaces right
219+  C029 CD 0F A9         call screen_getblock        ; get the block data into hl
220+  C02C CD EC A8         call screen_showchar        ; show this character here
221+  C02F 06 02            ld b,2
222+  C031 0E 18            ld c,24                     ; set gunbarrel coords
223+  C033 11 00 00         ld de,0
224+  C036 21 0C B6         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
225+  C039 3A E4 BE         ld a,(tank_missile_displayed)
226+  C03C FE 00            cp 0
227+  C03E CA 44 C0         jp z,tank_missilegraphic2
228+  C041 11 40 00         ld de,64
229+  C044              tank_missilegraphic2:
230+  C044 19               add hl,de                   ; work out missile graphic
231+  C045 CD EC A8         call screen_showchar        ; show this character here
232+  C048 C9               ret
233+  C049
234+  C049              ;
235+  C049              ; Deal with the player being killed by the tank
236+  C049              ;
237+  C049              tank_killedbytank:
238+  C049 ED 4B DC BE      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
239+  C04D 21 49 B4         ld hl,sprites                   ; empty sprite
240+  C050 CD EC A8         call screen_showchar            ; hide the last piece of dirt
241+  C053 CD 8E BC         call player_tankkillplayer
242+  C056 C9               ret
243+  C057
244+  C057              tank_move:
245+  C057 ED 4B D7 BE      ld bc,(tank_initpos2)
246+  C05B C5               push bc
247+  C05C 3A DA BE         ld a,(tank_anim)
248+  C05F FE 11            cp 17                       ; check first time flag
249+  C061 CA 73 C0         jp z,tank_move1             ; don't draw over previous one if first time
250+  C064 CD 78 C0         call tank_draw_full         ; delete old one
251+  C067 ED 4B D7 BE      ld bc,(tank_initpos2)       ; get the current coords
252+  C06B 78               ld a,b
253+  C06C D6 01            sub 1                       ; move back one pixels
254+  C06E 47               ld b,a
255+  C06F ED 43 D7 BE      ld (tank_initpos2),bc
256+  C073              tank_move1:
257+  C073 CD 78 C0         call tank_draw_full         ; draw the tank
258+  C076 C1               pop bc
259+  C077 C9               ret
260+  C078
261+  C078              tank_draw_full:
262+  C078 21 0C B6         ld hl,tank_sprite
263+  C07B ED 4B D7 BE      ld bc,(tank_initpos2)         ; load bc with the start coords
264+  C07F 22 E0 BE         ld (tank_current_sprite),hl  ; put into memory
265+  C082 ED 43 E2 BE      ld (tank_current_coords),bc  ; put into memory
266+  C086 CD A5 C0         call tank_draw
267+  C089 08               ex af,af'
268+  C08A 3A D9 BE         ld a,(tank_frame)            ; get the animation frame
269+  C08D 16 00            ld d,0
270+  C08F 5F               ld e,a
271+  C090 19               add hl,de
272+  C091 22 E0 BE         ld (tank_current_sprite),hl  ; put into memory
273+  C094 08               ex af,af'
274+  C095 ED 4B D7 BE      ld bc,(tank_initpos2)         ; load bc with the start coords
275+  C099 81 C6 08         add c,8                      ; move one line down
276+  C09C 4F               ld c,a
277+  C09D ED 43 E2 BE      ld (tank_current_coords),bc  ; put into memory
278+  C0A1 CD A5 C0         call tank_draw
279+  C0A4 C9               ret
280+  C0A5
281+  C0A5              ;
282+  C0A5              ; Draw the tank
283+  C0A5              ; Inputs:
284+  C0A5              ; None, all in memory
285+  C0A5              ;
286+  C0A5              tank_draw:
287+  C0A5 3E 04            ld a,4                              ; 4 pieces per half
288+  C0A7              tank_draw0:
289+  C0A7 F5               push af
290+  C0A8 2A E0 BE         ld hl,(tank_current_sprite)
291+  C0AB ED 4B E2 BE      ld bc,(tank_current_coords)         ; load bc with the start coords
292+  C0AF CD 94 A9         call sprites_drawsprite
293+  C0B2 2A E0 BE         ld hl,(tank_current_sprite)
294+  C0B5 ED 4B E2 BE      ld bc,(tank_current_coords)         ; load bc with the start coords
295+  C0B9 11 08 00         ld de,8
296+  C0BC 19               add hl,de
297+  C0BD 80 C6 08         add b,8
298+  C0C0 47               ld b,a
299+  C0C1 22 E0 BE         ld (tank_current_sprite),hl         ; put into memory
300+  C0C4 ED 43 E2 BE      ld (tank_current_coords),bc         ; put into memory
301+  C0C8 F1               pop af
302+  C0C9 3D               dec a
303+  C0CA FE 00            cp 0
304+  C0CC C2 A7 C0         jp nz,tank_draw0
305+  C0CF
306+  C0CF C9               ret
307+  C0D0
# file closed: game/tank.asm
 42   C0D0                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  C0D0              ;
  2+  C0D0              ; A structure of falling rocks
  3+  C0D0              ; Assume we'll never have more than 4 falling at any one time
  4+  C0D0              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  C0D0              ;
  6+  C0D0              rocks_falling:
  7+  C0D0 00 00 00 00      defb 0,0,0,0
  8+  C0D4 00 00 00 00      defb 0,0,0,0
  9+  C0D8 00 00 00 00      defb 0,0,0,0
 10+  C0DC 00 00 00 00      defb 0,0,0,0
 11+  C0E0
 12+  C0E0              rocks_tmp:
 13+  C0E0 00               defb 0
 14+  C0E1
 15+  C0E1              rocks_tmp2:
 16+  C0E1 00 00            defb 0,0
 17+  C0E3
 18+  C0E3              ;
 19+  C0E3              ; The number of frames to wobble for
 20+  C0E3              ; Must always be 10 more than the number of frames a player digs
 21+  C0E3              ;
 22+  C0E3              rocks_numberofframestowobble:
 23+  C0E3 14               defb 20
 24+  C0E4
 25+  C0E4              ;
 26+  C0E4              ; Coords of the rock that killed us
 27+  C0E4              ;
 28+  C0E4              rocks_killerrock:
 29+  C0E4 00 00            defb 0,0
 30+  C0E6
 31+  C0E6              ;
 32+  C0E6              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  C0E6              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  C0E6              ; If the pixel row is not the rock bottom, stop checking.
 35+  C0E6              ; Inputs:
 36+  C0E6              ; hl- memory location
 37+  C0E6              ;
 38+  C0E6              rocks_checkforfalling:
 39+  C0E6 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  C0E7 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  C0E9 C2 EF C0         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  C0EC CD F0 C0         call rocks_addrocktofalling ; mark the rock as falling
 43+  C0EF              rocks_checkforfalling2:
 44+  C0EF C9               ret
 45+  C0F0
 46+  C0F0              ;
 47+  C0F0              ; Adds the rock to the structure that tracks falling rocks
 48+  C0F0              ; Inputs:
 49+  C0F0              ; hl - memory location of falling rock graphic
 50+  C0F0              ; bc - coords of rock, c vert
 51+  C0F0              rocks_addrocktofalling:
 52+  C0F0 C5               push bc             ; store the coords
 53+  C0F1 11 D0 C0         ld de,rocks_falling
 54+  C0F4 06 04            ld b,4              ; number of possible falling rocks
 55+  C0F6              rocks_addrocktofalling0:
 56+  C0F6 13               inc de
 57+  C0F7                  ;inc de
 58+  C0F7 13               inc de              ; move three along to get the state
 59+  C0F8 1A               ld a,(de)           ; load the state
 60+  C0F9 FE 00            cp 0                ; check if this is not falling
 61+  C0FB C2 12 C1         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  C0FE 13               inc de              ; move to frame
 63+  C0FF 3A E3 C0         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  C102 12               ld (de),a
 65+  C103 1B               dec de              ; move de back to state
 66+  C104 3E 02            ld a,2
 67+  C106 12               ld (de),a           ; set the state to wobbling
 68+  C107 1B               dec de              ; move back coords
 69+  C108 C1               pop bc              ; get back coords
 70+  C109 78               ld a,b
 71+  C10A 12               ld (de),a           ; store the vertical
 72+  C10B 1B               dec de
 73+  C10C 79               ld a,c
 74+  C10D 12               ld (de),a           ; store the horizontal
 75+  C10E C5               push bc
 76+  C10F C3 16 C1         jp rocks_addrocktofalling2 ; done
 77+  C112              rocks_addrocktofalling1:
 78+  C112 13               inc de
 79+  C113 13               inc de              ; move memory along to next rock
 80+  C114 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  C116              rocks_addrocktofalling2: ; done, return
 82+  C116 C1               pop bc              ; to tidy up
 83+  C117 C9               ret
 84+  C118
 85+  C118              ;
 86+  C118              ; Processes any falling rocks
 87+  C118              ;
 88+  C118              rocks_processrocks:
 89+  C118 DD 21 D0 C0      ld ix,rocks_falling
 90+  C11C 06 04            ld b,4              ; the number of rocks to check
 91+  C11E              rocks_processrocks0:
 92+  C11E C5               push bc             ; store loop count
 93+  C11F DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  C123 46 01
 94+  C125 DD 23            inc ix
 95+  C127 DD 23            inc ix              ; move to the state
 96+  C129 DD 7E 00         ld a,(ix)           ; load the state into a
 97+  C12C FE 00            cp 0
 98+  C12E CA 4F C1         jp z,rocks_processrocks3 ; if not falling, check next
 99+  C131 FE 02            cp 2
100+  C133 C2 43 C1         jp nz, rocks_processrocks2
101+  C136                  ; we're wobbling
102+  C136 DD 23            inc ix              ; get frame number for wobble
103+  C138 DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  C13B CD 12 C2         call rocks_wobble
105+  C13E DD 23            inc ix              ; increment for next
106+  C140 C3 53 C1         jp rocks_processrocks1  ; do next rock
107+  C143              rocks_processrocks2:
108+  C143                  ; we're falling
109+  C143 C5               push bc
110+  C144 CD 57 C1         call rocks_fall
111+  C147 C1               pop bc
112+  C148 DD 23            inc ix
113+  C14A DD 23            inc ix              ; inc ix to get to next
114+  C14C C3 53 C1         jp rocks_processrocks1
115+  C14F              rocks_processrocks3:
116+  C14F DD 23            inc ix
117+  C151 DD 23            inc ix
118+  C153              rocks_processrocks1:
119+  C153 C1               pop bc              ; get loop count back
120+  C154 10 C8            djnz rocks_processrocks0
121+  C156 C9               ret
122+  C157
123+  C157              ;
124+  C157              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  C157              ; bc - coord of current rock graphic on screen
126+  C157              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  C157              ;
128+  C157              rocks_fall:
129+  C157 DD 2B            dec ix
130+  C159 DD 2B            dec ix              ; decrease ix back to coords
131+  C15B ED 43 E1 C0      ld (rocks_tmp2),bc  ; store original coords
132+  C15F 3E 03            ld a,3              ; move this number of pixels
133+  C161              rocks_fall1:
134+  C161 32 E0 C0         ld (rocks_tmp),a    ; store loop counter
135+  C164 DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  C168 46 01
136+  C16A CD 89 AA         call sprites_scadd  ; get the memory of the coords into de
137+  C16D 14               inc d               ; add 256 to get next row
138+  C16E 1A               ld a,(de)           ; get the contents of the next row
139+  C16F FE 00            cp 0
140+  C171 C2 D1 C1         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  C174 0C               inc c               ; increment the vertical
142+  C175 DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  C179 70 01
143+  C17B 79               ld a,c              ; get the vertical coord into a
144+  C17C E6 07            and 7               ; divisible by 8?
145+  C17E FE 00            cp 0
146+  C180 C2 9D C1         jp nz,rocks_fall4   ; if not, carry on
147+  C183 CD C2 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  C186 3E 42            ld a,66             ; load red
149+  C188 CD 1A A9         call screen_setattr
150+  C18B DD 4E 00 DD      ld bc,(ix)
150+  C18F 46 01
151+  C191 79               ld a,c              ; get vertical
152+  C192 D6 08            sub 8               ; look up one square
153+  C194 4F               ld c,a              ; put a back in c
154+  C195 CD C2 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  C198 3E 46            ld a,70             ; load yellow
156+  C19A CD 1A A9         call screen_setattr
157+  C19D              rocks_fall4:
158+  C19D 3A E0 C0         ld a,(rocks_tmp)    ; get the loop counter
159+  C1A0 3D               dec a
160+  C1A1 FE 00            cp 0
161+  C1A3 C2 61 C1         jp nz,rocks_fall1   ; do another pixel if needed
162+  C1A6              rocks_fall2:
163+  C1A6 3E 09            ld a,9              ; rock graphic
164+  C1A8 ED 4B E1 C0      ld bc,(rocks_tmp2)  ; get the original coords
165+  C1AC CD 0F A9         call screen_getblock     ; get the memory into hl
166+  C1AF CD 94 A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  C1B2 3E 09            ld a,9
168+  C1B4 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  C1B8 46 01
169+  C1BA CD 0F A9         call screen_getblock     ; get the memory into hl
170+  C1BD CD 94 A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  C1C0 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  C1C4 46 01
172+  C1C6 CD F7 C1         call rocks_checkforplayer ; check to see if we hit a player
173+  C1C9 DD 23            inc ix
174+  C1CB DD 23            inc ix                  ; get ix back to state
175+  C1CD CD E7 C1         call rocks_makesound
176+  C1D0 C9               ret
177+  C1D1              rocks_fall3:
178+  C1D1 3E 00            ld a,0              ; set the state to fell
179+  C1D3 DD 77 02         ld (ix+2),a           ; store the falling state
180+  C1D6 DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  C1DA 46 01
181+  C1DC CD C2 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  C1DF 3E 42            ld a,66             ; load magenta
183+  C1E1 CD 1A A9         call screen_setattr
184+  C1E4 C3 A6 C1         jp rocks_fall2      ; rejoin main loop
185+  C1E7
186+  C1E7              ;
187+  C1E7              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  C1E7              ;
189+  C1E7              rocks_makesound:
190+  C1E7 DD 7E 00         ld a,(ix)           ; get the state
191+  C1EA FE 00            cp 0
192+  C1EC C0               ret nz              ; if we haven't fallen, don't do anything
193+  C1ED 21 A5 BB         ld hl,player+11
194+  C1F0 7E               ld a,(hl)
195+  C1F1 FE 01            cp 1
196+  C1F3 C4 7A AE         call nz, sound_rockfell ; only make sound if didn't kill player
197+  C1F6 C9               ret
198+  C1F7
199+  C1F7              ;
200+  C1F7              ; Checks to see if the rock is hitting a player
201+  C1F7              ; Inputs:
202+  C1F7              ; bc - coords of rock we're checking
203+  C1F7              rocks_checkforplayer:
204+  C1F7 ED 5B 9A BB      ld de,(player)       ; get the player coords
205+  C1FB 7B               ld a,e               ; get the vert coord first
206+  C1FC 91               sub c                ; subtract the rock vertical coord from players
207+  C1FD FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  C1FF C0               ret nz               ; if not, hasn't hit
209+  C200 7A               ld a,d               ; get the player horiz coord
210+  C201 90               sub b                ; subtract rock coord
211+  C202 C6 07            add 7                ; add max distance
212+  C204 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  C206 DA 0A C2         jp c,rocks_checkforplayer0
214+  C209 C9               ret
215+  C20A              rocks_checkforplayer0:
216+  C20A ED 43 E4 C0      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  C20E CD 88 BC         call player_crushplayer ; if so, jump out
218+  C211 C9               ret
219+  C212
220+  C212              ;
221+  C212              ; Wobbles a rocks
222+  C212              ; Inputs:
223+  C212              ; bc - coord of current rock graphic on screen
224+  C212              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  C212              ; a - wobble frame
226+  C212              rocks_wobble:
227+  C212 DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  C215 E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  C217 1E 09            ld e,9              ; this is the rock frame
230+  C219 83               add a,e             ; add the frame toggle
231+  C21A C5               push bc
232+  C21B CD 0F A9         call screen_getblock     ; get the memory into hl
233+  C21E CD 94 A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  C221 DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  C224 3D               dec a               ; decrease
236+  C225 DD 77 00         ld (ix),a           ; store
237+  C228 E6 01            and 1
238+  C22A 1E 09            ld e,9              ; this is the rock frame
239+  C22C 83               add a,e             ; add the frame toggle
240+  C22D CD 0F A9         call screen_getblock     ; get the memory into hl
241+  C230 C1               pop bc
242+  C231 CD 94 A9         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  C234 DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  C237 FE 00            cp 0
245+  C239 C0               ret nz              ; if we're not at zero, return
246+  C23A DD 2B            dec ix              ; otherwise look to state location
247+  C23C 3E 01            ld a,1              ; set the state to falling
248+  C23E DD 77 00         ld (ix),a           ; store the falling state
249+  C241 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  C243 C9               ret
251+  C244
# file closed: game/rocks.asm
 43   C244                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  C244              ;
  2+  C244              ; The score of the current player
  3+  C244              ;
  4+  C244              scores_current:
  5+  C244 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  C248 30 30 30 30
  5+  C24C FF
  6+  C24D
  7+  C24D              scores_defaultname:
  8+  C24D 2D 2D 2D         defb '---'
  9+  C250
 10+  C250              ;
 11+  C250              ; The current high score table
 12+  C250              ;
 13+  C250              scores_table:
 14+  C250 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  C254 4D 30 30 30
 14+  C258 30 30 30 FF
 15+  C25C 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  C260 4D 30 30 30
 15+  C264 30 30 30 FF
 16+  C268 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  C26C 4D 30 30 30
 16+  C270 30 30 30 FF
 17+  C274
 18+  C274              ;
 19+  C274              ; Add thousands to the score
 20+  C274              ; Inputs:
 21+  C274              ; b - number to add
 22+  C274              ;
 23+  C274              scores_addthousands:
 24+  C274 21 48 C2         ld hl,scores_current+4
 25+  C277 CD A1 C2         call scores_update
 26+  C27A C9               ret
 27+  C27B
 28+  C27B              ;
 29+  C27B              ; Prints the score to screen
 30+  C27B              ;
 31+  C27B              scores_printscore:
 32+  C27B 3A 6C BB         ld a,(game_currentplayer)   ; get current player
 33+  C27E 21 44 C2         ld hl,scores_current
 34+  C281 FE 01            cp 1
 35+  C283 C2 8B C2         jp nz, score_printscore0    ; if not player 1
 36+  C286 36 04            ld (hl),4       ; set position for player 1
 37+  C288 C3 8D C2         jp score_printscore1
 38+  C28B              score_printscore0:
 39+  C28B 36 16            ld (hl),22       ; set position for player 2
 40+  C28D              score_printscore1:
 41+  C28D 21 44 C2         ld hl,scores_current
 42+  C290 CD BE 84         call string_print
 43+  C293 C9               ret
 44+  C294
 45+  C294              ;
 46+  C294              ; Prints both scores to screen
 47+  C294              ;
 48+  C294              scores_printscores:
 49+  C294 21 70 BC         ld hl,player1_score
 50+  C297 CD BE 84         call string_print
 51+  C29A 21 79 BC         ld hl,player2_score
 52+  C29D CD BE 84         call string_print
 53+  C2A0 C9               ret
 54+  C2A1
 55+  C2A1              ;
 56+  C2A1              ; Updates the current score.
 57+  C2A1              ; Inputs:
 58+  C2A1              ; hl - memory location of the score column
 59+  C2A1              ; b - number to add
 60+  C2A1              ;
 61+  C2A1              scores_update:
 62+  C2A1 7E               ld a,(hl)           ; current value of digit.
 63+  C2A2 80               add a,b             ; add points to this digit.
 64+  C2A3 77               ld (hl),a           ; place new digit back in string.
 65+  C2A4 FE 3A            cp 58               ; more than ASCII value '9'?
 66+  C2A6 D8               ret c               ; no - relax.
 67+  C2A7 D6 0A            sub 10              ; subtract 10.
 68+  C2A9 77               ld (hl),a           ; put new character back in string.
 69+  C2AA              scores_update0:
 70+  C2AA 2B               dec hl              ; previous character in string.
 71+  C2AB 34               inc (hl)            ; up this by one.
 72+  C2AC 7E               ld a,(hl)           ; what's the new value?
 73+  C2AD FE 3A            cp 58               ; gone past ASCII nine?
 74+  C2AF D8               ret c               ; no, scoring done.
 75+  C2B0 D6 0A            sub 10              ; down by ten.
 76+  C2B2 77               ld (hl),a           ; put it back
 77+  C2B3 C3 AA C2         jp scores_update0   ; go round again.
 78+  C2B6
 79+  C2B6
 80+  C2B6              ;
 81+  C2B6              ; Displays the high score table at the bottom of the screen
 82+  C2B6              ;
 83+  C2B6              scores_showtable:
 84+  C2B6 21 50 C2         ld hl, scores_table
 85+  C2B9 CD BE 84         call string_print
 86+  C2BC 21 5C C2         ld hl, scores_table+12
 87+  C2BF CD BE 84         call string_print
 88+  C2C2 21 68 C2         ld hl, scores_table+24
 89+  C2C5 CD BE 84         call string_print
 90+  C2C8 C9               ret
 91+  C2C9
 92+  C2C9              ;
 93+  C2C9              ; Place to store the current position we're checking
 94+  C2C9              ;
 95+  C2C9              scores_highscoretmp:
 96+  C2C9 00               defb 0
 97+  C2CA
 98+  C2CA              ;
 99+  C2CA              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
100+  C2CA              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
101+  C2CA              ;
102+  C2CA              scores_processhighscores:
103+  C2CA 21 C9 C2         ld hl,scores_highscoretmp
104+  C2CD 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
105+  C2CF 3E 1D            ld a,29
106+  C2D1              scores_processhighscores3:
107+  C2D1 21 50 C2         ld hl,scores_table          ; position of first score column
108+  C2D4 5F               ld e,a
109+  C2D5 16 00            ld d,0
110+  C2D7 19               add hl,de
111+  C2D8 08               ex af,af'                   ; store a for later
112+  C2D9 11 46 C2         ld de,scores_current+2      ; position of current score column
113+  C2DC 06 06            ld b,6                      ; times to loop
114+  C2DE              scores_processhighscores0:
115+  C2DE 7E               ld a,(hl)
116+  C2DF 4F               ld c,a                      ; get first score column
117+  C2E0 1A               ld a,(de)                   ; get first current column
118+  C2E1 B9               cp c                        ; compare current with first
119+  C2E2 DA F3 C2         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
120+  C2E5 23               inc hl
121+  C2E6 13               inc de                      ; move to next column
122+  C2E7 10 F5            djnz scores_processhighscores0 ; loop
123+  C2E9 08               ex af,af'                     ; still here, so must be bigger
124+  C2EA 32 C9 C2         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
125+  C2ED 0E 0C            ld c,12
126+  C2EF 91               sub c
127+  C2F0 D2 D1 C2         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
128+  C2F3              scores_processhighscores4
129+  C2F3 CD F7 C2         call scores_updatehighscores
130+  C2F6 C9               ret
131+  C2F7
132+  C2F7              ;
133+  C2F7              ; Update score table
134+  C2F7              ;
135+  C2F7              scores_updatehighscores:
136+  C2F7 3A C9 C2         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
137+  C2FA FE 00            cp 0
138+  C2FC C8               ret z                       ; if this is 0, didn't get a high score
139+  C2FD FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
140+  C2FF CA 32 C3         jp z, scores_updatehighscores3
141+  C302                                              ; copy old score over one below, if not first
142+  C302 21 50 C2         ld hl,scores_table
143+  C305 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
144+  C308 19               add hl,de                   ; position of first column
145+  C309 2B               dec hl
146+  C30A 2B               dec hl
147+  C30B 2B               dec hl
148+  C30C E5               push hl
149+  C30D 11 0C 00         ld de,12
150+  C310 19               add hl,de                   ; get position of next score
151+  C311 54 5D            ld de,hl
152+  C313 E1               pop hl                      ; get hl back
153+  C314 01 09 00         ld bc,9
154+  C317 ED B0            ldir
155+  C319 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
156+  C31B CA 32 C3         jp z,scores_updatehighscores3
157+  C31E 21 50 C2         ld hl,scores_table
158+  C321 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
159+  C324 19               add hl,de                   ; position of first column
160+  C325 E5               push hl
161+  C326 11 0C 00         ld de,12
162+  C329 19               add hl,de                   ; get position of next score
163+  C32A 54 5D            ld de,hl
164+  C32C E1               pop hl                      ; get hl back
165+  C32D 01 09 00         ld bc,9
166+  C330 ED B0            ldir
167+  C332              scores_updatehighscores3:
168+  C332 06 06            ld b,6                      ; now overwrite
169+  C334 21 50 C2         ld hl,scores_table
170+  C337 16 00            ld d,0
171+  C339 5F               ld e,a
172+  C33A 19               add hl,de                   ; position of first column
173+  C33B 08               ex af,af'
174+  C33C 11 46 C2         ld de,scores_current+2      ; position of current score column
175+  C33F              scores_updatehighscores2:
176+  C33F 1A               ld a,(de)
177+  C340 77               ld (hl),a
178+  C341 23               inc hl
179+  C342 13               inc de
180+  C343 10 FA            djnz scores_updatehighscores2
181+  C345 11 09 00         ld de,9
182+  C348 ED 52            sbc hl,de
183+  C34A 54 5D            ld de,hl                    ; get back to start of entry
184+  C34C 21 4D C2         ld hl,scores_defaultname    ; still need to overwrite the name
185+  C34F 01 03 00         ld bc,3                      ; 3 chars to copy
186+  C352 ED B0            ldir
187+  C354 C9               ret
# file closed: game/scores.asm
 44   C355                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  C355              diamonds_tmp:
  2+  C355 00               defb 0
  3+  C356
  4+  C356              diamonds_tmp2:
  5+  C356 00               defb 0
  6+  C357
  7+  C357              ;
  8+  C357              ; Holds the number of thousands for the current gem type
  9+  C357              ;
 10+  C357              diamonds_score:
 11+  C357 00               defb 0
 12+  C358
 13+  C358              ;
 14+  C358              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  C358              ; Inputs:
 16+  C358              ; hl - memory location of gem type
 17+  C358              diamonds_twinkle_type:
 18+  C358 CD 90 BB         call game_getcurrentframe       ; get current frame number
 19+  C35B E6 07            and 7                           ; want a number from 0-7
 20+  C35D C6 40            add 64                          ; add to 60 to get attr colour
 21+  C35F 32 56 C3         ld (diamonds_tmp2),a             ; store the colour
 22+  C362              diamonds_twinkle_type0:
 23+  C362 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  C366 79               ld a,c                          ; load c into a
 25+  C367 FE FF            cp 255                          ; is this the end?
 26+  C369 CA 91 C3         jp z,diamonds_twinkle_type1           ; step out if so
 27+  C36C 23               inc hl
 28+  C36D 23               inc hl
 29+  C36E 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  C36F FE 01            cp 1
 31+  C371 CA 92 C3         jp z,diamonds_twinkle_type2           ; step out if so
 32+  C374 CD D2 C3         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  C377 DC 99 C3         call c,diamonds_collect     ; we collided
 34+  C37A 23               inc hl
 35+  C37B E5               push hl
 36+  C37C E5 DD E1         ld ix,hl
 37+  C37F DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  C383 46 FE
 38+  C385 3A 56 C3         ld a,(diamonds_tmp2)
 39+  C388 CD 1A A9         call screen_setattr
 40+  C38B E1               pop hl
 41+  C38C 23               inc hl
 42+  C38D 23               inc hl                          ; move to next diamond
 43+  C38E C3 62 C3         jp diamonds_twinkle_type0
 44+  C391              diamonds_twinkle_type1:
 45+  C391 C9               ret
 46+  C392              diamonds_twinkle_type2:
 47+  C392 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  C393 23               inc hl
 49+  C394 23               inc hl
 50+  C395 08               ex af,af'
 51+  C396 C3 62 C3         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  C399
 53+  C399              ;
 54+  C399              ; Collect the diamond we collided with
 55+  C399              ; Inputs:
 56+  C399              ; hl - memory location of current diamond, currently on state
 57+  C399              ; Output:
 58+  C399              ; a - 70 - for yellow on black
 59+  C399              diamonds_collect:
 60+  C399 36 01            ld (hl),1                       ; collected
 61+  C39B E5               push hl
 62+  C39C 2B               dec hl
 63+  C39D 2B               dec hl
 64+  C39E 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  C3A2 CD D2 A8         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  C3A5 ED 5B 55 C3      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  C3A9 16 00            ld d,0
 68+  C3AB 21 49 B4         ld hl,sprites
 69+  C3AE 19               add hl,de
 70+  C3AF CD 94 A9         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  C3B2 E1               pop hl
 72+  C3B3 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  C3B5 32 56 C3         ld (diamonds_tmp2),a
 74+  C3B8 D9               exx
 75+  C3B9 3A 57 C3         ld a,(diamonds_score)
 76+  C3BC 47               ld b,a
 77+  C3BD CD 74 C2         call scores_addthousands
 78+  C3C0 3A 55 C3         ld a,(diamonds_tmp)
 79+  C3C3 FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  C3C5 C2 CD C3         jp nz,diamonds_collect0
 81+  C3C8 21 A7 BB         ld hl,player+13
 82+  C3CB 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  C3CD              diamonds_collect0:
 84+  C3CD CD 5D AE         call sound_gemcollected
 85+  C3D0 D9               exx
 86+  C3D1 C9               ret
 87+  C3D2
 88+  C3D2              ;
 89+  C3D2              ; Checks to see if the gem is hitting a player
 90+  C3D2              ; Inputs:
 91+  C3D2              ; bc - coords of diamond we're checking
 92+  C3D2              diamonds_checkforplayer:
 93+  C3D2 78               ld a,b               ; multiply b by 8
 94+  C3D3 07               rlca
 95+  C3D4 07               rlca
 96+  C3D5 07               rlca
 97+  C3D6 47               ld b,a
 98+  C3D7 ED 5B 9A BB      ld de,(player)       ; get the player coords
 99+  C3DB 7B               ld a,e               ; get the vert coord first
100+  C3DC 90               sub b                ; subtract the diamond vertical coord from players
101+  C3DD C6 04            add 4                ; add the max distance
102+  C3DF FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  C3E1 D0               ret nc               ; if not, hasn't hit
104+  C3E2 79               ld a,c               ; multiply c by 8
105+  C3E3 07               rlca
106+  C3E4 07               rlca
107+  C3E5 07               rlca
108+  C3E6 4F               ld c,a
109+  C3E7 7A               ld a,d               ; get the player horiz coord
110+  C3E8 91               sub c                ; subtract rock coord
111+  C3E9 C6 04            add 4                ; add max distance
112+  C3EB FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  C3ED D0               ret nc
114+  C3EE 3E 00            ld a,0
115+  C3F0 C9               ret
116+  C3F1
117+  C3F1
118+  C3F1              ;
119+  C3F1              ; Initialise diamonds and gems
120+  C3F1              ;
121+  C3F1              diamonds_twinkle
122+  C3F1 21 57 C3         ld hl,diamonds_score
123+  C3F4 36 02            ld (hl),2         ; store the score we'll add
124+  C3F6 21 55 C3         ld hl,diamonds_tmp
125+  C3F9 36 40            ld (hl),64         ; store the location the diamond sprite
126+  C3FB 21 C4 B3         ld hl, level01diamonds
127+  C3FE CD 58 C3         call diamonds_twinkle_type
128+  C401 21 57 C3         ld hl,diamonds_score
129+  C404 36 01            ld (hl),1         ; store the score we'll add
130+  C406 21 55 C3         ld hl,diamonds_tmp
131+  C409 36 70            ld (hl),112         ; store the location the gem sprite
132+  C40B 21 D4 B3         ld hl, level01gems
133+  C40E CD 58 C3         call diamonds_twinkle_type
134+  C411 C9               ret
135+  C412
136+  C412              ;
137+  C412              ; Initialise diamonds and gems
138+  C412              ;
139+  C412              diamonds_init:
140+  C412 21 C4 B3         ld hl, level01diamonds
141+  C415 CD 1F C4         call diamonds_init_type
142+  C418 21 D4 B3         ld hl, level01gems
143+  C41B CD 1F C4         call diamonds_init_type
144+  C41E C9               ret
145+  C41F
146+  C41F              ;
147+  C41F              ; Initialise diamonds or gems, get memory addresses
148+  C41F              ; Inputs:
149+  C41F              ; hl - memory location
150+  C41F              diamonds_init_type:
151+  C41F 4E               ld c,(hl)                      ; get coords into c
152+  C420 79               ld a,c                          ; load c into add
153+  C421 FE FF            cp 255                          ; is this the end?
154+  C423 CA 3A C4         jp z,diamonds_init_type1             ; step out if so
155+  C426 23               inc hl
156+  C427 46               ld b,(hl)                       ; get coords into b
157+  C428 E5               push hl
158+  C429 CD 83 A8         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  C42C E1               pop hl
160+  C42D 23               inc hl                          ; move to state
161+  C42E 36 00            ld (hl),0
162+  C430 23               inc hl                          ; move to memory
163+  C431 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  C435 23               inc hl                          ; move to next diamond
165+  C436 23               inc hl
166+  C437 C3 1F C4         jp diamonds_init_type
167+  C43A              diamonds_init_type1:
168+  C43A C9               ret
# file closed: game/diamonds.asm
 45   C43B                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  C43B              ;
  2+  C43B              ; Controls when missiles fall
  3+  C43B              ;
  4+  C43B              missiles_count:
  5+  C43B 00               defb 0
  6+  C43C
  7+  C43C              ;
  8+  C43C              ; A structure of falling missiles
  9+  C43C              ; Assume we'll never have more than 4 falling at any one time
 10+  C43C              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  C43C              ;
 12+  C43C              missiles_falling:
 13+  C43C 00 00 00         defb 0,0,0
 14+  C43F 00 00 00         defb 0,0,0
 15+  C442 00 00 00         defb 0,0,0
 16+  C445 00 00 00         defb 0,0,0
 17+  C448
 18+  C448              ;
 19+  C448              ; The coords of the missile that killed us
 20+  C448              ;
 21+  C448              missiles_killermissile:
 22+  C448 00 00            defb 0,0
 23+  C44A
 24+  C44A              ;
 25+  C44A              ; Zeroes the state of each missile
 26+  C44A              ;
 27+  C44A              missiles_init:
 28+  C44A 06 0C            ld b,12
 29+  C44C DD 21 4B B3      ld ix,level01missiles
 30+  C450              missiles_init0:
 31+  C450 DD 36 02 00      ld (ix+2),0               ; set the state to zero
 32+  C454 11 05 00         ld de,5
 33+  C457 DD 19            add ix,de
 34+  C459 DD 36 02 00      ld (ix+2),0
 35+  C45D DD 19            add ix,de
 36+  C45F 10 EF            djnz missiles_init0
 37+  C461 06 04            ld b,4                  ; reset four falling missiles
 38+  C463 21 3C C4         ld hl,missiles_falling
 39+  C466              missiles_init1:
 40+  C466 36 00            ld (hl),0
 41+  C468 23               inc hl
 42+  C469 36 00            ld (hl),0
 43+  C46B 23               inc hl
 44+  C46C 36 00            ld (hl),0
 45+  C46E 23               inc hl
 46+  C46F 10 F5            djnz missiles_init1
 47+  C471 C9               ret
 48+  C472
 49+  C472              ;
 50+  C472              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 51+  C472              ; Processes any already falling missiles
 52+  C472              ;
 53+  C472              missiles_process:
 54+  C472 3A A5 BB         ld a,(player+11)                        ; check if the player was hit by a missile previously
 55+  C475 FE 03            cp 3
 56+  C477 C2 7E C4         jp nz,missiles_process3                 ; if not, continue
 57+  C47A CD BB C5         call missiles_zonkplayer
 58+  C47D C9               ret
 59+  C47E              missiles_process3:
 60+  C47E 3A A8 BB         ld a,(player_location)
 61+  C481 FE 01            cp 1
 62+  C483 C2 F1 C4         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 63+  C486 21 A7 BB         ld hl,player+13
 64+  C489 7E               ld a,(hl)                               ; check if player has collected a diamond
 65+  C48A FE 01            cp 1
 66+  C48C C2 F1 C4         jp nz, missiles_process0                ; don't activate if not
 67+  C48F 21 3B C4         ld hl,missiles_count
 68+  C492 7E               ld a,(hl)                   ; get the missiles count
 69+  C493 3C               inc a
 70+  C494 FE 32            cp 50                                   ; have we reached the count yet
 71+  C496 CA 9D C4         jp z,missiles_process2                 ; if not, don't activate a new one
 72+  C499 77               ld (hl),a                               ; store the updated count, and continue without activating
 73+  C49A C3 F1 C4         jp missiles_process0
 74+  C49D              missiles_process2:
 75+  C49D 36 00            ld (hl),0                               ; zero the counter
 76+  C49F 1E 0C            ld e,12
 77+  C4A1 CD D6 80         call utilities_randomupper              ; get random number from 0 to 11
 78+  C4A4 11 0A 00         ld de,10
 79+  C4A7 CD 3A 80         call utilities_multiply                 ; multiple random number by 10
 80+  C4AA 54 5D            ld de,hl                                ; this is the offset for the random missile
 81+  C4AC DD 21 4B B3      ld ix,level01missiles                   ; load the location of the missile definitions
 82+  C4B0 DD 19            add ix,de                               ; get to location of missile
 83+  C4B2 DD 7E 02         ld a,(ix+2)
 84+  C4B5 FE 00            cp 0
 85+  C4B7 CA C7 C4         jp z,missiles_process1                  ; if this missile isn't active, activate it
 86+  C4BA 11 05 00         ld de,5                                 ; otherwise, check the missile above
 87+  C4BD DD 19            add ix,de
 88+  C4BF DD 7E 02         ld a,(ix+2)
 89+  C4C2 FE 00            cp 0
 90+  C4C4 C2 F1 C4         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 91+  C4C7              missiles_process1:                          ; activate a missile
 92+  C4C7 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
 93+  C4CB DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
 93+  C4CF 46 01
 94+  C4D1 78               ld a,b
 95+  C4D2 ED 5B 70 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
 96+  C4D6 93               sub e
 97+  C4D7 CD D2 A8         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
 98+  C4DA C5               push bc
 99+  C4DB 3E 0C            ld a,12                                 ; inactive missile sprite
100+  C4DD CD 0F A9         call screen_getblock
101+  C4E0 CD 94 A9         call sprites_drawsprite                 ; draw the sprite over the old one
102+  C4E3 C1               pop bc
103+  C4E4 C5               push bc
104+  C4E5 3E 14            ld a,20                                 ; active missile sprite
105+  C4E7 CD 0F A9         call screen_getblock
106+  C4EA CD 94 A9         call sprites_drawsprite                 ; draw the sprite over the old one
107+  C4ED C1               pop bc
108+  C4EE CD 7F C5         call missiles_addmissiletofalling
109+  C4F1              missiles_process0:
110+  C4F1 CD F5 C4         call missiles_fall
111+  C4F4 C9               ret
112+  C4F5
113+  C4F5              ;
114+  C4F5              ; Processes falling missiles
115+  C4F5              ;
116+  C4F5              missiles_fall:
117+  C4F5 06 04            ld b,4              ; number of possible falling missiles
118+  C4F7 DD 21 3C C4      ld ix,missiles_falling
119+  C4FB              missiles_fall0:
120+  C4FB C5               push bc
121+  C4FC DD 7E 02         ld a,(ix+2)
122+  C4FF FE 00            cp 0
123+  C501 CA 5E C5         jp z,missiles_fall1 ; not falling move to next
124+  C504 FE 01            cp 1                ; is this ready to fall
125+  C506 CA 0C C5         jp z, missiles_fall3
126+  C509 C3 78 C5         jp missiles_fall4   ; if not, decrease the countdown
127+  C50C              missiles_fall3:
128+  C50C DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
128+  C510 46 01
129+  C512 CD 89 AA         call sprites_scadd  ; get the memory of the coords into de
130+  C515 14               inc d               ; add 256 to get next row
131+  C516 1A               ld a,(de)           ; get the contents of the next row
132+  C517 FE 00            cp 0
133+  C519 C2 71 C5         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
134+  C51C 3E 14            ld a,20                                 ; active missile sprite
135+  C51E CD 0F A9         call screen_getblock
136+  C521 CD 94 A9         call sprites_drawsprite                 ; draw the sprite over the old one
137+  C524 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
137+  C528 46 01
138+  C52A 0C               inc c               ; move down one pixel
139+  C52B DD 71 00 DD      ld (ix),bc          ; store the new coords
139+  C52F 70 01
140+  C531 3E 14            ld a,20                                 ; active missile sprite
141+  C533 CD 0F A9         call screen_getblock
142+  C536 CD 94 A9         call sprites_drawsprite                 ; draw the sprite
143+  C539 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
143+  C53D 46 01
144+  C53F 79               ld a,c              ; get the vertical coord into a
145+  C540 E6 07            and 7               ; divisible by 8?
146+  C542 FE 00            cp 0
147+  C544 C2 5E C5         jp nz,missiles_fall1   ; if not, carry on
148+  C547 CD C2 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
149+  C54A 3E 43            ld a,67             ; load magenta
150+  C54C CD 1A A9         call screen_setattr
151+  C54F DD 4E 00 DD      ld bc,(ix)
151+  C553 46 01
152+  C555 CD C2 A8         call screen_getcharcoordsfromscreencoords ; get the attr address into de
153+  C558 05               dec b               ; look one square above
154+  C559 3E 46            ld a,70             ; load yellow
155+  C55B CD 1A A9         call screen_setattr
156+  C55E              missiles_fall1:         ; hl at state
157+  C55E DD 4E 00 DD      ld bc,(ix)          ; get coords back
157+  C562 46 01
158+  C564 CD A0 C5         call missiles_checkforplayer ; check for player
159+  C567 DD 23            inc ix
160+  C569 DD 23            inc ix
161+  C56B DD 23            inc ix              ; get to next missile
162+  C56D C1               pop bc
163+  C56E 10 8B            djnz missiles_fall0
164+  C570 C9               ret
165+  C571              missiles_fall2:
166+  C571 DD 36 02 00      ld (ix+2),0
167+  C575 C3 5E C5         jp missiles_fall1   ; rejoin the loop
168+  C578              missiles_fall4:
169+  C578 3D               dec a               ; decrease the countdown
170+  C579 DD 77 02         ld (ix+2),a         ; store back
171+  C57C C3 5E C5         jp missiles_fall1   ; do next missile
172+  C57F
173+  C57F              ;
174+  C57F              ; Adds the missile to the structure that tracks falling missile
175+  C57F              ; Inputs:
176+  C57F              ; bc - coords of missile, c vert
177+  C57F              missiles_addmissiletofalling:
178+  C57F C5               push bc             ; store the coords
179+  C580 11 3C C4         ld de,missiles_falling
180+  C583 06 04            ld b,4              ; number of possible falling missiles
181+  C585              missiles_addmissiletofalling0:
182+  C585 13               inc de
183+  C586 13               inc de              ; move three along to get the state
184+  C587 1A               ld a,(de)           ; load the state
185+  C588 FE 00            cp 0                ; check if this is not falling
186+  C58A C2 9B C5         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
187+  C58D 3E 19            ld a,25
188+  C58F 12               ld (de),a           ; set the state to pre-falling
189+  C590 1B               dec de              ; move back coords
190+  C591 C1               pop bc              ; get back coords
191+  C592 78               ld a,b
192+  C593 12               ld (de),a           ; store the vertical
193+  C594 1B               dec de
194+  C595 79               ld a,c
195+  C596 12               ld (de),a           ; store the horizontal
196+  C597 C5               push bc
197+  C598 C3 9E C5         jp missiles_addmissiletofalling2 ; done
198+  C59B              missiles_addmissiletofalling1:
199+  C59B 13               inc de              ; move memory along to next rock
200+  C59C 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
201+  C59E              missiles_addmissiletofalling2: ; done, return
202+  C59E C1               pop bc              ; to tidy up
203+  C59F C9               ret
204+  C5A0
205+  C5A0              ;
206+  C5A0              ; Checks to see if the missile is hitting a player
207+  C5A0              ; Inputs:
208+  C5A0              ; bc - coords of missile we're checking
209+  C5A0              missiles_checkforplayer:
210+  C5A0 ED 5B 9A BB      ld de,(player)       ; get the player coords
211+  C5A4 7B               ld a,e               ; get the vert coord first
212+  C5A5 91               sub c                ; subtract the missile vertical coord from players
213+  C5A6 FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
214+  C5A8 C0               ret nz               ; if not, hasn't hit
215+  C5A9 7A               ld a,d               ; get the player horiz coord
216+  C5AA 90               sub b                ; subtract missile coord
217+  C5AB C6 07            add 7                ; add max distance
218+  C5AD FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
219+  C5AF DA B3 C5         jp c,missiles_checkforplayer0
220+  C5B2 C9               ret
221+  C5B3              missiles_checkforplayer0:
222+  C5B3 ED 43 48 C4      ld (missiles_killermissile),bc; store the coords of the killer missile
223+  C5B7 CD 94 BC         call player_zonkplayer ; if so, jump out
224+  C5BA C9               ret
225+  C5BB
226+  C5BB              ;
227+  C5BB              ; Player has been hit, so draw text over them and mark as dead
228+  C5BB              ;
229+  C5BB              missiles_zonkplayer:
230+  C5BB CD 82 BC         call player_killplayer      ; mark as dead
231+  C5BE ED 4B 9A BB      ld bc,(player)              ; get player coords
232+  C5C2 CD C2 A8         call screen_getcharcoordsfromscreencoords
233+  C5C5 0D               dec c
234+  C5C6 0D               dec c
235+  C5C7 04               inc b
236+  C5C8 C5               push bc
237+  C5C9 3E 42            ld a,66
238+  C5CB CD 1A A9         call screen_setattr
239+  C5CE 0C               inc c
240+  C5CF CD 1A A9         call screen_setattr
241+  C5D2 0C               inc c
242+  C5D3 CD 1A A9         call screen_setattr
243+  C5D6 0C               inc c
244+  C5D7 CD 1A A9         call screen_setattr
245+  C5DA 0C               inc c
246+  C5DB CD 1A A9         call screen_setattr
247+  C5DE C1               pop bc
248+  C5DF ED 5B 70 A7      ld de,(screen_offset)
249+  C5E3 78               ld a,b
250+  C5E4 93               sub e
251+  C5E5 47               ld b,a                      ; subtract the offset
252+  C5E6 04               inc b
253+  C5E7 04               inc b                       ; add two for the score rows
254+  C5E8 ED 43 B6 84      ld (string_zonk),bc         ; set coords of string
255+  C5EC 21 B6 84         ld hl,string_zonk
256+  C5EF CD BE 84         call string_print
257+  C5F2 06 14            ld b,20
258+  C5F4 CD 82 80         call utilities_pauseforframes ; pause
259+  C5F7 C9               ret
260+  C5F8
# file closed: game/missiles.asm
 46   C5F8                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  C5F8              ;
  2+  C5F8              ; Timer for deciding how fast the trap withdraws
  3+  C5F8              ;
  4+  C5F8              thepit_timer:
  5+  C5F8 00               defb 0
  6+  C5F9
  7+  C5F9              ;
  8+  C5F9              ; Ticks for the trap state. Will count to 3 then reset
  9+  C5F9              ;
 10+  C5F9              thepit_trapcount:
 11+  C5F9 00               defb 0
 12+  C5FA
 13+  C5FA              ;
 14+  C5FA              ; The horizontal coordinate of the current pit trap
 15+  C5FA              ;
 16+  C5FA              thepit_trapcoord:
 17+  C5FA 08               defb 8
 18+  C5FB
 19+  C5FB              ;
 20+  C5FB              ; Initialises the pit
 21+  C5FB              ;
 22+  C5FB              thepit_init:
 23+  C5FB 21 FA C5         ld hl,thepit_trapcoord
 24+  C5FE 36 08            ld (hl),8
 25+  C600 21 F9 C5         ld hl,thepit_trapcount
 26+  C603 36 00            ld (hl),0
 27+  C605 C9               ret
 28+  C606
 29+  C606              ;
 30+  C606              ; Performs per frame processing on the pit room
 31+  C606              ;
 32+  C606              thepit_process:
 33+  C606 3A A8 BB         ld a,(player_location)
 34+  C609 FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 35+  C60B C2 67 C6         jp nz,thepit_process0
 36+  C60E ED 4B 9A BB      ld bc,(player)                  ; get the player's coords to check if about to fall
 37+  C612 3E 08            ld a,8
 38+  C614 81               add a,c
 39+  C615 4F               ld c,a                          ; look at the square underneath
 40+  C616 CD C2 A8         call screen_getcharcoordsfromscreencoords ; get the cell coords
 41+  C619 CD 50 A9         call screen_ischarempty
 42+  C61C FE 01            cp 1                            ; check if this is 1=empty
 43+  C61E CA 68 C6         jp z,thepit_process2
 44+  C621 3A F8 C5         ld a,(thepit_timer)             ; get the timer
 45+  C624 3C               inc a
 46+  C625 32 F8 C5         ld (thepit_timer),a             ; store
 47+  C628 FE 02            cp 2                           ; have we reached the trigger?
 48+  C62A C2 67 C6         jp nz, thepit_process0          ; no need to do anything
 49+  C62D 3E 00            ld a,0
 50+  C62F 32 F8 C5         ld (thepit_timer),a             ; zero the timer and process
 51+  C632 3A F9 C5         ld a,(thepit_trapcount)         ; get the current count
 52+  C635 3C               inc a
 53+  C636 32 F9 C5         ld (thepit_trapcount),a         ; reset the trap count
 54+  C639 FE 04            cp 4                            ; do we need to begin another character?
 55+  C63B C2 4F C6         jp nz,thepit_process1           ; if not, draw as normal
 56+  C63E 3E 00            ld a,0
 57+  C640 32 F9 C5         ld (thepit_trapcount),a         ; reset the trap count
 58+  C643 3A FA C5         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 59+  C646 FE 02            cp 2
 60+  C648 CA 67 C6         jp z,thepit_process0
 61+  C64B 3D               dec a
 62+  C64C 32 FA C5         ld (thepit_trapcoord),a         ; store the reduced coord
 63+  C64F
 64+  C64F              thepit_process1:                    ; draw the trapdoor in current position
 65+  C64F 3A FA C5         ld a,(thepit_trapcoord)
 66+  C652 FE 02            cp 2
 67+  C654 CA 67 C6         jp z, thepit_process0           ; don't process outside of the pit
 68+  C657 4F               ld c,a
 69+  C658 06 0A            ld b,10                         ; vertical coord will always be the same
 70+  C65A 3A F9 C5         ld a,(thepit_trapcount)         ; get the trap count
 71+  C65D 5F               ld e,a                          ; store in e
 72+  C65E 3E 16            ld a,22                         ; 21 is full trapdoor
 73+  C660 83               add a,e
 74+  C661 CD 0F A9         call screen_getblock
 75+  C664 CD EC A8         call screen_showchar            ; show the char
 76+  C667
 77+  C667              thepit_process0:
 78+  C667 C9               ret
 79+  C668              thepit_process2:
 80+  C668 CD 9A BC         call player_pitkillplayer
 81+  C66B C9               ret
 82+  C66C
# file closed: game/thepit.asm
 47   C66C                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  C66C
  2+  C66C              ;
  3+  C66C              ; Where the monster currently is
  4+  C66C              ;
  5+  C66C              monster_currentcoords:
  6+  C66C 00 00            defb 0,0
  7+  C66E
  8+  C66E              ;
  9+  C66E              ; The start coords of the monster
 10+  C66E              ;
 11+  C66E              monster_initcoords:
 12+  C66E 70 1B            defb 112,27
 13+  C670
 14+  C670              ;
 15+  C670              ; Store the memory location of the current jump position
 16+  C670              ;
 17+  C670              monster_jumppos:
 18+  C670 00 00            defb 0,0
 19+  C672
 20+  C672              ;
 21+  C672              ; The jump table for the monster.
 22+  C672              ;
 23+  C672              monster_jumptable:
 24+  C672 FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  C676 02 02 02 02
 24+  C67A 02 02 01 01
 24+  C67E 01 01 01 01
 24+  C682 FF
 25+  C683
 26+  C683              ;
 27+  C683              ; The vertical direction: 0 up, 1 down
 28+  C683              ;
 29+  C683              monster_jumpdirectionvert:
 30+  C683 00               defb 0
 31+  C684
 32+  C684              ;
 33+  C684              ; The horiz direction: 0 right, 1 left
 34+  C684              ;
 35+  C684              monster_jumpdirectionhoriz:
 36+  C684 00               defb 0
 37+  C685
 38+  C685              ;
 39+  C685              ; Frame offset, 0 or 32
 40+  C685              ;
 41+  C685              monster_frameoffset:
 42+  C685 00               defb 0
 43+  C686
 44+  C686              ;
 45+  C686              ; Monster tick
 46+  C686              ;
 47+  C686              monster_tick:
 48+  C686 00               defb 0
 49+  C687
 50+  C687              ;
 51+  C687              ; Initialises the pit monster
 52+  C687              ;
 53+  C687              monster_init:
 54+  C687 ED 4B 6E C6      ld bc,(monster_initcoords)              ; load the initial coords
 55+  C68B ED 43 6C C6      ld (monster_currentcoords),bc           ; save in current coords
 56+  C68F 21 73 C6         ld hl,monster_jumptable+1
 57+  C692 22 70 C6         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 58+  C695 3E 00            ld a,0
 59+  C697 32 83 C6         ld (monster_jumpdirectionvert),a        ; going up
 60+  C69A 32 85 C6         ld (monster_frameoffset),a
 61+  C69D 32 86 C6         ld (monster_tick),a
 62+  C6A0 CD 20 C7         call monster_draw                       ; the monster
 63+  C6A3 C9               ret
 64+  C6A4
 65+  C6A4              ;
 66+  C6A4              ; Animate the monster
 67+  C6A4              ;
 68+  C6A4              monster_process:
 69+  C6A4 3A 86 C6         ld a,(monster_tick)                     ; check if we should draw this frame
 70+  C6A7 FE 01            cp 1
 71+  C6A9 CA B1 C6         jp z,monster_process6
 72+  C6AC 3C               inc a
 73+  C6AD 32 86 C6         ld (monster_tick),a                     ; increase the tick and continue
 74+  C6B0 C9               ret
 75+  C6B1              monster_process6:
 76+  C6B1 3E 00            ld a,0
 77+  C6B3 32 86 C6         ld (monster_tick),a                     ; zero the tick
 78+  C6B6 CD 20 C7         call monster_draw                       ; overwrite the old sprite
 79+  C6B9 3A 85 C6         ld a,(monster_frameoffset)              ; get the anim frame offset
 80+  C6BC EE 20            xor 32                                  ; flip between 0 and 32
 81+  C6BE 32 85 C6         ld (monster_frameoffset),a              ; store
 82+  C6C1 ED 4B 6C C6      ld bc,(monster_currentcoords)           ; get the current coords
 83+  C6C5 2A 70 C6         ld hl,(monster_jumppos)                 ; get the position in the jump table
 84+  C6C8 56               ld d,(hl)                               ; get the jump modifier
 85+  C6C9 3A 83 C6         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 86+  C6CC FE 00            cp 0                                    ; if 0, going up, so dec vert
 87+  C6CE C2 D7 C6         jp nz,monster_process0
 88+  C6D1 79               ld a,c
 89+  C6D2 92               sub d
 90+  C6D3 23               inc hl                                  ; move forward a jump pos
 91+  C6D4 C3 DA C6         jp monster_process1
 92+  C6D7              monster_process0:
 93+  C6D7 79               ld a,c                                   ; going down so inc c
 94+  C6D8 82               add a,d
 95+  C6D9 2B               dec hl                                  ; move back a jump pos
 96+  C6DA              monster_process1:
 97+  C6DA 4F               ld c,a                                  ; get the vertical coord back
 98+  C6DB 7E               ld a,(hl)                               ; check the next jump pos
 99+  C6DC FE FF            cp 255                                  ; if 255 reverse
100+  C6DE CA E7 C6         jp z,monster_process3
101+  C6E1 22 70 C6         ld (monster_jumppos),hl                 ; store the new pos
102+  C6E4 C3 EF C6         jp monster_process2                     ; keep going
103+  C6E7              monster_process3:
104+  C6E7 3A 83 C6         ld a,(monster_jumpdirectionvert)        ; get the direction
105+  C6EA EE 01            xor 1                                   ; flip it
106+  C6EC 32 83 C6         ld (monster_jumpdirectionvert),a        ; store it
107+  C6EF              monster_process2:
108+  C6EF 3A 84 C6         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
109+  C6F2 FE 00            cp 0                                    ; is it right?
110+  C6F4 C2 09 C7         jp nz,monster_process4
111+  C6F7 04               inc b                                   ; 1 pixel right
112+  C6F8 78               ld a,b
113+  C6F9 FE 38            cp 56                                   ; reached the edge of the pit?
114+  C6FB C2 18 C7         jp nz,monster_process5
115+  C6FE 3A 84 C6         ld a,(monster_jumpdirectionhoriz)
116+  C701 EE 01            xor 1
117+  C703 32 84 C6         ld (monster_jumpdirectionhoriz),a       ; flip direction
118+  C706 C3 18 C7         jp monster_process5
119+  C709              monster_process4:
120+  C709 05               dec b                                   ; 1 pixel left
121+  C70A 78               ld a,b
122+  C70B FE 18            cp 24                                   ; reached the edge of the pit?
123+  C70D C2 18 C7         jp nz,monster_process5
124+  C710 3A 84 C6         ld a,(monster_jumpdirectionhoriz)
125+  C713 EE 01            xor 1
126+  C715 32 84 C6         ld (monster_jumpdirectionhoriz),a       ; flip direction
127+  C718              monster_process5:
128+  C718 ED 43 6C C6      ld (monster_currentcoords),bc           ; store the new vertical coords
129+  C71C CD 20 C7         call monster_draw                       ; finally, draw the monster
130+  C71F C9               ret
131+  C720
132+  C720              ;
133+  C720              ; Draw the monster at the current location
134+  C720              ;
135+  C720              monster_draw:
136+  C720 ED 4B 6C C6      ld bc,(monster_currentcoords)
137+  C724 3A 85 C6         ld a,(monster_frameoffset)
138+  C727 11 00 00         ld de,0
139+  C72A 5F               ld e,a
140+  C72B 21 54 B6         ld hl,monster_sprite                    ; load the first frame
141+  C72E 19               add hl,de
142+  C72F CD F2 A9         call sprites_draw2by2sprite
143+  C732 C9               ret
# file closed: game/monster.asm
 48   C733                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  C733
  2+  C733              ;
  3+  C733              ; Array of robot states
  4+  C733              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  C733              robots_robots:
  6+  C733 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  C737 00 00 00
  7+  C73A 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  C73E 00 00 00
  8+  C741 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  C745 00 00 00
  9+  C748 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  C74C 00 00 00
 10+  C74F 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  C753 00 00 00
 11+  C756
 12+  C756              robots_initcoords:
 13+  C756 18 E8            defb 24,232
 14+  C758
 15+  C758              ;
 16+  C758              ; When this reaches zero, spawn a new robot
 17+  C758              ;
 18+  C758              robots_spawntimer:
 19+  C758 FA               defb 250
 20+  C759
 21+  C759              ;
 22+  C759              ; When this reaches max, change the anim frame
 23+  C759              ;
 24+  C759              robots_animtimer:
 25+  C759 00               defb 0
 26+  C75A
 27+  C75A              ;
 28+  C75A              ; When this reaches max, change move the robot
 29+  C75A              ;
 30+  C75A              robots_movetimer:
 31+  C75A 00               defb 0
 32+  C75B
 33+  C75B
 34+  C75B              ;
 35+  C75B              ; The number of robots active
 36+  C75B              ;
 37+  C75B              robots_numberactive:
 38+  C75B 00               defb 0
 39+  C75C
 40+  C75C              ;
 41+  C75C              ; Tracks which directions a robot can move
 42+  C75C              ; up,down,left,right
 43+  C75C              robots_canmovedirections:
 44+  C75C 00 00 00 00      defb 0,0,0,0
 45+  C760
 46+  C760              ;
 47+  C760              ; The current robot speed
 48+  C760              ;
 49+  C760              robots_robotspeed:
 50+  C760 02               defb 2
 51+  C761
 52+  C761              ;
 53+  C761              ; The current max robots
 54+  C761              ;
 55+  C761              robots_robotsmax:
 56+  C761 02               defb 2
 57+  C762
 58+  C762              ;
 59+  C762              ; Initialises the robots
 60+  C762              ;
 61+  C762              robots_init:
 62+  C762 06 23            ld b,35
 63+  C764 DD 21 33 C7      ld ix,robots_robots
 64+  C768              robots_init0:
 65+  C768 DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 66+  C76C DD 23            inc ix
 67+  C76E 10 F8            djnz robots_init0
 68+  C770 3E 00            ld a,0
 69+  C772 32 5B C7         ld (robots_numberactive),a
 70+  C775 3E FA            ld a,250
 71+  C777 32 58 C7         ld (robots_spawntimer),a
 72+  C77A                  ; Self writing code
 73+  C77A                  ; Robot speed
 74+  C77A 3A 60 C7         ld a,(robots_robotspeed)
 75+  C77D 32 FE C7         ld (robots_process7+1),a
 76+  C780 3C               inc a
 77+  C781 32 26 C8         ld (robots_process6+1),a
 78+  C784                  ; Robots max
 79+  C784 3A 61 C7         ld a,(robots_robotsmax)
 80+  C787 32 92 C7         ld (robots_spawn+1),a
 81+  C78A 32 D0 C7         ld (robots_process8+1),a
 82+  C78D 32 EC C7         ld (robots_process0+1),a
 83+  C790 C9               ret
 84+  C791
 85+  C791              ;
 86+  C791              ; Spawns a new robot
 87+  C791              ; Inputs:
 88+  C791              ; ix - pointer to start of robot array entry
 89+  C791              ;
 90+  C791              robots_spawn:
 91+  C791 06 03            ld b,3
 92+  C793 DD 21 33 C7      ld ix,robots_robots
 93+  C797              robots_spawn0:
 94+  C797 DD 7E 02         ld a,(ix+2)                 ; get the state
 95+  C79A FE 00            cp 0
 96+  C79C C2 B8 C7         jp nz,robots_spawn1         ; if already active, move on
 97+  C79F ED 4B 56 C7      ld bc,(robots_initcoords)
 98+  C7A3 DD 71 00 DD      ld (ix),bc
 98+  C7A7 70 01
 99+  C7A9 DD 36 02 01      ld (ix+2),1
100+  C7AD 3A 5B C7         ld a,(robots_numberactive)
101+  C7B0 3C               inc a
102+  C7B1 32 5B C7         ld (robots_numberactive),a  ; increase the number active
103+  C7B4 CD 3E CA         call robots_draw            ; draw initial frame
104+  C7B7 C9               ret
105+  C7B8              robots_spawn1:
106+  C7B8 11 07 00         ld de,7
107+  C7BB DD 19            add ix,de
108+  C7BD 10 D8            djnz robots_spawn0
109+  C7BF C9               ret
110+  C7C0              ;
111+  C7C0              ; Kills robot
112+  C7C0              ; Inputs:
113+  C7C0              ; ix - pointer to start of robot array entry
114+  C7C0              ;
115+  C7C0              robots_kill:
116+  C7C0 3A 5B C7         ld a,(robots_numberactive)
117+  C7C3 3D               dec a
118+  C7C4 32 5B C7         ld (robots_numberactive),a
119+  C7C7 DD 36 02 00      ld (ix+2),0                     ; set to inactive
120+  C7CB C9               ret
121+  C7CC
122+  C7CC              ;
123+  C7CC              ; Processes the robots
124+  C7CC              ;
125+  C7CC              robots_process:
126+  C7CC 3A 5B C7         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
127+  C7CF              robots_process8:
128+  C7CF FE 03            cp 3                                    ; 3 is the maximum
129+  C7D1 CA EB C7         jp z,robots_process0                    ; if already three, nothing to do
130+  C7D4 3A 58 C7         ld a,(robots_spawntimer)                ; now check the spawn timer
131+  C7D7 FE 00            cp 0
132+  C7D9 C2 E7 C7         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
133+  C7DC 3E FA            ld a,250
134+  C7DE 32 58 C7         ld (robots_spawntimer),a                ; reset the spawn timer
135+  C7E1 CD 91 C7         call robots_spawn                       ; spawn a robot
136+  C7E4 C3 EB C7         jp robots_process0                      ; carry on
137+  C7E7              robots_process1:
138+  C7E7 3D               dec a
139+  C7E8 32 58 C7         ld (robots_spawntimer),a                ; decrease the spawn timer and store
140+  C7EB              robots_process0:
141+  C7EB 06 03            ld b,3                                  ; max number of robots
142+  C7ED DD 21 33 C7      ld ix, robots_robots                    ; point ix at the robot array
143+  C7F1              robots_process2:
144+  C7F1 C5               push bc
145+  C7F2 DD 7E 02         ld a,(ix+2)                             ; check the state
146+  C7F5 FE 00            cp 0
147+  C7F7 CA 0B C8         jp z,robots_process3                    ; if not active, move on
148+  C7FA 3A 5A C7         ld a,(robots_movetimer)
149+  C7FD              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
150+  C7FD FE 04            cp 4
151+  C7FF C2 0B C8         jp nz,robots_process3                   ; can we move this frame
152+  C802 CD 3E CA         call robots_draw                        ; draw over existing
153+  C805 CD 30 C8         call robots_move                        ; move the robot
154+  C808 CD 3E CA         call robots_draw                        ; draw the new robot
155+  C80B              robots_process3:
156+  C80B C1               pop bc
157+  C80C 11 07 00         ld de,7
158+  C80F DD 19            add ix,de
159+  C811 10 DE            djnz robots_process2
160+  C813 3A 59 C7         ld a,(robots_animtimer)
161+  C816 3C               inc a
162+  C817 FE 08            cp 8
163+  C819 C2 1E C8         jp nz,robots_process4
164+  C81C 3E 00            ld a,0                                  ; reset if we reached max
165+  C81E              robots_process4:
166+  C81E 32 59 C7         ld (robots_animtimer),a
167+  C821 3A 5A C7         ld a,(robots_movetimer)                 ; increment the robot move timer
168+  C824 3C               inc a
169+  C825              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
170+  C825 FE 05            cp 5                                    ; there is another reference to this number above
171+  C827 C2 2C C8         jp nz,robots_process5
172+  C82A 3E 00            ld a,0
173+  C82C              robots_process5:
174+  C82C 32 5A C7         ld (robots_movetimer),a
175+  C82F
176+  C82F C9               ret
177+  C830
178+  C830              ;
179+  C830              ; Moves a robot
180+  C830              ; Inputs:
181+  C830              ; ix - points to first byte of robot in array
182+  C830              robots_move:
183+  C830 3A 59 C7         ld a,(robots_animtimer)                 ; get the anim timer
184+  C833 FE 07            cp 7                                    ; compare with 8
185+  C835 C2 48 C8         jp nz,robots_move1                       ; if even, don't increment frame
186+  C838 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
187+  C83B 06 08            ld b,8
188+  C83D 80               add a,b                                 ; add to anim frame
189+  C83E FE 20            cp 32
190+  C840 C2 45 C8         jp nz,robots_move0                      ; if not 32, then just store
191+  C843 3E 00            ld a,0                                  ; otherwise, reset
192+  C845              robots_move0:
193+  C845 DD 77 04         ld (ix+4),a                             ; store
194+  C848              robots_move1:
195+  C848 DD 7E 05         ld a,(ix+5)
196+  C84B FE 00            cp 0                                    ; are we automoving
197+  C84D CA 56 C8         jp z,robots_move2                       ; if not, keep directions
198+  C850 CD 5E C8         call robots_automove
199+  C853 C3 5A C8         jp robots_move3
200+  C856              robots_move2:
201+  C856 CD 91 C8         call robots_checkdirectionsandmove
202+  C859 C9               ret
203+  C85A              robots_move3:
204+  C85A CD 5F CA         call robots_checkforplayer              ; check to see if we collided with a player
205+  C85D C9               ret
206+  C85E
207+  C85E              ;
208+  C85E              ; Processes automove
209+  C85E              ; Inputs:
210+  C85E              ; ix - points to the current robot
211+  C85E              ; a - number of frames left to move
212+  C85E              robots_automove:
213+  C85E 3D               dec a
214+  C85F DD 77 05         ld (ix+5),a                         ; store the decreased frames
215+  C862 DD 4E 00 DD      ld bc,(ix)                          ; get coords
215+  C866 46 01
216+  C868 DD 7E 06         ld a,(ix+6)                         ; get the direction
217+  C86B FE 00            cp 0                                ; left
218+  C86D CA 7E C8         jp z,robots_automove1
219+  C870 FE 02            cp 2                                ; up
220+  C872 CA 82 C8         jp z,robots_automove3
221+  C875 FE 03            cp 3                                ; down
222+  C877 CA 86 C8         jp z,robots_automove4
223+  C87A 04               inc b                               ; right
224+  C87B C3 8A C8         jp robots_automove2
225+  C87E              robots_automove1:
226+  C87E 05               dec b
227+  C87F C3 8A C8         jp robots_automove2
228+  C882              robots_automove3:
229+  C882 0D               dec c
230+  C883 C3 8A C8         jp robots_automove2
231+  C886              robots_automove4:
232+  C886 0C               inc c
233+  C887 C3 8A C8         jp robots_automove2
234+  C88A              robots_automove2:
235+  C88A DD 71 00 DD      ld (ix),bc
235+  C88E 70 01
236+  C890 C9               ret
237+  C891
238+  C891              ;
239+  C891              ; Checks if a robot can move in all directions, then picks one and moves there.
240+  C891              ; This looks complicated, but really what it does is:
241+  C891              ; 1) Look at the current direction
242+  C891              ; 2) Randomly determine which orthoganal direction check first
243+  C891              ; 3) If orthogonal can't be moved, keep going in direction we're going
244+  C891              ; 4) Otherwise, back the way we came
245+  C891              ; Inputs:
246+  C891              ; ix - points to the current robot
247+  C891              ;
248+  C891              robots_checkdirectionsandmove:
249+  C891 DD 7E 06         ld a,(ix+6)                 ; get the direction
250+  C894 FE 00            cp 0                        ; left
251+  C896 C2 BD C8         jp nz,robots_checkdirectionsandmove0
252+  C899                  ; random check
253+  C899 CD 90 BB         call game_getcurrentframe
254+  C89C E6 01            and 1                       ; odd or even
255+  C89E CA AA C8         jp z,robots_checkdirectionsandmove3
256+  C8A1 CD 43 C9         call robots_checkupthendown ; prefer up over down
257+  C8A4 FE 01            cp 1
258+  C8A6 C8               ret z
259+  C8A7 C3 B0 C8         jp robots_checkdirectionsandmove4
260+  C8AA              robots_checkdirectionsandmove3:
261+  C8AA CD 39 C9         call robots_checkdownthenup ; prefer down over up
262+  C8AD FE 01            cp 1
263+  C8AF C8               ret z
264+  C8B0              robots_checkdirectionsandmove4:
265+  C8B0                  ; check left
266+  C8B0 CD C7 C9         call robots_checkleftandmove
267+  C8B3 FE 01            cp 1
268+  C8B5 C8               ret z                       ; if we moved, don't check again
269+  C8B6                  ; check right
270+  C8B6 CD 00 CA         call robots_checkrightandmove
271+  C8B9 FE 01            cp 1
272+  C8BB C8               ret z                       ; if we moved, don't check again
273+  C8BC                  ; if we're here and haven't moved...
274+  C8BC C9               ret
275+  C8BD              robots_checkdirectionsandmove0
276+  C8BD FE 01            cp 1                        ; right
277+  C8BF C2 E6 C8         jp nz,robots_checkdirectionsandmove1
278+  C8C2                  ; ALREADY MOVING RIGHT
279+  C8C2                  ; random check
280+  C8C2 CD 90 BB         call game_getcurrentframe
281+  C8C5 E6 01            and 1                       ; odd or even
282+  C8C7 CA D3 C8         jp z,robots_checkdirectionsandmove5
283+  C8CA CD 39 C9         call robots_checkdownthenup ; prefer down over up
284+  C8CD FE 01            cp 1
285+  C8CF C8               ret z
286+  C8D0 C3 D9 C8         jp robots_checkdirectionsandmove6
287+  C8D3              robots_checkdirectionsandmove5:
288+  C8D3 CD 43 C9         call robots_checkupthendown ; prefer down over up
289+  C8D6 FE 01            cp 1
290+  C8D8 C8               ret z
291+  C8D9              robots_checkdirectionsandmove6:
292+  C8D9                  ; check right
293+  C8D9 CD 00 CA         call robots_checkrightandmove
294+  C8DC FE 01            cp 1
295+  C8DE C8               ret z                       ; if we moved, don't check again
296+  C8DF                  ; check left
297+  C8DF CD C7 C9         call robots_checkleftandmove
298+  C8E2 FE 01            cp 1
299+  C8E4 C8               ret z                       ; if we moved, don't check again
300+  C8E5                  ; if we're here and haven't moved...
301+  C8E5 C9               ret
302+  C8E6              robots_checkdirectionsandmove1
303+  C8E6 FE 02            cp 2                        ; up
304+  C8E8 C2 0F C9         jp nz,robots_checkdirectionsandmove2
305+  C8EB                  ; ALREADY MOVING UP
306+  C8EB                  ; random check
307+  C8EB CD 90 BB         call game_getcurrentframe
308+  C8EE E6 01            and 1                       ; odd or even
309+  C8F0 CA FC C8         jp z,robots_checkdirectionsandmove7
310+  C8F3 CD 59 C9         call robots_checkleftthenright ; prefer left over right
311+  C8F6 FE 01            cp 1
312+  C8F8 C8               ret z
313+  C8F9 C3 02 C9         jp robots_checkdirectionsandmove8
314+  C8FC              robots_checkdirectionsandmove7:
315+  C8FC CD 4F C9         call robots_checkrightthenleft ; prefer right over left
316+  C8FF FE 01            cp 1
317+  C901 C8               ret z
318+  C902              robots_checkdirectionsandmove8:
319+  C902                  ; check up
320+  C902 CD 65 C9         call robots_checkupandmove
321+  C905 FE 01            cp 1
322+  C907 C8               ret z                       ; if we moved, don't check again
323+  C908                  ; check down
324+  C908 CD 9A C9         call robots_checkdownandmove
325+  C90B FE 01            cp 1
326+  C90D C8               ret z                       ; if we moved, don't check again
327+  C90E                  ; if we're here and haven't moved...
328+  C90E C9               ret
329+  C90F              robots_checkdirectionsandmove2
330+  C90F                  ; ALREADY MOVING DOWN
331+  C90F                  ; random check
332+  C90F CD 90 BB         call game_getcurrentframe
333+  C912 E6 01            and 1                       ; odd or even
334+  C914 CA 20 C9         jp z,robots_checkdirectionsandmove9
335+  C917 CD 4F C9         call robots_checkrightthenleft ; prefer right over left
336+  C91A FE 01            cp 1
337+  C91C C8               ret z
338+  C91D C3 26 C9         jp robots_checkdirectionsandmove10
339+  C920              robots_checkdirectionsandmove9:
340+  C920 CD 59 C9         call robots_checkleftthenright ; prefer left over right
341+  C923 FE 01            cp 1
342+  C925 C8               ret z
343+  C926              robots_checkdirectionsandmove10:
344+  C926                  ; check down
345+  C926 CD 9A C9         call robots_checkdownandmove
346+  C929 FE 01            cp 1
347+  C92B C8               ret z                       ; if we moved, don't check again
348+  C92C                  ; check right first
349+  C92C CD 00 CA         call robots_checkrightandmove
350+  C92F FE 01            cp 1
351+  C931 C8               ret z                       ; if we moved, don't check again
352+  C932                  ; check up
353+  C932 CD 65 C9         call robots_checkupandmove
354+  C935 FE 01            cp 1
355+  C937 C8               ret z                       ; if we moved, don't check again
356+  C938                  ; if we're here and haven't moved...
357+  C938 C9               ret
358+  C939
359+  C939              ;
360+  C939              ; Different orders of checking directions, for pseudo random motion
361+  C939              ;
362+  C939              robots_checkdownthenup:
363+  C939                  ; check down
364+  C939 CD 9A C9         call robots_checkdownandmove
365+  C93C FE 01            cp 1
366+  C93E C8               ret z                       ; if we moved, don't check again
367+  C93F                  ; check up
368+  C93F CD 65 C9         call robots_checkupandmove
369+  C942 C9               ret
370+  C943
371+  C943              robots_checkupthendown:
372+  C943                  ; check up
373+  C943 CD 65 C9         call robots_checkupandmove
374+  C946 FE 01            cp 1
375+  C948 C8               ret z
376+  C949                  ; check down
377+  C949 CD 9A C9         call robots_checkdownandmove
378+  C94C FE 01            cp 1
379+  C94E C9               ret
380+  C94F              robots_checkrightthenleft:
381+  C94F                  ; check right
382+  C94F CD 00 CA         call robots_checkrightandmove
383+  C952 FE 01            cp 1
384+  C954 C8               ret z                       ; if we moved, don't check again
385+  C955                  ; check left
386+  C955 CD C7 C9         call robots_checkleftandmove
387+  C958 C9               ret
388+  C959
389+  C959              robots_checkleftthenright:
390+  C959                  ; check left
391+  C959 CD C7 C9         call robots_checkleftandmove
392+  C95C FE 01            cp 1
393+  C95E C8               ret z
394+  C95F                  ; check right
395+  C95F CD 00 CA         call robots_checkrightandmove
396+  C962 FE 01            cp 1
397+  C964 C9               ret
398+  C965
399+  C965              ;
400+  C965              ; Checks up for movement
401+  C965              ; Outputs:
402+  C965              ; a - 1 if have moved
403+  C965              robots_checkupandmove:
404+  C965                  ; check above
405+  C965 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
405+  C969 46 01
406+  C96B 79               ld a,c
407+  C96C FE 20            cp 32
408+  C96E D8               ret c
409+  C96F CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
410+  C972 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
411+  C974 11 20 00         ld de,32
412+  C977 ED 52            sbc hl,de                       ; memory location of line above now in hl
413+  C979 7E               ld a,(hl)                       ; get the contents of the line
414+  C97A FE 00            cp 0
415+  C97C C2 97 C9         jp nz,robots_checkupandmove0    ; can't move here so return
416+  C97F DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
416+  C983 46 01
417+  C985 0D               dec c                       ; move up
418+  C986 DD 71 00 DD      ld (ix),bc
418+  C98A 70 01
419+  C98C DD 36 06 02      ld (ix+6),2
420+  C990 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
421+  C994 3E 01            ld a,1
422+  C996 C9               ret
423+  C997              robots_checkupandmove0:
424+  C997 3E 00            ld a,0
425+  C999 C9               ret
426+  C99A
427+  C99A              ;
428+  C99A              ; Checks down for movement
429+  C99A              ; Outputs:
430+  C99A              ; a - 1 if have moved
431+  C99A              robots_checkdownandmove:
432+  C99A                  ; check below
433+  C99A DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
433+  C99E 46 01
434+  C9A0 CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
435+  C9A3 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
436+  C9A5 24               inc h                       ; memory location of cell beneath now in hl
437+  C9A6 7E               ld a,(hl)                       ; get the contents of the line
438+  C9A7 FE 00            cp 0
439+  C9A9 C2 C4 C9         jp nz,robots_checkdownandmove0    ; can't move here so return
440+  C9AC DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
440+  C9B0 46 01
441+  C9B2 0C               inc c                       ; move up
442+  C9B3 DD 71 00 DD      ld (ix),bc
442+  C9B7 70 01
443+  C9B9 DD 36 06 03      ld (ix+6),3
444+  C9BD DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
445+  C9C1 3E 01            ld a,1
446+  C9C3 C9               ret
447+  C9C4              robots_checkdownandmove0:
448+  C9C4 3E 00            ld a,0
449+  C9C6 C9               ret
450+  C9C7
451+  C9C7              ;
452+  C9C7              ; Checks left for movement
453+  C9C7              ; Outputs:
454+  C9C7              ; a - 1 if have moved
455+  C9C7              robots_checkleftandmove:
456+  C9C7                  ; check below
457+  C9C7 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
457+  C9CB 46 01
458+  C9CD CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
459+  C9D0 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
460+  C9D2 78               ld a,b
461+  C9D3 06 08            ld b,8
462+  C9D5 90               sub b                           ; move one cell left
463+  C9D6 47               ld b,a
464+  C9D7 2B               dec hl                          ; memory location of cell to the right now in hl
465+  C9D8 CD 45 B9         call movement_spaceisempty       ; check space is empty
466+  C9DB 7B               ld a,e                          ; check space empty flag
467+  C9DC FE 00            cp 0
468+  C9DE CA FD C9         jp z,robots_checkleftandmove0    ; if zero can't move
469+  C9E1 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
469+  C9E5 46 01
470+  C9E7 05               dec b
471+  C9E8 DD 71 00 DD      ld (ix),bc
471+  C9EC 70 01
472+  C9EE DD 36 06 00      ld (ix+6),0
473+  C9F2 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
474+  C9F6 DD 36 03 00      ld (ix+3),0                 ; set to right
475+  C9FA 3E 01            ld a,1
476+  C9FC C9               ret
477+  C9FD              robots_checkleftandmove0:
478+  C9FD 3E 00            ld a,0
479+  C9FF C9               ret
480+  CA00
481+  CA00              ;
482+  CA00              ; Checks right for movement
483+  CA00              ; Outputs:
484+  CA00              ; a - 1 if have moved
485+  CA00              robots_checkrightandmove:
486+  CA00                  ; check below
487+  CA00 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
487+  CA04 46 01
488+  CA06 78               ld a,b
489+  CA07 FE E8            cp 232
490+  CA09 CA 3B CA         jp z,robots_checkrightandmove0  ; can't move if at edge
491+  CA0C CD 89 AA         call sprites_scadd              ; get the memory location of cell into de
492+  CA0F 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
493+  CA11 3E 08            ld a,8
494+  CA13 80               add b                           ; move one cell right
495+  CA14 47               ld b,a
496+  CA15 23               inc hl                          ; memory location of cell to the right now in hl
497+  CA16 CD 45 B9         call movement_spaceisempty       ; check space is empty
498+  CA19 7B               ld a,e                          ; check space empty flag
499+  CA1A FE 00            cp 0
500+  CA1C CA 3B CA         jp z,robots_checkrightandmove0    ; if zero can't move
501+  CA1F DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
501+  CA23 46 01
502+  CA25 04               inc b
503+  CA26 DD 71 00 DD      ld (ix),bc
503+  CA2A 70 01
504+  CA2C DD 36 06 01      ld (ix+6),1
505+  CA30 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
506+  CA34 DD 36 03 01      ld (ix+3),1                 ; set to right
507+  CA38 3E 01            ld a,1
508+  CA3A C9               ret
509+  CA3B              robots_checkrightandmove0:
510+  CA3B 3E 00            ld a,0
511+  CA3D C9               ret
512+  CA3E
513+  CA3E              ;
514+  CA3E              ; Draws a robot
515+  CA3E              ; Inputs:
516+  CA3E              ; ix - points to first byte of robot in array
517+  CA3E              robots_draw:
518+  CA3E DD 4E 00 DD      ld bc,(ix)
518+  CA42 46 01
519+  CA44 21 94 B6         ld hl,robot_sprite                      ; set to the robot sprite
520+  CA47 DD 7E 03         ld a,(ix+3)                             ; get the direction
521+  CA4A FE 00            cp 0
522+  CA4C CA 53 CA         jp z,robots_draw0                       ; if left, nothing to do
523+  CA4F 11 20 00         ld de,32
524+  CA52 19               add hl,de                               ; add four frames to sprite
525+  CA53              robots_draw0:
526+  CA53 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
527+  CA56 11 00 00         ld de,0
528+  CA59 5F               ld e,a
529+  CA5A 19               add hl,de                               ; add to base
530+  CA5B CD 94 A9         call sprites_drawsprite
531+  CA5E C9               ret
532+  CA5F
533+  CA5F              ;
534+  CA5F              ; Checks to see if the robot is hitting a player
535+  CA5F              ; Inputs:
536+  CA5F              ; ix - memory location of robot we're checking
537+  CA5F              robots_checkforplayer:
538+  CA5F DD 4E 00 DD      ld bc,(ix)           ; get coords
538+  CA63 46 01
539+  CA65 ED 5B 9A BB      ld de,(player)       ; get the player coords
540+  CA69 7B               ld a,e               ; get the vert coord first
541+  CA6A 91               sub c                ; subtract the diamond vertical coord from players
542+  CA6B C6 08            add 8                ; add the max distance
543+  CA6D FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
544+  CA6F D0               ret nc               ; if not, hasn't hit
545+  CA70 7A               ld a,d               ; get the player horiz coord
546+  CA71 90               sub b                ; subtract rock coord
547+  CA72 C6 08            add 8                ; add max distance
548+  CA74 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
549+  CA76 D0               ret nc
550+  CA77 DD 36 02 00      ld (ix+2),0          ; mark as inactive
551+  CA7B CD 3E CA         call robots_draw     ; delete the frame
552+  CA7E CD A0 BC         call player_robotkillplayer ; mark the player as killed
553+  CA81 C9               ret
# file closed: game/robots.asm
 49   CA82
 50   CA82              ;===========================================================================
 51   CA82              ; main routine - the code execution starts here.
 52   CA82              ; Sets up the new interrupt routine, the memory
 53   CA82              ; banks and jumps to the start loop.
 54   CA82              ;===========================================================================
 55   CA82              main:
 56   CA82
 57   CA82                  ; Draw the title screen
 58   CA82              main_titlescreen:
 59   CA82 CD B3 AA         call titlescreen_show
 60   CA85 CD DF BB         call player_init_gamestart
 61   CA88
 62   CA88              main_lifestart:
 63   CA88
 64   CA88 CD FD BB         call player_init_lifestart
 65   CA8B
 66   CA8B CD 19 AC         call lifescreen_draw        ; show the lives remaining screen
 67   CA8E
 68   CA8E CD 00 80         call init_start
 69   CA91 CD 8B A7         call screen_draw
 70   CA94 CD DA A6         call buffer_allbuffertoscreen
 71   CA97
 72   CA97 CD 4A C4         call missiles_init
 73   CA9A CD D2 BD         call ship_land              ; land the ship
 74   CA9D CD E5 BE         call tank_init
 75   CAA0 CD 12 C4         call diamonds_init
 76   CAA3 CD FB C5         call thepit_init
 77   CAA6 CD 87 C6         call monster_init
 78   CAA9 CD 62 C7         call robots_init
 79   CAAC
 80   CAAC              mloop:
 81   CAAC                  ;halt
 82   CAAC CD E0 CA         call main_loop_processing
 83   CAAF
 84   CAAF                  ;
 85   CAAF                  ; Check if the player died
 86   CAAF                  ;
 87   CAAF 21 A4 BB         ld hl,player+10
 88   CAB2 7E               ld a,(hl)                   ; check if the player died this frame
 89   CAB3 FE 01            cp 1
 90   CAB5 C2 CC CA         jp nz,mloop0
 91   CAB8 CD 64 BC         call player_died        ; do end of life housekeeping
 92   CABB 06 28            ld b,40
 93   CABD CD 82 80         call utilities_pauseforframes
 94   CAC0 21 A3 BB         ld hl,player+9        ; check lives remaining
 95   CAC3 7E               ld a,(hl)
 96   CAC4 FE 00            cp 0
 97   CAC6 CA 11 CB         jp z,main_gameover   ; leave the loop if we're done
 98   CAC9 C3 88 CA         jp main_lifestart    ; otherwise, start a new life
 99   CACC              mloop0:
100   CACC                  ;
101   CACC                  ; Check if the player completed the level
102   CACC                  ;
103   CACC 21 A7 BB         ld hl,player+13
104   CACF 7E               ld a,(hl)
105   CAD0 FE 01            cp 1
106   CAD2 C2 AC CA         jp nz,mloop
107   CAD5 CD 9C BD         call player_checkforexit
108   CAD8 FE 01            cp 1                        ; look at return, if 1, level has been completed
109   CADA CA 17 CB         jp z,main_endlevel          ; jump to level transition screen
110   CADD C3 AC CA         jp mloop                ; start the loop again
111   CAE0
112   CAE0
113   CAE0              main_loop_processing:
114   CAE0
115   CAE0 CD 99 A6         call buffer_buffertoscreen  ; copy buffer to screen
116   CAE3 CD FE A5         call buffer_clearlist       ; zero the updated lines list
117   CAE6 CD A9 BB         call player_getlocation     ; figure out where the player is
118   CAE9 CD A6 BC         call player_drawplayer      ; delete player
119   CAEC CD D4 B6         call control_keyboard       ; check keyboard
120   CAEF CD A6 BC         call player_drawplayer      ; draw player
121   CAF2 CD 14 BF         call tank_process           ; prcoess the tank
122   CAF5 CD BD BD         call ship_process           ; proces the ship
123   CAF8 CD 18 C1         call rocks_processrocks     ; process falling rocks
124   CAFB CD 06 C6         call thepit_process         ; process the pit trap
125   CAFE CD 72 C4         call missiles_process       ; process missiles
126   CB01 CD A4 C6         call monster_process        ; process monster
127   CB04 CD CC C7         call robots_process         ; process robots
128   CB07 CD F1 C3         call diamonds_twinkle       ; make the diamonds twinkle
129   CB0A CD 7B C2         call scores_printscore      ; update the score on screen
130   CB0D CD 81 BB         call game_incrementframe    ; increment the game frame
131   CB10
132   CB10 C9               ret
133   CB11
134   CB11              main_gameover:
135   CB11 CD 6C AC         call gameover_draw          ; show the game over screen
136   CB14 C3 82 CA         jp main_titlescreen         ; go back to title
137   CB17
138   CB17              main_endlevel:
139   CB17 CD 4A BC         call player_recordcurrentscore
140   CB1A CD 5A AD         call endlevel_draw          ; show the end level screen
141   CB1D C3 88 CA         jp main_lifestart           ; start a new life
142   CB20
143   CB20              ;===========================================================================
144   CB20              ; Stack.
145   CB20              ;===========================================================================
146   CB20
147   CB20              ; Stack: this area is reserved for the stack
148   CB20              STACK_SIZE: equ 100    ; in words
149   CB20
150   CB20              ; Reserve stack space
151   CB20 00 00            defw 0  ; WPMEM, 2
152   CB22              stack_bottom:
153   CB22 00 00 00...      defs    STACK_SIZE*2, 0
154   CBEA              stack_top:
155   CBEA 00 00            defw 0  ; WPMEM, 2
156   CBEC
157   CBEC                     SAVESNA "ThePit.sna", main
# file closed: main.asm
