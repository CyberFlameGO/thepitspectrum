# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000 CD 6B 0D         call $0D6B
  7+  8003 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8005                                      ; bright (64).
  9+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 10+  8008 AF               xor a               ; quick way to load accumulator with zero.
 11+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 12+  800C CD AF 0D         call 3503           ; ROM routine - clears screen, opens chan 2.
 13+  800F
 14+  800F C9               ret
 15+  8010
 16+  8010              ;
 17+  8010              ;   Start coord
 18+  8010              ;   vert c, horiz b
 19+  8010              start_coord:
 20+  8010 18 30            defb 24,48
 21+  8012
 22+  8012
 23+  8012              ;
 24+  8012              ;   Data for players
 25+  8012              ;   horiz,vert,dir (0 up, 1 down, 2 left, 3 right), frame
 26+  8012              player_one:
 27+  8012 00 00 00 00      defb    0,0,0,0
# file closed: init.asm
 21   8016                  include "utilities.asm"
# file opened: utilities.asm
  1+  8016              ; ##########################################################################
  2+  8016              ; Print a character
  3+  8016              ; Inputs:
  4+  8016              ; b - x coord
  5+  8016              ; c - y coord
  6+  8016              ; d - character
  7+  8016              ; e - colour
  8+  8016              ; ##########################################################################
  9+  8016              utilities_print_char:
 10+  8016 7B               ld a,e
 11+  8017 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  801A 3E 16            ld a,22
 13+  801C D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  801D 78               ld a,b              ; Gets the X co-ordinate
 15+  801E 3D               dec a
 16+  801F D7               rst 16
 17+  8020 79               ld a,c              ; and the Y co-ordinate
 18+  8021 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8022 7A               ld a,d              ; ASCII code for udg.
 20+  8023 D7               rst 16              ; draw block.
 21+  8024 C9               ret
 22+  8025
 23+  8025
 24+  8025              ;Inputs:
 25+  8025              ;     DE and A are factors
 26+  8025              ;Outputs:
 27+  8025              ;     A is not changed
 28+  8025              ;     B is 0
 29+  8025              ;     C is not changed
 30+  8025              ;     DE is not changed
 31+  8025              ;     HL is the product
 32+  8025              ;Time:
 33+  8025              ;     342+6x
 34+  8025              ;
 35+  8025              utilities_multiply:
 36+  8025 06 08            ld b,8          ;7           7
 37+  8027 21 00 00         ld hl,0         ;10         10
 38+  802A 29               add hl,hl     ;11*8       88
 39+  802B 07               rlca          ;4*8        32
 40+  802C 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  802E 19                   add hl,de   ;--         --
 42+  802F 10 F9            djnz $-5      ;13*7+8     99
 43+  8031 C9               ret             ;10         10
# file closed: utilities.asm
 22   8032                  include "strings.asm"
# file opened: strings.asm
  1+  8032              string_score1:
  2+  8032 04 00 53 43      defb 4,0,'SCORE1',254
  2+  8036 4F 52 45 31
  2+  803A FE
  3+  803B              string_scorenumbers1:
  4+  803B 04 01 30 30      defb 4,1,'000000',254
  4+  803F 30 30 30 30
  4+  8043 FE
  5+  8044              string_company:
  6+  8044 0E 00 45 4E      defb 14,0,'ENV',254
  6+  8048 56 FE
  7+  804A              string_credits:
  8+  804A 0C 01 43 52      defb 12,1,'CREDITS 1',254
  8+  804E 45 44 49 54
  8+  8052 53 20 31 FE
  9+  8056              string_score2:
 10+  8056 17 00 53 43      defb 23,0,'SCORE2',254
 10+  805A 4F 52 45 32
 10+  805E FE
 11+  805F              string_scorenumbers2:
 12+  805F 17 01 30 30      defb 23,1,'000000',254
 12+  8063 30 30 30 30
 12+  8067 FE
 13+  8068
 14+  8068              ;
 15+  8068              ; Prints specified string
 16+  8068              ; Inputs:
 17+  8068              ; de: pointer to string
 18+  8068              ; bc: length of string
 19+  8068              ;
 20+  8068              ; Print String Data
 21+  8068              ; First two bytes of string contain X and Y char position, then the string
 22+  8068              ; Individual strings are terminated with 0xFE
 23+  8068              ; End of data is terminated with 0xFF
 24+  8068              ; HL: Address of string
 25+  8068              ;
 26+  8068 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
 27+  8069 23                                   INC HL                          ; Increase HL to the next memory location
 28+  806A 56                                   LD D,(HL)                       ; Fetch the Y coordinate
 29+  806B 23                                   INC HL                          ; Increase HL to the next memory location
 30+  806C CD 7F 80                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
 31+  806F 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
 32+  8070 23                                   INC HL                          ; Increase HL to the next character
 33+  8071 FE FE                                CP 0xFE                         ; Compare with 0xFE
 34+  8073 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
 35+  8075 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
 36+  8076 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
 37+  8077 CD 8F 80                             CALL Print_Char                 ; Print the character
 38+  807A E1                                   POP HL                          ; Retrieve HL back off the stack
 39+  807B 1C                                   INC E                           ; Go to the next screen address
 40+  807C 18 F1                                JR string_print_0               ; Loop back to print next character
 41+  807E C9                                   RET
 42+  807F
 43+  807F              ; Get screen address
 44+  807F              ; D = Y character position
 45+  807F              ; E = X character position
 46+  807F              ; Returns address in DE
 47+  807F              ;
 48+  807F 7A           string_getcharaddress:       LD A,D
 49+  8080 E6 07                                AND %00000111
 50+  8082 1F                                   RRA
 51+  8083 1F                                   RRA
 52+  8084 1F                                   RRA
 53+  8085 1F                                   RRA
 54+  8086 B3                                   OR E
 55+  8087 5F                                   LD E,A
 56+  8088 7A                                   LD A,D
 57+  8089 E6 18                                AND %00011000
 58+  808B F6 40                                OR %01000000
 59+  808D 57                                   LD D,A
 60+  808E C9                                   RET                             ; Returns screen address in DE
 61+  808F
 62+  808F              ; Print a single character out
 63+  808F              ; A:  Character to print
 64+  808F              ; DE: Screen address to print character at
 65+  808F              ;
 66+  808F 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
 67+  8092 06 00                                LD B,0                          ; Set BC to A
 68+  8094 4F                                   LD C,A
 69+  8095 E6 FF                                AND 0xFF                        ; Clear the carry bit
 70+  8097 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
 71+  8099 CB 10                                RL B
 72+  809B CB 11                                RL C
 73+  809D CB 10                                RL B
 74+  809F CB 11                                RL C
 75+  80A1 CB 10                                RL B
 76+  80A3 09                                   ADD HL,BC                       ; Get the character address in HL
 77+  80A4 0E 08                                LD C,8                          ; Loop counter
 78+  80A6 D5                                   PUSH DE
 79+  80A7 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
 80+  80A8 12                                   LD (DE),A                       ; Stick A onto the screen
 81+  80A9 14                                   INC D                           ; Goto next line on screen
 82+  80AA 2C                                   INC L                           ; Goto next byte of character
 83+  80AB 0D                                   DEC C                           ; Decrease the loop counter
 84+  80AC 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
 85+  80AE D1                                   POP DE
 86+  80AF C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   80B0                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  80B0              screen_buffer:
  2+  80B0 00 00 00...      defs 7424                   ; area reserved for screen
  3+  9DB0
  4+  9DB0              screen_attr_buffer:
  5+  9DB0 00 00 00...      defs 928                    ; attrs buffer area
  6+  A150
  7+  A150              screen_offset:
  8+  A150 00               defb 0                      ; offset from top of screen in lines
  9+  A151
 10+  A151              ;
 11+  A151              ; Copies the buffer to the screen. Use stack.
 12+  A151              ; Inputs: none
 13+  A151              ;
 14+  A151              screen_buffertoscreen:
 15+  A151 3A 50 A1         ld a,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 16+  A154 11 00 01         ld de,256
 17+  A157 CD 25 80         call utilities_multiply
 18+  A15A 54 5D            ld de,hl
 19+  A15C 21 B0 80         ld hl,screen_buffer
 20+  A15F 19               add hl,de                   ; add the offset
 21+  A160 ED 73 CC A1      ld (screen_buffertoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
 22+  A164 D9               exx
 23+  A165 21 50 40         ld hl,16384+80              ; where the actual screen is, but as we're using the stack it's the right hand side of the buffer (16+32+32)
 24+  A168              screen_buffertoscreen0:
 25+  A168 D9               exx                         ; hl is now buffer
 26+  A169 F9               ld sp,hl                    ; do first sixteen for left hand side
 27+  A16A F1               pop af
 28+  A16B C1               pop bc
 29+  A16C D1               pop de
 30+  A16D DD E1            pop ix
 31+  A16F D9               exx                         ; hl is now screen
 32+  A170 08               ex af,af'
 33+  A171 F1               pop af
 34+  A172 C1               pop bc
 35+  A173 D1               pop de
 36+  A174 FD E1            pop iy
 37+  A176 F9               ld sp,hl
 38+  A177 FD E5            push iy
 39+  A179 D5               push de
 40+  A17A C5               push bc
 41+  A17B F5               push af
 42+  A17C 08               ex af,af'
 43+  A17D D9               exx                         ; hl is now buffer
 44+  A17E DD E5            push ix
 45+  A180 D5               push de
 46+  A181 C5               push bc
 47+  A182 F5               push af
 48+  A183 1E 10            ld e,16                    ; do another sixteen for right hand side
 49+  A185 16 00            ld d,0
 50+  A187 19               add hl,de
 51+  A188 F9               ld sp,hl
 52+  A189 F1               pop af
 53+  A18A C1               pop bc
 54+  A18B D1               pop de
 55+  A18C DD E1            pop ix
 56+  A18E D9               exx                         ; hl is now screen
 57+  A18F 08               ex af,af'
 58+  A190 1E 10            ld e,16
 59+  A192 16 00            ld d,0
 60+  A194 19               add hl,de
 61+  A195 F1               pop af
 62+  A196 C1               pop bc
 63+  A197 D1               pop de
 64+  A198 FD E1            pop iy
 65+  A19A F9               ld sp,hl
 66+  A19B FD E5            push iy
 67+  A19D D5               push de
 68+  A19E C5               push bc
 69+  A19F F5               push af
 70+  A1A0 08               ex af,af'
 71+  A1A1 D9               exx                         ; hl is now buffer
 72+  A1A2 DD E5            push ix
 73+  A1A4 D5               push de
 74+  A1A5 C5               push bc
 75+  A1A6 F5               push af
 76+  A1A7 1E 10            ld e,16
 77+  A1A9 16 00            ld d,0
 78+  A1AB 19               add hl,de
 79+  A1AC D9               exx                         ; hl is now screen
 80+  A1AD 1E 10            ld e,16
 81+  A1AF 16 00            ld d,0
 82+  A1B1 ED 52            sbc hl,de
 83+  A1B3 24               inc h
 84+  A1B4 7C               ld a,h
 85+  A1B5 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
 86+  A1B7 20 AF            jr nz,screen_buffertoscreen0 ; next line in cell
 87+  A1B9 7C               ld a,h
 88+  A1BA D6 08            sub 8
 89+  A1BC 67               ld h,a
 90+  A1BD 7D               ld a,l
 91+  A1BE C6 20            add a,32
 92+  A1C0 6F               ld l,a
 93+  A1C1 30 A5            jr nc,screen_buffertoscreen0
 94+  A1C3 7C               ld a,h
 95+  A1C4 C6 08            add a,8
 96+  A1C6 67               ld h,a
 97+  A1C7 FE 58            cp 0x58
 98+  A1C9 20 9D            jr nz,screen_buffertoscreen0
 99+  A1CB              screen_buffertoscreen1:
100+  A1CB 31 00 00         ld sp,0
101+  A1CE D9               exx
102+  A1CF CD D3 A1         call screen_buffertoattrs
103+  A1D2 C9               ret
104+  A1D3
105+  A1D3              screen_buffertoattrs:
106+  A1D3 3A 50 A1         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
107+  A1D6 11 20 00         ld de,32
108+  A1D9 CD 25 80         call utilities_multiply
109+  A1DC 54 5D            ld de,hl
110+  A1DE 21 B0 9D         ld hl,screen_attr_buffer
111+  A1E1 19               add hl,de                       ; add the offset
112+  A1E2 11 40 58         ld de,22528+64                  ; add 32x2 to the attr memory address to account for the top two rows
113+  A1E5 01 A0 03         ld bc,928
114+  A1E8 ED B0            ldir
115+  A1EA C9               ret
116+  A1EB
117+  A1EB              screen_setscorecolours:
118+  A1EB 21 1E A7         ld hl,score_colours
119+  A1EE 11 00 58         ld de,22528                     ; attrs here
120+  A1F1 01 40 00         ld bc,64
121+  A1F4 ED B0            ldir
122+  A1F6 C9               ret
123+  A1F7
124+  A1F7
125+  A1F7              ; Draw the screen
126+  A1F7              ; Inputs:
127+  A1F7              ; none
128+  A1F7              ; Notes:
129+  A1F7              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
130+  A1F7              screen_draw:
131+  A1F7                  ;call clear_screen
132+  A1F7 0E 00            ld c,0                      ; horiz
133+  A1F9 06 00            ld b,0                      ; vert, 0 at top
134+  A1FB DD 21 72 A3      ld ix,level01               ; point ix at level data
135+  A1FF FD 21 B0 9D      ld iy,screen_attr_buffer    ; point iy at attr data
136+  A203              screen_draw0:
137+  A203 DD 7E 00         ld a,(ix)                   ; load the block number
138+  A206 C5               push bc                     ; store bc, contains loop count
139+  A207 CD E6 A2         call screen_getattr         ; get the memory location for this cell's attr into hl
140+  A20A 7E               ld a,(hl)                   ; get the attr value at the address
141+  A20B FD 77 00         ld (iy),a                   ; load the attr into memory
142+  A20E DD 7E 00         ld a,(ix)                   ; load the block number
143+  A211 CD DB A2         call screen_getblock        ; get the block data into hl
144+  A214 CD C1 A2         call screen_showchar        ; show this character here
145+  A217 C1               pop bc                      ; get the loop counter back
146+  A218 DD 23            inc ix                      ; increment level location
147+  A21A FD 23            inc iy                      ; increment attr location
148+  A21C 0C               inc c                       ; increment horiz
149+  A21D 79               ld a,c
150+  A21E FE 20            cp 32                       ; check if horiz has reach edge of screen
151+  A220 C2 03 A2         jp nz,screen_draw0          ; if not, loop
152+  A223 0E 00            ld c,0                      ; if so, reset horiz
153+  A225 04               inc b                       ; increment vertical
154+  A226 78               ld a,b
155+  A227 FE 1D            cp 29                       ; check if at bottom
156+  A229 C2 03 A2         jp nz,screen_draw0          ; if not, loop
157+  A22C CD 5F A2         call screen_initrocks       ; draw rocks
158+  A22F
159+  A22F 21 B8 A7         ld hl,player_sprite       ; load hl with the location of the player sprite data
160+  A232 ED 4B 10 80      ld bc,(start_coord)         ; load bc with the start coords
161+  A236 CD FD A2         call sprites_drawsprite     ; call the routine to draw the sprite
162+  A239 CD 3D A2         call screen_setuptext       ; draws text on the screen
163+  A23C C9               ret
164+  A23D
165+  A23D              ;
166+  A23D              ; Sets up text on the screen
167+  A23D              ;
168+  A23D              screen_setuptext:
169+  A23D 21 32 80         ld hl, string_score1
170+  A240 CD 68 80         call string_print
171+  A243 21 3B 80         ld hl, string_scorenumbers1
172+  A246 CD 68 80         call string_print
173+  A249 21 44 80         ld hl, string_company
174+  A24C CD 68 80         call string_print
175+  A24F 21 56 80         ld hl, string_score2
176+  A252 CD 68 80         call string_print
177+  A255 21 5F 80         ld hl, string_scorenumbers2
178+  A258 CD 68 80         call string_print
179+  A25B CD EB A1         call screen_setscorecolours
180+  A25E C9               ret
181+  A25F              ;
182+  A25F              ; Draw initial rock positions
183+  A25F              ; Inputs:
184+  A25F              ;
185+  A25F              screen_initrocks:
186+  A25F DD 21 12 A7      ld ix,level01rocks          ; load the location of the rock into ix
187+  A263 06 04            ld b,4                      ; length of data
188+  A265              screen_initrocks0:
189+  A265 C5               push bc
190+  A266 DD 4E 00         ld c,(ix)                   ; get the horiz coord
191+  A269 DD 23            inc ix                      ; move to next
192+  A26B DD 46 00         ld b,(ix)                   ; get the vert coord
193+  A26E DD 23            inc ix
194+  A270 CD 9B A2         call screen_getcellattradress ; get the memory address of b,c attr into de
195+  A273 3E 09            ld a,9                      ; load the block number for rock
196+  A275 D5               push de
197+  A276 CD E6 A2         call screen_getattr         ; get the memory location for this cell's attr into hl
198+  A279 D1               pop de
199+  A27A 7E               ld a,(hl)                   ; get the attr value at the address
200+  A27B 12               ld (de),a                   ; load the attr into memory
201+  A27C 3E 09            ld a,9                      ; load the block number for rock
202+  A27E CD DB A2         call screen_getblock        ; get the block data into hl
203+  A281 CD C1 A2         call screen_showchar        ; show this character here
204+  A284              screen_initrocks1:
205+  A284 DD 23            inc ix                      ; move past state
206+  A286 C1               pop bc
207+  A287 10 DC            djnz screen_initrocks0      ; decrease b and check if zero
208+  A289 C9               ret
209+  A28A
210+  A28A
211+  A28A              ;
212+  A28A              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
213+  A28A              ; Inputs:
214+  A28A              ; bc: coords
215+  A28A              ; Outputs:
216+  A28A              ; de: memory location
217+  A28A              ;
218+  A28A              screen_getcelladdress:
219+  A28A 78               ld a,b      ; vertical position.
220+  A28B E6 18            and 24      ; which segment, 0, 1 or 2?
221+  A28D C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
222+  A28F 57               ld d,a      ; this is our high byte.
223+  A290 78               ld a,b      ; what was that vertical position again?
224+  A291 E6 07            and 7       ; which row within segment?
225+  A293 0F               rrca        ; multiply row by 32.
226+  A294 0F               rrca
227+  A295 0F               rrca
228+  A296 5F               ld e,a      ; low byte.
229+  A297 79               ld a,c      ; add on y coordinate.
230+  A298 83               add a,e     ; mix with low byte.
231+  A299 5F               ld e,a      ; address of screen position in de.
232+  A29A C9               ret
233+  A29B
234+  A29B              ;
235+  A29B              ; Calculate buffer address of attribute for character at (b, c).
236+  A29B              ; Inputs:
237+  A29B              ; bc: coords
238+  A29B              ; Outputs:
239+  A29B              ; de: memory location
240+  A29B              ;
241+  A29B              screen_getcellattradress:
242+  A29B 11 B0 9D         ld de,screen_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
243+  A29E 69               ld l,c      ; x position.
244+  A29F 26 00            ld h,0      ; 0 h
245+  A2A1 19               add hl,de
246+  A2A2 54 5D            ld de,hl    ; horiz done
247+  A2A4 78               ld a,b      ; do vert
248+  A2A5 D5               push de
249+  A2A6 C5               push bc
250+  A2A7 11 20 00         ld de,32
251+  A2AA CD 25 80         call utilities_multiply
252+  A2AD C1               pop bc
253+  A2AE D1               pop de
254+  A2AF 19               add hl,de
255+  A2B0 54 5D            ld de,hl    ; vert done
256+  A2B2 C9               ret
257+  A2B3
258+  A2B3              ;
259+  A2B3              ; Get buffer address for a character at b,c - b vert
260+  A2B3              ; Buffer memory is stored as sequential block
261+  A2B3              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
262+  A2B3              ; Inputs:
263+  A2B3              ; bc - coords
264+  A2B3              ; Outputs:
265+  A2B3              ; de - memory location of first byte
266+  A2B3              screen_getbufferaddress:
267+  A2B3 21 B0 80         ld hl, screen_buffer    ; first get screen buffer start
268+  A2B6 50               ld d,b                  ; then work out vertical offset
269+  A2B7 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
270+  A2B9 19               add hl,de               ; add to base
271+  A2BA 59               ld e,c                  ; then add horizontal offset (c)
272+  A2BB 16 00            ld d,0
273+  A2BD 19               add hl,de               ; add to base
274+  A2BE 54 5D            ld de,hl
275+  A2C0 C9               ret
276+  A2C1
277+  A2C1
278+  A2C1              ;
279+  A2C1              ; Display character hl at (b, c) to buffer.
280+  A2C1              ; Stored sequentially
281+  A2C1              ; Inputs:
282+  A2C1              ; hl: block address
283+  A2C1              ; bc: coords
284+  A2C1              ;
285+  A2C1              screen_showchar:
286+  A2C1 3E 00            ld a,0
287+  A2C3 E5               push hl
288+  A2C4 CD B3 A2         call screen_getbufferaddress ; get the current screen buffer pointer
289+  A2C7 E1               pop hl
290+  A2C8 06 08            ld b,8              ; number of pixels high.
291+  A2CA              screen_showchar0:
292+  A2CA 7E               ld a,(hl)           ; source graphic.
293+  A2CB 12               ld (de),a           ; transfer to screen.
294+  A2CC 23               inc hl              ; next piece of data.
295+  A2CD E5               push hl             ; store hl
296+  A2CE 62 6B            ld hl,de            ; put de in hl
297+  A2D0 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
298+  A2D2 16 00            ld d,0
299+  A2D4 19               add hl,de              ; add de to hl
300+  A2D5 54 5D            ld de,hl            ; load back to de
301+  A2D7 E1               pop hl              ; restore hl
302+  A2D8
303+  A2D8 10 F0            djnz screen_showchar0 ; repeat
304+  A2DA C9               ret
305+  A2DB
306+  A2DB
307+  A2DB              ;
308+  A2DB              ; Get cell graphic.
309+  A2DB              ; Inputs:
310+  A2DB              ; a: block
311+  A2DB              ; Outputs:
312+  A2DB              ; hl: memory
313+  A2DB              ;
314+  A2DB              screen_getblock:
315+  A2DB 07               rlca                        ; multiply block number by eight.
316+  A2DC 07               rlca
317+  A2DD 07               rlca
318+  A2DE 5F               ld e,a                      ; displacement to graphic address.
319+  A2DF 16 00            ld d,0                      ; no high byte.
320+  A2E1 21 5E A7         ld hl,sprites               ; address of character blocks.
321+  A2E4 19               add hl,de                   ; point to block.
322+  A2E5 C9               ret
323+  A2E6
324+  A2E6              ;
325+  A2E6              ; Get cell attribute.
326+  A2E6              ; Inputs:
327+  A2E6              ; a: block
328+  A2E6              ; Outputs:
329+  A2E6              ; hl: memory
330+  A2E6              ;
331+  A2E6              screen_getattr:
332+  A2E6 5F               ld e,a                      ; displacement to attribute address.
333+  A2E7 16 00            ld d,0                      ; no high byte.
334+  A2E9 21 AE A7         ld hl,sprite_attrs          ; address of block attributes.
335+  A2EC 19               add hl,de                   ; point to attribute.
336+  A2ED C9               ret
337+  A2EE
# file closed: screen/screen.asm
 24   A2EE                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A2EE              ;
  2+  A2EE              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A2EE              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A2EE              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A2EE              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A2EE              ; routine takes care of all the shifting itself. This means that sprite
  7+  A2EE              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A2EE              ; space they would require in pre-shifted form.
  9+  A2EE              ; Inputs:
 10+  A2EE              ; hl - sprite data
 11+  A2EE              ; bc - screen coords
 12+  A2EE              ;
 13+  A2EE              sprites_drawsprite7:
 14+  A2EE EE 07            xor 7               ; complement last 3 bits.
 15+  A2F0 3C               inc a               ; add one for luck!
 16+  A2F1              sprites_drawsprite3:
 17+  A2F1 CB 11            rl c                ; ...into middle byte...
 18+  A2F3 CB 12            rl d                ; ...and finally into left character cell.
 19+  A2F5 3D               dec a               ; count shifts we've done.
 20+  A2F6 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A2F8                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A2F8 79               ld a,c              ; left edge of image is currently in e.
 23+  A2F9 4A               ld c,d              ; put right edge there instead.
 24+  A2FA 57               ld d,a              ; and the left edge back into c.
 25+  A2FB 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A2FD              sprites_drawsprite:
 27+  A2FD ED 43 6F A3      ld (dispx),bc       ; store coords in dispx for now.
 28+  A301 E5               push hl
 29+  A302 CD 4D A3         call sprites_scadd  ; calculate screen address.
 30+  A305 E1               pop hl
 31+  A306 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A308              sprites_drawsprite1:
 33+  A308 08               ex af,af'           ; store loop counter.
 34+  A309 D5               push de             ; store screen address.
 35+  A30A 4E               ld c,(hl)           ; first sprite graphic.
 36+  A30B 23               inc hl              ; increment poiinter to sprite data.
 37+  A30C 22 71 A3         ld (sprtmp),hl      ; store it for later.
 38+  A30F 16 00            ld d,0              ; blank right byte for now.
 39+  A311 78               ld a,b              ; b holds y position.
 40+  A312 E6 07            and 7               ; how are we straddling character cells?
 41+  A314 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A316 FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A318 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A31A A7               and a               ; oops, carry flag is set so clear it.
 45+  A31B              sprites_drawsprite2:
 46+  A31B CB 19            rr c                ; rotate left byte right...
 47+  A31D CB 1A            rr d                ; ...into right byte.
 48+  A31F 3D               dec a               ; one less shift to do.
 49+  A320 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A322              sprites_drawsprite0:
 51+  A322 E1               pop hl              ; pop screen address from stack.
 52+  A323 7E               ld a,(hl)           ; what's there already.
 53+  A324 A9               xor c               ; merge in image data.
 54+  A325 77               ld (hl),a           ; place onto screen.
 55+  A326 2C               inc l               ; next bit of screen area.
 56+  A327 7E               ld a,(hl)           ; what's already there.
 57+  A328 AA               xor d               ; right edge of sprite image data.
 58+  A329 77               ld (hl),a           ; plonk it on screen.
 59+  A32A 3A 6F A3         ld a,(dispx)        ; vertical coordinate.
 60+  A32D 3C               inc a               ; next line down.
 61+  A32E 32 6F A3         ld (dispx),a        ; store new position.
 62+  A331                  ;and 63              ; are we moving to next third of screen?
 63+  A331                  ;jr z,sprites_drawsprite4 ; yes so find next segment.
 64+  A331 E6 07            and 7               ; moving into character cell below?
 65+  A333 28 10            jr z,sprites_drawsprite5 ; yes, find next row.
 66+  A335 2D               dec l               ; left 2 bytes.
 67+  A336 1E 20            ld e,32
 68+  A338 16 00            ld d,0
 69+  A33A 19               add hl,de           ; add 32
 70+  A33B              sprites_drawsprite6:
 71+  A33B EB               ex de,hl            ; screen address in de.
 72+  A33C 2A 71 A3         ld hl,(sprtmp)      ; restore graphic address.
 73+  A33F 08               ex af,af'           ; restore loop counter.
 74+  A340 3D               dec a               ; decrement it.
 75+  A341 C2 08 A3         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 76+  A344 C9               ret                 ; job done.
 77+  A345              sprites_drawsprite5:
 78+  A345 1E 1F            ld e,31             ; add 32 to get to the next row, then subtract 1 to move to the previous cell
 79+  A347 16 00            ld d,0
 80+  A349 19               add hl,de
 81+  A34A C3 3B A3         jp sprites_drawsprite6   ; rejoin loop.
 82+  A34D
 83+  A34D              ;
 84+  A34D              ; This routine returns a buffer address for (c, b) in de (c vert).
 85+  A34D              ; For example: 0,0 will be at memory offset 0
 86+  A34D              ; 1,0 (1 down) will be at memory offset 1
 87+  A34D              ; 0,7 will be at memory offset 0
 88+  A34D              ; 9,1 will be at memory offset 8+1
 89+  A34D              ; 8,0 will be at memory offset 256
 90+  A34D              ; 9,0 will be at memory offset 257
 91+  A34D              ; Inputs:
 92+  A34D              ; de - coords
 93+  A34D              ;
 94+  A34D              sprites_scadd:
 95+  A34D 79               ld a,c               ; calculate vertical offset
 96+  A34E E6 F8            and 248             ;  to get nearest multiple of 8
 97+  A350 0F               rrca
 98+  A351 0F               rrca
 99+  A352 0F               rrca                ; divide by 8
100+  A353 67               ld h,a
101+  A354 78               ld a,b               ; calculate horizontal offset
102+  A355 E6 F8            and 248             ;  to get nearest multiple of 8
103+  A357 0F               rrca
104+  A358 0F               rrca
105+  A359 0F               rrca                ; divide by 8
106+  A35A 6F               ld l,a
107+  A35B C5               push bc             ; store the screen coords
108+  A35C 44 4D            ld bc,hl            ; load bc with the character coords
109+  A35E CD B3 A2         call screen_getbufferaddress
110+  A361 C1               pop bc              ; get back screen coords, de is now memory of character
111+  A362 79               ld a,c              ; now add the vertical within the cell
112+  A363 E6 07            and 7
113+  A365 0F               rrca                ; multiply by 32.
114+  A366 0F               rrca
115+  A367 0F               rrca
116+  A368 6F               ld l,a
117+  A369 26 00            ld h,0
118+  A36B 19               add hl,de
119+  A36C 54 5D            ld de,hl
120+  A36E C9               ret
121+  A36F
122+  A36F 00           dispx   defb 0           ; general-use coordinates.
123+  A370 00           dispy   defb 0
124+  A371 00           sprtmp  defb 0           ; sprite temporary address.
125+  A372
# file closed: screen/sprites.asm
 25   A372
 26   A372                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  A372              ; ###############################################################
  2+  A372              ; Data for level 1
  3+  A372              ; ###############################################################
  4+  A372              level01:
  5+  A372
  6+  A372 00 00 05 05      defb 0,0,5,5,5,5,5,5,5,5,5,5,5,5,2,1,1,1,1,3,5,5,5,5,5,5,5,5,5,5,5,0
  6+  A376 05 05 05 05
  6+  A37A 05 05 05 05
  6+  A37E 05 05 02 01
  6+  A382 01 01 01 03
  6+  A386 05 05 05 05
  6+  A38A 05 05 05 05
  6+  A38E 05 05 05 00
  7+  A392 00 00 05 05      defb 0,0,5,5,5,5,5,5,5,5,5,5,2,1,1,1,1,1,1,1,1,3,5,5,5,5,5,5,5,5,5,0
  7+  A396 05 05 05 05
  7+  A39A 05 05 05 05
  7+  A39E 02 01 01 01
  7+  A3A2 01 01 01 01
  7+  A3A6 01 03 05 05
  7+  A3AA 05 05 05 05
  7+  A3AE 05 05 05 00
  8+  A3B2 00 00 05 05      defb 0,0,5,5,5,5,5,5,5,5,2,1,1,1,1,1,1,1,1,1,1,1,1,3,5,5,5,5,5,5,5,0
  8+  A3B6 05 05 05 05
  8+  A3BA 05 05 02 01
  8+  A3BE 01 01 01 01
  8+  A3C2 01 01 01 01
  8+  A3C6 01 01 01 03
  8+  A3CA 05 05 05 05
  8+  A3CE 05 05 05 00
  9+  A3D2 00 00 01 01      defb 0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,5,5,5,5,5,5,0
  9+  A3D6 01 01 00 01
  9+  A3DA 01 01 01 01
  9+  A3DE 01 01 01 01
  9+  A3E2 01 01 01 01
  9+  A3E6 01 01 01 01
  9+  A3EA 03 05 05 05
  9+  A3EE 05 05 05 00
 10+  A3F2 00 00 01 01      defb 0,0,1,1,4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0
 10+  A3F6 04 04 04 04
 10+  A3FA 04 04 01 01
 10+  A3FE 01 01 01 01
 10+  A402 01 01 01 01
 10+  A406 01 01 01 01
 10+  A40A 01 01 01 01
 10+  A40E 01 00 01 00
 11+  A412 00 00 01 04      defb 0,0,1,4,4,4,4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,0
 11+  A416 04 04 04 04
 11+  A41A 04 04 04 04
 11+  A41E 01 01 01 01
 11+  A422 01 01 01 01
 11+  A426 01 01 01 01
 11+  A42A 01 00 00 00
 11+  A42E 00 00 01 00
 12+  A432 00 00 01 04      defb 0,0,1,4,4,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0
 12+  A436 04 01 01 01
 12+  A43A 01 01 04 04
 12+  A43E 04 04 01 01
 12+  A442 01 01 01 01
 12+  A446 01 00 00 00
 12+  A44A 00 00 01 01
 12+  A44E 01 01 01 00
 13+  A452 00 00 01 04      defb 0,0,1,4,4,4,4,4,4,1,4,4,4,4,4,4,4,4,0,0,0,0,4,4,4,4,4,4,4,4,1,0
 13+  A456 04 04 04 04
 13+  A45A 04 01 04 04
 13+  A45E 04 04 04 04
 13+  A462 04 04 00 00
 13+  A466 00 00 04 04
 13+  A46A 04 04 04 04
 13+  A46E 04 04 01 00
 14+  A472 00 00 01 01      defb 0,0,1,1,1,4,1,1,1,1,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,4,4,4,4,1,0
 14+  A476 01 04 01 01
 14+  A47A 01 01 04 04
 14+  A47E 04 04 04 04
 14+  A482 04 04 00 04
 14+  A486 04 04 04 04
 14+  A48A 04 04 04 04
 14+  A48E 04 04 01 00
 15+  A492 00 00 01 00      defb 0,0,1,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,0,0,0,0,1,0
 15+  A496 00 00 00 00
 15+  A49A 00 04 04 04
 15+  A49E 04 04 04 04
 15+  A4A2 04 04 00 04
 15+  A4A6 04 04 04 04
 15+  A4AA 04 04 00 00
 15+  A4AE 00 00 01 00
 16+  A4B2 00 00 01 07      defb 0,0,1,7,7,7,7,7,7,1,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,0,4,4,0,1,0
 16+  A4B6 07 07 07 07
 16+  A4BA 07 01 04 04
 16+  A4BE 04 04 04 04
 16+  A4C2 04 04 00 04
 16+  A4C6 04 04 04 04
 16+  A4CA 04 04 00 04
 16+  A4CE 04 00 01 00
 17+  A4D2 00 00 01 00      defb 0,0,1,0,0,0,0,0,0,1,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,0,4,4,0,1,0
 17+  A4D6 00 00 00 00
 17+  A4DA 00 01 04 04
 17+  A4DE 04 04 04 04
 17+  A4E2 04 04 00 04
 17+  A4E6 04 04 04 04
 17+  A4EA 04 04 00 04
 17+  A4EE 04 00 01 00
 18+  A4F2 00 00 01 00      defb 0,0,1,0,0,0,0,0,0,1,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,0,4,4,0,1,0
 18+  A4F6 00 00 00 00
 18+  A4FA 00 01 04 04
 18+  A4FE 04 04 04 04
 18+  A502 04 04 00 04
 18+  A506 04 04 04 04
 18+  A50A 04 04 00 04
 18+  A50E 04 00 01 00
 19+  A512 00 00 01 06      defb 0,0,1,6,6,6,6,6,6,1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,1,0
 19+  A516 06 06 06 06
 19+  A51A 06 01 04 00
 19+  A51E 00 00 00 00
 19+  A522 00 00 00 00
 19+  A526 00 00 00 00
 19+  A52A 00 00 00 04
 19+  A52E 04 00 01 00
 20+  A532 00 00 01 06      defb 0,0,1,6,6,6,6,6,6,1,4,0,4,4,4,4,4,4,0,4,4,4,0,4,4,4,4,4,4,0,1,0
 20+  A536 06 06 06 06
 20+  A53A 06 01 04 00
 20+  A53E 04 04 04 04
 20+  A542 04 04 00 04
 20+  A546 04 04 00 04
 20+  A54A 04 04 04 04
 20+  A54E 04 00 01 00
 21+  A552 00 00 01 06      defb 0,0,1,6,6,6,6,6,6,1,4,0,4,4,4,4,4,4,0,4,4,4,0,4,4,4,4,4,4,0,1,0
 21+  A556 06 06 06 06
 21+  A55A 06 01 04 00
 21+  A55E 04 04 04 04
 21+  A562 04 04 00 04
 21+  A566 04 04 00 04
 21+  A56A 04 04 04 04
 21+  A56E 04 00 01 00
 22+  A572 00 00 01 06      defb 0,0,1,6,6,6,6,6,6,1,4,0,4,4,4,4,4,4,0,4,4,4,0,4,4,4,4,4,4,0,1,0
 22+  A576 06 06 06 06
 22+  A57A 06 01 04 00
 22+  A57E 04 04 04 04
 22+  A582 04 04 00 04
 22+  A586 04 04 00 04
 22+  A58A 04 04 04 04
 22+  A58E 04 00 01 00
 23+  A592 00 00 01 01      defb 0,0,1,1,1,1,1,1,1,1,4,0,4,4,4,4,4,4,0,4,4,4,0,4,4,4,4,4,4,0,1,0
 23+  A596 01 01 01 01
 23+  A59A 01 01 04 00
 23+  A59E 04 04 04 04
 23+  A5A2 04 04 00 04
 23+  A5A6 04 04 00 04
 23+  A5AA 04 04 04 04
 23+  A5AE 04 00 01 00
 24+  A5B2 00 00 01 04      defb 0,0,1,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,0,4,4,4,0,0,0,0,4,4,4,4,1,0
 24+  A5B6 04 04 04 04
 24+  A5BA 04 04 04 00
 24+  A5BE 04 04 04 04
 24+  A5C2 04 04 00 04
 24+  A5C6 04 04 00 00
 24+  A5CA 00 00 04 04
 24+  A5CE 04 04 01 00
 25+  A5D2 00 00 01 04      defb 0,0,1,4,4,4,0,0,0,0,0,0,4,4,4,4,4,4,0,4,4,4,4,4,4,0,4,4,4,4,1,0
 25+  A5D6 04 04 00 00
 25+  A5DA 00 00 00 00
 25+  A5DE 04 04 04 04
 25+  A5E2 04 04 00 04
 25+  A5E6 04 04 04 04
 25+  A5EA 04 00 04 04
 25+  A5EE 04 04 01 00
 26+  A5F2 00 00 01 04      defb 0,0,1,4,4,4,0,4,4,4,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,0,4,4,4,4,1,0
 26+  A5F6 04 04 00 04
 26+  A5FA 04 04 04 04
 26+  A5FE 04 04 04 04
 26+  A602 04 04 00 04
 26+  A606 04 04 04 04
 26+  A60A 04 00 04 04
 26+  A60E 04 04 01 00
 27+  A612 00 00 01 04      defb 0,0,1,4,4,4,0,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,0,4,4,4,4,1,0
 27+  A616 04 04 00 04
 27+  A61A 04 04 01 01
 27+  A61E 01 01 01 01
 27+  A622 01 01 01 01
 27+  A626 01 01 01 01
 27+  A62A 04 00 04 04
 27+  A62E 04 04 01 00
 28+  A632 00 00 01 04      defb 0,0,1,4,4,4,0,4,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,4,0,4,4,4,4,1,0
 28+  A636 04 04 00 04
 28+  A63A 04 04 01 00
 28+  A63E 00 00 00 00
 28+  A642 00 00 00 00
 28+  A646 00 00 00 01
 28+  A64A 04 00 04 04
 28+  A64E 04 04 01 00
 29+  A652 00 00 01 04      defb 0,0,1,4,4,4,0,4,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,4,0,4,4,4,4,1,0
 29+  A656 04 04 00 04
 29+  A65A 04 04 01 00
 29+  A65E 00 00 00 00
 29+  A662 00 00 00 00
 29+  A666 00 00 00 01
 29+  A66A 04 00 04 04
 29+  A66E 04 04 01 00
 30+  A672 00 00 01 04      defb 0,0,1,4,4,4,0,4,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,4,0,4,4,4,4,1,0
 30+  A676 04 04 00 04
 30+  A67A 04 04 01 00
 30+  A67E 00 00 00 00
 30+  A682 00 00 00 00
 30+  A686 00 00 00 01
 30+  A68A 04 00 04 04
 30+  A68E 04 04 01 00
 31+  A692 00 00 01 04      defb 0,0,1,4,4,4,0,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,1,0
 31+  A696 04 04 00 04
 31+  A69A 04 04 04 00
 31+  A69E 00 00 00 00
 31+  A6A2 00 00 00 00
 31+  A6A6 00 00 00 04
 31+  A6AA 04 04 04 04
 31+  A6AE 04 04 01 00
 32+  A6B2 00 00 01 04      defb 0,0,1,4,4,4,4,4,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,4,4,4,4,4,4,1,0
 32+  A6B6 04 04 04 04
 32+  A6BA 04 04 01 00
 32+  A6BE 00 00 00 00
 32+  A6C2 00 00 00 00
 32+  A6C6 00 00 00 01
 32+  A6CA 04 04 04 04
 32+  A6CE 04 04 01 00
 33+  A6D2 00 00 01 04      defb 0,0,1,4,4,4,4,4,4,4,1,0,8,0,1,0,8,0,0,1,0,8,0,1,4,4,4,4,4,4,1,0
 33+  A6D6 04 04 04 04
 33+  A6DA 04 04 01 00
 33+  A6DE 08 00 01 00
 33+  A6E2 08 00 00 01
 33+  A6E6 00 08 00 01
 33+  A6EA 04 04 04 04
 33+  A6EE 04 04 01 00
 34+  A6F2 00 00 01 01      defb 0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0
 34+  A6F6 01 01 01 01
 34+  A6FA 01 01 01 01
 34+  A6FE 01 01 01 01
 34+  A702 01 01 01 01
 34+  A706 01 01 01 01
 34+  A70A 01 01 01 01
 34+  A70E 01 01 01 00
 35+  A712
 36+  A712              ; ###############################################################
 37+  A712              ; Rock data: horiz, vert, state
 38+  A712              ; ###############################################################
 39+  A712              level01rocks:
 40+  A712 09 04 00         defb 9,4,0
 41+  A715 0C 07 00         defb 12,7,0
 42+  A718 10 07 00         defb 16,7,0
 43+  A71B 0B 09 00         defb 11,9,0
 44+  A71E
 45+  A71E              ;
 46+  A71E              ; Score area colours
 47+  A71E              ;
 48+  A71E              score_colours:
 49+  A71E 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,66,66,67,67,67,67,67,66,66,71,71,71,71,71,71,71,71,71,71,71
 49+  A722 47 47 47 47
 49+  A726 47 47 47 42
 49+  A72A 42 42 43 43
 49+  A72E 43 43 43 42
 49+  A732 42 47 47 47
 49+  A736 47 47 47 47
 49+  A73A 47 47 47 47
 50+  A73E 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,66,66,66,66,66,66,66,66,66,66,66,71,71,71,71,71,71,71,71,71
 50+  A742 47 47 47 47
 50+  A746 47 47 47 42
 50+  A74A 42 42 42 42
 50+  A74E 42 42 42 42
 50+  A752 42 42 42 47
 50+  A756 47 47 47 47
 50+  A75A 47 47 47 47
# file closed: leveldata/level01.asm
 27   A75E                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  A75E              ; Tiles graphics.
  2+  A75E              sprites:
  3+  A75E 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  A762 00 00 00 00
  4+  A766 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  A76A FF FF FF FF
  5+  A76E 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  A772 1F 3F 7F FF
  6+  A776 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  A77A F8 FC FE FF
  7+  A77E 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  A782 55 AA 55 AA
  8+  A786 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 5, sky block
  8+  A78A FF FF FF FF
  9+  A78E FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  A792 FF FF FF FF
 10+  A796 FF FF 00 00      defb    255,255,  0,  0,  0,  0,  0,  0   ; 7, trapdoor
 10+  A79A 00 00 00 00
 11+  A79E 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52, 24    ; 8, gem
 11+  A7A2 F1 72 34 18
 12+  A7A6 1C 7E FF 7F      defb    28,126,255,127,254,252,127, 62    ; 9, rock
 12+  A7AA FE FC 7F 3E
 13+  A7AE
 14+  A7AE              sprite_attrs:
 15+  A7AE 47               defb    071 ; 0, space
 16+  A7AF 65               defb    101 ; 1, cyan block
 17+  A7B0 4D               defb    077 ; 2, slope left
 18+  A7B1 4D               defb    077 ; 3, slope right
 19+  A7B2 46               defb    070 ; 4, dirt
 20+  A7B3 41               defb    065 ; 5, sky
 21+  A7B4 4C               defb    076 ; 6, slime
 22+  A7B5 42               defb    066 ; 7, trapdoor
 23+  A7B6 46               defb    070 ; 8, gem
 24+  A7B7 42               defb    066 ; 9, rock
 25+  A7B8
 26+  A7B8              player_sprite:
 27+  A7B8 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 0 right 1
 27+  A7BC 3C 38 68 4C
 28+  A7C0 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 56,108, 64 ; 1 right 2
 28+  A7C4 3C 38 6C 40
 29+  A7C8 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 2 left 1
 29+  A7CC 3C 1C 16 32
 30+  A7D0 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 54,  2 ; 3 left 2
 30+  A7D4 3C 1C 36 02
 31+  A7D8 40 E0 40 FC  	defb	 64,224, 64,252,240,240,152,192 ; 4 shoot right
 31+  A7DC F0 F0 98 C0
 32+  A7E0 02 07 02 3F  	defb	 2,  7,  2, 63, 15, 15, 25,  3  ; 4 shoot left
 32+  A7E4 0F 0F 19 03
 33+  A7E8 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 5 up/down 1
 33+  A7EC 38 3D C3 80
 34+  A7F0 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 6 up/down 2
 34+  A7F4 1C BC C3 01
 35+  A7F8
# file closed: graphics/graphics.asm
 28   A7F8
 29   A7F8              ;===========================================================================
 30   A7F8              ; main routine - the code execution starts here.
 31   A7F8              ; Sets up the new interrupt routine, the memory
 32   A7F8              ; banks and jumps to the start loop.
 33   A7F8              ;===========================================================================
 34   A7F8              main:
 35   A7F8                  ; Disable interrupts
 36   A7F8                  ;di
 37   A7F8
 38   A7F8                  ; Setup stack
 39   A7F8 31 FA A8         ld sp,stack_top
 40   A7FB
 41   A7FB CD 00 80         call init_start
 42   A7FE CD F7 A1         call screen_draw
 43   A801
 44   A801              mloop:
 45   A801 F3               di
 46   A802 CD 51 A1         call screen_buffertoscreen
 47   A805 FB               ei           ; enable interupts
 48   A806 76               halt
 49   A807 01 FE FD         ld bc,65022         ; port for keyboard row.
 50   A80A ED 78            in a,(c)            ; read keyboard.
 51   A80C 47               ld b,a              ; store result in b register.
 52   A80D CB 18            rr b                ; check outermost key.
 53   A80F D4 1A A8         call nc,mpl         ; player left.
 54   A812 CB 18            rr b                ; check next key.
 55   A814 D4 25 A8         call nc,mpr         ; player right.
 56   A817
 57   A817 C3 01 A8         jp mloop
 58   A81A
 59   A81A              mpl:
 60   A81A 3A 50 A1         ld a,(screen_offset)
 61   A81D FE 07            cp 7
 62   A81F C8               ret z
 63   A820 3C               inc a
 64   A821 32 50 A1         ld (screen_offset),a
 65   A824 C9               ret
 66   A825              mpr:
 67   A825 3A 50 A1         ld a,(screen_offset)
 68   A828 FE 00            cp 0
 69   A82A C8               ret z
 70   A82B 3D               dec a
 71   A82C 32 50 A1         ld (screen_offset),a
 72   A82F C9               ret
 73   A830
 74   A830              ;===========================================================================
 75   A830              ; Stack.
 76   A830              ;===========================================================================
 77   A830
 78   A830              ; Stack: this area is reserved for the stack
 79   A830              STACK_SIZE: equ 100    ; in words
 80   A830
 81   A830              ; Reserve stack space
 82   A830 00 00            defw 0  ; WPMEM, 2
 83   A832              stack_bottom:
 84   A832 00 00 00...      defs    STACK_SIZE*2, 0
 85   A8FA              stack_top:
 86   A8FA 00 00            defw 0  ; WPMEM, 2
 87   A8FC
 88   A8FC                     SAVESNA "ThePit.sna", main
# file closed: main.asm
