# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 67 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 F6 A6         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 F7 A6         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 8E A5         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD CB B8         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8051 C9               ret                 ; key was pressed.
 53+  8052
 54+  8052              ;
 55+  8052              ; Waits number of frames for keypress. If got, returns 1, if not 0
 56+  8052              ; Inputs:
 57+  8052              ; a - number of frames to waits
 58+  8052              ; Ouputs:
 59+  8052              ; e - 0 not pressed, 1 pressed
 60+  8052              utilities_waitforkey_forframes:
 61+  8052 21 08 5C         ld hl,23560         ; LAST K system variable.
 62+  8055 36 00            ld (hl),0           ; put null value there.
 63+  8057 47               ld b,a              ; number of frames to wait
 64+  8058              utilities_waitforkey_forframes0:
 65+  8058 7E               ld a,(hl)           ; new value of LAST K.
 66+  8059 FE 00            cp 0                ; is it still zero?
 67+  805B 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 68+  805D 1E 01            ld e,1              ; set the pressed flag
 69+  805F C9               ret                 ; key was pressed.
 70+  8060              utilities_waitforkey_forframes1:
 71+  8060 76               halt                ; wait for frame
 72+  8061 76               halt                ; wait for frame
 73+  8062 10 F4            djnz utilities_waitforkey_forframes0 ; loop again
 74+  8064 1E 00            ld e,0              ; nothing pressed in time
 75+  8066 C9               ret
 76+  8067
 77+  8067              ;
 78+  8067              ; Clears the screen
 79+  8067              ; Inputs:
 80+  8067              ; a - attribute colour
 81+  8067              utilities_clearscreen:
 82+  8067 76               halt
 83+  8068 21 00 58         ld hl,22528         ; attr
 84+  806B 11 01 58         ld de,22529         ; attr+1
 85+  806E 01 FF 02         ld bc,767
 86+  8071 77               ld (hl),a
 87+  8072 ED B0            ldir
 88+  8074
 89+  8074 21 00 40         ld hl, 16384        ;pixels
 90+  8077 11 01 40         ld de, 16385        ;pixels + 1
 91+  807A 01 FF 17         ld bc, 6143         ;pixels area length - 1
 92+  807D 36 00            ld (hl), 0          ;set first byte to '0'
 93+  807F ED B0            ldir                ;copy bytes
 94+  8081
 95+  8081 C9               ret
 96+  8082
 97+  8082              ;
 98+  8082              ; Wait for a number of frames
 99+  8082              ; Inputs:
100+  8082              ; b - number of frames
101+  8082              utilities_pauseforframes:
102+  8082 76               halt
103+  8083 10 FD            djnz utilities_pauseforframes
104+  8085 C9               ret
105+  8086
106+  8086              utilities_readkey:
107+  8086 21 A6 80         LD HL,utilties_keymap              ; Point HL at the keyboard list
108+  8089 16 08            LD D,8                                  ; This is the number of ports (rows) to check
109+  808B 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
110+  808D              utilities_readkey_0:
111+  808D 46               LD B,(HL)                               ; Get the keyboard port address from table
112+  808E 23               INC HL                                  ; Increment to list of keys
113+  808F ED 78            IN A,(C)                                ; Read the row of keys in
114+  8091 E6 1F            AND $1F                                     ; We are only interested in the first five bits
115+  8093 1E 05            LD E,5                                  ; This is the number of keys in the row
116+  8095              utilities_readkey_1:
117+  8095 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
118+  8097 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
119+  8099 23               INC HL                                  ; Go to next table address
120+  809A 1D               DEC E                                   ; Decrement key loop counter
121+  809B 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
122+  809D 15               DEC D                                   ; Decrement row loop counter
123+  809E 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
124+  80A0 A7               AND A                                   ; Clear A (no key found)
125+  80A1 C3 86 80         jp utilities_readkey
126+  80A4              utilities_readkey_2:
127+  80A4 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
128+  80A5 C9               RET
129+  80A6
130+  80A6              utilties_keymap:
131+  80A6 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
131+  80AA 43 56
132+  80AC FD 41 53 44      defb $FD,"A","S","D","F","G"
132+  80B0 46 47
133+  80B2 FB 51 57 45      defb $FB,"Q","W","E","R","T"
133+  80B6 52 54
134+  80B8 F7 31 32 33      defb $F7,"1","2","3","4","5"
134+  80BC 34 35
135+  80BE EF 30 39 38      defb $EF,"0","9","8","7","6"
135+  80C2 37 36
136+  80C4 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
136+  80C8 55 59
137+  80CA BF 23 4C 4B      defb $BF,"#","L","K","J","H"
137+  80CE 4A 48
138+  80D0 7F 20 23 4D      defb $7F," ","#","M","N","B"
138+  80D4 4E 42
# file closed: utilities.asm
 22   80D6                  include "strings.asm"
# file opened: strings.asm
  1+  80D6              string_score1:
  2+  80D6 04 00 53 43      defb 4,0,'SCORE1',255
  2+  80DA 4F 52 45 31
  2+  80DE FF
  3+  80DF              string_scorenumbers1:
  4+  80DF 04 01 30 30      defb 4,1,'000000',255
  4+  80E3 30 30 30 30
  4+  80E7 FF
  5+  80E8              string_company:
  6+  80E8 0E 00 45 4E      defb 14,0,'ENV',255
  6+  80EC 56 FF
  7+  80EE              string_credits:
  8+  80EE 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  80F2 41 59 45 52
  8+  80F6 20 31 FF
  9+  80F9              string_score2:
 10+  80F9 16 00 53 43      defb 22,0,'SCORE2',255
 10+  80FD 4F 52 45 32
 10+  8101 FF
 11+  8102              string_scorenumbers2:
 12+  8102 16 01 30 30      defb 22,1,'000000',255
 12+  8106 30 30 30 30
 12+  810A FF
 13+  810B              string_titlescreen_copyright:
 14+  810B 04 16 7F 20      defb 4,22, 127,' 1982 AW ZILEC ELC LTD',255
 14+  810F 31 39 38 32
 14+  8113 20 41 57 20
 14+  8117 5A 49 4C 45
 14+  811B 43 20 45 4C
 14+  811F 43 20 4C 54
 14+  8123 44 FF
 15+  8125
 16+  8125
 17+  8125              string_alttitlescreen_1:
 18+  8125 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  8129 45 44 49 54
 18+  812D 53 20 31 FF
 19+  8131              string_alttitlescreen_2:
 20+  8131 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  8135 20 20 20 20
 20+  8139 20 20 20 20
 20+  813D 20 54 48 45
 20+  8141 20 4F 42 4A
 20+  8145 45 43 54 FE
 21+  8149 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  814D 20 20 20 20
 21+  8151 20 20 20 20
 21+  8155 4F 46 20 54
 21+  8159 48 49 53 20
 21+  815D 47 41 4D 45
 21+  8161 FE
 22+  8162 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  8166 20 20 20 20
 22+  816A 20 20 20 49
 22+  816E 53 20 54 4F
 22+  8172 20 44 49 47
 22+  8176 20 44 4F 57
 22+  817A 4E FE
 23+  817C 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  8180 20 20 20 20
 23+  8184 20 20 54 4F
 23+  8188 20 54 48 45
 23+  818C 20 42 4F 54
 23+  8190 54 4F 4D 20
 23+  8194 50 49 54 FE
 24+  8198 00 06 20 20      defb 0,6,'               AND',254
 24+  819C 20 20 20 20
 24+  81A0 20 20 20 20
 24+  81A4 20 20 20 20
 24+  81A8 20 41 4E 44
 24+  81AC FE
 25+  81AD 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  81B1 20 20 20 20
 25+  81B5 20 20 43 4F
 25+  81B9 4C 4C 45 43
 25+  81BD 54 20 41 54
 25+  81C1 20 4C 45 41
 25+  81C5 53 54 FE
 26+  81C8 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  81CC 20 20 20 20
 26+  81D0 20 20 20 4F
 26+  81D4 4E 45 20 4C
 26+  81D8 41 52 47 45
 26+  81DC 20 4A 45 57
 26+  81E0 45 4C FE
 27+  81E3 00 09 20 20      defb 0,9,'              THEN',254
 27+  81E7 20 20 20 20
 27+  81EB 20 20 20 20
 27+  81EF 20 20 20 20
 27+  81F3 54 48 45 4E
 27+  81F7 FE
 28+  81F8 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  81FC 20 20 20 20
 28+  8200 20 20 20 52
 28+  8204 45 54 55 52
 28+  8208 4E 20 54 4F
 28+  820C 20 53 48 49
 28+  8210 50 FE
 29+  8212 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  8216 20 20 20 20
 29+  821A 20 20 20 54
 29+  821E 48 52 55 20
 29+  8222 55 50 50 45
 29+  8226 52 20 50 49
 29+  822A 54 FF
 30+  822C              string_alttitlescreen_3:
 31+  822C 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  8230 20 20 53 49
 31+  8234 4E 47 4C 45
 31+  8238 20 42 4F 4E
 31+  823C 55 53 20 20
 31+  8240 35 30 30 30
 31+  8244 20 50 4F 49
 31+  8248 4E 54 53 FE
 32+  824C 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  8250 20 20 20 20
 32+  8254 43 4F 4C 4C
 32+  8258 45 43 54 20
 32+  825C 31 20 4C 41
 32+  8260 52 47 45 20
 32+  8264 4A 45 57 45
 32+  8268 4C FE
 33+  826A 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  826E 20 20 20 20
 33+  8272 20 41 4E 44
 33+  8276 20 52 45 54
 33+  827A 55 52 4E 20
 33+  827E 54 4F 20 53
 33+  8282 48 49 50 FE
 34+  8286 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  828A 20 20 44 4F
 34+  828E 55 42 4C 45
 34+  8292 20 42 4F 4E
 34+  8296 55 53 20 20
 34+  829A 31 30 30 30
 34+  829E 30 20 50 4F
 34+  82A2 49 4E 54 53
 34+  82A6 FE
 35+  82A7 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  82AB 20 20 43 4F
 35+  82AF 4C 4C 45 43
 35+  82B3 54 20 41 4C
 35+  82B7 4C 20 33 20
 35+  82BB 4C 41 52 47
 35+  82BF 45 20 4A 45
 35+  82C3 57 45 4C 53
 35+  82C7 FE
 36+  82C8 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  82CC 20 20 20 20
 36+  82D0 20 4F 52 20
 36+  82D4 20 20 41 4C
 36+  82D8 4C 20 34 20
 36+  82DC 53 4D 41 4C
 36+  82E0 4C 20 4A 45
 36+  82E4 57 45 4C 53
 36+  82E8 FE
 37+  82E9 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  82ED 20 20 54 52
 37+  82F1 49 50 4C 45
 37+  82F5 20 42 4F 4E
 37+  82F9 55 53 20 20
 37+  82FD 31 35 30 30
 37+  8301 30 20 50 4F
 37+  8305 49 4E 54 53
 37+  8309 FE
 38+  830A 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  830E 20 20 20 20
 38+  8312 20 43 4F 4C
 38+  8316 4C 45 43 54
 38+  831A 20 41 4C 4C
 38+  831E 20 37 20 4A
 38+  8322 45 57 45 4C
 38+  8326 53 FF
 39+  8328
 40+  8328              string_lifescreen_player:
 41+  8328 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  832C 4C 41 59 45
 41+  8330 52 20 31 20
 41+  8334 FF
 42+  8335              string_lifescreen_lives:
 43+  8335 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  8339 4D 45 4E 20
 43+  833D 4C 45 46 54
 43+  8341 FF
 44+  8342              string_lifescreen_lastman:
 45+  8342 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  8346 53 54 20 4D
 45+  834A 41 4E FF
 46+  834D
 47+  834D              string_gameoverscreen_gameover:
 48+  834D 0C 06 47 41      defb 12,6,'GAME OVER',255
 48+  8351 4D 45 20 4F
 48+  8355 56 45 52 FF
 49+  8359              string_gameoverscreen_copyright:
 50+  8359 05 12 7F 20      defb 5,18,127,' 1982 AW ZILEC ELC LTD',255
 50+  835D 31 39 38 32
 50+  8361 20 41 57 20
 50+  8365 5A 49 4C 45
 50+  8369 43 20 45 4C
 50+  836D 43 20 4C 54
 50+  8371 44 FF
 51+  8373              string_gameoverscreen_bestscores:
 52+  8373 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  8377 53 54 20 53
 52+  837B 43 4F 52 45
 52+  837F 53 20 54 4F
 52+  8383 44 41 59 FF
 53+  8387              string_gameover_credits:
 54+  8387 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  838B 45 44 49 54
 54+  838F 53 20 30 FF
 55+  8393
 56+  8393              string_highscore_congratulations:
 57+  8393 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 57+  8397 4E 47 52 41
 57+  839B 54 55 4C 41
 57+  839F 54 49 4F 4E
 57+  83A3 53 FF
 58+  83A5              string_highscore_player1:
 59+  83A5 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 59+  83A9 41 59 45 52
 59+  83AD 20 31 FF
 60+  83B0              string_highscore_player2:
 61+  83B0 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 61+  83B4 41 59 45 52
 61+  83B8 20 32 FF
 62+  83BB              string_highscore_youhaveearned:
 63+  83BB 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 63+  83BF 55 20 48 41
 63+  83C3 56 45 20 45
 63+  83C7 41 52 4E 45
 63+  83CB 44 FF
 64+  83CD              string_highscore_place1:
 65+  83CD 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 65+  83D1 45 20 47 52
 65+  83D5 45 41 54 45
 65+  83D9 53 54 20 53
 65+  83DD 43 4F 52 45
 65+  83E1 FF
 66+  83E2              string_highscore_place2:
 67+  83E2 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 67+  83E6 45 20 32 4E
 67+  83EA 44 20 42 45
 67+  83EE 53 54 20 53
 67+  83F2 43 4F 52 45
 67+  83F6 FF
 68+  83F7              string_highscore_place3:
 69+  83F7 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 69+  83FB 45 20 33 52
 69+  83FF 44 20 42 45
 69+  8403 53 54 20 53
 69+  8407 43 4F 52 45
 69+  840B FF
 70+  840C              string_highscore_pleaseenter
 71+  840C 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 71+  8410 43 4F 52 44
 71+  8414 20 59 4F 55
 71+  8418 52 20 49 4E
 71+  841C 49 54 49 41
 71+  8420 4C 53 20 42
 71+  8424 45 4C 4F 57
 71+  8428 FF
 72+  8429
 73+  8429              string_endlevel_youhaveearned:
 74+  8429 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 74+  842D 55 20 48 41
 74+  8431 56 45 20 45
 74+  8435 41 52 4E 45
 74+  8439 44 FF
 75+  843B              string_endlevel_bonus1:
 76+  843B 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 76+  843F 4E 47 4C 45
 76+  8443 20 42 4F 4E
 76+  8447 55 53 FF
 77+  844A              string_endlevel_bonus2:
 78+  844A 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 78+  844E 55 42 4C 45
 78+  8452 20 42 4F 4E
 78+  8456 55 53 FF
 79+  8459              string_endlevel_bonus3:
 80+  8459 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 80+  845D 49 50 4C 45
 80+  8461 20 42 4F 4E
 80+  8465 55 53 FF
 81+  8468              string_endlevel_points1:
 82+  8468 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 82+  846C 30 30 20 50
 82+  8470 4F 49 4E 54
 82+  8474 53 FF
 83+  8476              string_endlevel_points2:
 84+  8476 09 0F 31 30      defb 9,15,'10000 POINTS',255
 84+  847A 30 30 30 20
 84+  847E 50 4F 49 4E
 84+  8482 54 53 FF
 85+  8485              string_endlevel_points3:
 86+  8485 09 0F 31 35      defb 9,15,'15000 POINTS',255
 86+  8489 30 30 30 20
 86+  848D 50 4F 49 4E
 86+  8491 54 53 FF
 87+  8494              string_endlevel_anothergo:
 88+  8494 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 88+  8498 56 45 20 41
 88+  849C 4E 4F 54 48
 88+  84A0 45 52 20 47
 88+  84A4 4F FF
 89+  84A6              ;
 90+  84A6              ; Prints specified string
 91+  84A6              ; Inputs:
 92+  84A6              ; de: pointer to string
 93+  84A6              ; bc: length of string
 94+  84A6              ;
 95+  84A6              ; Print String Data
 96+  84A6              ; First two bytes of string contain X and Y char position, then the string
 97+  84A6              ; Individual strings are terminated with 0xFE
 98+  84A6              ; End of data is terminated with 0xFF
 99+  84A6              ; HL: Address of string
100+  84A6              ;
101+  84A6 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
102+  84A7 23                                   INC HL                          ; Increase HL to the next memory location
103+  84A8 56                                   LD D,(HL)                       ; Fetch the Y coordinate
104+  84A9 23                                   INC HL                          ; Increase HL to the next memory location
105+  84AA CD BD 84                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
106+  84AD 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
107+  84AE 23                                   INC HL                          ; Increase HL to the next character
108+  84AF FE FE                                CP 0xFE                         ; Compare with 0xFE
109+  84B1 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
110+  84B3 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
111+  84B4 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
112+  84B5 CD CD 84                             CALL Print_Char                 ; Print the character
113+  84B8 E1                                   POP HL                          ; Retrieve HL back off the stack
114+  84B9 1C                                   INC E                           ; Go to the next screen address
115+  84BA 18 F1                                JR string_print_0               ; Loop back to print next character
116+  84BC C9                                   RET
117+  84BD
118+  84BD              ; Get screen address
119+  84BD              ; D = Y character position
120+  84BD              ; E = X character position
121+  84BD              ; Returns address in DE
122+  84BD              ;
123+  84BD 7A           string_getcharaddress:       LD A,D
124+  84BE E6 07                                AND %00000111
125+  84C0 1F                                   RRA
126+  84C1 1F                                   RRA
127+  84C2 1F                                   RRA
128+  84C3 1F                                   RRA
129+  84C4 B3                                   OR E
130+  84C5 5F                                   LD E,A
131+  84C6 7A                                   LD A,D
132+  84C7 E6 18                                AND %00011000
133+  84C9 F6 40                                OR %01000000
134+  84CB 57                                   LD D,A
135+  84CC C9                                   RET                             ; Returns screen address in DE
136+  84CD
137+  84CD              ; Print a single character out
138+  84CD              ; A:  Character to print
139+  84CD              ; DE: Screen address to print character at
140+  84CD              ;
141+  84CD 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
142+  84D0 06 00                                LD B,0                          ; Set BC to A
143+  84D2 4F                                   LD C,A
144+  84D3 E6 FF                                AND 0xFF                        ; Clear the carry bit
145+  84D5 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
146+  84D7 CB 10                                RL B
147+  84D9 CB 11                                RL C
148+  84DB CB 10                                RL B
149+  84DD CB 11                                RL C
150+  84DF CB 10                                RL B
151+  84E1 09                                   ADD HL,BC                       ; Get the character address in HL
152+  84E2 0E 08                                LD C,8                          ; Loop counter
153+  84E4 D5                                   PUSH DE
154+  84E5 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
155+  84E6 12                                   LD (DE),A                       ; Stick A onto the screen
156+  84E7 14                                   INC D                           ; Goto next line on screen
157+  84E8 2C                                   INC L                           ; Goto next byte of character
158+  84E9 0D                                   DEC C                           ; Decrease the loop counter
159+  84EA 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
160+  84EC D1                                   POP DE
161+  84ED C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   84EE                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  84EE              buffer_buffer:
  2+  84EE 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A1EE
  4+  A1EE              buffer_attr_buffer:
  5+  A1EE 00 00 00...      defs 928                    ; attrs buffer area
  6+  A58E
  7+  A58E              buffer_tmp:
  8+  A58E 00 00            defb 0,0                    ; temp area
  9+  A590
 10+  A590              buffer_updatedlines:
 11+  A590 FF FF FF...      defs 21,255
 12+  A5A5
 13+  A5A5              buffer_updateall:
 14+  A5A5 00               defb 0
 15+  A5A6
 16+  A5A6              ;
 17+  A5A6              ; Stores a line number in the update list
 18+  A5A6              ; Inputs:
 19+  A5A6              ; a - row number
 20+  A5A6              buffer_marklineforupdate:
 21+  A5A6 FE 15            cp 21
 22+  A5A8 D0               ret nc                          ; dont store lines that we shouldn't draw
 23+  A5A9 5F               ld e,a                          ; store in e
 24+  A5AA 06 15            ld b,21
 25+  A5AC 21 90 A5         ld hl,buffer_updatedlines
 26+  A5AF              buffer_marklineforupdate0:
 27+  A5AF 7E               ld a,(hl)                       ; get the line stored in updated lines
 28+  A5B0 BB               cp e                            ; is this the same as the row number passed in?
 29+  A5B1 C8               ret z                           ; if so, don't need to do anything
 30+  A5B2 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 31+  A5B4 C2 B9 A5         jp nz,buffer_marklineforupdate1 ; if not, move to next
 32+  A5B7 73               ld (hl),e                       ; if it is, this spot is empty, so store the row number
 33+  A5B8 C9               ret                             ; and finish
 34+  A5B9              buffer_marklineforupdate1:
 35+  A5B9 23               inc hl
 36+  A5BA 10 F3            djnz buffer_marklineforupdate0
 37+  A5BC C9               ret
 38+  A5BD
 39+  A5BD              ;
 40+  A5BD              ; Zeroes the updated lines list
 41+  A5BD              ;
 42+  A5BD              buffer_clearlist:
 43+  A5BD 06 15            ld b,21
 44+  A5BF 21 90 A5         ld hl,buffer_updatedlines
 45+  A5C2              buffer_clearlist0:
 46+  A5C2 36 FF            ld (hl),255
 47+  A5C4 23               inc hl
 48+  A5C5 10 FB            djnz buffer_clearlist0
 49+  A5C7 C9               ret
 50+  A5C8
 51+  A5C8              ;
 52+  A5C8              ; Copies the buffer to the screen. Use stack.
 53+  A5C8              ; Inputs:
 54+  A5C8              ; a - row number to display - 0 is first line
 55+  A5C8              ;
 56+  A5C8              buffer_bufferlinetoscreen:
 57+  A5C8 4F               ld c,a                          ; store a
 58+  A5C9 ED 5B F6 A6      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 59+  A5CD 83               add a,e                       ; add the row number
 60+  A5CE 11 00 01         ld de,256
 61+  A5D1 CD 3A 80         call utilities_multiply
 62+  A5D4 54 5D            ld de,hl
 63+  A5D6 21 EE 84         ld hl,buffer_buffer
 64+  A5D9 19               add hl,de                   ; add the offset
 65+  A5DA 79               ld a,c                      ; get original row back
 66+  A5DB ED 73 39 A6      ld (buffer_bufferlinetoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
 67+  A5DF D9               exx
 68+  A5E0 0E 00            ld c,0                      ; zero horizontal
 69+  A5E2 47               ld b,a                      ; load the row number into vertical coord
 70+  A5E3 04               inc b
 71+  A5E4 04               inc b                       ; move forward 2 to allow for scores
 72+  A5E5 CD E0 A7         call screen_getcelladdress  ; get the memory into de
 73+  A5E8 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
 74+  A5EB 19               add hl,de
 75+  A5EC              buffer_bufferlinetoscreen0:
 76+  A5EC D9               exx                         ; hl is now buffer
 77+  A5ED 23               inc hl
 78+  A5EE 23               inc hl                      ; move hl forward 2 to skip first two blocks
 79+  A5EF F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
 80+  A5F0 F1               pop af
 81+  A5F1 C1               pop bc
 82+  A5F2 D1               pop de
 83+  A5F3 DD E1            pop ix
 84+  A5F5 D9               exx                         ; hl is now screen
 85+  A5F6 08               ex af,af'
 86+  A5F7 F1               pop af
 87+  A5F8 C1               pop bc
 88+  A5F9 D1               pop de
 89+  A5FA F9               ld sp,hl                    ; sp pointing at screen
 90+  A5FB D5               push de
 91+  A5FC C5               push bc
 92+  A5FD F5               push af
 93+  A5FE 08               ex af,af'
 94+  A5FF D9               exx                         ; hl is now buffer
 95+  A600 DD E5            push ix
 96+  A602 D5               push de
 97+  A603 C5               push bc
 98+  A604 F5               push af
 99+  A605 1E 0E            ld e,14                    ; do another fourteen for right hand side
100+  A607 16 00            ld d,0
101+  A609 19               add hl,de
102+  A60A F9               ld sp,hl                    ; sp pointing at buffer
103+  A60B F1               pop af
104+  A60C C1               pop bc
105+  A60D D1               pop de
106+  A60E DD E1            pop ix
107+  A610                  ;pop ix
108+  A610 D9               exx                         ; hl is now screen
109+  A611 08               ex af,af'
110+  A612 1E 0E            ld e,14
111+  A614 16 00            ld d,0
112+  A616 19               add hl,de
113+  A617 F1               pop af
114+  A618 C1               pop bc
115+  A619 D1               pop de
116+  A61A                  ;pop iy
117+  A61A F9               ld sp,hl                    ; sp pointing at screen
118+  A61B                  ;push iy
119+  A61B D5               push de
120+  A61C C5               push bc
121+  A61D F5               push af
122+  A61E 08               ex af,af'
123+  A61F D9               exx                         ; hl is now buffer
124+  A620 DD E5            push ix
125+  A622 D5               push de
126+  A623 C5               push bc
127+  A624 F5               push af
128+  A625 1E 10            ld e,16
129+  A627 16 00            ld d,0
130+  A629 19               add hl,de
131+  A62A D9               exx                         ; hl is now screen
132+  A62B 1E 0E            ld e,14
133+  A62D 16 00            ld d,0
134+  A62F ED 52            sbc hl,de
135+  A631 24               inc h
136+  A632 7C               ld a,h
137+  A633 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
138+  A635 C2 EC A5         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
139+  A638              buffer_bufferlinetoscreen1:
140+  A638 31 00 00         ld sp,0
141+  A63B D9               exx
142+  A63C C9               ret
143+  A63D
144+  A63D              ;
145+  A63D              ; Copies the buffer to the screen for updated lines. Use stack.
146+  A63D              ; Inputs: none
147+  A63D              ;
148+  A63D              buffer_buffertoscreen:
149+  A63D 3A A5 A5         ld a,(buffer_updateall)      ; get the all update flag
150+  A640 FE 00            cp 0
151+  A642 CA 4E A6         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
152+  A645 CD 6F A6         call buffer_allbuffertoscreen ; otherwise, draw whole screen
153+  A648 21 A5 A5         ld hl,buffer_updateall
154+  A64B 36 00            ld (hl),0                    ; reset flag
155+  A64D C9               ret
156+  A64E              buffer_buffertoscreen2:
157+  A64E 06 15            ld b,21
158+  A650 FD 21 90 A5      ld iy,buffer_updatedlines    ; the location of the updated lines
159+  A654              buffer_buffertoscreen0:
160+  A654 FD 7E 00         ld a,(iy)
161+  A657 FE FF            cp 255
162+  A659 CA 6B A6         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
163+  A65C C5               push bc
164+  A65D FD E5            push iy
165+  A65F F3               di
166+  A660 CD C8 A5         call buffer_bufferlinetoscreen
167+  A663 FB               ei
168+  A664 FD E1            pop iy
169+  A666 C1               pop bc
170+  A667 FD 23            inc iy
171+  A669 10 E9            djnz buffer_buffertoscreen0
172+  A66B              buffer_buffertoscreen1:
173+  A66B CD 83 A6         call buffer_buffertoattrsfast
174+  A66E C9               ret
175+  A66F
176+  A66F              ;
177+  A66F              ; Copies the buffer to the screen. Use stack.
178+  A66F              ; Inputs: none
179+  A66F              ;
180+  A66F              buffer_allbuffertoscreen:
181+  A66F 06 15            ld b,21
182+  A671 3E 00            ld a,0
183+  A673              buffer_allbuffertoscreen0:
184+  A673 C5               push bc
185+  A674 F5               push af
186+  A675 F3               di
187+  A676 CD C8 A5         call buffer_bufferlinetoscreen
188+  A679 FB               ei
189+  A67A F1               pop af
190+  A67B C1               pop bc
191+  A67C 3C               inc a
192+  A67D 10 F4            djnz buffer_allbuffertoscreen0
193+  A67F
194+  A67F CD 83 A6         call buffer_buffertoattrsfast
195+  A682 C9               ret
196+  A683
197+  A683              ;
198+  A683              ; Copies the attrs buffer to screen with the stack
199+  A683              ;
200+  A683              buffer_buffertoattrsfast:
201+  A683 ED 73 F2 A6      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
202+  A687 3A F6 A6         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
203+  A68A 11 20 00         ld de,32
204+  A68D CD 3A 80         call utilities_multiply
205+  A690 54 5D            ld de,hl
206+  A692 21 EE A1         ld hl,buffer_attr_buffer
207+  A695 19               add hl,de                       ; add the offset, start of attr buffer now in hl
208+  A696 D9               exx
209+  A697 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
210+  A69A FD 21 8E A5      ld iy,buffer_tmp
211+  A69E FD 36 00 15      ld (iy),21              ; number of times to loop
212+  A6A2              buffer_buffertoattrsfast0:
213+  A6A2 D9               exx                         ; hl is now buffer
214+  A6A3 23               inc hl
215+  A6A4 23               inc hl                      ; move hl forward 2 to skip first two blocks
216+  A6A5 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
217+  A6A6 F1               pop af
218+  A6A7 C1               pop bc
219+  A6A8 D1               pop de
220+  A6A9 DD E1            pop ix
221+  A6AB D9               exx                         ; hl is now screen
222+  A6AC 08               ex af,af'
223+  A6AD F1               pop af
224+  A6AE C1               pop bc
225+  A6AF D1               pop de
226+  A6B0 F9               ld sp,hl                    ; sp pointing at screen
227+  A6B1 D5               push de
228+  A6B2 C5               push bc
229+  A6B3 F5               push af
230+  A6B4 08               ex af,af'
231+  A6B5 D9               exx                         ; hl is now buffer
232+  A6B6 DD E5            push ix
233+  A6B8 D5               push de
234+  A6B9 C5               push bc
235+  A6BA F5               push af
236+  A6BB 1E 0E            ld e,14                    ; do another fourteen for right hand side
237+  A6BD 16 00            ld d,0
238+  A6BF 19               add hl,de
239+  A6C0 F9               ld sp,hl                    ; sp pointing at buffer
240+  A6C1 F1               pop af
241+  A6C2 C1               pop bc
242+  A6C3 D1               pop de
243+  A6C4 DD E1            pop ix
244+  A6C6 D9               exx                         ; hl is now screen
245+  A6C7 08               ex af,af'
246+  A6C8 1E 0E            ld e,14
247+  A6CA 16 00            ld d,0
248+  A6CC 19               add hl,de
249+  A6CD F1               pop af
250+  A6CE C1               pop bc
251+  A6CF D1               pop de
252+  A6D0 F9               ld sp,hl                    ; sp pointing at screen
253+  A6D1 D5               push de
254+  A6D2 C5               push bc
255+  A6D3 F5               push af
256+  A6D4 08               ex af,af'
257+  A6D5 D9               exx                         ; hl is now buffer
258+  A6D6 DD E5            push ix
259+  A6D8 D5               push de
260+  A6D9 C5               push bc
261+  A6DA F5               push af
262+  A6DB 1E 10            ld e,16
263+  A6DD 16 00            ld d,0
264+  A6DF 19               add hl,de
265+  A6E0 D9               exx                         ; hl is now screen
266+  A6E1 11 12 00         ld de,18
267+  A6E4 19               add hl,de
268+  A6E5 FD 7E 00         ld a,(iy)
269+  A6E8 3D               dec a
270+  A6E9 FE 00            cp 0
271+  A6EB FD 77 00         ld (iy),a
272+  A6EE C2 A2 A6         jp nz,buffer_buffertoattrsfast0 ; do another row
273+  A6F1              buffer_buffertoattrsfast1:
274+  A6F1 31 00 00         ld sp,0
275+  A6F4 D9               exx
276+  A6F5 C9               ret
# file closed: screen/buffer.asm
 24   A6F6                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A6F6              screen_offset:
  2+  A6F6 00               defb 0                      ; offset from top of screen in lines
  3+  A6F7
  4+  A6F7              screen_tmp:
  5+  A6F7 00 00            defb 0,0                      ; temporary memory
  6+  A6F9
  7+  A6F9              screen_setscorecolours:
  8+  A6F9 21 33 B2         ld hl,score_colours
  9+  A6FC 11 00 58         ld de,22528                     ; attrs here
 10+  A6FF 01 40 00         ld bc,64
 11+  A702 ED B0            ldir
 12+  A704 C9               ret
 13+  A705
 14+  A705              screen_sethighscorecolours:
 15+  A705 21 73 B2         ld hl,high_score_colours
 16+  A708 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A70B 01 20 00         ld bc,32
 18+  A70E ED B0            ldir
 19+  A710 C9               ret
 20+  A711
 21+  A711              ; Draw the screen
 22+  A711              ; Inputs:
 23+  A711              ; none
 24+  A711              ; Notes:
 25+  A711              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A711              screen_draw:
 27+  A711                  ;call clear_screen
 28+  A711 0E 00            ld c,0                      ; horiz
 29+  A713 06 00            ld b,0                      ; vert, 0 at top
 30+  A715 DD 21 E0 AC      ld ix,level01               ; point ix at level data
 31+  A719 FD 21 EE A1      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A71D              screen_draw0:
 33+  A71D DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A720 C5               push bc                     ; store bc, contains loop count
 35+  A721 CD 83 A8         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A724 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A725 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A728 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A72B CD 78 A8         call screen_getblock        ; get the block data into hl
 40+  A72E CD 5E A8         call screen_showchar        ; show this character here
 41+  A731 C1               pop bc                      ; get the loop counter back
 42+  A732 DD 23            inc ix                      ; increment level location
 43+  A734 FD 23            inc iy                      ; increment attr location
 44+  A736 0C               inc c                       ; increment horiz
 45+  A737 79               ld a,c
 46+  A738 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A73A C2 1D A7         jp nz,screen_draw0          ; if not, loop
 48+  A73D 0E 00            ld c,0                      ; if so, reset horiz
 49+  A73F 04               inc b                       ; increment vertical
 50+  A740 78               ld a,b
 51+  A741 FE 1D            cp 29                       ; check if at bottom
 52+  A743 C2 1D A7         jp nz,screen_draw0          ; if not, loop
 53+  A746 21 F7 A6         ld hl, screen_tmp
 54+  A749 36 09            ld (hl),9                   ; load the block number into memory
 55+  A74B DD 21 95 B0      ld ix,level01rocks          ; rock memory
 56+  A74F CD B0 A7         call screen_initobjects     ; draw rocks
 57+  A752 21 F7 A6         ld hl, screen_tmp
 58+  A755 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A757 DD 21 95 B1      ld ix,level01missiles       ; missile memory
 60+  A75B CD B0 A7         call screen_initobjects     ; draw missiles
 61+  A75E 21 F7 A6         ld hl, screen_tmp
 62+  A761 36 08            ld (hl),08                  ; load the block number into memory
 63+  A763 DD 21 0E B2      ld ix,level01diamonds       ; diamond memory
 64+  A767 CD B0 A7         call screen_initobjects     ; draw diamonds
 65+  A76A 21 F7 A6         ld hl, screen_tmp
 66+  A76D 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A76F DD 21 1E B2      ld ix,level01gems           ; gems memory
 68+  A773 CD B0 A7         call screen_initobjects     ; draw gems
 69+  A776 CD 7D A7         call screen_setuptext       ; draws text on the screen
 70+  A779 CD 60 BF         call scores_printscores     ; print the current scores
 71+  A77C C9               ret
 72+  A77D
 73+  A77D              ;
 74+  A77D              ; Sets up text on the screen
 75+  A77D              ;
 76+  A77D              screen_setuptext:
 77+  A77D CD 82 BF         call scores_showtable
 78+  A780 CD 05 A7         call screen_sethighscorecolours
 79+  A783 21 D6 80         ld hl, string_score1
 80+  A786 CD A6 84         call string_print
 81+  A789 21 DF 80         ld hl, string_scorenumbers1
 82+  A78C CD A6 84         call string_print
 83+  A78F 21 E8 80         ld hl, string_company
 84+  A792 CD A6 84         call string_print
 85+  A795 21 F9 80         ld hl, string_score2
 86+  A798 CD A6 84         call string_print
 87+  A79B 21 02 81         ld hl, string_scorenumbers2
 88+  A79E CD A6 84         call string_print
 89+  A7A1 21 EE 80         ld hl, string_credits
 90+  A7A4 CD A6 84         call string_print
 91+  A7A7 CD F9 A6         call screen_setscorecolours
 92+  A7AA C9               ret
 93+  A7AB
 94+  A7AB              ;
 95+  A7AB              ; Sets a line of colours
 96+  A7AB              ; Inputs:
 97+  A7AB              ; a - colour to set
 98+  A7AB              ; b - number to set
 99+  A7AB              ; de - start memory location
100+  A7AB              ;
101+  A7AB              screen_setcolours:
102+  A7AB 12               ld (de),a
103+  A7AC 13               inc de
104+  A7AD 10 FC            djnz screen_setcolours
105+  A7AF C9               ret
106+  A7B0
107+  A7B0              ;
108+  A7B0              ; Draw initial object positions
109+  A7B0              ; Inputs:
110+  A7B0              ; ix - memory location of objects
111+  A7B0              ; a - graphic
112+  A7B0              screen_initobjects:
113+  A7B0 DD 4E 00         ld c,(ix)                   ; get the horiz coord
114+  A7B3 79               ld a,c
115+  A7B4 FE FF            cp 255
116+  A7B6 CA DF A7         jp z,screen_initobjects2
117+  A7B9 DD 23            inc ix                      ; move to next
118+  A7BB DD 46 00         ld b,(ix)                   ; get the vert coord
119+  A7BE DD 23            inc ix
120+  A7C0 CD F1 A7         call screen_getcellattradress ; get the memory address of b,c attr into de
121+  A7C3 D5               push de
122+  A7C4 3A F7 A6         ld a,(screen_tmp)                  ; get the block number back
123+  A7C7 CD 83 A8         call screen_getattr         ; get the memory location for this cell's attr into hl
124+  A7CA D1               pop de
125+  A7CB 7E               ld a,(hl)                   ; get the attr value at the address
126+  A7CC 12               ld (de),a                   ; load the attr into memory
127+  A7CD 3A F7 A6         ld a,(screen_tmp)                  ; get the block number back
128+  A7D0 CD 78 A8         call screen_getblock        ; get the block data into hl
129+  A7D3 CD 5E A8         call screen_showchar        ; show this character here
130+  A7D6
131+  A7D6              screen_initobjects1:
132+  A7D6 DD 23            inc ix                      ; move past state
133+  A7D8 DD 23            inc ix
134+  A7DA DD 23            inc ix                      ; move past mem
135+  A7DC C3 B0 A7         jp screen_initobjects
136+  A7DF              screen_initobjects2:
137+  A7DF C9               ret
138+  A7E0
139+  A7E0
140+  A7E0              ;
141+  A7E0              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
142+  A7E0              ; Inputs:
143+  A7E0              ; bc: coords
144+  A7E0              ; Outputs:
145+  A7E0              ; de: memory location
146+  A7E0              ;
147+  A7E0              screen_getcelladdress:
148+  A7E0 78               ld a,b      ; vertical position.
149+  A7E1 E6 18            and 24      ; which segment, 0, 1 or 2?
150+  A7E3 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
151+  A7E5 57               ld d,a      ; this is our high byte.
152+  A7E6 78               ld a,b      ; what was that vertical position again?
153+  A7E7 E6 07            and 7       ; which row within segment?
154+  A7E9 0F               rrca        ; multiply row by 32.
155+  A7EA 0F               rrca
156+  A7EB 0F               rrca
157+  A7EC 5F               ld e,a      ; low byte.
158+  A7ED 79               ld a,c      ; add on y coordinate.
159+  A7EE 83               add a,e     ; mix with low byte.
160+  A7EF 5F               ld e,a      ; address of screen position in de.
161+  A7F0 C9               ret
162+  A7F1
163+  A7F1              ;
164+  A7F1              ; Calculate buffer address of attribute for character at (b, c).
165+  A7F1              ; Inputs:
166+  A7F1              ; bc: coords
167+  A7F1              ; Outputs:
168+  A7F1              ; de: memory location
169+  A7F1              ;
170+  A7F1              screen_getcellattradress:
171+  A7F1 11 EE A1         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
172+  A7F4 69               ld l,c      ; x position.
173+  A7F5 26 00            ld h,0      ; 0 h
174+  A7F7 19               add hl,de
175+  A7F8 54 5D            ld de,hl    ; horiz done
176+  A7FA 78               ld a,b      ; do vert
177+  A7FB D5               push de
178+  A7FC C5               push bc
179+  A7FD 11 20 00         ld de,32
180+  A800 CD 3A 80         call utilities_multiply
181+  A803 C1               pop bc
182+  A804 D1               pop de
183+  A805 19               add hl,de
184+  A806 54 5D            ld de,hl    ; vert done
185+  A808 C9               ret
186+  A809
187+  A809              ;
188+  A809              ; Calculate buffer address of attribute for character at (b, c).
189+  A809              ; Inputs:
190+  A809              ; bc: coords
191+  A809              ; Outputs:
192+  A809              ; de: memory location
193+  A809              ;
194+  A809              screen_getscreenattradress:
195+  A809 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
196+  A80C 69               ld l,c      ; x position.
197+  A80D 26 00            ld h,0      ; 0 h
198+  A80F 19               add hl,de
199+  A810 54 5D            ld de,hl    ; horiz done
200+  A812 78               ld a,b      ; do vert
201+  A813 D5               push de
202+  A814 C5               push bc
203+  A815 11 20 00         ld de,32
204+  A818 CD 3A 80         call utilities_multiply
205+  A81B C1               pop bc
206+  A81C D1               pop de
207+  A81D 19               add hl,de
208+  A81E 54 5D            ld de,hl    ; vert done
209+  A820 C9               ret
210+  A821
211+  A821              ;
212+  A821              ; Gets the attr memory location for a screen coord
213+  A821              ; Will overwrite bc
214+  A821              ; Inputs:
215+  A821              ; bc - screen coords
216+  A821              ; Outputs:
217+  A821              ; de - memory location
218+  A821              ; bc - character coords
219+  A821              ;
220+  A821              screen_getattraddressfromscreencoords:
221+  A821 78               ld a,b                          ; get the player block coords of current block
222+  A822 E6 F8            and 248                         ; find closest multiple of eight
223+  A824 0F               rrca
224+  A825 0F               rrca
225+  A826 0F               rrca                ; divide by 8
226+  A827 47               ld b,a
227+  A828 79               ld a,c
228+  A829 48               ld c,b                         ; swap b and c
229+  A82A E6 F8            and 248
230+  A82C 0F               rrca
231+  A82D 0F               rrca
232+  A82E 0F               rrca                ; divide by 8
233+  A82F 47               ld b,a
234+  A830 CD F1 A7         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
235+  A833 C9               ret
236+  A834
237+  A834
238+  A834              ; Gets the nearest cell coords for a screen coord
239+  A834              ; Will overwrite bc
240+  A834              ; Inputs:
241+  A834              ; bc - screen coords
242+  A834              ; Outputs:
243+  A834              ; bc - character coords
244+  A834              ;
245+  A834              screen_getcharcoordsfromscreencoords:
246+  A834 78               ld a,b                          ; get the player block coords of current block
247+  A835 E6 F8            and 248                         ; find closest multiple of eight
248+  A837 0F               rrca
249+  A838 0F               rrca
250+  A839 0F               rrca                ; divide by 8
251+  A83A 47               ld b,a
252+  A83B 79               ld a,c
253+  A83C 48               ld c,b                         ; swap b and c
254+  A83D E6 F8            and 248
255+  A83F 0F               rrca
256+  A840 0F               rrca
257+  A841 0F               rrca                ; divide by 8
258+  A842 47               ld b,a
259+  A843 C9               ret
260+  A844
261+  A844              ; Gets the screen coords for a cell coord
262+  A844              ; Will overwrite bc
263+  A844              ; Inputs:
264+  A844              ; bc - char coords
265+  A844              ; Outputs:
266+  A844              ; bc - screen coords
267+  A844              ;
268+  A844              screen_getscreencoordsfromcharcoords:
269+  A844 78               ld a,b                          ; get the player block coords of current block
270+  A845 07               rlca
271+  A846 07               rlca
272+  A847 07               rlca                ; multiply by 8
273+  A848 47               ld b,a
274+  A849 79               ld a,c
275+  A84A 48               ld c,b                         ; swap b and c
276+  A84B 07               rlca
277+  A84C 07               rlca
278+  A84D 07               rlca                ; divide by 8
279+  A84E 47               ld b,a
280+  A84F C9               ret
281+  A850
282+  A850              ;
283+  A850              ; Get buffer address for a character at b,c - b vert
284+  A850              ; Buffer memory is stored as sequential block
285+  A850              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
286+  A850              ; Inputs:
287+  A850              ; bc - coords
288+  A850              ; Outputs:
289+  A850              ; de - memory location of first byte
290+  A850              screen_getbufferaddress:
291+  A850 21 EE 84         ld hl, buffer_buffer    ; first get screen buffer start
292+  A853 50               ld d,b                  ; then work out vertical offset
293+  A854 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
294+  A856 19               add hl,de               ; add to base
295+  A857 59               ld e,c                  ; then add horizontal offset (c)
296+  A858 16 00            ld d,0
297+  A85A 19               add hl,de               ; add to base
298+  A85B 54 5D            ld de,hl
299+  A85D C9               ret
300+  A85E
301+  A85E              ;
302+  A85E              ; Display character hl at (b, c) to buffer.
303+  A85E              ; Stored sequentially
304+  A85E              ; Inputs:
305+  A85E              ; hl: block address
306+  A85E              ; bc: coords
307+  A85E              ;
308+  A85E              screen_showchar:
309+  A85E 3E 00            ld a,0
310+  A860 E5               push hl
311+  A861 CD 50 A8         call screen_getbufferaddress ; get the current screen buffer pointer
312+  A864 E1               pop hl
313+  A865 06 08            ld b,8              ; number of pixels high.
314+  A867              screen_showchar0:
315+  A867 7E               ld a,(hl)           ; source graphic.
316+  A868 12               ld (de),a           ; transfer to screen.
317+  A869 23               inc hl              ; next piece of data.
318+  A86A E5               push hl             ; store hl
319+  A86B 62 6B            ld hl,de            ; put de in hl
320+  A86D 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
321+  A86F 16 00            ld d,0
322+  A871 19               add hl,de              ; add de to hl
323+  A872 54 5D            ld de,hl            ; load back to de
324+  A874 E1               pop hl              ; restore hl
325+  A875
326+  A875 10 F0            djnz screen_showchar0 ; repeat
327+  A877 C9               ret
328+  A878
329+  A878
330+  A878              ;
331+  A878              ; Get cell graphic.
332+  A878              ; Inputs:
333+  A878              ; a: block
334+  A878              ; Outputs:
335+  A878              ; hl: memory
336+  A878              ;
337+  A878              screen_getblock:
338+  A878 07               rlca                        ; multiply block number by eight.
339+  A879 07               rlca
340+  A87A 07               rlca
341+  A87B 5F               ld e,a                      ; displacement to graphic address.
342+  A87C 16 00            ld d,0                      ; no high byte.
343+  A87E 21 93 B2         ld hl,sprites               ; address of character blocks.
344+  A881 19               add hl,de                   ; point to block.
345+  A882 C9               ret
346+  A883
347+  A883              ;
348+  A883              ; Get cell attribute.
349+  A883              ; Inputs:
350+  A883              ; a: block
351+  A883              ; Outputs:
352+  A883              ; hl: memory
353+  A883              ;
354+  A883              screen_getattr:
355+  A883 5F               ld e,a                      ; displacement to attribute address.
356+  A884 16 00            ld d,0                      ; no high byte.
357+  A886 21 33 B3         ld hl,sprite_attrs          ; address of block attributes.
358+  A889 19               add hl,de                   ; point to attribute.
359+  A88A C9               ret
360+  A88B
361+  A88B              ;
362+  A88B              ; Checks whether a character block has anything in it
363+  A88B              ; Inputs:
364+  A88B              ; bc - char coords
365+  A88B              ; Outputs:
366+  A88B              ; a - 1, empty
367+  A88B              screen_ischarempty:
368+  A88B CD 50 A8         call screen_getbufferaddress ; get the current screen buffer pointer
369+  A88E 06 08            ld b,8                      ; check 8 rows
370+  A890              screen_ischarempty2:
371+  A890 1A               ld a,(de)                   ; check line
372+  A891 FE 00            cp 0
373+  A893 C2 A1 A8         jp nz,screen_ischarempty1   ; if not zero, jump out with false
374+  A896 21 20 00         ld hl,32
375+  A899 19               add hl,de
376+  A89A 54 5D            ld de,hl                    ; move to next row
377+  A89C 10 F2            djnz screen_ischarempty2
378+  A89E              screen_ischarempty0:
379+  A89E 3E 01            ld a,1
380+  A8A0 C9               ret
381+  A8A1              screen_ischarempty1:
382+  A8A1 3E 00            ld a,0
383+  A8A3 C9               ret
384+  A8A4
385+  A8A4              ;
386+  A8A4              ; Copies a block from one place to another directly underneath, leaves the original empty
387+  A8A4              ; Inputs:
388+  A8A4              ; bc - coords of block to copy from
389+  A8A4              screen_copyblockdown
390+  A8A4 CD 50 A8         call screen_getbufferaddress ; get the current screen buffer pointer for source
391+  A8A7 06 08            ld b,8                      ; copy 8 rows
392+  A8A9              screen_copyblock0:
393+  A8A9 1A               ld a,(de)                    ; get what we're copying
394+  A8AA 08               ex af,af'
395+  A8AB 3E 00            ld a,0
396+  A8AD 12               ld (de),a                    ; replace with empty
397+  A8AE 08               ex af,af'
398+  A8AF 14               inc d                        ; add 256 to get to the next row
399+  A8B0 12               ld (de),a                    ; copy to the next row
400+  A8B1 15               dec d
401+  A8B2 21 20 00         ld hl,32
402+  A8B5 19               add hl,de                       ; return back to source, next row down
403+  A8B6 54 5D            ld de,hl
404+  A8B8 10 EF            djnz screen_copyblock0
405+  A8BA C9               ret
406+  A8BB
407+  A8BB              ;
408+  A8BB              ; Returns the first byte of a character. Useful for figuring out what's there
409+  A8BB              ; Inputs:
410+  A8BB              ; bc - coords
411+  A8BB              ; Outputs:
412+  A8BB              ; a - first byte
413+  A8BB              ;
414+  A8BB              screen_getcharfirstbyte:
415+  A8BB CD 50 A8         call screen_getbufferaddress ; get the current screen buffer pointer for source
416+  A8BE 1A               ld a,(de)
417+  A8BF C9               ret
418+  A8C0
# file closed: screen/screen.asm
 25   A8C0                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A8C0              ;
  2+  A8C0              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A8C0              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A8C0              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A8C0              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A8C0              ; routine takes care of all the shifting itself. This means that sprite
  7+  A8C0              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A8C0              ; space they would require in pre-shifted form.
  9+  A8C0              ; Inputs:
 10+  A8C0              ; hl - sprite data
 11+  A8C0              ; bc - screen coords
 12+  A8C0              ;
 13+  A8C0              sprites_drawsprite7:
 14+  A8C0 EE 07            xor 7               ; complement last 3 bits.
 15+  A8C2 3C               inc a               ; add one for luck!
 16+  A8C3              sprites_drawsprite3:
 17+  A8C3 CB 11            rl c                ; ...into middle byte...
 18+  A8C5 CB 12            rl d                ; ...and finally into left character cell.
 19+  A8C7 3D               dec a               ; count shifts we've done.
 20+  A8C8 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A8CA                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A8CA 79               ld a,c              ; left edge of image is currently in e.
 23+  A8CB 4A               ld c,d              ; put right edge there instead.
 24+  A8CC 57               ld d,a              ; and the left edge back into c.
 25+  A8CD 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A8CF              sprites_drawsprite:
 27+  A8CF ED 43 34 A9      ld (dispx),bc       ; store coords in dispx for now.
 28+  A8D3 E5               push hl
 29+  A8D4 CD 12 A9         call sprites_scadd  ; calculate screen address.
 30+  A8D7 E1               pop hl
 31+  A8D8 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A8DA              sprites_drawsprite1:
 33+  A8DA 08               ex af,af'           ; store loop counter.
 34+  A8DB D5               push de             ; store screen address.
 35+  A8DC 4E               ld c,(hl)           ; first sprite graphic.
 36+  A8DD 23               inc hl              ; increment poiinter to sprite data.
 37+  A8DE 22 36 A9         ld (sprtmp),hl      ; store it for later.
 38+  A8E1 16 00            ld d,0              ; blank right byte for now.
 39+  A8E3 78               ld a,b              ; b holds y position.
 40+  A8E4 E6 07            and 7               ; how are we straddling character cells?
 41+  A8E6 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A8E8 FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A8EA 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A8EC A7               and a               ; oops, carry flag is set so clear it.
 45+  A8ED              sprites_drawsprite2:
 46+  A8ED CB 19            rr c                ; rotate left byte right...
 47+  A8EF CB 1A            rr d                ; ...into right byte.
 48+  A8F1 3D               dec a               ; one less shift to do.
 49+  A8F2 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A8F4              sprites_drawsprite0:
 51+  A8F4 E1               pop hl              ; pop screen address from stack.
 52+  A8F5 7E               ld a,(hl)           ; what's there already.
 53+  A8F6 A9               xor c               ; merge in image data.
 54+  A8F7 77               ld (hl),a           ; place onto screen.
 55+  A8F8 23               inc hl
 56+  A8F9 7E               ld a,(hl)           ; what's already there.
 57+  A8FA AA               xor d               ; right edge of sprite image data.
 58+  A8FB 77               ld (hl),a           ; plonk it on screen.
 59+  A8FC 3A 34 A9         ld a,(dispx)        ; vertical coordinate.
 60+  A8FF 3C               inc a               ; next line down.
 61+  A900 32 34 A9         ld (dispx),a        ; store new position.
 62+  A903 2B               dec hl
 63+  A904 11 20 00         ld de,32            ; add 32 to get to the next row
 64+  A907 19               add hl,de           ; add 32
 65+  A908              sprites_drawsprite6:
 66+  A908 EB               ex de,hl            ; screen address in de.
 67+  A909 2A 36 A9         ld hl,(sprtmp)      ; restore graphic address.
 68+  A90C 08               ex af,af'           ; restore loop counter.
 69+  A90D 3D               dec a               ; decrement it.
 70+  A90E C2 DA A8         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 71+  A911 C9               ret                 ; job done.
 72+  A912
 73+  A912              ;
 74+  A912              ; This routine returns a buffer address for (c, b) in de (c vert).
 75+  A912              ; For example: 0,0 will be at memory offset 0
 76+  A912              ; 1,0 (1 down) will be at memory offset 1
 77+  A912              ; 0,7 will be at memory offset 0
 78+  A912              ; 9,1 will be at memory offset 8+1
 79+  A912              ; 8,0 will be at memory offset 256
 80+  A912              ; 9,0 will be at memory offset 257
 81+  A912              ; Outputs:
 82+  A912              ; de - coords
 83+  A912              ;
 84+  A912              sprites_scadd:
 85+  A912 79               ld a,c               ; calculate vertical offset
 86+  A913 E6 F8            and 248             ;  to get nearest multiple of 8
 87+  A915 0F               rrca
 88+  A916 0F               rrca
 89+  A917 0F               rrca                ; divide by 8
 90+  A918 67               ld h,a
 91+  A919 78               ld a,b               ; calculate horizontal offset
 92+  A91A E6 F8            and 248             ;  to get nearest multiple of 8
 93+  A91C 0F               rrca
 94+  A91D 0F               rrca
 95+  A91E 0F               rrca                ; divide by 8
 96+  A91F 6F               ld l,a
 97+  A920 C5               push bc             ; store the screen coords
 98+  A921 44 4D            ld bc,hl            ; load bc with the character coords
 99+  A923 CD 50 A8         call screen_getbufferaddress
100+  A926 C1               pop bc              ; get back screen coords, de is now memory of character
101+  A927 79               ld a,c              ; now add the vertical within the cell
102+  A928 E6 07            and 7
103+  A92A 0F               rrca                ; multiply by 32.
104+  A92B 0F               rrca
105+  A92C 0F               rrca
106+  A92D 6F               ld l,a
107+  A92E 26 00            ld h,0
108+  A930 19               add hl,de
109+  A931 54 5D            ld de,hl
110+  A933 C9               ret
111+  A934
112+  A934 00           dispx   defb 0           ; general-use coordinates.
113+  A935 00           dispy   defb 0
114+  A936 00 00        sprtmp  defb 0,0           ; sprite temporary address.
115+  A938
# file closed: screen/sprites.asm
 26   A938                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  A938              ;
  2+  A938              ; Draws the title screen
  3+  A938              ;
  4+  A938              titlescreen_show:
  5+  A938 CD B0 A9         call titlescreen_init
  6+  A93B CD 59 A9         call titlescreen_drawtitle
  7+  A93E 3E FA            ld a,250                              ; wait for 200 frames
  8+  A940 CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
  9+  A943 7B               ld a,e
 10+  A944 FE 01            cp 1                                  ; was anything pressed?
 11+  A946 C8               ret z                                 ; end titlescreen if so
 12+  A947
 13+  A947 CD C3 A9         call titlescreen_alt_init             ; otherwise, draw alt screen
 14+  A94A CD 75 A9         call titlescreen_alt_drawtitle
 15+  A94D 3E FA            ld a,250                              ; wait for 200 frames
 16+  A94F CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 17+  A952 7B               ld a,e
 18+  A953 FE 01            cp 1                                  ; was anything pressed?
 19+  A955 C2 38 A9         jp nz,titlescreen_show                ; start again if not
 20+  A958 C9               ret
 21+  A959
 22+  A959              ;
 23+  A959              ; Draws the iconic logo
 24+  A959              ;
 25+  A959              titlescreen_drawtitle:
 26+  A959 06 66            ld b,102              ; number of points
 27+  A95B DD 21 D0 A9      ld ix,titlescreen_logo_data
 28+  A95F              titlescreen_drawtitle0:
 29+  A95F C5               push bc
 30+  A960 DD 4E 00         ld c,(ix)                   ; got horiz
 31+  A963 DD 23            inc ix
 32+  A965 DD 46 00         ld b,(ix)                   ; got vert
 33+  A968 DD 23            inc ix
 34+  A96A CD 09 A8         call screen_getscreenattradress ; memory in de
 35+  A96D 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 36+  A96E 3E 13            ld a,19
 37+  A970 12               ld (de),a
 38+  A971 C1               pop bc
 39+  A972 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 40+  A974 C9               ret
 41+  A975
 42+  A975              ;
 43+  A975              ; Draws the alternate title screen
 44+  A975              ;
 45+  A975              titlescreen_alt_drawtitle:
 46+  A975 21 25 81         ld hl,string_alttitlescreen_1
 47+  A978 CD A6 84         call string_print
 48+  A97B 21 31 81         ld hl,string_alttitlescreen_2
 49+  A97E CD A6 84         call string_print
 50+  A981 21 2C 82         ld hl,string_alttitlescreen_3
 51+  A984 CD A6 84         call string_print
 52+  A987 06 20            ld b,32
 53+  A989 3E 43            ld a,67
 54+  A98B 11 00 58         ld de,22528                         ; top row attrs here
 55+  A98E CD AB A7         call screen_setcolours
 56+  A991 06 20            ld b,32
 57+  A993 3E 46            ld a,70
 58+  A995 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 59+  A998 CD AB A7         call screen_setcolours
 60+  A99B 06 20            ld b,32
 61+  A99D 3E 43            ld a,67
 62+  A99F 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 63+  A9A2 CD AB A7         call screen_setcolours
 64+  A9A5 06 20            ld b,32
 65+  A9A7 3E 42            ld a,66
 66+  A9A9 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 67+  A9AC CD AB A7         call screen_setcolours
 68+  A9AF C9               ret
 69+  A9B0
 70+  A9B0              ;
 71+  A9B0              ; Initialises the screen
 72+  A9B0              ;
 73+  A9B0              titlescreen_init:
 74+  A9B0              ; We want a black screen.
 75+  A9B0 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 76+  A9B2                                      ; bright (64).
 77+  A9B2 CD 67 80         call utilities_clearscreen
 78+  A9B5 32 8D 5C         ld (23693),a        ; set our screen colours.
 79+  A9B8 3E 01            ld a,1              ; 2 is the code for red.
 80+  A9BA D3 FE            out (254),a         ; write to port 254.
 81+  A9BC
 82+  A9BC 21 0B 81         ld hl,string_titlescreen_copyright
 83+  A9BF CD A6 84         call string_print
 84+  A9C2
 85+  A9C2 C9               ret
 86+  A9C3
 87+  A9C3              ;
 88+  A9C3              ; Initialises the screen
 89+  A9C3              ;
 90+  A9C3              titlescreen_alt_init:
 91+  A9C3              ; We want a black screen.
 92+  A9C3 3E 47            ld a,71             ; white ink (7) on black paper (0),
 93+  A9C5                                      ; bright (64).
 94+  A9C5 CD 67 80         call utilities_clearscreen
 95+  A9C8 32 8D 5C         ld (23693),a        ; set our screen colours.
 96+  A9CB 3E 00            ld a,0              ; 2 is the code for red.
 97+  A9CD D3 FE            out (254),a         ; write to port 254.
 98+  A9CF
 99+  A9CF C9               ret
100+  A9D0
101+  A9D0              ;
102+  A9D0              ; Horiz, vert
103+  A9D0              ;
104+  A9D0              titlescreen_logo_data:
105+  A9D0 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
105+  A9D4 0A 00 0C 00
105+  A9D8 0F 00 11 00
105+  A9DC 12 00 13 00
106+  A9E0 09 01 0C 01      defb 9,1,12,1,15,1,17,1
106+  A9E4 0F 01 11 01
107+  A9E8 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
107+  A9EC 0D 02 0E 02
107+  A9F0 0F 02 11 02
107+  A9F4 12 02 13 02
108+  A9F8 09 03 0C 03      defb 9,3,12,3,15,3,17,3
108+  A9FC 0F 03 11 03
109+  AA00 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
109+  AA04 0F 04 11 04
109+  AA08 12 04 13 04
110+  AA0C 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
110+  AA10 02 06 03 06
110+  AA14 04 06 05 06
110+  AA18 06 06 07 06
110+  AA1C 08 06 09 06
110+  AA20 0A 06 0B 06
111+  AA24 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
111+  AA28 12 06 13 06
111+  AA2C 14 06 15 06
111+  AA30 16 06 17 06
111+  AA34 18 06 19 06
111+  AA38 1A 06 1B 06
112+  AA3C 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20
112+  AA40 02 09 02 0A
112+  AA44 02 0B 02 0C
112+  AA48 02 0D 02 0E
112+  AA4C 02 0F 02 10
112+  AA50 02 11 02 12
112+  AA54 02 13 02 14
113+  AA58 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20
113+  AA5C 19 09 19 0A
113+  AA60 19 0B 19 0C
113+  AA64 19 0D 19 0E
113+  AA68 19 0F 19 10
113+  AA6C 19 11 19 12
113+  AA70 19 13 19 14
114+  AA74 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
114+  AA78 05 0B 06 0B
114+  AA7C 07 0B 08 0B
114+  AA80 09 0B 0A 0B
114+  AA84 0B 0B
115+  AA86 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
115+  AA8A 0B 09 0B 0A
116+  AA8E 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19,16,20
116+  AA92 10 10 10 11
116+  AA96 10 12 10 13
116+  AA9A 10 14
117+  AA9C
# file closed: screen/titlescreen.asm
 27   AA9C                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  AA9C              ;
  2+  AA9C              ; Draws the life remaining screen
  3+  AA9C              ;
  4+  AA9C              lifescreen_draw:
  5+  AA9C CD E2 AA         call lifescreen_init
  6+  AA9F
  7+  AA9F 3A A3 B8         ld a,(game_currentplayer)             ; get the current player
  8+  AAA2 C6 30            add 48                                ; add 48 to get char
  9+  AAA4 21 32 83         ld hl,string_lifescreen_player+10
 10+  AAA7 77               ld (hl),a                             ; load this to the string we're about to show
 11+  AAA8
 12+  AAA8 21 28 83         ld hl,string_lifescreen_player
 13+  AAAB CD A6 84         call string_print
 14+  AAAE
 15+  AAAE 3A DA B8         ld a,(player+9)                       ; get the current player lives
 16+  AAB1 C6 30            add 48                                ; add 48 to get the character
 17+  AAB3 FE 31            cp 49
 18+  AAB5 C2 C8 AA         jp nz,lifescreen_draw0
 19+  AAB8 21 42 83         ld hl,string_lifescreen_lastman
 20+  AABB
 21+  AABB 06 08            ld b,8
 22+  AABD 3E 0A            ld a,10                                ; set red
 23+  AABF 11 6C 58         ld de,22528+108                        ; attrs here
 24+  AAC2 CD AB A7         call screen_setcolours
 25+  AAC5
 26+  AAC5 C3 CF AA         jp lifescreen_draw1
 27+  AAC8              lifescreen_draw0:
 28+  AAC8 21 37 83         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  AACB 77               ld (hl),a                             ; load this to the string we're about to show
 30+  AACC 21 35 83         ld hl,string_lifescreen_lives
 31+  AACF              lifescreen_draw1:
 32+  AACF CD A6 84         call string_print
 33+  AAD2
 34+  AAD2 3E 86            ld a,134
 35+  AAD4 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AAD7 06 0A            ld b,10
 37+  AAD9 CD AB A7         call screen_setcolours
 38+  AADC
 39+  AADC 3E 64            ld a,100                              ; wait for 200 frames
 40+  AADE CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 41+  AAE1
 42+  AAE1 C9               ret
 43+  AAE2
 44+  AAE2              ;
 45+  AAE2              ; Initialises the screen
 46+  AAE2              ;
 47+  AAE2              lifescreen_init:
 48+  AAE2              ; We want a blue screen.
 49+  AAE2                  ;call $0D6B
 50+  AAE2 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 51+  AAE4                                      ; bright (64).
 52+  AAE4 CD 67 80         call utilities_clearscreen
 53+  AAE7 32 8D 5C         ld (23693),a        ; set our screen colours.
 54+  AAEA 3E 01            ld a,1              ; 1 is the code for blue.
 55+  AAEC D3 FE            out (254),a         ; write to port 254.
 56+  AAEE                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 57+  AAEE
 58+  AAEE C9               ret
# file closed: screen/lifescreen.asm
 28   AAEF                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AAEF              ;
  2+  AAEF              ; Draws the game over screen
  3+  AAEF              ;
  4+  AAEF              gameover_draw:
  5+  AAEF CD 96 BF         call scores_processhighscores
  6+  AAF2
  7+  AAF2              gameover_draw0:
  8+  AAF2 CD 32 AB         call gameover_enterhighscores
  9+  AAF5
 10+  AAF5 CD D0 AB         call gameover_init
 11+  AAF8
 12+  AAF8 21 4D 83         ld hl,string_gameoverscreen_gameover
 13+  AAFB CD A6 84         call string_print
 14+  AAFE
 15+  AAFE 21 59 83         ld hl,string_gameoverscreen_copyright
 16+  AB01 CD A6 84         call string_print
 17+  AB04
 18+  AB04 CD 15 AB         call gameover_commontext
 19+  AB07
 20+  AB07 06 0B            ld b,11
 21+  AB09 3E 42            ld a,66
 22+  AB0B 11 2B 58         ld de,22528+43                         ; attrs here
 23+  AB0E CD AB A7         call screen_setcolours
 24+  AB11 CD 47 80         call utilities_waitforkey   ; wait for keypress
 25+  AB14
 26+  AB14 C9               ret
 27+  AB15
 28+  AB15              ;
 29+  AB15              ; Draws text shared by the game over and high score screens
 30+  AB15              ;
 31+  AB15              gameover_commontext:
 32+  AB15 CD 7D A7         call screen_setuptext       ; show scores
 33+  AB18 CD 60 BF         call scores_printscores     ; print the current scores
 34+  AB1B
 35+  AB1B 21 87 83         ld hl,string_gameover_credits
 36+  AB1E CD A6 84         call string_print
 37+  AB21
 38+  AB21 21 73 83         ld hl,string_gameoverscreen_bestscores
 39+  AB24 CD A6 84         call string_print
 40+  AB27
 41+  AB27 06 20            ld b,32
 42+  AB29 3E 45            ld a,69
 43+  AB2B 11 C0 5A         ld de,22528+704                         ; attrs here
 44+  AB2E CD AB A7         call screen_setcolours
 45+  AB31
 46+  AB31 C9               ret
 47+  AB32
 48+  AB32              ;
 49+  AB32              ; If required, enter highscore
 50+  AB32              ;
 51+  AB32              gameover_enterhighscores:
 52+  AB32                  ; check if we need to enter initial
 53+  AB32 3A 95 BF         ld a,(scores_highscoretmp)
 54+  AB35 FE 00            cp 0
 55+  AB37 C8               ret z
 56+  AB38 CD 66 AB         call gameover_enterhighscores_init
 57+  AB3B 3A 95 BF         ld a,(scores_highscoretmp)
 58+  AB3E 3D               dec a
 59+  AB3F 3D               dec a
 60+  AB40 3D               dec a                                   ; get high score location back to position of name
 61+  AB41 16 00            ld d,0
 62+  AB43 5F               ld e,a
 63+  AB44 21 1C BF         ld hl,scores_table
 64+  AB47 19               add hl,de                               ; load memory into hl
 65+  AB48 08               ex af,af'
 66+  AB49 06 0F            ld b,15
 67+  AB4B CD 82 80         call utilities_pauseforframes           ; pause for a little bit
 68+  AB4E 06 03            ld b,3                                  ; collect three chars
 69+  AB50              gameover_draw2:
 70+  AB50 C5               push bc
 71+  AB51 E5               push hl
 72+  AB52 CD 86 80         call utilities_readkey               ; get key into a
 73+  AB55 E1               pop hl
 74+  AB56 77               ld (hl),a
 75+  AB57 23               inc hl
 76+  AB58 E5               push hl
 77+  AB59 CD 82 BF         call scores_showtable
 78+  AB5C E1               pop hl
 79+  AB5D 06 0F            ld b,15
 80+  AB5F CD 82 80         call utilities_pauseforframes
 81+  AB62 C1               pop bc
 82+  AB63 10 EB            djnz gameover_draw2
 83+  AB65 C9               ret
 84+  AB66
 85+  AB66              ;
 86+  AB66              ; Displays the screen text for high score entry
 87+  AB66              ;
 88+  AB66              gameover_enterhighscores_init:
 89+  AB66
 90+  AB66 CD D0 AB         call gameover_init
 91+  AB69 CD 15 AB         call gameover_commontext
 92+  AB6C
 93+  AB6C 21 93 83         ld hl,string_highscore_congratulations
 94+  AB6F CD A6 84         call string_print
 95+  AB72
 96+  AB72 3A A3 B8         ld a,(game_currentplayer)
 97+  AB75 FE 01            cp 1
 98+  AB77 21 A5 83         ld hl,string_highscore_player1
 99+  AB7A C3 80 AB         jp gameover_enterhighscores_init1
100+  AB7D              gameover_enterhighscores_init0:
101+  AB7D 21 B0 83         ld hl,string_highscore_player2
102+  AB80              gameover_enterhighscores_init1:
103+  AB80 CD A6 84         call string_print
104+  AB83 06 60            ld b,96
105+  AB85 3E 43            ld a,67
106+  AB87 11 A0 58         ld de,22528+160                         ; attrs here
107+  AB8A CD AB A7         call screen_setcolours
108+  AB8D
109+  AB8D 21 BB 83         ld hl,string_highscore_youhaveearned
110+  AB90 CD A6 84         call string_print
111+  AB93
112+  AB93 3A 95 BF         ld a,(scores_highscoretmp)
113+  AB96 FE 05            cp 5
114+  AB98 CA A6 AB         jp z, gameover_enterhighscores_init2    ; first place
115+  AB9B FE 11            cp 17
116+  AB9D CA AC AB         jp z, gameover_enterhighscores_init3    ; 2nd place
117+  ABA0 21 F7 83         ld hl,string_highscore_place3           ; 3rd place
118+  ABA3 C3 B2 AB         jp gameover_enterhighscores_init4
119+  ABA6              gameover_enterhighscores_init2
120+  ABA6 21 CD 83         ld hl,string_highscore_place1
121+  ABA9 C3 B2 AB         jp gameover_enterhighscores_init4
122+  ABAC              gameover_enterhighscores_init3
123+  ABAC 21 E2 83         ld hl,string_highscore_place2
124+  ABAF C3 B2 AB         jp gameover_enterhighscores_init4
125+  ABB2              gameover_enterhighscores_init4
126+  ABB2 CD A6 84         call string_print
127+  ABB5
128+  ABB5 06 60            ld b,96
129+  ABB7 3E 42            ld a,66
130+  ABB9 11 40 59         ld de,22528+320                         ; attrs here
131+  ABBC CD AB A7         call screen_setcolours
132+  ABBF
133+  ABBF 21 0C 84         ld hl,string_highscore_pleaseenter
134+  ABC2 CD A6 84         call string_print
135+  ABC5
136+  ABC5 06 60            ld b,96
137+  ABC7 3E 46            ld a,70
138+  ABC9 11 E0 59         ld de,22528+480                         ; attrs here
139+  ABCC CD AB A7         call screen_setcolours
140+  ABCF C9               ret
141+  ABD0
142+  ABD0              ;
143+  ABD0              ; Initialises the screen
144+  ABD0              ;
145+  ABD0              gameover_init:
146+  ABD0              ; We want a black screen.
147+  ABD0 3E 47            ld a,71             ; white ink (7) on black paper (0),
148+  ABD2                                      ; bright (64).
149+  ABD2 CD 67 80         call utilities_clearscreen
150+  ABD5 32 8D 5C         ld (23693),a        ; set our screen colours.
151+  ABD8 3E 00            ld a,0              ; 2 is the code for red.
152+  ABDA D3 FE            out (254),a         ; write to port 254.
153+  ABDC C9               ret
# file closed: screen/gameover.asm
 29   ABDD                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  ABDD              ;
  2+  ABDD              ; Draws the level transition screen
  3+  ABDD              ;
  4+  ABDD              endlevel_draw:
  5+  ABDD CD D3 AC         call endlevel_init
  6+  ABE0 CD BC AC         call endlevel_commontext
  7+  ABE3
  8+  ABE3 21 93 83         ld hl,string_highscore_congratulations
  9+  ABE6 CD A6 84         call string_print
 10+  ABE9
 11+  ABE9 3A A3 B8         ld a,(game_currentplayer)
 12+  ABEC FE 01            cp 1
 13+  ABEE 21 A5 83         ld hl,string_highscore_player1
 14+  ABF1 C3 F7 AB         jp endlevel_init1
 15+  ABF4              endlevel_init0:
 16+  ABF4 21 B0 83         ld hl,string_highscore_player2
 17+  ABF7              endlevel_init1:
 18+  ABF7 CD A6 84         call string_print
 19+  ABFA
 20+  ABFA 21 29 84         ld hl,string_endlevel_youhaveearned
 21+  ABFD CD A6 84         call string_print
 22+  AC00
 23+  AC00 CD 5B AC         call endlevel_workoutbonus
 24+  AC03 D5               push de
 25+  AC04 08               ex af,af'                               ; store the a value for later
 26+  AC05 CD A6 84         call string_print
 27+  AC08 D1               pop de
 28+  AC09 62 6B            ld hl,de                                ; get the points text into de
 29+  AC0B CD A6 84         call string_print
 30+  AC0E
 31+  AC0E 21 94 84         ld hl, string_endlevel_anothergo
 32+  AC11 CD A6 84         call string_print
 33+  AC14
 34+  AC14 06 20            ld b,32
 35+  AC16 3E 63            ld a,99
 36+  AC18 11 60 59         ld de,22528+352                         ; attrs here
 37+  AC1B CD AB A7         call screen_setcolours
 38+  AC1E
 39+  AC1E 06 20            ld b,32
 40+  AC20 3E 65            ld a,101
 41+  AC22 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AC25 CD AB A7         call screen_setcolours
 43+  AC28
 44+  AC28 06 20            ld b,32
 45+  AC2A 3E 63            ld a,99
 46+  AC2C 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AC2F CD AB A7         call screen_setcolours
 48+  AC32
 49+  AC32 06 20            ld b,32
 50+  AC34 3E 62            ld a,98
 51+  AC36 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AC39 CD AB A7         call screen_setcolours
 53+  AC3C
 54+  AC3C 08               ex af,af'                               ; get back a value with bonus type
 55+  AC3D 06 14            ld b,20
 56+  AC3F CD 82 80         call utilities_pauseforframes
 57+  AC42
 58+  AC42 47               ld b,a                      ; put the bonus count in b
 59+  AC43              endlevel_init2:
 60+  AC43 C5               push bc
 61+  AC44 06 01            ld b,1
 62+  AC46 CD 40 BF         call scores_addthousands
 63+  AC49 CD 4A B9         call player_recordcurrentscore
 64+  AC4C CD 60 BF         call scores_printscores     ; print the current scores
 65+  AC4F 06 0A            ld b,10
 66+  AC51 CD 82 80         call utilities_pauseforframes
 67+  AC54 C1               pop bc
 68+  AC55 10 EC            djnz endlevel_init2
 69+  AC57
 70+  AC57 CD 47 80         call utilities_waitforkey   ; wait for keypress
 71+  AC5A
 72+  AC5A C9               ret
 73+  AC5B
 74+  AC5B              ;
 75+  AC5B              ; Works out the bonus
 76+  AC5B              ; Outputs:
 77+  AC5B              ; a = 15 (all seven)
 78+  AC5B              ; a = 10 (3 large or 4 small)
 79+  AC5B              ; a = 5 (1 large diamond)
 80+  AC5B              ; hl - pointer to bonus text
 81+  AC5B              ; de - pointer to points text
 82+  AC5B              ;
 83+  AC5B              endlevel_workoutbonus:
 84+  AC5B 21 10 B2         ld hl,level01diamonds+2     ; location of state of first diamond
 85+  AC5E 06 03            ld b,3                      ; number to check
 86+  AC60 16 00            ld d,0                      ; zero diamond count
 87+  AC62              endlevel_workoutbonus0:
 88+  AC62 7E               ld a,(hl)                   ; get state
 89+  AC63 FE 01            cp 1
 90+  AC65 C2 69 AC         jp nz,endlevel_workoutbonus1 ; if not, move on
 91+  AC68 14               inc d                       ; increment diamond count
 92+  AC69              endlevel_workoutbonus1:
 93+  AC69 23               inc hl
 94+  AC6A 23               inc hl
 95+  AC6B 23               inc hl
 96+  AC6C 23               inc hl
 97+  AC6D 23               inc hl                      ; get to next state
 98+  AC6E 10 F2            djnz endlevel_workoutbonus0
 99+  AC70
100+  AC70 21 20 B2         ld hl,level01gems+2     ; location of state of first gem
101+  AC73 06 04            ld b,4                      ; number to check
102+  AC75 1E 00            ld e,0                      ; zero gem count
103+  AC77              endlevel_workoutbonus2:
104+  AC77 7E               ld a,(hl)                   ; get state
105+  AC78 FE 01            cp 1
106+  AC7A C2 7E AC         jp nz,endlevel_workoutbonus3 ; if not, move on
107+  AC7D 1C               inc e                       ; increment diamond count
108+  AC7E              endlevel_workoutbonus3:
109+  AC7E 23               inc hl
110+  AC7F 23               inc hl
111+  AC80 23               inc hl
112+  AC81 23               inc hl
113+  AC82 23               inc hl                     ; get to next state
114+  AC83 10 F2            djnz endlevel_workoutbonus2
115+  AC85
116+  AC85 7A               ld a,d
117+  AC86 83               add e
118+  AC87 FE 07            cp 7                        ; check for max bonus
119+  AC89 C2 95 AC         jp nz,endlevel_workoutbonus4 ;
120+  AC8C 3E 0F            ld a,15
121+  AC8E 21 59 84         ld hl, string_endlevel_bonus3
122+  AC91 11 85 84         ld de, string_endlevel_points3
123+  AC94 C9               ret                         ; return with bonus of 15
124+  AC95              endlevel_workoutbonus4:
125+  AC95 7A               ld a,d                      ; check for for diamonds
126+  AC96 FE 03            cp 3
127+  AC98 C2 A4 AC         jp nz,endlevel_workoutbonus5
128+  AC9B 3E 0A            ld a,10
129+  AC9D 21 4A 84         ld hl, string_endlevel_bonus2
130+  ACA0 11 76 84         ld de, string_endlevel_points2
131+  ACA3 C9               ret                         ; return with bonus of ten
132+  ACA4              endlevel_workoutbonus5:
133+  ACA4 7B               ld a,e                      ; check for four gems
134+  ACA5 FE 04            cp 4
135+  ACA7 C2 B3 AC         jp nz,endlevel_workoutbonus6
136+  ACAA 3E 0A            ld a,10
137+  ACAC 21 4A 84         ld hl, string_endlevel_bonus2
138+  ACAF 11 76 84         ld de, string_endlevel_points2
139+  ACB2 C9               ret                         ; return with bonus of 10
140+  ACB3              endlevel_workoutbonus6:
141+  ACB3 3E 05            ld a,5                      ; otherwise, bonus is 5
142+  ACB5 21 3B 84         ld hl, string_endlevel_bonus1
143+  ACB8 11 68 84         ld de, string_endlevel_points1
144+  ACBB C9               ret
145+  ACBC
146+  ACBC              ;
147+  ACBC              ; Draws text shared by the game over and high score screens
148+  ACBC              ;
149+  ACBC              endlevel_commontext:
150+  ACBC CD 7D A7         call screen_setuptext       ; show scores
151+  ACBF CD 60 BF         call scores_printscores     ; print the current scores
152+  ACC2
153+  ACC2 21 73 83         ld hl,string_gameoverscreen_bestscores
154+  ACC5 CD A6 84         call string_print
155+  ACC8
156+  ACC8 06 20            ld b,32
157+  ACCA 3E 45            ld a,69
158+  ACCC 11 C0 5A         ld de,22528+704                         ; attrs here
159+  ACCF CD AB A7         call screen_setcolours
160+  ACD2
161+  ACD2 C9               ret
162+  ACD3
163+  ACD3              ;
164+  ACD3              ; Initialises the screen
165+  ACD3              ;
166+  ACD3              endlevel_init:
167+  ACD3              ; We want a green screen.
168+  ACD3 3E 61            ld a,97             ; white ink (7) on black paper (0),
169+  ACD5                                      ; bright (64).
170+  ACD5 CD 67 80         call utilities_clearscreen
171+  ACD8 32 8D 5C         ld (23693),a        ; set our screen colours.
172+  ACDB 3E 00            ld a,0              ; 2 is the code for red.
173+  ACDD D3 FE            out (254),a         ; write to port 254.
174+  ACDF C9               ret
# file closed: screen/endlevel.asm
 30   ACE0
 31   ACE0                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  ACE0              ; ###############################################################
  2+  ACE0              ; Data for level 1
  3+  ACE0              ; ###############################################################
  4+  ACE0              level01:
  5+  ACE0
  6+  ACE0                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  ACE0
  8+  ACE0 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  ACE4 05 05 05 05
  8+  ACE8 05 05 05 05
  8+  ACEC 05 05 02 01
  8+  ACF0 01 01 03 05
  8+  ACF4 05 05 05 05
  8+  ACF8 05 05 05 05
  8+  ACFC 05 05 00 00
  9+  AD00 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  AD04 05 05 05 05
  9+  AD08 05 05 05 05
  9+  AD0C 02 01 01 01
  9+  AD10 01 01 01 01
  9+  AD14 03 05 05 05
  9+  AD18 05 05 05 05
  9+  AD1C 05 05 00 00
 10+  AD20 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  AD24 05 05 05 05
 10+  AD28 05 05 02 01
 10+  AD2C 01 01 01 01
 10+  AD30 01 01 01 01
 10+  AD34 01 01 03 05
 10+  AD38 0D 0D 0D 0D
 10+  AD3C 0D 0D 00 00
 11+  AD40 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  AD44 01 01 00 01
 11+  AD48 01 01 01 01
 11+  AD4C 01 01 01 01
 11+  AD50 01 01 01 01
 11+  AD54 01 01 01 03
 11+  AD58 05 05 05 05
 11+  AD5C 05 05 00 00
 12+  AD60 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  AD64 04 04 04 04
 12+  AD68 04 04 01 01
 12+  AD6C 01 01 01 01
 12+  AD70 01 01 01 01
 12+  AD74 01 01 01 01
 12+  AD78 01 01 01 01
 12+  AD7C 00 01 00 00
 13+  AD80 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  AD84 04 04 04 04
 13+  AD88 04 04 04 04
 13+  AD8C 01 01 01 01
 13+  AD90 01 01 01 01
 13+  AD94 01 01 01 01
 13+  AD98 00 00 00 00
 13+  AD9C 00 01 00 00
 14+  ADA0 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  ADA4 04 01 01 01
 14+  ADA8 01 01 04 04
 14+  ADAC 04 04 01 01
 14+  ADB0 01 01 01 01
 14+  ADB4 01 00 00 00
 14+  ADB8 00 01 01 01
 14+  ADBC 01 01 00 00
 15+  ADC0 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  ADC4 04 04 04 04
 15+  ADC8 04 01 04 04
 15+  ADCC 04 04 04 04
 15+  ADD0 04 04 00 00
 15+  ADD4 00 00 04 04
 15+  ADD8 04 04 04 04
 15+  ADDC 04 01 00 00
 16+  ADE0 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  ADE4 01 04 01 01
 16+  ADE8 01 01 04 04
 16+  ADEC 04 04 04 04
 16+  ADF0 04 04 00 04
 16+  ADF4 04 04 04 04
 16+  ADF8 04 04 04 04
 16+  ADFC 04 01 00 00
 17+  AE00 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  AE04 00 00 00 00
 17+  AE08 00 04 04 04
 17+  AE0C 04 04 04 04
 17+  AE10 04 04 00 04
 17+  AE14 04 04 04 04
 17+  AE18 04 04 04 04
 17+  AE1C 04 01 00 00
 18+  AE20 00 00 01 07      defb 00,00,01,07,07,07,07,07,07,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  AE24 07 07 07 07
 18+  AE28 07 01 04 04
 18+  AE2C 04 04 04 04
 18+  AE30 04 04 00 04
 18+  AE34 04 04 04 04
 18+  AE38 04 04 04 04
 18+  AE3C 04 01 00 00
 19+  AE40 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  AE44 00 00 00 00
 19+  AE48 00 01 04 04
 19+  AE4C 04 04 04 04
 19+  AE50 04 04 00 04
 19+  AE54 04 04 04 04
 19+  AE58 04 00 00 00
 19+  AE5C 00 01 00 00
 20+  AE60 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  AE64 00 00 00 00
 20+  AE68 00 01 04 04
 20+  AE6C 04 04 04 04
 20+  AE70 04 04 00 04
 20+  AE74 04 04 04 04
 20+  AE78 04 00 04 04
 20+  AE7C 00 01 00 00
 21+  AE80 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  AE84 06 06 06 06
 21+  AE88 06 01 04 04
 21+  AE8C 04 04 04 04
 21+  AE90 04 04 00 04
 21+  AE94 04 04 04 04
 21+  AE98 04 00 04 04
 21+  AE9C 00 01 00 00
 22+  AEA0 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  AEA4 06 06 06 06
 22+  AEA8 06 01 04 00
 22+  AEAC 00 00 00 00
 22+  AEB0 00 00 00 00
 22+  AEB4 00 00 00 00
 22+  AEB8 00 00 04 04
 22+  AEBC 00 01 00 00
 23+  AEC0 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  AEC4 06 06 06 06
 23+  AEC8 06 01 04 00
 23+  AECC 04 04 04 04
 23+  AED0 04 04 00 04
 23+  AED4 04 04 00 04
 23+  AED8 04 04 04 04
 23+  AEDC 00 01 00 00
 24+  AEE0 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  AEE4 06 06 06 06
 24+  AEE8 06 01 04 00
 24+  AEEC 04 04 04 04
 24+  AEF0 04 04 00 04
 24+  AEF4 04 04 00 04
 24+  AEF8 04 04 04 04
 24+  AEFC 00 01 00 00
 25+  AF00 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  AF04 01 01 01 01
 25+  AF08 01 01 04 00
 25+  AF0C 04 04 04 04
 25+  AF10 04 04 00 04
 25+  AF14 04 04 00 04
 25+  AF18 04 04 04 04
 25+  AF1C 00 01 00 00
 26+  AF20 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  AF24 04 04 04 04
 26+  AF28 04 04 04 00
 26+  AF2C 04 04 04 04
 26+  AF30 04 04 00 04
 26+  AF34 04 04 00 00
 26+  AF38 00 00 04 04
 26+  AF3C 04 01 00 00
 27+  AF40 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  AF44 04 04 00 00
 27+  AF48 00 00 00 00
 27+  AF4C 04 04 04 04
 27+  AF50 04 04 00 04
 27+  AF54 04 04 04 04
 27+  AF58 04 00 04 04
 27+  AF5C 04 01 00 00
 28+  AF60 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  AF64 04 04 00 04
 28+  AF68 04 04 04 04
 28+  AF6C 04 04 04 04
 28+  AF70 04 04 00 04
 28+  AF74 04 04 04 04
 28+  AF78 04 00 04 04
 28+  AF7C 04 01 00 00
 29+  AF80 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  AF84 04 04 00 04
 29+  AF88 04 04 01 01
 29+  AF8C 01 01 01 01
 29+  AF90 01 01 01 01
 29+  AF94 01 01 01 01
 29+  AF98 04 00 04 04
 29+  AF9C 04 01 00 00
 30+  AFA0 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  AFA4 04 04 00 04
 30+  AFA8 04 04 01 00
 30+  AFAC 00 00 00 00
 30+  AFB0 00 00 00 00
 30+  AFB4 00 00 00 01
 30+  AFB8 04 00 04 04
 30+  AFBC 04 01 00 00
 31+  AFC0 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  AFC4 04 04 00 04
 31+  AFC8 04 04 01 00
 31+  AFCC 00 00 00 00
 31+  AFD0 00 00 00 00
 31+  AFD4 00 00 00 01
 31+  AFD8 04 00 04 04
 31+  AFDC 04 01 00 00
 32+  AFE0 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  AFE4 04 04 00 04
 32+  AFE8 04 04 01 00
 32+  AFEC 00 00 00 00
 32+  AFF0 00 00 00 00
 32+  AFF4 00 00 00 01
 32+  AFF8 04 00 04 04
 32+  AFFC 04 01 00 00
 33+  B000 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B004 04 04 00 04
 33+  B008 04 04 04 00
 33+  B00C 00 00 00 00
 33+  B010 00 00 00 00
 33+  B014 00 00 00 04
 33+  B018 04 04 04 04
 33+  B01C 04 01 00 00
 34+  B020 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B024 04 04 04 04
 34+  B028 04 04 01 00
 34+  B02C 00 00 00 00
 34+  B030 00 00 00 00
 34+  B034 00 00 00 01
 34+  B038 04 04 04 04
 34+  B03C 04 01 00 00
 35+  B040 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B044 04 04 04 04
 35+  B048 04 04 01 00
 35+  B04C 00 00 01 00
 35+  B050 00 00 00 01
 35+  B054 00 00 00 01
 35+  B058 04 04 04 04
 35+  B05C 04 01 00 00
 36+  B060 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B064 01 01 01 01
 36+  B068 01 01 01 01
 36+  B06C 01 01 01 01
 36+  B070 01 01 01 01
 36+  B074 01 01 01 01
 36+  B078 01 01 01 01
 36+  B07C 01 01 00 00
 37+  B080
 38+  B080              ; ###############################################################
 39+  B080              ; Object data: horiz, vert, state, memh, meml
 40+  B080              ; ###############################################################
 41+  B080              level01rocks1:
 42+  B080 1C 09 00 00      defb 28,9,0,0,0
 42+  B084 00
 43+  B085 1B 0C 00 00      defb 27,12,0,0,0
 43+  B089 00
 44+  B08A 1B 11 00 00      defb 27,17,0,0,0
 44+  B08E 00
 45+  B08F 1C 12 00 00      defb 28,18,0,0,0
 45+  B093 00
 46+  B094 FF               defb 255
 47+  B095
 48+  B095              level01rocks:
 49+  B095 09 04 00 00      defb 9,4,0,0,0
 49+  B099 00
 50+  B09A 0C 07 00 00      defb 12,7,0,0,0
 50+  B09E 00
 51+  B09F 10 07 00 00      defb 16,7,0,0,0
 51+  B0A3 00
 52+  B0A4 0B 08 00 00      defb 11,8,0,0,0
 52+  B0A8 00
 53+  B0A9 0A 0A 00 00      defb 10,10,0,0,0
 53+  B0AD 00
 54+  B0AE 0C 0A 00 00      defb 12,10,0,0,0
 54+  B0B2 00
 55+  B0B3 0D 09 00 00      defb 13,9,0,0,0
 55+  B0B7 00
 56+  B0B8 0E 08 00 00      defb 14,8,0,0,0
 56+  B0BC 00
 57+  B0BD 0F 0B 00 00      defb 15,11,0,0,0
 57+  B0C1 00
 58+  B0C2 0B 0C 00 00      defb 11,12,0,0,0
 58+  B0C6 00
 59+  B0C7 11 0C 00 00      defb 17,12,0,0,0
 59+  B0CB 00
 60+  B0CC 13 08 00 00      defb 19,8,0,0,0
 60+  B0D0 00
 61+  B0D1 16 09 00 00      defb 22,9,0,0,0
 61+  B0D5 00
 62+  B0D6 13 0A 00 00      defb 19,10,0,0,0
 62+  B0DA 00
 63+  B0DB 15 0A 00 00      defb 21,10,0,0,0
 63+  B0DF 00
 64+  B0E0 15 0C 00 00      defb 21,12,0,0,0
 64+  B0E4 00
 65+  B0E5 16 0C 00 00      defb 22,12,0,0,0
 65+  B0E9 00
 66+  B0EA 18 0A 00 00      defb 24,10,0,0,0
 66+  B0EE 00
 67+  B0EF 19 09 00 00      defb 25,9,0,0,0
 67+  B0F3 00
 68+  B0F4 1C 09 00 00      defb 28,9,0,0,0
 68+  B0F8 00
 69+  B0F9 1B 0C 00 00      defb 27,12,0,0,0
 69+  B0FD 00
 70+  B0FE 1A 0D 00 00      defb 26,13,0,0,0
 70+  B102 00
 71+  B103 19 0E 00 00      defb 25,14,0,0,0
 71+  B107 00
 72+  B108 19 10 00 00      defb 25,16,0,0,0
 72+  B10C 00
 73+  B10D 1A 11 00 00      defb 26,17,0,0,0
 73+  B111 00
 74+  B112 1B 11 00 00      defb 27,17,0,0,0
 74+  B116 00
 75+  B117 1C 12 00 00      defb 28,18,0,0,0
 75+  B11B 00
 76+  B11C 1A 13 00 00      defb 26,19,0,0,0
 76+  B120 00
 77+  B121 1B 15 00 00      defb 27,21,0,0,0
 77+  B125 00
 78+  B126 1A 17 00 00      defb 26,23,0,0,0
 78+  B12A 00
 79+  B12B 1B 18 00 00      defb 27,24,0,0,0
 79+  B12F 00
 80+  B130 19 18 00 00      defb 25,24,0,0,0
 80+  B134 00
 81+  B135 18 17 00 00      defb 24,23,0,0,0
 81+  B139 00
 82+  B13A 13 14 00 00      defb 19,20,0,0,0
 82+  B13E 00
 83+  B13F 14 12 00 00      defb 20,18,0,0,0
 83+  B143 00
 84+  B144 14 10 00 00      defb 20,16,0,0,0
 84+  B148 00
 85+  B149 15 10 00 00      defb 21,16,0,0,0
 85+  B14D 00
 86+  B14E 16 12 00 00      defb 22,18,0,0,0
 86+  B152 00
 87+  B153 11 14 00 00      defb 17,20,0,0,0
 87+  B157 00
 88+  B158 0D 11 00 00      defb 13,17,0,0,0
 88+  B15C 00
 89+  B15D 0C 13 00 00      defb 12,19,0,0,0
 89+  B161 00
 90+  B162 0B 13 00 00      defb 11,19,0,0,0
 90+  B166 00
 91+  B167 0A 11 00 00      defb 10,17,0,0,0
 91+  B16B 00
 92+  B16C 05 12 00 00      defb 5,18,0,0,0
 92+  B170 00
 93+  B171 07 16 00 00      defb 7,22,0,0,0
 93+  B175 00
 94+  B176 09 17 00 00      defb 9,23,0,0,0
 94+  B17A 00
 95+  B17B 07 18 00 00      defb 7,24,0,0,0
 95+  B17F 00
 96+  B180 05 18 00 00      defb 5,24,0,0,0
 96+  B184 00
 97+  B185 06 19 00 00      defb 6,25,0,0,0
 97+  B189 00
 98+  B18A 08 19 00 00      defb 8,25,0,0,0
 98+  B18E 00
 99+  B18F 04 17 00 00      defb 4,23,0,0,0
 99+  B193 00
100+  B194 FF               defb 255
101+  B195
102+  B195              level01missiles:
103+  B195 0B 17 00 00      defb 11,23,0,0,0
103+  B199 00
104+  B19A 0B 16 00 00      defb 11,22,0,0,0
104+  B19E 00
105+  B19F 0C 17 00 00      defb 12,23,0,0,0
105+  B1A3 00
106+  B1A4 0C 16 00 00      defb 12,22,0,0,0
106+  B1A8 00
107+  B1A9 0D 17 00 00      defb 13,23,0,0,0
107+  B1AD 00
108+  B1AE 0D 16 00 00      defb 13,22,0,0,0
108+  B1B2 00
109+  B1B3 0E 17 00 00      defb 14,23,0,0,0
109+  B1B7 00
110+  B1B8 0E 16 00 00      defb 14,22,0,0,0
110+  B1BC 00
111+  B1BD 0F 17 00 00      defb 15,23,0,0,0
111+  B1C1 00
112+  B1C2 0F 16 00 00      defb 15,22,0,0,0
112+  B1C6 00
113+  B1C7 10 17 00 00      defb 16,23,0,0,0
113+  B1CB 00
114+  B1CC 10 16 00 00      defb 16,22,0,0,0
114+  B1D0 00
115+  B1D1 11 17 00 00      defb 17,23,0,0,0
115+  B1D5 00
116+  B1D6 11 16 00 00      defb 17,22,0,0,0
116+  B1DA 00
117+  B1DB 12 17 00 00      defb 18,23,0,0,0
117+  B1DF 00
118+  B1E0 12 16 00 00      defb 18,22,0,0,0
118+  B1E4 00
119+  B1E5 13 17 00 00      defb 19,23,0,0,0
119+  B1E9 00
120+  B1EA 13 16 00 00      defb 19,22,0,0,0
120+  B1EE 00
121+  B1EF 14 17 00 00      defb 20,23,0,0,0
121+  B1F3 00
122+  B1F4 14 16 00 00      defb 20,22,0,0,0
122+  B1F8 00
123+  B1F9 15 17 00 00      defb 21,23,0,0,0
123+  B1FD 00
124+  B1FE 15 16 00 00      defb 21,22,0,0,0
124+  B202 00
125+  B203 16 17 00 00      defb 22,23,0,0,0
125+  B207 00
126+  B208 16 16 00 00      defb 22,22,0,0,0
126+  B20C 00
127+  B20D FF               defb 255
128+  B20E
129+  B20E              ;
130+  B20E              ; Diamonds: x,y,state,mem1+mem2
131+  B20E              ;
132+  B20E              level01diamonds:
133+  B20E 0C 1B 00 00      defb 12,27,0,0,0
133+  B212 00
134+  B213 10 1B 00 00      defb 16,27,0,0,0
134+  B217 00
135+  B218 15 1B 00 00      defb 21,27,0,0,0
135+  B21C 00
136+  B21D FF               defb 255
137+  B21E
138+  B21E              level01gems:
139+  B21E 12 14 00 00      defb 18,20,0,0,0
139+  B222 00
140+  B223 06 18 00 00      defb 6,24,0,0,0
140+  B227 00
141+  B228 19 17 00 00      defb 25,23,0,0,0
141+  B22C 00
142+  B22D 1C 11 00 00      defb 28,17,0,0,0
142+  B231 00
143+  B232 FF               defb 255
144+  B233              ;
145+  B233              ; Score area colours
146+  B233              ;
147+  B233              score_colours:
148+  B233 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
148+  B237 47 47 47 47
148+  B23B 47 47 47 42
148+  B23F 43 43 43 43
148+  B243 43 43 43 43
148+  B247 42 47 47 47
148+  B24B 47 47 47 47
148+  B24F 47 47 47 47
149+  B253 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
149+  B257 47 47 47 47
149+  B25B 47 47 47 46
149+  B25F 46 46 46 46
149+  B263 46 46 46 46
149+  B267 46 47 47 47
149+  B26B 47 47 47 47
149+  B26F 47 47 47 47
150+  B273
151+  B273              high_score_colours:
152+  B273 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
152+  B277 42 42 47 47
152+  B27B 47 47 47 47
152+  B27F 43 43 43 47
152+  B283 47 47 47 47
152+  B287 47 46 46 46
152+  B28B 47 47 47 47
152+  B28F 47 47 00 00
# file closed: leveldata/level01.asm
 32   B293                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B293              ; Tiles graphics.
  2+  B293              sprites:
  3+  B293 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B297 00 00 00 00
  4+  B29B FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B29F FF FF FF FF
  5+  B2A3 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B2A7 1F 3F 7F FF
  6+  B2AB 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B2AF F8 FC FE FF
  7+  B2B3 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B2B7 55 AA 55 AA
  8+  B2BB 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B2BF 00 00 00 00
  9+  B2C3 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  B2C7 FF FF FF FF
 10+  B2CB FF FF 00 00      defb    255,255,  0,  0,  0,  0,  0,  0   ; 7, trapdoor
 10+  B2CF 00 00 00 00
 11+  B2D3 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B2D7 F1 72 34 18
 12+  B2DB 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B2DF FE FE FF 7E
 13+  B2E3 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B2E7 FE FF 7E 3C
 14+  B2EB 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B2EF 00 00 FF FF
 15+  B2F3 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 12, missile
 15+  B2F7 FF 7E 3C 18
 16+  B2FB 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B2FF 00 00 00 00
 17+  B303 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B307 00 3C 5A 34
 18+  B30B FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  B30F FD FE FD FE
 19+  B313 F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  B317 F4 F8 F4 F8
 20+  B31B D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  B31F D0 E0 D0 E0
 21+  B323 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  B327 40 80 40 80
 22+  B32B 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  B32F ED 00 00 00
 23+  B333
 24+  B333
 25+  B333              sprite_attrs:
 26+  B333 46               defb    070 ; 0, space
 27+  B334 4D               defb    077 ; 1, cyan block
 28+  B335 4D               defb    077 ; 2, slope left
 29+  B336 4D               defb    077 ; 3, slope right
 30+  B337 46               defb    070 ; 4, dirt
 31+  B338 4E               defb    078 ; 5, sky
 32+  B339 4C               defb    076 ; 6, slime
 33+  B33A 42               defb    066 ; 7, trapdoor
 34+  B33B 46               defb    070 ; 8, diamond
 35+  B33C 42               defb    066 ; 9, rock
 36+  B33D 42               defb    066 ; 10, rock 2
 37+  B33E 49           	defb    073 ; 11, sky, trapdoor
 38+  B33F 43           	defb    067 ; 12, missile
 39+  B340 4A               defb    074 ; 13, sky, red ink (tank)
 40+  B341 46               defb    070 ; 14, gem
 41+  B342 4D               defb    077 ; 15, damaged mountain
 42+  B343 4D               defb    077 ; 16, damaged mountain 2
 43+  B344 4D               defb    077 ; 17, damaged mountain 3
 44+  B345 4D               defb    077 ; 18, damaged mountain 4
 45+  B346
 46+  B346              player_sprite:
 47+  B346 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 47+  B34A 38 3D C3 80
 48+  B34E 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 48+  B352 3C 1C 16 32
 49+  B356 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 49+  B35A 3C 38 68 4C
 50+  B35E 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 50+  B362 1C BC C3 01
 51+  B366 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 51+  B36A 3C 3C 64 0C
 52+  B36E 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 52+  B372 3C 3C 26 30
 53+  B376 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 53+  B37A 1E 5C FD 5F
 54+  B37E 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 54+  B382 4F 8F 19 03
 55+  B386 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 55+  B38A F2 F1 98 C0
 56+  B38E FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 56+  B392 48 08 14 2A
 57+  B396 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 57+  B39A 38 78 44 C3
 58+  B39E 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 58+  B3A2 1C 1E 22 C3
 59+  B3A6
 60+  B3A6              ;
 61+  B3A6              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 62+  B3A6              ;
 63+  B3A6              ship_sprite:
 64+  B3A6 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 64+  B3AA 03 1F 7F FF
 65+  B3AE 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 65+  B3B2 FF FF FF FF
 66+  B3B6 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 66+  B3BA FF FF FF FF
 67+  B3BE 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 67+  B3C2 C0 F8 FE FF
 68+  B3C6 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 68+  B3CA 03 03 02 07
 69+  B3CE 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 69+  B3D2 FF 0F 07 83
 70+  B3D6 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 70+  B3DA FF 10 20 C1
 71+  B3DE 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 71+  B3E2 C0 C0 40 E0
 72+  B3E6 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 72+  B3EA 03 03 02 07
 73+  B3EE F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 73+  B3F2 FF 08 04 83
 74+  B3F6 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 74+  B3FA FF F0 E0 C1
 75+  B3FE CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 75+  B402 C0 C0 40 E0
 76+  B406
 77+  B406              ;
 78+  B406              ;  First 8 frames are tank, last frame is the gun barrel
 79+  B406              ;
 80+  B406              tank_sprite:
 81+  B406 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 81+  B40A 7F 00 00 00
 82+  B40E 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 82+  B412 FE FF 7F 40
 83+  B416 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 83+  B41A 03 FF FF 01
 84+  B41E 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
 84+  B422 E0 C0 00 00
 85+  B426 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
 85+  B42A F7 E1 7F 3F
 86+  B42E FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
 86+  B432 54 16 FF FF
 87+  B436 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
 87+  B43A 9B A8 FF FF
 88+  B43E FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
 88+  B442 9F AF FE FC
 89+  B446 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
 89+  B44A 1F 00 00 00
# file closed: graphics/graphics.asm
 33   B44E
 34   B44E                  include "game\control.asm"
# file opened: game/control.asm
  1+  B44E              ;
  2+  B44E              ; Check the keyboard then move
  3+  B44E              ;
  4+  B44E              control_keyboard:
  5+  B44E 3A DC B8         ld a,(player+11)    ; first, check if player is dying
  6+  B451 FE 00            cp 0
  7+  B453 C0               ret nz               ; if so, can't move
  8+  B454 3A D6 B8         ld a,(player+5)      ; next, check if the player has pixels left to move
  9+  B457 FE 00            cp 0
 10+  B459 CA 60 B4         jp z, control_keyboard5
 11+  B45C CD 65 B5         call control_automove
 12+  B45F C9               ret
 13+  B460              control_keyboard5:
 14+  B460 3A D7 B8         ld a,(player+6)      ; next, check if the player is digging
 15+  B463 FE 00            cp 0
 16+  B465 CA 6C B4         jp z, control_keyboard0
 17+  B468 CD A3 B4         call control_dig
 18+  B46B C9               ret
 19+  B46C              control_keyboard0:
 20+  B46C 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 21+  B46F ED 78            in a,(c)            ; read keyboard.
 22+  B471 47               ld b,a              ; store result in b register.
 23+  B472 CB 18            rr b                ; check outermost key (q).
 24+  B474 D2 93 B4         jp nc,control_keyboard1
 25+  B477 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 26+  B47A ED 78            in a,(c)            ; read keyboard.
 27+  B47C 47               ld b,a              ; store result in b register.
 28+  B47D CB 18            rr b                ; check outermost key (a).
 29+  B47F D2 97 B4         jp nc,control_keyboard2
 30+  B482 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 31+  B485 ED 78            in a,(c)            ; read keyboard.
 32+  B487 47               ld b,a              ; store result in b register.
 33+  B488 CB 18            rr b                ; check outermost key (p).
 34+  B48A D2 9B B4         jp nc,control_keyboard3
 35+  B48D CB 18            rr b                ; check next key.
 36+  B48F D2 9F B4         jp nc,control_keyboard4
 37+  B492 C9               ret
 38+  B493              control_keyboard1:
 39+  B493 CD AE B5         call control_pl_moveup         ; player up.
 40+  B496 C9               ret
 41+  B497              control_keyboard2:
 42+  B497 CD DD B5         call control_pl_movedown       ; player down.
 43+  B49A C9               ret
 44+  B49B              control_keyboard3:
 45+  B49B CD 3A B6         call control_pl_moveright       ; player left.
 46+  B49E C9               ret
 47+  B49F              control_keyboard4:
 48+  B49F CD 0A B6         call control_pl_moveleft       ; player right.
 49+  B4A2 C9               ret
 50+  B4A3
 51+  B4A3              ;
 52+  B4A3              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 53+  B4A3              ;
 54+  B4A3              control_dig:
 55+  B4A3 ED 4B D1 B8      ld bc,(player)      ; load the current coords into bc
 56+  B4A7 C5               push bc
 57+  B4A8 3A D3 B8         ld a,(player+2)     ; get the direction
 58+  B4AB FE 01            cp 1                ; left
 59+  B4AD CA C5 B4         jp z,control_dig0
 60+  B4B0 FE 02            cp 2                ; right
 61+  B4B2 CA DA B4         jp z,control_dig1
 62+  B4B5 FE 03            cp 3                ; down
 63+  B4B7 CA FE B4         jp z,control_dig5
 64+  B4BA FE 00            cp 0                ; up
 65+  B4BC CA EE B4         jp z,control_dig4
 66+  B4BF 21 D7 B8         ld hl,player+6
 67+  B4C2 36 00            ld (hl),0           ; turn off digging
 68+  B4C4 C9               ret                 ; return
 69+  B4C5              control_dig0:           ; going left
 70+  B4C5 CD 12 A9         call sprites_scadd  ; get the current coord
 71+  B4C8 62 6B            ld hl,de
 72+  B4CA 2B               dec hl              ; move one left
 73+  B4CB C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
 74+  B4CC 78               ld a,b
 75+  B4CD 06 08            ld b,8
 76+  B4CF 90               sub b
 77+  B4D0 47               ld b,a
 78+  B4D1 79               ld a,c
 79+  B4D2 0E 08            ld c,8
 80+  B4D4 91               sub c
 81+  B4D5 4F               ld c,a
 82+  B4D6 C5               push bc
 83+  B4D7 C3 07 B5         jp control_dig2
 84+  B4DA              control_dig1:
 85+  B4DA CD 12 A9         call sprites_scadd  ; get the current coord
 86+  B4DD 62 6B            ld hl,de
 87+  B4DF 23               inc hl              ; move one right
 88+  B4E0 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
 89+  B4E1 3E 08            ld a,8
 90+  B4E3 80               add a,b
 91+  B4E4 47               ld b,a
 92+  B4E5 79               ld a,c
 93+  B4E6 0E 08            ld c,8
 94+  B4E8 91               sub c
 95+  B4E9 4F               ld c,a
 96+  B4EA C5               push bc
 97+  B4EB C3 07 B5         jp control_dig2
 98+  B4EE              control_dig4:
 99+  B4EE CD 12 A9         call sprites_scadd  ; get the current coord
100+  B4F1 62 6B            ld hl,de
101+  B4F3 11 20 00         ld de,32
102+  B4F6 ED 52            sbc hl,de             ; move one up
103+  B4F8 C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
104+  B4F9 0D               dec c
105+  B4FA C5               push bc
106+  B4FB C3 1F B5         jp control_dig6
107+  B4FE              control_dig5:
108+  B4FE CD 12 A9         call sprites_scadd  ; get the current coord
109+  B501 62 6B            ld hl,de
110+  B503 24               inc h              ; move one down
111+  B504                                     ; not bothered about working out bc here, since rock will never fall if digging down
112+  B504 C3 07 B5         jp control_dig2
113+  B507              ; Normal (not up) digging
114+  B507              control_dig2:
115+  B507 3A D9 B8         ld a,(player+8)     ; get the number of rows we need to overwrite
116+  B50A 47               ld b,a              ; rows to copy over
117+  B50B E5               push hl             ; store the memory location of the first row for later
118+  B50C              control_dig3:
119+  B50C CD 4E B5         call control_getpixelrow
120+  B50F 77               ld (hl),a           ; load contents into row
121+  B510 11 20 00         ld de,32
122+  B513 19               add hl,de           ; move to next row
123+  B514 10 F6            djnz control_dig3
124+  B516 E1               pop hl              ; get the original memory location back
125+  B517 11 20 00         ld de,32
126+  B51A ED 52            sbc hl,de           ; move to above row, ready for checking for rock
127+  B51C C3 35 B5         jp control_dig10
128+  B51F              ; Special case for going up
129+  B51F              control_dig6:
130+  B51F 3A D9 B8         ld a,(player+8)     ; get the number of rows we need to overwrite
131+  B522 47               ld b,a              ; rows to copy over
132+  B523              control_dig7:
133+  B523 CD 4E B5         call control_getpixelrow
134+  B526              control_dig12:
135+  B526 77               ld (hl),a           ; load empty into row
136+  B527 11 20 00         ld de,32
137+  B52A ED 52            sbc hl,de           ; move up to next row
138+  B52C 0D               dec c               ; decrease c to track rows
139+  B52D 10 F4            djnz control_dig7
140+  B52F 79               ld a,c
141+  B530 D6 07            sub 7
142+  B532 C1               pop bc
143+  B533 4F               ld c,a
144+  B534 C5               push bc             ; store the decreased c coord
145+  B535              control_dig10:
146+  B535 DD 21 D8 B8      ld ix,player+7
147+  B539 DD 7E 00         ld a,(ix)     ; get the dig frame number
148+  B53C 3D               dec a
149+  B53D DD 77 00         ld (ix),a
150+  B540                  ; call the check for rocks above the removed dirt
151+  B540 DD 21 D7 B8      ld ix,player+6
152+  B544 DD 7E 00         ld a,(ix)     ; get the dig state
153+  B547 FE 00            cp 0
154+  B549 C1               pop bc
155+  B54A CC B5 BD         call z, rocks_checkforfalling ; make the check if we're no longer digging
156+  B54D C9               ret
157+  B54E
158+  B54E              ;
159+  B54E              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
160+  B54E              ; Inputs:
161+  B54E              ; hl - memory of pixel row
162+  B54E              ; Outputs:
163+  B54E              ; a - modified row to write
164+  B54E              ;
165+  B54E              control_getpixelrow:
166+  B54E 3A D8 B8         ld a,(player+7)     ; get the dig frame number
167+  B551 FE 00            cp 0                ; is this the last dig
168+  B553 CA 5A B5         jp z,control_getpixelrow1
169+  B556 7E               ld a,(hl)           ; if not, xor with 255 to flip it
170+  B557 EE FF            xor 255
171+  B559 C9               ret
172+  B55A              control_getpixelrow1:
173+  B55A DD 21 D7 B8      ld ix,player+6
174+  B55E DD 36 00 00      ld (ix),0           ; turn off digging
175+  B562 3E 00            ld a,0              ; if it is, load with empty
176+  B564 C9               ret
177+  B565
178+  B565              ;
179+  B565              ; Auto move the player until pixels is zero
180+  B565              ;
181+  B565              control_automove:
182+  B565 5F               ld e,a              ; store the number of pixels left to move in e
183+  B566 ED 4B D1 B8      ld bc,(player)      ; load the current coords into bc
184+  B56A 21 D3 B8         ld hl,player+2      ; get the direction
185+  B56D 7E               ld a,(hl)
186+  B56E FE 03            cp 3                ; down
187+  B570 CA 84 B5         jp z,control_automove3  ; don't need to do anything
188+  B573 FE 00            cp 0                ; going up
189+  B575 CA 90 B5         jp z,control_automove2
190+  B578 FE 01            cp 1                ; going left?
191+  B57A CA 9C B5         jp z,control_automove0
192+  B57D 78               ld a,b
193+  B57E 3C               inc a               ; if we're going right, increment a twice for two pixels
194+  B57F 3C               inc a
195+  B580 47               ld b,a
196+  B581 C3 A0 B5         jp control_automove1
197+  B584              control_automove3:
198+  B584 79               ld a,c
199+  B585 3C               inc a
200+  B586 3C               inc a               ; if we're going down, increment twice
201+  B587 4F               ld c,a
202+  B588 FE 90            cp 144
203+  B58A CC 68 B6         call z, control_scroll_down
204+  B58D C3 A0 B5         jp control_automove1
205+  B590              control_automove2:
206+  B590 79               ld a,c
207+  B591 3D               dec a
208+  B592 3D               dec a               ; if we're going up, decrement twice
209+  B593 4F               ld c,a
210+  B594 FE 60            cp 96
211+  B596 CC 75 B6         call z, control_scroll_up
212+  B599 C3 A0 B5         jp control_automove1
213+  B59C              control_automove0:
214+  B59C 78               ld a,b
215+  B59D 3D               dec a               ; if we're going left, decrement a twice
216+  B59E 3D               dec a
217+  B59F 47               ld b,a
218+  B5A0              control_automove1:
219+  B5A0 ED 43 D1 B8      ld (player),bc      ; and back to player
220+  B5A4 7B               ld a,e              ; now get the pixel count back
221+  B5A5 3D               dec a               ; decrease by one
222+  B5A6 21 D6 B8         ld hl,player+5
223+  B5A9 77               ld (hl),a           ; copy back
224+  B5AA CD 19 BA         call player_justmoved
225+  B5AD C9               ret
226+  B5AE
227+  B5AE              ;
228+  B5AE              ; Moves the player up
229+  B5AE              ;
230+  B5AE              control_pl_moveup:
231+  B5AE C5               push bc
232+  B5AF ED 4B D1 B8      ld bc,(player)          ; get the current coords, b horiz, c vert
233+  B5B3 79               ld a,c                  ; load c into the acc
234+  B5B4 FE 18            cp 24
235+  B5B6 CA D6 B5         jp z,control_pl_moveup0 ; are we at the edge of the screen
236+  B5B9 FE 60            cp 96
237+  B5BB CC 75 B6         call z, control_scroll_up
238+  B5BE CD 15 B8         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
239+  B5C1 F5               push af
240+  B5C2 7B               ld a,e                  ; put e in a
241+  B5C3 FE 00            cp 0
242+  B5C5 CA D5 B5         jp z,control_pl_moveup1 ; don't move if we can't
243+  B5C8 F1               pop af
244+  B5C9 D6 01            sub 1                   ; subtract 1
245+  B5CB D6 01            sub 1                   ; subtract 1
246+  B5CD 4F               ld c,a                  ; load back to c
247+  B5CE ED 43 D1 B8      ld (player),bc          ; load back to player
248+  B5D2 C3 D6 B5         jp control_pl_moveup0
249+  B5D5              control_pl_moveup1:
250+  B5D5 F1               pop af                  ; restore af if needed
251+  B5D6              control_pl_moveup0:
252+  B5D6 3E 00            ld a,0
253+  B5D8 32 D3 B8         ld (player+2),a        ; set direction to up
254+  B5DB C1               pop bc
255+  B5DC C9               ret
256+  B5DD              ;
257+  B5DD              ; Moves the player down
258+  B5DD              ;
259+  B5DD              control_pl_movedown:
260+  B5DD C5               push bc
261+  B5DE ED 4B D1 B8      ld bc,(player)          ; get the current coords, b horiz, c vert
262+  B5E2 79               ld a,c                  ; load c into the acc
263+  B5E3 FE E0            cp 224
264+  B5E5 CA 03 B6         jp z,control_pl_movedown0 ; are we at the edge of the screen
265+  B5E8 FE 80            cp 128
266+  B5EA CC 68 B6         call z, control_scroll_down
267+  B5ED CD E9 B7         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
268+  B5F0 F5               push af
269+  B5F1 7B               ld a,e                  ; put e in a
270+  B5F2 FE 00            cp 0
271+  B5F4 CA 02 B6         jp z,control_pl_movedown1 ; don't move if we can't
272+  B5F7 F1               pop af
273+  B5F8 3C               inc a                   ; add 1
274+  B5F9 3C               inc a                   ; add 1
275+  B5FA 4F               ld c,a                  ; load back to c
276+  B5FB ED 43 D1 B8      ld (player),bc          ; load back to player
277+  B5FF C3 03 B6         jp control_pl_movedown0
278+  B602              control_pl_movedown1:
279+  B602 F1               pop af                  ; restore af if needed
280+  B603              control_pl_movedown0:
281+  B603 3E 03            ld a,3
282+  B605 32 D3 B8         ld (player+2),a        ; set direction to down
283+  B608 C1               pop bc
284+  B609 C9               ret
285+  B60A              ;
286+  B60A              ; Moves the player left
287+  B60A              ;
288+  B60A              control_pl_moveleft:
289+  B60A C5               push bc
290+  B60B ED 4B D1 B8      ld bc,(player)          ; get the current coords, b horiz, c vert
291+  B60F 78               ld a,b                  ; load b into the acc
292+  B610 FE 10            cp 16
293+  B612 CA 33 B6         jp z,control_pl_moveleft0 ; are we at the edge of the screen
294+  B615 CD 74 B8         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
295+  B618 F5               push af
296+  B619 7B               ld a,e                  ; put e in a
297+  B61A FE 00            cp 0
298+  B61C CA 32 B6         jp z,control_pl_moveleft1 ; don't move if we can't
299+  B61F 21 D6 B8         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
300+  B622 3E 03            ld a,3
301+  B624 77               ld (hl),a
302+  B625 F1               pop af
303+  B626 D6 01            sub 1                    ; subtract 2
304+  B628 D6 01            sub 1
305+  B62A 47               ld b,a                  ; load back to c
306+  B62B ED 43 D1 B8      ld (player),bc          ; load back to player
307+  B62F C3 33 B6         jp control_pl_moveleft0
308+  B632              control_pl_moveleft1:
309+  B632 F1               pop af
310+  B633              control_pl_moveleft0:
311+  B633 3E 01            ld a,1
312+  B635 32 D3 B8         ld (player+2),a        ; set direction to left
313+  B638 C1               pop bc
314+  B639 C9               ret
315+  B63A              ;
316+  B63A              ; Moves the player right
317+  B63A              ;
318+  B63A              control_pl_moveright:
319+  B63A C5               push bc
320+  B63B ED 4B D1 B8      ld bc,(player)          ; get the current coords, b horiz, c vert
321+  B63F 78               ld a,b                  ; load b into the acc
322+  B640 FE F0            cp 240
323+  B642 CA 61 B6         jp z,control_pl_moveright0 ; are we at the edge of the screen
324+  B645 CD 48 B8         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
325+  B648 F5               push af
326+  B649 7B               ld a,e                  ; put e in a
327+  B64A FE 00            cp 0
328+  B64C CA 60 B6         jp z,control_pl_moveright1 ; don't move if we can't
329+  B64F 21 D6 B8         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
330+  B652 3E 03            ld a,3
331+  B654 77               ld (hl),a
332+  B655 F1               pop af
333+  B656 3C               inc a                   ; add 2
334+  B657 3C               inc a
335+  B658 47               ld b,a                  ; load back to b
336+  B659 ED 43 D1 B8      ld (player),bc          ; load back to player
337+  B65D C3 61 B6         jp control_pl_moveright0
338+  B660              control_pl_moveright1:
339+  B660 F1               pop af                  ; restore af if needed
340+  B661              control_pl_moveright0:
341+  B661 3E 02            ld a,2
342+  B663 32 D3 B8         ld (player+2),a        ; set direction to right
343+  B666 C1               pop bc
344+  B667 C9               ret
345+  B668
346+  B668              ;
347+  B668              ; Scrolls the screen down
348+  B668              ;
349+  B668              control_scroll_down:
350+  B668 F5               push af
351+  B669 3E 08            ld a,8
352+  B66B 32 F6 A6         ld (screen_offset),a
353+  B66E F1               pop af
354+  B66F 21 A5 A5         ld hl,buffer_updateall
355+  B672 36 01            ld (hl),1         ; flag as screen needing update
356+  B674 C9               ret
357+  B675
358+  B675              ;
359+  B675              ; Scrolls the screen up
360+  B675              ;
361+  B675              control_scroll_up:
362+  B675 F5               push af
363+  B676 3E 00            ld a,0
364+  B678 32 F6 A6         ld (screen_offset),a
365+  B67B F1               pop af
366+  B67C 21 A5 A5         ld hl,buffer_updateall
367+  B67F 36 01            ld (hl),1         ; flag as screen needing update
368+  B681 C9               ret
369+  B682
370+  B682
371+  B682
372+  B682
# file closed: game/control.asm
 35   B682                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  B682              ;
  2+  B682              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  3+  B682              ; Inputs:
  4+  B682              ; hl - memory location of top pixel row
  5+  B682              ; bc - screen coords, b horiz, c vert
  6+  B682              ; Outputs:
  7+  B682              ; e - 0 if not empty, 1 if empty
  8+  B682              ;
  9+  B682              movement_spaceisempty:
 10+  B682 C5               push bc
 11+  B683 E5               push hl
 12+  B684 CD AC B6         call movement_spaceisgem        ; check if space is a gem
 13+  B687 E1               pop hl
 14+  B688 C1               pop bc
 15+  B689 7B               ld a,e
 16+  B68A FE 01            cp 1
 17+  B68C C8               ret z                           ; if e is 1, space is a gem so can move here, return
 18+  B68D 3E 08            ld a,8                          ; 8 rows to check
 19+  B68F              movement_spaceisempty0:
 20+  B68F 08               ex af,af'                       ; store the loop counter
 21+  B690 7E               ld a,(hl)                       ; get current pixel row
 22+  B691 FE 00            cp 0
 23+  B693 C2 A7 B6         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 24+  B696 79               ld a,c                          ; load the vertical coord
 25+  B697 3C               inc a                           ; next row down
 26+  B698 11 20 00         ld de,32
 27+  B69B 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 28+  B69C 4F               ld c,a                          ; copy vert coord back to c
 29+  B69D 08               ex af,af'                       ; get loop counter back
 30+  B69E 3D               dec a                           ; decrease loop counter
 31+  B69F C2 8F B6         jp nz, movement_spaceisempty0
 32+  B6A2 16 00            ld d,0
 33+  B6A4 1E 01            ld e,1                          ; got to end, so space is empty
 34+  B6A6 C9               ret
 35+  B6A7              movement_spaceisempty1:
 36+  B6A7 16 00            ld d,0
 37+  B6A9 1E 00            ld e,0                          ; returning false, ie space not empty
 38+  B6AB C9               ret
 39+  B6AC
 40+  B6AC              ;
 41+  B6AC              ; Check if a space contains a gem
 42+  B6AC              ; Inputs:
 43+  B6AC              ; bc - screen coords
 44+  B6AC              ; Outputs:
 45+  B6AC              ; e = 1 if gem
 46+  B6AC              movement_spaceisgem:
 47+  B6AC CD 34 A8         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 48+  B6AF 21 0E B2         ld hl,level01diamonds           ; check diamonds first
 49+  B6B2              movement_spaceisgem0:
 50+  B6B2 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 51+  B6B6 7B               ld a,e                          ; check for end of data
 52+  B6B7 FE FF            cp 255
 53+  B6B9 CA D4 B6         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 54+  B6BC 23               inc hl
 55+  B6BD 23               inc hl                          ; move to state
 56+  B6BE 7E               ld a,(hl)
 57+  B6BF 23               inc hl
 58+  B6C0 23               inc hl
 59+  B6C1 23               inc hl                          ; get to next
 60+  B6C2 FE 01            cp 1                            ; check if collected
 61+  B6C4 CA B2 B6         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 62+  B6C7 7B               ld a,e                          ; load e again
 63+  B6C8 B9               cp c                            ; otherwise, compare c with e
 64+  B6C9 C2 B2 B6         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 65+  B6CC 7A               ld a,d                          ; get d coord
 66+  B6CD B8               cp b                            ; compare b with d
 67+  B6CE C2 B2 B6         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 68+  B6D1 1E 01            ld e,1                          ; otherwise, exit with e = 1
 69+  B6D3 C9               ret
 70+  B6D4              movement_spaceisgem1:
 71+  B6D4 21 1E B2         ld hl,level01gems              ; check gems
 72+  B6D7              movement_spaceisgem2:
 73+  B6D7 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 74+  B6DB 7B               ld a,e                          ; check for end of data
 75+  B6DC FE FF            cp 255
 76+  B6DE CA F9 B6         jp z,movement_spaceisgem3       ; if yes, done with gems
 77+  B6E1 23               inc hl
 78+  B6E2 23               inc hl                          ; move to state
 79+  B6E3 7E               ld a,(hl)
 80+  B6E4 23               inc hl
 81+  B6E5 23               inc hl
 82+  B6E6 23               inc hl                          ; get to next
 83+  B6E7 FE 01            cp 1                            ; check if collected
 84+  B6E9 CA D7 B6         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 85+  B6EC 7B               ld a,e                          ; load e again
 86+  B6ED B9               cp c                            ; otherwise, compare c with e
 87+  B6EE C2 D7 B6         jp nz,movement_spaceisgem2      ; if different, move to next gem
 88+  B6F1 7A               ld a,d                          ; get d coord
 89+  B6F2 B8               cp b                            ; compare b with d
 90+  B6F3 C2 D7 B6         jp nz,movement_spaceisgem2      ; if different, move to next gem
 91+  B6F6 1E 01            ld e,1                          ; otherwise, exit with e = 1
 92+  B6F8 C9               ret
 93+  B6F9              movement_spaceisgem3:
 94+  B6F9 1E 00            ld e,0                          ; nothing found, return e = 0
 95+  B6FB C9               ret
 96+  B6FC
 97+  B6FC              ;
 98+  B6FC              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
 99+  B6FC              ; Inputs:
100+  B6FC              ; hl - memory location of top pixel row
101+  B6FC              ; bc - screen coords, b horiz, c vert
102+  B6FC              ; Outputs:
103+  B6FC              ; e - 0 if not empty, 1 if empty
104+  B6FC              ;
105+  B6FC              movement_linebelowisempty:
106+  B6FC C5               push bc
107+  B6FD E5               push hl
108+  B6FE CD AC B6         call movement_spaceisgem        ; check if space is a gem
109+  B701 E1               pop hl
110+  B702 C1               pop bc
111+  B703 7B               ld a,e
112+  B704 FE 01            cp 1
113+  B706 C8               ret z                           ; if e is 1, space is a gem so can move here, return
114+  B707 7E               ld a,(hl)                       ; get current pixel row
115+  B708 FE 00            cp 0
116+  B70A C2 12 B7         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
117+  B70D 16 00            ld d,0
118+  B70F 1E 01            ld e,1                          ; got to end, so space is empty
119+  B711 C9               ret
120+  B712              movement_linebelowisempty1:
121+  B712 16 00            ld d,0
122+  B714 1E 00            ld e,0                          ; returning false, ie space not empty
123+  B716 C9               ret
124+  B717
125+  B717              ;
126+  B717              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
127+  B717              ; Inputs:
128+  B717              ; hl - memory location of top pixel row
129+  B717              ; bc - screen coords, b horiz, c vert
130+  B717              ; Outputs:
131+  B717              ; e - 0 if not empty, 1 if empty
132+  B717              ;
133+  B717              movement_lineaboveisempty:
134+  B717 C5               push bc
135+  B718 E5               push hl
136+  B719 CD AC B6         call movement_spaceisgem        ; check if space is a gem
137+  B71C E1               pop hl
138+  B71D C1               pop bc
139+  B71E 7B               ld a,e
140+  B71F FE 01            cp 1
141+  B721 C8               ret z
142+  B722 7E               ld a,(hl)                       ; get current pixel row
143+  B723 FE 00            cp 0
144+  B725 C2 2D B7         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
145+  B728 16 00            ld d,0
146+  B72A 1E 01            ld e,1                          ; got to end, so space is empty
147+  B72C C9               ret
148+  B72D              movement_lineaboveisempty1:
149+  B72D 16 00            ld d,0
150+  B72F 1E 00            ld e,0                          ; returning false, ie space not empty
151+  B731 C9               ret
152+  B732
153+  B732              ;
154+  B732              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
155+  B732              ; Inputs:
156+  B732              ; hl - memory location of top pixel row
157+  B732              ; bc - screen coords, b horiz, c vert
158+  B732              ; Outputs:
159+  B732              ; none - puts player into digging mode
160+  B732              ;
161+  B732              movement_spaceisdiggable:
162+  B732 3E 08            ld a,8                          ; 8 rows to check
163+  B734              movement_spaceisdiggable0:
164+  B734 08               ex af,af'                       ; store the loop counter
165+  B735 7E               ld a,(hl)                       ; get current pixel row
166+  B736 FE 00            cp 0
167+  B738 CA 48 B7         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
168+  B73B FE 55            cp 85
169+  B73D CA 48 B7         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
170+  B740 FE AA            cp 170
171+  B742 CA 48 B7         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
172+  B745 C3 60 B7         jp movement_spaceisdiggable1     ; otherwise, stop checking
173+  B748              movement_spaceisdiggable2:
174+  B748 79               ld a,c                          ; load the vertical coord
175+  B749 3C               inc a                           ; next row down
176+  B74A 11 20 00         ld de,32
177+  B74D 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
178+  B74E 4F               ld c,a                          ; copy vert coord back to c
179+  B74F 08               ex af,af'                       ; get loop counter back
180+  B750 3D               dec a                           ; decrease loop counter
181+  B751 C2 34 B7         jp nz, movement_spaceisdiggable0
182+  B754 21 D7 B8         ld hl,player+6
183+  B757 36 01            ld (hl),1                       ; set the player into digging mode
184+  B759 23               inc hl
185+  B75A 36 05            ld (hl),5                      ; set the number of frame to dig for
186+  B75C 23               inc hl
187+  B75D 36 08            ld (hl),8                       ; set the number of pixels to dig
188+  B75F C9               ret
189+  B760              movement_spaceisdiggable1:
190+  B760 21 D7 B8         ld hl,player+6
191+  B763 36 00            ld (hl),0                       ; set the player out of digging mode
192+  B765 C9               ret
193+  B766
194+  B766              ;
195+  B766              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
196+  B766              ; Inputs:
197+  B766              ; hl - memory location of top pixel row
198+  B766              ; bc - screen coords, b horiz, c vert
199+  B766              ; Outputs:
200+  B766              ; none - puts player into digging mode
201+  B766              ;
202+  B766              movement_spacebelowisdiggable:
203+  B766 7E               ld a,(hl)                       ; get first pixel row
204+  B767 FE 55            cp 85
205+  B769 CA 74 B7         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
206+  B76C FE AA            cp 170
207+  B76E CA 74 B7         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
208+  B771 C3 60 B7         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
209+  B774              movement_spacebelowisdiggable3:
210+  B774 3E 08            ld a,8                          ; rows to check
211+  B776 1E 00            ld e,0                          ; count of rows to dig
212+  B778              movement_spacebelowisdiggable0:
213+  B778 08               ex af,af'                       ; store the loop counter
214+  B779 7E               ld a,(hl)                       ; get current pixel row
215+  B77A FE 55            cp 85
216+  B77C CA 87 B7         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
217+  B77F FE AA            cp 170
218+  B781 CA 87 B7         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
219+  B784 C3 96 B7         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
220+  B787              movement_spacebelowisdiggable4:
221+  B787 1C               inc e                           ; inc count of rows to dig
222+  B788              movement_spacebelowisdiggable2:
223+  B788 79               ld a,c                          ; load the vertical coord
224+  B789 3C               inc a                           ; next row down
225+  B78A D5               push de                         ; need e for later
226+  B78B 11 20 00         ld de,32
227+  B78E 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
228+  B78F 4F               ld c,a                          ; copy vert coord back to c
229+  B790 D1               pop de                          ; get e back
230+  B791 08               ex af,af'                       ; get loop counter back
231+  B792 3D               dec a                           ; incease loop counter
232+  B793 C2 78 B7         jp nz, movement_spacebelowisdiggable0
233+  B796              movement_spacebelowisdiggable5:
234+  B796 21 D7 B8         ld hl,player+6
235+  B799 36 01            ld (hl),1                       ; set the player into digging mode
236+  B79B 23               inc hl
237+  B79C 36 03            ld (hl),3                      ; set the number of frame to dig for
238+  B79E 23               inc hl
239+  B79F 73               ld (hl),e                       ; set the number of pixels to dig
240+  B7A0 C9               ret
241+  B7A1              movement_spacebelowisdiggable1:
242+  B7A1 21 D7 B8         ld hl,player+6
243+  B7A4 36 00            ld (hl),0                       ; set the player out of digging mode
244+  B7A6 C9               ret
245+  B7A7
246+  B7A7              ;
247+  B7A7              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
248+  B7A7              ; Inputs:
249+  B7A7              ; hl - memory location of top pixel row
250+  B7A7              ; bc - screen coords, b horiz, c vert
251+  B7A7              ; Outputs:
252+  B7A7              ; none - puts player into digging mode
253+  B7A7              ;
254+  B7A7              movement_spaceaboveisdiggable:
255+  B7A7 7E               ld a,(hl)                       ; get first pixel row
256+  B7A8 FE 55            cp 85
257+  B7AA CA B5 B7         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
258+  B7AD FE AA            cp 170
259+  B7AF CA B5 B7         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
260+  B7B2 C3 60 B7         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
261+  B7B5              movement_spaceaboveisdiggable3:
262+  B7B5 3E 08            ld a,8                          ; rows to check
263+  B7B7 1E 00            ld e,0                          ; count of rows to dig
264+  B7B9              movement_spaceaboveisdiggable0:
265+  B7B9 08               ex af,af'                       ; store the loop counter
266+  B7BA 7E               ld a,(hl)                       ; get current pixel row
267+  B7BB FE 55            cp 85
268+  B7BD CA C8 B7         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
269+  B7C0 FE AA            cp 170
270+  B7C2 CA C8 B7         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
271+  B7C5 C3 D8 B7         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
272+  B7C8              movement_spaceaboveisdiggable4:
273+  B7C8 1C               inc e                           ; inc count of rows to dig
274+  B7C9              movement_spaceaboveisdiggable2:
275+  B7C9 79               ld a,c                          ; load the vertical coord
276+  B7CA 3D               dec a                           ; next row up
277+  B7CB D5               push de                         ; need e for later
278+  B7CC 11 20 00         ld de,32
279+  B7CF ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
280+  B7D1 4F               ld c,a                          ; copy vert coord back to c
281+  B7D2 D1               pop de                          ; get e back
282+  B7D3 08               ex af,af'                       ; get loop counter back
283+  B7D4 3D               dec a                           ; incease loop counter
284+  B7D5 C2 B9 B7         jp nz, movement_spaceaboveisdiggable0
285+  B7D8              movement_spaceaboveisdiggable5:
286+  B7D8 21 D7 B8         ld hl,player+6
287+  B7DB 36 01            ld (hl),1                       ; set the player into digging mode
288+  B7DD 23               inc hl
289+  B7DE 36 05            ld (hl),5                       ; set the number of frame to dig for
290+  B7E0 23               inc hl
291+  B7E1 73               ld (hl),e                       ; set the number of pixels to dig
292+  B7E2 C9               ret
293+  B7E3              movement_spaceaboveisdiggable1:
294+  B7E3 21 D7 B8         ld hl,player+6
295+  B7E6 36 00            ld (hl),0                       ; set the player out of digging mode
296+  B7E8 C9               ret
297+  B7E9
298+  B7E9              ;
299+  B7E9              ; Checks if the player can move down
300+  B7E9              ; Inputs:
301+  B7E9              ; bc - player coords, b horiz, c vert
302+  B7E9              ; Outputs:
303+  B7E9              ; de - 1 can move
304+  B7E9              movement_checkcanmove_down:
305+  B7E9 F5               push af
306+  B7EA C5               push bc
307+  B7EB CD 12 A9         call sprites_scadd              ; get the memory location of cell into de
308+  B7EE 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
309+  B7F0 24               inc h                       ; memory location of cell beneath now in hl
310+  B7F1 3E 08            ld a,8                       ; look below
311+  B7F3 81               add c
312+  B7F4 4F               ld c,a
313+  B7F5 CD FC B6         call movement_linebelowisempty       ; check space is empty
314+  B7F8 7B               ld a,e                          ; check space empty flag
315+  B7F9 FE 00            cp 0
316+  B7FB CA 04 B8         jp z, movement_checkcanmove_down1 ; can't move
317+  B7FE CD 19 BA         call player_justmoved
318+  B801 C1               pop bc
319+  B802 F1               pop af
320+  B803 C9               ret
321+  B804              movement_checkcanmove_down1:
322+  B804 C1               pop bc
323+  B805 CD 12 A9         call sprites_scadd              ; get the memory location of cell into de
324+  B808 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
325+  B80A 24               inc h
326+  B80B C5               push bc
327+  B80C CD 66 B7         call movement_spacebelowisdiggable    ; can't move here, but can we dig
328+  B80F 11 00 00         ld de,0
329+  B812 C1               pop bc
330+  B813 F1               pop af
331+  B814 C9               ret
332+  B815
333+  B815              ;
334+  B815              ; Checks if the player can move up
335+  B815              ; Inputs:
336+  B815              ; bc - player coords, b horiz, c vert
337+  B815              ; Outputs:
338+  B815              ; de - 1 can move
339+  B815              movement_checkcanmove_up:
340+  B815 F5               push af
341+  B816 C5               push bc
342+  B817 CD 12 A9         call sprites_scadd              ; get the memory location of cell into de
343+  B81A 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
344+  B81C 11 20 00         ld de,32
345+  B81F ED 52            sbc hl,de                       ; memory location of line above now in hl
346+  B821 0D               dec c                           ; look above
347+  B822 CD 17 B7         call movement_lineaboveisempty       ; check space is empty
348+  B825 7B               ld a,e                          ; check space empty flag
349+  B826 FE 00            cp 0
350+  B828 CA 33 B8         jp z, movement_checkcanmove_up1 ; can't move
351+  B82B 1E 01            ld e,1
352+  B82D CD 19 BA         call player_justmoved
353+  B830 C1               pop bc
354+  B831 F1               pop af
355+  B832 C9               ret
356+  B833              movement_checkcanmove_up1:
357+  B833 C1               pop bc
358+  B834 CD 12 A9         call sprites_scadd              ; get the memory location of cell into de
359+  B837 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
360+  B839 11 20 00         ld de,32
361+  B83C ED 52            sbc hl,de                       ; memory location of line above now in hl
362+  B83E C5               push bc
363+  B83F CD A7 B7         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
364+  B842 11 00 00         ld de,0
365+  B845 C1               pop bc
366+  B846 F1               pop af
367+  B847 C9               ret
368+  B848
369+  B848              ;
370+  B848              ; Checks if the player can move right
371+  B848              ; Inputs:
372+  B848              ; bc - player coords, b horiz, c vert
373+  B848              ; Outputs:
374+  B848              ; de - 1 can move
375+  B848              movement_checkcanmove_right:
376+  B848 F5               push af
377+  B849 C5               push bc
378+  B84A CD 12 A9         call sprites_scadd              ; get the memory location of cell into de
379+  B84D 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
380+  B84F 3E 08            ld a,8
381+  B851 80               add b                           ; move one cell right
382+  B852 47               ld b,a
383+  B853 23               inc hl                          ; memory location of cell to the right now in hl
384+  B854 CD 82 B6         call movement_spaceisempty       ; check space is empty
385+  B857 7B               ld a,e                          ; check space empty flag
386+  B858 FE 00            cp 0
387+  B85A CA 63 B8         jp z, movement_checkcanmove_right1 ; can't move
388+  B85D CD 19 BA         call player_justmoved
389+  B860 C1               pop bc
390+  B861 F1               pop af
391+  B862 C9               ret
392+  B863              movement_checkcanmove_right1:
393+  B863 C1               pop bc
394+  B864 CD 12 A9         call sprites_scadd              ; get the memory location of cell into de
395+  B867 62 6B            ld hl,de
396+  B869 23               inc hl                          ; memory location of cell to the right now in hl
397+  B86A C5               push bc
398+  B86B CD 32 B7         call movement_spaceisdiggable    ; can't move here, but can we dig
399+  B86E 11 00 00         ld de,0
400+  B871 C1               pop bc
401+  B872 F1               pop af
402+  B873 C9               ret
403+  B874
404+  B874              ;
405+  B874              ; Checks if the player can move left
406+  B874              ; Inputs:
407+  B874              ; bc - player coords, b horiz, c vert
408+  B874              ; Outputs:
409+  B874              ; de - 1 can move
410+  B874              movement_checkcanmove_left:
411+  B874 F5               push af
412+  B875 C5               push bc
413+  B876 CD 12 A9         call sprites_scadd              ; get the memory location of cell into de
414+  B879 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
415+  B87B 78               ld a,b
416+  B87C 06 08            ld b,8
417+  B87E 90               sub b                           ; move one cell left
418+  B87F 47               ld b,a
419+  B880 2B               dec hl                          ; memory location of cell to the right now in hl
420+  B881 CD 82 B6         call movement_spaceisempty       ; check space is empty
421+  B884 7B               ld a,e                          ; check space empty flag
422+  B885 FE 00            cp 0
423+  B887 CA 90 B8         jp z, movement_checkcanmove_left1 ; can't move
424+  B88A CD 19 BA         call player_justmoved
425+  B88D C1               pop bc
426+  B88E F1               pop af
427+  B88F C9               ret
428+  B890              movement_checkcanmove_left1:
429+  B890 C1               pop bc
430+  B891 CD 12 A9         call sprites_scadd              ; get the memory location of cell into de
431+  B894 62 6B            ld hl,de
432+  B896 2B               dec hl                          ; memory location of cell to the right now in hl
433+  B897 C5               push bc
434+  B898 CD 32 B7         call movement_spaceisdiggable    ; can't move here, but can we dig
435+  B89B 11 00 00         ld de,0
436+  B89E C1               pop bc
437+  B89F F1               pop af
438+  B8A0 C9               ret
# file closed: game/movement.asm
 36   B8A1                  include "game\game.asm"
# file opened: game/game.asm
  1+  B8A1              ;
  2+  B8A1              ; The current frame count, incremented each frame
  3+  B8A1              ;
  4+  B8A1              game_framenumber:
  5+  B8A1 00               defb    0
  6+  B8A2
  7+  B8A2              ;
  8+  B8A2              ; The number of players
  9+  B8A2              ;
 10+  B8A2              game_numberplayers:
 11+  B8A2 01               defb 1
 12+  B8A3
 13+  B8A3              ;
 14+  B8A3              ; The current player
 15+  B8A3              ;
 16+  B8A3              game_currentplayer:
 17+  B8A3 01               defb 1
 18+  B8A4
 19+  B8A4              ;
 20+  B8A4              ; The default number of lives
 21+  B8A4              ;
 22+  B8A4              game_numberlives:
 23+  B8A4 04               defb 4
 24+  B8A5
 25+  B8A5              ;
 26+  B8A5              ; Moves to the next player
 27+  B8A5              ;
 28+  B8A5              game_changeplayer:
 29+  B8A5 3A A3 B8         ld a,(game_currentplayer)
 30+  B8A8 FE 01            cp 1
 31+  B8AA C8               ret z                       ; if just one player, no need to change
 32+  B8AB 3D               dec a                       ; otherwise decrease by one
 33+  B8AC EE 01            xor 1                       ; xor with one to flip
 34+  B8AE 3C               inc a                       ; increment
 35+  B8AF 21 A3 B8         ld hl,game_currentplayer
 36+  B8B2 77               ld (hl),a                   ; store
 37+  B8B3 C9               ret
 38+  B8B4
 39+  B8B4              ;
 40+  B8B4              ; Sets the number of players at the start of the game
 41+  B8B4              ; Inputs:
 42+  B8B4              ; a - number of players
 43+  B8B4              game_setnumberofplayers:
 44+  B8B4 21 A2 B8         ld hl,game_numberplayers
 45+  B8B7 77               ld (hl),a
 46+  B8B8
 47+  B8B8              ;
 48+  B8B8              ; Increment frame number by 1
 49+  B8B8              ;
 50+  B8B8              game_incrementframe:
 51+  B8B8 3A A1 B8         ld a,(game_framenumber)
 52+  B8BB FE FF            cp 255
 53+  B8BD C2 C2 B8         jp nz,game_incrementframe0
 54+  B8C0 3E 00            ld a,0
 55+  B8C2              game_incrementframe0:
 56+  B8C2 3C               inc a
 57+  B8C3 32 A1 B8         ld (game_framenumber),a
 58+  B8C6 C9               ret
 59+  B8C7
 60+  B8C7              ;
 61+  B8C7              ; Returns current frame
 62+  B8C7              ; Outputs:
 63+  B8C7              ; a - current frame
 64+  B8C7              ;
 65+  B8C7              game_getcurrentframe:
 66+  B8C7 3A A1 B8         ld a,(game_framenumber)
 67+  B8CA C9               ret
 68+  B8CB
 69+  B8CB              ;
 70+  B8CB              ; Resets current frame
 71+  B8CB              ;
 72+  B8CB              game_resetcurrentframe:
 73+  B8CB 21 A1 B8         ld hl,game_framenumber
 74+  B8CE 36 00            ld (hl),0
 75+  B8D0 C9               ret
# file closed: game/game.asm
 37   B8D1                  include "game\player.asm"
# file opened: game/player.asm
  1+  B8D1              ;
  2+  B8D1              ;   Data for current player
  3+  B8D1              ;
  4+  B8D1              player:
  5+  B8D1 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  B8D3 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  B8D6 00               defb    0                   ; auto move remaining (+5)
  8+  B8D7 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  B8DA 00               defb    0                   ; lives remaining (+9)
 10+  B8DB 00               defb    0                   ; died this life (+10)
 11+  B8DC 00 00            defb    0,0                 ; crushed (+11), frames (+12)
 12+  B8DE 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  B8DF
 14+  B8DF              ;
 15+  B8DF              ; Initializes a player at start of game
 16+  B8DF              ; Copy initial coords, copy lives, copy score
 17+  B8DF              ;
 18+  B8DF              player_init_gamestart:
 19+  B8DF 3A A4 B8         ld a,(game_numberlives)
 20+  B8E2 32 6E B9         ld (player1_lives),a
 21+  B8E5 32 6F B9         ld (player2_lives),a                        ; set the initial number of lives at game start
 22+  B8E8
 23+  B8E8 21 72 B9         ld hl,player1_score+2
 24+  B8EB 06 06            ld b,6
 25+  B8ED              player_init_gamestart0:
 26+  B8ED 36 30            ld (hl),48
 27+  B8EF 23               inc hl
 28+  B8F0 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 29+  B8F2 21 7B B9         ld hl,player2_score+2
 30+  B8F5 06 06            ld b,6
 31+  B8F7              player_init_gamestart1:
 32+  B8F7 36 30            ld (hl),48
 33+  B8F9 23               inc hl
 34+  B8FA 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 35+  B8FC C9               ret
 36+  B8FD
 37+  B8FD              ;
 38+  B8FD              ; Initializes a player at start of a life
 39+  B8FD              ; Copy initial coords, copy lives, copy score
 40+  B8FD              ;
 41+  B8FD              player_init_lifestart:
 42+  B8FD 21 D6 B8         ld hl,player+5
 43+  B900 06 09            ld b,9                      ; initialise 9 properties
 44+  B902              player_init_lifestart2:
 45+  B902 36 00            ld (hl),0
 46+  B904 23               inc hl
 47+  B905 10 FB            djnz player_init_lifestart2
 48+  B907
 49+  B907 21 D3 B8         ld hl,player+2              ; initialise some properties
 50+  B90A 36 02            ld (hl),2
 51+  B90C 23               inc hl
 52+  B90D 36 00            ld (hl),0
 53+  B90F 23               inc hl
 54+  B910 36 01            ld (hl),1
 55+  B912
 56+  B912 ED 4B 22 80      ld bc,(init_coord)
 57+  B916 ED 43 D1 B8      ld (player),bc
 58+  B91A 01 DA B8         ld bc,player+9
 59+  B91D 3A 6E B9         ld a,(player1_lives)
 60+  B920 02               ld (bc),a
 61+  B921
 62+  B921 CD CC C0         call diamonds_init      ; initialise gems
 63+  B924
 64+  B924 01 06 00         ld bc,6
 65+  B927 11 12 BF         ld de,scores_current+2
 66+  B92A 3A A3 B8         ld a,(game_currentplayer)
 67+  B92D FE 01            cp 1
 68+  B92F C2 38 B9         jp nz,player_init_lifestart0
 69+  B932 21 72 B9         ld hl,player1_score+2
 70+  B935 C3 3B B9         jp player_init_lifestart1
 71+  B938              player_init_lifestart0:
 72+  B938 21 7B B9         ld hl,player2_score+2
 73+  B93B              player_init_lifestart1:
 74+  B93B ED B0            ldir
 75+  B93D C9               ret
 76+  B93E
 77+  B93E              ;
 78+  B93E              ; Finalises a player at end of a life
 79+  B93E              ; Copy lives, copy score
 80+  B93E              ;
 81+  B93E              player_lifeend:
 82+  B93E 01 DA B8         ld bc,player+9
 83+  B941 0A               ld a,(bc)
 84+  B942 01 6E B9         ld bc,player1_lives
 85+  B945 02               ld (bc),a
 86+  B946 CD 4A B9         call player_recordcurrentscore
 87+  B949 C9               ret
 88+  B94A
 89+  B94A              ;
 90+  B94A              ; Copies the current score in the current
 91+  B94A              ;
 92+  B94A              player_recordcurrentscore:
 93+  B94A 01 06 00         ld bc,6                  ; copy current score back to correct player
 94+  B94D 21 12 BF         ld hl,scores_current+2
 95+  B950 3A A3 B8         ld a,(game_currentplayer)
 96+  B953 FE 01            cp 1
 97+  B955 C2 5E B9         jp nz,player_lifeend0
 98+  B958 11 72 B9         ld de,player1_score+2
 99+  B95B C3 61 B9         jp player_lifeend1
100+  B95E              player_lifeend0:
101+  B95E 11 7B B9         ld de,player2_score+2
102+  B961              player_lifeend1:
103+  B961 ED B0            ldir
104+  B963 C9               ret
105+  B964
106+  B964              ;
107+  B964              ; Player just died, subtract a life
108+  B964              ;
109+  B964              player_died:
110+  B964 01 DA B8         ld bc,player+9
111+  B967 0A               ld a,(bc)
112+  B968 3D               dec a
113+  B969 02               ld (bc),a
114+  B96A CD 3E B9         call player_lifeend
115+  B96D C9               ret
116+  B96E
117+  B96E              ;
118+  B96E              ; Player lives
119+  B96E              ;
120+  B96E              player1_lives:
121+  B96E 03               defb 3
122+  B96F              player2_lives:
123+  B96F 03               defb 3
124+  B970
125+  B970              ;
126+  B970              ; Player scores
127+  B970              ;
128+  B970              player1_score:
129+  B970 04 01 30 30      defb 4,1,'000000',255
129+  B974 30 30 30 30
129+  B978 FF
130+  B979              player2_score:
131+  B979 16 01 30 30      defb 22,1,'000000',255
131+  B97D 30 30 30 30
131+  B981 FF
132+  B982
133+  B982              ;
134+  B982              ; Kills a player this life
135+  B982              ;
136+  B982              player_killplayer:
137+  B982 21 DB B8         ld hl,player+10
138+  B985 36 01            ld (hl),1
139+  B987 C9               ret
140+  B988
141+  B988              ;
142+  B988              ; Crush a player this life
143+  B988              ;
144+  B988              player_crushplayer:
145+  B988 21 DC B8         ld hl,player+11             ; mark as crushed
146+  B98B 36 01            ld (hl),1
147+  B98D C9               ret
148+  B98E
149+  B98E              player_tankkillplayer
150+  B98E 21 DC B8         ld hl,player+11             ; mark as tanked
151+  B991 36 02            ld (hl),2
152+  B993 C9               ret
153+  B994              ;
154+  B994              ; Draws the player at the current position or deletes them
155+  B994              ;
156+  B994              player_drawplayer:
157+  B994 3A D3 B8         ld a,(player+2)             ; get the current direction
158+  B997 FE 03            cp 3
159+  B999 C2 9E B9         jp nz,player_drawplayer0
160+  B99C 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
161+  B99E              player_drawplayer0:
162+  B99E 5F               ld e,a                      ; store in e
163+  B99F 3A DC B8         ld a,(player+11)             ; get the dying flag
164+  B9A2 FE 01            cp 1
165+  B9A4 CA B6 B9         jp z,player_drawplayer3     ; if it's one, we're being crushed
166+  B9A7              player_drawplayer4:
167+  B9A7 3A D7 B8         ld a,(player+6)             ; get the dig flag
168+  B9AA FE 01            cp 1
169+  B9AC CA FF B9         jp z,player_drawplayer1    ; get dig frame
170+  B9AF 3A D4 B8         ld a,(player+3)             ; this is normal movement so get the current frame
171+  B9B2 83               add a,e
172+  B9B3 C3 04 BA         jp player_drawplayer2
173+  B9B6              player_drawplayer3:
174+  B9B6 21 DD B8         ld hl,player+12
175+  B9B9 7E               ld a,(hl)                  ; crushing, so get the current anim flag
176+  B9BA FE 00            cp 0
177+  B9BC C2 C5 B9         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
178+  B9BF 3E 64            ld a,100
179+  B9C1 77               ld (hl),a                   ; otherwise, load up the anim frames
180+  B9C2 C3 A7 B9         jp player_drawplayer4       ; and return to the main loop to remove the current frame
181+  B9C5              player_drawplayer5:
182+  B9C5 3D               dec a
183+  B9C6 77               ld (hl),a
184+  B9C7 FE 00            cp 0
185+  B9C9 CC 82 B9         call z,player_killplayer    ; final animation, so kill the player
186+  B9CC FE 14            cp 20                        ; check if we should move the rock
187+  B9CE C2 E2 B9         jp nz,player_drawplayer8
188+  B9D1 D9               exx
189+  B9D2 08               ex af,af'
190+  B9D3 ED 4B B3 BD      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
191+  B9D7 21 DB B2         ld hl,sprites+72
192+  B9DA CD CF A8         call sprites_drawsprite     ; draw a rock over current
193+  B9DD 08               ex af,af'
194+  B9DE D9               exx
195+  B9DF C3 F8 B9         jp player_drawplayer6       ; continue drawing player
196+  B9E2              player_drawplayer8:
197+  B9E2 FE 14            cp 20
198+  B9E4 D2 F8 B9         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
199+  B9E7 ED 4B D1 B8      ld bc,(player)
200+  B9EB CD 21 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
201+  B9EE 62 6B            ld hl,de
202+  B9F0 36 42            ld (hl),66
203+  B9F2 21 DB B2         ld hl,sprites+72            ; otherwise, player is rock
204+  B9F5 C3 0E BA         jp player_drawplayer7
205+  B9F8              player_drawplayer6:
206+  B9F8 E6 01            and 1                       ; check for odd
207+  B9FA C6 0A            add 10                      ; add 10, to get either 10 or 11
208+  B9FC C3 04 BA         jp player_drawplayer2
209+  B9FF              player_drawplayer1:
210+  B9FF 3A D3 B8         ld a,(player+2)             ; digging, get the current direction again, because want all four
211+  BA02 C6 06            add a,6                     ; add direction to 6 to get frame
212+  BA04              player_drawplayer2:
213+  BA04 07               rlca
214+  BA05 07               rlca
215+  BA06 07               rlca                        ; multiply by eight
216+  BA07 6F               ld l,a
217+  BA08 26 00            ld h,0
218+  BA0A 11 46 B3         ld de,player_sprite
219+  BA0D 19               add hl,de                   ; load hl with the location of the player sprite data
220+  BA0E              player_drawplayer7:
221+  BA0E ED 4B D1 B8      ld bc,(player)              ; load bc with the start coords
222+  BA12 CD CF A8         call sprites_drawsprite     ; call the routine to draw the sprite
223+  BA15 CD 45 BA         call player_storeupdatedlines ; log updated rows
224+  BA18 C9               ret
225+  BA19
226+  BA19
227+  BA19              ;
228+  BA19              ; Runs after the player just moved. Changes animation frame if required
229+  BA19              ;
230+  BA19              player_justmoved:
231+  BA19 D9               exx
232+  BA1A 3A D5 B8         ld a,(player+4)             ; get the transition count
233+  BA1D FE 00            cp 0
234+  BA1F CA 25 BA         jp z, player_justmoved2     ; if zero reset and change the frame
235+  BA22 C3 3F BA         jp player_justmoved1       ; otherwise decrease and continue
236+  BA25              player_justmoved2:
237+  BA25                  ; reset and change frame in here
238+  BA25 3E 01            ld a,1
239+  BA27 32 D5 B8         ld (player+4),a            ; reset back to whatever
240+  BA2A 3A D4 B8         ld a,(player+3)             ; load the frame
241+  BA2D FE 03            cp 3                       ; flip between 3 and 0
242+  BA2F C2 37 BA         jp nz, player_justmoved4
243+  BA32 3E 00            ld a,0
244+  BA34 C3 39 BA         jp player_justmoved5
245+  BA37              player_justmoved4:
246+  BA37 3E 03            ld a,3
247+  BA39              player_justmoved5:
248+  BA39 32 D4 B8         ld (player+3),a           ; save back
249+  BA3C C3 43 BA         jp player_justmoved3
250+  BA3F              player_justmoved1:
251+  BA3F                  ; decrease count
252+  BA3F 3D               dec a
253+  BA40 32 D5 B8         ld (player+4),a
254+  BA43              player_justmoved3:
255+  BA43 D9               exx;
256+  BA44 C9               ret
257+  BA45
258+  BA45              ;
259+  BA45              ; Stores the updated rows associated with the player
260+  BA45              ;
261+  BA45              player_storeupdatedlines:
262+  BA45 ED 4B D1 B8      ld bc,(player)          ; get the screen coords into bc
263+  BA49 79               ld a,c                  ; get the player block coords of current block
264+  BA4A E6 F8            and 248                 ; find closest multiple of eight
265+  BA4C 0F               rrca
266+  BA4D 0F               rrca
267+  BA4E 0F               rrca                    ; divide by 8
268+  BA4F ED 5B F6 A6      ld de,(screen_offset)          ; load the screen offset, this is in rows
269+  BA53 93               sub e
270+  BA54 F5               push af
271+  BA55 CD A6 A5         call buffer_marklineforupdate  ; store current row in updated lines
272+  BA58 F1               pop af
273+  BA59 3D               dec a
274+  BA5A F5               push af
275+  BA5B CD A6 A5         call buffer_marklineforupdate  ; store line above
276+  BA5E F1               pop af
277+  BA5F 3C               inc a
278+  BA60 3C               inc a
279+  BA61 CD A6 A5         call buffer_marklineforupdate  ; store line beneath
280+  BA64 C9               ret
281+  BA65
282+  BA65              ;
283+  BA65              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
284+  BA65              ; Outputs:
285+  BA65              ; a - 1 for completed level
286+  BA65              player_checkforexit:
287+  BA65 ED 4B D1 B8      ld bc,(player)                 ; get player coords
288+  BA69 ED 5B 22 80      ld de,(init_coord)             ; get start coords
289+  BA6D 78               ld a,b
290+  BA6E BA               cp d                         ; compare horiz
291+  BA6F C2 7A BA         jp nz,player_checkforexit1
292+  BA72 79               ld a,c
293+  BA73 BB               cp e                        ; compare vert
294+  BA74 C2 7A BA         jp nz,player_checkforexit1
295+  BA77              player_checkforexit0:
296+  BA77 3E 01            ld a,1                       ; hasn't completed
297+  BA79 C9               ret
298+  BA7A              player_checkforexit1:
299+  BA7A 3E 00            ld a,0                       ; has completed
300+  BA7C C9               ret
# file closed: game/player.asm
 38   BA7D                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  BA7D              ;
  2+  BA7D              ; Ship initial position: vert,horiz
  3+  BA7D              ;
  4+  BA7D              ship_initpos:
  5+  BA7D 00 24            defb 0,36
  6+  BA7F              ship_initpos2:
  7+  BA7F 00 00            defb 0,0
  8+  BA81              ship_frame:
  9+  BA81 00               defb 0
 10+  BA82              ;
 11+  BA82              ; The current memory location
 12+  BA82              ;
 13+  BA82              ship_current_sprite:
 14+  BA82 00 00            defb 0,0
 15+  BA84
 16+  BA84              ship_current_coords:
 17+  BA84 00 00            defb 0,0
 18+  BA86
 19+  BA86              ship_process:
 20+  BA86 3A DC B8         ld a,(player+11)
 21+  BA89 FE 02            cp 2                        ; has the player been killed by tank?
 22+  BA8B C0               ret nz                      ; do nothing if not
 23+  BA8C CD 75 B6         call control_scroll_up           ; make sure the screen is on the top screen
 24+  BA8F CD FE BA         call ship_takeoff           ; bye bye
 25+  BA92 CD 82 B9         call player_killplayer      ; killed
 26+  BA95 06 32            ld b,50
 27+  BA97 CD 82 80         call utilities_pauseforframes
 28+  BA9A C9               ret
 29+  BA9B
 30+  BA9B              ;
 31+  BA9B              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  BA9B              ;
 33+  BA9B              ship_land:
 34+  BA9B ED 4B 7D BA      ld bc,(ship_initpos)
 35+  BA9F ED 43 7F BA      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  BAA3 1E 00            ld e,0                      ; store a flag to track first time round
 37+  BAA5 06 09            ld b,9                      ; move down 8 pixels
 38+  BAA7              ship_land0:
 39+  BAA7 C5               push bc
 40+  BAA8 7B               ld a,e
 41+  BAA9 D5               push de                     ; store de for next time round
 42+  BAAA FE 01            cp 1                        ; check first time flag
 43+  BAAC C2 C1 BA         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  BAAF CD 55 BB         call ship_draw_full         ; delete old one
 45+  BAB2 CD 2A BB         call ship_change_frame      ; increment the frame
 46+  BAB5 ED 4B 7F BA      ld bc,(ship_initpos2)       ; get the current coords
 47+  BAB9 81 C6 01         add c,1                     ; move down one pixels
 48+  BABC 4F               ld c,a
 49+  BABD ED 43 7F BA      ld (ship_initpos2),bc
 50+  BAC1              ship_land1:
 51+  BAC1 CD 55 BB         call ship_draw_full         ; draw the ship
 52+  BAC4 CD 3F BB         call ship_draw_screen
 53+  BAC7 D1               pop de
 54+  BAC8 1E 01            ld e,1
 55+  BACA C1               pop bc
 56+  BACB 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  BACD                  ; done moving down
 58+  BACD                  ; now move across
 59+  BACD CD 94 B9         call player_drawplayer      ; draw player
 60+  BAD0 CD 55 BB         call ship_draw_full         ; delete old one
 61+  BAD3 1E 00            ld e,0                      ; store a flag to track first time round
 62+  BAD5 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  BAD7              ship_land3:
 64+  BAD7 C5               push bc
 65+  BAD8 7B               ld a,e
 66+  BAD9 D5               push de                     ; store de for next time round
 67+  BADA FE 01            cp 1                        ; check first time flag
 68+  BADC C2 F1 BA         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  BADF CD 55 BB         call ship_draw_full         ; delete old one
 70+  BAE2 CD 2A BB         call ship_change_frame      ; increment the frame
 71+  BAE5 ED 4B 7F BA      ld bc,(ship_initpos2)       ; get the current coords
 72+  BAE9 78               ld a,b
 73+  BAEA D6 01            sub 1                       ; move back one pixels
 74+  BAEC 47               ld b,a
 75+  BAED ED 43 7F BA      ld (ship_initpos2),bc
 76+  BAF1              ship_land2:
 77+  BAF1 CD 55 BB         call ship_draw_full         ; draw the ship
 78+  BAF4 CD 3F BB         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  BAF7 D1               pop de
 80+  BAF8 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  BAFA C1               pop bc
 82+  BAFB 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  BAFD C9               ret
 84+  BAFE
 85+  BAFE              ;
 86+  BAFE              ;   Take off the ship
 87+  BAFE              ;
 88+  BAFE              ship_takeoff:
 89+  BAFE 1E 01            ld e,1                      ; store a flag to track first time round
 90+  BB00 06 08            ld b,8                      ; move up 8 pixels
 91+  BB02              ship_takeoff0:
 92+  BB02 C5               push bc
 93+  BB03 7B               ld a,e
 94+  BB04 D5               push de                     ; store de for next time round
 95+  BB05 FE 01            cp 1                        ; check first time flag
 96+  BB07 C2 1D BB         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  BB0A ED 4B 7F BA      ld bc,(ship_initpos2)       ; get the current coords
 98+  BB0E CD 55 BB         call ship_draw_full         ; delete old one
 99+  BB11 CD 2A BB         call ship_change_frame      ; increment the frame
100+  BB14 ED 4B 7F BA      ld bc,(ship_initpos2)       ; get the current coords
101+  BB18 0D               dec c                       ; move up one pixels
102+  BB19 ED 43 7F BA      ld (ship_initpos2),bc
103+  BB1D              ship_takeoff1:
104+  BB1D CD 55 BB         call ship_draw_full         ; draw the ship
105+  BB20 CD 3F BB         call ship_draw_screen
106+  BB23 D1               pop de
107+  BB24 1E 01            ld e,1
108+  BB26 C1               pop bc
109+  BB27 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  BB29                  ; done moving up
111+  BB29 C9               ret
112+  BB2A
113+  BB2A              ;
114+  BB2A              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  BB2A              ;
116+  BB2A              ship_change_frame:
117+  BB2A F5               push af
118+  BB2B 3A 81 BA         ld a,(ship_frame)
119+  BB2E FE 00            cp 0
120+  BB30 CA 38 BB         jp z,ship_change_frame0
121+  BB33 3E 00            ld a,0                      ; flip to 0
122+  BB35 C3 3A BB         jp ship_change_frame1
123+  BB38              ship_change_frame0:
124+  BB38 3E 20            ld a,32                      ; flip to 32
125+  BB3A              ship_change_frame1:
126+  BB3A 32 81 BA         ld (ship_frame),a            ; save the frame
127+  BB3D F1               pop af
128+  BB3E C9               ret
129+  BB3F
130+  BB3F              ship_draw_screen:
131+  BB3F 3E 00            ld a,0
132+  BB41 CD A6 A5         call buffer_marklineforupdate
133+  BB44 3E 01            ld a,1
134+  BB46 CD A6 A5         call buffer_marklineforupdate
135+  BB49 3E 02            ld a,2
136+  BB4B CD A6 A5         call buffer_marklineforupdate   ; mark the first three rows for update
137+  BB4E 76               halt
138+  BB4F F3               di
139+  BB50 CD 3D A6         call buffer_buffertoscreen  ; copy buffer to screen
140+  BB53 FB               ei                          ; enable interupts
141+  BB54 C9               ret
142+  BB55
143+  BB55              ship_draw_full:
144+  BB55 21 A6 B3         ld hl,ship_sprite
145+  BB58 ED 4B 7F BA      ld bc,(ship_initpos2)         ; load bc with the start coords
146+  BB5C 22 82 BA         ld (ship_current_sprite),hl  ; put into memory
147+  BB5F ED 43 84 BA      ld (ship_current_coords),bc  ; put into memory
148+  BB63 CD 82 BB         call ship_draw
149+  BB66 08               ex af,af'
150+  BB67 3A 81 BA         ld a,(ship_frame)            ; get the animation frame
151+  BB6A 16 00            ld d,0
152+  BB6C 5F               ld e,a
153+  BB6D 19               add hl,de
154+  BB6E 22 82 BA         ld (ship_current_sprite),hl  ; put into memory
155+  BB71 08               ex af,af'
156+  BB72 ED 4B 7F BA      ld bc,(ship_initpos2)         ; load bc with the start coords
157+  BB76 81 C6 08         add c,8                      ; move one line down
158+  BB79 4F               ld c,a
159+  BB7A ED 43 84 BA      ld (ship_current_coords),bc  ; put into memory
160+  BB7E CD 82 BB         call ship_draw
161+  BB81 C9               ret
162+  BB82
163+  BB82              ;
164+  BB82              ; Draw the ship
165+  BB82              ; Inputs:
166+  BB82              ; None, all in memory
167+  BB82              ;
168+  BB82              ship_draw:
169+  BB82 3E 04            ld a,4                              ; 4 pieces per half
170+  BB84              ship_draw0:
171+  BB84 F5               push af
172+  BB85 2A 82 BA         ld hl,(ship_current_sprite)
173+  BB88 ED 4B 84 BA      ld bc,(ship_current_coords)         ; load bc with the start coords
174+  BB8C CD CF A8         call sprites_drawsprite
175+  BB8F 2A 82 BA         ld hl,(ship_current_sprite)
176+  BB92 ED 4B 84 BA      ld bc,(ship_current_coords)         ; load bc with the start coords
177+  BB96 11 08 00         ld de,8
178+  BB99 19               add hl,de
179+  BB9A 80 C6 08         add b,8
180+  BB9D 47               ld b,a
181+  BB9E 22 82 BA         ld (ship_current_sprite),hl         ; put into memory
182+  BBA1 ED 43 84 BA      ld (ship_current_coords),bc         ; put into memory
183+  BBA5 F1               pop af
184+  BBA6 3D               dec a
185+  BBA7 FE 00            cp 0
186+  BBA9 C2 84 BB         jp nz,ship_draw0
187+  BBAC
188+  BBAC C9               ret
189+  BBAD
# file closed: game/ship.asm
 39   BBAD                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  BBAD              ;
  2+  BBAD              ; tank initial position: vert,horiz
  3+  BBAD              ;
  4+  BBAD              tank_initpos:
  5+  BBAD 10 D0            defb 16,208
  6+  BBAF              tank_initpos2:
  7+  BBAF 00 00            defb 0,0
  8+  BBB1              tank_frame:
  9+  BBB1 00               defb 0
 10+  BBB2              tank_anim:
 11+  BBB2 11               defb 17
 12+  BBB3
 13+  BBB3              ;
 14+  BBB3              ; The damage countdown
 15+  BBB3              ;
 16+  BBB3              tank_currentdamage:
 17+  BBB3 F0               defb 240
 18+  BBB4
 19+  BBB4              ;
 20+  BBB4              ; The damage coordinate
 21+  BBB4              ;
 22+  BBB4              tank_currentdamagecoord:
 23+  BBB4 16 02            defb 22,2
 24+  BBB6
 25+  BBB6              ;
 26+  BBB6              ; Controls when the tank shoots
 27+  BBB6              ;
 28+  BBB6              tank_count:
 29+  BBB6 00               defb 0
 30+  BBB7
 31+  BBB7              ;
 32+  BBB7              ; Holds the block number of the current damage sprite
 33+  BBB7              ;
 34+  BBB7              tank_damageframe:
 35+  BBB7 00               defb 0
 36+  BBB8
 37+  BBB8              ;
 38+  BBB8              ; The current memory location
 39+  BBB8              ;
 40+  BBB8              tank_current_sprite:
 41+  BBB8 00 00            defb 0,0
 42+  BBBA
 43+  BBBA              tank_current_coords:
 44+  BBBA 00 00            defb 0,0
 45+  BBBC
 46+  BBBC              ;
 47+  BBBC              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  BBBC              ;
 49+  BBBC              tank_missile_displayed:
 50+  BBBC 00               defb 0
 51+  BBBD
 52+  BBBD              ;
 53+  BBBD              ; Initialise the tank
 54+  BBBD              ;
 55+  BBBD              tank_init:
 56+  BBBD ED 4B AD BB      ld bc,(tank_initpos)
 57+  BBC1 ED 43 AF BB      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  BBC5 21 B1 BB         ld hl,tank_frame
 59+  BBC8 36 00            ld (hl),0
 60+  BBCA 21 B2 BB         ld hl,tank_anim
 61+  BBCD 36 11            ld (hl),17
 62+  BBCF 21 B7 BB         ld hl,tank_damageframe              ; reset tank
 63+  BBD2 36 00            ld (hl),0
 64+  BBD4 21 B6 BB         ld hl,tank_count
 65+  BBD7 36 00            ld (hl),0
 66+  BBD9 21 B3 BB         ld hl,tank_currentdamage
 67+  BBDC 36 F0            ld (hl),240
 68+  BBDE 21 B4 BB         ld hl,tank_currentdamagecoord
 69+  BBE1 36 16            ld (hl),22
 70+  BBE3 23               inc hl
 71+  BBE4 36 02            ld (hl),2
 72+  BBE6 21 BC BB         ld hl,tank_missile_displayed
 73+  BBE9 36 00            ld (hl),0
 74+  BBEB
 75+  BBEB C9               ret
 76+  BBEC
 77+  BBEC              ;
 78+  BBEC              ;   Draw and move the tank
 79+  BBEC              ;   Start processing at frame 200
 80+  BBEC              ;   Don't move if anim is zero
 81+  BBEC              ;   Decrement frame if moved
 82+  BBEC              ;
 83+  BBEC              tank_process:
 84+  BBEC 3A B2 BB         ld a,(tank_anim)
 85+  BBEF FE 00            cp 0
 86+  BBF1 C2 F8 BB         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  BBF4 CD 09 BC         call tank_fire
 88+  BBF7 C9               ret
 89+  BBF8              tank_process0:
 90+  BBF8 CD C7 B8         call game_getcurrentframe   ; get the current frame number into a
 91+  BBFB FE 4B            cp 75
 92+  BBFD D8               ret c                       ; return if the frame number is below 100
 93+  BBFE CD 1D BD         call tank_move              ; move tank if not
 94+  BC01 3A B2 BB         ld a,(tank_anim)
 95+  BC04 3D               dec a
 96+  BC05 32 B2 BB         ld (tank_anim),a            ; decrease the anim count
 97+  BC08 C9               ret
 98+  BC09
 99+  BC09              ;
100+  BC09              ; Fires the tank
101+  BC09              ;
102+  BC09              tank_fire:
103+  BC09 3A B6 BB         ld a,(tank_count)            ; if not, don't do anything
104+  BC0C 3C               inc a                        ; increment
105+  BC0D FE 19            cp 25                        ; have we reached fifty
106+  BC0F C2 14 BC         jp nz,tank_fire0
107+  BC12 3E 00            ld a,0                       ; reset if reached fifty
108+  BC14              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  BC14 32 B6 BB         ld (tank_count),a            ; store tank count
110+  BC17 FE 00            cp 0
111+  BC19 CA 30 BC         jp z,tank_fire7              ; If this is zero, fire
112+  BC1C 3A BC BB         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  BC1F FE 00            cp 0
114+  BC21 C8               ret z                       ; don't do anything if not
115+  BC22 CD D7 BC         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  BC25 3E 00            ld a,0                       ; reset the flag
117+  BC27 32 BC BB         ld (tank_missile_displayed),a
118+  BC2A 3E 02            ld a,2
119+  BC2C CD A6 A5         call buffer_marklineforupdate
120+  BC2F C9               ret                        ; only shoot if we're on 0
121+  BC30              tank_fire7:
122+  BC30 3A B3 BB         ld a,(tank_currentdamage)    ; get the damage countdown
123+  BC33 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
124+  BC35 C2 6B BC         jp nz,tank_fire1            ; not, so just do a normal frame
125+  BC38 ED 4B B4 BB      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
126+  BC3C 79               ld a,c
127+  BC3D FE 0A            cp 10
128+  BC3F C2 46 BC         jp nz, tank_fire6
129+  BC42 CD 0F BD         call tank_killedbytank      ; we're through, so the player has died. Kill them.
130+  BC45 C9               ret                         ; return if we're through the mountain
131+  BC46              tank_fire6:
132+  BC46 3E 0F            ld a,15
133+  BC48 32 B7 BB         ld (tank_damageframe),a     ; reset the damage frame
134+  BC4B 21 93 B2         ld hl,sprites               ; location of the empty block
135+  BC4E CD 5E A8         call screen_showchar        ; show this character here
136+  BC51 ED 4B B4 BB      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
137+  BC55 05               dec b                       ; look one above
138+  BC56 CD 8B A8         call screen_ischarempty     ; check if it is empty
139+  BC59 ED 4B B4 BB      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
140+  BC5D FE 01            cp 1
141+  BC5F C2 A2 BC         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
142+  BC62 ED 4B B4 BB      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
143+  BC66 0D               dec c
144+  BC67 ED 43 B4 BB      ld (tank_currentdamagecoord),bc ; store the coord
145+  BC6B              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
146+  BC6B ED 4B B4 BB      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  BC6F 3A B3 BB         ld a,(tank_currentdamage)    ; get the damage countdown
148+  BC72 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
149+  BC74 C2 7F BC         jp nz, tank_fire5
150+  BC77 CD BB A8         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
151+  BC7A FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
152+  BC7C C2 C0 BC         jp nz,tank_fire3            ; if it's a slope, handle this differently
153+  BC7F              tank_fire5:
154+  BC7F 3A B7 BB         ld a,(tank_damageframe)
155+  BC82 CD 78 A8         call screen_getblock        ; get the block data into hl
156+  BC85 CD 5E A8         call screen_showchar        ; show this character here
157+  BC88 3A B7 BB         ld a,(tank_damageframe)
158+  BC8B 3C               inc a
159+  BC8C 32 B7 BB         ld (tank_damageframe),a     ; increment the damage block and store
160+  BC8F 3A B3 BB         ld a,(tank_currentdamage)    ; get the damage countdown
161+  BC92 3D               dec a
162+  BC93 3D               dec a
163+  BC94 32 B3 BB         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
164+  BC97 3A BC BB         ld a,(tank_missile_displayed) ; is the missile displaying?
165+  BC9A FE 00            cp 0
166+  BC9C CC D7 BC         call z, tank_missilegraphic
167+  BC9F C3 C9 BC         jp tank_fire4
168+  BCA2              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
169+  BCA2 05               dec b
170+  BCA3 C5               push bc
171+  BCA4 CD A4 A8         call screen_copyblockdown       ; copy the block down
172+  BCA7 ED 4B B4 BB      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
173+  BCAB C1               pop bc                      ; get the coord we just checked back
174+  BCAC 78               ld a,b
175+  BCAD FE 00            cp 0
176+  BCAF CA 6B BC         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
177+  BCB2 C5               push bc
178+  BCB3 05               dec b
179+  BCB4 CD 8B A8         call screen_ischarempty     ; check if it is empty
180+  BCB7 C1               pop bc
181+  BCB8 FE 01            cp 1                        ; if empty
182+  BCBA C2 A2 BC         jp nz, tank_fire2            ; copy another one down
183+  BCBD C3 6B BC         jp tank_fire1               ; otherwise, return to main thread
184+  BCC0              tank_fire3:                      ; dealing with slopes
185+  BCC0 3A B3 BB         ld a,(tank_currentdamage)    ; get the damage countdown
186+  BCC3 06 08            ld b,8
187+  BCC5 90               sub b                        ; special case for slopes
188+  BCC6 32 B3 BB         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
189+  BCC9              tank_fire4:                     ; TIDY UP
190+  BCC9 CD A6 A5         call buffer_marklineforupdate
191+  BCCC 3E 01            ld a,1
192+  BCCE CD A6 A5         call buffer_marklineforupdate
193+  BCD1 3E 02            ld a,2
194+  BCD3 CD A6 A5         call buffer_marklineforupdate
195+  BCD6 C9               ret
196+  BCD7
197+  BCD7              ;
198+  BCD7              ; Displays or hides the missile graphic, and changes the gun
199+  BCD7              ;
200+  BCD7              tank_missilegraphic:
201+  BCD7 3A BC BB         ld a,(tank_missile_displayed)
202+  BCDA FE 00            cp 0
203+  BCDC C2 E4 BC         jp nz,tank_missilegraphic0
204+  BCDF 3E 13            ld a,19
205+  BCE1 C3 E6 BC         jp tank_missilegraphic1
206+  BCE4              tank_missilegraphic0:
207+  BCE4 3E 00            ld a,0
208+  BCE6              tank_missilegraphic1:
209+  BCE6 32 BC BB         ld (tank_missile_displayed),a ; store the flipped graphic
210+  BCE9 ED 4B B4 BB      ld bc,(tank_currentdamagecoord)
211+  BCED 0C               inc c
212+  BCEE 0C               inc c                   ; print the graphic 2 spaces right
213+  BCEF CD 78 A8         call screen_getblock        ; get the block data into hl
214+  BCF2 CD 5E A8         call screen_showchar        ; show this character here
215+  BCF5 06 02            ld b,2
216+  BCF7 0E 18            ld c,24                     ; set gunbarrel coords
217+  BCF9 11 00 00         ld de,0
218+  BCFC 21 06 B4         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
219+  BCFF 3A BC BB         ld a,(tank_missile_displayed)
220+  BD02 FE 00            cp 0
221+  BD04 CA 0A BD         jp z,tank_missilegraphic2
222+  BD07 11 40 00         ld de,64
223+  BD0A              tank_missilegraphic2:
224+  BD0A 19               add hl,de                   ; work out missile graphic
225+  BD0B CD 5E A8         call screen_showchar        ; show this character here
226+  BD0E C9               ret
227+  BD0F
228+  BD0F              ;
229+  BD0F              ; Deal with the player being killed by the tank
230+  BD0F              ;
231+  BD0F              tank_killedbytank:
232+  BD0F ED 4B B4 BB      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
233+  BD13 21 93 B2         ld hl,sprites                   ; empty sprite
234+  BD16 CD 5E A8         call screen_showchar            ; hide the last piece of dirt
235+  BD19 CD 8E B9         call player_tankkillplayer
236+  BD1C C9               ret
237+  BD1D
238+  BD1D              tank_move:
239+  BD1D ED 4B AF BB      ld bc,(tank_initpos2)
240+  BD21 C5               push bc
241+  BD22 3A B2 BB         ld a,(tank_anim)
242+  BD25 FE 11            cp 17                       ; check first time flag
243+  BD27 CA 39 BD         jp z,tank_move1             ; don't draw over previous one if first time
244+  BD2A CD 3E BD         call tank_draw_full         ; delete old one
245+  BD2D ED 4B AF BB      ld bc,(tank_initpos2)       ; get the current coords
246+  BD31 78               ld a,b
247+  BD32 D6 01            sub 1                       ; move back one pixels
248+  BD34 47               ld b,a
249+  BD35 ED 43 AF BB      ld (tank_initpos2),bc
250+  BD39              tank_move1:
251+  BD39 CD 3E BD         call tank_draw_full         ; draw the tank
252+  BD3C C1               pop bc
253+  BD3D C9               ret
254+  BD3E
255+  BD3E              tank_draw_full:
256+  BD3E 21 06 B4         ld hl,tank_sprite
257+  BD41 ED 4B AF BB      ld bc,(tank_initpos2)         ; load bc with the start coords
258+  BD45 22 B8 BB         ld (tank_current_sprite),hl  ; put into memory
259+  BD48 ED 43 BA BB      ld (tank_current_coords),bc  ; put into memory
260+  BD4C CD 75 BD         call tank_draw
261+  BD4F 08               ex af,af'
262+  BD50 3A B1 BB         ld a,(tank_frame)            ; get the animation frame
263+  BD53 16 00            ld d,0
264+  BD55 5F               ld e,a
265+  BD56 19               add hl,de
266+  BD57 22 B8 BB         ld (tank_current_sprite),hl  ; put into memory
267+  BD5A 08               ex af,af'
268+  BD5B ED 4B AF BB      ld bc,(tank_initpos2)         ; load bc with the start coords
269+  BD5F 81 C6 08         add c,8                      ; move one line down
270+  BD62 4F               ld c,a
271+  BD63 ED 43 BA BB      ld (tank_current_coords),bc  ; put into memory
272+  BD67 CD 75 BD         call tank_draw
273+  BD6A 3E 02            ld a,2
274+  BD6C CD A6 A5         call buffer_marklineforupdate
275+  BD6F 3E 03            ld a,3
276+  BD71 CD A6 A5         call buffer_marklineforupdate   ; mark the first two rows for update
277+  BD74 C9               ret
278+  BD75
279+  BD75              ;
280+  BD75              ; Draw the tank
281+  BD75              ; Inputs:
282+  BD75              ; None, all in memory
283+  BD75              ;
284+  BD75              tank_draw:
285+  BD75 3E 04            ld a,4                              ; 4 pieces per half
286+  BD77              tank_draw0:
287+  BD77 F5               push af
288+  BD78 2A B8 BB         ld hl,(tank_current_sprite)
289+  BD7B ED 4B BA BB      ld bc,(tank_current_coords)         ; load bc with the start coords
290+  BD7F CD CF A8         call sprites_drawsprite
291+  BD82 2A B8 BB         ld hl,(tank_current_sprite)
292+  BD85 ED 4B BA BB      ld bc,(tank_current_coords)         ; load bc with the start coords
293+  BD89 11 08 00         ld de,8
294+  BD8C 19               add hl,de
295+  BD8D 80 C6 08         add b,8
296+  BD90 47               ld b,a
297+  BD91 22 B8 BB         ld (tank_current_sprite),hl         ; put into memory
298+  BD94 ED 43 BA BB      ld (tank_current_coords),bc         ; put into memory
299+  BD98 F1               pop af
300+  BD99 3D               dec a
301+  BD9A FE 00            cp 0
302+  BD9C C2 77 BD         jp nz,tank_draw0
303+  BD9F
304+  BD9F C9               ret
305+  BDA0
# file closed: game/tank.asm
 40   BDA0                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  BDA0              ;
  2+  BDA0              ; A structure of falling rocks
  3+  BDA0              ; Assume we'll never have more than 4 falling at any one time
  4+  BDA0              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  BDA0              ;
  6+  BDA0              rocks_falling:
  7+  BDA0 00 00 00 00      defb 0,0,0,0
  8+  BDA4 00 00 00 00      defb 0,0,0,0
  9+  BDA8 00 00 00 00      defb 0,0,0,0
 10+  BDAC 00 00 00 00      defb 0,0,0,0
 11+  BDB0
 12+  BDB0              rocks_tmp:
 13+  BDB0 00               defb 0
 14+  BDB1
 15+  BDB1              rocks_tmp2:
 16+  BDB1 00 00            defb 0,0
 17+  BDB3
 18+  BDB3              ;
 19+  BDB3              ; Coords of the rock that killed us
 20+  BDB3              ;
 21+  BDB3              rocks_killerrock:
 22+  BDB3 00 00            defb 0,0
 23+  BDB5
 24+  BDB5              ;
 25+  BDB5              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 26+  BDB5              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 27+  BDB5              ; If the pixel row is not the rock bottom, stop checking.
 28+  BDB5              ; Inputs:
 29+  BDB5              ; hl- memory location
 30+  BDB5              ;
 31+  BDB5              rocks_checkforfalling:
 32+  BDB5 7E               ld a,(hl)           ; get the pixel row in this memory location
 33+  BDB6 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 34+  BDB8 C2 BE BD         jp nz,rocks_checkforfalling2 ; not a rock, stop
 35+  BDBB CD BF BD         call rocks_addrocktofalling ; mark the rock as falling
 36+  BDBE              rocks_checkforfalling2:
 37+  BDBE C9               ret
 38+  BDBF
 39+  BDBF              ;
 40+  BDBF              ; Adds the rock to the structure that tracks falling rocks
 41+  BDBF              ; Inputs:
 42+  BDBF              ; hl - memory location of falling rock graphic
 43+  BDBF              ; bc - coords of rock, c vert
 44+  BDBF              rocks_addrocktofalling:
 45+  BDBF C5               push bc             ; store the coords
 46+  BDC0 11 A0 BD         ld de,rocks_falling
 47+  BDC3 06 04            ld b,4              ; number of possible falling rocks
 48+  BDC5              rocks_addrocktofalling0:
 49+  BDC5 13               inc de
 50+  BDC6                  ;inc de
 51+  BDC6 13               inc de              ; move three along to get the state
 52+  BDC7 1A               ld a,(de)           ; load the state
 53+  BDC8 FE 00            cp 0                ; check if this is not falling
 54+  BDCA C2 E0 BD         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 55+  BDCD 13               inc de              ; move to frame
 56+  BDCE 3E 10            ld a,16             ; load the number of frames to wobble
 57+  BDD0 12               ld (de),a
 58+  BDD1 1B               dec de              ; move de back to state
 59+  BDD2 3E 02            ld a,2
 60+  BDD4 12               ld (de),a           ; set the state to wobbling
 61+  BDD5 1B               dec de              ; move back coords
 62+  BDD6 C1               pop bc              ; get back coords
 63+  BDD7 78               ld a,b
 64+  BDD8 12               ld (de),a           ; store the vertical
 65+  BDD9 1B               dec de
 66+  BDDA 79               ld a,c
 67+  BDDB 12               ld (de),a           ; store the horizontal
 68+  BDDC C5               push bc
 69+  BDDD C3 E4 BD         jp rocks_addrocktofalling2 ; done
 70+  BDE0              rocks_addrocktofalling1:
 71+  BDE0 13               inc de
 72+  BDE1 13               inc de              ; move memory along to next rock
 73+  BDE2 10 E1            djnz rocks_addrocktofalling0 ; try the next rock
 74+  BDE4              rocks_addrocktofalling2: ; done, return
 75+  BDE4 C1               pop bc              ; to tidy up
 76+  BDE5 C9               ret
 77+  BDE6
 78+  BDE6              ;
 79+  BDE6              ; Processes any falling rocks
 80+  BDE6              ;
 81+  BDE6              rocks_processrocks:
 82+  BDE6 DD 21 A0 BD      ld ix,rocks_falling
 83+  BDEA 06 04            ld b,4              ; the number of rocks to check
 84+  BDEC              rocks_processrocks0:
 85+  BDEC C5               push bc             ; store loop count
 86+  BDED DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 86+  BDF1 46 01
 87+  BDF3 DD 23            inc ix
 88+  BDF5 DD 23            inc ix              ; move to the state
 89+  BDF7 DD 7E 00         ld a,(ix)           ; load the state into a
 90+  BDFA FE 00            cp 0
 91+  BDFC CA 20 BE         jp z,rocks_processrocks3 ; if not falling, check next
 92+  BDFF FE 02            cp 2
 93+  BE01 C2 11 BE         jp nz, rocks_processrocks2
 94+  BE04                  ; we're wobbling
 95+  BE04 DD 23            inc ix              ; get frame number for wobble
 96+  BE06 DD 7E 00         ld a,(ix)           ; get wobble frame into a
 97+  BE09 CD DE BE         call rocks_wobble
 98+  BE0C DD 23            inc ix              ; increment for next
 99+  BE0E C3 24 BE         jp rocks_processrocks1  ; do next rock
100+  BE11              rocks_processrocks2:
101+  BE11                  ; we're falling
102+  BE11 C5               push bc
103+  BE12 CD 3D BE         call rocks_fall
104+  BE15 C1               pop bc
105+  BE16 CD 28 BE         call rocks_storeupdatedlines
106+  BE19 DD 23            inc ix
107+  BE1B DD 23            inc ix              ; inc ix to get to next
108+  BE1D C3 24 BE         jp rocks_processrocks1
109+  BE20              rocks_processrocks3:
110+  BE20 DD 23            inc ix
111+  BE22 DD 23            inc ix
112+  BE24              rocks_processrocks1:
113+  BE24 C1               pop bc              ; get loop count back
114+  BE25 10 C5            djnz rocks_processrocks0
115+  BE27 C9               ret
116+  BE28
117+  BE28              ;
118+  BE28              ; Stores the updated rows associated with the rock
119+  BE28              ; Inputs:
120+  BE28              ; bc - coords
121+  BE28              ;
122+  BE28              rocks_storeupdatedlines:
123+  BE28 79               ld a,c                  ; get the rock block coords of current block
124+  BE29 E6 F8            and 248                 ; find closest multiple of eight
125+  BE2B 0F               rrca
126+  BE2C 0F               rrca
127+  BE2D 0F               rrca                    ; divide by 8
128+  BE2E ED 5B F6 A6      ld de,(screen_offset)          ; load the screen offset, this is in rows
129+  BE32 93               sub e
130+  BE33 F5               push af
131+  BE34 CD A6 A5         call buffer_marklineforupdate  ; store current row in updated lines
132+  BE37 F1               pop af
133+  BE38 3C               inc a
134+  BE39 CD A6 A5         call buffer_marklineforupdate  ; store line beneath
135+  BE3C C9               ret
136+  BE3D
137+  BE3D              ;
138+  BE3D              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
139+  BE3D              ; bc - coord of current rock graphic on screen
140+  BE3D              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
141+  BE3D              ;
142+  BE3D              rocks_fall:
143+  BE3D DD 2B            dec ix
144+  BE3F DD 2B            dec ix              ; decrease ix back to coords
145+  BE41 ED 43 B1 BD      ld (rocks_tmp2),bc  ; store original coords
146+  BE45 3E 03            ld a,3              ; move this number of pixels
147+  BE47              rocks_fall1:
148+  BE47 08               ex af,af'
149+  BE48 DD 4E 00 DD      ld bc,(ix)          ; get current coords
149+  BE4C 46 01
150+  BE4E CD 12 A9         call sprites_scadd  ; get the memory of the coords into de
151+  BE51 14               inc d               ; add 256 to get next row
152+  BE52 1A               ld a,(de)           ; get the contents of the next row
153+  BE53 FE 00            cp 0
154+  BE55 C2 AE BE         jp nz,rocks_fall3    ; move the rock if the row is empty
155+  BE58 0C               inc c               ; increment the vertical
156+  BE59 DD 71 00 DD      ld (ix),bc          ; store the new coords
156+  BE5D 70 01
157+  BE5F 79               ld a,c              ; get the vertical coord into a
158+  BE60 E6 07            and 7               ; divisible by 8?
159+  BE62 FE 00            cp 0
160+  BE64 C2 7F BE         jp nz,rocks_fall4   ; if not, carry on
161+  BE67 CD 21 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
162+  BE6A 62 6B            ld hl,de
163+  BE6C 36 42            ld (hl),66          ; load this square with the yellow colour
164+  BE6E DD 4E 00 DD      ld bc,(ix)
164+  BE72 46 01
165+  BE74 79               ld a,c              ; get vertical
166+  BE75 D6 08            sub 8               ; look up one square
167+  BE77 4F               ld c,a              ; put a back in c
168+  BE78 CD 21 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
169+  BE7B 62 6B            ld hl,de
170+  BE7D 36 46            ld (hl),70          ; load this square with the yellow colour
171+  BE7F              rocks_fall4:
172+  BE7F 08               ex af,af'
173+  BE80 3D               dec a
174+  BE81 FE 00            cp 0
175+  BE83 C2 47 BE         jp nz,rocks_fall1   ; do another pixel if needed
176+  BE86              rocks_fall2:
177+  BE86 3E 09            ld a,9              ; rock graphic
178+  BE88 ED 4B B1 BD      ld bc,(rocks_tmp2)  ; get the original coords
179+  BE8C CD 78 A8         call screen_getblock     ; get the memory into hl
180+  BE8F CD CF A8         call sprites_drawsprite  ; draw the sprite - over the top of the current one
181+  BE92 3E 09            ld a,9
182+  BE94 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
182+  BE98 46 01
183+  BE9A CD 78 A8         call screen_getblock     ; get the memory into hl
184+  BE9D CD CF A8         call sprites_drawsprite  ; draw the sprite - over the top of the current one
185+  BEA0 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
185+  BEA4 46 01
186+  BEA6 CD C3 BE         call rocks_checkforplayer ; check to see if we hit a player
187+  BEA9 DD 23            inc ix
188+  BEAB DD 23            inc ix                  ; get ix back to state
189+  BEAD C9               ret
190+  BEAE              rocks_fall3:
191+  BEAE 3E 00            ld a,0              ; set the state to fell
192+  BEB0 DD 77 02         ld (ix+2),a           ; store the falling state
193+  BEB3 DD 4E 00 DD      ld bc,(ix)          ; get the coords
193+  BEB7 46 01
194+  BEB9 CD 21 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
195+  BEBC 62 6B            ld hl,de
196+  BEBE 36 42            ld (hl),66
197+  BEC0 C3 86 BE         jp rocks_fall2      ; rejoin main loop
198+  BEC3
199+  BEC3              ;
200+  BEC3              ; Checks to see if the rock is hitting a player
201+  BEC3              ; Inputs:
202+  BEC3              ; bc - coords of rock we're checking
203+  BEC3              rocks_checkforplayer:
204+  BEC3 ED 5B D1 B8      ld de,(player)       ; get the player coords
205+  BEC7 7B               ld a,e               ; get the vert coord first
206+  BEC8 91               sub c                ; subtract the rock vertical coord from players
207+  BEC9 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  BECB C0               ret nz               ; if not, hasn't hit
209+  BECC 7A               ld a,d               ; get the player horiz coord
210+  BECD 90               sub b                ; subtract rock coord
211+  BECE C6 07            add 7                ; add max distance
212+  BED0 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  BED2 DA D6 BE         jp c,rocks_checkforplayer0
214+  BED5 C9               ret
215+  BED6              rocks_checkforplayer0:
216+  BED6 ED 43 B3 BD      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  BEDA CD 88 B9         call player_crushplayer ; if so, jump out
218+  BEDD C9               ret
219+  BEDE
220+  BEDE              ;
221+  BEDE              ; Wobbles a rocks
222+  BEDE              ; Inputs:
223+  BEDE              ; bc - coord of current rock graphic on screen
224+  BEDE              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  BEDE              ; a - wobble frame
226+  BEDE              rocks_wobble:
227+  BEDE DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  BEE1 E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  BEE3 1E 09            ld e,9              ; this is the rock frame
230+  BEE5 83               add a,e             ; add the frame toggle
231+  BEE6 C5               push bc
232+  BEE7 CD 78 A8         call screen_getblock     ; get the memory into hl
233+  BEEA CD CF A8         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  BEED
235+  BEED DD 7E 00         ld a,(ix)           ; get the frame toggle again
236+  BEF0 3D               dec a               ; decrease
237+  BEF1 DD 77 00         ld (ix),a           ; store
238+  BEF4
239+  BEF4 E6 01            and 1
240+  BEF6 1E 09            ld e,9              ; this is the rock frame
241+  BEF8 83               add a,e             ; add the frame toggle
242+  BEF9 CD 78 A8         call screen_getblock     ; get the memory into hl
243+  BEFC
244+  BEFC C1               pop bc
245+  BEFD CD CF A8         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
246+  BF00
247+  BF00 DD 7E 00         ld a,(ix)           ; get the wobble count back
248+  BF03 FE 00            cp 0
249+  BF05 C0               ret nz              ; if we're not at zero, return
250+  BF06 DD 2B            dec ix              ; otherwise look to state location
251+  BF08 3E 01            ld a,1              ; set the state to falling
252+  BF0A DD 77 00         ld (ix),a           ; store the falling state
253+  BF0D DD 23            inc ix              ; set ix back to location of wobble count, and we're done
254+  BF0F C9               ret
255+  BF10
# file closed: game/rocks.asm
 41   BF10                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  BF10              ;
  2+  BF10              ; The score of the current player
  3+  BF10              ;
  4+  BF10              scores_current:
  5+  BF10 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  BF14 30 30 30 30
  5+  BF18 FF
  6+  BF19
  7+  BF19              scores_defaultname:
  8+  BF19 2D 2D 2D         defb '---'
  9+  BF1C
 10+  BF1C              ;
 11+  BF1C              ; The current high score table
 12+  BF1C              ;
 13+  BF1C              scores_table:
 14+  BF1C 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  BF20 4D 30 30 30
 14+  BF24 30 30 30 FF
 15+  BF28 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  BF2C 4D 30 30 30
 15+  BF30 30 30 30 FF
 16+  BF34 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  BF38 4D 30 30 30
 16+  BF3C 30 30 30 FF
 17+  BF40
 18+  BF40              ;
 19+  BF40              ; Add thousands to the score
 20+  BF40              ; Inputs:
 21+  BF40              ; b - number to add
 22+  BF40              ;
 23+  BF40              scores_addthousands:
 24+  BF40 21 14 BF         ld hl,scores_current+4
 25+  BF43 CD 6D BF         call scores_update
 26+  BF46 C9               ret
 27+  BF47
 28+  BF47              ;
 29+  BF47              ; Prints the score to screen
 30+  BF47              ;
 31+  BF47              scores_printscore:
 32+  BF47 3A A3 B8         ld a,(game_currentplayer)   ; get current player
 33+  BF4A 21 10 BF         ld hl,scores_current
 34+  BF4D FE 01            cp 1
 35+  BF4F C2 57 BF         jp nz, score_printscore0    ; if not player 1
 36+  BF52 36 04            ld (hl),4       ; set position for player 1
 37+  BF54 C3 59 BF         jp score_printscore1
 38+  BF57              score_printscore0:
 39+  BF57 36 16            ld (hl),22       ; set position for player 2
 40+  BF59              score_printscore1:
 41+  BF59 21 10 BF         ld hl,scores_current
 42+  BF5C CD A6 84         call string_print
 43+  BF5F C9               ret
 44+  BF60
 45+  BF60              ;
 46+  BF60              ; Prints both scores to screen
 47+  BF60              ;
 48+  BF60              scores_printscores:
 49+  BF60 21 70 B9         ld hl,player1_score
 50+  BF63 CD A6 84         call string_print
 51+  BF66 21 79 B9         ld hl,player2_score
 52+  BF69 CD A6 84         call string_print
 53+  BF6C C9               ret
 54+  BF6D
 55+  BF6D              ;
 56+  BF6D              ; Updates the current score.
 57+  BF6D              ; Inputs:
 58+  BF6D              ; hl - memory location of the score column
 59+  BF6D              ; b - number to add
 60+  BF6D              ;
 61+  BF6D              scores_update:
 62+  BF6D 7E               ld a,(hl)           ; current value of digit.
 63+  BF6E 80               add a,b             ; add points to this digit.
 64+  BF6F 77               ld (hl),a           ; place new digit back in string.
 65+  BF70 FE 3A            cp 58               ; more than ASCII value '9'?
 66+  BF72 D8               ret c               ; no - relax.
 67+  BF73 D6 0A            sub 10              ; subtract 10.
 68+  BF75 77               ld (hl),a           ; put new character back in string.
 69+  BF76              scores_update0:
 70+  BF76 2B               dec hl              ; previous character in string.
 71+  BF77 34               inc (hl)            ; up this by one.
 72+  BF78 7E               ld a,(hl)           ; what's the new value?
 73+  BF79 FE 3A            cp 58               ; gone past ASCII nine?
 74+  BF7B D8               ret c               ; no, scoring done.
 75+  BF7C D6 0A            sub 10              ; down by ten.
 76+  BF7E 77               ld (hl),a           ; put it back
 77+  BF7F C3 76 BF         jp scores_update0   ; go round again.
 78+  BF82
 79+  BF82
 80+  BF82              ;
 81+  BF82              ; Displays the high score table at the bottom of the screen
 82+  BF82              ;
 83+  BF82              scores_showtable:
 84+  BF82 21 1C BF         ld hl, scores_table
 85+  BF85 CD A6 84         call string_print
 86+  BF88 21 28 BF         ld hl, scores_table+12
 87+  BF8B CD A6 84         call string_print
 88+  BF8E 21 34 BF         ld hl, scores_table+24
 89+  BF91 CD A6 84         call string_print
 90+  BF94 C9               ret
 91+  BF95
 92+  BF95              ;
 93+  BF95              ; Place to store the current position we're checking
 94+  BF95              ;
 95+  BF95              scores_highscoretmp:
 96+  BF95 00               defb 0
 97+  BF96
 98+  BF96              ;
 99+  BF96              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
100+  BF96              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
101+  BF96              ;
102+  BF96              scores_processhighscores:
103+  BF96 21 95 BF         ld hl,scores_highscoretmp
104+  BF99 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
105+  BF9B 3E 1D            ld a,29
106+  BF9D              scores_processhighscores3:
107+  BF9D 21 1C BF         ld hl,scores_table          ; position of first score column
108+  BFA0 5F               ld e,a
109+  BFA1 16 00            ld d,0
110+  BFA3 19               add hl,de
111+  BFA4 08               ex af,af'                   ; store a for later
112+  BFA5 11 12 BF         ld de,scores_current+2      ; position of current score column
113+  BFA8 06 06            ld b,6                      ; times to loop
114+  BFAA              scores_processhighscores0:
115+  BFAA 7E               ld a,(hl)
116+  BFAB 4F               ld c,a                      ; get first score column
117+  BFAC 1A               ld a,(de)                   ; get first current column
118+  BFAD B9               cp c                        ; compare current with first
119+  BFAE DA BF BF         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
120+  BFB1 23               inc hl
121+  BFB2 13               inc de                      ; move to next column
122+  BFB3 10 F5            djnz scores_processhighscores0 ; loop
123+  BFB5 08               ex af,af'                     ; still here, so must be bigger
124+  BFB6 32 95 BF         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
125+  BFB9 0E 0C            ld c,12
126+  BFBB 91               sub c
127+  BFBC D2 9D BF         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
128+  BFBF              scores_processhighscores4
129+  BFBF CD C3 BF         call scores_updatehighscores
130+  BFC2 C9               ret
131+  BFC3
132+  BFC3              ;
133+  BFC3              ; Update score table
134+  BFC3              ;
135+  BFC3              scores_updatehighscores:
136+  BFC3 3A 95 BF         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
137+  BFC6 FE 00            cp 0
138+  BFC8 C8               ret z                       ; if this is 0, didn't get a high score
139+  BFC9 FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
140+  BFCB CA FE BF         jp z, scores_updatehighscores3
141+  BFCE                                              ; copy old score over one below, if not first
142+  BFCE 21 1C BF         ld hl,scores_table
143+  BFD1 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
144+  BFD4 19               add hl,de                   ; position of first column
145+  BFD5 2B               dec hl
146+  BFD6 2B               dec hl
147+  BFD7 2B               dec hl
148+  BFD8 E5               push hl
149+  BFD9 11 0C 00         ld de,12
150+  BFDC 19               add hl,de                   ; get position of next score
151+  BFDD 54 5D            ld de,hl
152+  BFDF E1               pop hl                      ; get hl back
153+  BFE0 01 09 00         ld bc,9
154+  BFE3 ED B0            ldir
155+  BFE5 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
156+  BFE7 CA FE BF         jp z,scores_updatehighscores3
157+  BFEA 21 1C BF         ld hl,scores_table
158+  BFED 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
159+  BFF0 19               add hl,de                   ; position of first column
160+  BFF1 E5               push hl
161+  BFF2 11 0C 00         ld de,12
162+  BFF5 19               add hl,de                   ; get position of next score
163+  BFF6 54 5D            ld de,hl
164+  BFF8 E1               pop hl                      ; get hl back
165+  BFF9 01 09 00         ld bc,9
166+  BFFC ED B0            ldir
167+  BFFE              scores_updatehighscores3:
168+  BFFE 06 06            ld b,6                      ; now overwrite
169+  C000 21 1C BF         ld hl,scores_table
170+  C003 16 00            ld d,0
171+  C005 5F               ld e,a
172+  C006 19               add hl,de                   ; position of first column
173+  C007 08               ex af,af'
174+  C008 11 12 BF         ld de,scores_current+2      ; position of current score column
175+  C00B              scores_updatehighscores2:
176+  C00B 1A               ld a,(de)
177+  C00C 77               ld (hl),a
178+  C00D 23               inc hl
179+  C00E 13               inc de
180+  C00F 10 FA            djnz scores_updatehighscores2
181+  C011 11 09 00         ld de,9
182+  C014 ED 52            sbc hl,de
183+  C016 54 5D            ld de,hl                    ; get back to start of entry
184+  C018 21 19 BF         ld hl,scores_defaultname    ; still need to overwrite the name
185+  C01B 01 03 00         ld bc,3                      ; 3 chars to copy
186+  C01E ED B0            ldir
187+  C020 C9               ret
# file closed: game/scores.asm
 42   C021                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  C021              diamonds_tmp:
  2+  C021 00               defb 0
  3+  C022
  4+  C022              ;
  5+  C022              ; Holds the number of thousands for the current gem type
  6+  C022              ;
  7+  C022              diamonds_score:
  8+  C022 00               defb 0
  9+  C023
 10+  C023              ;
 11+  C023              ; Changes the attribute of gem and diamond cells based on the frame count
 12+  C023              ; Inputs:
 13+  C023              ; hl - memory location of gem type
 14+  C023              diamonds_twinkle_type:
 15+  C023 CD C7 B8         call game_getcurrentframe       ; get current frame number
 16+  C026 E6 07            and 7                           ; want a number from 0-7
 17+  C028 C6 40            add 64                          ; add to 60 to get attr colour
 18+  C02A              diamonds_twinkle_type0:
 19+  C02A 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 20+  C02E 08               ex af, af'
 21+  C02F 79               ld a,c                          ; load c into a
 22+  C030 FE FF            cp 255                          ; is this the end?
 23+  C032 CA 4F C0         jp z,diamonds_twinkle_type1           ; step out if so
 24+  C035 23               inc hl
 25+  C036 23               inc hl
 26+  C037 7E               ld a,(hl)                       ; check the state, don't process if collected
 27+  C038 FE 01            cp 1
 28+  C03A CA 50 C0         jp z,diamonds_twinkle_type2           ; step out if so
 29+  C03D CD 8C C0         call diamonds_checkforplayer    ; check to see if we've collided with player
 30+  C040 DC 57 C0         call c,diamonds_collect     ; we collided
 31+  C043 23               inc hl
 32+  C044 08               ex af,af'
 33+  C045 5E 23 56 2B      ld de,(hl)                      ; get the memory location into de
 34+  C049 12               ld (de),a                       ; set the value of attr
 35+  C04A 23               inc hl
 36+  C04B 23               inc hl                          ; move to next diamond
 37+  C04C C3 2A C0         jp diamonds_twinkle_type0
 38+  C04F              diamonds_twinkle_type1:
 39+  C04F C9               ret
 40+  C050              diamonds_twinkle_type2:
 41+  C050 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 42+  C051 23               inc hl
 43+  C052 23               inc hl
 44+  C053 08               ex af,af'
 45+  C054 C3 2A C0         jp diamonds_twinkle_type0       ; rejoin main loop
 46+  C057
 47+  C057              ;
 48+  C057              ; Collect the diamond we collided with
 49+  C057              ; Inputs:
 50+  C057              ; hl - memory location of current diamond, currently on state
 51+  C057              ; Output:
 52+  C057              ; a - 70 - for yellow on black
 53+  C057              diamonds_collect:
 54+  C057 36 01            ld (hl),1                       ; collected
 55+  C059 E5               push hl
 56+  C05A 2B               dec hl
 57+  C05B 2B               dec hl
 58+  C05C 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 59+  C060 CD 44 A8         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 60+  C063 ED 5B 21 C0      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 61+  C067 16 00            ld d,0
 62+  C069 21 93 B2         ld hl,sprites
 63+  C06C 19               add hl,de
 64+  C06D CD CF A8         call sprites_drawsprite     ; call the routine to draw the sprite
 65+  C070 E1               pop hl
 66+  C071 08               ex af,af'
 67+  C072 3E 46            ld a,70
 68+  C074 08               ex af,af'                       ; make sure a is in the af we'll use for the attr
 69+  C075 D9               exx
 70+  C076 3A 22 C0         ld a,(diamonds_score)
 71+  C079 47               ld b,a
 72+  C07A CD 40 BF         call scores_addthousands
 73+  C07D 3A 21 C0         ld a,(diamonds_tmp)
 74+  C080 FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 75+  C082 C2 8A C0         jp nz,diamonds_collect0
 76+  C085 21 DE B8         ld hl,player+13
 77+  C088 36 01            ld (hl),1                   ; mark the player as able to complete the level
 78+  C08A              diamonds_collect0:
 79+  C08A D9               exx
 80+  C08B C9               ret
 81+  C08C
 82+  C08C              ;
 83+  C08C              ; Checks to see if the gem is hitting a player
 84+  C08C              ; Inputs:
 85+  C08C              ; bc - coords of diamond we're checking
 86+  C08C              diamonds_checkforplayer:
 87+  C08C 78               ld a,b               ; multiply b by 8
 88+  C08D 07               rlca
 89+  C08E 07               rlca
 90+  C08F 07               rlca
 91+  C090 47               ld b,a
 92+  C091 ED 5B D1 B8      ld de,(player)       ; get the player coords
 93+  C095 7B               ld a,e               ; get the vert coord first
 94+  C096 90               sub b                ; subtract the diamond vertical coord from players
 95+  C097 C6 04            add 4                ; add the max distance
 96+  C099 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
 97+  C09B D0               ret nc               ; if not, hasn't hit
 98+  C09C 79               ld a,c               ; multiply c by 8
 99+  C09D 07               rlca
100+  C09E 07               rlca
101+  C09F 07               rlca
102+  C0A0 4F               ld c,a
103+  C0A1 7A               ld a,d               ; get the player horiz coord
104+  C0A2 91               sub c                ; subtract rock coord
105+  C0A3 C6 04            add 4                ; add max distance
106+  C0A5 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
107+  C0A7 D0               ret nc
108+  C0A8 3E 00            ld a,0
109+  C0AA C9               ret
110+  C0AB
111+  C0AB
112+  C0AB              ;
113+  C0AB              ; Initialise diamonds and gems
114+  C0AB              ;
115+  C0AB              diamonds_twinkle
116+  C0AB 21 22 C0         ld hl,diamonds_score
117+  C0AE 36 02            ld (hl),2         ; store the score we'll add
118+  C0B0 21 21 C0         ld hl,diamonds_tmp
119+  C0B3 36 40            ld (hl),64         ; store the location the diamond sprite
120+  C0B5 21 0E B2         ld hl, level01diamonds
121+  C0B8 CD 23 C0         call diamonds_twinkle_type
122+  C0BB 21 22 C0         ld hl,diamonds_score
123+  C0BE 36 01            ld (hl),1         ; store the score we'll add
124+  C0C0 21 21 C0         ld hl,diamonds_tmp
125+  C0C3 36 70            ld (hl),112         ; store the location the gem sprite
126+  C0C5 21 1E B2         ld hl, level01gems
127+  C0C8 CD 23 C0         call diamonds_twinkle_type
128+  C0CB C9               ret
129+  C0CC
130+  C0CC              ;
131+  C0CC              ; Initialise diamonds and gems
132+  C0CC              ;
133+  C0CC              diamonds_init:
134+  C0CC 21 0E B2         ld hl, level01diamonds
135+  C0CF CD D9 C0         call diamonds_init_type
136+  C0D2 21 1E B2         ld hl, level01gems
137+  C0D5 CD D9 C0         call diamonds_init_type
138+  C0D8 C9               ret
139+  C0D9
140+  C0D9              ;
141+  C0D9              ; Initialise diamonds or gems, get memory addresses
142+  C0D9              ; Inputs:
143+  C0D9              ; hl - memory location
144+  C0D9              diamonds_init_type:
145+  C0D9 4E               ld c,(hl)                      ; get coords into c
146+  C0DA 79               ld a,c                          ; load c into add
147+  C0DB FE FF            cp 255                          ; is this the end?
148+  C0DD CA F4 C0         jp z,diamonds_init_type1             ; step out if so
149+  C0E0 23               inc hl
150+  C0E1 46               ld b,(hl)                       ; get coords into b
151+  C0E2 E5               push hl
152+  C0E3 CD F1 A7         call screen_getcellattradress ; get memory of attr for this diamond into de
153+  C0E6 E1               pop hl
154+  C0E7 23               inc hl                          ; move to state
155+  C0E8 36 00            ld (hl),0
156+  C0EA 23               inc hl                          ; move to memory
157+  C0EB 73 23 72 2B      ld (hl),de                      ; store the memory location
158+  C0EF 23               inc hl                          ; move to next diamond
159+  C0F0 23               inc hl
160+  C0F1 C3 D9 C0         jp diamonds_init_type
161+  C0F4              diamonds_init_type1:
162+  C0F4 C9               ret
# file closed: game/diamonds.asm
 43   C0F5
 44   C0F5              ;===========================================================================
 45   C0F5              ; main routine - the code execution starts here.
 46   C0F5              ; Sets up the new interrupt routine, the memory
 47   C0F5              ; banks and jumps to the start loop.
 48   C0F5              ;===========================================================================
 49   C0F5              main:
 50   C0F5
 51   C0F5                  ; Draw the title screen
 52   C0F5              main_titlescreen:
 53   C0F5 CD 38 A9         call titlescreen_show
 54   C0F8 CD DF B8         call player_init_gamestart
 55   C0FB
 56   C0FB              main_lifestart:
 57   C0FB
 58   C0FB CD FD B8         call player_init_lifestart
 59   C0FE
 60   C0FE CD 9C AA         call lifescreen_draw        ; show the lives remaining screen
 61   C101
 62   C101 CD 00 80         call init_start
 63   C104 CD 11 A7         call screen_draw
 64   C107 CD 6F A6         call buffer_allbuffertoscreen
 65   C10A
 66   C10A CD 9B BA         call ship_land              ; land the ship
 67   C10D CD BD BB         call tank_init
 68   C110 CD CC C0         call diamonds_init
 69   C113
 70   C113              mloop:
 71   C113 76               halt
 72   C114 CD 43 C1         call main_loop_processing
 73   C117
 74   C117                  ;
 75   C117                  ; Check if the player died
 76   C117                  ;
 77   C117 21 DB B8         ld hl,player+10
 78   C11A 7E               ld a,(hl)                   ; check if the player died this frame
 79   C11B FE 01            cp 1
 80   C11D C2 2F C1         jp nz,mloop0
 81   C120 CD 64 B9         call player_died        ; do end of life housekeeping
 82   C123 21 DA B8         ld hl,player+9        ; check lives remaining
 83   C126 7E               ld a,(hl)
 84   C127 FE 00            cp 0
 85   C129 CA 65 C1         jp z,main_gameover   ; leave the loop if we're done
 86   C12C C3 FB C0         jp main_lifestart    ; otherwise, start a new life
 87   C12F              mloop0:
 88   C12F                  ;
 89   C12F                  ; Check if the player completed the level
 90   C12F                  ;
 91   C12F 21 DE B8         ld hl,player+13
 92   C132 7E               ld a,(hl)
 93   C133 FE 01            cp 1
 94   C135 C2 13 C1         jp nz,mloop
 95   C138 CD 65 BA         call player_checkforexit
 96   C13B FE 01            cp 1                        ; look at return, if 1, level has been completed
 97   C13D CA 6B C1         jp z,main_endlevel          ; jump to level transition screen
 98   C140 C3 13 C1         jp mloop                ; start the loop again
 99   C143
100   C143
101   C143              main_loop_processing:
102   C143
103   C143 CD 3D A6         call buffer_buffertoscreen  ; copy buffer to screen
104   C146 CD BD A5         call buffer_clearlist       ; zero the updated lines list
105   C149 CD 94 B9         call player_drawplayer      ; delete player
106   C14C CD 4E B4         call control_keyboard       ; check keyboard
107   C14F CD 94 B9         call player_drawplayer      ; draw player
108   C152 CD EC BB         call tank_process           ; prcoess the tank
109   C155 CD 86 BA         call ship_process           ; proces the ship
110   C158 CD E6 BD         call rocks_processrocks     ; process falling rocks
111   C15B CD AB C0         call diamonds_twinkle       ; make the diamonds twinkle
112   C15E CD 47 BF         call scores_printscore      ; update the score on screen
113   C161 CD B8 B8         call game_incrementframe    ; increment the game frame
114   C164
115   C164 C9               ret
116   C165
117   C165              main_gameover:
118   C165 CD EF AA         call gameover_draw          ; show the game over screen
119   C168 C3 F5 C0         jp main_titlescreen         ; go back to title
120   C16B
121   C16B              main_endlevel:
122   C16B CD 4A B9         call player_recordcurrentscore
123   C16E CD DD AB         call endlevel_draw          ; show the end level screen
124   C171 C3 FB C0         jp main_lifestart           ; start a new life
125   C174
126   C174              ;===========================================================================
127   C174              ; Stack.
128   C174              ;===========================================================================
129   C174
130   C174              ; Stack: this area is reserved for the stack
131   C174              STACK_SIZE: equ 100    ; in words
132   C174
133   C174              ; Reserve stack space
134   C174 00 00            defw 0  ; WPMEM, 2
135   C176              stack_bottom:
136   C176 00 00 00...      defs    STACK_SIZE*2, 0
137   C23E              stack_top:
138   C23E 00 00            defw 0  ; WPMEM, 2
139   C240
140   C240                     SAVESNA "ThePit.sna", main
# file closed: main.asm
