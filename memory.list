# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 80 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 09 A8         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 0A A8         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 3F A6         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD 8A BD         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 20 0A            jr nz,utilities_waitforkey1           ; yes, so no key pressed.
 52+  8051 01 1F 00         ld bc,31                        ; Kempston joystick port.
 53+  8054 ED 78            in a,(c)                        ; read input.
 54+  8056 E6 10            and 16
 55+  8058 CA 4C 80         jp z,utilities_waitforkey0
 56+  805B              utilities_waitforkey1:
 57+  805B C9               ret                 ; key was pressed.
 58+  805C
 59+  805C              ;
 60+  805C              ; Waits number of frames for keypress. If got, returns 1, if not 0
 61+  805C              ; Inputs:
 62+  805C              ; a - number of frames to waits
 63+  805C              ; Ouputs:
 64+  805C              ; e - 0 not pressed, 1 pressed
 65+  805C              utilities_waitforkey_forframes:
 66+  805C 21 08 5C         ld hl,23560         ; LAST K system variable.
 67+  805F 36 00            ld (hl),0           ; put null value there.
 68+  8061 47               ld b,a              ; number of frames to wait
 69+  8062              utilities_waitforkey_forframes0:
 70+  8062 7E               ld a,(hl)           ; new value of LAST K.
 71+  8063 FE 00            cp 0                ; is it still zero?
 72+  8065 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 73+  8067 1E 01            ld e,1              ; set the pressed flag
 74+  8069 C9               ret                 ; key was pressed.
 75+  806A              utilities_waitforkey_forframes1:
 76+  806A C5               push bc
 77+  806B 01 1F 00         ld bc,31                        ; Kempston joystick port.
 78+  806E ED 78            in a,(c)                        ; read input.
 79+  8070 C1               pop bc
 80+  8071 E6 10            and 16
 81+  8073 CA 79 80         jp z,utilities_waitforkey_forframes2
 82+  8076 1E 01            ld e,1              ; set the pressed flag
 83+  8078 C9               ret                 ; key was pressed.
 84+  8079              utilities_waitforkey_forframes2:
 85+  8079 76               halt                ; wait for frame
 86+  807A 76               halt                ; wait for frame
 87+  807B 10 E5            djnz utilities_waitforkey_forframes0 ; loop again
 88+  807D 1E 00            ld e,0              ; nothing pressed in time
 89+  807F C9               ret
 90+  8080
 91+  8080              ;
 92+  8080              ; Clears the screen
 93+  8080              ; Inputs:
 94+  8080              ; a - attribute colour
 95+  8080              utilities_clearscreen:
 96+  8080 76               halt
 97+  8081 21 00 58         ld hl,22528         ; attr
 98+  8084 11 01 58         ld de,22529         ; attr+1
 99+  8087 01 FF 02         ld bc,767
100+  808A 77               ld (hl),a
101+  808B ED B0            ldir
102+  808D
103+  808D 21 00 40         ld hl, 16384        ;pixels
104+  8090 11 01 40         ld de, 16385        ;pixels + 1
105+  8093 01 FF 17         ld bc, 6143         ;pixels area length - 1
106+  8096 36 00            ld (hl), 0          ;set first byte to '0'
107+  8098 ED B0            ldir                ;copy bytes
108+  809A
109+  809A C9               ret
110+  809B
111+  809B              ;
112+  809B              ; Wait for a number of frames
113+  809B              ; Inputs:
114+  809B              ; b - number of frames
115+  809B              utilities_pauseforframes:
116+  809B 76               halt
117+  809C 10 FD            djnz utilities_pauseforframes
118+  809E C9               ret
119+  809F
120+  809F              utilities_readkey:
121+  809F 21 BF 80         LD HL,utilties_keymap              ; Point HL at the keyboard list
122+  80A2 16 08            LD D,8                                  ; This is the number of ports (rows) to check
123+  80A4 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
124+  80A6              utilities_readkey_0:
125+  80A6 46               LD B,(HL)                               ; Get the keyboard port address from table
126+  80A7 23               INC HL                                  ; Increment to list of keys
127+  80A8 ED 78            IN A,(C)                                ; Read the row of keys in
128+  80AA E6 1F            AND $1F                                     ; We are only interested in the first five bits
129+  80AC 1E 05            LD E,5                                  ; This is the number of keys in the row
130+  80AE              utilities_readkey_1:
131+  80AE CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
132+  80B0 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
133+  80B2 23               INC HL                                  ; Go to next table address
134+  80B3 1D               DEC E                                   ; Decrement key loop counter
135+  80B4 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
136+  80B6 15               DEC D                                   ; Decrement row loop counter
137+  80B7 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
138+  80B9 A7               AND A                                   ; Clear A (no key found)
139+  80BA C3 9F 80         jp utilities_readkey
140+  80BD              utilities_readkey_2:
141+  80BD 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
142+  80BE C9               RET
143+  80BF
144+  80BF              utilties_keymap:
145+  80BF FE 23 5A 58      defb $FE,"#","Z","X","C","V"
145+  80C3 43 56
146+  80C5 FD 41 53 44      defb $FD,"A","S","D","F","G"
146+  80C9 46 47
147+  80CB FB 51 57 45      defb $FB,"Q","W","E","R","T"
147+  80CF 52 54
148+  80D1 F7 31 32 33      defb $F7,"1","2","3","4","5"
148+  80D5 34 35
149+  80D7 EF 30 39 38      defb $EF,"0","9","8","7","6"
149+  80DB 37 36
150+  80DD DF 50 4F 49      defb $DF,"P","O","I","U","Y"
150+  80E1 55 59
151+  80E3 BF 23 4C 4B      defb $BF,"#","L","K","J","H"
151+  80E7 4A 48
152+  80E9 7F 20 23 4D      defb $7F," ","#","M","N","B"
152+  80ED 4E 42
153+  80EF
154+  80EF
155+  80EF              ;
156+  80EF              ; Generates a randomish number in the range 0 to e
157+  80EF              ; Inputs:
158+  80EF              ; e - upper value
159+  80EF              ; Outputs:
160+  80EF              ; a - random number
161+  80EF              utilities_randomupper
162+  80EF 3A 5E BD         ld a,(game_framenumber)
163+  80F2 6F               ld l,a
164+  80F3 26 00            ld h,0
165+  80F5 16 00            ld d,0
166+  80F7 42 4B            ld bc,de
167+  80F9              utilities_randomupper0:
168+  80F9 B7               or a
169+  80FA ED 42            sbc hl,bc
170+  80FC F2 F9 80         jp p,utilities_randomupper0
171+  80FF 09               add hl,bc
172+  8100 01 00 00         ld bc,0
173+  8103 09               add hl,bc
174+  8104 7D               ld a,l
175+  8105 C9               ret
# file closed: utilities.asm
 22   8106                  include "strings.asm"
# file opened: strings.asm
  1+  8106              string_score1:
  2+  8106 04 00 53 43      defb 4,0,'SCORE1',255
  2+  810A 4F 52 45 31
  2+  810E FF
  3+  810F              string_scorenumbers1:
  4+  810F 04 01 30 30      defb 4,1,'000000',255
  4+  8113 30 30 30 30
  4+  8117 FF
  5+  8118              string_company:
  6+  8118 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  811C 4E 54 55 52
  6+  8120 49 FF
  7+  8122              string_credits:
  8+  8122 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  8126 41 59 45 52
  8+  812A 20 31 FF
  9+  812D              string_score2:
 10+  812D 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8131 4F 52 45 32
 10+  8135 FF
 11+  8136              string_scorenumbers2:
 12+  8136 16 01 30 30      defb 22,1,'000000',255
 12+  813A 30 30 30 30
 12+  813E FF
 13+  813F              string_titlescreen_copyright:
 14+  813F 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 14+  8143 39 38 32 20
 14+  8147 20 43 45 4E
 14+  814B 54 55 52 49
 14+  814F 20 49 4E 43
 14+  8153 FF
 15+  8154
 16+  8154
 17+  8154              string_alttitlescreen_1:
 18+  8154 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  8158 45 44 49 54
 18+  815C 53 20 31 FF
 19+  8160              string_alttitlescreen_2:
 20+  8160 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  8164 20 20 20 20
 20+  8168 20 20 20 20
 20+  816C 20 54 48 45
 20+  8170 20 4F 42 4A
 20+  8174 45 43 54 FE
 21+  8178 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  817C 20 20 20 20
 21+  8180 20 20 20 20
 21+  8184 4F 46 20 54
 21+  8188 48 49 53 20
 21+  818C 47 41 4D 45
 21+  8190 FE
 22+  8191 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  8195 20 20 20 20
 22+  8199 20 20 20 49
 22+  819D 53 20 54 4F
 22+  81A1 20 44 49 47
 22+  81A5 20 44 4F 57
 22+  81A9 4E FE
 23+  81AB 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  81AF 20 20 20 20
 23+  81B3 20 20 54 4F
 23+  81B7 20 54 48 45
 23+  81BB 20 42 4F 54
 23+  81BF 54 4F 4D 20
 23+  81C3 50 49 54 FE
 24+  81C7 00 06 20 20      defb 0,6,'               AND',254
 24+  81CB 20 20 20 20
 24+  81CF 20 20 20 20
 24+  81D3 20 20 20 20
 24+  81D7 20 41 4E 44
 24+  81DB FE
 25+  81DC 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  81E0 20 20 20 20
 25+  81E4 20 20 43 4F
 25+  81E8 4C 4C 45 43
 25+  81EC 54 20 41 54
 25+  81F0 20 4C 45 41
 25+  81F4 53 54 FE
 26+  81F7 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  81FB 20 20 20 20
 26+  81FF 20 20 20 4F
 26+  8203 4E 45 20 4C
 26+  8207 41 52 47 45
 26+  820B 20 4A 45 57
 26+  820F 45 4C FE
 27+  8212 00 09 20 20      defb 0,9,'              THEN',254
 27+  8216 20 20 20 20
 27+  821A 20 20 20 20
 27+  821E 20 20 20 20
 27+  8222 54 48 45 4E
 27+  8226 FE
 28+  8227 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  822B 20 20 20 20
 28+  822F 20 20 20 52
 28+  8233 45 54 55 52
 28+  8237 4E 20 54 4F
 28+  823B 20 53 48 49
 28+  823F 50 FE
 29+  8241 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  8245 20 20 20 20
 29+  8249 20 20 20 54
 29+  824D 48 52 55 20
 29+  8251 55 50 50 45
 29+  8255 52 20 50 49
 29+  8259 54 FF
 30+  825B              string_alttitlescreen_3:
 31+  825B 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  825F 20 20 53 49
 31+  8263 4E 47 4C 45
 31+  8267 20 42 4F 4E
 31+  826B 55 53 20 20
 31+  826F 35 30 30 30
 31+  8273 20 50 4F 49
 31+  8277 4E 54 53 FE
 32+  827B 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  827F 20 20 20 20
 32+  8283 43 4F 4C 4C
 32+  8287 45 43 54 20
 32+  828B 31 20 4C 41
 32+  828F 52 47 45 20
 32+  8293 4A 45 57 45
 32+  8297 4C FE
 33+  8299 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  829D 20 20 20 20
 33+  82A1 20 41 4E 44
 33+  82A5 20 52 45 54
 33+  82A9 55 52 4E 20
 33+  82AD 54 4F 20 53
 33+  82B1 48 49 50 FE
 34+  82B5 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  82B9 20 20 44 4F
 34+  82BD 55 42 4C 45
 34+  82C1 20 42 4F 4E
 34+  82C5 55 53 20 20
 34+  82C9 31 30 30 30
 34+  82CD 30 20 50 4F
 34+  82D1 49 4E 54 53
 34+  82D5 FE
 35+  82D6 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  82DA 20 20 43 4F
 35+  82DE 4C 4C 45 43
 35+  82E2 54 20 41 4C
 35+  82E6 4C 20 33 20
 35+  82EA 4C 41 52 47
 35+  82EE 45 20 4A 45
 35+  82F2 57 45 4C 53
 35+  82F6 FE
 36+  82F7 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  82FB 20 20 20 20
 36+  82FF 20 4F 52 20
 36+  8303 20 20 41 4C
 36+  8307 4C 20 34 20
 36+  830B 53 4D 41 4C
 36+  830F 4C 20 4A 45
 36+  8313 57 45 4C 53
 36+  8317 FE
 37+  8318 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  831C 20 20 54 52
 37+  8320 49 50 4C 45
 37+  8324 20 42 4F 4E
 37+  8328 55 53 20 20
 37+  832C 31 35 30 30
 37+  8330 30 20 50 4F
 37+  8334 49 4E 54 53
 37+  8338 FE
 38+  8339 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  833D 20 20 20 20
 38+  8341 20 43 4F 4C
 38+  8345 4C 45 43 54
 38+  8349 20 41 4C 4C
 38+  834D 20 37 20 4A
 38+  8351 45 57 45 4C
 38+  8355 53 FF
 39+  8357
 40+  8357              string_lifescreen_player:
 41+  8357 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  835B 4C 41 59 45
 41+  835F 52 20 31 20
 41+  8363 FF
 42+  8364              string_lifescreen_lives:
 43+  8364 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  8368 4D 45 4E 20
 43+  836C 4C 45 46 54
 43+  8370 FF
 44+  8371              string_lifescreen_lastman:
 45+  8371 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  8375 53 54 20 4D
 45+  8379 41 4E FF
 46+  837C
 47+  837C              string_gameoverscreen_gameover:
 48+  837C 0B 06 47 41      defb 11,6,'GAME OVER',255
 48+  8380 4D 45 20 4F
 48+  8384 56 45 52 FF
 49+  8388              string_gameoverscreen_copyright:
 50+  8388 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 50+  838C 39 38 32 20
 50+  8390 43 45 4E 54
 50+  8394 55 52 49 20
 50+  8398 49 4E 43 FF
 51+  839C              string_gameoverscreen_bestscores:
 52+  839C 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  83A0 53 54 20 53
 52+  83A4 43 4F 52 45
 52+  83A8 53 20 54 4F
 52+  83AC 44 41 59 FF
 53+  83B0              string_gameover_credits:
 54+  83B0 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  83B4 45 44 49 54
 54+  83B8 53 20 30 FF
 55+  83BC
 56+  83BC              string_highscore_congratulations:
 57+  83BC 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 57+  83C0 4E 47 52 41
 57+  83C4 54 55 4C 41
 57+  83C8 54 49 4F 4E
 57+  83CC 53 FF
 58+  83CE              string_highscore_player1:
 59+  83CE 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 59+  83D2 41 59 45 52
 59+  83D6 20 31 FF
 60+  83D9              string_highscore_player2:
 61+  83D9 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 61+  83DD 41 59 45 52
 61+  83E1 20 32 FF
 62+  83E4              string_highscore_youhaveearned:
 63+  83E4 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 63+  83E8 55 20 48 41
 63+  83EC 56 45 20 45
 63+  83F0 41 52 4E 45
 63+  83F4 44 FF
 64+  83F6              string_highscore_place1:
 65+  83F6 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 65+  83FA 45 20 47 52
 65+  83FE 45 41 54 45
 65+  8402 53 54 20 53
 65+  8406 43 4F 52 45
 65+  840A FF
 66+  840B              string_highscore_place2:
 67+  840B 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 67+  840F 45 20 32 4E
 67+  8413 44 20 42 45
 67+  8417 53 54 20 53
 67+  841B 43 4F 52 45
 67+  841F FF
 68+  8420              string_highscore_place3:
 69+  8420 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 69+  8424 45 20 33 52
 69+  8428 44 20 42 45
 69+  842C 53 54 20 53
 69+  8430 43 4F 52 45
 69+  8434 FF
 70+  8435              string_highscore_pleaseenter
 71+  8435 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 71+  8439 43 4F 52 44
 71+  843D 20 59 4F 55
 71+  8441 52 20 49 4E
 71+  8445 49 54 49 41
 71+  8449 4C 53 20 42
 71+  844D 45 4C 4F 57
 71+  8451 FF
 72+  8452
 73+  8452              string_endlevel_youhaveearned:
 74+  8452 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 74+  8456 55 20 48 41
 74+  845A 56 45 20 45
 74+  845E 41 52 4E 45
 74+  8462 44 FF
 75+  8464              string_endlevel_bonus1:
 76+  8464 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 76+  8468 4E 47 4C 45
 76+  846C 20 42 4F 4E
 76+  8470 55 53 FF
 77+  8473              string_endlevel_bonus2:
 78+  8473 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 78+  8477 55 42 4C 45
 78+  847B 20 42 4F 4E
 78+  847F 55 53 FF
 79+  8482              string_endlevel_bonus3:
 80+  8482 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 80+  8486 49 50 4C 45
 80+  848A 20 42 4F 4E
 80+  848E 55 53 FF
 81+  8491              string_endlevel_points1:
 82+  8491 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 82+  8495 30 30 20 50
 82+  8499 4F 49 4E 54
 82+  849D 53 FF
 83+  849F              string_endlevel_points2:
 84+  849F 09 0F 31 30      defb 9,15,'10000 POINTS',255
 84+  84A3 30 30 30 20
 84+  84A7 50 4F 49 4E
 84+  84AB 54 53 FF
 85+  84AE              string_endlevel_points3:
 86+  84AE 09 0F 31 35      defb 9,15,'15000 POINTS',255
 86+  84B2 30 30 30 20
 86+  84B6 50 4F 49 4E
 86+  84BA 54 53 FF
 87+  84BD              string_endlevel_anothergo:
 88+  84BD 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 88+  84C1 56 45 20 41
 88+  84C5 4E 4F 54 48
 88+  84C9 45 52 20 47
 88+  84CD 4F FF
 89+  84CF
 90+  84CF              string_zonk:
 91+  84CF 00 00 5A 4F      defb 0,0,'ZONK!!',255
 91+  84D3 4E 4B 21 21
 91+  84D7 FF
 92+  84D8
 93+  84D8
 94+  84D8              string_options_title:
 95+  84D8 0D 03 54 48      defb 13,3,'THE PIT',255
 95+  84DC 45 20 50 49
 95+  84E0 54 FF
 96+  84E2              string_options_1player:
 97+  84E2 0A 06 31 2E      defb 10,6,'1. ONE PLAYER',255
 97+  84E6 20 4F 4E 45
 97+  84EA 20 50 4C 41
 97+  84EE 59 45 52 FF
 98+  84F2              string_options_2player:
 99+  84F2 0A 07 32 2E      defb 10,7,'2. TWO PLAYER',255
 99+  84F6 20 54 57 4F
 99+  84FA 20 50 4C 41
 99+  84FE 59 45 52 FF
100+  8502              string_options_keyboard:
101+  8502 0A 08 33 2E      defb 10,8,'3. KEYBOARD',255
101+  8506 20 4B 45 59
101+  850A 42 4F 41 52
101+  850E 44 FF
102+  8510              string_options_joystick:
103+  8510 0A 09 34 2E      defb 10,9,'4. KEMPSTON',255
103+  8514 20 4B 45 4D
103+  8518 50 53 54 4F
103+  851C 4E FF
104+  851E              string_options_start:
105+  851E 0A 0A 35 2E      defb 10,10,'5. START',255
105+  8522 20 53 54 41
105+  8526 52 54 FF
106+  8529              string_options_vanity:
107+  8529 08 16 53 70      defb 8,22,'Spectrum Conversion',254
107+  852D 65 63 74 72
107+  8531 75 6D 20 43
107+  8535 6F 6E 76 65
107+  8539 72 73 69 6F
107+  853D 6E FE
108+  853F 07 17 62 79      defb 7,23,'by Dave Tansley, 2020',255
108+  8543 20 44 61 76
108+  8547 65 20 54 61
108+  854B 6E 73 6C 65
108+  854F 79 2C 20 32
108+  8553 30 32 30 FF
109+  8557
110+  8557              ;
111+  8557              ; Prints specified string
112+  8557              ; Inputs:
113+  8557              ; de: pointer to string
114+  8557              ; bc: length of string
115+  8557              ;
116+  8557              ; Print String Data
117+  8557              ; First two bytes of string contain X and Y char position, then the string
118+  8557              ; Individual strings are terminated with 0xFE
119+  8557              ; End of data is terminated with 0xFF
120+  8557              ; HL: Address of string
121+  8557              ;
122+  8557 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
123+  8558 23                                   INC HL                          ; Increase HL to the next memory location
124+  8559 56                                   LD D,(HL)                       ; Fetch the Y coordinate
125+  855A 23                                   INC HL                          ; Increase HL to the next memory location
126+  855B CD 6E 85                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
127+  855E 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
128+  855F 23                                   INC HL                          ; Increase HL to the next character
129+  8560 FE FE                                CP 0xFE                         ; Compare with 0xFE
130+  8562 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
131+  8564 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
132+  8565 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
133+  8566 CD 7E 85                             CALL Print_Char                 ; Print the character
134+  8569 E1                                   POP HL                          ; Retrieve HL back off the stack
135+  856A 1C                                   INC E                           ; Go to the next screen address
136+  856B 18 F1                                JR string_print_0               ; Loop back to print next character
137+  856D C9                                   RET
138+  856E
139+  856E              ; Get screen address
140+  856E              ; D = Y character position
141+  856E              ; E = X character position
142+  856E              ; Returns address in DE
143+  856E              ;
144+  856E 7A           string_getcharaddress:       LD A,D
145+  856F E6 07                                AND %00000111
146+  8571 1F                                   RRA
147+  8572 1F                                   RRA
148+  8573 1F                                   RRA
149+  8574 1F                                   RRA
150+  8575 B3                                   OR E
151+  8576 5F                                   LD E,A
152+  8577 7A                                   LD A,D
153+  8578 E6 18                                AND %00011000
154+  857A F6 40                                OR %01000000
155+  857C 57                                   LD D,A
156+  857D C9                                   RET                             ; Returns screen address in DE
157+  857E
158+  857E              ; Print a single character out
159+  857E              ; A:  Character to print
160+  857E              ; DE: Screen address to print character at
161+  857E              ;
162+  857E 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
163+  8581 06 00                                LD B,0                          ; Set BC to A
164+  8583 4F                                   LD C,A
165+  8584 E6 FF                                AND 0xFF                        ; Clear the carry bit
166+  8586 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
167+  8588 CB 10                                RL B
168+  858A CB 11                                RL C
169+  858C CB 10                                RL B
170+  858E CB 11                                RL C
171+  8590 CB 10                                RL B
172+  8592 09                                   ADD HL,BC                       ; Get the character address in HL
173+  8593 0E 08                                LD C,8                          ; Loop counter
174+  8595 D5                                   PUSH DE
175+  8596 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
176+  8597 12                                   LD (DE),A                       ; Stick A onto the screen
177+  8598 14                                   INC D                           ; Goto next line on screen
178+  8599 2C                                   INC L                           ; Goto next byte of character
179+  859A 0D                                   DEC C                           ; Decrease the loop counter
180+  859B 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
181+  859D D1                                   POP DE
182+  859E C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   859F                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  859F              buffer_buffer:
  2+  859F 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A29F
  4+  A29F              buffer_attr_buffer:
  5+  A29F 00 00 00...      defs 928                    ; attrs buffer area
  6+  A63F
  7+  A63F              buffer_tmp:
  8+  A63F 00 00            defb 0,0                    ; temp area
  9+  A641
 10+  A641              ;
 11+  A641              ; This list stores lines to be updated by the buffer.
 12+  A641              ; This is done by half line. Lines are encded with.
 13+  A641              ; 00hlllll
 14+  A641              ; Where h is the half of the screen (0 or 1), lllll is the line number
 15+  A641              buffer_updatedlines:
 16+  A641 FF FF FF...      defs 21,255
 17+  A656
 18+  A656              buffer_updateall:
 19+  A656 00               defb 0
 20+  A657
 21+  A657              ;
 22+  A657              ; Stores a line number in the update list
 23+  A657              ; Inputs:
 24+  A657              ; a - row number
 25+  A657              buffer_marklineforupdate:
 26+  A657 FE 15            cp 21
 27+  A659 D0               ret nc                          ; dont store lines that we shouldn't draw
 28+  A65A 5F               ld e,a                          ; store in e
 29+  A65B ED 4B 44 AB      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 30+  A65F 79               ld a,c                          ; get the horiz coord
 31+  A660 FE 0F            cp 15
 32+  A662 CA 79 A6         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 33+  A665 FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 34+  A667 CA 79 A6         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 35+  A66A DA 75 A6         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 36+  A66D 78               ld a,b                          ; get the vertical
 37+  A66E 3E 20            ld a,32                         ; set the 6th bit by adding 32
 38+  A670 83               add a,e
 39+  A671 5F               ld e,a                          ; store this value
 40+  A672 C3 80 A6         jp buffer_marklineforupdate2
 41+  A675              buffer_marklineforupdate4:
 42+  A675 78               ld a,b
 43+  A676 C3 80 A6         jp buffer_marklineforupdate2    ; just get the vertical
 44+  A679              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 45+  A679 CD 84 A6         call buffer_storelineforupdate  ; call store update for e
 46+  A67C 3E 20            ld a,32
 47+  A67E 83               add a,e
 48+  A67F 5F               ld e,a
 49+  A680              buffer_marklineforupdate2:
 50+  A680 CD 84 A6         call buffer_storelineforupdate  ; call store update for e
 51+  A683 C9               ret
 52+  A684
 53+  A684
 54+  A684              ;
 55+  A684              ; Stores the calculated line and half if needed
 56+  A684              ; Inputs:
 57+  A684              ; e - half/row
 58+  A684              ;
 59+  A684              buffer_storelineforupdate:
 60+  A684 06 15            ld b,21
 61+  A686 21 41 A6         ld hl,buffer_updatedlines
 62+  A689              buffer_storelineforupdate0:
 63+  A689 7E               ld a,(hl)                       ; get the line stored in updated lines
 64+  A68A BB               cp e                            ; is this the same as the row number passed in?
 65+  A68B C8               ret z                           ; if so, don't need to do anything
 66+  A68C FE FF            cp 255                          ; is this 255, ie the end of the buffer
 67+  A68E C2 93 A6         jp nz,buffer_storelineforupdate1 ; if not, move to next
 68+  A691 73               ld (hl),e
 69+  A692 C9               ret
 70+  A693              buffer_storelineforupdate1:
 71+  A693 23               inc hl
 72+  A694 10 F3            djnz buffer_storelineforupdate0
 73+  A696 C9               ret
 74+  A697
 75+  A697              ;
 76+  A697              ; Zeroes the updated lines list
 77+  A697              ;
 78+  A697              buffer_clearlist:
 79+  A697 06 15            ld b,21
 80+  A699 21 41 A6         ld hl,buffer_updatedlines
 81+  A69C              buffer_clearlist0:
 82+  A69C 36 FF            ld (hl),255
 83+  A69E 23               inc hl
 84+  A69F 10 FB            djnz buffer_clearlist0
 85+  A6A1 C9               ret
 86+  A6A2
 87+  A6A2              ;
 88+  A6A2              ; Which half are we displaying? 0 left 1 right
 89+  A6A2              ;
 90+  A6A2              buffer_bufferhalf:
 91+  A6A2 00               defb 0
 92+  A6A3
 93+  A6A3              ;
 94+  A6A3              ; Copies the buffer to the screen. Use stack.
 95+  A6A3              ; Inputs:
 96+  A6A3              ; hl - half/line number to display - 0 is first half, 0 is first line
 97+  A6A3              ;
 98+  A6A3              buffer_bufferlinetoscreen:
 99+  A6A3 7C               ld a,h
100+  A6A4 32 A2 A6         ld (buffer_bufferhalf),a        ; store the half
101+  A6A7 7D               ld a,l
102+  A6A8 4F               ld c,a                          ; store a
103+  A6A9 ED 5B 09 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
104+  A6AD 83               add a,e                       ; add the row number
105+  A6AE 11 00 01         ld de,256
106+  A6B1 CD 3A 80         call utilities_multiply
107+  A6B4 54 5D            ld de,hl
108+  A6B6 21 9F 85         ld hl,buffer_buffer
109+  A6B9 19               add hl,de                   ; add the offset
110+  A6BA 79               ld a,c                      ; get original row back
111+  A6BB ED 73 2E A7      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
112+  A6BF D9               exx
113+  A6C0 0E 00            ld c,0                      ; zero horizontal
114+  A6C2 47               ld b,a                      ; load the row number into vertical coord
115+  A6C3 04               inc b
116+  A6C4 04               inc b                       ; move forward 2 to allow for scores
117+  A6C5 CD F3 A8         call screen_getcelladdress  ; get the memory into de
118+  A6C8 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
119+  A6CB 19               add hl,de
120+  A6CC 3A A2 A6         ld a,(buffer_bufferhalf)    ; get the half
121+  A6CF FE 01            cp 1
122+  A6D1 CA FE A6         jp z,buffer_bufferlinetoscreen4
123+  A6D4              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
124+  A6D4 D9               exx                         ; hl is now buffer
125+  A6D5 23               inc hl
126+  A6D6 23               inc hl                      ; move hl forward 2 to skip first two blocks
127+  A6D7 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
128+  A6D8 F1               pop af
129+  A6D9 C1               pop bc
130+  A6DA D1               pop de
131+  A6DB DD E1            pop ix
132+  A6DD D9               exx                         ; hl is now screen
133+  A6DE 08               ex af,af'
134+  A6DF F1               pop af
135+  A6E0 C1               pop bc
136+  A6E1 D1               pop de
137+  A6E2 F9               ld sp,hl                    ; sp pointing at screen
138+  A6E3 D5               push de
139+  A6E4 C5               push bc
140+  A6E5 F5               push af
141+  A6E6 08               ex af,af'
142+  A6E7 D9               exx                         ; hl is now buffer
143+  A6E8 DD E5            push ix
144+  A6EA D5               push de
145+  A6EB C5               push bc
146+  A6EC F5               push af
147+  A6ED 11 1E 00         ld de,30                    ; add thirty to get to next line
148+  A6F0 19               add hl,de
149+  A6F1 F9               ld sp,hl                    ; sp pointing at buffer
150+  A6F2 D9               exx                         ; hl is now screen
151+  A6F3 08               ex af,af'
152+  A6F4 24               inc h
153+  A6F5 7C               ld a,h
154+  A6F6 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
155+  A6F8 C2 D4 A6         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
156+  A6FB              buffer_bufferlinetoscreen1:
157+  A6FB C3 2D A7         jp buffer_bufferlinetoscreen3
158+  A6FE              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
159+  A6FE D9               exx                         ; hl is buffer
160+  A6FF 11 10 00         ld de,16
161+  A702 19               add hl,de                   ; move halfway across
162+  A703 D9               exx                         ; hl is screen
163+  A704 11 0E 00         ld de,14
164+  A707 19               add hl,de
165+  A708              buffer_bufferlinetoscreen2:
166+  A708 D9               exx                         ; hl is now buffer
167+  A709 F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
168+  A70A F1               pop af
169+  A70B C1               pop bc
170+  A70C D1               pop de
171+  A70D DD E1            pop ix
172+  A70F D9               exx                         ; hl is now screen
173+  A710 08               ex af,af'
174+  A711 F1               pop af
175+  A712 C1               pop bc
176+  A713 D1               pop de
177+  A714 F9               ld sp,hl                    ; sp pointing at screen
178+  A715 D5               push de
179+  A716 C5               push bc
180+  A717 F5               push af
181+  A718 08               ex af,af'
182+  A719 D9               exx                         ; hl is now buffer
183+  A71A DD E5            push ix
184+  A71C D5               push de
185+  A71D C5               push bc
186+  A71E F5               push af
187+  A71F 11 20 00         ld de,32                    ; add thirty two to get to next line
188+  A722 19               add hl,de
189+  A723 F9               ld sp,hl                    ; sp pointing at buffer
190+  A724 D9               exx                         ; hl is now screen
191+  A725 08               ex af,af'
192+  A726 24               inc h
193+  A727 7C               ld a,h
194+  A728 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
195+  A72A C2 08 A7         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
196+  A72D              buffer_bufferlinetoscreen3:
197+  A72D 31 00 00         ld sp,0
198+  A730 D9               exx
199+  A731 C9               ret
200+  A732
201+  A732              ;
202+  A732              ; Copies the buffer to the screen for updated lines. Use stack.
203+  A732              ; Inputs: none
204+  A732              ;
205+  A732              buffer_buffertoscreen:
206+  A732 3A 56 A6         ld a,(buffer_updateall)      ; get the all update flag
207+  A735 FE 00            cp 0
208+  A737 CA 43 A7         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
209+  A73A CD 73 A7         call buffer_allbuffertoscreen ; otherwise, draw whole screen
210+  A73D 21 56 A6         ld hl,buffer_updateall
211+  A740 36 00            ld (hl),0                    ; reset flag
212+  A742 C9               ret
213+  A743              buffer_buffertoscreen2:
214+  A743 06 15            ld b,21
215+  A745 FD 21 41 A6      ld iy,buffer_updatedlines    ; the location of the updated lines
216+  A749              buffer_buffertoscreen0:
217+  A749 FD 7E 00         ld a,(iy)
218+  A74C FE FF            cp 255
219+  A74E CA 72 A7         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
220+  A751 6F               ld l,a
221+  A752 26 00            ld h,0
222+  A754 E6 20            and 32                      ; and with 32 to see if 6th bit is set
223+  A756 FE 20            cp 32                       ; if so, second half of screen
224+  A758 C2 63 A7         jp nz,buffer_buffertoscreen3
225+  A75B 26 01            ld h,1                      ; store half in h
226+  A75D FD 7E 00         ld a,(iy)
227+  A760 D6 20            sub 32                      ; remove 32
228+  A762 6F               ld l,a                      ; stor in line number
229+  A763              buffer_buffertoscreen3:
230+  A763 C5               push bc
231+  A764 FD E5            push iy
232+  A766 F3               di
233+  A767 CD A3 A6         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
234+  A76A FB               ei
235+  A76B FD E1            pop iy
236+  A76D C1               pop bc
237+  A76E FD 23            inc iy
238+  A770 10 D7            djnz buffer_buffertoscreen0
239+  A772              buffer_buffertoscreen1:
240+  A772                  ;call buffer_buffertoattrsfast
241+  A772 C9               ret
242+  A773
243+  A773              ;
244+  A773              ; Copies the buffer to the screen. Use stack.
245+  A773              ; Inputs: none
246+  A773              ;
247+  A773              buffer_allbuffertoscreen:
248+  A773 06 15            ld b,21
249+  A775 3E 00            ld a,0
250+  A777              buffer_allbuffertoscreen0:
251+  A777 C5               push bc
252+  A778 F5               push af
253+  A779 F3               di
254+  A77A 26 00            ld h,0
255+  A77C 6F               ld l,a
256+  A77D CD A3 A6         call buffer_bufferlinetoscreen
257+  A780 FB               ei
258+  A781 F1               pop af
259+  A782 F5               push af
260+  A783 F3               di
261+  A784 26 01            ld h,1
262+  A786 6F               ld l,a
263+  A787 CD A3 A6         call buffer_bufferlinetoscreen
264+  A78A FB               ei
265+  A78B F1               pop af
266+  A78C C1               pop bc
267+  A78D 3C               inc a
268+  A78E 10 E7            djnz buffer_allbuffertoscreen0
269+  A790 F3               di
270+  A791 CD 96 A7         call buffer_buffertoattrsfast
271+  A794 FB               ei
272+  A795 C9               ret
273+  A796
274+  A796              ;
275+  A796              ; Copies the attrs buffer to screen with the stack
276+  A796              ;
277+  A796              buffer_buffertoattrsfast:
278+  A796 ED 73 05 A8      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
279+  A79A 3A 09 A8         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
280+  A79D 11 20 00         ld de,32
281+  A7A0 CD 3A 80         call utilities_multiply
282+  A7A3 54 5D            ld de,hl
283+  A7A5 21 9F A2         ld hl,buffer_attr_buffer
284+  A7A8 19               add hl,de                       ; add the offset, start of attr buffer now in hl
285+  A7A9 D9               exx
286+  A7AA 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
287+  A7AD FD 21 3F A6      ld iy,buffer_tmp
288+  A7B1 FD 36 00 15      ld (iy),21              ; number of times to loop
289+  A7B5              buffer_buffertoattrsfast0:
290+  A7B5 D9               exx                         ; hl is now buffer
291+  A7B6 23               inc hl
292+  A7B7 23               inc hl                      ; move hl forward 2 to skip first two blocks
293+  A7B8 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
294+  A7B9 F1               pop af
295+  A7BA C1               pop bc
296+  A7BB D1               pop de
297+  A7BC DD E1            pop ix
298+  A7BE D9               exx                         ; hl is now screen
299+  A7BF 08               ex af,af'
300+  A7C0 F1               pop af
301+  A7C1 C1               pop bc
302+  A7C2 D1               pop de
303+  A7C3 F9               ld sp,hl                    ; sp pointing at screen
304+  A7C4 D5               push de
305+  A7C5 C5               push bc
306+  A7C6 F5               push af
307+  A7C7 08               ex af,af'
308+  A7C8 D9               exx                         ; hl is now buffer
309+  A7C9 DD E5            push ix
310+  A7CB D5               push de
311+  A7CC C5               push bc
312+  A7CD F5               push af
313+  A7CE 1E 0E            ld e,14                    ; do another fourteen for right hand side
314+  A7D0 16 00            ld d,0
315+  A7D2 19               add hl,de
316+  A7D3 F9               ld sp,hl                    ; sp pointing at buffer
317+  A7D4 F1               pop af
318+  A7D5 C1               pop bc
319+  A7D6 D1               pop de
320+  A7D7 DD E1            pop ix
321+  A7D9 D9               exx                         ; hl is now screen
322+  A7DA 08               ex af,af'
323+  A7DB 1E 0E            ld e,14
324+  A7DD 16 00            ld d,0
325+  A7DF 19               add hl,de
326+  A7E0 F1               pop af
327+  A7E1 C1               pop bc
328+  A7E2 D1               pop de
329+  A7E3 F9               ld sp,hl                    ; sp pointing at screen
330+  A7E4 D5               push de
331+  A7E5 C5               push bc
332+  A7E6 F5               push af
333+  A7E7 08               ex af,af'
334+  A7E8 D9               exx                         ; hl is now buffer
335+  A7E9 DD E5            push ix
336+  A7EB D5               push de
337+  A7EC C5               push bc
338+  A7ED F5               push af
339+  A7EE 1E 10            ld e,16
340+  A7F0 16 00            ld d,0
341+  A7F2 19               add hl,de
342+  A7F3 D9               exx                         ; hl is now screen
343+  A7F4 11 12 00         ld de,18
344+  A7F7 19               add hl,de
345+  A7F8 FD 7E 00         ld a,(iy)
346+  A7FB 3D               dec a
347+  A7FC FE 00            cp 0
348+  A7FE FD 77 00         ld (iy),a
349+  A801 C2 B5 A7         jp nz,buffer_buffertoattrsfast0 ; do another row
350+  A804              buffer_buffertoattrsfast1:
351+  A804 31 00 00         ld sp,0
352+  A807 D9               exx
353+  A808 C9               ret
# file closed: screen/buffer.asm
 24   A809                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A809              screen_offset:
  2+  A809 00               defb 0                      ; offset from top of screen in lines
  3+  A80A
  4+  A80A              screen_tmp:
  5+  A80A 00 00            defb 0,0                      ; temporary memory
  6+  A80C
  7+  A80C              screen_setscorecolours:
  8+  A80C 21 57 B5         ld hl,score_colours
  9+  A80F 11 00 58         ld de,22528                     ; attrs here
 10+  A812 01 40 00         ld bc,64
 11+  A815 ED B0            ldir
 12+  A817 C9               ret
 13+  A818
 14+  A818              screen_sethighscorecolours:
 15+  A818 21 97 B5         ld hl,high_score_colours
 16+  A81B 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A81E 01 20 00         ld bc,32
 18+  A821 ED B0            ldir
 19+  A823 C9               ret
 20+  A824
 21+  A824              ; Draw the screen
 22+  A824              ; Inputs:
 23+  A824              ; none
 24+  A824              ; Notes:
 25+  A824              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A824              screen_draw:
 27+  A824                  ;call clear_screen
 28+  A824 0E 00            ld c,0                      ; horiz
 29+  A826 06 00            ld b,0                      ; vert, 0 at top
 30+  A828 DD 21 19 B0      ld ix,level01               ; point ix at level data
 31+  A82C FD 21 9F A2      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A830              screen_draw0:
 33+  A830 DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A833 C5               push bc                     ; store bc, contains loop count
 35+  A834 CD E1 A9         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A837 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A838 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A83B DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A83E CD A8 A9         call screen_getblock        ; get the block data into hl
 40+  A841 CD 85 A9         call screen_showchar        ; show this character here
 41+  A844 C1               pop bc                      ; get the loop counter back
 42+  A845 DD 23            inc ix                      ; increment level location
 43+  A847 FD 23            inc iy                      ; increment attr location
 44+  A849 0C               inc c                       ; increment horiz
 45+  A84A 79               ld a,c
 46+  A84B FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A84D C2 30 A8         jp nz,screen_draw0          ; if not, loop
 48+  A850 0E 00            ld c,0                      ; if so, reset horiz
 49+  A852 04               inc b                       ; increment vertical
 50+  A853 78               ld a,b
 51+  A854 FE 1D            cp 29                       ; check if at bottom
 52+  A856 C2 30 A8         jp nz,screen_draw0          ; if not, loop
 53+  A859 21 0A A8         ld hl, screen_tmp
 54+  A85C 36 09            ld (hl),9                   ; load the block number into memory
 55+  A85E DD 21 B9 B3      ld ix,level01rocks          ; rock memory
 56+  A862 CD C3 A8         call screen_initobjects     ; draw rocks
 57+  A865 21 0A A8         ld hl, screen_tmp
 58+  A868 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A86A DD 21 B9 B4      ld ix,level01missiles       ; missile memory
 60+  A86E CD C3 A8         call screen_initobjects     ; draw missiles
 61+  A871 21 0A A8         ld hl, screen_tmp
 62+  A874 36 08            ld (hl),08                  ; load the block number into memory
 63+  A876 DD 21 32 B5      ld ix,level01diamonds       ; diamond memory
 64+  A87A CD C3 A8         call screen_initobjects     ; draw diamonds
 65+  A87D 21 0A A8         ld hl, screen_tmp
 66+  A880 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A882 DD 21 42 B5      ld ix,level01gems           ; gems memory
 68+  A886 CD C3 A8         call screen_initobjects     ; draw gems
 69+  A889 CD 90 A8         call screen_setuptext       ; draws text on the screen
 70+  A88C CD EB C4         call scores_printscores     ; print the current scores
 71+  A88F C9               ret
 72+  A890
 73+  A890              ;
 74+  A890              ; Sets up text on the screen
 75+  A890              ;
 76+  A890              screen_setuptext:
 77+  A890 CD 47 C5         call scores_showtable
 78+  A893 CD 18 A8         call screen_sethighscorecolours
 79+  A896 21 06 81         ld hl, string_score1
 80+  A899 CD 57 85         call string_print
 81+  A89C 21 0F 81         ld hl, string_scorenumbers1
 82+  A89F CD 57 85         call string_print
 83+  A8A2 21 18 81         ld hl, string_company
 84+  A8A5 CD 57 85         call string_print
 85+  A8A8 21 2D 81         ld hl, string_score2
 86+  A8AB CD 57 85         call string_print
 87+  A8AE 21 36 81         ld hl, string_scorenumbers2
 88+  A8B1 CD 57 85         call string_print
 89+  A8B4 21 22 81         ld hl, string_credits
 90+  A8B7 CD 57 85         call string_print
 91+  A8BA CD 0C A8         call screen_setscorecolours
 92+  A8BD C9               ret
 93+  A8BE
 94+  A8BE              ;
 95+  A8BE              ; Sets a line of colours
 96+  A8BE              ; Inputs:
 97+  A8BE              ; a - colour to set
 98+  A8BE              ; b - number to set
 99+  A8BE              ; de - start memory location
100+  A8BE              ;
101+  A8BE              screen_setcolours:
102+  A8BE 12               ld (de),a
103+  A8BF 13               inc de
104+  A8C0 10 FC            djnz screen_setcolours
105+  A8C2 C9               ret
106+  A8C3
107+  A8C3              ;
108+  A8C3              ; Draw initial object positions
109+  A8C3              ; Inputs:
110+  A8C3              ; ix - memory location of objects
111+  A8C3              ; a - graphic
112+  A8C3              screen_initobjects:
113+  A8C3 DD 4E 00         ld c,(ix)                   ; get the horiz coord
114+  A8C6 79               ld a,c
115+  A8C7 FE FF            cp 255
116+  A8C9 CA F2 A8         jp z,screen_initobjects2
117+  A8CC DD 23            inc ix                      ; move to next
118+  A8CE DD 46 00         ld b,(ix)                   ; get the vert coord
119+  A8D1 DD 23            inc ix
120+  A8D3 CD 04 A9         call screen_getcellattradress ; get the memory address of b,c attr into de
121+  A8D6 D5               push de
122+  A8D7 3A 0A A8         ld a,(screen_tmp)                  ; get the block number back
123+  A8DA CD E1 A9         call screen_getattr         ; get the memory location for this cell's attr into hl
124+  A8DD D1               pop de
125+  A8DE 7E               ld a,(hl)                   ; get the attr value at the address
126+  A8DF 12               ld (de),a                   ; load the attr into memory
127+  A8E0 3A 0A A8         ld a,(screen_tmp)                  ; get the block number back
128+  A8E3 CD A8 A9         call screen_getblock        ; get the block data into hl
129+  A8E6 CD 85 A9         call screen_showchar        ; show this character here
130+  A8E9
131+  A8E9              screen_initobjects1:
132+  A8E9 DD 23            inc ix                      ; move past state
133+  A8EB DD 23            inc ix
134+  A8ED DD 23            inc ix                      ; move past mem
135+  A8EF C3 C3 A8         jp screen_initobjects
136+  A8F2              screen_initobjects2:
137+  A8F2 C9               ret
138+  A8F3
139+  A8F3
140+  A8F3              ;
141+  A8F3              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
142+  A8F3              ; Inputs:
143+  A8F3              ; bc: coords
144+  A8F3              ; Outputs:
145+  A8F3              ; de: memory location
146+  A8F3              ;
147+  A8F3              screen_getcelladdress:
148+  A8F3 78               ld a,b      ; vertical position.
149+  A8F4 E6 18            and 24      ; which segment, 0, 1 or 2?
150+  A8F6 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
151+  A8F8 57               ld d,a      ; this is our high byte.
152+  A8F9 78               ld a,b      ; what was that vertical position again?
153+  A8FA E6 07            and 7       ; which row within segment?
154+  A8FC 0F               rrca        ; multiply row by 32.
155+  A8FD 0F               rrca
156+  A8FE 0F               rrca
157+  A8FF 5F               ld e,a      ; low byte.
158+  A900 79               ld a,c      ; add on y coordinate.
159+  A901 83               add a,e     ; mix with low byte.
160+  A902 5F               ld e,a      ; address of screen position in de.
161+  A903 C9               ret
162+  A904
163+  A904              ;
164+  A904              ; Calculate buffer address of attribute for character at (b, c).
165+  A904              ; Inputs:
166+  A904              ; bc: coords
167+  A904              ; Outputs:
168+  A904              ; de: memory location
169+  A904              ;
170+  A904              screen_getcellattradress:
171+  A904 11 9F A2         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
172+  A907 69               ld l,c      ; x position.
173+  A908 26 00            ld h,0      ; 0 h
174+  A90A 19               add hl,de
175+  A90B 54 5D            ld de,hl    ; horiz done
176+  A90D 78               ld a,b      ; do vert
177+  A90E D5               push de
178+  A90F C5               push bc
179+  A910 11 20 00         ld de,32
180+  A913 CD 3A 80         call utilities_multiply
181+  A916 C1               pop bc
182+  A917 D1               pop de
183+  A918 19               add hl,de
184+  A919 54 5D            ld de,hl    ; vert done
185+  A91B C9               ret
186+  A91C
187+  A91C              ;
188+  A91C              ; Calculate buffer address offset of attribute for character at (b, c).
189+  A91C              ; Inputs:
190+  A91C              ; bc: coords
191+  A91C              ; Outputs:
192+  A91C              ; de: memory location
193+  A91C              ;
194+  A91C              screen_getcellattroffset:
195+  A91C 69               ld l,c      ; x position.
196+  A91D 26 00            ld h,0      ; 0 h
197+  A91F 54 5D            ld de,hl    ; horiz done
198+  A921 78               ld a,b      ; do vert
199+  A922 D5               push de
200+  A923 C5               push bc
201+  A924 11 20 00         ld de,32
202+  A927 CD 3A 80         call utilities_multiply
203+  A92A C1               pop bc
204+  A92B D1               pop de
205+  A92C 19               add hl,de
206+  A92D 54 5D            ld de,hl    ; vert done
207+  A92F C9               ret
208+  A930
209+  A930              ;
210+  A930              ; Calculate buffer address of attribute for character at (b, c).
211+  A930              ; Inputs:
212+  A930              ; bc: coords
213+  A930              ; Outputs:
214+  A930              ; de: memory location
215+  A930              ;
216+  A930              screen_getscreenattradress:
217+  A930 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
218+  A933 69               ld l,c      ; x position.
219+  A934 26 00            ld h,0      ; 0 h
220+  A936 19               add hl,de
221+  A937 54 5D            ld de,hl    ; horiz done
222+  A939 78               ld a,b      ; do vert
223+  A93A D5               push de
224+  A93B C5               push bc
225+  A93C 11 20 00         ld de,32
226+  A93F CD 3A 80         call utilities_multiply
227+  A942 C1               pop bc
228+  A943 D1               pop de
229+  A944 19               add hl,de
230+  A945 54 5D            ld de,hl    ; vert done
231+  A947 C9               ret
232+  A948
233+  A948              ;
234+  A948              ; Gets the attr memory location for a screen coord
235+  A948              ; Will overwrite bc
236+  A948              ; Inputs:
237+  A948              ; bc - screen coords
238+  A948              ; Outputs:
239+  A948              ; de - memory location
240+  A948              ; bc - character coords
241+  A948              ;
242+  A948              screen_getattraddressfromscreencoords:
243+  A948 78               ld a,b                          ; get the player block coords of current block
244+  A949 E6 F8            and 248                         ; find closest multiple of eight
245+  A94B 0F               rrca
246+  A94C 0F               rrca
247+  A94D 0F               rrca                ; divide by 8
248+  A94E 47               ld b,a
249+  A94F 79               ld a,c
250+  A950 48               ld c,b                         ; swap b and c
251+  A951 E6 F8            and 248
252+  A953 0F               rrca
253+  A954 0F               rrca
254+  A955 0F               rrca                ; divide by 8
255+  A956 47               ld b,a
256+  A957 CD 04 A9         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
257+  A95A C9               ret
258+  A95B
259+  A95B
260+  A95B              ; Gets the nearest cell coords for a screen coord
261+  A95B              ; Will overwrite bc
262+  A95B              ; Inputs:
263+  A95B              ; bc - screen coords
264+  A95B              ; Outputs:
265+  A95B              ; bc - character coords
266+  A95B              ;
267+  A95B              screen_getcharcoordsfromscreencoords:
268+  A95B 78               ld a,b                          ; get the player block coords of current block
269+  A95C E6 F8            and 248                         ; find closest multiple of eight
270+  A95E 0F               rrca
271+  A95F 0F               rrca
272+  A960 0F               rrca                ; divide by 8
273+  A961 47               ld b,a
274+  A962 79               ld a,c
275+  A963 48               ld c,b                         ; swap b and c
276+  A964 E6 F8            and 248
277+  A966 0F               rrca
278+  A967 0F               rrca
279+  A968 0F               rrca                ; divide by 8
280+  A969 47               ld b,a
281+  A96A C9               ret
282+  A96B
283+  A96B              ; Gets the screen coords for a cell coord
284+  A96B              ; Will overwrite bc
285+  A96B              ; Inputs:
286+  A96B              ; bc - char coords
287+  A96B              ; Outputs:
288+  A96B              ; bc - screen coords
289+  A96B              ;
290+  A96B              screen_getscreencoordsfromcharcoords:
291+  A96B 78               ld a,b                          ; get the player block coords of current block
292+  A96C 07               rlca
293+  A96D 07               rlca
294+  A96E 07               rlca                ; multiply by 8
295+  A96F 47               ld b,a
296+  A970 79               ld a,c
297+  A971 48               ld c,b                         ; swap b and c
298+  A972 07               rlca
299+  A973 07               rlca
300+  A974 07               rlca                ; divide by 8
301+  A975 47               ld b,a
302+  A976 C9               ret
303+  A977
304+  A977              ;
305+  A977              ; Get buffer address for a character at b,c - b vert
306+  A977              ; Buffer memory is stored as sequential block
307+  A977              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
308+  A977              ; Inputs:
309+  A977              ; bc - coords
310+  A977              ; Outputs:
311+  A977              ; de - memory location of first byte
312+  A977              screen_getbufferaddress:
313+  A977 21 9F 85         ld hl, buffer_buffer    ; first get screen buffer start
314+  A97A 50               ld d,b                  ; then work out vertical offset
315+  A97B 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
316+  A97D 19               add hl,de               ; add to base
317+  A97E 59               ld e,c                  ; then add horizontal offset (c)
318+  A97F 16 00            ld d,0
319+  A981 19               add hl,de               ; add to base
320+  A982 54 5D            ld de,hl
321+  A984 C9               ret
322+  A985
323+  A985              ;
324+  A985              ; Display character hl at (b, c) to buffer.
325+  A985              ; Stored sequentially
326+  A985              ; Inputs:
327+  A985              ; hl: block address
328+  A985              ; bc: coords
329+  A985              ;
330+  A985              screen_showchar:
331+  A985 ED 43 44 AB      ld (origcoords),bc   ; store char coords
332+  A989 3E 00            ld a,0
333+  A98B E5               push hl
334+  A98C CD 77 A9         call screen_getbufferaddress ; get the current screen buffer pointer
335+  A98F E1               pop hl
336+  A990 06 08            ld b,8              ; number of pixels high.
337+  A992              screen_showchar0:
338+  A992 7E               ld a,(hl)           ; source graphic.
339+  A993 12               ld (de),a           ; transfer to screen.
340+  A994 23               inc hl              ; next piece of data.
341+  A995 E5               push hl             ; store hl
342+  A996 62 6B            ld hl,de            ; put de in hl
343+  A998 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
344+  A99A 16 00            ld d,0
345+  A99C 19               add hl,de              ; add de to hl
346+  A99D 54 5D            ld de,hl            ; load back to de
347+  A99F E1               pop hl              ; restore hl
348+  A9A0
349+  A9A0 10 F0            djnz screen_showchar0 ; repeat
350+  A9A2 2E 01            ld l,1
351+  A9A4 CD F5 AA         call sprites_marklinesforupdatechar
352+  A9A7
353+  A9A7 C9               ret
354+  A9A8
355+  A9A8
356+  A9A8              ;
357+  A9A8              ; Get cell graphic.
358+  A9A8              ; Inputs:
359+  A9A8              ; a: block
360+  A9A8              ; Outputs:
361+  A9A8              ; hl: memory
362+  A9A8              ;
363+  A9A8              screen_getblock:
364+  A9A8 07               rlca                        ; multiply block number by eight.
365+  A9A9 07               rlca
366+  A9AA 07               rlca
367+  A9AB 5F               ld e,a                      ; displacement to graphic address.
368+  A9AC 16 00            ld d,0                      ; no high byte.
369+  A9AE 21 B7 B5         ld hl,sprites               ; address of character blocks.
370+  A9B1 19               add hl,de                   ; point to block.
371+  A9B2 C9               ret
372+  A9B3
373+  A9B3              ;
374+  A9B3              ; Set a the attr of a coord
375+  A9B3              ; Inputs:
376+  A9B3              ; bc - char coords
377+  A9B3              ; a - attr
378+  A9B3              ;
379+  A9B3              screen_setattr:
380+  A9B3 DD E5            push ix
381+  A9B5 C5               push bc
382+  A9B6 08               ex af, af'
383+  A9B7 CD 1C A9         call screen_getcellattroffset   ; get offset into de
384+  A9BA 21 9F A2         ld hl,buffer_attr_buffer
385+  A9BD 19               add hl,de                       ; get the memory location
386+  A9BE 08               ex af, af'                      ; get attr back
387+  A9BF 77               ld (hl),a                         ; set the attr
388+  A9C0 08               ex af, af'                      ; get attr back
389+  A9C1 ED 5B 09 A8      ld de,(screen_offset)           ; get the offset
390+  A9C5 78               ld a,b                          ; get the vertical
391+  A9C6 93               sub e                           ; subtract the offset
392+  A9C7 DA DD A9         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
393+  A9CA FE 15            cp 21
394+  A9CC D2 DD A9         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
395+  A9CF 47               ld b,a                          ; put the coord back in b
396+  A9D0 CD 30 A9         call screen_getscreenattradress ; screen attr address in de
397+  A9D3 21 40 00         ld hl,64                        ; attr memory + two rows for scores
398+  A9D6 19               add hl,de
399+  A9D7 08               ex af, af'                      ; get attr back
400+  A9D8 77               ld (hl),a
401+  A9D9 C1               pop bc
402+  A9DA DD E1            pop ix
403+  A9DC C9               ret
404+  A9DD              screen_setattr0:
405+  A9DD C1               pop bc
406+  A9DE DD E1            pop ix
407+  A9E0 C9               ret
408+  A9E1
409+  A9E1              ;
410+  A9E1              ; Get cell attribute.
411+  A9E1              ; Inputs:
412+  A9E1              ; a: block
413+  A9E1              ; Outputs:
414+  A9E1              ; hl: memory
415+  A9E1              ;
416+  A9E1              screen_getattr:
417+  A9E1 5F               ld e,a                      ; displacement to attribute address.
418+  A9E2 16 00            ld d,0                      ; no high byte.
419+  A9E4 21 97 B6         ld hl,sprite_attrs          ; address of block attributes.
420+  A9E7 19               add hl,de                   ; point to attribute.
421+  A9E8 C9               ret
422+  A9E9
423+  A9E9              ;
424+  A9E9              ; Checks whether a character block has anything in it
425+  A9E9              ; Inputs:
426+  A9E9              ; bc - char coords
427+  A9E9              ; Outputs:
428+  A9E9              ; a - 1, empty
429+  A9E9              screen_ischarempty:
430+  A9E9 CD 77 A9         call screen_getbufferaddress ; get the current screen buffer pointer
431+  A9EC 06 08            ld b,8                      ; check 8 rows
432+  A9EE              screen_ischarempty2:
433+  A9EE 1A               ld a,(de)                   ; check line
434+  A9EF FE 00            cp 0
435+  A9F1 C2 FF A9         jp nz,screen_ischarempty1   ; if not zero, jump out with false
436+  A9F4 21 20 00         ld hl,32
437+  A9F7 19               add hl,de
438+  A9F8 54 5D            ld de,hl                    ; move to next row
439+  A9FA 10 F2            djnz screen_ischarempty2
440+  A9FC              screen_ischarempty0:
441+  A9FC 3E 01            ld a,1
442+  A9FE C9               ret
443+  A9FF              screen_ischarempty1:
444+  A9FF 3E 00            ld a,0
445+  AA01 C9               ret
446+  AA02
447+  AA02              ;
448+  AA02              ; Copies a block from one place to another directly underneath, leaves the original empty
449+  AA02              ; Inputs:
450+  AA02              ; bc - coords of block to copy from
451+  AA02              screen_copyblockdown
452+  AA02 CD 77 A9         call screen_getbufferaddress ; get the current screen buffer pointer for source
453+  AA05 06 08            ld b,8                      ; copy 8 rows
454+  AA07              screen_copyblock0:
455+  AA07 1A               ld a,(de)                    ; get what we're copying
456+  AA08 08               ex af,af'
457+  AA09 3E 00            ld a,0
458+  AA0B 12               ld (de),a                    ; replace with empty
459+  AA0C 08               ex af,af'
460+  AA0D 14               inc d                        ; add 256 to get to the next row
461+  AA0E 12               ld (de),a                    ; copy to the next row
462+  AA0F 15               dec d
463+  AA10 21 20 00         ld hl,32
464+  AA13 19               add hl,de                       ; return back to source, next row down
465+  AA14 54 5D            ld de,hl
466+  AA16 10 EF            djnz screen_copyblock0
467+  AA18 C9               ret
468+  AA19
469+  AA19              ;
470+  AA19              ; Returns the first byte of a character. Useful for figuring out what's there
471+  AA19              ; Inputs:
472+  AA19              ; bc - coords
473+  AA19              ; Outputs:
474+  AA19              ; a - first byte
475+  AA19              ;
476+  AA19              screen_getcharfirstbyte:
477+  AA19 CD 77 A9         call screen_getbufferaddress ; get the current screen buffer pointer for source
478+  AA1C 1A               ld a,(de)
479+  AA1D C9               ret
480+  AA1E
# file closed: screen/screen.asm
 25   AA1E                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  AA1E              ;
  2+  AA1E              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  AA1E              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  AA1E              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  AA1E              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  AA1E              ; routine takes care of all the shifting itself. This means that sprite
  7+  AA1E              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  AA1E              ; space they would require in pre-shifted form.
  9+  AA1E              ; Inputs:
 10+  AA1E              ; hl - sprite data
 11+  AA1E              ; bc - screen coords
 12+  AA1E              ;
 13+  AA1E              sprites_drawsprite7:
 14+  AA1E EE 07            xor 7               ; complement last 3 bits.
 15+  AA20 3C               inc a               ; add one for luck!
 16+  AA21              sprites_drawsprite3:
 17+  AA21 CB 11            rl c                ; ...into middle byte...
 18+  AA23 CB 12            rl d                ; ...and finally into left character cell.
 19+  AA25 3D               dec a               ; count shifts we've done.
 20+  AA26 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  AA28                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  AA28 79               ld a,c              ; left edge of image is currently in e.
 23+  AA29 4A               ld c,d              ; put right edge there instead.
 24+  AA2A 57               ld d,a              ; and the left edge back into c.
 25+  AA2B 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  AA2D              sprites_drawsprite:
 27+  AA2D ED 43 44 AB      ld (origcoords),bc  ; store coords
 28+  AA31 ED 43 46 AB      ld (dispx),bc       ; store coords in dispx for now.
 29+  AA35 E5               push hl
 30+  AA36 CD 22 AB         call sprites_scadd  ; calculate screen address.
 31+  AA39 E1               pop hl
 32+  AA3A 3E 08            ld a,8              ; height of sprite in pixels.
 33+  AA3C              sprites_drawsprite1:
 34+  AA3C 08               ex af,af'           ; store loop counter.
 35+  AA3D D5               push de             ; store screen address.
 36+  AA3E 4E               ld c,(hl)           ; first sprite graphic.
 37+  AA3F 23               inc hl              ; increment poiinter to sprite data.
 38+  AA40 22 48 AB         ld (sprtmp),hl      ; store it for later.
 39+  AA43 16 00            ld d,0              ; blank right byte for now.
 40+  AA45 78               ld a,b              ; b holds y position.
 41+  AA46 E6 07            and 7               ; how are we straddling character cells?
 42+  AA48 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  AA4A FE 05            cp 5                ; 5 or more right shifts needed?
 44+  AA4C 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  AA4E A7               and a               ; oops, carry flag is set so clear it.
 46+  AA4F              sprites_drawsprite2:
 47+  AA4F CB 19            rr c                ; rotate left byte right...
 48+  AA51 CB 1A            rr d                ; ...into right byte.
 49+  AA53 3D               dec a               ; one less shift to do.
 50+  AA54 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  AA56              sprites_drawsprite0:
 52+  AA56 E1               pop hl              ; pop screen address from stack.
 53+  AA57 7E               ld a,(hl)           ; what's there already.
 54+  AA58 A9               xor c               ; merge in image data.
 55+  AA59 77               ld (hl),a           ; place onto screen.
 56+  AA5A 23               inc hl
 57+  AA5B 7E               ld a,(hl)           ; what's already there.
 58+  AA5C AA               xor d               ; right edge of sprite image data.
 59+  AA5D 77               ld (hl),a           ; plonk it on screen.
 60+  AA5E 3A 46 AB         ld a,(dispx)        ; vertical coordinate.
 61+  AA61 3C               inc a               ; next line down.
 62+  AA62 32 46 AB         ld (dispx),a        ; store new position.
 63+  AA65 2B               dec hl
 64+  AA66 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  AA69 19               add hl,de           ; add 32
 66+  AA6A              sprites_drawsprite6:
 67+  AA6A EB               ex de,hl            ; screen address in de.
 68+  AA6B 2A 48 AB         ld hl,(sprtmp)      ; restore graphic address.
 69+  AA6E 08               ex af,af'           ; restore loop counter.
 70+  AA6F 3D               dec a               ; decrement it.
 71+  AA70 C2 3C AA         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  AA73 2E 02            ld l,2
 73+  AA75 CD E4 AA         call sprites_marklinesforupdatescreen
 74+  AA78 C9               ret                 ; job done.
 75+  AA79
 76+  AA79              ; Inputs:
 77+  AA79              ; hl - sprite data
 78+  AA79              ; bc - screen coords
 79+  AA79              ;
 80+  AA79              sprites_draw2by2sprite7
 81+  AA79 EE 07            xor 7               ; complement last 3 bits.
 82+  AA7B 3C               inc a               ; add one for luck!
 83+  AA7C              sprites_draw2by2sprite3
 84+  AA7C CB 12            rl d                ; rotate left...
 85+  AA7E CB 11            rl c                ; ...into middle byte...
 86+  AA80 CB 13            rl e                ; ...and finally into left character cell.
 87+  AA82 3D               dec a               ; count shifts we've done.
 88+  AA83 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  AA85                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  AA85 7B               ld a,e              ; left edge of image is currently in e.
 91+  AA86 5A               ld e,d              ; put right edge there instead.
 92+  AA87 51               ld d,c              ; middle bit goes in d.
 93+  AA88 4F               ld c,a              ; and the left edge back into c.
 94+  AA89 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  AA8B              sprites_draw2by2sprite
 96+  AA8B ED 43 44 AB      ld (origcoords),bc  ; store coords
 97+  AA8F ED 43 46 AB      ld (dispx),bc       ; store coords in dispx for now.
 98+  AA93 79               ld a,c
 99+  AA94 32 4A AB         ld (sprtmp0),a         ; store vertical.
100+  AA97 E5               push hl
101+  AA98 CD 22 AB         call sprites_scadd          ; calculate screen address.
102+  AA9B E1               pop hl
103+  AA9C 3E 10            ld a,16             ; height of sprite in pixels.
104+  AA9E              sprites_draw2by2sprite1
105+  AA9E 08               ex af,af'           ; store loop counter.
106+  AA9F D5               push de             ; store screen address.
107+  AAA0 4E               ld c,(hl)           ; first sprite graphic.
108+  AAA1 23               inc hl              ; increment poiinter to sprite data.
109+  AAA2 56               ld d,(hl)           ; next bit of sprite image.
110+  AAA3 23               inc hl              ; point to next row of sprite data.
111+  AAA4 22 48 AB         ld (sprtmp),hl        ; store in tmp0 for later.
112+  AAA7 1E 00            ld e,0              ; blank right byte for now.
113+  AAA9 78               ld a,b              ; b holds y position.
114+  AAAA E6 07            and 7               ; how are we straddling character cells?
115+  AAAC 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  AAAE FE 05            cp 5                ; 5 or more right shifts needed?
117+  AAB0 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  AAB2 A7               and a               ; oops, carry flag is set so clear it.
119+  AAB3              sprites_draw2by2sprite2
120+  AAB3 CB 19            rr c                ; rotate left byte right...
121+  AAB5 CB 1A            rr d                ; ...through middle byte...
122+  AAB7 CB 1B            rr e                ; ...into right byte.
123+  AAB9 3D               dec a               ; one less shift to do.
124+  AABA 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  AABC              sprites_draw2by2sprite0
126+  AABC E1               pop hl              ; pop screen address from stack.
127+  AABD 7E               ld a,(hl)           ; what's there already.
128+  AABE A9               xor c               ; merge in image data.
129+  AABF 77               ld (hl),a           ; place onto screen.
130+  AAC0 23               inc hl               ; next character cell to right please.
131+  AAC1 7E               ld a,(hl)           ; what's there already.
132+  AAC2 AA               xor d               ; merge with middle bit of image.
133+  AAC3 77               ld (hl),a           ; put back onto screen.
134+  AAC4 23               inc hl              ; next bit of screen area.
135+  AAC5 7E               ld a,(hl)           ; what's already there.
136+  AAC6 AB               xor e               ; right edge of sprite image data.
137+  AAC7 77               ld (hl),a           ; plonk it on screen.
138+  AAC8 3A 4A AB         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  AACB 3C               inc a               ; next line down.
140+  AACC 32 4A AB         ld (sprtmp0),a         ; store new position.
141+  AACF 2B               dec hl
142+  AAD0 2B               dec hl
143+  AAD1 11 20 00         ld de,32            ; add 32 to get to the next row
144+  AAD4 19               add hl,de           ; add 32
145+  AAD5              sprites_draw2by2sprite6
146+  AAD5 EB               ex de,hl            ; screen address in de.
147+  AAD6 2A 48 AB         ld hl,(sprtmp)        ; restore graphic address.
148+  AAD9 08               ex af,af'           ; restore loop counter.
149+  AADA 3D               dec a               ; decrement it.
150+  AADB C2 9E AA         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  AADE 2E 03            ld l,3
152+  AAE0 CD E4 AA         call sprites_marklinesforupdatescreen
153+  AAE3 C9               ret                 ; job done.
154+  AAE4
155+  AAE4              ;
156+  AAE4              ; Marks lines for update with screen coords
157+  AAE4              ; Inputs:
158+  AAE4              ; l - number to update
159+  AAE4              ;
160+  AAE4              sprites_marklinesforupdatescreen:
161+  AAE4 F5               push af
162+  AAE5 ED 4B 44 AB      ld bc,(origcoords)
163+  AAE9 CD 5B A9         call screen_getcharcoordsfromscreencoords
164+  AAEC ED 43 44 AB      ld (origcoords),bc
165+  AAF0 CD FF AA         call sprites_marklinesforupdate
166+  AAF3 F1               pop af
167+  AAF4 C9               ret
168+  AAF5
169+  AAF5              ;
170+  AAF5              ; Marks lines for update with char coords
171+  AAF5              ; Inputs:
172+  AAF5              ; l - number to update
173+  AAF5              ;
174+  AAF5              sprites_marklinesforupdatechar:
175+  AAF5 F5               push af
176+  AAF6 ED 43 44 AB      ld (origcoords),bc
177+  AAFA CD FF AA         call sprites_marklinesforupdate
178+  AAFD F1               pop af
179+  AAFE C9               ret
180+  AAFF
181+  AAFF              ;
182+  AAFF              ; Marks lines for update
183+  AAFF              ; Inputs:
184+  AAFF              ; l - number to update
185+  AAFF              ;
186+  AAFF              sprites_marklinesforupdate:
187+  AAFF ED 4B 44 AB      ld bc,(origcoords)
188+  AB03 ED 5B 09 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
189+  AB07 78               ld a,b
190+  AB08 93               sub e
191+  AB09 47               ld b,a
192+  AB0A 7D               ld a,l                          ; get loop counter
193+  AB0B              sprites_marklinesforupdate0:
194+  AB0B C5               push bc
195+  AB0C 08               ex af,af'                     ; store loop counter
196+  AB0D 78               ld a,b
197+  AB0E CD 57 A6         call buffer_marklineforupdate ; mark this line for update
198+  AB11 ED 4B 44 AB      ld bc,(origcoords)            ; move the coords for the next line
199+  AB15 04               inc b
200+  AB16 ED 43 44 AB      ld (origcoords),bc
201+  AB1A C1               pop bc
202+  AB1B 04               inc b
203+  AB1C 08               ex af,af'                     ; restore loop counter
204+  AB1D 3D               dec a
205+  AB1E C2 0B AB         jp nz,sprites_marklinesforupdate0
206+  AB21 C9               ret
207+  AB22
208+  AB22              ;
209+  AB22              ; This routine returns a buffer address for (c, b) in de (c vert).
210+  AB22              ; For example: 0,0 will be at memory offset 0
211+  AB22              ; 1,0 (1 down) will be at memory offset 1
212+  AB22              ; 0,7 will be at memory offset 0
213+  AB22              ; 9,1 will be at memory offset 8+1
214+  AB22              ; 8,0 will be at memory offset 256
215+  AB22              ; 9,0 will be at memory offset 257
216+  AB22              ; Outputs:
217+  AB22              ; de - coords
218+  AB22              ;
219+  AB22              sprites_scadd:
220+  AB22 79               ld a,c               ; calculate vertical offset
221+  AB23 E6 F8            and 248             ;  to get nearest multiple of 8
222+  AB25 0F               rrca
223+  AB26 0F               rrca
224+  AB27 0F               rrca                ; divide by 8
225+  AB28 67               ld h,a
226+  AB29 78               ld a,b               ; calculate horizontal offset
227+  AB2A E6 F8            and 248             ;  to get nearest multiple of 8
228+  AB2C 0F               rrca
229+  AB2D 0F               rrca
230+  AB2E 0F               rrca                ; divide by 8
231+  AB2F 6F               ld l,a
232+  AB30 C5               push bc             ; store the screen coords
233+  AB31 44 4D            ld bc,hl            ; load bc with the character coords
234+  AB33 CD 77 A9         call screen_getbufferaddress
235+  AB36 C1               pop bc              ; get back screen coords, de is now memory of character
236+  AB37 79               ld a,c              ; now add the vertical within the cell
237+  AB38 E6 07            and 7
238+  AB3A 0F               rrca                ; multiply by 32.
239+  AB3B 0F               rrca
240+  AB3C 0F               rrca
241+  AB3D 6F               ld l,a
242+  AB3E 26 00            ld h,0
243+  AB40 19               add hl,de
244+  AB41 54 5D            ld de,hl
245+  AB43 C9               ret
246+  AB44
247+  AB44 00 00        origcoords   defb 0,0           ; general-use coordinates.
248+  AB46
249+  AB46 00           dispx   defb 0           ; general-use coordinates.
250+  AB47 00           dispy   defb 0
251+  AB48 00 00        sprtmp  defb 0,0           ; sprite temporary address.
252+  AB4A 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
253+  AB4C
# file closed: screen/sprites.asm
 26   AB4C                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AB4C              ;
  2+  AB4C              ; Draws the title screen
  3+  AB4C              ;
  4+  AB4C              titlescreen_show:
  5+  AB4C CD DE AB         call titlescreen_init
  6+  AB4F CD 87 AB         call titlescreen_drawtitle
  7+  AB52 3A 63 BD         ld a,(game_control)
  8+  AB55 FE 00            cp 0
  9+  AB57 CA 5F AB         jp z,titlescreen_show1
 10+  AB5A 06 32            ld b,50
 11+  AB5C CD 9B 80         call utilities_pauseforframes         ; pause for a second
 12+  AB5F              titlescreen_show1:
 13+  AB5F 3E FA            ld a,250                              ; wait for 200 frames
 14+  AB61 CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 15+  AB64 7B               ld a,e
 16+  AB65 FE 01            cp 1                                  ; was anything pressed?
 17+  AB67 C8               ret z                                 ; end titlescreen if so
 18+  AB68
 19+  AB68 CD F1 AB         call titlescreen_alt_init             ; otherwise, draw alt screen
 20+  AB6B CD A3 AB         call titlescreen_alt_drawtitle
 21+  AB6E 3A 63 BD         ld a,(game_control)
 22+  AB71 FE 00            cp 0
 23+  AB73 CA 7B AB         jp z,titlescreen_show0
 24+  AB76 06 32            ld b,50
 25+  AB78 CD 9B 80         call utilities_pauseforframes         ; pause for a second if joystick
 26+  AB7B              titlescreen_show0:
 27+  AB7B 3E FA            ld a,250                              ; wait for 200 frames
 28+  AB7D CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 29+  AB80 7B               ld a,e
 30+  AB81 FE 01            cp 1                                  ; was anything pressed?
 31+  AB83 C2 4C AB         jp nz,titlescreen_show                ; start again if not
 32+  AB86 C9               ret
 33+  AB87
 34+  AB87              ;
 35+  AB87              ; Draws the iconic logo
 36+  AB87              ;
 37+  AB87              titlescreen_drawtitle:
 38+  AB87 06 67            ld b,103              ; number of points
 39+  AB89 DD 21 FE AB      ld ix,titlescreen_logo_data
 40+  AB8D              titlescreen_drawtitle0:
 41+  AB8D C5               push bc
 42+  AB8E DD 4E 00         ld c,(ix)                   ; got horiz
 43+  AB91 DD 23            inc ix
 44+  AB93 DD 46 00         ld b,(ix)                   ; got vert
 45+  AB96 DD 23            inc ix
 46+  AB98 CD 30 A9         call screen_getscreenattradress ; memory in de
 47+  AB9B 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 48+  AB9C 3E 13            ld a,19
 49+  AB9E 12               ld (de),a
 50+  AB9F C1               pop bc
 51+  ABA0 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 52+  ABA2 C9               ret
 53+  ABA3
 54+  ABA3              ;
 55+  ABA3              ; Draws the alternate title screen
 56+  ABA3              ;
 57+  ABA3              titlescreen_alt_drawtitle:
 58+  ABA3 21 54 81         ld hl,string_alttitlescreen_1
 59+  ABA6 CD 57 85         call string_print
 60+  ABA9 21 60 81         ld hl,string_alttitlescreen_2
 61+  ABAC CD 57 85         call string_print
 62+  ABAF 21 5B 82         ld hl,string_alttitlescreen_3
 63+  ABB2 CD 57 85         call string_print
 64+  ABB5 06 20            ld b,32
 65+  ABB7 3E 43            ld a,67
 66+  ABB9 11 00 58         ld de,22528                         ; top row attrs here
 67+  ABBC CD BE A8         call screen_setcolours
 68+  ABBF 06 20            ld b,32
 69+  ABC1 3E 46            ld a,70
 70+  ABC3 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 71+  ABC6 CD BE A8         call screen_setcolours
 72+  ABC9 06 20            ld b,32
 73+  ABCB 3E 43            ld a,67
 74+  ABCD 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 75+  ABD0 CD BE A8         call screen_setcolours
 76+  ABD3 06 20            ld b,32
 77+  ABD5 3E 42            ld a,66
 78+  ABD7 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 79+  ABDA CD BE A8         call screen_setcolours
 80+  ABDD C9               ret
 81+  ABDE
 82+  ABDE              ;
 83+  ABDE              ; Initialises the screen
 84+  ABDE              ;
 85+  ABDE              titlescreen_init:
 86+  ABDE              ; We want a black screen.
 87+  ABDE 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 88+  ABE0                                      ; bright (64).
 89+  ABE0 CD 80 80         call utilities_clearscreen
 90+  ABE3 32 8D 5C         ld (23693),a        ; set our screen colours.
 91+  ABE6 3E 01            ld a,1              ; 2 is the code for red.
 92+  ABE8 D3 FE            out (254),a         ; write to port 254.
 93+  ABEA
 94+  ABEA 21 3F 81         ld hl,string_titlescreen_copyright
 95+  ABED CD 57 85         call string_print
 96+  ABF0
 97+  ABF0 C9               ret
 98+  ABF1
 99+  ABF1              ;
100+  ABF1              ; Initialises the screen
101+  ABF1              ;
102+  ABF1              titlescreen_alt_init:
103+  ABF1              ; We want a black screen.
104+  ABF1 3E 47            ld a,71             ; white ink (7) on black paper (0),
105+  ABF3                                      ; bright (64).
106+  ABF3 CD 80 80         call utilities_clearscreen
107+  ABF6 32 8D 5C         ld (23693),a        ; set our screen colours.
108+  ABF9 3E 00            ld a,0              ; 2 is the code for red.
109+  ABFB D3 FE            out (254),a         ; write to port 254.
110+  ABFD
111+  ABFD C9               ret
112+  ABFE
113+  ABFE              ;
114+  ABFE              ; Horiz, vert
115+  ABFE              ;
116+  ABFE              titlescreen_logo_data:
117+  ABFE 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
117+  AC02 0A 00 0C 00
117+  AC06 0F 00 11 00
117+  AC0A 12 00 13 00
118+  AC0E 09 01 0C 01      defb 9,1,12,1,15,1,17,1
118+  AC12 0F 01 11 01
119+  AC16 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
119+  AC1A 0D 02 0E 02
119+  AC1E 0F 02 11 02
119+  AC22 12 02 13 02
120+  AC26 09 03 0C 03      defb 9,3,12,3,15,3,17,3
120+  AC2A 0F 03 11 03
121+  AC2E 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
121+  AC32 0F 04 11 04
121+  AC36 12 04 13 04
122+  AC3A 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
122+  AC3E 02 06 03 06
122+  AC42 04 06 05 06
122+  AC46 06 06 07 06
122+  AC4A 08 06 09 06
122+  AC4E 0A 06 0B 06
123+  AC52 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
123+  AC56 12 06 13 06
123+  AC5A 14 06 15 06
123+  AC5E 16 06 17 06
123+  AC62 18 06 19 06
123+  AC66 1A 06 1B 06
124+  AC6A 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
124+  AC6E 02 09 02 0A
124+  AC72 02 0B 02 0C
124+  AC76 02 0D 02 0E
124+  AC7A 02 0F 02 10
124+  AC7E 02 11 02 12
124+  AC82 02 13 02 14
124+  AC86 02 15
125+  AC88 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
125+  AC8C 19 09 19 0A
125+  AC90 19 0B 19 0C
125+  AC94 19 0D 19 0E
125+  AC98 19 0F 19 10
125+  AC9C 19 11 19 12
125+  ACA0 19 13 19 14
125+  ACA4 19 15
126+  ACA6 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
126+  ACAA 05 0B 06 0B
126+  ACAE 07 0B 08 0B
126+  ACB2 09 0B 0A 0B
126+  ACB6 0B 0B
127+  ACB8 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
127+  ACBC 0B 09 0B 0A
128+  ACC0 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
128+  ACC4 10 10 10 11
128+  ACC8 10 12 10 13
129+  ACCC
# file closed: screen/titlescreen.asm
 27   ACCC                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ACCC              ;
  2+  ACCC              ; Draws the life remaining screen
  3+  ACCC              ;
  4+  ACCC              lifescreen_draw:
  5+  ACCC CD 1F AD         call lifescreen_init
  6+  ACCF
  7+  ACCF 3A 60 BD         ld a,(game_currentplayer)             ; get the current player
  8+  ACD2 C6 30            add 48                                ; add 48 to get char
  9+  ACD4 21 61 83         ld hl,string_lifescreen_player+10
 10+  ACD7 77               ld (hl),a                             ; load this to the string we're about to show
 11+  ACD8
 12+  ACD8 21 57 83         ld hl,string_lifescreen_player
 13+  ACDB CD 57 85         call string_print
 14+  ACDE
 15+  ACDE 3A A0 BD         ld a,(player+9)                       ; get the current player lives
 16+  ACE1 C6 30            add 48                                ; add 48 to get the character
 17+  ACE3 FE 31            cp 49
 18+  ACE5 C2 F8 AC         jp nz,lifescreen_draw0
 19+  ACE8 21 71 83         ld hl,string_lifescreen_lastman
 20+  ACEB
 21+  ACEB 06 08            ld b,8
 22+  ACED 3E 0A            ld a,10                                ; set red
 23+  ACEF 11 6C 58         ld de,22528+108                        ; attrs here
 24+  ACF2 CD BE A8         call screen_setcolours
 25+  ACF5
 26+  ACF5 C3 FF AC         jp lifescreen_draw1
 27+  ACF8              lifescreen_draw0:
 28+  ACF8 21 66 83         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  ACFB 77               ld (hl),a                             ; load this to the string we're about to show
 30+  ACFC 21 64 83         ld hl,string_lifescreen_lives
 31+  ACFF              lifescreen_draw1:
 32+  ACFF CD 57 85         call string_print
 33+  AD02
 34+  AD02 3E 86            ld a,134
 35+  AD04 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AD07 06 0A            ld b,10
 37+  AD09 CD BE A8         call screen_setcolours
 38+  AD0C 3A 63 BD         ld a,(game_control)
 39+  AD0F FE 00            cp 0
 40+  AD11 CA 19 AD         jp z,lifescreen_draw2
 41+  AD14 06 32            ld b,50
 42+  AD16 CD 9B 80         call utilities_pauseforframes         ; pause for a second if joystick
 43+  AD19              lifescreen_draw2:
 44+  AD19 3E 64            ld a,100                              ; wait for 200 frames
 45+  AD1B CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 46+  AD1E
 47+  AD1E C9               ret
 48+  AD1F
 49+  AD1F              ;
 50+  AD1F              ; Initialises the screen
 51+  AD1F              ;
 52+  AD1F              lifescreen_init:
 53+  AD1F              ; We want a blue screen.
 54+  AD1F                  ;call $0D6B
 55+  AD1F 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 56+  AD21                                      ; bright (64).
 57+  AD21 CD 80 80         call utilities_clearscreen
 58+  AD24 32 8D 5C         ld (23693),a        ; set our screen colours.
 59+  AD27 3E 01            ld a,1              ; 1 is the code for blue.
 60+  AD29 D3 FE            out (254),a         ; write to port 254.
 61+  AD2B                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 62+  AD2B
 63+  AD2B C9               ret
# file closed: screen/lifescreen.asm
 28   AD2C                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AD2C              ;
  2+  AD2C              ; Draws the game over screen
  3+  AD2C              ;
  4+  AD2C              gameover_draw:
  5+  AD2C CD 5B C5         call scores_processhighscores
  6+  AD2F
  7+  AD2F              gameover_draw0:
  8+  AD2F CD 6F AD         call gameover_enterhighscores
  9+  AD32
 10+  AD32 CD 0D AE         call gameover_init
 11+  AD35
 12+  AD35 21 7C 83         ld hl,string_gameoverscreen_gameover
 13+  AD38 CD 57 85         call string_print
 14+  AD3B
 15+  AD3B 21 88 83         ld hl,string_gameoverscreen_copyright
 16+  AD3E CD 57 85         call string_print
 17+  AD41
 18+  AD41 CD 52 AD         call gameover_commontext
 19+  AD44
 20+  AD44 06 0B            ld b,11
 21+  AD46 3E 42            ld a,66
 22+  AD48 11 2B 58         ld de,22528+43                         ; attrs here
 23+  AD4B CD BE A8         call screen_setcolours
 24+  AD4E CD 47 80         call utilities_waitforkey   ; wait for keypress
 25+  AD51
 26+  AD51 C9               ret
 27+  AD52
 28+  AD52              ;
 29+  AD52              ; Draws text shared by the game over and high score screens
 30+  AD52              ;
 31+  AD52              gameover_commontext:
 32+  AD52 CD 90 A8         call screen_setuptext       ; show scores
 33+  AD55 CD EB C4         call scores_printscores     ; print the current scores
 34+  AD58
 35+  AD58 21 B0 83         ld hl,string_gameover_credits
 36+  AD5B CD 57 85         call string_print
 37+  AD5E
 38+  AD5E 21 9C 83         ld hl,string_gameoverscreen_bestscores
 39+  AD61 CD 57 85         call string_print
 40+  AD64
 41+  AD64 06 20            ld b,32
 42+  AD66 3E 45            ld a,69
 43+  AD68 11 C0 5A         ld de,22528+704                         ; attrs here
 44+  AD6B CD BE A8         call screen_setcolours
 45+  AD6E
 46+  AD6E C9               ret
 47+  AD6F
 48+  AD6F              ;
 49+  AD6F              ; If required, enter highscore
 50+  AD6F              ;
 51+  AD6F              gameover_enterhighscores:
 52+  AD6F                  ; check if we need to enter initial
 53+  AD6F 3A 5A C5         ld a,(scores_highscoretmp)
 54+  AD72 FE 00            cp 0
 55+  AD74 C8               ret z
 56+  AD75 CD A3 AD         call gameover_enterhighscores_init
 57+  AD78 3A 5A C5         ld a,(scores_highscoretmp)
 58+  AD7B 3D               dec a
 59+  AD7C 3D               dec a
 60+  AD7D 3D               dec a                                   ; get high score location back to position of name
 61+  AD7E 16 00            ld d,0
 62+  AD80 5F               ld e,a
 63+  AD81 21 70 C4         ld hl,scores_table
 64+  AD84 19               add hl,de                               ; load memory into hl
 65+  AD85 08               ex af,af'
 66+  AD86 06 0F            ld b,15
 67+  AD88 CD 9B 80         call utilities_pauseforframes           ; pause for a little bit
 68+  AD8B 06 03            ld b,3                                  ; collect three chars
 69+  AD8D              gameover_draw2:
 70+  AD8D C5               push bc
 71+  AD8E E5               push hl
 72+  AD8F CD 9F 80         call utilities_readkey               ; get key into a
 73+  AD92 E1               pop hl
 74+  AD93 77               ld (hl),a
 75+  AD94 23               inc hl
 76+  AD95 E5               push hl
 77+  AD96 CD 47 C5         call scores_showtable
 78+  AD99 E1               pop hl
 79+  AD9A 06 0F            ld b,15
 80+  AD9C CD 9B 80         call utilities_pauseforframes
 81+  AD9F C1               pop bc
 82+  ADA0 10 EB            djnz gameover_draw2
 83+  ADA2 C9               ret
 84+  ADA3
 85+  ADA3              ;
 86+  ADA3              ; Displays the screen text for high score entry
 87+  ADA3              ;
 88+  ADA3              gameover_enterhighscores_init:
 89+  ADA3
 90+  ADA3 CD 0D AE         call gameover_init
 91+  ADA6 CD 52 AD         call gameover_commontext
 92+  ADA9
 93+  ADA9 21 BC 83         ld hl,string_highscore_congratulations
 94+  ADAC CD 57 85         call string_print
 95+  ADAF
 96+  ADAF 3A 60 BD         ld a,(game_currentplayer)
 97+  ADB2 FE 01            cp 1
 98+  ADB4 21 CE 83         ld hl,string_highscore_player1
 99+  ADB7 C3 BD AD         jp gameover_enterhighscores_init1
100+  ADBA              gameover_enterhighscores_init0:
101+  ADBA 21 D9 83         ld hl,string_highscore_player2
102+  ADBD              gameover_enterhighscores_init1:
103+  ADBD CD 57 85         call string_print
104+  ADC0 06 60            ld b,96
105+  ADC2 3E 43            ld a,67
106+  ADC4 11 A0 58         ld de,22528+160                         ; attrs here
107+  ADC7 CD BE A8         call screen_setcolours
108+  ADCA
109+  ADCA 21 E4 83         ld hl,string_highscore_youhaveearned
110+  ADCD CD 57 85         call string_print
111+  ADD0
112+  ADD0 3A 5A C5         ld a,(scores_highscoretmp)
113+  ADD3 FE 05            cp 5
114+  ADD5 CA E3 AD         jp z, gameover_enterhighscores_init2    ; first place
115+  ADD8 FE 11            cp 17
116+  ADDA CA E9 AD         jp z, gameover_enterhighscores_init3    ; 2nd place
117+  ADDD 21 20 84         ld hl,string_highscore_place3           ; 3rd place
118+  ADE0 C3 EF AD         jp gameover_enterhighscores_init4
119+  ADE3              gameover_enterhighscores_init2
120+  ADE3 21 F6 83         ld hl,string_highscore_place1
121+  ADE6 C3 EF AD         jp gameover_enterhighscores_init4
122+  ADE9              gameover_enterhighscores_init3
123+  ADE9 21 0B 84         ld hl,string_highscore_place2
124+  ADEC C3 EF AD         jp gameover_enterhighscores_init4
125+  ADEF              gameover_enterhighscores_init4
126+  ADEF CD 57 85         call string_print
127+  ADF2
128+  ADF2 06 60            ld b,96
129+  ADF4 3E 42            ld a,66
130+  ADF6 11 40 59         ld de,22528+320                         ; attrs here
131+  ADF9 CD BE A8         call screen_setcolours
132+  ADFC
133+  ADFC 21 35 84         ld hl,string_highscore_pleaseenter
134+  ADFF CD 57 85         call string_print
135+  AE02
136+  AE02 06 60            ld b,96
137+  AE04 3E 46            ld a,70
138+  AE06 11 E0 59         ld de,22528+480                         ; attrs here
139+  AE09 CD BE A8         call screen_setcolours
140+  AE0C C9               ret
141+  AE0D
142+  AE0D              ;
143+  AE0D              ; Initialises the screen
144+  AE0D              ;
145+  AE0D              gameover_init:
146+  AE0D              ; We want a black screen.
147+  AE0D 3E 47            ld a,71             ; white ink (7) on black paper (0),
148+  AE0F                                      ; bright (64).
149+  AE0F CD 80 80         call utilities_clearscreen
150+  AE12 32 8D 5C         ld (23693),a        ; set our screen colours.
151+  AE15 3E 00            ld a,0              ; 2 is the code for red.
152+  AE17 D3 FE            out (254),a         ; write to port 254.
153+  AE19 C9               ret
# file closed: screen/gameover.asm
 29   AE1A                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AE1A              ;
  2+  AE1A              ; Draws the level transition screen
  3+  AE1A              ;
  4+  AE1A              endlevel_draw:
  5+  AE1A CD 15 AF         call endlevel_init
  6+  AE1D CD FE AE         call endlevel_commontext
  7+  AE20
  8+  AE20 21 BC 83         ld hl,string_highscore_congratulations
  9+  AE23 CD 57 85         call string_print
 10+  AE26
 11+  AE26 3A 60 BD         ld a,(game_currentplayer)
 12+  AE29 FE 01            cp 1
 13+  AE2B 21 CE 83         ld hl,string_highscore_player1
 14+  AE2E C3 34 AE         jp endlevel_init1
 15+  AE31              endlevel_init0:
 16+  AE31 21 D9 83         ld hl,string_highscore_player2
 17+  AE34              endlevel_init1:
 18+  AE34 CD 57 85         call string_print
 19+  AE37
 20+  AE37 21 52 84         ld hl,string_endlevel_youhaveearned
 21+  AE3A CD 57 85         call string_print
 22+  AE3D
 23+  AE3D CD 9D AE         call endlevel_workoutbonus
 24+  AE40 D5               push de
 25+  AE41 08               ex af,af'                               ; store the a value for later
 26+  AE42 CD 57 85         call string_print
 27+  AE45 D1               pop de
 28+  AE46 62 6B            ld hl,de                                ; get the points text into de
 29+  AE48 CD 57 85         call string_print
 30+  AE4B
 31+  AE4B 21 BD 84         ld hl, string_endlevel_anothergo
 32+  AE4E CD 57 85         call string_print
 33+  AE51
 34+  AE51 06 20            ld b,32
 35+  AE53 3E 23            ld a,35
 36+  AE55 11 60 59         ld de,22528+352                         ; attrs here
 37+  AE58 CD BE A8         call screen_setcolours
 38+  AE5B
 39+  AE5B 06 20            ld b,32
 40+  AE5D 3E 25            ld a,37
 41+  AE5F 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AE62 CD BE A8         call screen_setcolours
 43+  AE65
 44+  AE65 06 20            ld b,32
 45+  AE67 3E 23            ld a,35
 46+  AE69 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AE6C CD BE A8         call screen_setcolours
 48+  AE6F
 49+  AE6F 06 20            ld b,32
 50+  AE71 3E 22            ld a,34
 51+  AE73 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AE76 CD BE A8         call screen_setcolours
 53+  AE79
 54+  AE79 08               ex af,af'                               ; get back a value with bonus type
 55+  AE7A 06 14            ld b,20
 56+  AE7C CD 9B 80         call utilities_pauseforframes
 57+  AE7F
 58+  AE7F 47               ld b,a                      ; put the bonus count in b
 59+  AE80              endlevel_init2:
 60+  AE80 C5               push bc
 61+  AE81 06 01            ld b,1
 62+  AE83 CD 94 C4         call scores_addthousands
 63+  AE86 CD 5C BE         call player_recordcurrentstate
 64+  AE89 CD AB C4         call scores_printscore     ; print the current scores
 65+  AE8C 06 0A            ld b,10
 66+  AE8E CD 9B 80         call utilities_pauseforframes
 67+  AE91 C1               pop bc
 68+  AE92 10 EC            djnz endlevel_init2
 69+  AE94
 70+  AE94 CD 90 BD         call game_increasedifficulty ; move the difficulty up a level
 71+  AE97
 72+  AE97 3E 64            ld a,100                              ; wait for 200 frames
 73+  AE99 CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 74+  AE9C
 75+  AE9C C9               ret
 76+  AE9D
 77+  AE9D              ;
 78+  AE9D              ; Works out the bonus
 79+  AE9D              ; Outputs:
 80+  AE9D              ; a = 15 (all seven)
 81+  AE9D              ; a = 10 (3 large or 4 small)
 82+  AE9D              ; a = 5 (1 large diamond)
 83+  AE9D              ; hl - pointer to bonus text
 84+  AE9D              ; de - pointer to points text
 85+  AE9D              ;
 86+  AE9D              endlevel_workoutbonus:
 87+  AE9D 21 34 B5         ld hl,level01diamonds+2     ; location of state of first diamond
 88+  AEA0 06 03            ld b,3                      ; number to check
 89+  AEA2 16 00            ld d,0                      ; zero diamond count
 90+  AEA4              endlevel_workoutbonus0:
 91+  AEA4 7E               ld a,(hl)                   ; get state
 92+  AEA5 FE 01            cp 1
 93+  AEA7 C2 AB AE         jp nz,endlevel_workoutbonus1 ; if not, move on
 94+  AEAA 14               inc d                       ; increment diamond count
 95+  AEAB              endlevel_workoutbonus1:
 96+  AEAB 23               inc hl
 97+  AEAC 23               inc hl
 98+  AEAD 23               inc hl
 99+  AEAE 23               inc hl
100+  AEAF 23               inc hl                      ; get to next state
101+  AEB0 10 F2            djnz endlevel_workoutbonus0
102+  AEB2
103+  AEB2 21 44 B5         ld hl,level01gems+2     ; location of state of first gem
104+  AEB5 06 04            ld b,4                      ; number to check
105+  AEB7 1E 00            ld e,0                      ; zero gem count
106+  AEB9              endlevel_workoutbonus2:
107+  AEB9 7E               ld a,(hl)                   ; get state
108+  AEBA FE 01            cp 1
109+  AEBC C2 C0 AE         jp nz,endlevel_workoutbonus3 ; if not, move on
110+  AEBF 1C               inc e                       ; increment diamond count
111+  AEC0              endlevel_workoutbonus3:
112+  AEC0 23               inc hl
113+  AEC1 23               inc hl
114+  AEC2 23               inc hl
115+  AEC3 23               inc hl
116+  AEC4 23               inc hl                     ; get to next state
117+  AEC5 10 F2            djnz endlevel_workoutbonus2
118+  AEC7
119+  AEC7 7A               ld a,d
120+  AEC8 83               add e
121+  AEC9 FE 07            cp 7                        ; check for max bonus
122+  AECB C2 D7 AE         jp nz,endlevel_workoutbonus4 ;
123+  AECE 3E 0F            ld a,15
124+  AED0 21 82 84         ld hl, string_endlevel_bonus3
125+  AED3 11 AE 84         ld de, string_endlevel_points3
126+  AED6 C9               ret                         ; return with bonus of 15
127+  AED7              endlevel_workoutbonus4:
128+  AED7 7A               ld a,d                      ; check for for diamonds
129+  AED8 FE 03            cp 3
130+  AEDA C2 E6 AE         jp nz,endlevel_workoutbonus5
131+  AEDD 3E 0A            ld a,10
132+  AEDF 21 73 84         ld hl, string_endlevel_bonus2
133+  AEE2 11 9F 84         ld de, string_endlevel_points2
134+  AEE5 C9               ret                         ; return with bonus of ten
135+  AEE6              endlevel_workoutbonus5:
136+  AEE6 7B               ld a,e                      ; check for four gems
137+  AEE7 FE 04            cp 4
138+  AEE9 C2 F5 AE         jp nz,endlevel_workoutbonus6
139+  AEEC 3E 0A            ld a,10
140+  AEEE 21 73 84         ld hl, string_endlevel_bonus2
141+  AEF1 11 9F 84         ld de, string_endlevel_points2
142+  AEF4 C9               ret                         ; return with bonus of 10
143+  AEF5              endlevel_workoutbonus6:
144+  AEF5 3E 05            ld a,5                      ; otherwise, bonus is 5
145+  AEF7 21 64 84         ld hl, string_endlevel_bonus1
146+  AEFA 11 91 84         ld de, string_endlevel_points1
147+  AEFD C9               ret
148+  AEFE
149+  AEFE              ;
150+  AEFE              ; Draws text shared by the game over and high score screens
151+  AEFE              ;
152+  AEFE              endlevel_commontext:
153+  AEFE CD 90 A8         call screen_setuptext       ; show scores
154+  AF01 CD EB C4         call scores_printscores     ; print the current scores
155+  AF04
156+  AF04 21 9C 83         ld hl,string_gameoverscreen_bestscores
157+  AF07 CD 57 85         call string_print
158+  AF0A
159+  AF0A 06 20            ld b,32
160+  AF0C 3E 45            ld a,69
161+  AF0E 11 C0 5A         ld de,22528+704                         ; attrs here
162+  AF11 CD BE A8         call screen_setcolours
163+  AF14
164+  AF14 C9               ret
165+  AF15
166+  AF15              ;
167+  AF15              ; Initialises the screen
168+  AF15              ;
169+  AF15              endlevel_init:
170+  AF15              ; We want a green screen.
171+  AF15 3E 21            ld a,33             ; white ink (7) on black paper (0),
172+  AF17                                      ; bright (64).
173+  AF17 CD 80 80         call utilities_clearscreen
174+  AF1A 32 8D 5C         ld (23693),a        ; set our screen colours.
175+  AF1D 3E 00            ld a,0              ; 2 is the code for red.
176+  AF1F D3 FE            out (254),a         ; write to port 254.
177+  AF21 C9               ret
# file closed: screen/endlevel.asm
 30   AF22                  include "screen\options.asm"
# file opened: screen/options.asm
  1+  AF22              ;
  2+  AF22              ; Show the options screen
  3+  AF22              ;
  4+  AF22              options_show:
  5+  AF22 CD BD AF         call options_init
  6+  AF25
  7+  AF25 21 D8 84         ld hl,string_options_title
  8+  AF28 CD 57 85         call string_print
  9+  AF2B 21 E2 84         ld hl,string_options_1player
 10+  AF2E CD 57 85         call string_print
 11+  AF31 21 F2 84         ld hl,string_options_2player
 12+  AF34 CD 57 85         call string_print
 13+  AF37 21 02 85         ld hl,string_options_keyboard
 14+  AF3A CD 57 85         call string_print
 15+  AF3D 21 10 85         ld hl,string_options_joystick
 16+  AF40 CD 57 85         call string_print
 17+  AF43 21 1E 85         ld hl,string_options_start
 18+  AF46 CD 57 85         call string_print
 19+  AF49 21 29 85         ld hl,string_options_vanity
 20+  AF4C CD 57 85         call string_print
 21+  AF4F
 22+  AF4F 3A 5F BD         ld a,(game_numberplayers)
 23+  AF52 FE 01            cp 1
 24+  AF54 C2 5D AF         jp nz,options_show0
 25+  AF57 11 CA 58         ld de,22528+202                         ; top row attrs here
 26+  AF5A C3 60 AF         jp options_show1
 27+  AF5D              options_show0:
 28+  AF5D 11 EA 58         ld de,22528+234                         ; top row attrs here
 29+  AF60              options_show1:
 30+  AF60 06 0D            ld b,13
 31+  AF62 3E C7            ld a,199
 32+  AF64 CD BE A8         call screen_setcolours                  ; highlight current player
 33+  AF67
 34+  AF67 3A 63 BD         ld a,(game_control)
 35+  AF6A FE 00            cp 0
 36+  AF6C C2 75 AF         jp nz,options_show6
 37+  AF6F 11 0A 59         ld de,22528+266                         ; top row attrs here
 38+  AF72 C3 78 AF         jp options_show7
 39+  AF75              options_show6:
 40+  AF75 11 2A 59         ld de,22528+298                         ; top row attrs here
 41+  AF78              options_show7:
 42+  AF78 06 0D            ld b,13
 43+  AF7A 3E C7            ld a,199
 44+  AF7C CD BE A8         call screen_setcolours                  ; highlight current control
 45+  AF7F              options_show8:
 46+  AF7F CD 9F 80         call utilities_readkey
 47+  AF82 FE 31            cp 49                                   ; was 1 pressed
 48+  AF84 C2 8F AF         jp nz,options_show2
 49+  AF87 21 5F BD         ld hl,game_numberplayers
 50+  AF8A 36 01            ld (hl),1
 51+  AF8C C3 22 AF         jp options_show
 52+  AF8F              options_show2:
 53+  AF8F FE 32            cp 50                                   ; was 2 pressed
 54+  AF91 C2 9C AF         jp nz,options_show3
 55+  AF94 21 5F BD         ld hl,game_numberplayers
 56+  AF97 36 02            ld (hl),2
 57+  AF99 C3 22 AF         jp options_show
 58+  AF9C              options_show3:
 59+  AF9C FE 33            cp 51                                   ; was 3 pressed
 60+  AF9E C2 A9 AF         jp nz,options_show4
 61+  AFA1 21 63 BD         ld hl,game_control
 62+  AFA4 36 00            ld (hl),0
 63+  AFA6 C3 22 AF         jp options_show
 64+  AFA9              options_show4:
 65+  AFA9 FE 34            cp 52                                   ; was 4 pressed
 66+  AFAB C2 B6 AF         jp nz,options_show5
 67+  AFAE 21 63 BD         ld hl,game_control
 68+  AFB1 36 01            ld (hl),1
 69+  AFB3 C3 22 AF         jp options_show
 70+  AFB6              options_show5:
 71+  AFB6 FE 35            cp 53                                   ; was 5 pressed
 72+  AFB8 C8               ret z                                   ; exit if so
 73+  AFB9 C3 7F AF         jp options_show8                         ; otherwise, jump to top
 74+  AFBC C9               ret
 75+  AFBD
 76+  AFBD              ;
 77+  AFBD              ; Initialise the options screen
 78+  AFBD              ;
 79+  AFBD              options_init:
 80+  AFBD 3E 47            ld a,71             ; white ink (7) on black paper (0),
 81+  AFBF                                      ; bright (64).
 82+  AFBF CD 80 80         call utilities_clearscreen
 83+  AFC2 32 8D 5C         ld (23693),a        ; set our screen colours.
 84+  AFC5 3E 00            ld a,0              ; 2 is the code for red.
 85+  AFC7 D3 FE            out (254),a         ; write to port 254.
 86+  AFC9
 87+  AFC9 C9               ret
 88+  AFCA C9               ret
# file closed: screen/options.asm
 31   AFCB
 32   AFCB                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  AFCB              sound_gemcollected:
  2+  AFCB 21 C8 00         ld hl,200 ; pitch.
  3+  AFCE 11 3E 00         ld de,62 ; duration.
  4+  AFD1 CD B5 03         call 949 ; ROM beeper routine.
  5+  AFD4 C9               ret
  6+  AFD5
  7+  AFD5              sound_pitchbend:
  8+  AFD5 21 F4 01         ld hl,500 ; starting pitch.
  9+  AFD8 06 FA            ld b,250 ; length of pitch bend.
 10+  AFDA              sound_pitchbend0:
 11+  AFDA C5                push bc
 12+  AFDB E5               push hl ; store pitch.
 13+  AFDC 11 01 00         ld de,1 ; very short duration.
 14+  AFDF CD B5 03         call 949 ; ROM beeper routine.
 15+  AFE2 E1               pop hl ; restore pitch.
 16+  AFE3 23               inc hl ; pitch going up.
 17+  AFE4 C1               pop bc
 18+  AFE5 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  AFE7 C9               ret
 20+  AFE8
 21+  AFE8              sound_rockfell:
 22+  AFE8 08               ex af,af'
 23+  AFE9 1E 32            ld e,50 ; repeat 250 times.
 24+  AFEB 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  AFEE D5           sound_rockfell2 push de
 26+  AFEF 06 20            ld b,32 ; length of step.
 27+  AFF1 C5           sound_rockfell0 push bc
 28+  AFF2 7E               ld a,(hl) ; next "random" number.
 29+  AFF3 23               inc hl ; pointer.
 30+  AFF4 E6 F8            and 248 ; we want a black border.
 31+  AFF6 D3 FE            out (254),a ; write to speaker.
 32+  AFF8 7B               ld a,e ; as e gets smaller...
 33+  AFF9 2F               cpl ; ...we increase the delay.
 34+  AFFA 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  AFFB 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  AFFD C1               pop bc
 37+  AFFE 10 F1            djnz sound_rockfell0 ; next step.
 38+  B000 D1               pop de
 39+  B001 7B               ld a,e
 40+  B002 D6 18            sub 24 ; size of step.
 41+  B004 FE 1E            cp 30 ; end of range.
 42+  B006 CA 17 B0         jp z,sound_rockfell5
 43+  B009 DA 17 B0         jp c, sound_rockfell5
 44+  B00C 5F               ld e,a
 45+  B00D 2F               cpl
 46+  B00E 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  B010 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  B012 3D               dec a
 49+  B013 20 F9            jr nz,sound_rockfell3
 50+  B015 18 D7            jr sound_rockfell2
 51+  B017              sound_rockfell5
 52+  B017 08               ex af,af'
 53+  B018 C9               ret
 54+  B019
# file closed: sound/sound.asm
 33   B019
 34   B019                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  B019              ; ###############################################################
  2+  B019              ; Data for level 1
  3+  B019              ; ###############################################################
  4+  B019              level01:
  5+  B019
  6+  B019                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  B019
  8+  B019 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  B01D 05 05 05 05
  8+  B021 05 05 05 05
  8+  B025 05 05 02 01
  8+  B029 01 01 03 05
  8+  B02D 05 05 05 05
  8+  B031 05 05 05 05
  8+  B035 05 05 00 00
  9+  B039 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  B03D 05 05 05 05
  9+  B041 05 05 05 05
  9+  B045 02 01 01 01
  9+  B049 01 01 01 01
  9+  B04D 03 05 05 05
  9+  B051 05 05 05 05
  9+  B055 05 05 00 00
 10+  B059 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  B05D 05 05 05 05
 10+  B061 05 05 02 01
 10+  B065 01 01 01 01
 10+  B069 01 01 01 01
 10+  B06D 01 01 03 05
 10+  B071 0D 0D 0D 0D
 10+  B075 0D 0D 00 00
 11+  B079 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  B07D 01 01 00 01
 11+  B081 01 01 01 01
 11+  B085 01 01 01 01
 11+  B089 01 01 01 01
 11+  B08D 01 01 01 03
 11+  B091 05 05 05 05
 11+  B095 05 05 00 00
 12+  B099 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  B09D 04 04 04 04
 12+  B0A1 04 04 01 01
 12+  B0A5 01 01 01 01
 12+  B0A9 01 01 01 01
 12+  B0AD 01 01 01 01
 12+  B0B1 01 01 01 01
 12+  B0B5 00 01 00 00
 13+  B0B9 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  B0BD 04 04 04 04
 13+  B0C1 04 04 04 04
 13+  B0C5 01 01 01 01
 13+  B0C9 01 01 01 01
 13+  B0CD 01 01 01 01
 13+  B0D1 00 00 00 00
 13+  B0D5 00 01 00 00
 14+  B0D9 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  B0DD 04 01 01 01
 14+  B0E1 01 01 04 04
 14+  B0E5 04 04 01 01
 14+  B0E9 01 01 01 01
 14+  B0ED 01 00 00 00
 14+  B0F1 00 01 01 01
 14+  B0F5 01 01 00 00
 15+  B0F9 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  B0FD 04 04 04 04
 15+  B101 04 01 04 04
 15+  B105 04 04 04 04
 15+  B109 04 04 00 00
 15+  B10D 00 00 04 04
 15+  B111 04 04 04 04
 15+  B115 04 01 00 00
 16+  B119 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  B11D 01 04 01 01
 16+  B121 01 01 04 04
 16+  B125 04 04 04 04
 16+  B129 04 04 00 04
 16+  B12D 04 04 04 04
 16+  B131 04 04 04 04
 16+  B135 04 01 00 00
 17+  B139 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  B13D 00 00 00 00
 17+  B141 00 04 04 04
 17+  B145 04 04 04 04
 17+  B149 04 04 00 04
 17+  B14D 04 04 04 04
 17+  B151 04 04 04 04
 17+  B155 04 01 00 00
 18+  B159 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  B15D 15 15 15 15
 18+  B161 15 01 04 04
 18+  B165 04 04 04 04
 18+  B169 04 04 00 04
 18+  B16D 04 04 04 04
 18+  B171 04 04 04 04
 18+  B175 04 01 00 00
 19+  B179 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B17D 00 00 00 00
 19+  B181 00 01 04 04
 19+  B185 04 04 04 04
 19+  B189 04 04 00 04
 19+  B18D 04 04 04 04
 19+  B191 04 00 00 00
 19+  B195 00 01 00 00
 20+  B199 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B19D 00 00 00 00
 20+  B1A1 00 01 04 04
 20+  B1A5 04 04 04 04
 20+  B1A9 04 04 00 04
 20+  B1AD 04 04 04 04
 20+  B1B1 04 00 04 04
 20+  B1B5 00 01 00 00
 21+  B1B9 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B1BD 06 06 06 06
 21+  B1C1 06 01 04 04
 21+  B1C5 04 04 04 04
 21+  B1C9 04 04 00 04
 21+  B1CD 04 04 04 04
 21+  B1D1 04 00 04 04
 21+  B1D5 00 01 00 00
 22+  B1D9 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B1DD 1A 1A 1A 1A
 22+  B1E1 1A 01 04 00
 22+  B1E5 00 00 00 00
 22+  B1E9 00 00 00 00
 22+  B1ED 00 00 00 00
 22+  B1F1 00 00 04 04
 22+  B1F5 00 01 00 00
 23+  B1F9 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B1FD 1A 1A 1A 1A
 23+  B201 1A 01 04 00
 23+  B205 04 04 04 04
 23+  B209 04 04 00 04
 23+  B20D 04 04 00 04
 23+  B211 04 04 04 04
 23+  B215 00 01 00 00
 24+  B219 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B21D 1A 1A 1A 1A
 24+  B221 1A 01 04 00
 24+  B225 04 04 04 04
 24+  B229 04 04 00 04
 24+  B22D 04 04 00 04
 24+  B231 04 04 04 04
 24+  B235 00 01 00 00
 25+  B239 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B23D 01 01 01 01
 25+  B241 01 01 04 00
 25+  B245 04 04 04 04
 25+  B249 04 04 00 04
 25+  B24D 04 04 00 04
 25+  B251 04 04 04 04
 25+  B255 00 01 00 00
 26+  B259 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B25D 04 04 04 04
 26+  B261 04 04 04 00
 26+  B265 04 04 04 04
 26+  B269 04 04 00 04
 26+  B26D 04 04 00 00
 26+  B271 00 00 04 04
 26+  B275 04 01 00 00
 27+  B279 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B27D 04 04 00 00
 27+  B281 00 00 00 00
 27+  B285 04 04 04 04
 27+  B289 04 04 00 04
 27+  B28D 04 04 04 04
 27+  B291 04 00 04 04
 27+  B295 04 01 00 00
 28+  B299 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B29D 04 04 00 04
 28+  B2A1 04 04 04 04
 28+  B2A5 04 04 04 04
 28+  B2A9 04 04 00 04
 28+  B2AD 04 04 04 04
 28+  B2B1 04 00 04 04
 28+  B2B5 04 01 00 00
 29+  B2B9 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B2BD 04 04 00 04
 29+  B2C1 04 04 01 01
 29+  B2C5 01 01 01 01
 29+  B2C9 01 01 01 01
 29+  B2CD 01 01 01 01
 29+  B2D1 04 00 04 04
 29+  B2D5 04 01 00 00
 30+  B2D9 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B2DD 04 04 00 04
 30+  B2E1 04 04 01 00
 30+  B2E5 00 00 00 00
 30+  B2E9 00 00 00 00
 30+  B2ED 00 00 00 01
 30+  B2F1 04 00 04 04
 30+  B2F5 04 01 00 00
 31+  B2F9 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B2FD 04 04 00 04
 31+  B301 04 04 01 00
 31+  B305 00 00 00 00
 31+  B309 00 00 00 00
 31+  B30D 00 00 00 01
 31+  B311 04 00 04 04
 31+  B315 04 01 00 00
 32+  B319 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B31D 04 04 00 04
 32+  B321 04 04 01 00
 32+  B325 00 00 00 00
 32+  B329 00 00 00 00
 32+  B32D 00 00 00 01
 32+  B331 04 00 04 04
 32+  B335 04 01 00 00
 33+  B339 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B33D 04 04 00 04
 33+  B341 04 04 04 00
 33+  B345 00 00 00 00
 33+  B349 00 00 00 00
 33+  B34D 00 00 00 04
 33+  B351 04 04 04 04
 33+  B355 04 01 00 00
 34+  B359 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B35D 04 04 04 04
 34+  B361 04 04 01 00
 34+  B365 00 00 00 00
 34+  B369 00 00 00 00
 34+  B36D 00 00 00 01
 34+  B371 04 04 04 04
 34+  B375 04 01 00 00
 35+  B379 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B37D 04 04 04 04
 35+  B381 04 04 01 00
 35+  B385 00 00 01 00
 35+  B389 00 00 00 01
 35+  B38D 00 00 00 01
 35+  B391 04 04 04 04
 35+  B395 04 01 00 00
 36+  B399 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B39D 01 01 01 01
 36+  B3A1 01 01 01 01
 36+  B3A5 01 01 01 01
 36+  B3A9 01 01 01 01
 36+  B3AD 01 01 01 01
 36+  B3B1 01 01 01 01
 36+  B3B5 01 01 00 00
 37+  B3B9
 38+  B3B9              ; ###############################################################
 39+  B3B9              ; Object data: horiz, vert, state, memh, meml
 40+  B3B9              ; ###############################################################
 41+  B3B9              level01rocks:
 42+  B3B9 09 04 00 00      defb 9,4,0,0,0
 42+  B3BD 00
 43+  B3BE 0C 07 00 00      defb 12,7,0,0,0
 43+  B3C2 00
 44+  B3C3 10 07 00 00      defb 16,7,0,0,0
 44+  B3C7 00
 45+  B3C8 0B 08 00 00      defb 11,8,0,0,0
 45+  B3CC 00
 46+  B3CD 0A 0A 00 00      defb 10,10,0,0,0
 46+  B3D1 00
 47+  B3D2 0C 0A 00 00      defb 12,10,0,0,0
 47+  B3D6 00
 48+  B3D7 0D 09 00 00      defb 13,9,0,0,0
 48+  B3DB 00
 49+  B3DC 0E 08 00 00      defb 14,8,0,0,0
 49+  B3E0 00
 50+  B3E1 0F 0B 00 00      defb 15,11,0,0,0
 50+  B3E5 00
 51+  B3E6 0B 0C 00 00      defb 11,12,0,0,0
 51+  B3EA 00
 52+  B3EB 11 0C 00 00      defb 17,12,0,0,0
 52+  B3EF 00
 53+  B3F0 13 08 00 00      defb 19,8,0,0,0
 53+  B3F4 00
 54+  B3F5 16 09 00 00      defb 22,9,0,0,0
 54+  B3F9 00
 55+  B3FA 13 0A 00 00      defb 19,10,0,0,0
 55+  B3FE 00
 56+  B3FF 15 0A 00 00      defb 21,10,0,0,0
 56+  B403 00
 57+  B404 15 0C 00 00      defb 21,12,0,0,0
 57+  B408 00
 58+  B409 16 0C 00 00      defb 22,12,0,0,0
 58+  B40D 00
 59+  B40E 18 0A 00 00      defb 24,10,0,0,0
 59+  B412 00
 60+  B413 19 09 00 00      defb 25,9,0,0,0
 60+  B417 00
 61+  B418 1C 09 00 00      defb 28,9,0,0,0
 61+  B41C 00
 62+  B41D 1B 0C 00 00      defb 27,12,0,0,0
 62+  B421 00
 63+  B422 1A 0D 00 00      defb 26,13,0,0,0
 63+  B426 00
 64+  B427 19 0E 00 00      defb 25,14,0,0,0
 64+  B42B 00
 65+  B42C 19 10 00 00      defb 25,16,0,0,0
 65+  B430 00
 66+  B431 1A 11 00 00      defb 26,17,0,0,0
 66+  B435 00
 67+  B436 1B 11 00 00      defb 27,17,0,0,0
 67+  B43A 00
 68+  B43B 1C 12 00 00      defb 28,18,0,0,0
 68+  B43F 00
 69+  B440 1A 13 00 00      defb 26,19,0,0,0
 69+  B444 00
 70+  B445 1B 15 00 00      defb 27,21,0,0,0
 70+  B449 00
 71+  B44A 1A 17 00 00      defb 26,23,0,0,0
 71+  B44E 00
 72+  B44F 1B 18 00 00      defb 27,24,0,0,0
 72+  B453 00
 73+  B454 19 18 00 00      defb 25,24,0,0,0
 73+  B458 00
 74+  B459 18 17 00 00      defb 24,23,0,0,0
 74+  B45D 00
 75+  B45E 13 14 00 00      defb 19,20,0,0,0
 75+  B462 00
 76+  B463 14 12 00 00      defb 20,18,0,0,0
 76+  B467 00
 77+  B468 14 10 00 00      defb 20,16,0,0,0
 77+  B46C 00
 78+  B46D 15 10 00 00      defb 21,16,0,0,0
 78+  B471 00
 79+  B472 16 12 00 00      defb 22,18,0,0,0
 79+  B476 00
 80+  B477 11 14 00 00      defb 17,20,0,0,0
 80+  B47B 00
 81+  B47C 0D 11 00 00      defb 13,17,0,0,0
 81+  B480 00
 82+  B481 0C 13 00 00      defb 12,19,0,0,0
 82+  B485 00
 83+  B486 0B 13 00 00      defb 11,19,0,0,0
 83+  B48A 00
 84+  B48B 0A 11 00 00      defb 10,17,0,0,0
 84+  B48F 00
 85+  B490 05 12 00 00      defb 5,18,0,0,0
 85+  B494 00
 86+  B495 07 16 00 00      defb 7,22,0,0,0
 86+  B499 00
 87+  B49A 09 16 00 00      defb 9,22,0,0,0
 87+  B49E 00
 88+  B49F 07 18 00 00      defb 7,24,0,0,0
 88+  B4A3 00
 89+  B4A4 05 18 00 00      defb 5,24,0,0,0
 89+  B4A8 00
 90+  B4A9 06 19 00 00      defb 6,25,0,0,0
 90+  B4AD 00
 91+  B4AE 08 19 00 00      defb 8,25,0,0,0
 91+  B4B2 00
 92+  B4B3 04 17 00 00      defb 4,23,0,0,0
 92+  B4B7 00
 93+  B4B8 FF               defb 255
 94+  B4B9
 95+  B4B9              level01missiles:
 96+  B4B9 0B 17 00 00      defb 11,23,0,0,0
 96+  B4BD 00
 97+  B4BE 0B 16 00 00      defb 11,22,0,0,0
 97+  B4C2 00
 98+  B4C3 0C 17 00 00      defb 12,23,0,0,0
 98+  B4C7 00
 99+  B4C8 0C 16 00 00      defb 12,22,0,0,0
 99+  B4CC 00
100+  B4CD 0D 17 00 00      defb 13,23,0,0,0
100+  B4D1 00
101+  B4D2 0D 16 00 00      defb 13,22,0,0,0
101+  B4D6 00
102+  B4D7 0E 17 00 00      defb 14,23,0,0,0
102+  B4DB 00
103+  B4DC 0E 16 00 00      defb 14,22,0,0,0
103+  B4E0 00
104+  B4E1 0F 17 00 00      defb 15,23,0,0,0
104+  B4E5 00
105+  B4E6 0F 16 00 00      defb 15,22,0,0,0
105+  B4EA 00
106+  B4EB 10 17 00 00      defb 16,23,0,0,0
106+  B4EF 00
107+  B4F0 10 16 00 00      defb 16,22,0,0,0
107+  B4F4 00
108+  B4F5 11 17 00 00      defb 17,23,0,0,0
108+  B4F9 00
109+  B4FA 11 16 00 00      defb 17,22,0,0,0
109+  B4FE 00
110+  B4FF 12 17 00 00      defb 18,23,0,0,0
110+  B503 00
111+  B504 12 16 00 00      defb 18,22,0,0,0
111+  B508 00
112+  B509 13 17 00 00      defb 19,23,0,0,0
112+  B50D 00
113+  B50E 13 16 00 00      defb 19,22,0,0,0
113+  B512 00
114+  B513 14 17 00 00      defb 20,23,0,0,0
114+  B517 00
115+  B518 14 16 00 00      defb 20,22,0,0,0
115+  B51C 00
116+  B51D 15 17 00 00      defb 21,23,0,0,0
116+  B521 00
117+  B522 15 16 00 00      defb 21,22,0,0,0
117+  B526 00
118+  B527 16 17 00 00      defb 22,23,0,0,0
118+  B52B 00
119+  B52C 16 16 00 00      defb 22,22,0,0,0
119+  B530 00
120+  B531 FF               defb 255
121+  B532
122+  B532              ;
123+  B532              ; Diamonds: x,y,state,mem1+mem2
124+  B532              ;
125+  B532              level01diamonds:
126+  B532 0C 1B 00 00      defb 12,27,0,0,0
126+  B536 00
127+  B537 10 1B 00 00      defb 16,27,0,0,0
127+  B53B 00
128+  B53C 15 1B 00 00      defb 21,27,0,0,0
128+  B540 00
129+  B541 FF               defb 255
130+  B542
131+  B542              level01gems:
132+  B542 12 14 00 00      defb 18,20,0,0,0
132+  B546 00
133+  B547 06 18 00 00      defb 6,24,0,0,0
133+  B54B 00
134+  B54C 19 17 00 00      defb 25,23,0,0,0
134+  B550 00
135+  B551 1C 11 00 00      defb 28,17,0,0,0
135+  B555 00
136+  B556 FF               defb 255
137+  B557              ;
138+  B557              ; Score area colours
139+  B557              ;
140+  B557              score_colours:
141+  B557 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  B55B 47 47 47 47
141+  B55F 47 47 47 42
141+  B563 43 43 43 43
141+  B567 43 43 43 43
141+  B56B 42 47 47 47
141+  B56F 47 47 47 47
141+  B573 47 47 47 47
142+  B577 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  B57B 47 47 47 47
142+  B57F 47 47 47 46
142+  B583 46 46 46 46
142+  B587 46 46 46 46
142+  B58B 46 47 47 47
142+  B58F 47 47 47 47
142+  B593 47 47 47 47
143+  B597
144+  B597              high_score_colours:
145+  B597 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  B59B 42 42 47 47
145+  B59F 47 47 47 47
145+  B5A3 43 43 43 47
145+  B5A7 47 47 47 47
145+  B5AB 47 46 46 46
145+  B5AF 47 47 47 47
145+  B5B3 47 47 00 00
# file closed: leveldata/level01.asm
 35   B5B7                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B5B7              ; Tiles graphics.
  2+  B5B7              sprites:
  3+  B5B7 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B5BB 00 00 00 00
  4+  B5BF FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B5C3 FF FF FF FF
  5+  B5C7 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B5CB 1F 3F 7F FF
  6+  B5CF 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B5D3 F8 FC FE FF
  7+  B5D7 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B5DB 55 AA 55 AA
  8+  B5DF 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B5E3 00 00 00 00
  9+  B5E7 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 6, slime block
  9+  B5EB 00 00 00 00
 10+  B5EF 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  B5F3 00 00 00 00
 11+  B5F7 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B5FB F1 72 34 18
 12+  B5FF 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B603 FE FE FF 7E
 13+  B607 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B60B FE FF 7E 3C
 14+  B60F 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B613 00 00 FF FF
 15+  B617 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  B61B FF 42 24 18
 16+  B61F 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B623 00 00 00 00
 17+  B627 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B62B 00 3C 5A 34
 18+  B62F FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  B633 FD FE FD FE
 19+  B637 F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  B63B F4 F8 F4 F8
 20+  B63F D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  B643 D0 E0 D0 E0
 21+  B647 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  B64B 40 80 40 80
 22+  B64F 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  B653 ED 00 00 00
 23+  B657 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  B65B FF 7E 3C 18
 24+  B65F FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  B663 00 00 00 00
 25+  B667 FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  B66B 00 00 00 00
 26+  B66F F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  B673 00 00 00 00
 27+  B677 C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  B67B 00 00 00 00
 28+  B67F 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  B683 00 00 00 00
 29+  B687 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  B68B FF FF FF FF
 30+  B68F 00 00 00 66  	defb    0,  0,  0,102,  0,  0,  0,  0     ; 27, bullet
 30+  B693 00 00 00 00
 31+  B697
 32+  B697
 33+  B697              sprite_attrs:
 34+  B697 46               defb    070 ; 0, space
 35+  B698 4D               defb    077 ; 1, cyan block
 36+  B699 4D               defb    077 ; 2, slope left
 37+  B69A 4D               defb    077 ; 3, slope right
 38+  B69B 46               defb    070 ; 4, dirt
 39+  B69C 4E               defb    078 ; 5, sky
 40+  B69D 66               defb    102 ; 6, slime
 41+  B69E 42               defb    066 ; 7, trapdoor
 42+  B69F 46               defb    070 ; 8, diamond
 43+  B6A0 42               defb    066 ; 9, rock
 44+  B6A1 42               defb    066 ; 10, rock 2
 45+  B6A2 49           	defb    073 ; 11, sky, trapdoor
 46+  B6A3 43           	defb    067 ; 12, missile
 47+  B6A4 4A               defb    074 ; 13, sky, red ink (tank)
 48+  B6A5 46               defb    070 ; 14, gem
 49+  B6A6 4D               defb    077 ; 15, damaged mountain
 50+  B6A7 4D               defb    077 ; 16, damaged mountain 2
 51+  B6A8 4D               defb    077 ; 17, damaged mountain 3
 52+  B6A9 4D               defb    077 ; 18, damaged mountain 4
 53+  B6AA 00           	defb 	000 ; 19, tank missile (not used
 54+  B6AB 43           	defb    067 ; 20, missile active
 55+  B6AC 42           	defb	066	; 21, the pit 1
 56+  B6AD 42           	defb	066	; 22, the pit 2
 57+  B6AE 42           	defb	066	; 23, the pit 3
 58+  B6AF 42           	defb	066	; 24, the pit 4
 59+  B6B0 42           	defb	066	; 25, the pit 5
 60+  B6B1 64           	defb    100 ; 26, slime, green on green
 61+  B6B2 46           	defb 	070 ; 27, bullet
 62+  B6B3
 63+  B6B3
 64+  B6B3              player_sprite:
 65+  B6B3 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 65+  B6B7 38 3D C3 80
 66+  B6BB 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 66+  B6BF 3C 1C 16 32
 67+  B6C3 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 67+  B6C7 3C 38 68 4C
 68+  B6CB 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 68+  B6CF 1C BC C3 01
 69+  B6D3 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 69+  B6D7 3C 3C 64 0C
 70+  B6DB 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 70+  B6DF 3C 3C 26 30
 71+  B6E3 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 71+  B6E7 1E 5C FD 5F
 72+  B6EB 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 72+  B6EF 4F 8F 19 03
 73+  B6F3 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 73+  B6F7 F2 F1 98 C0
 74+  B6FB FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 74+  B6FF 48 08 14 2A
 75+  B703 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 75+  B707 38 78 44 C3
 76+  B70B 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 76+  B70F 1C 1E 22 C3
 77+  B713 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 77+  B717 6F 45 E1 9B
 78+  B71B 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 78+  B71F F6 A2 87 D9
 79+  B723
 80+  B723              ;
 81+  B723              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 82+  B723              ;
 83+  B723              ship_sprite:
 84+  B723 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 84+  B727 03 1F 7F FF
 85+  B72B 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 85+  B72F FF FF FF FF
 86+  B733 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 86+  B737 FF FF FF FF
 87+  B73B 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 87+  B73F C0 F8 FE FF
 88+  B743 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 88+  B747 03 03 02 07
 89+  B74B 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 89+  B74F FF 0F 07 83
 90+  B753 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 90+  B757 FF 10 20 C1
 91+  B75B 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 91+  B75F C0 C0 40 E0
 92+  B763 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 92+  B767 03 03 02 07
 93+  B76B F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 93+  B76F FF 08 04 83
 94+  B773 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 94+  B777 FF F0 E0 C1
 95+  B77B CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 95+  B77F C0 C0 40 E0
 96+  B783
 97+  B783              ;
 98+  B783              ;  First 8 frames are tank, last frame is the gun barrel
 99+  B783              ;
100+  B783              tank_sprite:
101+  B783 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
101+  B787 7F 00 00 00
102+  B78B 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
102+  B78F FE FF 7F 40
103+  B793 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
103+  B797 03 FF FF 01
104+  B79B 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
104+  B79F E0 C0 00 00
105+  B7A3 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
105+  B7A7 F7 E1 7F 3F
106+  B7AB FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
106+  B7AF 54 16 FF FF
107+  B7B3 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
107+  B7B7 9B A8 FF FF
108+  B7BB FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
108+  B7BF 9F AF FE FC
109+  B7C3 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
109+  B7C7 1F 00 00 00
110+  B7CB
111+  B7CB              monster_sprite:
112+  B7CB 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  B7CF 0B D0 16 68
113+  B7D3 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
113+  B7D7 35 AC 7F FE
114+  B7DB FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
114+  B7DF 8F F1 8F F1
115+  B7E3 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
115+  B7E7 18 18 00 00
116+  B7EB 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
116+  B7EF 0B D0 16 68
117+  B7F3 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
117+  B7F7 F5 AF FF FF
118+  B7FB BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
118+  B7FF 0F F0 0F F0
119+  B803 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
119+  B807 00 00 00 00
120+  B80B
121+  B80B              robot_sprite:
122+  B80B 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
122+  B80F CE 12 22 66
123+  B813 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
123+  B817 4E 12 24 6C
124+  B81B 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
124+  B81F 4E 32 63 03
125+  B823 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
125+  B827 CE 0A 09 1B
126+  B82B 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
126+  B82F 73 48 44 66
127+  B833 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
127+  B837 72 48 24 36
128+  B83B 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
128+  B83F 72 4C C6 C0
129+  B843 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
129+  B847 73 50 90 D8
130+  B84B 38 A9 BA 7C  	defb     56,169,186,124, 56, 42, 38, 96     ; dead 1
130+  B84F 38 2A 26 60
131+  B853 1C 95 5D 3E  	defb	 28,149, 93, 62, 28, 84,100,  6		; dead 2
131+  B857 1C 54 64 06
# file closed: graphics/graphics.asm
 36   B85B
 37   B85B                  include "game\control.asm"
# file opened: game/control.asm
  1+  B85B              ;
  2+  B85B              ; Check the preferred input method then move
  3+  B85B              ;
  4+  B85B              control_input:
  5+  B85B 3A A2 BD         ld a,(player+11)    ; first, check if player is dying
  6+  B85E FE 04            cp 4                ; is the player falling
  7+  B860 CC 2A B9         call z, control_fall
  8+  B863 FE 05            cp 5                ; is the player fighting
  9+  B865 CC 17 B9         call z, control_fight
 10+  B868 3A A2 BD         ld a,(player+11)    ; first, check if player is dying
 11+  B86B FE 00            cp 0
 12+  B86D C0               ret nz               ; if so, can't move
 13+  B86E 3A 9C BD         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  B871 FE 00            cp 0
 15+  B873 CA 7A B8         jp z, control_input0
 16+  B876 CD 08 BA         call control_automove
 17+  B879 C9               ret
 18+  B87A              control_input0:
 19+  B87A 3A 9D BD         ld a,(player+6)      ; next, check if the player is digging
 20+  B87D FE 00            cp 0
 21+  B87F CA 86 B8         jp z, control_input1
 22+  B882 CD 46 B9         call control_dig
 23+  B885 C9               ret
 24+  B886              control_input1:
 25+  B886 3A 63 BD         ld a,(game_control)
 26+  B889 FE 00            cp 0                ; is this keyboard
 27+  B88B C2 92 B8         jp nz,control_input2
 28+  B88E CD 96 B8         call control_keyboard
 29+  B891 C9               ret
 30+  B892              control_input2:
 31+  B892                  ; do joystick
 32+  B892 CD DC B8         call control_joystick
 33+  B895 C9               ret
 34+  B896
 35+  B896              ;
 36+  B896              ; Check the keyboard
 37+  B896              ;
 38+  B896              control_keyboard:
 39+  B896 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 40+  B899 ED 78            in a,(c)            ; read keyboard.
 41+  B89B 47               ld b,a              ; store result in b register.
 42+  B89C CB 18            rr b                ; check outermost key (q).
 43+  B89E D2 C8 B8         jp nc,control_keyboard1
 44+  B8A1 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 45+  B8A4 ED 78            in a,(c)            ; read keyboard.
 46+  B8A6 47               ld b,a              ; store result in b register.
 47+  B8A7 CB 18            rr b                ; check outermost key (a).
 48+  B8A9 D2 CC B8         jp nc,control_keyboard2
 49+  B8AC 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 50+  B8AF ED 78            in a,(c)            ; read keyboard.
 51+  B8B1 47               ld b,a              ; store result in b register.
 52+  B8B2 CB 18            rr b                ; check outermost key (p).
 53+  B8B4 D2 D0 B8         jp nc,control_keyboard3
 54+  B8B7 CB 18            rr b                ; check next key.
 55+  B8B9 D2 D4 B8         jp nc,control_keyboard4
 56+  B8BC 01 FE 7F         ld bc,32766         ; port for keyboard row b-space.
 57+  B8BF ED 78            in a,(c)            ; read keyboard.
 58+  B8C1 47               ld b,a              ; store result in b register.
 59+  B8C2 CB 18            rr b                ; check outermost key (space).
 60+  B8C4 D2 D8 B8         jp nc,control_keyboard5
 61+  B8C7 C9               ret
 62+  B8C8              control_keyboard1:
 63+  B8C8 CD 51 BA         call control_pl_moveup         ; player up.
 64+  B8CB C9               ret
 65+  B8CC              control_keyboard2:
 66+  B8CC CD 7E BA         call control_pl_movedown       ; player down.
 67+  B8CF C9               ret
 68+  B8D0              control_keyboard3:
 69+  B8D0 CD DA BA         call control_pl_moveright       ; player left.
 70+  B8D3 C9               ret
 71+  B8D4              control_keyboard4:
 72+  B8D4 CD AA BA         call control_pl_moveleft       ; player right.
 73+  B8D7 C9               ret
 74+  B8D8              control_keyboard5:
 75+  B8D8 CD 08 BB         call control_pl_fire       ; player fire.
 76+  B8DB C9               ret
 77+  B8DC
 78+  B8DC              ;
 79+  B8DC              ; Check the joystick
 80+  B8DC              ;
 81+  B8DC              control_joystick:
 82+  B8DC 01 1F 00         ld bc,31                        ; Kempston joystick port.
 83+  B8DF ED 78            in a,(c)                        ; read input.
 84+  B8E1 E6 02            and 2                           ; check "left" bit.
 85+  B8E3 C2 0B B9         jp nz,control_joystick3       ; move left.
 86+  B8E6 ED 78            in a,(c)                        ; read input.
 87+  B8E8 E6 01            and 1                           ; test "right" bit.
 88+  B8EA C2 0F B9         jp nz,control_joystick4       ; move right.
 89+  B8ED ED 78            in a,(c)                        ; read input.
 90+  B8EF E6 08            and 8                           ; check "up" bit.
 91+  B8F1 C2 03 B9         jp nz,control_joystick1       ; move up.
 92+  B8F4 ED 78            in a,(c)                        ; read input.
 93+  B8F6 E6 04            and 4                           ; check "down" bit.
 94+  B8F8 C2 07 B9         jp nz,control_joystick2       ; move down.
 95+  B8FB ED 78            in a,(c)                        ; read input.
 96+  B8FD E6 10            and 16                          ; try the fire bit.
 97+  B8FF C2 13 B9         jp nz,control_joystick5       ; fire pressed.
 98+  B902 C9               ret
 99+  B903              control_joystick1:
100+  B903 CD 51 BA         call control_pl_moveup         ; player up.
101+  B906 C9               ret
102+  B907              control_joystick2:
103+  B907 CD 7E BA         call control_pl_movedown       ; player down.
104+  B90A C9               ret
105+  B90B              control_joystick3:
106+  B90B CD AA BA         call control_pl_moveleft       ; player left.
107+  B90E C9               ret
108+  B90F              control_joystick4:
109+  B90F CD DA BA         call control_pl_moveright       ; player right.
110+  B912 C9               ret
111+  B913              control_joystick5:
112+  B913 CD 08 BB         call control_pl_fire
113+  B916 C9               ret
114+  B917
115+  B917              ;
116+  B917              ; Fights the player - just flips the players anim frame
117+  B917              ;
118+  B917              control_fight:
119+  B917 3A 9A BD         ld a,(player+3)             ; load the frame
120+  B91A FE 0C            cp 12                       ; flip between 12 and 13
121+  B91C CA 24 B9         jp z,control_fight0
122+  B91F 3E 0C            ld a,12
123+  B921 C3 26 B9         jp control_fight1
124+  B924              control_fight0:
125+  B924 3E 0D            ld a,13
126+  B926              control_fight1:
127+  B926 32 9A BD         ld (player+3),a           ; save back
128+  B929 C9               ret
129+  B92A
130+  B92A              ;
131+  B92A              ; Falls the player
132+  B92A              ;
133+  B92A              control_fall:
134+  B92A ED 4B 97 BD      ld bc,(player)              ; get coords
135+  B92E 0C               inc c
136+  B92F ED 43 97 BD      ld (player),bc
137+  B933 3A 9A BD         ld a,(player+3)             ; load the frame
138+  B936 FE 03            cp 3                       ; flip between 3 and 0
139+  B938 C2 40 B9         jp nz, control_fall0
140+  B93B 3E 00            ld a,0
141+  B93D C3 42 B9         jp control_fall1
142+  B940              control_fall0:
143+  B940 3E 03            ld a,3
144+  B942              control_fall1:
145+  B942 32 9A BD         ld (player+3),a           ; save back
146+  B945 C9               ret
147+  B946
148+  B946              ;
149+  B946              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
150+  B946              ;
151+  B946              control_dig:
152+  B946 ED 4B 97 BD      ld bc,(player)      ; load the current coords into bc
153+  B94A C5               push bc
154+  B94B 3A 99 BD         ld a,(player+2)     ; get the direction
155+  B94E FE 01            cp 1                ; left
156+  B950 CA 68 B9         jp z,control_dig0
157+  B953 FE 02            cp 2                ; right
158+  B955 CA 7D B9         jp z,control_dig1
159+  B958 FE 03            cp 3                ; down
160+  B95A CA A1 B9         jp z,control_dig5
161+  B95D FE 00            cp 0                ; up
162+  B95F CA 91 B9         jp z,control_dig4
163+  B962 21 9D BD         ld hl,player+6
164+  B965 36 00            ld (hl),0           ; turn off digging
165+  B967 C9               ret                 ; return
166+  B968              control_dig0:           ; going left
167+  B968 CD 22 AB         call sprites_scadd  ; get the current coord
168+  B96B 62 6B            ld hl,de
169+  B96D 2B               dec hl              ; move one left
170+  B96E C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
171+  B96F 78               ld a,b
172+  B970 06 08            ld b,8
173+  B972 90               sub b
174+  B973 47               ld b,a
175+  B974 79               ld a,c
176+  B975 0E 08            ld c,8
177+  B977 91               sub c
178+  B978 4F               ld c,a
179+  B979 C5               push bc
180+  B97A C3 AA B9         jp control_dig2
181+  B97D              control_dig1:
182+  B97D CD 22 AB         call sprites_scadd  ; get the current coord
183+  B980 62 6B            ld hl,de
184+  B982 23               inc hl              ; move one right
185+  B983 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
186+  B984 3E 08            ld a,8
187+  B986 80               add a,b
188+  B987 47               ld b,a
189+  B988 79               ld a,c
190+  B989 0E 08            ld c,8
191+  B98B 91               sub c
192+  B98C 4F               ld c,a
193+  B98D C5               push bc
194+  B98E C3 AA B9         jp control_dig2
195+  B991              control_dig4:
196+  B991 CD 22 AB         call sprites_scadd  ; get the current coord
197+  B994 62 6B            ld hl,de
198+  B996 11 20 00         ld de,32
199+  B999 ED 52            sbc hl,de             ; move one up
200+  B99B C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
201+  B99C 0D               dec c
202+  B99D C5               push bc
203+  B99E C3 C2 B9         jp control_dig6
204+  B9A1              control_dig5:
205+  B9A1 CD 22 AB         call sprites_scadd  ; get the current coord
206+  B9A4 62 6B            ld hl,de
207+  B9A6 24               inc h              ; move one down
208+  B9A7                                     ; not bothered about working out bc here, since rock will never fall if digging down
209+  B9A7 C3 AA B9         jp control_dig2
210+  B9AA              ; Normal (not up) digging
211+  B9AA              control_dig2:
212+  B9AA 3A 9F BD         ld a,(player+8)     ; get the number of rows we need to overwrite
213+  B9AD 47               ld b,a              ; rows to copy over
214+  B9AE E5               push hl             ; store the memory location of the first row for later
215+  B9AF              control_dig3:
216+  B9AF CD F1 B9         call control_getpixelrow
217+  B9B2 77               ld (hl),a           ; load contents into row
218+  B9B3 11 20 00         ld de,32
219+  B9B6 19               add hl,de           ; move to next row
220+  B9B7 10 F6            djnz control_dig3
221+  B9B9 E1               pop hl              ; get the original memory location back
222+  B9BA 11 20 00         ld de,32
223+  B9BD ED 52            sbc hl,de           ; move to above row, ready for checking for rock
224+  B9BF C3 D8 B9         jp control_dig10
225+  B9C2              ; Special case for going up
226+  B9C2              control_dig6:
227+  B9C2 3A 9F BD         ld a,(player+8)     ; get the number of rows we need to overwrite
228+  B9C5 47               ld b,a              ; rows to copy over
229+  B9C6              control_dig7:
230+  B9C6 CD F1 B9         call control_getpixelrow
231+  B9C9              control_dig12:
232+  B9C9 77               ld (hl),a           ; load empty into row
233+  B9CA 11 20 00         ld de,32
234+  B9CD ED 52            sbc hl,de           ; move up to next row
235+  B9CF 0D               dec c               ; decrease c to track rows
236+  B9D0 10 F4            djnz control_dig7
237+  B9D2 79               ld a,c
238+  B9D3 D6 07            sub 7
239+  B9D5 C1               pop bc
240+  B9D6 4F               ld c,a
241+  B9D7 C5               push bc             ; store the decreased c coord
242+  B9D8              control_dig10:
243+  B9D8 DD 21 9E BD      ld ix,player+7
244+  B9DC DD 7E 00         ld a,(ix)     ; get the dig frame number
245+  B9DF 3D               dec a
246+  B9E0 DD 77 00         ld (ix),a
247+  B9E3                  ; call the check for rocks above the removed dirt
248+  B9E3 DD 21 9D BD      ld ix,player+6
249+  B9E7 DD 7E 00         ld a,(ix)     ; get the dig state
250+  B9EA FE 00            cp 0
251+  B9EC C1               pop bc
252+  B9ED CC 06 C3         call z, rocks_checkforfalling ; make the check if we're no longer digging
253+  B9F0 C9               ret
254+  B9F1
255+  B9F1              ;
256+  B9F1              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
257+  B9F1              ; Inputs:
258+  B9F1              ; hl - memory of pixel row
259+  B9F1              ; Outputs:
260+  B9F1              ; a - modified row to write
261+  B9F1              ;
262+  B9F1              control_getpixelrow:
263+  B9F1 3A 9E BD         ld a,(player+7)     ; get the dig frame number
264+  B9F4 FE 00            cp 0                ; is this the last dig
265+  B9F6 CA FD B9         jp z,control_getpixelrow1
266+  B9F9 7E               ld a,(hl)           ; if not, xor with 255 to flip it
267+  B9FA EE FF            xor 255
268+  B9FC C9               ret
269+  B9FD              control_getpixelrow1:
270+  B9FD DD 21 9D BD      ld ix,player+6
271+  BA01 DD 36 00 00      ld (ix),0           ; turn off digging
272+  BA05 3E 00            ld a,0              ; if it is, load with empty
273+  BA07 C9               ret
274+  BA08
275+  BA08              ;
276+  BA08              ; Auto move the player until pixels is zero
277+  BA08              ;
278+  BA08              control_automove:
279+  BA08 5F               ld e,a              ; store the number of pixels left to move in e
280+  BA09 ED 4B 97 BD      ld bc,(player)      ; load the current coords into bc
281+  BA0D 21 99 BD         ld hl,player+2      ; get the direction
282+  BA10 7E               ld a,(hl)
283+  BA11 FE 03            cp 3                ; down
284+  BA13 CA 27 BA         jp z,control_automove3  ; don't need to do anything
285+  BA16 FE 00            cp 0                ; going up
286+  BA18 CA 33 BA         jp z,control_automove2
287+  BA1B FE 01            cp 1                ; going left?
288+  BA1D CA 3F BA         jp z,control_automove0
289+  BA20 78               ld a,b
290+  BA21 3C               inc a               ; if we're going right, increment a twice for two pixels
291+  BA22 3C               inc a
292+  BA23 47               ld b,a
293+  BA24 C3 43 BA         jp control_automove1
294+  BA27              control_automove3:
295+  BA27 79               ld a,c
296+  BA28 3C               inc a
297+  BA29 3C               inc a               ; if we're going down, increment twice
298+  BA2A 4F               ld c,a
299+  BA2B FE 90            cp 144
300+  BA2D CC 1E BB         call z, control_scroll_down
301+  BA30 C3 43 BA         jp control_automove1
302+  BA33              control_automove2:
303+  BA33 79               ld a,c
304+  BA34 3D               dec a
305+  BA35 3D               dec a               ; if we're going up, decrement twice
306+  BA36 4F               ld c,a
307+  BA37 FE 60            cp 96
308+  BA39 CC 2B BB         call z, control_scroll_up
309+  BA3C C3 43 BA         jp control_automove1
310+  BA3F              control_automove0:
311+  BA3F 78               ld a,b
312+  BA40 3D               dec a               ; if we're going left, decrement a twice
313+  BA41 3D               dec a
314+  BA42 47               ld b,a
315+  BA43              control_automove1:
316+  BA43 ED 43 97 BD      ld (player),bc      ; and back to player
317+  BA47 7B               ld a,e              ; now get the pixel count back
318+  BA48 3D               dec a               ; decrease by one
319+  BA49 21 9C BD         ld hl,player+5
320+  BA4C 77               ld (hl),a           ; copy back
321+  BA4D CD 90 BF         call player_justmoved
322+  BA50 C9               ret
323+  BA51
324+  BA51              ;
325+  BA51              ; Moves the player up
326+  BA51              ;
327+  BA51              control_pl_moveup:
328+  BA51 C5               push bc
329+  BA52 ED 4B 97 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
330+  BA56 79               ld a,c                  ; load c into the acc
331+  BA57 FE 18            cp 24
332+  BA59 CA 77 BA         jp z,control_pl_moveup0 ; are we at the edge of the screen
333+  BA5C FE 60            cp 96
334+  BA5E CC 2B BB         call z, control_scroll_up
335+  BA61 CD D2 BC         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
336+  BA64 F5               push af
337+  BA65 7B               ld a,e                  ; put e in a
338+  BA66 FE 00            cp 0
339+  BA68 CA 76 BA         jp z,control_pl_moveup1 ; don't move if we can't
340+  BA6B F1               pop af
341+  BA6C D6 01            sub 1                   ; subtract 1
342+  BA6E                  ;sub 1                   ; subtract 1
343+  BA6E 4F               ld c,a                  ; load back to c
344+  BA6F ED 43 97 BD      ld (player),bc          ; load back to player
345+  BA73 C3 77 BA         jp control_pl_moveup0
346+  BA76              control_pl_moveup1:
347+  BA76 F1               pop af                  ; restore af if needed
348+  BA77              control_pl_moveup0:
349+  BA77 3E 00            ld a,0
350+  BA79 32 99 BD         ld (player+2),a        ; set direction to up
351+  BA7C C1               pop bc
352+  BA7D C9               ret
353+  BA7E              ;
354+  BA7E              ; Moves the player down
355+  BA7E              ;
356+  BA7E              control_pl_movedown:
357+  BA7E C5               push bc
358+  BA7F ED 4B 97 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
359+  BA83 79               ld a,c                  ; load c into the acc
360+  BA84 FE E0            cp 224
361+  BA86 CA A3 BA         jp z,control_pl_movedown0 ; are we at the edge of the screen
362+  BA89 FE 80            cp 128
363+  BA8B CC 1E BB         call z, control_scroll_down
364+  BA8E CD A6 BC         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
365+  BA91 F5               push af
366+  BA92 7B               ld a,e                  ; put e in a
367+  BA93 FE 00            cp 0
368+  BA95 CA A2 BA         jp z,control_pl_movedown1 ; don't move if we can't
369+  BA98 F1               pop af
370+  BA99 3C               inc a                   ; add 1
371+  BA9A                  ;inc a                   ; add 1
372+  BA9A 4F               ld c,a                  ; load back to c
373+  BA9B ED 43 97 BD      ld (player),bc          ; load back to player
374+  BA9F C3 A3 BA         jp control_pl_movedown0
375+  BAA2              control_pl_movedown1:
376+  BAA2 F1               pop af                  ; restore af if needed
377+  BAA3              control_pl_movedown0:
378+  BAA3 3E 03            ld a,3
379+  BAA5 32 99 BD         ld (player+2),a        ; set direction to down
380+  BAA8 C1               pop bc
381+  BAA9 C9               ret
382+  BAAA              ;
383+  BAAA              ; Moves the player left
384+  BAAA              ;
385+  BAAA              control_pl_moveleft:
386+  BAAA C5               push bc
387+  BAAB ED 4B 97 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
388+  BAAF 78               ld a,b                  ; load b into the acc
389+  BAB0 FE 10            cp 16
390+  BAB2 CA D3 BA         jp z,control_pl_moveleft0 ; are we at the edge of the screen
391+  BAB5 CD 31 BD         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
392+  BAB8 F5               push af
393+  BAB9 7B               ld a,e                  ; put e in a
394+  BABA FE 00            cp 0
395+  BABC CA D2 BA         jp z,control_pl_moveleft1 ; don't move if we can't
396+  BABF 21 9C BD         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
397+  BAC2 3E 03            ld a,3
398+  BAC4 77               ld (hl),a
399+  BAC5 F1               pop af
400+  BAC6 D6 01            sub 1                    ; subtract 2
401+  BAC8 D6 01            sub 1
402+  BACA 47               ld b,a                  ; load back to c
403+  BACB ED 43 97 BD      ld (player),bc          ; load back to player
404+  BACF C3 D3 BA         jp control_pl_moveleft0
405+  BAD2              control_pl_moveleft1:
406+  BAD2 F1               pop af
407+  BAD3              control_pl_moveleft0:
408+  BAD3 3E 01            ld a,1
409+  BAD5 32 99 BD         ld (player+2),a        ; set direction to left
410+  BAD8 C1               pop bc
411+  BAD9 C9               ret
412+  BADA              ;
413+  BADA              ; Moves the player right
414+  BADA              ;
415+  BADA              control_pl_moveright:
416+  BADA C5               push bc
417+  BADB ED 4B 97 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
418+  BADF 78               ld a,b                  ; load b into the acc
419+  BAE0 FE F0            cp 240
420+  BAE2 CA 01 BB         jp z,control_pl_moveright0 ; are we at the edge of the screen
421+  BAE5 CD 05 BD         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
422+  BAE8 F5               push af
423+  BAE9 7B               ld a,e                  ; put e in a
424+  BAEA FE 00            cp 0
425+  BAEC CA 00 BB         jp z,control_pl_moveright1 ; don't move if we can't
426+  BAEF 21 9C BD         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
427+  BAF2 3E 03            ld a,3
428+  BAF4 77               ld (hl),a
429+  BAF5 F1               pop af
430+  BAF6 3C               inc a                   ; add 2
431+  BAF7 3C               inc a
432+  BAF8 47               ld b,a                  ; load back to b
433+  BAF9 ED 43 97 BD      ld (player),bc          ; load back to player
434+  BAFD C3 01 BB         jp control_pl_moveright0
435+  BB00              control_pl_moveright1:
436+  BB00 F1               pop af                  ; restore af if needed
437+  BB01              control_pl_moveright0:
438+  BB01 3E 02            ld a,2
439+  BB03 32 99 BD         ld (player+2),a        ; set direction to right
440+  BB06 C1               pop bc
441+  BB07 C9               ret
442+  BB08
443+  BB08              ;
444+  BB08              ; Player fires
445+  BB08              ;
446+  BB08              control_pl_fire:
447+  BB08 3A 99 BD         ld a,(player+2)         ; get player direction
448+  BB0B FE 00            cp 0
449+  BB0D C8               ret z
450+  BB0E FE 03            cp 3
451+  BB10 C8               ret z                   ; if up or down, don't fire
452+  BB11 3A 82 CD         ld a,(bullet_state+3)       ; get the state
453+  BB14 FE 01            cp 1
454+  BB16 C8               ret z                   ; if currently firing, don't fire
455+  BB17 CD 83 CD         call bullet_init        ; initialise the bullet
456+  BB1A CD 98 CD         call bullet_shoot       ; shoot the bullet
457+  BB1D C9               ret
458+  BB1E
459+  BB1E              ;
460+  BB1E              ; Scrolls the screen down
461+  BB1E              ;
462+  BB1E              control_scroll_down:
463+  BB1E F5               push af
464+  BB1F 3E 08            ld a,8
465+  BB21 32 09 A8         ld (screen_offset),a
466+  BB24 F1               pop af
467+  BB25 21 56 A6         ld hl,buffer_updateall
468+  BB28 36 01            ld (hl),1         ; flag as screen needing update
469+  BB2A C9               ret
470+  BB2B
471+  BB2B              ;
472+  BB2B              ; Scrolls the screen up
473+  BB2B              ;
474+  BB2B              control_scroll_up:
475+  BB2B F5               push af
476+  BB2C 3E 00            ld a,0
477+  BB2E 32 09 A8         ld (screen_offset),a
478+  BB31 F1               pop af
479+  BB32 21 56 A6         ld hl,buffer_updateall
480+  BB35 36 01            ld (hl),1         ; flag as screen needing update
481+  BB37 C9               ret
482+  BB38
483+  BB38
484+  BB38
485+  BB38
# file closed: game/control.asm
 38   BB38                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  BB38              ;
  2+  BB38              ; The number of frames to dig for
  3+  BB38              ;
  4+  BB38              movement_numberdigframes:
  5+  BB38 0A               defb 10
  6+  BB39
  7+  BB39              ;
  8+  BB39              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  BB39              ; Inputs:
 10+  BB39              ; hl - memory location of top pixel row
 11+  BB39              ; bc - screen coords, b horiz, c vert
 12+  BB39              ; Outputs:
 13+  BB39              ; e - 0 if not empty, 1 if empty
 14+  BB39              ;
 15+  BB39              movement_spaceisempty:
 16+  BB39 C5               push bc
 17+  BB3A E5               push hl
 18+  BB3B CD 63 BB         call movement_spaceisgem        ; check if space is a gem
 19+  BB3E E1               pop hl
 20+  BB3F C1               pop bc
 21+  BB40 7B               ld a,e
 22+  BB41 FE 01            cp 1
 23+  BB43 C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  BB44 3E 08            ld a,8                          ; 8 rows to check
 25+  BB46              movement_spaceisempty0:
 26+  BB46 08               ex af,af'                       ; store the loop counter
 27+  BB47 7E               ld a,(hl)                       ; get current pixel row
 28+  BB48 FE 00            cp 0
 29+  BB4A C2 5E BB         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  BB4D 79               ld a,c                          ; load the vertical coord
 31+  BB4E 3C               inc a                           ; next row down
 32+  BB4F 11 20 00         ld de,32
 33+  BB52 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  BB53 4F               ld c,a                          ; copy vert coord back to c
 35+  BB54 08               ex af,af'                       ; get loop counter back
 36+  BB55 3D               dec a                           ; decrease loop counter
 37+  BB56 C2 46 BB         jp nz, movement_spaceisempty0
 38+  BB59 16 00            ld d,0
 39+  BB5B 1E 01            ld e,1                          ; got to end, so space is empty
 40+  BB5D C9               ret
 41+  BB5E              movement_spaceisempty1:
 42+  BB5E 16 00            ld d,0
 43+  BB60 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  BB62 C9               ret
 45+  BB63
 46+  BB63              ;
 47+  BB63              ; Check if a space contains a gem
 48+  BB63              ; Inputs:
 49+  BB63              ; bc - screen coords
 50+  BB63              ; Outputs:
 51+  BB63              ; e = 1 if gem
 52+  BB63              movement_spaceisgem:
 53+  BB63 CD 5B A9         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  BB66 21 32 B5         ld hl,level01diamonds           ; check diamonds first
 55+  BB69              movement_spaceisgem0:
 56+  BB69 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  BB6D 7B               ld a,e                          ; check for end of data
 58+  BB6E FE FF            cp 255
 59+  BB70 CA 8B BB         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  BB73 23               inc hl
 61+  BB74 23               inc hl                          ; move to state
 62+  BB75 7E               ld a,(hl)
 63+  BB76 23               inc hl
 64+  BB77 23               inc hl
 65+  BB78 23               inc hl                          ; get to next
 66+  BB79 FE 01            cp 1                            ; check if collected
 67+  BB7B CA 69 BB         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  BB7E 7B               ld a,e                          ; load e again
 69+  BB7F B9               cp c                            ; otherwise, compare c with e
 70+  BB80 C2 69 BB         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  BB83 7A               ld a,d                          ; get d coord
 72+  BB84 B8               cp b                            ; compare b with d
 73+  BB85 C2 69 BB         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  BB88 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  BB8A C9               ret
 76+  BB8B              movement_spaceisgem1:
 77+  BB8B 21 42 B5         ld hl,level01gems              ; check gems
 78+  BB8E              movement_spaceisgem2:
 79+  BB8E 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  BB92 7B               ld a,e                          ; check for end of data
 81+  BB93 FE FF            cp 255
 82+  BB95 CA B0 BB         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  BB98 23               inc hl
 84+  BB99 23               inc hl                          ; move to state
 85+  BB9A 7E               ld a,(hl)
 86+  BB9B 23               inc hl
 87+  BB9C 23               inc hl
 88+  BB9D 23               inc hl                          ; get to next
 89+  BB9E FE 01            cp 1                            ; check if collected
 90+  BBA0 CA 8E BB         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  BBA3 7B               ld a,e                          ; load e again
 92+  BBA4 B9               cp c                            ; otherwise, compare c with e
 93+  BBA5 C2 8E BB         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  BBA8 7A               ld a,d                          ; get d coord
 95+  BBA9 B8               cp b                            ; compare b with d
 96+  BBAA C2 8E BB         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  BBAD 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  BBAF C9               ret
 99+  BBB0              movement_spaceisgem3:
100+  BBB0 1E 00            ld e,0                          ; nothing found, return e = 0
101+  BBB2 C9               ret
102+  BBB3
103+  BBB3              ;
104+  BBB3              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  BBB3              ; Inputs:
106+  BBB3              ; hl - memory location of top pixel row
107+  BBB3              ; bc - screen coords, b horiz, c vert
108+  BBB3              ; Outputs:
109+  BBB3              ; e - 0 if not empty, 1 if empty
110+  BBB3              ;
111+  BBB3              movement_linebelowisempty:
112+  BBB3 C5               push bc
113+  BBB4 E5               push hl
114+  BBB5 CD 63 BB         call movement_spaceisgem        ; check if space is a gem
115+  BBB8 E1               pop hl
116+  BBB9 C1               pop bc
117+  BBBA 7B               ld a,e
118+  BBBB FE 01            cp 1
119+  BBBD C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  BBBE 7E               ld a,(hl)                       ; get current pixel row
121+  BBBF FE 00            cp 0
122+  BBC1 C2 C9 BB         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  BBC4 16 00            ld d,0
124+  BBC6 1E 01            ld e,1                          ; got to end, so space is empty
125+  BBC8 C9               ret
126+  BBC9              movement_linebelowisempty1:
127+  BBC9 16 00            ld d,0
128+  BBCB 1E 00            ld e,0                          ; returning false, ie space not empty
129+  BBCD C9               ret
130+  BBCE
131+  BBCE              ;
132+  BBCE              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  BBCE              ; Inputs:
134+  BBCE              ; hl - memory location of top pixel row
135+  BBCE              ; bc - screen coords, b horiz, c vert
136+  BBCE              ; Outputs:
137+  BBCE              ; e - 0 if not empty, 1 if empty
138+  BBCE              ;
139+  BBCE              movement_lineaboveisempty:
140+  BBCE C5               push bc
141+  BBCF E5               push hl
142+  BBD0 CD 63 BB         call movement_spaceisgem        ; check if space is a gem
143+  BBD3 E1               pop hl
144+  BBD4 C1               pop bc
145+  BBD5 7B               ld a,e
146+  BBD6 FE 01            cp 1
147+  BBD8 C8               ret z
148+  BBD9 7E               ld a,(hl)                       ; get current pixel row
149+  BBDA FE 00            cp 0
150+  BBDC C2 E4 BB         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  BBDF 16 00            ld d,0
152+  BBE1 1E 01            ld e,1                          ; got to end, so space is empty
153+  BBE3 C9               ret
154+  BBE4              movement_lineaboveisempty1:
155+  BBE4 16 00            ld d,0
156+  BBE6 1E 00            ld e,0                          ; returning false, ie space not empty
157+  BBE8 C9               ret
158+  BBE9
159+  BBE9              ;
160+  BBE9              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  BBE9              ; Inputs:
162+  BBE9              ; hl - memory location of top pixel row
163+  BBE9              ; bc - screen coords, b horiz, c vert
164+  BBE9              ; Outputs:
165+  BBE9              ; none - puts player into digging mode
166+  BBE9              ;
167+  BBE9              movement_spaceisdiggable:
168+  BBE9 3E 08            ld a,8                          ; 8 rows to check
169+  BBEB              movement_spaceisdiggable0:
170+  BBEB 08               ex af,af'                       ; store the loop counter
171+  BBEC 7E               ld a,(hl)                       ; get current pixel row
172+  BBED FE 00            cp 0
173+  BBEF CA FF BB         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  BBF2 FE 55            cp 85
175+  BBF4 CA FF BB         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  BBF7 FE AA            cp 170
177+  BBF9 CA FF BB         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  BBFC C3 19 BC         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  BBFF              movement_spaceisdiggable2:
180+  BBFF 79               ld a,c                          ; load the vertical coord
181+  BC00 3C               inc a                           ; next row down
182+  BC01 11 20 00         ld de,32
183+  BC04 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  BC05 4F               ld c,a                          ; copy vert coord back to c
185+  BC06 08               ex af,af'                       ; get loop counter back
186+  BC07 3D               dec a                           ; decrease loop counter
187+  BC08 C2 EB BB         jp nz, movement_spaceisdiggable0
188+  BC0B 21 9D BD         ld hl,player+6
189+  BC0E 36 01            ld (hl),1                       ; set the player into digging mode
190+  BC10 23               inc hl
191+  BC11 3A 38 BB         ld a,(movement_numberdigframes)
192+  BC14 77               ld (hl),a                       ; set the number of frame to dig for
193+  BC15 23               inc hl
194+  BC16 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  BC18 C9               ret
196+  BC19              movement_spaceisdiggable1:
197+  BC19 21 9D BD         ld hl,player+6
198+  BC1C 36 00            ld (hl),0                       ; set the player out of digging mode
199+  BC1E C9               ret
200+  BC1F
201+  BC1F              ;
202+  BC1F              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
203+  BC1F              ; Inputs:
204+  BC1F              ; hl - memory location of top pixel row
205+  BC1F              ; bc - screen coords, b horiz, c vert
206+  BC1F              ; Outputs:
207+  BC1F              ; none - puts player into digging mode
208+  BC1F              ;
209+  BC1F              movement_spacebelowisdiggable:
210+  BC1F 7E               ld a,(hl)                       ; get first pixel row
211+  BC20 FE 55            cp 85
212+  BC22 CA 2D BC         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
213+  BC25 FE AA            cp 170
214+  BC27 CA 2D BC         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
215+  BC2A C3 19 BC         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
216+  BC2D              movement_spacebelowisdiggable3:
217+  BC2D 3E 08            ld a,8                          ; rows to check
218+  BC2F 1E 00            ld e,0                          ; count of rows to dig
219+  BC31              movement_spacebelowisdiggable0:
220+  BC31 08               ex af,af'                       ; store the loop counter
221+  BC32 7E               ld a,(hl)                       ; get current pixel row
222+  BC33 FE 55            cp 85
223+  BC35 CA 40 BC         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
224+  BC38 FE AA            cp 170
225+  BC3A CA 40 BC         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
226+  BC3D C3 4F BC         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
227+  BC40              movement_spacebelowisdiggable4:
228+  BC40 1C               inc e                           ; inc count of rows to dig
229+  BC41              movement_spacebelowisdiggable2:
230+  BC41 79               ld a,c                          ; load the vertical coord
231+  BC42 3C               inc a                           ; next row down
232+  BC43 D5               push de                         ; need e for later
233+  BC44 11 20 00         ld de,32
234+  BC47 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
235+  BC48 4F               ld c,a                          ; copy vert coord back to c
236+  BC49 D1               pop de                          ; get e back
237+  BC4A 08               ex af,af'                       ; get loop counter back
238+  BC4B 3D               dec a                           ; incease loop counter
239+  BC4C C2 31 BC         jp nz, movement_spacebelowisdiggable0
240+  BC4F              movement_spacebelowisdiggable5:
241+  BC4F 21 9D BD         ld hl,player+6
242+  BC52 36 01            ld (hl),1                       ; set the player into digging mode
243+  BC54 23               inc hl
244+  BC55 3A 38 BB         ld a,(movement_numberdigframes)
245+  BC58 77               ld (hl),a                       ; set the number of frame to dig for
246+  BC59 23               inc hl
247+  BC5A 73               ld (hl),e                       ; set the number of pixels to dig
248+  BC5B C9               ret
249+  BC5C              movement_spacebelowisdiggable1:
250+  BC5C 21 9D BD         ld hl,player+6
251+  BC5F 36 00            ld (hl),0                       ; set the player out of digging mode
252+  BC61 C9               ret
253+  BC62
254+  BC62              ;
255+  BC62              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
256+  BC62              ; Inputs:
257+  BC62              ; hl - memory location of top pixel row
258+  BC62              ; bc - screen coords, b horiz, c vert
259+  BC62              ; Outputs:
260+  BC62              ; none - puts player into digging mode
261+  BC62              ;
262+  BC62              movement_spaceaboveisdiggable:
263+  BC62 7E               ld a,(hl)                       ; get first pixel row
264+  BC63 FE 55            cp 85
265+  BC65 CA 70 BC         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
266+  BC68 FE AA            cp 170
267+  BC6A CA 70 BC         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
268+  BC6D C3 19 BC         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
269+  BC70              movement_spaceaboveisdiggable3:
270+  BC70 3E 08            ld a,8                          ; rows to check
271+  BC72 1E 00            ld e,0                          ; count of rows to dig
272+  BC74              movement_spaceaboveisdiggable0:
273+  BC74 08               ex af,af'                       ; store the loop counter
274+  BC75 7E               ld a,(hl)                       ; get current pixel row
275+  BC76 FE 55            cp 85
276+  BC78 CA 83 BC         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
277+  BC7B FE AA            cp 170
278+  BC7D CA 83 BC         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
279+  BC80 C3 93 BC         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
280+  BC83              movement_spaceaboveisdiggable4:
281+  BC83 1C               inc e                           ; inc count of rows to dig
282+  BC84              movement_spaceaboveisdiggable2:
283+  BC84 79               ld a,c                          ; load the vertical coord
284+  BC85 3D               dec a                           ; next row up
285+  BC86 D5               push de                         ; need e for later
286+  BC87 11 20 00         ld de,32
287+  BC8A ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
288+  BC8C 4F               ld c,a                          ; copy vert coord back to c
289+  BC8D D1               pop de                          ; get e back
290+  BC8E 08               ex af,af'                       ; get loop counter back
291+  BC8F 3D               dec a                           ; incease loop counter
292+  BC90 C2 74 BC         jp nz, movement_spaceaboveisdiggable0
293+  BC93              movement_spaceaboveisdiggable5:
294+  BC93 21 9D BD         ld hl,player+6
295+  BC96 36 01            ld (hl),1                       ; set the player into digging mode
296+  BC98 23               inc hl
297+  BC99 3A 38 BB         ld a,(movement_numberdigframes)
298+  BC9C 77               ld (hl),a                       ; set the number of frame to dig for
299+  BC9D 23               inc hl
300+  BC9E 73               ld (hl),e                       ; set the number of pixels to dig
301+  BC9F C9               ret
302+  BCA0              movement_spaceaboveisdiggable1:
303+  BCA0 21 9D BD         ld hl,player+6
304+  BCA3 36 00            ld (hl),0                       ; set the player out of digging mode
305+  BCA5 C9               ret
306+  BCA6
307+  BCA6              ;
308+  BCA6              ; Checks if the player can move down
309+  BCA6              ; Inputs:
310+  BCA6              ; bc - player coords, b horiz, c vert
311+  BCA6              ; Outputs:
312+  BCA6              ; de - 1 can move
313+  BCA6              movement_checkcanmove_down:
314+  BCA6 F5               push af
315+  BCA7 C5               push bc
316+  BCA8 CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
317+  BCAB 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
318+  BCAD 24               inc h                       ; memory location of cell beneath now in hl
319+  BCAE 3E 08            ld a,8                       ; look below
320+  BCB0 81               add c
321+  BCB1 4F               ld c,a
322+  BCB2 CD B3 BB         call movement_linebelowisempty       ; check space is empty
323+  BCB5 7B               ld a,e                          ; check space empty flag
324+  BCB6 FE 00            cp 0
325+  BCB8 CA C1 BC         jp z, movement_checkcanmove_down1 ; can't move
326+  BCBB CD 90 BF         call player_justmoved
327+  BCBE C1               pop bc
328+  BCBF F1               pop af
329+  BCC0 C9               ret
330+  BCC1              movement_checkcanmove_down1:
331+  BCC1 C1               pop bc
332+  BCC2 CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
333+  BCC5 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
334+  BCC7 24               inc h
335+  BCC8 C5               push bc
336+  BCC9 CD 1F BC         call movement_spacebelowisdiggable    ; can't move here, but can we dig
337+  BCCC 11 00 00         ld de,0
338+  BCCF C1               pop bc
339+  BCD0 F1               pop af
340+  BCD1 C9               ret
341+  BCD2
342+  BCD2              ;
343+  BCD2              ; Checks if the player can move up
344+  BCD2              ; Inputs:
345+  BCD2              ; bc - player coords, b horiz, c vert
346+  BCD2              ; Outputs:
347+  BCD2              ; de - 1 can move
348+  BCD2              movement_checkcanmove_up:
349+  BCD2 F5               push af
350+  BCD3 C5               push bc
351+  BCD4 CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
352+  BCD7 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
353+  BCD9 11 20 00         ld de,32
354+  BCDC ED 52            sbc hl,de                       ; memory location of line above now in hl
355+  BCDE 0D               dec c                           ; look above
356+  BCDF CD CE BB         call movement_lineaboveisempty       ; check space is empty
357+  BCE2 7B               ld a,e                          ; check space empty flag
358+  BCE3 FE 00            cp 0
359+  BCE5 CA F0 BC         jp z, movement_checkcanmove_up1 ; can't move
360+  BCE8 1E 01            ld e,1
361+  BCEA CD 90 BF         call player_justmoved
362+  BCED C1               pop bc
363+  BCEE F1               pop af
364+  BCEF C9               ret
365+  BCF0              movement_checkcanmove_up1:
366+  BCF0 C1               pop bc
367+  BCF1 CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
368+  BCF4 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
369+  BCF6 11 20 00         ld de,32
370+  BCF9 ED 52            sbc hl,de                       ; memory location of line above now in hl
371+  BCFB C5               push bc
372+  BCFC CD 62 BC         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
373+  BCFF 11 00 00         ld de,0
374+  BD02 C1               pop bc
375+  BD03 F1               pop af
376+  BD04 C9               ret
377+  BD05
378+  BD05              ;
379+  BD05              ; Checks if the player can move right
380+  BD05              ; Inputs:
381+  BD05              ; bc - player coords, b horiz, c vert
382+  BD05              ; Outputs:
383+  BD05              ; de - 1 can move
384+  BD05              movement_checkcanmove_right:
385+  BD05 F5               push af
386+  BD06 C5               push bc
387+  BD07 CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
388+  BD0A 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
389+  BD0C 3E 08            ld a,8
390+  BD0E 80               add b                           ; move one cell right
391+  BD0F 47               ld b,a
392+  BD10 23               inc hl                          ; memory location of cell to the right now in hl
393+  BD11 CD 39 BB         call movement_spaceisempty       ; check space is empty
394+  BD14 7B               ld a,e                          ; check space empty flag
395+  BD15 FE 00            cp 0
396+  BD17 CA 20 BD         jp z, movement_checkcanmove_right1 ; can't move
397+  BD1A CD 90 BF         call player_justmoved
398+  BD1D C1               pop bc
399+  BD1E F1               pop af
400+  BD1F C9               ret
401+  BD20              movement_checkcanmove_right1:
402+  BD20 C1               pop bc
403+  BD21 CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
404+  BD24 62 6B            ld hl,de
405+  BD26 23               inc hl                          ; memory location of cell to the right now in hl
406+  BD27 C5               push bc
407+  BD28 CD E9 BB         call movement_spaceisdiggable    ; can't move here, but can we dig
408+  BD2B 11 00 00         ld de,0
409+  BD2E C1               pop bc
410+  BD2F F1               pop af
411+  BD30 C9               ret
412+  BD31
413+  BD31              ;
414+  BD31              ; Checks if the player can move left
415+  BD31              ; Inputs:
416+  BD31              ; bc - player coords, b horiz, c vert
417+  BD31              ; Outputs:
418+  BD31              ; de - 1 can move
419+  BD31              movement_checkcanmove_left:
420+  BD31 F5               push af
421+  BD32 C5               push bc
422+  BD33 CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
423+  BD36 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
424+  BD38 78               ld a,b
425+  BD39 06 08            ld b,8
426+  BD3B 90               sub b                           ; move one cell left
427+  BD3C 47               ld b,a
428+  BD3D 2B               dec hl                          ; memory location of cell to the right now in hl
429+  BD3E CD 39 BB         call movement_spaceisempty       ; check space is empty
430+  BD41 7B               ld a,e                          ; check space empty flag
431+  BD42 FE 00            cp 0
432+  BD44 CA 4D BD         jp z, movement_checkcanmove_left1 ; can't move
433+  BD47 CD 90 BF         call player_justmoved
434+  BD4A C1               pop bc
435+  BD4B F1               pop af
436+  BD4C C9               ret
437+  BD4D              movement_checkcanmove_left1:
438+  BD4D C1               pop bc
439+  BD4E CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
440+  BD51 62 6B            ld hl,de
441+  BD53 2B               dec hl                          ; memory location of cell to the right now in hl
442+  BD54 C5               push bc
443+  BD55 CD E9 BB         call movement_spaceisdiggable    ; can't move here, but can we dig
444+  BD58 11 00 00         ld de,0
445+  BD5B C1               pop bc
446+  BD5C F1               pop af
447+  BD5D C9               ret
# file closed: game/movement.asm
 39   BD5E                  include "game\game.asm"
# file opened: game/game.asm
  1+  BD5E              ;
  2+  BD5E              ; The current frame count, incremented each frame
  3+  BD5E              ;
  4+  BD5E              game_framenumber:
  5+  BD5E 00               defb    0
  6+  BD5F
  7+  BD5F              ;
  8+  BD5F              ; The number of players
  9+  BD5F              ;
 10+  BD5F              game_numberplayers:
 11+  BD5F 01               defb 1
 12+  BD60
 13+  BD60              ;
 14+  BD60              ; The current player
 15+  BD60              ;
 16+  BD60              game_currentplayer:
 17+  BD60 01               defb 1
 18+  BD61
 19+  BD61              ;
 20+  BD61              ; The default number of lives
 21+  BD61              ;
 22+  BD61              game_numberlives:
 23+  BD61 04               defb 4
 24+  BD62
 25+  BD62              ;
 26+  BD62              ; The current difficulty
 27+  BD62              ;
 28+  BD62              game_difficulty:
 29+  BD62 00               defb 0
 30+  BD63
 31+  BD63              ;
 32+  BD63              ; Control method: 0 for keyboard, 1 for kempston
 33+  BD63              ;
 34+  BD63              game_control:
 35+  BD63 00               defb 0
 36+  BD64
 37+  BD64              ;
 38+  BD64              ; Moves to the next player
 39+  BD64              ;
 40+  BD64              game_changeplayer:
 41+  BD64 3A 60 BD         ld a,(game_currentplayer)
 42+  BD67 FE 01            cp 1
 43+  BD69 C8               ret z                       ; if just one player, no need to change
 44+  BD6A 3D               dec a                       ; otherwise decrease by one
 45+  BD6B EE 01            xor 1                       ; xor with one to flip
 46+  BD6D 3C               inc a                       ; increment
 47+  BD6E 21 60 BD         ld hl,game_currentplayer
 48+  BD71 77               ld (hl),a                   ; store
 49+  BD72 C9               ret
 50+  BD73
 51+  BD73              ;
 52+  BD73              ; Sets the number of players at the start of the game
 53+  BD73              ; Inputs:
 54+  BD73              ; a - number of players
 55+  BD73              game_setnumberofplayers:
 56+  BD73 21 5F BD         ld hl,game_numberplayers
 57+  BD76 77               ld (hl),a
 58+  BD77
 59+  BD77              ;
 60+  BD77              ; Increment frame number by 1
 61+  BD77              ;
 62+  BD77              game_incrementframe:
 63+  BD77 3A 5E BD         ld a,(game_framenumber)
 64+  BD7A FE FF            cp 255
 65+  BD7C C2 81 BD         jp nz,game_incrementframe0
 66+  BD7F 3E 00            ld a,0
 67+  BD81              game_incrementframe0:
 68+  BD81 3C               inc a
 69+  BD82 32 5E BD         ld (game_framenumber),a
 70+  BD85 C9               ret
 71+  BD86
 72+  BD86              ;
 73+  BD86              ; Returns current frame
 74+  BD86              ; Outputs:
 75+  BD86              ; a - current frame
 76+  BD86              ;
 77+  BD86              game_getcurrentframe:
 78+  BD86 3A 5E BD         ld a,(game_framenumber)
 79+  BD89 C9               ret
 80+  BD8A
 81+  BD8A              ;
 82+  BD8A              ; Resets current frame
 83+  BD8A              ;
 84+  BD8A              game_resetcurrentframe:
 85+  BD8A 21 5E BD         ld hl,game_framenumber
 86+  BD8D 36 00            ld (hl),0
 87+  BD8F C9               ret
 88+  BD90
 89+  BD90              ;
 90+  BD90              ; Increases the current difficulty
 91+  BD90              ;
 92+  BD90              game_increasedifficulty:
 93+  BD90 3A 62 BD         ld a,(game_difficulty)
 94+  BD93 3C               inc a
 95+  BD94 32 62 BD         ld (game_difficulty),a
# file closed: game/game.asm
 40   BD97                  include "game\player.asm"
# file opened: game/player.asm
  1+  BD97              ;
  2+  BD97              ;   Data for current player
  3+  BD97              ;
  4+  BD97              player:
  5+  BD97 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  BD99 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  BD9C 00               defb    0                   ; auto move remaining (+5)
  8+  BD9D 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  BDA0 00               defb    0                   ; lives remaining (+9)
 10+  BDA1 00               defb    0                   ; died this life (+10)
 11+  BDA2 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  BDA4 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  BDA5 00               defb    0                   ; difficulty (+14)
 14+  BDA6
 15+  BDA6              player_location:
 16+  BDA6 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 17+  BDA7
 18+  BDA7              ;
 19+  BDA7              ; Works out which part of the screen the player is in
 20+  BDA7              ; Pit is between 3,9 and 8,9
 21+  BDA7              ; Diamond cavern is between 11,22 and 22,28
 22+  BDA7              ;
 23+  BDA7              player_getlocation:
 24+  BDA7 ED 4B 97 BD      ld bc,(player)              ; get screen coords
 25+  BDAB CD 5B A9         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 26+  BDAE 78               ld a,b                      ; check for pit first
 27+  BDAF FE 09            cp 9                        ; if not on this row, not in the pit
 28+  BDB1 C2 C0 BD         jp nz,player_getlocation0
 29+  BDB4 79               ld a,c                      ; check horizontal
 30+  BDB5 FE 09            cp 9
 31+  BDB7 D2 C0 BD         jp nc, player_getlocation0  ; if more than 9, not in the pit
 32+  BDBA 21 A6 BD         ld hl,player_location
 33+  BDBD 36 02            ld (hl),2                   ; load location with 2, the pit
 34+  BDBF C9               ret                         ; done
 35+  BDC0              player_getlocation0:            ; check for diamond cavern
 36+  BDC0 78               ld a,b                      ; first check vertical
 37+  BDC1 FE 16            cp 22                       ; if above row 22, then not in cavern
 38+  BDC3 DA D7 BD         jp c,player_getlocation1
 39+  BDC6 79               ld a,c                      ; get the horizontal next
 40+  BDC7 FE 0B            cp 11
 41+  BDC9 DA D7 BD         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 42+  BDCC FE 16            cp 22
 43+  BDCE D2 D7 BD         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 44+  BDD1 21 A6 BD         ld hl,player_location
 45+  BDD4 36 01            ld (hl),1                   ; load location with 1, the cavern
 46+  BDD6 C9               ret
 47+  BDD7              player_getlocation1:
 48+  BDD7 21 A6 BD         ld hl,player_location
 49+  BDDA 36 00            ld (hl),0                   ; load location with 2, the pit
 50+  BDDC C9               ret                         ; done
 51+  BDDD
 52+  BDDD
 53+  BDDD              ;
 54+  BDDD              ; Initializes a player at start of game
 55+  BDDD              ; Copy initial coords, copy lives, copy score
 56+  BDDD              ;
 57+  BDDD              player_init_gamestart:
 58+  BDDD 3A 61 BD         ld a,(game_numberlives)
 59+  BDE0 32 8C BE         ld (player1_lives),a
 60+  BDE3 32 8D BE         ld (player2_lives),a                        ; set the initial number of lives at game start
 61+  BDE6
 62+  BDE6 21 90 BE         ld hl,player1_score+2
 63+  BDE9 06 06            ld b,6
 64+  BDEB              player_init_gamestart0:
 65+  BDEB 36 30            ld (hl),48
 66+  BDED 23               inc hl
 67+  BDEE 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 68+  BDF0 21 99 BE         ld hl,player2_score+2
 69+  BDF3 06 06            ld b,6
 70+  BDF5              player_init_gamestart1:
 71+  BDF5 36 30            ld (hl),48
 72+  BDF7 23               inc hl
 73+  BDF8 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 74+  BDFA 3E 00            ld a,0
 75+  BDFC 32 A0 BE         ld (player1_difficulty),a
 76+  BDFF 32 A1 BE         ld (player2_difficulty),a                   ; set player difficulties to zero
 77+  BE02 C9               ret
 78+  BE03
 79+  BE03              ;
 80+  BE03              ; Initializes a player at start of a life
 81+  BE03              ; Copy initial coords, copy lives, copy score
 82+  BE03              ;
 83+  BE03              player_init_lifestart:
 84+  BE03 21 9C BD         ld hl,player+5
 85+  BE06 06 09            ld b,9                      ; initialise 9 properties
 86+  BE08              player_init_lifestart2:
 87+  BE08 36 00            ld (hl),0
 88+  BE0A 23               inc hl
 89+  BE0B 10 FB            djnz player_init_lifestart2
 90+  BE0D
 91+  BE0D 21 99 BD         ld hl,player+2              ; initialise some properties
 92+  BE10 36 02            ld (hl),2
 93+  BE12 23               inc hl
 94+  BE13 36 00            ld (hl),0
 95+  BE15 23               inc hl
 96+  BE16 36 01            ld (hl),1
 97+  BE18
 98+  BE18 ED 4B 22 80      ld bc,(init_coord)
 99+  BE1C ED 43 97 BD      ld (player),bc
100+  BE20 01 A0 BD         ld bc,player+9
101+  BE23 3A 8C BE         ld a,(player1_lives)
102+  BE26 02               ld (bc),a
103+  BE27
104+  BE27 CD A3 C6         call diamonds_init      ; initialise gems
105+  BE2A
106+  BE2A 01 06 00         ld bc,6
107+  BE2D 11 66 C4         ld de,scores_current+2
108+  BE30 3A 60 BD         ld a,(game_currentplayer)
109+  BE33 FE 01            cp 1
110+  BE35 C2 44 BE         jp nz,player_init_lifestart0
111+  BE38 3A A0 BE         ld a,(player1_difficulty)       ; initialise player 1 difficulty
112+  BE3B 32 62 BD         ld (game_difficulty),a
113+  BE3E 21 90 BE         ld hl,player1_score+2           ; itialise player 1 scores
114+  BE41 C3 4D BE         jp player_init_lifestart1
115+  BE44              player_init_lifestart0:
116+  BE44 3A A1 BE         ld a,(player2_difficulty)       ; initialise player 2 difficulty
117+  BE47 32 62 BD         ld (game_difficulty),a
118+  BE4A 21 99 BE         ld hl,player2_score+2           ; initialise player 2 scores
119+  BE4D              player_init_lifestart1:
120+  BE4D ED B0            ldir
121+  BE4F C9               ret
122+  BE50
123+  BE50              ;
124+  BE50              ; Finalises a player at end of a life
125+  BE50              ; Copy lives, copy score
126+  BE50              ;
127+  BE50              player_lifeend:
128+  BE50 01 A0 BD         ld bc,player+9
129+  BE53 0A               ld a,(bc)
130+  BE54 01 8C BE         ld bc,player1_lives
131+  BE57 02               ld (bc),a
132+  BE58 CD 5C BE         call player_recordcurrentstate
133+  BE5B C9               ret
134+  BE5C
135+  BE5C              ;
136+  BE5C              ; Copies the current score and difficulty in the current player
137+  BE5C              ;
138+  BE5C              player_recordcurrentstate:
139+  BE5C 01 06 00         ld bc,6                  ; copy current score back to correct player
140+  BE5F 21 66 C4         ld hl,scores_current+2
141+  BE62 3A 60 BD         ld a,(game_currentplayer)
142+  BE65 FE 01            cp 1
143+  BE67 C2 76 BE         jp nz,player_recordcurrentstate0
144+  BE6A 3A 62 BD         ld a,(game_difficulty)
145+  BE6D 32 A0 BE         ld (player1_difficulty),a       ; store difficulty
146+  BE70 11 90 BE         ld de,player1_score+2
147+  BE73 C3 7F BE         jp player_recordcurrentstate1
148+  BE76              player_recordcurrentstate0:         ; do player 2
149+  BE76 3A 62 BD         ld a,(game_difficulty)
150+  BE79 32 A1 BE         ld (player2_difficulty),a       ; store difficulty
151+  BE7C 11 99 BE         ld de,player2_score+2
152+  BE7F              player_recordcurrentstate1:
153+  BE7F ED B0            ldir
154+  BE81 C9               ret
155+  BE82
156+  BE82              ;
157+  BE82              ; Player just died, subtract a life
158+  BE82              ;
159+  BE82              player_died:
160+  BE82 01 A0 BD         ld bc,player+9
161+  BE85 0A               ld a,(bc)
162+  BE86 3D               dec a
163+  BE87 02               ld (bc),a
164+  BE88 CD 50 BE         call player_lifeend
165+  BE8B C9               ret
166+  BE8C
167+  BE8C              ;
168+  BE8C              ; Player lives
169+  BE8C              ;
170+  BE8C              player1_lives:
171+  BE8C 03               defb 3
172+  BE8D              player2_lives:
173+  BE8D 03               defb 3
174+  BE8E
175+  BE8E              ;
176+  BE8E              ; Player scores
177+  BE8E              ;
178+  BE8E              player1_score:
179+  BE8E 04 01 30 30      defb 4,1,'000000',255
179+  BE92 30 30 30 30
179+  BE96 FF
180+  BE97              player2_score:
181+  BE97 16 01 30 30      defb 22,1,'000000',255
181+  BE9B 30 30 30 30
181+  BE9F FF
182+  BEA0
183+  BEA0              ;
184+  BEA0              ; Player difficulties
185+  BEA0              ;
186+  BEA0              player1_difficulty:
187+  BEA0 00               defb 0
188+  BEA1              player2_difficulty:
189+  BEA1 00               defb 0
190+  BEA2
191+  BEA2              ;
192+  BEA2              ; Kills a player this life
193+  BEA2              ;
194+  BEA2              player_killplayer:
195+  BEA2 21 A1 BD         ld hl,player+10
196+  BEA5 36 01            ld (hl),1
197+  BEA7 C9               ret
198+  BEA8
199+  BEA8              ;
200+  BEA8              ; Crush a player this life
201+  BEA8              ;
202+  BEA8              player_crushplayer:
203+  BEA8 21 A2 BD         ld hl,player+11             ; mark as crushed
204+  BEAB 36 01            ld (hl),1
205+  BEAD C9               ret
206+  BEAE
207+  BEAE              player_tankkillplayer
208+  BEAE 21 A2 BD         ld hl,player+11             ; mark as tanked
209+  BEB1 36 02            ld (hl),2
210+  BEB3 C9               ret
211+  BEB4
212+  BEB4              player_zonkplayer
213+  BEB4 21 A2 BD         ld hl,player+11             ; mark as zonked (missile)
214+  BEB7 36 03            ld (hl),3
215+  BEB9 C9               ret
216+  BEBA
217+  BEBA              player_pitkillplayer
218+  BEBA 21 A2 BD         ld hl,player+11             ; mark as pit killed
219+  BEBD 36 04            ld (hl),4
220+  BEBF C9               ret
221+  BEC0
222+  BEC0              player_robotkillplayer
223+  BEC0 21 A2 BD         ld hl,player+11             ; mark as robot killed
224+  BEC3 36 05            ld (hl),5
225+  BEC5 C9               ret
226+  BEC6
227+  BEC6              ;
228+  BEC6              ; Draws the player at the current position or deletes them
229+  BEC6              ;
230+  BEC6              player_drawplayer:
231+  BEC6 3A 99 BD         ld a,(player+2)             ; get the current direction
232+  BEC9 FE 03            cp 3
233+  BECB C2 D0 BE         jp nz,player_drawplayer0
234+  BECE 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
235+  BED0              player_drawplayer0:             ; DYING CHECKS
236+  BED0 5F               ld e,a                      ; store in e
237+  BED1 3A A2 BD         ld a,(player+11)             ; get the dying flag
238+  BED4 FE 01            cp 1
239+  BED6 CA 10 BF         jp z,player_drawplayer3     ; if it's one, we're being crushed
240+  BED9 FE 04            cp 4
241+  BEDB CA 58 BF         jp z,player_drawplayer9     ; player is falling into the pit
242+  BEDE FE 05            cp 5
243+  BEE0 CA 74 BF         jp z,player_drawplayer12    ; player has been killed by a robot
244+  BEE3              player_drawplayer4:             ; CHECK FOR DIGGING
245+  BEE3 3A 9D BD         ld a,(player+6)             ; get the dig flag
246+  BEE6 FE 01            cp 1
247+  BEE8 CA F9 BE         jp z,player_drawplayer1    ; get dig frame
248+  BEEB 3A 9A BD         ld a,(player+3)             ; this is normal movement so get the current frame
249+  BEEE 83               add a,e
250+  BEEF C3 FE BE         jp player_drawplayer2
251+  BEF2              player_drawplayer6:             ; GETTING THE DIG FRAM
252+  BEF2 E6 01            and 1                       ; check for odd
253+  BEF4 C6 0A            add 10                      ; add 10, to get either 10 or 11
254+  BEF6 C3 FE BE         jp player_drawplayer2
255+  BEF9              player_drawplayer1:             ; GET THE NORMAL FRAME
256+  BEF9 3A 99 BD         ld a,(player+2)             ; digging, get the current direction again, because want all four
257+  BEFC C6 06            add a,6                     ; add direction to 6 to get frame
258+  BEFE              player_drawplayer2:             ; WORK OUT THE FRAME
259+  BEFE 07               rlca
260+  BEFF 07               rlca
261+  BF00 07               rlca                        ; multiply by eight
262+  BF01 6F               ld l,a
263+  BF02 26 00            ld h,0
264+  BF04 11 B3 B6         ld de,player_sprite
265+  BF07 19               add hl,de                   ; load hl with the location of the player sprite data
266+  BF08              player_drawplayer7:             ; DRAW THE PlAYER
267+  BF08 ED 4B 97 BD      ld bc,(player)              ; load bc with the start coords
268+  BF0C CD 2D AA         call sprites_drawsprite     ; call the routine to draw the sprite
269+  BF0F                  ;call player_storeupdatedlines ; log updated rows
270+  BF0F C9               ret
271+  BF10              ;
272+  BF10              ; CRUSHING
273+  BF10              ;
274+  BF10              player_drawplayer3:
275+  BF10 21 A3 BD         ld hl,player+12
276+  BF13 7E               ld a,(hl)                  ; crushing, so get the current anim flag
277+  BF14 FE 00            cp 0
278+  BF16 C2 1F BF         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
279+  BF19 3E 64            ld a,100
280+  BF1B 77               ld (hl),a                   ; otherwise, load up the anim frames
281+  BF1C C3 E3 BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
282+  BF1F              player_drawplayer5:
283+  BF1F 3D               dec a
284+  BF20 77               ld (hl),a
285+  BF21 FE 00            cp 0
286+  BF23 CC A2 BE         call z,player_killplayer     ; final animation, so kill the player
287+  BF26 FE 0A            cp 10                         ; play the sound
288+  BF28 CC E8 AF         call z, sound_rockfell
289+  BF2B FE 14            cp 20                        ; check if we should move the rock
290+  BF2D C2 41 BF         jp nz,player_drawplayer8
291+  BF30 D9               exx
292+  BF31 F5               push af
293+  BF32 ED 4B 04 C3      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
294+  BF36 21 FF B5         ld hl,sprites+72
295+  BF39 CD 2D AA         call sprites_drawsprite     ; draw a rock over current
296+  BF3C F1               pop af
297+  BF3D D9               exx
298+  BF3E C3 F2 BE         jp player_drawplayer6       ; continue drawing player
299+  BF41              player_drawplayer8:
300+  BF41 FE 14            cp 20
301+  BF43 D2 F2 BE         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
302+  BF46 ED 4B 97 BD      ld bc,(player)
303+  BF4A CD 5B A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
304+  BF4D 3E 42            ld a,66             ; load red
305+  BF4F CD B3 A9         call screen_setattr
306+  BF52 21 FF B5         ld hl,sprites+72            ; otherwise, player is rock
307+  BF55 C3 08 BF         jp player_drawplayer7
308+  BF58              ;
309+  BF58              ; FALLING
310+  BF58              ;
311+  BF58              player_drawplayer9:             ; player is falling into the pit
312+  BF58 21 A3 BD         ld hl,player+12
313+  BF5B 7E               ld a,(hl)                   ; get the frames
314+  BF5C FE 00            cp 0
315+  BF5E C2 67 BF         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
316+  BF61 3E 50            ld a,80
317+  BF63 77               ld (hl),a                   ; otherwise, load up the anim frames
318+  BF64 C3 E3 BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
319+  BF67              player_drawplayer10:
320+  BF67 3D               dec a
321+  BF68 77               ld (hl),a
322+  BF69 FE 00            cp 0
323+  BF6B CC A2 BE         call z,player_killplayer     ; final frame, so kill the player
324+  BF6E 3A 9A BD         ld a,(player+3)
325+  BF71 C3 FE BE         jp player_drawplayer2
326+  BF74              ;
327+  BF74              ; ROBOT KILLED
328+  BF74              ;
329+  BF74              player_drawplayer12:
330+  BF74 21 A3 BD         ld hl,player+12
331+  BF77 7E               ld a,(hl)                   ; get the frames
332+  BF78 FE 00            cp 0
333+  BF7A C2 83 BF         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
334+  BF7D 3E C8            ld a,200
335+  BF7F 77               ld (hl),a                   ; otherwise, load up the anim frames
336+  BF80 C3 E3 BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
337+  BF83              player_drawplayer13:
338+  BF83 3D               dec a
339+  BF84 77               ld (hl),a
340+  BF85 FE 00            cp 0
341+  BF87 CC A2 BE         call z,player_killplayer     ; final frame, so kill the player
342+  BF8A 3A 9A BD         ld a,(player+3)
343+  BF8D C3 FE BE         jp player_drawplayer2
344+  BF90
345+  BF90              ;
346+  BF90              ; Runs after the player just moved. Changes animation frame if required
347+  BF90              ;
348+  BF90              player_justmoved:
349+  BF90 D9               exx
350+  BF91 3A 9B BD         ld a,(player+4)             ; get the transition count
351+  BF94 FE 00            cp 0
352+  BF96 CA 9C BF         jp z, player_justmoved2     ; if zero reset and change the frame
353+  BF99 C3 B6 BF         jp player_justmoved1       ; otherwise decrease and continue
354+  BF9C              player_justmoved2:
355+  BF9C                  ; reset and change frame in here
356+  BF9C 3E 01            ld a,1
357+  BF9E 32 9B BD         ld (player+4),a            ; reset back to whatever
358+  BFA1 3A 9A BD         ld a,(player+3)             ; load the frame
359+  BFA4 FE 03            cp 3                       ; flip between 3 and 0
360+  BFA6 C2 AE BF         jp nz, player_justmoved4
361+  BFA9 3E 00            ld a,0
362+  BFAB C3 B0 BF         jp player_justmoved5
363+  BFAE              player_justmoved4:
364+  BFAE 3E 03            ld a,3
365+  BFB0              player_justmoved5:
366+  BFB0 32 9A BD         ld (player+3),a           ; save back
367+  BFB3 C3 BA BF         jp player_justmoved3
368+  BFB6              player_justmoved1:
369+  BFB6                  ; decrease count
370+  BFB6 3D               dec a
371+  BFB7 32 9B BD         ld (player+4),a
372+  BFBA              player_justmoved3:
373+  BFBA D9               exx;
374+  BFBB C9               ret
375+  BFBC
376+  BFBC              ;
377+  BFBC              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
378+  BFBC              ; Outputs:
379+  BFBC              ; a - 1 for completed level
380+  BFBC              player_checkforexit:
381+  BFBC ED 4B 97 BD      ld bc,(player)                 ; get player coords
382+  BFC0 ED 5B 22 80      ld de,(init_coord)             ; get start coords
383+  BFC4 78               ld a,b
384+  BFC5 BA               cp d                         ; compare horiz
385+  BFC6 C2 D1 BF         jp nz,player_checkforexit1
386+  BFC9 79               ld a,c
387+  BFCA BB               cp e                        ; compare vert
388+  BFCB C2 D1 BF         jp nz,player_checkforexit1
389+  BFCE              player_checkforexit0:
390+  BFCE 3E 01            ld a,1                       ; hasn't completed
391+  BFD0 C9               ret
392+  BFD1              player_checkforexit1:
393+  BFD1 3E 00            ld a,0                       ; has completed
394+  BFD3 C9               ret
# file closed: game/player.asm
 41   BFD4                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  BFD4              ;
  2+  BFD4              ; Ship initial position: vert,horiz
  3+  BFD4              ;
  4+  BFD4              ship_initpos:
  5+  BFD4 00 24            defb 0,36
  6+  BFD6              ship_initpos2:
  7+  BFD6 00 00            defb 0,0
  8+  BFD8              ship_frame:
  9+  BFD8 00               defb 0
 10+  BFD9              ;
 11+  BFD9              ; The current memory location
 12+  BFD9              ;
 13+  BFD9              ship_current_sprite:
 14+  BFD9 00 00            defb 0,0
 15+  BFDB
 16+  BFDB              ship_current_coords:
 17+  BFDB 00 00            defb 0,0
 18+  BFDD
 19+  BFDD              ship_process:
 20+  BFDD 3A A2 BD         ld a,(player+11)
 21+  BFE0 FE 02            cp 2                        ; has the player been killed by tank?
 22+  BFE2 C0               ret nz                      ; do nothing if not
 23+  BFE3 CD 2B BB         call control_scroll_up           ; make sure the screen is on the top screen
 24+  BFE6 CD 55 C0         call ship_takeoff           ; bye bye
 25+  BFE9 CD A2 BE         call player_killplayer      ; killed
 26+  BFEC 06 32            ld b,50
 27+  BFEE CD 9B 80         call utilities_pauseforframes
 28+  BFF1 C9               ret
 29+  BFF2
 30+  BFF2              ;
 31+  BFF2              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  BFF2              ;
 33+  BFF2              ship_land:
 34+  BFF2 ED 4B D4 BF      ld bc,(ship_initpos)
 35+  BFF6 ED 43 D6 BF      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  BFFA 1E 00            ld e,0                      ; store a flag to track first time round
 37+  BFFC 06 09            ld b,9                      ; move down 8 pixels
 38+  BFFE              ship_land0:
 39+  BFFE C5               push bc
 40+  BFFF 7B               ld a,e
 41+  C000 D5               push de                     ; store de for next time round
 42+  C001 FE 01            cp 1                        ; check first time flag
 43+  C003 C2 18 C0         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  C006 CD 9D C0         call ship_draw_full         ; delete old one
 45+  C009 CD 81 C0         call ship_change_frame      ; increment the frame
 46+  C00C ED 4B D6 BF      ld bc,(ship_initpos2)       ; get the current coords
 47+  C010 81 C6 01         add c,1                     ; move down one pixels
 48+  C013 4F               ld c,a
 49+  C014 ED 43 D6 BF      ld (ship_initpos2),bc
 50+  C018              ship_land1:
 51+  C018 CD 9D C0         call ship_draw_full         ; draw the ship
 52+  C01B CD 96 C0         call ship_draw_screen
 53+  C01E D1               pop de
 54+  C01F 1E 01            ld e,1
 55+  C021 C1               pop bc
 56+  C022 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  C024                  ; done moving down
 58+  C024                  ; now move across
 59+  C024 CD C6 BE         call player_drawplayer      ; draw player
 60+  C027 CD 9D C0         call ship_draw_full         ; delete old one
 61+  C02A 1E 00            ld e,0                      ; store a flag to track first time round
 62+  C02C 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  C02E              ship_land3:
 64+  C02E C5               push bc
 65+  C02F 7B               ld a,e
 66+  C030 D5               push de                     ; store de for next time round
 67+  C031 FE 01            cp 1                        ; check first time flag
 68+  C033 C2 48 C0         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  C036 CD 9D C0         call ship_draw_full         ; delete old one
 70+  C039 CD 81 C0         call ship_change_frame      ; increment the frame
 71+  C03C ED 4B D6 BF      ld bc,(ship_initpos2)       ; get the current coords
 72+  C040 78               ld a,b
 73+  C041 D6 01            sub 1                       ; move back one pixels
 74+  C043 47               ld b,a
 75+  C044 ED 43 D6 BF      ld (ship_initpos2),bc
 76+  C048              ship_land2:
 77+  C048 CD 9D C0         call ship_draw_full         ; draw the ship
 78+  C04B CD 96 C0         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  C04E D1               pop de
 80+  C04F 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  C051 C1               pop bc
 82+  C052 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  C054 C9               ret
 84+  C055
 85+  C055              ;
 86+  C055              ;   Take off the ship
 87+  C055              ;
 88+  C055              ship_takeoff:
 89+  C055 1E 01            ld e,1                      ; store a flag to track first time round
 90+  C057 06 08            ld b,8                      ; move up 8 pixels
 91+  C059              ship_takeoff0:
 92+  C059 C5               push bc
 93+  C05A 7B               ld a,e
 94+  C05B D5               push de                     ; store de for next time round
 95+  C05C FE 01            cp 1                        ; check first time flag
 96+  C05E C2 74 C0         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  C061 ED 4B D6 BF      ld bc,(ship_initpos2)       ; get the current coords
 98+  C065 CD 9D C0         call ship_draw_full         ; delete old one
 99+  C068 CD 81 C0         call ship_change_frame      ; increment the frame
100+  C06B ED 4B D6 BF      ld bc,(ship_initpos2)       ; get the current coords
101+  C06F 0D               dec c                       ; move up one pixels
102+  C070 ED 43 D6 BF      ld (ship_initpos2),bc
103+  C074              ship_takeoff1:
104+  C074 CD 9D C0         call ship_draw_full         ; draw the ship
105+  C077 CD 96 C0         call ship_draw_screen
106+  C07A D1               pop de
107+  C07B 1E 01            ld e,1
108+  C07D C1               pop bc
109+  C07E 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  C080                  ; done moving up
111+  C080 C9               ret
112+  C081
113+  C081              ;
114+  C081              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  C081              ;
116+  C081              ship_change_frame:
117+  C081 F5               push af
118+  C082 3A D8 BF         ld a,(ship_frame)
119+  C085 FE 00            cp 0
120+  C087 CA 8F C0         jp z,ship_change_frame0
121+  C08A 3E 00            ld a,0                      ; flip to 0
122+  C08C C3 91 C0         jp ship_change_frame1
123+  C08F              ship_change_frame0:
124+  C08F 3E 20            ld a,32                      ; flip to 32
125+  C091              ship_change_frame1:
126+  C091 32 D8 BF         ld (ship_frame),a            ; save the frame
127+  C094 F1               pop af
128+  C095 C9               ret
129+  C096
130+  C096              ship_draw_screen:
131+  C096 76               halt
132+  C097 F3               di
133+  C098 CD 32 A7         call buffer_buffertoscreen  ; copy buffer to screen
134+  C09B FB               ei                          ; enable interupts
135+  C09C C9               ret
136+  C09D
137+  C09D              ship_draw_full:
138+  C09D 21 23 B7         ld hl,ship_sprite
139+  C0A0 ED 4B D6 BF      ld bc,(ship_initpos2)         ; load bc with the start coords
140+  C0A4 22 D9 BF         ld (ship_current_sprite),hl  ; put into memory
141+  C0A7 ED 43 DB BF      ld (ship_current_coords),bc  ; put into memory
142+  C0AB CD CA C0         call ship_draw
143+  C0AE 08               ex af,af'
144+  C0AF 3A D8 BF         ld a,(ship_frame)            ; get the animation frame
145+  C0B2 16 00            ld d,0
146+  C0B4 5F               ld e,a
147+  C0B5 19               add hl,de
148+  C0B6 22 D9 BF         ld (ship_current_sprite),hl  ; put into memory
149+  C0B9 08               ex af,af'
150+  C0BA ED 4B D6 BF      ld bc,(ship_initpos2)         ; load bc with the start coords
151+  C0BE 81 C6 08         add c,8                      ; move one line down
152+  C0C1 4F               ld c,a
153+  C0C2 ED 43 DB BF      ld (ship_current_coords),bc  ; put into memory
154+  C0C6 CD CA C0         call ship_draw
155+  C0C9 C9               ret
156+  C0CA
157+  C0CA              ;
158+  C0CA              ; Draw the ship
159+  C0CA              ; Inputs:
160+  C0CA              ; None, all in memory
161+  C0CA              ;
162+  C0CA              ship_draw:
163+  C0CA 3E 04            ld a,4                              ; 4 pieces per half
164+  C0CC              ship_draw0:
165+  C0CC F5               push af
166+  C0CD 2A D9 BF         ld hl,(ship_current_sprite)
167+  C0D0 ED 4B DB BF      ld bc,(ship_current_coords)         ; load bc with the start coords
168+  C0D4 CD 2D AA         call sprites_drawsprite
169+  C0D7 2A D9 BF         ld hl,(ship_current_sprite)
170+  C0DA ED 4B DB BF      ld bc,(ship_current_coords)         ; load bc with the start coords
171+  C0DE 11 08 00         ld de,8
172+  C0E1 19               add hl,de
173+  C0E2 80 C6 08         add b,8
174+  C0E5 47               ld b,a
175+  C0E6 22 D9 BF         ld (ship_current_sprite),hl         ; put into memory
176+  C0E9 ED 43 DB BF      ld (ship_current_coords),bc         ; put into memory
177+  C0ED F1               pop af
178+  C0EE 3D               dec a
179+  C0EF FE 00            cp 0
180+  C0F1 C2 CC C0         jp nz,ship_draw0
181+  C0F4
182+  C0F4 C9               ret
183+  C0F5
# file closed: game/ship.asm
 42   C0F5                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  C0F5              ;
  2+  C0F5              ; tank initial position: vert,horiz
  3+  C0F5              ;
  4+  C0F5              tank_initpos:
  5+  C0F5 10 D0            defb 16,208
  6+  C0F7              tank_initpos2:
  7+  C0F7 00 00            defb 0,0
  8+  C0F9              tank_frame:
  9+  C0F9 00               defb 0
 10+  C0FA              tank_anim:
 11+  C0FA 11               defb 17
 12+  C0FB
 13+  C0FB              ;
 14+  C0FB              ; The damage countdown
 15+  C0FB              ;
 16+  C0FB              tank_currentdamage:
 17+  C0FB F0               defb 240
 18+  C0FC
 19+  C0FC              ;
 20+  C0FC              ; The damage coordinate
 21+  C0FC              ;
 22+  C0FC              tank_currentdamagecoord:
 23+  C0FC 16 02            defb 22,2
 24+  C0FE
 25+  C0FE              ;
 26+  C0FE              ; Controls when the tank shoots
 27+  C0FE              ;
 28+  C0FE              tank_count:
 29+  C0FE 00               defb 0
 30+  C0FF
 31+  C0FF              ;
 32+  C0FF              ; Holds the block number of the current damage sprite
 33+  C0FF              ;
 34+  C0FF              tank_damageframe:
 35+  C0FF 00               defb 0
 36+  C100
 37+  C100              ;
 38+  C100              ; The current memory location
 39+  C100              ;
 40+  C100              tank_current_sprite:
 41+  C100 00 00            defb 0,0
 42+  C102
 43+  C102              tank_current_coords:
 44+  C102 00 00            defb 0,0
 45+  C104
 46+  C104              ;
 47+  C104              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  C104              ;
 49+  C104              tank_missile_displayed:
 50+  C104 00               defb 0
 51+  C105
 52+  C105              ;
 53+  C105              ; Initialise the tank
 54+  C105              ;
 55+  C105              tank_init:
 56+  C105 ED 4B F5 C0      ld bc,(tank_initpos)
 57+  C109 ED 43 F7 C0      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  C10D 21 F9 C0         ld hl,tank_frame
 59+  C110 36 00            ld (hl),0
 60+  C112 21 FA C0         ld hl,tank_anim
 61+  C115 36 11            ld (hl),17
 62+  C117 21 FF C0         ld hl,tank_damageframe              ; reset tank
 63+  C11A 36 00            ld (hl),0
 64+  C11C 21 FE C0         ld hl,tank_count
 65+  C11F 36 00            ld (hl),0
 66+  C121 21 FB C0         ld hl,tank_currentdamage
 67+  C124 36 F0            ld (hl),240
 68+  C126 21 FC C0         ld hl,tank_currentdamagecoord
 69+  C129 36 16            ld (hl),22
 70+  C12B 23               inc hl
 71+  C12C 36 02            ld (hl),2
 72+  C12E 21 04 C1         ld hl,tank_missile_displayed
 73+  C131 36 00            ld (hl),0
 74+  C133
 75+  C133 C9               ret
 76+  C134
 77+  C134              ;
 78+  C134              ;   Draw and move the tank
 79+  C134              ;   Start processing at frame 200
 80+  C134              ;   Don't move if anim is zero
 81+  C134              ;   Decrement frame if moved
 82+  C134              ;
 83+  C134              tank_process:
 84+  C134 3A FA C0         ld a,(tank_anim)
 85+  C137 FE 00            cp 0
 86+  C139 C2 40 C1         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  C13C CD 51 C1         call tank_fire
 88+  C13F C9               ret
 89+  C140              tank_process0:
 90+  C140 CD 86 BD         call game_getcurrentframe   ; get the current frame number into a
 91+  C143 FE 4B            cp 75
 92+  C145 D8               ret c                       ; return if the frame number is below 100
 93+  C146 CD 77 C2         call tank_move              ; move tank if not
 94+  C149 3A FA C0         ld a,(tank_anim)
 95+  C14C 3D               dec a
 96+  C14D 32 FA C0         ld (tank_anim),a            ; decrease the anim count
 97+  C150 C9               ret
 98+  C151
 99+  C151              ;
100+  C151              ; Fires the tank
101+  C151              ;
102+  C151              tank_fire:
103+  C151 3A FE C0         ld a,(tank_count)            ; if not, don't do anything
104+  C154 3C               inc a                        ; increment
105+  C155 FE 32            cp 50                        ; have we reached fifty
106+  C157 C2 5C C1         jp nz,tank_fire0
107+  C15A 3E 00            ld a,0                       ; reset if reached fifty
108+  C15C              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  C15C 32 FE C0         ld (tank_count),a            ; store tank count
110+  C15F FE 00            cp 0
111+  C161 CA 82 C1         jp z,tank_fire7              ; If this is zero, fire
112+  C164 3A 04 C1         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  C167 FE 00            cp 0
114+  C169 C8               ret z                       ; don't do anything if not
115+  C16A CD 31 C2         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  C16D 3E 00            ld a,0                       ; reset the flag
117+  C16F 32 04 C1         ld (tank_missile_displayed),a
118+  C172 3E 02            ld a,2
119+  C174 ED 4B FC C0      ld bc,(tank_currentdamagecoord)
120+  C178 0C               inc c
121+  C179 0C               inc c
122+  C17A ED 43 44 AB      ld (origcoords),bc
123+  C17E CD 57 A6         call buffer_marklineforupdate
124+  C181 C9               ret                        ; only shoot if we're on 0
125+  C182              tank_fire7:
126+  C182 3A FB C0         ld a,(tank_currentdamage)    ; get the damage countdown
127+  C185 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
128+  C187 C2 BD C1         jp nz,tank_fire1            ; not, so just do a normal frame
129+  C18A ED 4B FC C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
130+  C18E 79               ld a,c
131+  C18F FE 0A            cp 10
132+  C191 C2 98 C1         jp nz, tank_fire6
133+  C194 CD 69 C2         call tank_killedbytank      ; we're through, so the player has died. Kill them.
134+  C197 C9               ret                         ; return if we're through the mountain
135+  C198              tank_fire6:
136+  C198 3E 0F            ld a,15
137+  C19A 32 FF C0         ld (tank_damageframe),a     ; reset the damage frame
138+  C19D 21 B7 B5         ld hl,sprites               ; location of the empty block
139+  C1A0 CD 85 A9         call screen_showchar        ; show this character here
140+  C1A3 ED 4B FC C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
141+  C1A7 05               dec b                       ; look one above
142+  C1A8 CD E9 A9         call screen_ischarempty     ; check if it is empty
143+  C1AB ED 4B FC C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
144+  C1AF FE 01            cp 1
145+  C1B1 C2 F4 C1         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
146+  C1B4 ED 4B FC C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  C1B8 0D               dec c
148+  C1B9 ED 43 FC C0      ld (tank_currentdamagecoord),bc ; store the coord
149+  C1BD              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
150+  C1BD ED 4B FC C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
151+  C1C1 3A FB C0         ld a,(tank_currentdamage)    ; get the damage countdown
152+  C1C4 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
153+  C1C6 C2 D1 C1         jp nz, tank_fire5
154+  C1C9 CD 19 AA         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
155+  C1CC FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
156+  C1CE C2 12 C2         jp nz,tank_fire3            ; if it's a slope, handle this differently
157+  C1D1              tank_fire5:
158+  C1D1 3A FF C0         ld a,(tank_damageframe)
159+  C1D4 CD A8 A9         call screen_getblock        ; get the block data into hl
160+  C1D7 CD 85 A9         call screen_showchar        ; show this character here
161+  C1DA 3A FF C0         ld a,(tank_damageframe)
162+  C1DD 3C               inc a
163+  C1DE 32 FF C0         ld (tank_damageframe),a     ; increment the damage block and store
164+  C1E1 3A FB C0         ld a,(tank_currentdamage)    ; get the damage countdown
165+  C1E4 3D               dec a
166+  C1E5 3D               dec a
167+  C1E6 32 FB C0         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
168+  C1E9 3A 04 C1         ld a,(tank_missile_displayed) ; is the missile displaying?
169+  C1EC FE 00            cp 0
170+  C1EE CC 31 C2         call z, tank_missilegraphic
171+  C1F1 C3 1B C2         jp tank_fire4
172+  C1F4              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
173+  C1F4 05               dec b
174+  C1F5 C5               push bc
175+  C1F6 CD 02 AA         call screen_copyblockdown       ; copy the block down
176+  C1F9 ED 4B FC C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
177+  C1FD C1               pop bc                      ; get the coord we just checked back
178+  C1FE 78               ld a,b
179+  C1FF FE 00            cp 0
180+  C201 CA BD C1         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
181+  C204 C5               push bc
182+  C205 05               dec b
183+  C206 CD E9 A9         call screen_ischarempty     ; check if it is empty
184+  C209 C1               pop bc
185+  C20A FE 01            cp 1                        ; if empty
186+  C20C C2 F4 C1         jp nz, tank_fire2            ; copy another one down
187+  C20F C3 BD C1         jp tank_fire1               ; otherwise, return to main thread
188+  C212              tank_fire3:                      ; dealing with slopes
189+  C212 3A FB C0         ld a,(tank_currentdamage)    ; get the damage countdown
190+  C215 06 08            ld b,8
191+  C217 90               sub b                        ; special case for slopes
192+  C218 32 FB C0         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
193+  C21B              tank_fire4:                     ; TIDY UP
194+  C21B ED 4B FC C0      ld bc,(tank_currentdamagecoord)
195+  C21F ED 43 44 AB      ld (origcoords),bc
196+  C223 CD 57 A6         call buffer_marklineforupdate
197+  C226 3E 01            ld a,1
198+  C228 CD 57 A6         call buffer_marklineforupdate
199+  C22B 3E 02            ld a,2
200+  C22D CD 57 A6         call buffer_marklineforupdate
201+  C230 C9               ret
202+  C231
203+  C231              ;
204+  C231              ; Displays or hides the missile graphic, and changes the gun
205+  C231              ;
206+  C231              tank_missilegraphic:
207+  C231 3A 04 C1         ld a,(tank_missile_displayed)
208+  C234 FE 00            cp 0
209+  C236 C2 3E C2         jp nz,tank_missilegraphic0
210+  C239 3E 13            ld a,19
211+  C23B C3 40 C2         jp tank_missilegraphic1
212+  C23E              tank_missilegraphic0:
213+  C23E 3E 00            ld a,0
214+  C240              tank_missilegraphic1:
215+  C240 32 04 C1         ld (tank_missile_displayed),a ; store the flipped graphic
216+  C243 ED 4B FC C0      ld bc,(tank_currentdamagecoord)
217+  C247 0C               inc c
218+  C248 0C               inc c                   ; print the graphic 2 spaces right
219+  C249 CD A8 A9         call screen_getblock        ; get the block data into hl
220+  C24C CD 85 A9         call screen_showchar        ; show this character here
221+  C24F 06 02            ld b,2
222+  C251 0E 18            ld c,24                     ; set gunbarrel coords
223+  C253 11 00 00         ld de,0
224+  C256 21 83 B7         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
225+  C259 3A 04 C1         ld a,(tank_missile_displayed)
226+  C25C FE 00            cp 0
227+  C25E CA 64 C2         jp z,tank_missilegraphic2
228+  C261 11 40 00         ld de,64
229+  C264              tank_missilegraphic2:
230+  C264 19               add hl,de                   ; work out missile graphic
231+  C265 CD 85 A9         call screen_showchar        ; show this character here
232+  C268 C9               ret
233+  C269
234+  C269              ;
235+  C269              ; Deal with the player being killed by the tank
236+  C269              ;
237+  C269              tank_killedbytank:
238+  C269 ED 4B FC C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
239+  C26D 21 B7 B5         ld hl,sprites                   ; empty sprite
240+  C270 CD 85 A9         call screen_showchar            ; hide the last piece of dirt
241+  C273 CD AE BE         call player_tankkillplayer
242+  C276 C9               ret
243+  C277
244+  C277              tank_move:
245+  C277 ED 4B F7 C0      ld bc,(tank_initpos2)
246+  C27B C5               push bc
247+  C27C 3A FA C0         ld a,(tank_anim)
248+  C27F FE 11            cp 17                       ; check first time flag
249+  C281 CA 93 C2         jp z,tank_move1             ; don't draw over previous one if first time
250+  C284 CD 98 C2         call tank_draw_full         ; delete old one
251+  C287 ED 4B F7 C0      ld bc,(tank_initpos2)       ; get the current coords
252+  C28B 78               ld a,b
253+  C28C D6 01            sub 1                       ; move back one pixels
254+  C28E 47               ld b,a
255+  C28F ED 43 F7 C0      ld (tank_initpos2),bc
256+  C293              tank_move1:
257+  C293 CD 98 C2         call tank_draw_full         ; draw the tank
258+  C296 C1               pop bc
259+  C297 C9               ret
260+  C298
261+  C298              tank_draw_full:
262+  C298 21 83 B7         ld hl,tank_sprite
263+  C29B ED 4B F7 C0      ld bc,(tank_initpos2)         ; load bc with the start coords
264+  C29F 22 00 C1         ld (tank_current_sprite),hl  ; put into memory
265+  C2A2 ED 43 02 C1      ld (tank_current_coords),bc  ; put into memory
266+  C2A6 CD C5 C2         call tank_draw
267+  C2A9 08               ex af,af'
268+  C2AA 3A F9 C0         ld a,(tank_frame)            ; get the animation frame
269+  C2AD 16 00            ld d,0
270+  C2AF 5F               ld e,a
271+  C2B0 19               add hl,de
272+  C2B1 22 00 C1         ld (tank_current_sprite),hl  ; put into memory
273+  C2B4 08               ex af,af'
274+  C2B5 ED 4B F7 C0      ld bc,(tank_initpos2)         ; load bc with the start coords
275+  C2B9 81 C6 08         add c,8                      ; move one line down
276+  C2BC 4F               ld c,a
277+  C2BD ED 43 02 C1      ld (tank_current_coords),bc  ; put into memory
278+  C2C1 CD C5 C2         call tank_draw
279+  C2C4 C9               ret
280+  C2C5
281+  C2C5              ;
282+  C2C5              ; Draw the tank
283+  C2C5              ; Inputs:
284+  C2C5              ; None, all in memory
285+  C2C5              ;
286+  C2C5              tank_draw:
287+  C2C5 3E 04            ld a,4                              ; 4 pieces per half
288+  C2C7              tank_draw0:
289+  C2C7 F5               push af
290+  C2C8 2A 00 C1         ld hl,(tank_current_sprite)
291+  C2CB ED 4B 02 C1      ld bc,(tank_current_coords)         ; load bc with the start coords
292+  C2CF CD 2D AA         call sprites_drawsprite
293+  C2D2 2A 00 C1         ld hl,(tank_current_sprite)
294+  C2D5 ED 4B 02 C1      ld bc,(tank_current_coords)         ; load bc with the start coords
295+  C2D9 11 08 00         ld de,8
296+  C2DC 19               add hl,de
297+  C2DD 80 C6 08         add b,8
298+  C2E0 47               ld b,a
299+  C2E1 22 00 C1         ld (tank_current_sprite),hl         ; put into memory
300+  C2E4 ED 43 02 C1      ld (tank_current_coords),bc         ; put into memory
301+  C2E8 F1               pop af
302+  C2E9 3D               dec a
303+  C2EA FE 00            cp 0
304+  C2EC C2 C7 C2         jp nz,tank_draw0
305+  C2EF
306+  C2EF C9               ret
307+  C2F0
# file closed: game/tank.asm
 43   C2F0                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  C2F0              ;
  2+  C2F0              ; A structure of falling rocks
  3+  C2F0              ; Assume we'll never have more than 4 falling at any one time
  4+  C2F0              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  C2F0              ;
  6+  C2F0              rocks_falling:
  7+  C2F0 00 00 00 00      defb 0,0,0,0
  8+  C2F4 00 00 00 00      defb 0,0,0,0
  9+  C2F8 00 00 00 00      defb 0,0,0,0
 10+  C2FC 00 00 00 00      defb 0,0,0,0
 11+  C300
 12+  C300              rocks_tmp:
 13+  C300 00               defb 0
 14+  C301
 15+  C301              rocks_tmp2:
 16+  C301 00 00            defb 0,0
 17+  C303
 18+  C303              ;
 19+  C303              ; The number of frames to wobble for
 20+  C303              ; Must always be 10 more than the number of frames a player digs
 21+  C303              ;
 22+  C303              rocks_numberofframestowobble:
 23+  C303 14               defb 20
 24+  C304
 25+  C304              ;
 26+  C304              ; Coords of the rock that killed us
 27+  C304              ;
 28+  C304              rocks_killerrock:
 29+  C304 00 00            defb 0,0
 30+  C306
 31+  C306              ;
 32+  C306              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  C306              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  C306              ; If the pixel row is not the rock bottom, stop checking.
 35+  C306              ; Inputs:
 36+  C306              ; hl- memory location
 37+  C306              ;
 38+  C306              rocks_checkforfalling:
 39+  C306 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  C307 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  C309 C2 0F C3         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  C30C CD 10 C3         call rocks_addrocktofalling ; mark the rock as falling
 43+  C30F              rocks_checkforfalling2:
 44+  C30F C9               ret
 45+  C310
 46+  C310              ;
 47+  C310              ; Adds the rock to the structure that tracks falling rocks
 48+  C310              ; Inputs:
 49+  C310              ; hl - memory location of falling rock graphic
 50+  C310              ; bc - coords of rock, c vert
 51+  C310              rocks_addrocktofalling:
 52+  C310 C5               push bc             ; store the coords
 53+  C311 11 F0 C2         ld de,rocks_falling
 54+  C314 06 04            ld b,4              ; number of possible falling rocks
 55+  C316              rocks_addrocktofalling0:
 56+  C316 13               inc de
 57+  C317                  ;inc de
 58+  C317 13               inc de              ; move three along to get the state
 59+  C318 1A               ld a,(de)           ; load the state
 60+  C319 FE 00            cp 0                ; check if this is not falling
 61+  C31B C2 32 C3         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  C31E 13               inc de              ; move to frame
 63+  C31F 3A 03 C3         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  C322 12               ld (de),a
 65+  C323 1B               dec de              ; move de back to state
 66+  C324 3E 02            ld a,2
 67+  C326 12               ld (de),a           ; set the state to wobbling
 68+  C327 1B               dec de              ; move back coords
 69+  C328 C1               pop bc              ; get back coords
 70+  C329 78               ld a,b
 71+  C32A 12               ld (de),a           ; store the vertical
 72+  C32B 1B               dec de
 73+  C32C 79               ld a,c
 74+  C32D 12               ld (de),a           ; store the horizontal
 75+  C32E C5               push bc
 76+  C32F C3 36 C3         jp rocks_addrocktofalling2 ; done
 77+  C332              rocks_addrocktofalling1:
 78+  C332 13               inc de
 79+  C333 13               inc de              ; move memory along to next rock
 80+  C334 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  C336              rocks_addrocktofalling2: ; done, return
 82+  C336 C1               pop bc              ; to tidy up
 83+  C337 C9               ret
 84+  C338
 85+  C338              ;
 86+  C338              ; Processes any falling rocks
 87+  C338              ;
 88+  C338              rocks_processrocks:
 89+  C338 DD 21 F0 C2      ld ix,rocks_falling
 90+  C33C 06 04            ld b,4              ; the number of rocks to check
 91+  C33E              rocks_processrocks0:
 92+  C33E C5               push bc             ; store loop count
 93+  C33F DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  C343 46 01
 94+  C345 DD 23            inc ix
 95+  C347 DD 23            inc ix              ; move to the state
 96+  C349 DD 7E 00         ld a,(ix)           ; load the state into a
 97+  C34C FE 00            cp 0
 98+  C34E CA 6F C3         jp z,rocks_processrocks3 ; if not falling, check next
 99+  C351 FE 02            cp 2
100+  C353 C2 63 C3         jp nz, rocks_processrocks2
101+  C356                  ; we're wobbling
102+  C356 DD 23            inc ix              ; get frame number for wobble
103+  C358 DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  C35B CD 32 C4         call rocks_wobble
105+  C35E DD 23            inc ix              ; increment for next
106+  C360 C3 73 C3         jp rocks_processrocks1  ; do next rock
107+  C363              rocks_processrocks2:
108+  C363                  ; we're falling
109+  C363 C5               push bc
110+  C364 CD 77 C3         call rocks_fall
111+  C367 C1               pop bc
112+  C368 DD 23            inc ix
113+  C36A DD 23            inc ix              ; inc ix to get to next
114+  C36C C3 73 C3         jp rocks_processrocks1
115+  C36F              rocks_processrocks3:
116+  C36F DD 23            inc ix
117+  C371 DD 23            inc ix
118+  C373              rocks_processrocks1:
119+  C373 C1               pop bc              ; get loop count back
120+  C374 10 C8            djnz rocks_processrocks0
121+  C376 C9               ret
122+  C377
123+  C377              ;
124+  C377              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  C377              ; bc - coord of current rock graphic on screen
126+  C377              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  C377              ;
128+  C377              rocks_fall:
129+  C377 DD 2B            dec ix
130+  C379 DD 2B            dec ix              ; decrease ix back to coords
131+  C37B ED 43 01 C3      ld (rocks_tmp2),bc  ; store original coords
132+  C37F 3E 03            ld a,3              ; move this number of pixels
133+  C381              rocks_fall1:
134+  C381 32 00 C3         ld (rocks_tmp),a    ; store loop counter
135+  C384 DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  C388 46 01
136+  C38A CD 22 AB         call sprites_scadd  ; get the memory of the coords into de
137+  C38D 14               inc d               ; add 256 to get next row
138+  C38E 1A               ld a,(de)           ; get the contents of the next row
139+  C38F FE 00            cp 0
140+  C391 C2 F1 C3         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  C394 0C               inc c               ; increment the vertical
142+  C395 DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  C399 70 01
143+  C39B 79               ld a,c              ; get the vertical coord into a
144+  C39C E6 07            and 7               ; divisible by 8?
145+  C39E FE 00            cp 0
146+  C3A0 C2 BD C3         jp nz,rocks_fall4   ; if not, carry on
147+  C3A3 CD 5B A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  C3A6 3E 42            ld a,66             ; load red
149+  C3A8 CD B3 A9         call screen_setattr
150+  C3AB DD 4E 00 DD      ld bc,(ix)
150+  C3AF 46 01
151+  C3B1 79               ld a,c              ; get vertical
152+  C3B2 D6 08            sub 8               ; look up one square
153+  C3B4 4F               ld c,a              ; put a back in c
154+  C3B5 CD 5B A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  C3B8 3E 46            ld a,70             ; load yellow
156+  C3BA CD B3 A9         call screen_setattr
157+  C3BD              rocks_fall4:
158+  C3BD 3A 00 C3         ld a,(rocks_tmp)    ; get the loop counter
159+  C3C0 3D               dec a
160+  C3C1 FE 00            cp 0
161+  C3C3 C2 81 C3         jp nz,rocks_fall1   ; do another pixel if needed
162+  C3C6              rocks_fall2:
163+  C3C6 3E 09            ld a,9              ; rock graphic
164+  C3C8 ED 4B 01 C3      ld bc,(rocks_tmp2)  ; get the original coords
165+  C3CC CD A8 A9         call screen_getblock     ; get the memory into hl
166+  C3CF CD 2D AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  C3D2 3E 09            ld a,9
168+  C3D4 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  C3D8 46 01
169+  C3DA CD A8 A9         call screen_getblock     ; get the memory into hl
170+  C3DD CD 2D AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  C3E0 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  C3E4 46 01
172+  C3E6 CD 17 C4         call rocks_checkforplayer ; check to see if we hit a player
173+  C3E9 DD 23            inc ix
174+  C3EB DD 23            inc ix                  ; get ix back to state
175+  C3ED CD 07 C4         call rocks_makesound
176+  C3F0 C9               ret
177+  C3F1              rocks_fall3:
178+  C3F1 3E 00            ld a,0              ; set the state to fell
179+  C3F3 DD 77 02         ld (ix+2),a           ; store the falling state
180+  C3F6 DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  C3FA 46 01
181+  C3FC CD 5B A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  C3FF 3E 42            ld a,66             ; load magenta
183+  C401 CD B3 A9         call screen_setattr
184+  C404 C3 C6 C3         jp rocks_fall2      ; rejoin main loop
185+  C407
186+  C407              ;
187+  C407              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  C407              ;
189+  C407              rocks_makesound:
190+  C407 DD 7E 00         ld a,(ix)           ; get the state
191+  C40A FE 00            cp 0
192+  C40C C0               ret nz              ; if we haven't fallen, don't do anything
193+  C40D 21 A2 BD         ld hl,player+11
194+  C410 7E               ld a,(hl)
195+  C411 FE 01            cp 1
196+  C413 C4 E8 AF         call nz, sound_rockfell ; only make sound if didn't kill player
197+  C416 C9               ret
198+  C417
199+  C417              ;
200+  C417              ; Checks to see if the rock is hitting a player
201+  C417              ; Inputs:
202+  C417              ; bc - coords of rock we're checking
203+  C417              rocks_checkforplayer:
204+  C417 ED 5B 97 BD      ld de,(player)       ; get the player coords
205+  C41B 7B               ld a,e               ; get the vert coord first
206+  C41C 91               sub c                ; subtract the rock vertical coord from players
207+  C41D FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  C41F C0               ret nz               ; if not, hasn't hit
209+  C420 7A               ld a,d               ; get the player horiz coord
210+  C421 90               sub b                ; subtract rock coord
211+  C422 C6 07            add 7                ; add max distance
212+  C424 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  C426 DA 2A C4         jp c,rocks_checkforplayer0
214+  C429 C9               ret
215+  C42A              rocks_checkforplayer0:
216+  C42A ED 43 04 C3      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  C42E CD A8 BE         call player_crushplayer ; if so, jump out
218+  C431 C9               ret
219+  C432
220+  C432              ;
221+  C432              ; Wobbles a rocks
222+  C432              ; Inputs:
223+  C432              ; bc - coord of current rock graphic on screen
224+  C432              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  C432              ; a - wobble frame
226+  C432              rocks_wobble:
227+  C432 DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  C435 E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  C437 1E 09            ld e,9              ; this is the rock frame
230+  C439 83               add a,e             ; add the frame toggle
231+  C43A C5               push bc
232+  C43B CD A8 A9         call screen_getblock     ; get the memory into hl
233+  C43E CD 2D AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  C441 DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  C444 3D               dec a               ; decrease
236+  C445 DD 77 00         ld (ix),a           ; store
237+  C448 E6 01            and 1
238+  C44A 1E 09            ld e,9              ; this is the rock frame
239+  C44C 83               add a,e             ; add the frame toggle
240+  C44D CD A8 A9         call screen_getblock     ; get the memory into hl
241+  C450 C1               pop bc
242+  C451 CD 2D AA         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  C454 DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  C457 FE 00            cp 0
245+  C459 C0               ret nz              ; if we're not at zero, return
246+  C45A DD 2B            dec ix              ; otherwise look to state location
247+  C45C 3E 01            ld a,1              ; set the state to falling
248+  C45E DD 77 00         ld (ix),a           ; store the falling state
249+  C461 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  C463 C9               ret
251+  C464
# file closed: game/rocks.asm
 44   C464                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  C464              ;
  2+  C464              ; The score of the current player
  3+  C464              ;
  4+  C464              scores_current:
  5+  C464 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  C468 30 30 30 30
  5+  C46C FF
  6+  C46D
  7+  C46D              scores_defaultname:
  8+  C46D 2D 2D 2D         defb '---'
  9+  C470
 10+  C470              ;
 11+  C470              ; The current high score table
 12+  C470              ;
 13+  C470              scores_table:
 14+  C470 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  C474 4D 30 30 30
 14+  C478 30 30 30 FF
 15+  C47C 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  C480 4D 30 30 30
 15+  C484 30 30 30 FF
 16+  C488 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  C48C 4D 30 30 30
 16+  C490 30 30 30 FF
 17+  C494
 18+  C494              ;
 19+  C494              ; Add thousands to the score
 20+  C494              ; Inputs:
 21+  C494              ; b - number to add
 22+  C494              ;
 23+  C494              scores_addthousands:
 24+  C494 21 68 C4         ld hl,scores_current+4
 25+  C497 CD F8 C4         call scores_update
 26+  C49A C9               ret
 27+  C49B
 28+  C49B              ;
 29+  C49B              ; Add hundreds to the score
 30+  C49B              ; Inputs:
 31+  C49B              ; b - number to add
 32+  C49B              ;
 33+  C49B              scores_addhundreds:
 34+  C49B 21 69 C4         ld hl,scores_current+5
 35+  C49E CD F8 C4         call scores_update
 36+  C4A1 C9               ret
 37+  C4A2
 38+  C4A2              ;
 39+  C4A2              ; Temporary area for printing scores
 40+  C4A2              ;
 41+  C4A2              scores_printscore_tmp:
 42+  C4A2 00 00 00 00      defb 0,0,0,0,0,0,0,0,255
 42+  C4A6 00 00 00 00
 42+  C4AA FF
 43+  C4AB
 44+  C4AB              ;
 45+  C4AB              ; Prints the score to screen
 46+  C4AB              ;
 47+  C4AB              scores_printscore:
 48+  C4AB 3A 60 BD         ld a,(game_currentplayer)   ; get current player
 49+  C4AE 21 64 C4         ld hl,scores_current
 50+  C4B1 FE 01            cp 1
 51+  C4B3 C2 BB C4         jp nz, score_printscore0    ; if not player 1
 52+  C4B6 36 04            ld (hl),4       ; set position for player 1
 53+  C4B8 C3 BD C4         jp score_printscore1
 54+  C4BB              score_printscore0:
 55+  C4BB 36 16            ld (hl),22       ; set position for player 2
 56+  C4BD              score_printscore1:
 57+  C4BD CD C1 C4         call score_printscoreformatted
 58+  C4C0 C9               ret
 59+  C4C1
 60+  C4C1              ;
 61+  C4C1              ; Formats a score and prints to the top screen
 62+  C4C1              ; Inputs:
 63+  C4C1              ; hl - where is the score
 64+  C4C1              score_printscoreformatted:
 65+  C4C1 01 08 00         ld bc,8
 66+  C4C4 11 A2 C4         ld de,scores_printscore_tmp
 67+  C4C7 ED B0            ldir                        ; copy to temp
 68+  C4C9 21 A2 C4         ld hl,scores_printscore_tmp
 69+  C4CC E5 DD E1         ld ix,hl
 70+  C4CF DD 7E 02         ld a,(ix+2)
 71+  C4D2 FE 30            cp 48                   ; is it a leading zero?
 72+  C4D4 C2 E7 C4         jp nz,score_printscore2
 73+  C4D7 DD 36 02 20      ld (ix+2),32              ; load it with a space
 74+  C4DB DD 7E 03         ld a,(ix+3)
 75+  C4DE FE 30            cp 48                   ; is it a leading zero?
 76+  C4E0 C2 E7 C4         jp nz,score_printscore2
 77+  C4E3 DD 36 03 20      ld (ix+3),32              ; load it with a space
 78+  C4E7              score_printscore2:
 79+  C4E7 CD 57 85         call string_print
 80+  C4EA C9               ret
 81+  C4EB
 82+  C4EB              ;
 83+  C4EB              ; Prints both scores to screen
 84+  C4EB              ;
 85+  C4EB              scores_printscores:
 86+  C4EB 21 8E BE         ld hl,player1_score
 87+  C4EE CD C1 C4         call score_printscoreformatted
 88+  C4F1 21 97 BE         ld hl,player2_score
 89+  C4F4 CD C1 C4         call score_printscoreformatted
 90+  C4F7 C9               ret
 91+  C4F8
 92+  C4F8              ;
 93+  C4F8              ; Updates the current score.
 94+  C4F8              ; Inputs:
 95+  C4F8              ; hl - memory location of the score column
 96+  C4F8              ; b - number to add
 97+  C4F8              ;
 98+  C4F8              scores_update:
 99+  C4F8 7E               ld a,(hl)           ; current value of digit.
100+  C4F9 80               add a,b             ; add points to this digit.
101+  C4FA 77               ld (hl),a           ; place new digit back in string.
102+  C4FB FE 3A            cp 58               ; more than ASCII value '9'?
103+  C4FD D8               ret c               ; no - relax.
104+  C4FE D6 0A            sub 10              ; subtract 10.
105+  C500 77               ld (hl),a           ; put new character back in string.
106+  C501              scores_update0:
107+  C501 2B               dec hl              ; previous character in string.
108+  C502 34               inc (hl)            ; up this by one.
109+  C503 7E               ld a,(hl)           ; what's the new value?
110+  C504 FE 3A            cp 58               ; gone past ASCII nine?
111+  C506 D8               ret c               ; no, scoring done.
112+  C507 D6 0A            sub 10              ; down by ten.
113+  C509 77               ld (hl),a           ; put it back
114+  C50A C3 01 C5         jp scores_update0   ; go round again.
115+  C50D
116+  C50D
117+  C50D              ;
118+  C50D              ; Temporary area to store score
119+  C50D              ;
120+  C50D              scores_showtable_tmp:
121+  C50D 00 00 00 00      defb 0,0,0,0,0,0,0,0,0,0,0,255
121+  C511 00 00 00 00
121+  C515 00 00 00 FF
122+  C519
123+  C519              ;
124+  C519              ; Processes a score
125+  C519              ; Inputs:
126+  C519              ; hl - location on table
127+  C519              ;
128+  C519              scores_showtable_process:
129+  C519 01 0B 00         ld bc,11                     ; copy this many
130+  C51C 11 0D C5         ld de,scores_showtable_tmp
131+  C51F ED B0            ldir
132+  C521 DD 21 0D C5      ld ix,scores_showtable_tmp   ; decide whether to show five or six numbers
133+  C525 DD 7E 05         ld a,(ix+5)
134+  C528 FE 30            cp 48                        ; is this a zero?
135+  C52A C2 40 C5         jp nz,scores_showtable_process0 ; if not, show the whole thing
136+  C52D 01 05 00         ld bc,5                      ; copy this many
137+  C530 DD E5 E1         ld hl,ix
138+  C533 11 06 00         ld de,6
139+  C536 19               add hl,de                    ; move to second digit
140+  C537 54 5D            ld de,hl
141+  C539 1B               dec de
142+  C53A ED B0            ldir
143+  C53C DD 36 0A 20      ld (ix+10),32                ; stick a space at the end
144+  C540              scores_showtable_process0:
145+  C540 21 0D C5         ld hl,scores_showtable_tmp
146+  C543 CD 57 85         call string_print
147+  C546 C9               ret
148+  C547
149+  C547              ;
150+  C547              ; Displays the high score table at the bottom of the screen
151+  C547              ;
152+  C547              scores_showtable:
153+  C547 21 70 C4         ld hl, scores_table
154+  C54A CD 19 C5         call scores_showtable_process
155+  C54D 21 7C C4         ld hl, scores_table+12
156+  C550 CD 19 C5         call scores_showtable_process
157+  C553 21 88 C4         ld hl, scores_table+24
158+  C556 CD 19 C5         call scores_showtable_process
159+  C559 C9               ret
160+  C55A
161+  C55A              ;
162+  C55A              ; Place to store the current position we're checking
163+  C55A              ;
164+  C55A              scores_highscoretmp:
165+  C55A 00               defb 0
166+  C55B
167+  C55B              ;
168+  C55B              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
169+  C55B              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
170+  C55B              ;
171+  C55B              scores_processhighscores:
172+  C55B 21 5A C5         ld hl,scores_highscoretmp
173+  C55E 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
174+  C560 3E 1D            ld a,29
175+  C562              scores_processhighscores3:
176+  C562 21 70 C4         ld hl,scores_table          ; position of first score column
177+  C565 5F               ld e,a
178+  C566 16 00            ld d,0
179+  C568 19               add hl,de
180+  C569 08               ex af,af'                   ; store a for later
181+  C56A 11 66 C4         ld de,scores_current+2      ; position of current score column
182+  C56D 06 06            ld b,6                      ; times to loop
183+  C56F              scores_processhighscores0:
184+  C56F 7E               ld a,(hl)
185+  C570 4F               ld c,a                      ; get first score column
186+  C571 1A               ld a,(de)                   ; get first current column
187+  C572 B9               cp c                        ; compare current with first
188+  C573 DA 84 C5         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
189+  C576 23               inc hl
190+  C577 13               inc de                      ; move to next column
191+  C578 10 F5            djnz scores_processhighscores0 ; loop
192+  C57A 08               ex af,af'                     ; still here, so must be bigger
193+  C57B 32 5A C5         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
194+  C57E 0E 0C            ld c,12
195+  C580 91               sub c
196+  C581 D2 62 C5         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
197+  C584              scores_processhighscores4
198+  C584 CD 88 C5         call scores_updatehighscores
199+  C587 C9               ret
200+  C588
201+  C588              ;
202+  C588              ; Update score table
203+  C588              ;
204+  C588              scores_updatehighscores:
205+  C588 3A 5A C5         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
206+  C58B FE 00            cp 0
207+  C58D C8               ret z                       ; if this is 0, didn't get a high score
208+  C58E FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
209+  C590 CA C3 C5         jp z, scores_updatehighscores3
210+  C593                                              ; copy old score over one below, if not first
211+  C593 21 70 C4         ld hl,scores_table
212+  C596 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
213+  C599 19               add hl,de                   ; position of first column
214+  C59A 2B               dec hl
215+  C59B 2B               dec hl
216+  C59C 2B               dec hl
217+  C59D E5               push hl
218+  C59E 11 0C 00         ld de,12
219+  C5A1 19               add hl,de                   ; get position of next score
220+  C5A2 54 5D            ld de,hl
221+  C5A4 E1               pop hl                      ; get hl back
222+  C5A5 01 09 00         ld bc,9
223+  C5A8 ED B0            ldir
224+  C5AA FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
225+  C5AC CA C3 C5         jp z,scores_updatehighscores3
226+  C5AF 21 70 C4         ld hl,scores_table
227+  C5B2 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
228+  C5B5 19               add hl,de                   ; position of first column
229+  C5B6 E5               push hl
230+  C5B7 11 0C 00         ld de,12
231+  C5BA 19               add hl,de                   ; get position of next score
232+  C5BB 54 5D            ld de,hl
233+  C5BD E1               pop hl                      ; get hl back
234+  C5BE 01 09 00         ld bc,9
235+  C5C1 ED B0            ldir
236+  C5C3              scores_updatehighscores3:
237+  C5C3 06 06            ld b,6                      ; now overwrite
238+  C5C5 21 70 C4         ld hl,scores_table
239+  C5C8 16 00            ld d,0
240+  C5CA 5F               ld e,a
241+  C5CB 19               add hl,de                   ; position of first column
242+  C5CC 08               ex af,af'
243+  C5CD 11 66 C4         ld de,scores_current+2      ; position of current score column
244+  C5D0              scores_updatehighscores2:
245+  C5D0 1A               ld a,(de)
246+  C5D1 77               ld (hl),a
247+  C5D2 23               inc hl
248+  C5D3 13               inc de
249+  C5D4 10 FA            djnz scores_updatehighscores2
250+  C5D6 11 09 00         ld de,9
251+  C5D9 ED 52            sbc hl,de
252+  C5DB 54 5D            ld de,hl                    ; get back to start of entry
253+  C5DD 21 6D C4         ld hl,scores_defaultname    ; still need to overwrite the name
254+  C5E0 01 03 00         ld bc,3                      ; 3 chars to copy
255+  C5E3 ED B0            ldir
256+  C5E5 C9               ret
# file closed: game/scores.asm
 45   C5E6                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  C5E6              diamonds_tmp:
  2+  C5E6 00               defb 0
  3+  C5E7
  4+  C5E7              diamonds_tmp2:
  5+  C5E7 00               defb 0
  6+  C5E8
  7+  C5E8              ;
  8+  C5E8              ; Holds the number of thousands for the current gem type
  9+  C5E8              ;
 10+  C5E8              diamonds_score:
 11+  C5E8 00               defb 0
 12+  C5E9
 13+  C5E9              ;
 14+  C5E9              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  C5E9              ; Inputs:
 16+  C5E9              ; hl - memory location of gem type
 17+  C5E9              diamonds_twinkle_type:
 18+  C5E9 CD 86 BD         call game_getcurrentframe       ; get current frame number
 19+  C5EC E6 07            and 7                           ; want a number from 0-7
 20+  C5EE C6 40            add 64                          ; add to 60 to get attr colour
 21+  C5F0 32 E7 C5         ld (diamonds_tmp2),a             ; store the colour
 22+  C5F3              diamonds_twinkle_type0:
 23+  C5F3 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  C5F7 79               ld a,c                          ; load c into a
 25+  C5F8 FE FF            cp 255                          ; is this the end?
 26+  C5FA CA 22 C6         jp z,diamonds_twinkle_type1           ; step out if so
 27+  C5FD 23               inc hl
 28+  C5FE 23               inc hl
 29+  C5FF 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  C600 FE 01            cp 1
 31+  C602 CA 23 C6         jp z,diamonds_twinkle_type2           ; step out if so
 32+  C605 CD 63 C6         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  C608 DC 2A C6         call c,diamonds_collect     ; we collided
 34+  C60B 23               inc hl
 35+  C60C E5               push hl
 36+  C60D E5 DD E1         ld ix,hl
 37+  C610 DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  C614 46 FE
 38+  C616 3A E7 C5         ld a,(diamonds_tmp2)
 39+  C619 CD B3 A9         call screen_setattr
 40+  C61C E1               pop hl
 41+  C61D 23               inc hl
 42+  C61E 23               inc hl                          ; move to next diamond
 43+  C61F C3 F3 C5         jp diamonds_twinkle_type0
 44+  C622              diamonds_twinkle_type1:
 45+  C622 C9               ret
 46+  C623              diamonds_twinkle_type2:
 47+  C623 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  C624 23               inc hl
 49+  C625 23               inc hl
 50+  C626 08               ex af,af'
 51+  C627 C3 F3 C5         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  C62A
 53+  C62A              ;
 54+  C62A              ; Collect the diamond we collided with
 55+  C62A              ; Inputs:
 56+  C62A              ; hl - memory location of current diamond, currently on state
 57+  C62A              ; Output:
 58+  C62A              ; a - 70 - for yellow on black
 59+  C62A              diamonds_collect:
 60+  C62A 36 01            ld (hl),1                       ; collected
 61+  C62C E5               push hl
 62+  C62D 2B               dec hl
 63+  C62E 2B               dec hl
 64+  C62F 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  C633 CD 6B A9         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  C636 ED 5B E6 C5      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  C63A 16 00            ld d,0
 68+  C63C 21 B7 B5         ld hl,sprites
 69+  C63F 19               add hl,de
 70+  C640 CD 2D AA         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  C643 E1               pop hl
 72+  C644 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  C646 32 E7 C5         ld (diamonds_tmp2),a
 74+  C649 D9               exx
 75+  C64A 3A E8 C5         ld a,(diamonds_score)
 76+  C64D 47               ld b,a
 77+  C64E CD 94 C4         call scores_addthousands
 78+  C651 3A E6 C5         ld a,(diamonds_tmp)
 79+  C654 FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  C656 C2 5E C6         jp nz,diamonds_collect0
 81+  C659 21 A4 BD         ld hl,player+13
 82+  C65C 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  C65E              diamonds_collect0:
 84+  C65E CD CB AF         call sound_gemcollected
 85+  C661 D9               exx
 86+  C662 C9               ret
 87+  C663
 88+  C663              ;
 89+  C663              ; Checks to see if the gem is hitting a player
 90+  C663              ; Inputs:
 91+  C663              ; bc - coords of diamond we're checking
 92+  C663              diamonds_checkforplayer:
 93+  C663 78               ld a,b               ; multiply b by 8
 94+  C664 07               rlca
 95+  C665 07               rlca
 96+  C666 07               rlca
 97+  C667 47               ld b,a
 98+  C668 ED 5B 97 BD      ld de,(player)       ; get the player coords
 99+  C66C 7B               ld a,e               ; get the vert coord first
100+  C66D 90               sub b                ; subtract the diamond vertical coord from players
101+  C66E C6 04            add 4                ; add the max distance
102+  C670 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  C672 D0               ret nc               ; if not, hasn't hit
104+  C673 79               ld a,c               ; multiply c by 8
105+  C674 07               rlca
106+  C675 07               rlca
107+  C676 07               rlca
108+  C677 4F               ld c,a
109+  C678 7A               ld a,d               ; get the player horiz coord
110+  C679 91               sub c                ; subtract rock coord
111+  C67A C6 04            add 4                ; add max distance
112+  C67C FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  C67E D0               ret nc
114+  C67F 3E 00            ld a,0
115+  C681 C9               ret
116+  C682
117+  C682
118+  C682              ;
119+  C682              ; Initialise diamonds and gems
120+  C682              ;
121+  C682              diamonds_twinkle
122+  C682 21 E8 C5         ld hl,diamonds_score
123+  C685 36 02            ld (hl),2         ; store the score we'll add
124+  C687 21 E6 C5         ld hl,diamonds_tmp
125+  C68A 36 40            ld (hl),64         ; store the location the diamond sprite
126+  C68C 21 32 B5         ld hl, level01diamonds
127+  C68F CD E9 C5         call diamonds_twinkle_type
128+  C692 21 E8 C5         ld hl,diamonds_score
129+  C695 36 01            ld (hl),1         ; store the score we'll add
130+  C697 21 E6 C5         ld hl,diamonds_tmp
131+  C69A 36 70            ld (hl),112         ; store the location the gem sprite
132+  C69C 21 42 B5         ld hl, level01gems
133+  C69F CD E9 C5         call diamonds_twinkle_type
134+  C6A2 C9               ret
135+  C6A3
136+  C6A3              ;
137+  C6A3              ; Initialise diamonds and gems
138+  C6A3              ;
139+  C6A3              diamonds_init:
140+  C6A3 21 32 B5         ld hl, level01diamonds
141+  C6A6 CD B0 C6         call diamonds_init_type
142+  C6A9 21 42 B5         ld hl, level01gems
143+  C6AC CD B0 C6         call diamonds_init_type
144+  C6AF C9               ret
145+  C6B0
146+  C6B0              ;
147+  C6B0              ; Initialise diamonds or gems, get memory addresses
148+  C6B0              ; Inputs:
149+  C6B0              ; hl - memory location
150+  C6B0              diamonds_init_type:
151+  C6B0 4E               ld c,(hl)                      ; get coords into c
152+  C6B1 79               ld a,c                          ; load c into add
153+  C6B2 FE FF            cp 255                          ; is this the end?
154+  C6B4 CA CB C6         jp z,diamonds_init_type1             ; step out if so
155+  C6B7 23               inc hl
156+  C6B8 46               ld b,(hl)                       ; get coords into b
157+  C6B9 E5               push hl
158+  C6BA CD 1C A9         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  C6BD E1               pop hl
160+  C6BE 23               inc hl                          ; move to state
161+  C6BF 36 00            ld (hl),0
162+  C6C1 23               inc hl                          ; move to memory
163+  C6C2 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  C6C6 23               inc hl                          ; move to next diamond
165+  C6C7 23               inc hl
166+  C6C8 C3 B0 C6         jp diamonds_init_type
167+  C6CB              diamonds_init_type1:
168+  C6CB C9               ret
# file closed: game/diamonds.asm
 46   C6CC                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  C6CC              ;
  2+  C6CC              ; Controls when missiles fall
  3+  C6CC              ;
  4+  C6CC              missiles_count:
  5+  C6CC 00               defb 0
  6+  C6CD
  7+  C6CD              ;
  8+  C6CD              ; A structure of falling missiles
  9+  C6CD              ; Assume we'll never have more than 4 falling at any one time
 10+  C6CD              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  C6CD              ;
 12+  C6CD              missiles_falling:
 13+  C6CD 00 00 00         defb 0,0,0
 14+  C6D0 00 00 00         defb 0,0,0
 15+  C6D3 00 00 00         defb 0,0,0
 16+  C6D6 00 00 00         defb 0,0,0
 17+  C6D9
 18+  C6D9              ;
 19+  C6D9              ; The coords of the missile that killed us
 20+  C6D9              ;
 21+  C6D9              missiles_killermissile:
 22+  C6D9 00 00            defb 0,0
 23+  C6DB
 24+  C6DB              ;
 25+  C6DB              ; Zeroes the state of each missile
 26+  C6DB              ;
 27+  C6DB              missiles_init:
 28+  C6DB 06 0C            ld b,12
 29+  C6DD DD 21 B9 B4      ld ix,level01missiles
 30+  C6E1              missiles_init0:
 31+  C6E1 DD 36 02 00      ld (ix+2),0               ; set the state to zero
 32+  C6E5 11 05 00         ld de,5
 33+  C6E8 DD 19            add ix,de
 34+  C6EA DD 36 02 00      ld (ix+2),0
 35+  C6EE DD 19            add ix,de
 36+  C6F0 10 EF            djnz missiles_init0
 37+  C6F2 06 04            ld b,4                  ; reset four falling missiles
 38+  C6F4 21 CD C6         ld hl,missiles_falling
 39+  C6F7              missiles_init1:
 40+  C6F7 36 00            ld (hl),0
 41+  C6F9 23               inc hl
 42+  C6FA 36 00            ld (hl),0
 43+  C6FC 23               inc hl
 44+  C6FD 36 00            ld (hl),0
 45+  C6FF 23               inc hl
 46+  C700 10 F5            djnz missiles_init1
 47+  C702 C9               ret
 48+  C703
 49+  C703              ;
 50+  C703              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 51+  C703              ; Processes any already falling missiles
 52+  C703              ;
 53+  C703              missiles_process:
 54+  C703 3A A2 BD         ld a,(player+11)                        ; check if the player was hit by a missile previously
 55+  C706 FE 03            cp 3
 56+  C708 C2 0F C7         jp nz,missiles_process3                 ; if not, continue
 57+  C70B CD 4C C8         call missiles_zonkplayer
 58+  C70E C9               ret
 59+  C70F              missiles_process3:
 60+  C70F 3A A6 BD         ld a,(player_location)
 61+  C712 FE 01            cp 1
 62+  C714 C2 82 C7         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 63+  C717 21 A4 BD         ld hl,player+13
 64+  C71A 7E               ld a,(hl)                               ; check if player has collected a diamond
 65+  C71B FE 01            cp 1
 66+  C71D C2 82 C7         jp nz, missiles_process0                ; don't activate if not
 67+  C720 21 CC C6         ld hl,missiles_count
 68+  C723 7E               ld a,(hl)                   ; get the missiles count
 69+  C724 3C               inc a
 70+  C725 FE 32            cp 50                                   ; have we reached the count yet
 71+  C727 CA 2E C7         jp z,missiles_process2                 ; if not, don't activate a new one
 72+  C72A 77               ld (hl),a                               ; store the updated count, and continue without activating
 73+  C72B C3 82 C7         jp missiles_process0
 74+  C72E              missiles_process2:
 75+  C72E 36 00            ld (hl),0                               ; zero the counter
 76+  C730 1E 0C            ld e,12
 77+  C732 CD EF 80         call utilities_randomupper              ; get random number from 0 to 11
 78+  C735 11 0A 00         ld de,10
 79+  C738 CD 3A 80         call utilities_multiply                 ; multiple random number by 10
 80+  C73B 54 5D            ld de,hl                                ; this is the offset for the random missile
 81+  C73D DD 21 B9 B4      ld ix,level01missiles                   ; load the location of the missile definitions
 82+  C741 DD 19            add ix,de                               ; get to location of missile
 83+  C743 DD 7E 02         ld a,(ix+2)
 84+  C746 FE 00            cp 0
 85+  C748 CA 58 C7         jp z,missiles_process1                  ; if this missile isn't active, activate it
 86+  C74B 11 05 00         ld de,5                                 ; otherwise, check the missile above
 87+  C74E DD 19            add ix,de
 88+  C750 DD 7E 02         ld a,(ix+2)
 89+  C753 FE 00            cp 0
 90+  C755 C2 82 C7         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 91+  C758              missiles_process1:                          ; activate a missile
 92+  C758 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
 93+  C75C DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
 93+  C760 46 01
 94+  C762 78               ld a,b
 95+  C763 ED 5B 09 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
 96+  C767 93               sub e
 97+  C768 CD 6B A9         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
 98+  C76B C5               push bc
 99+  C76C 3E 0C            ld a,12                                 ; inactive missile sprite
100+  C76E CD A8 A9         call screen_getblock
101+  C771 CD 2D AA         call sprites_drawsprite                 ; draw the sprite over the old one
102+  C774 C1               pop bc
103+  C775 C5               push bc
104+  C776 3E 14            ld a,20                                 ; active missile sprite
105+  C778 CD A8 A9         call screen_getblock
106+  C77B CD 2D AA         call sprites_drawsprite                 ; draw the sprite over the old one
107+  C77E C1               pop bc
108+  C77F CD 10 C8         call missiles_addmissiletofalling
109+  C782              missiles_process0:
110+  C782 CD 86 C7         call missiles_fall
111+  C785 C9               ret
112+  C786
113+  C786              ;
114+  C786              ; Processes falling missiles
115+  C786              ;
116+  C786              missiles_fall:
117+  C786 06 04            ld b,4              ; number of possible falling missiles
118+  C788 DD 21 CD C6      ld ix,missiles_falling
119+  C78C              missiles_fall0:
120+  C78C C5               push bc
121+  C78D DD 7E 02         ld a,(ix+2)
122+  C790 FE 00            cp 0
123+  C792 CA EF C7         jp z,missiles_fall1 ; not falling move to next
124+  C795 FE 01            cp 1                ; is this ready to fall
125+  C797 CA 9D C7         jp z, missiles_fall3
126+  C79A C3 09 C8         jp missiles_fall4   ; if not, decrease the countdown
127+  C79D              missiles_fall3:
128+  C79D DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
128+  C7A1 46 01
129+  C7A3 CD 22 AB         call sprites_scadd  ; get the memory of the coords into de
130+  C7A6 14               inc d               ; add 256 to get next row
131+  C7A7 1A               ld a,(de)           ; get the contents of the next row
132+  C7A8 FE 00            cp 0
133+  C7AA C2 02 C8         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
134+  C7AD 3E 14            ld a,20                                 ; active missile sprite
135+  C7AF CD A8 A9         call screen_getblock
136+  C7B2 CD 2D AA         call sprites_drawsprite                 ; draw the sprite over the old one
137+  C7B5 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
137+  C7B9 46 01
138+  C7BB 0C               inc c               ; move down one pixel
139+  C7BC DD 71 00 DD      ld (ix),bc          ; store the new coords
139+  C7C0 70 01
140+  C7C2 3E 14            ld a,20                                 ; active missile sprite
141+  C7C4 CD A8 A9         call screen_getblock
142+  C7C7 CD 2D AA         call sprites_drawsprite                 ; draw the sprite
143+  C7CA DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
143+  C7CE 46 01
144+  C7D0 79               ld a,c              ; get the vertical coord into a
145+  C7D1 E6 07            and 7               ; divisible by 8?
146+  C7D3 FE 00            cp 0
147+  C7D5 C2 EF C7         jp nz,missiles_fall1   ; if not, carry on
148+  C7D8 CD 5B A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
149+  C7DB 3E 43            ld a,67             ; load magenta
150+  C7DD CD B3 A9         call screen_setattr
151+  C7E0 DD 4E 00 DD      ld bc,(ix)
151+  C7E4 46 01
152+  C7E6 CD 5B A9         call screen_getcharcoordsfromscreencoords ; get the attr address into de
153+  C7E9 05               dec b               ; look one square above
154+  C7EA 3E 46            ld a,70             ; load yellow
155+  C7EC CD B3 A9         call screen_setattr
156+  C7EF              missiles_fall1:         ; hl at state
157+  C7EF DD 4E 00 DD      ld bc,(ix)          ; get coords back
157+  C7F3 46 01
158+  C7F5 CD 31 C8         call missiles_checkforplayer ; check for player
159+  C7F8 DD 23            inc ix
160+  C7FA DD 23            inc ix
161+  C7FC DD 23            inc ix              ; get to next missile
162+  C7FE C1               pop bc
163+  C7FF 10 8B            djnz missiles_fall0
164+  C801 C9               ret
165+  C802              missiles_fall2:
166+  C802 DD 36 02 00      ld (ix+2),0
167+  C806 C3 EF C7         jp missiles_fall1   ; rejoin the loop
168+  C809              missiles_fall4:
169+  C809 3D               dec a               ; decrease the countdown
170+  C80A DD 77 02         ld (ix+2),a         ; store back
171+  C80D C3 EF C7         jp missiles_fall1   ; do next missile
172+  C810
173+  C810              ;
174+  C810              ; Adds the missile to the structure that tracks falling missile
175+  C810              ; Inputs:
176+  C810              ; bc - coords of missile, c vert
177+  C810              missiles_addmissiletofalling:
178+  C810 C5               push bc             ; store the coords
179+  C811 11 CD C6         ld de,missiles_falling
180+  C814 06 04            ld b,4              ; number of possible falling missiles
181+  C816              missiles_addmissiletofalling0:
182+  C816 13               inc de
183+  C817 13               inc de              ; move three along to get the state
184+  C818 1A               ld a,(de)           ; load the state
185+  C819 FE 00            cp 0                ; check if this is not falling
186+  C81B C2 2C C8         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
187+  C81E 3E 19            ld a,25
188+  C820 12               ld (de),a           ; set the state to pre-falling
189+  C821 1B               dec de              ; move back coords
190+  C822 C1               pop bc              ; get back coords
191+  C823 78               ld a,b
192+  C824 12               ld (de),a           ; store the vertical
193+  C825 1B               dec de
194+  C826 79               ld a,c
195+  C827 12               ld (de),a           ; store the horizontal
196+  C828 C5               push bc
197+  C829 C3 2F C8         jp missiles_addmissiletofalling2 ; done
198+  C82C              missiles_addmissiletofalling1:
199+  C82C 13               inc de              ; move memory along to next rock
200+  C82D 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
201+  C82F              missiles_addmissiletofalling2: ; done, return
202+  C82F C1               pop bc              ; to tidy up
203+  C830 C9               ret
204+  C831
205+  C831              ;
206+  C831              ; Checks to see if the missile is hitting a player
207+  C831              ; Inputs:
208+  C831              ; bc - coords of missile we're checking
209+  C831              missiles_checkforplayer:
210+  C831 ED 5B 97 BD      ld de,(player)       ; get the player coords
211+  C835 7B               ld a,e               ; get the vert coord first
212+  C836 91               sub c                ; subtract the missile vertical coord from players
213+  C837 FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
214+  C839 C0               ret nz               ; if not, hasn't hit
215+  C83A 7A               ld a,d               ; get the player horiz coord
216+  C83B 90               sub b                ; subtract missile coord
217+  C83C C6 07            add 7                ; add max distance
218+  C83E FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
219+  C840 DA 44 C8         jp c,missiles_checkforplayer0
220+  C843 C9               ret
221+  C844              missiles_checkforplayer0:
222+  C844 ED 43 D9 C6      ld (missiles_killermissile),bc; store the coords of the killer missile
223+  C848 CD B4 BE         call player_zonkplayer ; if so, jump out
224+  C84B C9               ret
225+  C84C
226+  C84C              ;
227+  C84C              ; Player has been hit, so draw text over them and mark as dead
228+  C84C              ;
229+  C84C              missiles_zonkplayer:
230+  C84C CD A2 BE         call player_killplayer      ; mark as dead
231+  C84F ED 4B 97 BD      ld bc,(player)              ; get player coords
232+  C853 CD 5B A9         call screen_getcharcoordsfromscreencoords
233+  C856 0D               dec c
234+  C857 0D               dec c
235+  C858 04               inc b
236+  C859 C5               push bc
237+  C85A 3E 42            ld a,66
238+  C85C CD B3 A9         call screen_setattr
239+  C85F 0C               inc c
240+  C860 CD B3 A9         call screen_setattr
241+  C863 0C               inc c
242+  C864 CD B3 A9         call screen_setattr
243+  C867 0C               inc c
244+  C868 CD B3 A9         call screen_setattr
245+  C86B 0C               inc c
246+  C86C CD B3 A9         call screen_setattr
247+  C86F C1               pop bc
248+  C870 ED 5B 09 A8      ld de,(screen_offset)
249+  C874 78               ld a,b
250+  C875 93               sub e
251+  C876 47               ld b,a                      ; subtract the offset
252+  C877 04               inc b
253+  C878 04               inc b                       ; add two for the score rows
254+  C879 ED 43 CF 84      ld (string_zonk),bc         ; set coords of string
255+  C87D 21 CF 84         ld hl,string_zonk
256+  C880 CD 57 85         call string_print
257+  C883 06 14            ld b,20
258+  C885 CD 9B 80         call utilities_pauseforframes ; pause
259+  C888 C9               ret
260+  C889
# file closed: game/missiles.asm
 47   C889                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  C889              ;
  2+  C889              ; Timer for deciding how fast the trap withdraws
  3+  C889              ;
  4+  C889              thepit_timer:
  5+  C889 00               defb 0
  6+  C88A
  7+  C88A              ;
  8+  C88A              ; Ticks for the trap state. Will count to 3 then reset
  9+  C88A              ;
 10+  C88A              thepit_trapcount:
 11+  C88A 00               defb 0
 12+  C88B
 13+  C88B              ;
 14+  C88B              ; The horizontal coordinate of the current pit trap
 15+  C88B              ;
 16+  C88B              thepit_trapcoord:
 17+  C88B 08               defb 8
 18+  C88C
 19+  C88C              ;
 20+  C88C              ; Initialises the pit
 21+  C88C              ;
 22+  C88C              thepit_init:
 23+  C88C 21 8B C8         ld hl,thepit_trapcoord
 24+  C88F 36 08            ld (hl),8
 25+  C891 21 8A C8         ld hl,thepit_trapcount
 26+  C894 36 00            ld (hl),0
 27+  C896 C9               ret
 28+  C897
 29+  C897              ;
 30+  C897              ; Performs per frame processing on the pit room
 31+  C897              ;
 32+  C897              thepit_process:
 33+  C897 3A A6 BD         ld a,(player_location)
 34+  C89A FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 35+  C89C C2 F8 C8         jp nz,thepit_process0
 36+  C89F ED 4B 97 BD      ld bc,(player)                  ; get the player's coords to check if about to fall
 37+  C8A3 3E 08            ld a,8
 38+  C8A5 81               add a,c
 39+  C8A6 4F               ld c,a                          ; look at the square underneath
 40+  C8A7 CD 5B A9         call screen_getcharcoordsfromscreencoords ; get the cell coords
 41+  C8AA CD E9 A9         call screen_ischarempty
 42+  C8AD FE 01            cp 1                            ; check if this is 1=empty
 43+  C8AF CA F9 C8         jp z,thepit_process2
 44+  C8B2 3A 89 C8         ld a,(thepit_timer)             ; get the timer
 45+  C8B5 3C               inc a
 46+  C8B6 32 89 C8         ld (thepit_timer),a             ; store
 47+  C8B9 FE 02            cp 2                           ; have we reached the trigger?
 48+  C8BB C2 F8 C8         jp nz, thepit_process0          ; no need to do anything
 49+  C8BE 3E 00            ld a,0
 50+  C8C0 32 89 C8         ld (thepit_timer),a             ; zero the timer and process
 51+  C8C3 3A 8A C8         ld a,(thepit_trapcount)         ; get the current count
 52+  C8C6 3C               inc a
 53+  C8C7 32 8A C8         ld (thepit_trapcount),a         ; reset the trap count
 54+  C8CA FE 04            cp 4                            ; do we need to begin another character?
 55+  C8CC C2 E0 C8         jp nz,thepit_process1           ; if not, draw as normal
 56+  C8CF 3E 00            ld a,0
 57+  C8D1 32 8A C8         ld (thepit_trapcount),a         ; reset the trap count
 58+  C8D4 3A 8B C8         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 59+  C8D7 FE 02            cp 2
 60+  C8D9 CA F8 C8         jp z,thepit_process0
 61+  C8DC 3D               dec a
 62+  C8DD 32 8B C8         ld (thepit_trapcoord),a         ; store the reduced coord
 63+  C8E0
 64+  C8E0              thepit_process1:                    ; draw the trapdoor in current position
 65+  C8E0 3A 8B C8         ld a,(thepit_trapcoord)
 66+  C8E3 FE 02            cp 2
 67+  C8E5 CA F8 C8         jp z, thepit_process0           ; don't process outside of the pit
 68+  C8E8 4F               ld c,a
 69+  C8E9 06 0A            ld b,10                         ; vertical coord will always be the same
 70+  C8EB 3A 8A C8         ld a,(thepit_trapcount)         ; get the trap count
 71+  C8EE 5F               ld e,a                          ; store in e
 72+  C8EF 3E 16            ld a,22                         ; 21 is full trapdoor
 73+  C8F1 83               add a,e
 74+  C8F2 CD A8 A9         call screen_getblock
 75+  C8F5 CD 85 A9         call screen_showchar            ; show the char
 76+  C8F8
 77+  C8F8              thepit_process0:
 78+  C8F8 C9               ret
 79+  C8F9              thepit_process2:
 80+  C8F9 CD BA BE         call player_pitkillplayer
 81+  C8FC C9               ret
 82+  C8FD
# file closed: game/thepit.asm
 48   C8FD                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  C8FD
  2+  C8FD              ;
  3+  C8FD              ; Where the monster currently is
  4+  C8FD              ;
  5+  C8FD              monster_currentcoords:
  6+  C8FD 00 00            defb 0,0
  7+  C8FF
  8+  C8FF              ;
  9+  C8FF              ; The start coords of the monster
 10+  C8FF              ;
 11+  C8FF              monster_initcoords:
 12+  C8FF 70 1B            defb 112,27
 13+  C901
 14+  C901              ;
 15+  C901              ; Store the memory location of the current jump position
 16+  C901              ;
 17+  C901              monster_jumppos:
 18+  C901 00 00            defb 0,0
 19+  C903
 20+  C903              ;
 21+  C903              ; The jump table for the monster.
 22+  C903              ;
 23+  C903              monster_jumptable:
 24+  C903 FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  C907 02 02 02 02
 24+  C90B 02 02 01 01
 24+  C90F 01 01 01 01
 24+  C913 FF
 25+  C914
 26+  C914              ;
 27+  C914              ; The vertical direction: 0 up, 1 down
 28+  C914              ;
 29+  C914              monster_jumpdirectionvert:
 30+  C914 00               defb 0
 31+  C915
 32+  C915              ;
 33+  C915              ; The horiz direction: 0 right, 1 left
 34+  C915              ;
 35+  C915              monster_jumpdirectionhoriz:
 36+  C915 00               defb 0
 37+  C916
 38+  C916              ;
 39+  C916              ; Frame offset, 0 or 32
 40+  C916              ;
 41+  C916              monster_frameoffset:
 42+  C916 00               defb 0
 43+  C917
 44+  C917              ;
 45+  C917              ; Monster tick
 46+  C917              ;
 47+  C917              monster_tick:
 48+  C917 00               defb 0
 49+  C918
 50+  C918              ;
 51+  C918              ; Initialises the pit monster
 52+  C918              ;
 53+  C918              monster_init:
 54+  C918 ED 4B FF C8      ld bc,(monster_initcoords)              ; load the initial coords
 55+  C91C ED 43 FD C8      ld (monster_currentcoords),bc           ; save in current coords
 56+  C920 21 04 C9         ld hl,monster_jumptable+1
 57+  C923 22 01 C9         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 58+  C926 3E 00            ld a,0
 59+  C928 32 14 C9         ld (monster_jumpdirectionvert),a        ; going up
 60+  C92B 32 16 C9         ld (monster_frameoffset),a
 61+  C92E 32 17 C9         ld (monster_tick),a
 62+  C931 CD B1 C9         call monster_draw                       ; the monster
 63+  C934 C9               ret
 64+  C935
 65+  C935              ;
 66+  C935              ; Animate the monster
 67+  C935              ;
 68+  C935              monster_process:
 69+  C935 3A 17 C9         ld a,(monster_tick)                     ; check if we should draw this frame
 70+  C938 FE 01            cp 1
 71+  C93A CA 42 C9         jp z,monster_process6
 72+  C93D 3C               inc a
 73+  C93E 32 17 C9         ld (monster_tick),a                     ; increase the tick and continue
 74+  C941 C9               ret
 75+  C942              monster_process6:
 76+  C942 3E 00            ld a,0
 77+  C944 32 17 C9         ld (monster_tick),a                     ; zero the tick
 78+  C947 CD B1 C9         call monster_draw                       ; overwrite the old sprite
 79+  C94A 3A 16 C9         ld a,(monster_frameoffset)              ; get the anim frame offset
 80+  C94D EE 20            xor 32                                  ; flip between 0 and 32
 81+  C94F 32 16 C9         ld (monster_frameoffset),a              ; store
 82+  C952 ED 4B FD C8      ld bc,(monster_currentcoords)           ; get the current coords
 83+  C956 2A 01 C9         ld hl,(monster_jumppos)                 ; get the position in the jump table
 84+  C959 56               ld d,(hl)                               ; get the jump modifier
 85+  C95A 3A 14 C9         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 86+  C95D FE 00            cp 0                                    ; if 0, going up, so dec vert
 87+  C95F C2 68 C9         jp nz,monster_process0
 88+  C962 79               ld a,c
 89+  C963 92               sub d
 90+  C964 23               inc hl                                  ; move forward a jump pos
 91+  C965 C3 6B C9         jp monster_process1
 92+  C968              monster_process0:
 93+  C968 79               ld a,c                                   ; going down so inc c
 94+  C969 82               add a,d
 95+  C96A 2B               dec hl                                  ; move back a jump pos
 96+  C96B              monster_process1:
 97+  C96B 4F               ld c,a                                  ; get the vertical coord back
 98+  C96C 7E               ld a,(hl)                               ; check the next jump pos
 99+  C96D FE FF            cp 255                                  ; if 255 reverse
100+  C96F CA 78 C9         jp z,monster_process3
101+  C972 22 01 C9         ld (monster_jumppos),hl                 ; store the new pos
102+  C975 C3 80 C9         jp monster_process2                     ; keep going
103+  C978              monster_process3:
104+  C978 3A 14 C9         ld a,(monster_jumpdirectionvert)        ; get the direction
105+  C97B EE 01            xor 1                                   ; flip it
106+  C97D 32 14 C9         ld (monster_jumpdirectionvert),a        ; store it
107+  C980              monster_process2:
108+  C980 3A 15 C9         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
109+  C983 FE 00            cp 0                                    ; is it right?
110+  C985 C2 9A C9         jp nz,monster_process4
111+  C988 04               inc b                                   ; 1 pixel right
112+  C989 78               ld a,b
113+  C98A FE 38            cp 56                                   ; reached the edge of the pit?
114+  C98C C2 A9 C9         jp nz,monster_process5
115+  C98F 3A 15 C9         ld a,(monster_jumpdirectionhoriz)
116+  C992 EE 01            xor 1
117+  C994 32 15 C9         ld (monster_jumpdirectionhoriz),a       ; flip direction
118+  C997 C3 A9 C9         jp monster_process5
119+  C99A              monster_process4:
120+  C99A 05               dec b                                   ; 1 pixel left
121+  C99B 78               ld a,b
122+  C99C FE 18            cp 24                                   ; reached the edge of the pit?
123+  C99E C2 A9 C9         jp nz,monster_process5
124+  C9A1 3A 15 C9         ld a,(monster_jumpdirectionhoriz)
125+  C9A4 EE 01            xor 1
126+  C9A6 32 15 C9         ld (monster_jumpdirectionhoriz),a       ; flip direction
127+  C9A9              monster_process5:
128+  C9A9 ED 43 FD C8      ld (monster_currentcoords),bc           ; store the new vertical coords
129+  C9AD CD B1 C9         call monster_draw                       ; finally, draw the monster
130+  C9B0 C9               ret
131+  C9B1
132+  C9B1              ;
133+  C9B1              ; Draw the monster at the current location
134+  C9B1              ;
135+  C9B1              monster_draw:
136+  C9B1 ED 4B FD C8      ld bc,(monster_currentcoords)
137+  C9B5 3A 16 C9         ld a,(monster_frameoffset)
138+  C9B8 11 00 00         ld de,0
139+  C9BB 5F               ld e,a
140+  C9BC 21 CB B7         ld hl,monster_sprite                    ; load the first frame
141+  C9BF 19               add hl,de
142+  C9C0 CD 8B AA         call sprites_draw2by2sprite
143+  C9C3 C9               ret
# file closed: game/monster.asm
 49   C9C4                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  C9C4
  2+  C9C4              ;
  3+  C9C4              ; Array of robot states
  4+  C9C4              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  C9C4              robots_robots:
  6+  C9C4 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  C9C8 00 00 00
  7+  C9CB 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  C9CF 00 00 00
  8+  C9D2 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  C9D6 00 00 00
  9+  C9D9 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  C9DD 00 00 00
 10+  C9E0 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  C9E4 00 00 00
 11+  C9E7
 12+  C9E7              robots_initcoords:
 13+  C9E7 18 E8            defb 24,232
 14+  C9E9
 15+  C9E9              ;
 16+  C9E9              ; When this reaches zero, spawn a new robot
 17+  C9E9              ;
 18+  C9E9              robots_spawntimer:
 19+  C9E9 FA               defb 250
 20+  C9EA
 21+  C9EA              ;
 22+  C9EA              ; When this reaches max, change the anim frame
 23+  C9EA              ;
 24+  C9EA              robots_animtimer:
 25+  C9EA 00               defb 0
 26+  C9EB
 27+  C9EB              ;
 28+  C9EB              ; When this reaches max, change move the robot
 29+  C9EB              ;
 30+  C9EB              robots_movetimer:
 31+  C9EB 00               defb 0
 32+  C9EC
 33+  C9EC
 34+  C9EC              ;
 35+  C9EC              ; The number of robots active
 36+  C9EC              ;
 37+  C9EC              robots_numberactive:
 38+  C9EC 00               defb 0
 39+  C9ED
 40+  C9ED              ;
 41+  C9ED              ; Tracks which directions a robot can move
 42+  C9ED              ; up,down,left,right
 43+  C9ED              robots_canmovedirections:
 44+  C9ED 00 00 00 00      defb 0,0,0,0
 45+  C9F1
 46+  C9F1              ;
 47+  C9F1              ; The current robot speed
 48+  C9F1              ;
 49+  C9F1              robots_robotspeed:
 50+  C9F1 02               defb 2
 51+  C9F2
 52+  C9F2              ;
 53+  C9F2              ; The current max robots
 54+  C9F2              ;
 55+  C9F2              robots_robotsmax:
 56+  C9F2 02               defb 2
 57+  C9F3
 58+  C9F3              ;
 59+  C9F3              ; Initialises the robots
 60+  C9F3              ;
 61+  C9F3              robots_init:
 62+  C9F3 06 23            ld b,35
 63+  C9F5 DD 21 C4 C9      ld ix,robots_robots
 64+  C9F9              robots_init0:
 65+  C9F9 DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 66+  C9FD DD 23            inc ix
 67+  C9FF 10 F8            djnz robots_init0
 68+  CA01 3E 00            ld a,0
 69+  CA03 32 EC C9         ld (robots_numberactive),a
 70+  CA06 3E FA            ld a,250
 71+  CA08 32 E9 C9         ld (robots_spawntimer),a
 72+  CA0B                  ; Self writing code
 73+  CA0B                  ; Robot speed
 74+  CA0B 3A F1 C9         ld a,(robots_robotspeed)
 75+  CA0E 32 A8 CA         ld (robots_process7+1),a
 76+  CA11 3C               inc a
 77+  CA12 32 D8 CA         ld (robots_process6+1),a
 78+  CA15                  ; Robots max
 79+  CA15 3A F2 C9         ld a,(robots_robotsmax)
 80+  CA18 32 23 CA         ld (robots_spawn+1),a
 81+  CA1B 32 7A CA         ld (robots_process8+1),a
 82+  CA1E 32 96 CA         ld (robots_process0+1),a
 83+  CA21 C9               ret
 84+  CA22
 85+  CA22              ;
 86+  CA22              ; Spawns a new robot
 87+  CA22              ; Inputs:
 88+  CA22              ; ix - pointer to start of robot array entry
 89+  CA22              ;
 90+  CA22              robots_spawn:
 91+  CA22 06 03            ld b,3                      ;(SELF WRITING CODE)
 92+  CA24 DD 21 C4 C9      ld ix,robots_robots
 93+  CA28              robots_spawn0:
 94+  CA28 DD 7E 02         ld a,(ix+2)                 ; get the state
 95+  CA2B FE 00            cp 0
 96+  CA2D C2 59 CA         jp nz,robots_spawn1         ; if already active, move on
 97+  CA30 ED 4B E7 C9      ld bc,(robots_initcoords)
 98+  CA34 DD 71 00 DD      ld (ix),bc
 98+  CA38 70 01
 99+  CA3A DD 36 02 01      ld (ix+2),1
100+  CA3E DD 36 03 00      ld (ix+3),0
101+  CA42 DD 36 04 00      ld (ix+4),0
102+  CA46 DD 36 05 00      ld (ix+5),0
103+  CA4A DD 36 06 00      ld (ix+6),0
104+  CA4E 3A EC C9         ld a,(robots_numberactive)
105+  CA51 3C               inc a
106+  CA52 32 EC C9         ld (robots_numberactive),a  ; increase the number active
107+  CA55 CD 10 CD         call robots_draw            ; draw initial frame
108+  CA58 C9               ret
109+  CA59              robots_spawn1:
110+  CA59 11 07 00         ld de,7
111+  CA5C DD 19            add ix,de
112+  CA5E 10 C8            djnz robots_spawn0
113+  CA60 C9               ret
114+  CA61              ;
115+  CA61              ; Kills robot
116+  CA61              ; Inputs:
117+  CA61              ; ix - pointer to start of robot array entry
118+  CA61              ;
119+  CA61              robots_kill:
120+  CA61 3A EC C9         ld a,(robots_numberactive)
121+  CA64 3D               dec a
122+  CA65 32 EC C9         ld (robots_numberactive),a
123+  CA68 DD 36 02 00      ld (ix+2),0                     ; set to inactive
124+  CA6C C5               push bc
125+  CA6D E5               push hl
126+  CA6E 06 01            ld b,1
127+  CA70 CD 9B C4         call scores_addhundreds
128+  CA73 E1               pop hl
129+  CA74 C1               pop bc
130+  CA75 C9               ret
131+  CA76
132+  CA76              ;
133+  CA76              ; Processes the robots
134+  CA76              ;
135+  CA76              robots_process:
136+  CA76 3A EC C9         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
137+  CA79              robots_process8:
138+  CA79 FE 03            cp 3                                    ; 3 is the maximum
139+  CA7B CA 95 CA         jp z,robots_process0                    ; if already three, nothing to do
140+  CA7E 3A E9 C9         ld a,(robots_spawntimer)                ; now check the spawn timer
141+  CA81 FE 00            cp 0
142+  CA83 C2 91 CA         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
143+  CA86 3E FA            ld a,250
144+  CA88 32 E9 C9         ld (robots_spawntimer),a                ; reset the spawn timer
145+  CA8B CD 22 CA         call robots_spawn                       ; spawn a robot
146+  CA8E C3 95 CA         jp robots_process0                      ; carry on
147+  CA91              robots_process1:
148+  CA91 3D               dec a
149+  CA92 32 E9 C9         ld (robots_spawntimer),a                ; decrease the spawn timer and store
150+  CA95              robots_process0:
151+  CA95 06 03            ld b,3                                  ; max number of robots (SELF WRITING CODE)
152+  CA97 DD 21 C4 C9      ld ix, robots_robots                    ; point ix at the robot array
153+  CA9B              robots_process2:
154+  CA9B C5               push bc
155+  CA9C DD 7E 02         ld a,(ix+2)                             ; check the state
156+  CA9F FE 00            cp 0
157+  CAA1 CA BD CA         jp z,robots_process3                    ; if not active, move on
158+  CAA4 3A EB C9         ld a,(robots_movetimer)
159+  CAA7              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
160+  CAA7 FE 04            cp 4
161+  CAA9 C2 BD CA         jp nz,robots_process3                   ; can we move this frame
162+  CAAC CD 10 CD         call robots_draw                        ; draw over existing
163+  CAAF CD E2 CA         call robots_move                        ; move the
164+  CAB2 DD 7E 02         ld a,(ix+2)                             ; get the state again
165+  CAB5 FE 00            cp 0
166+  CAB7 CA BD CA         jp z,robots_process3                    ; move to next if this robot has become inactive
167+  CABA CD 10 CD         call robots_draw                        ; draw the new robot
168+  CABD              robots_process3:
169+  CABD C1               pop bc
170+  CABE 11 07 00         ld de,7
171+  CAC1 DD 19            add ix,de
172+  CAC3 10 D6            djnz robots_process2
173+  CAC5 3A EA C9         ld a,(robots_animtimer)
174+  CAC8 3C               inc a
175+  CAC9 FE 08            cp 8
176+  CACB C2 D0 CA         jp nz,robots_process4
177+  CACE 3E 00            ld a,0                                  ; reset if we reached max
178+  CAD0              robots_process4:
179+  CAD0 32 EA C9         ld (robots_animtimer),a
180+  CAD3 3A EB C9         ld a,(robots_movetimer)                 ; increment the robot move timer
181+  CAD6 3C               inc a
182+  CAD7              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
183+  CAD7 FE 05            cp 5                                    ; there is another reference to this number above
184+  CAD9 C2 DE CA         jp nz,robots_process5
185+  CADC 3E 00            ld a,0
186+  CADE              robots_process5:
187+  CADE 32 EB C9         ld (robots_movetimer),a
188+  CAE1
189+  CAE1 C9               ret
190+  CAE2
191+  CAE2
192+  CAE2              ;
193+  CAE2              ; Moves a robot
194+  CAE2              ; Inputs:
195+  CAE2              ; ix - points to first byte of robot in array
196+  CAE2              robots_move:
197+  CAE2 DD 7E 02         ld a,(ix+2)                             ; get the state
198+  CAE5 FE 02            cp 2
199+  CAE7 CA 18 CB         jp z,robots_move4                       ; don't move if shot, just change the anim
200+  CAEA 3A EA C9         ld a,(robots_animtimer)                 ; get the anim timer
201+  CAED FE 07            cp 7                                    ; compare with 8
202+  CAEF C2 02 CB         jp nz,robots_move1                       ; if even, don't increment frame
203+  CAF2 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
204+  CAF5 06 08            ld b,8
205+  CAF7 80               add a,b                                 ; add to anim frame
206+  CAF8 FE 20            cp 32
207+  CAFA C2 FF CA         jp nz,robots_move0                      ; if not 32, then just store
208+  CAFD 3E 00            ld a,0                                  ; otherwise, reset
209+  CAFF              robots_move0:
210+  CAFF DD 77 04         ld (ix+4),a                             ; store
211+  CB02              robots_move1:
212+  CB02 DD 7E 05         ld a,(ix+5)
213+  CB05 FE 00            cp 0                                    ; are we automoving
214+  CB07 CA 10 CB         jp z,robots_move2                       ; if not, keep directions
215+  CB0A CD 2C CB         call robots_automove
216+  CB0D C3 14 CB         jp robots_move3
217+  CB10              robots_move2:
218+  CB10 CD 61 CB         call robots_checkdirectionsandmove
219+  CB13 C9               ret
220+  CB14              robots_move3:
221+  CB14 CD 59 CD         call robots_checkforplayer              ; check to see if we collided with a player
222+  CB17 C9               ret
223+  CB18              robots_move4:
224+  CB18 DD 7E 04         ld a,(ix+4)
225+  CB1B FE 48            cp 72
226+  CB1D C2 26 CB         jp nz,robots_move5
227+  CB20 3E 40            ld a,64
228+  CB22 DD 77 04         ld (ix+4),a
229+  CB25 C9               ret
230+  CB26              robots_move5:
231+  CB26 3E 48            ld a,72
232+  CB28 DD 77 04         ld (ix+4),a
233+  CB2B C9               ret
234+  CB2C
235+  CB2C
236+  CB2C              ;
237+  CB2C              ; Processes automove
238+  CB2C              ; Inputs:
239+  CB2C              ; ix - points to the current robot
240+  CB2C              ; a - number of frames left to move
241+  CB2C              robots_automove:
242+  CB2C 3D               dec a
243+  CB2D DD 77 05         ld (ix+5),a                         ; store the decreased frames
244+  CB30 DD 4E 00 DD      ld bc,(ix)                          ; get coords
244+  CB34 46 01
245+  CB36 DD 7E 06         ld a,(ix+6)                         ; get the direction
246+  CB39 FE 00            cp 0                                ; left
247+  CB3B CA 4C CB         jp z,robots_automove1
248+  CB3E FE 02            cp 2                                ; up
249+  CB40 CA 50 CB         jp z,robots_automove3
250+  CB43 FE 03            cp 3                                ; down
251+  CB45 CA 55 CB         jp z,robots_automove4
252+  CB48 04               inc b                               ; right
253+  CB49 C3 5A CB         jp robots_automove2
254+  CB4C              robots_automove1:
255+  CB4C 05               dec b
256+  CB4D C3 5A CB         jp robots_automove2
257+  CB50              robots_automove3:
258+  CB50 0D               dec c
259+  CB51 0D               dec c
260+  CB52 C3 5A CB         jp robots_automove2
261+  CB55              robots_automove4:
262+  CB55 0C               inc c
263+  CB56 0C               inc c
264+  CB57 C3 5A CB         jp robots_automove2
265+  CB5A              robots_automove2:
266+  CB5A DD 71 00 DD      ld (ix),bc
266+  CB5E 70 01
267+  CB60 C9               ret
268+  CB61
269+  CB61              ;
270+  CB61              ; Checks if a robot can move in all directions, then picks one and moves there.
271+  CB61              ; This looks complicated, but really what it does is:
272+  CB61              ; 1) Look at the current direction
273+  CB61              ; 2) Randomly determine which orthoganal direction check first
274+  CB61              ; 3) If orthogonal can't be moved, keep going in direction we're going
275+  CB61              ; 4) Otherwise, back the way we came
276+  CB61              ; Inputs:
277+  CB61              ; ix - points to the current robot
278+  CB61              ;
279+  CB61              robots_checkdirectionsandmove:
280+  CB61 DD 7E 06         ld a,(ix+6)                 ; get the direction
281+  CB64 FE 00            cp 0                        ; left
282+  CB66 C2 8D CB         jp nz,robots_checkdirectionsandmove0
283+  CB69                  ; random check
284+  CB69 CD 86 BD         call game_getcurrentframe
285+  CB6C E6 01            and 1                       ; odd or even
286+  CB6E CA 7A CB         jp z,robots_checkdirectionsandmove3
287+  CB71 CD 13 CC         call robots_checkupthendown ; prefer up over down
288+  CB74 FE 01            cp 1
289+  CB76 C8               ret z
290+  CB77 C3 80 CB         jp robots_checkdirectionsandmove4
291+  CB7A              robots_checkdirectionsandmove3:
292+  CB7A CD 09 CC         call robots_checkdownthenup ; prefer down over up
293+  CB7D FE 01            cp 1
294+  CB7F C8               ret z
295+  CB80              robots_checkdirectionsandmove4:
296+  CB80                  ; check left
297+  CB80 CD 99 CC         call robots_checkleftandmove
298+  CB83 FE 01            cp 1
299+  CB85 C8               ret z                       ; if we moved, don't check again
300+  CB86                  ; check right
301+  CB86 CD D2 CC         call robots_checkrightandmove
302+  CB89 FE 01            cp 1
303+  CB8B C8               ret z                       ; if we moved, don't check again
304+  CB8C                  ; if we're here and haven't moved...
305+  CB8C C9               ret
306+  CB8D              robots_checkdirectionsandmove0
307+  CB8D FE 01            cp 1                        ; right
308+  CB8F C2 B6 CB         jp nz,robots_checkdirectionsandmove1
309+  CB92                  ; ALREADY MOVING RIGHT
310+  CB92                  ; random check
311+  CB92 CD 86 BD         call game_getcurrentframe
312+  CB95 E6 01            and 1                       ; odd or even
313+  CB97 CA A3 CB         jp z,robots_checkdirectionsandmove5
314+  CB9A CD 09 CC         call robots_checkdownthenup ; prefer down over up
315+  CB9D FE 01            cp 1
316+  CB9F C8               ret z
317+  CBA0 C3 A9 CB         jp robots_checkdirectionsandmove6
318+  CBA3              robots_checkdirectionsandmove5:
319+  CBA3 CD 13 CC         call robots_checkupthendown ; prefer down over up
320+  CBA6 FE 01            cp 1
321+  CBA8 C8               ret z
322+  CBA9              robots_checkdirectionsandmove6:
323+  CBA9                  ; check right
324+  CBA9 CD D2 CC         call robots_checkrightandmove
325+  CBAC FE 01            cp 1
326+  CBAE C8               ret z                       ; if we moved, don't check again
327+  CBAF                  ; check left
328+  CBAF CD 99 CC         call robots_checkleftandmove
329+  CBB2 FE 01            cp 1
330+  CBB4 C8               ret z                       ; if we moved, don't check again
331+  CBB5                  ; if we're here and haven't moved...
332+  CBB5 C9               ret
333+  CBB6              robots_checkdirectionsandmove1
334+  CBB6 FE 02            cp 2                        ; up
335+  CBB8 C2 DF CB         jp nz,robots_checkdirectionsandmove2
336+  CBBB                  ; ALREADY MOVING UP
337+  CBBB                  ; random check
338+  CBBB CD 86 BD         call game_getcurrentframe
339+  CBBE E6 01            and 1                       ; odd or even
340+  CBC0 CA CC CB         jp z,robots_checkdirectionsandmove7
341+  CBC3 CD 29 CC         call robots_checkleftthenright ; prefer left over right
342+  CBC6 FE 01            cp 1
343+  CBC8 C8               ret z
344+  CBC9 C3 D2 CB         jp robots_checkdirectionsandmove8
345+  CBCC              robots_checkdirectionsandmove7:
346+  CBCC CD 1F CC         call robots_checkrightthenleft ; prefer right over left
347+  CBCF FE 01            cp 1
348+  CBD1 C8               ret z
349+  CBD2              robots_checkdirectionsandmove8:
350+  CBD2                  ; check up
351+  CBD2 CD 35 CC         call robots_checkupandmove
352+  CBD5 FE 01            cp 1
353+  CBD7 C8               ret z                       ; if we moved, don't check again
354+  CBD8                  ; check down
355+  CBD8 CD 6B CC         call robots_checkdownandmove
356+  CBDB FE 01            cp 1
357+  CBDD C8               ret z                       ; if we moved, don't check again
358+  CBDE                  ; if we're here and haven't moved...
359+  CBDE C9               ret
360+  CBDF              robots_checkdirectionsandmove2
361+  CBDF                  ; ALREADY MOVING DOWN
362+  CBDF                  ; random check
363+  CBDF CD 86 BD         call game_getcurrentframe
364+  CBE2 E6 01            and 1                       ; odd or even
365+  CBE4 CA F0 CB         jp z,robots_checkdirectionsandmove9
366+  CBE7 CD 1F CC         call robots_checkrightthenleft ; prefer right over left
367+  CBEA FE 01            cp 1
368+  CBEC C8               ret z
369+  CBED C3 F6 CB         jp robots_checkdirectionsandmove10
370+  CBF0              robots_checkdirectionsandmove9:
371+  CBF0 CD 29 CC         call robots_checkleftthenright ; prefer left over right
372+  CBF3 FE 01            cp 1
373+  CBF5 C8               ret z
374+  CBF6              robots_checkdirectionsandmove10:
375+  CBF6                  ; check down
376+  CBF6 CD 6B CC         call robots_checkdownandmove
377+  CBF9 FE 01            cp 1
378+  CBFB C8               ret z                       ; if we moved, don't check again
379+  CBFC                  ; check right first
380+  CBFC CD D2 CC         call robots_checkrightandmove
381+  CBFF FE 01            cp 1
382+  CC01 C8               ret z                       ; if we moved, don't check again
383+  CC02                  ; check up
384+  CC02 CD 35 CC         call robots_checkupandmove
385+  CC05 FE 01            cp 1
386+  CC07 C8               ret z                       ; if we moved, don't check again
387+  CC08                  ; if we're here and haven't moved...
388+  CC08 C9               ret
389+  CC09
390+  CC09              ;
391+  CC09              ; Different orders of checking directions, for pseudo random motion
392+  CC09              ;
393+  CC09              robots_checkdownthenup:
394+  CC09                  ; check down
395+  CC09 CD 6B CC         call robots_checkdownandmove
396+  CC0C FE 01            cp 1
397+  CC0E C8               ret z                       ; if we moved, don't check again
398+  CC0F                  ; check up
399+  CC0F CD 35 CC         call robots_checkupandmove
400+  CC12 C9               ret
401+  CC13
402+  CC13              robots_checkupthendown:
403+  CC13                  ; check up
404+  CC13 CD 35 CC         call robots_checkupandmove
405+  CC16 FE 01            cp 1
406+  CC18 C8               ret z
407+  CC19                  ; check down
408+  CC19 CD 6B CC         call robots_checkdownandmove
409+  CC1C FE 01            cp 1
410+  CC1E C9               ret
411+  CC1F              robots_checkrightthenleft:
412+  CC1F                  ; check right
413+  CC1F CD D2 CC         call robots_checkrightandmove
414+  CC22 FE 01            cp 1
415+  CC24 C8               ret z                       ; if we moved, don't check again
416+  CC25                  ; check left
417+  CC25 CD 99 CC         call robots_checkleftandmove
418+  CC28 C9               ret
419+  CC29
420+  CC29              robots_checkleftthenright:
421+  CC29                  ; check left
422+  CC29 CD 99 CC         call robots_checkleftandmove
423+  CC2C FE 01            cp 1
424+  CC2E C8               ret z
425+  CC2F                  ; check right
426+  CC2F CD D2 CC         call robots_checkrightandmove
427+  CC32 FE 01            cp 1
428+  CC34 C9               ret
429+  CC35
430+  CC35              ;
431+  CC35              ; Checks up for movement
432+  CC35              ; Outputs:
433+  CC35              ; a - 1 if have moved
434+  CC35              robots_checkupandmove:
435+  CC35                  ; check above
436+  CC35 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
436+  CC39 46 01
437+  CC3B 79               ld a,c
438+  CC3C FE 28            cp 40
439+  CC3E D8               ret c
440+  CC3F CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
441+  CC42 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
442+  CC44 11 20 00         ld de,32
443+  CC47 ED 52            sbc hl,de                       ; memory location of line above now in hl
444+  CC49 7E               ld a,(hl)                       ; get the contents of the line
445+  CC4A FE 00            cp 0
446+  CC4C C2 68 CC         jp nz,robots_checkupandmove0    ; can't move here so return
447+  CC4F DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
447+  CC53 46 01
448+  CC55 0D               dec c                       ; move up
449+  CC56 0D               dec c
450+  CC57 DD 71 00 DD      ld (ix),bc
450+  CC5B 70 01
451+  CC5D DD 36 06 02      ld (ix+6),2
452+  CC61 DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
453+  CC65 3E 01            ld a,1
454+  CC67 C9               ret
455+  CC68              robots_checkupandmove0:
456+  CC68 3E 00            ld a,0
457+  CC6A C9               ret
458+  CC6B
459+  CC6B              ;
460+  CC6B              ; Checks down for movement
461+  CC6B              ; Outputs:
462+  CC6B              ; a - 1 if have moved
463+  CC6B              robots_checkdownandmove:
464+  CC6B                  ; check below
465+  CC6B DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
465+  CC6F 46 01
466+  CC71 CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
467+  CC74 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
468+  CC76 24               inc h                       ; memory location of cell beneath now in hl
469+  CC77 7E               ld a,(hl)                       ; get the contents of the line
470+  CC78 FE 00            cp 0
471+  CC7A C2 96 CC         jp nz,robots_checkdownandmove0    ; can't move here so return
472+  CC7D DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
472+  CC81 46 01
473+  CC83 0C               inc c                       ; move up
474+  CC84 0C               inc c
475+  CC85 DD 71 00 DD      ld (ix),bc
475+  CC89 70 01
476+  CC8B DD 36 06 03      ld (ix+6),3
477+  CC8F DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
478+  CC93 3E 01            ld a,1
479+  CC95 C9               ret
480+  CC96              robots_checkdownandmove0:
481+  CC96 3E 00            ld a,0
482+  CC98 C9               ret
483+  CC99
484+  CC99              ;
485+  CC99              ; Checks left for movement
486+  CC99              ; Outputs:
487+  CC99              ; a - 1 if have moved
488+  CC99              robots_checkleftandmove:
489+  CC99                  ; check below
490+  CC99 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
490+  CC9D 46 01
491+  CC9F CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
492+  CCA2 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
493+  CCA4 78               ld a,b
494+  CCA5 06 08            ld b,8
495+  CCA7 90               sub b                           ; move one cell left
496+  CCA8 47               ld b,a
497+  CCA9 2B               dec hl                          ; memory location of cell to the right now in hl
498+  CCAA CD 39 BB         call movement_spaceisempty       ; check space is empty
499+  CCAD 7B               ld a,e                          ; check space empty flag
500+  CCAE FE 00            cp 0
501+  CCB0 CA CF CC         jp z,robots_checkleftandmove0    ; if zero can't move
502+  CCB3 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
502+  CCB7 46 01
503+  CCB9 05               dec b
504+  CCBA DD 71 00 DD      ld (ix),bc
504+  CCBE 70 01
505+  CCC0 DD 36 06 00      ld (ix+6),0
506+  CCC4 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
507+  CCC8 DD 36 03 00      ld (ix+3),0                 ; set to right
508+  CCCC 3E 01            ld a,1
509+  CCCE C9               ret
510+  CCCF              robots_checkleftandmove0:
511+  CCCF 3E 00            ld a,0
512+  CCD1 C9               ret
513+  CCD2
514+  CCD2              ;
515+  CCD2              ; Checks right for movement
516+  CCD2              ; Outputs:
517+  CCD2              ; a - 1 if have moved
518+  CCD2              robots_checkrightandmove:
519+  CCD2                  ; check below
520+  CCD2 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
520+  CCD6 46 01
521+  CCD8 78               ld a,b
522+  CCD9 FE E8            cp 232
523+  CCDB CA 0D CD         jp z,robots_checkrightandmove0  ; can't move if at edge
524+  CCDE CD 22 AB         call sprites_scadd              ; get the memory location of cell into de
525+  CCE1 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
526+  CCE3 3E 08            ld a,8
527+  CCE5 80               add b                           ; move one cell right
528+  CCE6 47               ld b,a
529+  CCE7 23               inc hl                          ; memory location of cell to the right now in hl
530+  CCE8 CD 39 BB         call movement_spaceisempty       ; check space is empty
531+  CCEB 7B               ld a,e                          ; check space empty flag
532+  CCEC FE 00            cp 0
533+  CCEE CA 0D CD         jp z,robots_checkrightandmove0    ; if zero can't move
534+  CCF1 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
534+  CCF5 46 01
535+  CCF7 04               inc b
536+  CCF8 DD 71 00 DD      ld (ix),bc
536+  CCFC 70 01
537+  CCFE DD 36 06 01      ld (ix+6),1
538+  CD02 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
539+  CD06 DD 36 03 01      ld (ix+3),1                 ; set to right
540+  CD0A 3E 01            ld a,1
541+  CD0C C9               ret
542+  CD0D              robots_checkrightandmove0:
543+  CD0D 3E 00            ld a,0
544+  CD0F C9               ret
545+  CD10
546+  CD10              ;
547+  CD10              ; Draws a robot
548+  CD10              ; Inputs:
549+  CD10              ; ix - points to first byte of robot in array
550+  CD10              robots_draw:
551+  CD10 DD 4E 00 DD      ld bc,(ix)
551+  CD14 46 01
552+  CD16 21 0B B8         ld hl,robot_sprite                      ; set to the robot sprite
553+  CD19 DD 7E 02         ld a,(ix+2)                             ; get the state
554+  CD1C FE 02            cp 2                                    ; is this dying
555+  CD1E CA 39 CD         jp z,robots_draw1
556+  CD21              robots_draw3:
557+  CD21 DD 7E 03         ld a,(ix+3)                             ; get the direction
558+  CD24 FE 00            cp 0
559+  CD26 CA 2D CD         jp z,robots_draw0                       ; if left, nothing to do
560+  CD29 11 20 00         ld de,32
561+  CD2C 19               add hl,de                               ; add four frames to sprite
562+  CD2D              robots_draw0:
563+  CD2D DD 7E 04         ld a,(ix+4)                             ; get the anim frame
564+  CD30 11 00 00         ld de,0
565+  CD33 5F               ld e,a
566+  CD34 19               add hl,de                               ; add to base
567+  CD35 CD 2D AA         call sprites_drawsprite
568+  CD38 C9               ret
569+  CD39              ;
570+  CD39              ; Dying
571+  CD39              ;
572+  CD39              robots_draw1:
573+  CD39 DD 7E 05         ld a,(ix+5)                             ; get anim frames
574+  CD3C FE 00            cp 0                                    ; if zero this is the first time around
575+  CD3E C2 49 CD         jp nz,robots_draw2
576+  CD41 3E 18            ld a,24
577+  CD43 DD 77 05         ld (ix+5),a                             ; load up the anim frames
578+  CD46 C3 21 CD         jp robots_draw3                         ; return to main loop to draw as normal
579+  CD49              robots_draw2:
580+  CD49 3D               dec a
581+  CD4A DD 77 05         ld (ix+5),a
582+  CD4D FE 00            cp 0                                    ; have we reached the end yet
583+  CD4F C2 55 CD         jp nz, robots_draw4
584+  CD52 CD 61 CA         call robots_kill
585+  CD55              robots_draw4:
586+  CD55 C3 2D CD         jp robots_draw0
587+  CD58 C9               ret
588+  CD59
589+  CD59              ;
590+  CD59              ; Checks to see if the robot is hitting a player
591+  CD59              ; Inputs:
592+  CD59              ; ix - memory location of robot we're checking
593+  CD59              robots_checkforplayer:
594+  CD59 3A A2 BD         ld a,(player+11)     ; get player state
595+  CD5C FE 00            cp 0
596+  CD5E C0               ret nz               ; if already dying, don't kill again
597+  CD5F DD 4E 00 DD      ld bc,(ix)           ; get coords
597+  CD63 46 01
598+  CD65 ED 5B 97 BD      ld de,(player)       ; get the player coords
599+  CD69 7B               ld a,e               ; get the vert coord first
600+  CD6A 91               sub c                ; subtract the diamond vertical coord from players
601+  CD6B C6 08            add 8                ; add the max distance
602+  CD6D FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
603+  CD6F D0               ret nc               ; if not, hasn't hit
604+  CD70 7A               ld a,d               ; get the player horiz coord
605+  CD71 90               sub b                ; subtract rock coord
606+  CD72 C6 08            add 8                ; add max distance
607+  CD74 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
608+  CD76 D0               ret nc
609+  CD77 DD 36 02 00      ld (ix+2),0          ; mark as inactive
610+  CD7B CD C0 BE         call player_robotkillplayer ; mark the player as killed
611+  CD7E C9               ret
# file closed: game/robots.asm
 50   CD7F                  include "game\bullet.asm"
# file opened: game/bullet.asm
  1+  CD7F              ;
  2+  CD7F              ; Current state: x & y coords (screen), direction (0 left, 1 right), state
  3+  CD7F              ;
  4+  CD7F              bullet_state:
  5+  CD7F 00 00 00 00      defb 0,0,0,0
  6+  CD83
  7+  CD83              ;
  8+  CD83              ; Initialise a the bullet
  9+  CD83              ;
 10+  CD83              bullet_init:
 11+  CD83 DD 21 7F CD      ld ix,bullet_state
 12+  CD87 DD 36 00 00      ld (ix),0
 13+  CD8B DD 36 01 00      ld (ix+1),0
 14+  CD8F DD 36 02 00      ld (ix+2),0
 15+  CD93 DD 36 03 00      ld (ix+3),0
 16+  CD97 C9               ret
 17+  CD98
 18+  CD98              ;
 19+  CD98              ; Shoots the bullet
 20+  CD98              ;
 21+  CD98              bullet_shoot:
 22+  CD98 DD 21 7F CD      ld ix,bullet_state
 23+  CD9C ED 4B 97 BD      ld bc,(player)              ; get the player coords
 24+  CDA0 3A 99 BD         ld a,(player+2)             ; get the player direction
 25+  CDA3 FE 01            cp 1                        ; going left?
 26+  CDA5 CA B3 CD         jp z,bullet_shoot0
 27+  CDA8 3E 08            ld a,8
 28+  CDAA 80               add a,b                     ; going right so add eight to start coords
 29+  CDAB 47               ld b,a
 30+  CDAC DD 36 02 01      ld (ix+2),1                 ; set right
 31+  CDB0 C3 BC CD         jp bullet_shoot1
 32+  CDB3              bullet_shoot0:
 33+  CDB3 78               ld a,b
 34+  CDB4 06 08            ld b,8
 35+  CDB6 90               sub b
 36+  CDB7 47               ld b,a                      ; going left so subtract eight to start coords
 37+  CDB8 DD 36 02 00      ld (ix+2),0                 ; set right
 38+  CDBC              bullet_shoot1:
 39+  CDBC DD 71 00 DD      ld (ix),bc        ; store coords
 39+  CDC0 70 01
 40+  CDC2 DD 36 03 01      ld (ix+3),1       ; set state to 1
 41+  CDC6 CD 1C CE         call bullet_draw ; draw the initial frame
 42+  CDC9 C9               ret
 43+  CDCA
 44+  CDCA              ;
 45+  CDCA              ; Performs bullet processing
 46+  CDCA              ;
 47+  CDCA              bullet_process:
 48+  CDCA 3A 82 CD         ld a,(bullet_state+3)       ; get the state
 49+  CDCD FE 00            cp 0
 50+  CDCF C8               ret z                       ; don't draw if this has become inactive
 51+  CDD0 CD 1C CE         call bullet_draw            ; delete current frame
 52+  CDD3 CD E0 CD         call bullet_move            ; move the bullet
 53+  CDD6 3A 82 CD         ld a,(bullet_state+3)       ; get the state
 54+  CDD9 FE 00            cp 0
 55+  CDDB C8               ret z                       ; don't draw if this has become inactive
 56+  CDDC CD 1C CE         call bullet_draw            ; draw new frame
 57+  CDDF C9               ret
 58+  CDE0
 59+  CDE0              ;
 60+  CDE0              ; Moves the bullet, checking for collisions
 61+  CDE0              ;
 62+  CDE0              bullet_move:
 63+  CDE0 DD 21 7F CD      ld ix,bullet_state
 64+  CDE4 DD 4E 00 DD      ld bc,(ix)
 64+  CDE8 46 01
 65+  CDEA DD 7E 02         ld a,(ix+2)                 ; get the direction
 66+  CDED FE 00            cp 0                        ; going left?
 67+  CDEF CA F9 CD         jp z,bullet_move0
 68+  CDF2 3E 08            ld a,8
 69+  CDF4 80               add b
 70+  CDF5 47               ld b,a                      ; add 8 since going right
 71+  CDF6 C3 FE CD         jp bullet_move1
 72+  CDF9              bullet_move0:
 73+  CDF9 78               ld a,b
 74+  CDFA 06 08            ld b,8
 75+  CDFC 90               sub b
 76+  CDFD 47               ld b,a                      ; subtract 8 since going left
 77+  CDFE              bullet_move1:
 78+  CDFE DD 71 00 DD      ld (ix),bc                  ; store new coords
 78+  CE02 70 01
 79+  CE04 C5               push bc
 80+  CE05 CD 29 CE         call bullets_checkforrobot
 81+  CE08 C1               pop bc
 82+  CE09 FE 01            cp 1                        ; if we hit a robot, keep moving
 83+  CE0B C8               ret z
 84+  CE0C CD 22 AB         call sprites_scadd          ; get memory loc of this block into de
 85+  CE0F 21 60 00         ld hl,96
 86+  CE12 19               add hl,de
 87+  CE13 7E               ld a,(hl)                   ; get the content
 88+  CE14 FE 00            cp 0
 89+  CE16 C8               ret z                       ; if empty, continue
 90+  CE17 DD 36 03 00      ld (ix+3),0                 ; otherwise, mark bullet as inactive
 91+  CE1B C9               ret
 92+  CE1C
 93+  CE1C              ;
 94+  CE1C              ; Draw the bullet
 95+  CE1C              ;
 96+  CE1C              bullet_draw:
 97+  CE1C ED 4B 7F CD      ld bc,(bullet_state)        ; get coords
 98+  CE20 3E 1B            ld a,27
 99+  CE22 CD A8 A9         call screen_getblock        ; get the block address
100+  CE25 CD 2D AA         call sprites_drawsprite     ; draw the sprite
101+  CE28 C9               ret
102+  CE29
103+  CE29              ;
104+  CE29              ; Checks to see if the robot is hitting a bullet
105+  CE29              ; Outputs:
106+  CE29              ; a = 0 if not robot hit
107+  CE29              ; a = 1 if robot not hit
108+  CE29              bullets_checkforrobot:
109+  CE29 3E 00            ld a,0
110+  CE2B 32 7F CE         ld (bullets_tmp),a
111+  CE2E 3A F2 C9         ld a,(robots_robotsmax) ; robots to check
112+  CE31 47               ld b,a
113+  CE32 FD 21 C4 C9      ld iy,robots_robots   ; start of robot array
114+  CE36              bullets_checkforrobot0:
115+  CE36 C5               push bc
116+  CE37 FD 7E 02         ld a,(iy+2)             ; get the state
117+  CE3A FE 01            cp 1
118+  CE3C C2 73 CE         jp nz,bullets_checkforrobot1 ; if not active, don't check
119+  CE3F FD 5E 00 FD      ld de,(iy)              ; get robot coords
119+  CE43 56 01
120+  CE45 7A               ld a,d
121+  CE46 E6 F8            and 248                 ; get nearest multiple of 8
122+  CE48 57               ld d,a
123+  CE49 ED 4B 7F CD      ld bc,(bullet_state)    ; get bullet coords
124+  CE4D 7A               ld a,d               ; get the player horiz coord
125+  CE4E 90               sub b                ; subtract robot coord
126+  CE4F FE 00            cp 0                ; should be the same
127+  CE51 C2 5D CE         jp nz,bullets_checkforrobot2 ; if not, might have hit, so check the next char along... if matched, check vert
128+  CE54 3E 08            ld a,8
129+  CE56 82               add a,d
130+  CE57 90               sub b                ; check again for the next char along
131+  CE58 FE 00            cp 0
132+  CE5A C2 73 CE         jp nz,bullets_checkforrobot1 ; if not, haven't hit
133+  CE5D              bullets_checkforrobot2:
134+  CE5D 7B               ld a,e               ; get the vert coord
135+  CE5E 91               sub c                ; subtract the bullet vertical coord from robots
136+  CE5F C6 04            add 4                ; add the max distance
137+  CE61 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
138+  CE63 D2 73 CE         jp nc,bullets_checkforrobot1   ; if not, hasn't hit
139+  CE66 FD 36 02 02      ld (iy+2),2             ; mark the robot as killed
140+  CE6A FD 36 05 00      ld (iy+5),0             ; mark the anim frames as zero
141+  CE6E 3E 01            ld a,1
142+  CE70 32 7F CE         ld (bullets_tmp),a      ; hit the flag to say we killed a robot
143+  CE73              bullets_checkforrobot1:
144+  CE73 11 07 00         ld de,7
145+  CE76 FD 19            add iy,de              ; move to next robot
146+  CE78 C1               pop bc
147+  CE79 10 BB            djnz bullets_checkforrobot0
148+  CE7B 3A 7F CE         ld a,(bullets_tmp)
149+  CE7E C9               ret
150+  CE7F
151+  CE7F              bullets_tmp:
152+  CE7F 00               defb 0
153+  CE80
# file closed: game/bullet.asm
 51   CE80
 52   CE80              ;===========================================================================
 53   CE80              ; main routine - the code execution starts here.
 54   CE80              ; Sets up the new interrupt routine, the memory
 55   CE80              ; banks and jumps to the start loop.
 56   CE80              ;===========================================================================
 57   CE80              main:
 58   CE80 CD 22 AF         call options_show
 59   CE83
 60   CE83                  ; Draw the title screen
 61   CE83              main_titlescreen:
 62   CE83 CD 4C AB         call titlescreen_show
 63   CE86 CD DD BD         call player_init_gamestart
 64   CE89
 65   CE89              main_lifestart:
 66   CE89
 67   CE89 CD 03 BE         call player_init_lifestart
 68   CE8C
 69   CE8C CD CC AC         call lifescreen_draw        ; show the lives remaining screen
 70   CE8F
 71   CE8F CD 00 80         call init_start
 72   CE92 CD 24 A8         call screen_draw
 73   CE95 CD 73 A7         call buffer_allbuffertoscreen
 74   CE98
 75   CE98 CD DB C6         call missiles_init
 76   CE9B CD F2 BF         call ship_land              ; land the ship
 77   CE9E CD 05 C1         call tank_init
 78   CEA1 CD A3 C6         call diamonds_init
 79   CEA4 CD 8C C8         call thepit_init
 80   CEA7 CD 18 C9         call monster_init
 81   CEAA CD F3 C9         call robots_init
 82   CEAD CD 83 CD         call bullet_init
 83   CEB0
 84   CEB0              mloop:
 85   CEB0                  ;halt
 86   CEB0 CD E4 CE         call main_loop_processing
 87   CEB3
 88   CEB3                  ;
 89   CEB3                  ; Check if the player died
 90   CEB3                  ;
 91   CEB3 21 A1 BD         ld hl,player+10
 92   CEB6 7E               ld a,(hl)                   ; check if the player died this frame
 93   CEB7 FE 01            cp 1
 94   CEB9 C2 D0 CE         jp nz,mloop0
 95   CEBC CD 82 BE         call player_died        ; do end of life housekeeping
 96   CEBF 06 28            ld b,40
 97   CEC1 CD 9B 80         call utilities_pauseforframes
 98   CEC4 21 A0 BD         ld hl,player+9        ; check lives remaining
 99   CEC7 7E               ld a,(hl)
100   CEC8 FE 00            cp 0
101   CECA CA 18 CF         jp z,main_gameover   ; leave the loop if we're done
102   CECD C3 89 CE         jp main_lifestart    ; otherwise, start a new life
103   CED0              mloop0:
104   CED0                  ;
105   CED0                  ; Check if the player completed the level
106   CED0                  ;
107   CED0 21 A4 BD         ld hl,player+13
108   CED3 7E               ld a,(hl)
109   CED4 FE 01            cp 1
110   CED6 C2 B0 CE         jp nz,mloop
111   CED9 CD BC BF         call player_checkforexit
112   CEDC FE 01            cp 1                        ; look at return, if 1, level has been completed
113   CEDE CA 1E CF         jp z,main_endlevel          ; jump to level transition screen
114   CEE1 C3 B0 CE         jp mloop                ; start the loop again
115   CEE4
116   CEE4
117   CEE4              main_loop_processing:
118   CEE4
119   CEE4 CD 32 A7         call buffer_buffertoscreen  ; copy buffer to screen
120   CEE7 CD 97 A6         call buffer_clearlist       ; zero the updated lines list
121   CEEA CD A7 BD         call player_getlocation     ; figure out where the player is
122   CEED CD C6 BE         call player_drawplayer      ; delete player
123   CEF0 CD 5B B8         call control_input          ; check input
124   CEF3 CD C6 BE         call player_drawplayer      ; draw player
125   CEF6 CD 34 C1         call tank_process           ; prcoess the tank
126   CEF9 CD DD BF         call ship_process           ; proces the ship
127   CEFC CD 38 C3         call rocks_processrocks     ; process falling rocks
128   CEFF CD 97 C8         call thepit_process         ; process the pit trap
129   CF02 CD 03 C7         call missiles_process       ; process missiles
130   CF05 CD 35 C9         call monster_process        ; process monster
131   CF08 CD 76 CA         call robots_process         ; process robots
132   CF0B CD CA CD         call bullet_process         ; process the bullet
133   CF0E CD 82 C6         call diamonds_twinkle       ; make the diamonds twinkle
134   CF11 CD AB C4         call scores_printscore      ; update the score on screen
135   CF14 CD 77 BD         call game_incrementframe    ; increment the game frame
136   CF17
137   CF17 C9               ret
138   CF18
139   CF18              main_gameover:
140   CF18 CD 2C AD         call gameover_draw          ; show the game over screen
141   CF1B C3 83 CE         jp main_titlescreen         ; go back to title
142   CF1E
143   CF1E              main_endlevel:
144   CF1E CD 5C BE         call player_recordcurrentstate
145   CF21 CD 1A AE         call endlevel_draw          ; show the end level screen
146   CF24 C3 89 CE         jp main_lifestart           ; start a new life
147   CF27
148   CF27              ;===========================================================================
149   CF27              ; Stack.
150   CF27              ;===========================================================================
151   CF27
152   CF27              ; Stack: this area is reserved for the stack
153   CF27              STACK_SIZE: equ 100    ; in words
154   CF27
155   CF27              ; Reserve stack space
156   CF27 00 00            defw 0  ; WPMEM, 2
157   CF29              stack_bottom:
158   CF29 00 00 00...      defs    STACK_SIZE*2, 0
159   CFF1              stack_top:
160   CFF1 00 00            defw 0  ; WPMEM, 2
161   CFF3
162   CFF3                     SAVESNA "ThePit.sna", main
# file closed: main.asm
