# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 67 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 A2 A7         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 A3 A7         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 AC A5         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD BF BA         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 28 FB            jr z,utilities_waitforkey0           ; yes, so no key pressed.
 52+  8051 C9               ret                 ; key was pressed.
 53+  8052
 54+  8052              ;
 55+  8052              ; Waits number of frames for keypress. If got, returns 1, if not 0
 56+  8052              ; Inputs:
 57+  8052              ; a - number of frames to waits
 58+  8052              ; Ouputs:
 59+  8052              ; e - 0 not pressed, 1 pressed
 60+  8052              utilities_waitforkey_forframes:
 61+  8052 21 08 5C         ld hl,23560         ; LAST K system variable.
 62+  8055 36 00            ld (hl),0           ; put null value there.
 63+  8057 47               ld b,a              ; number of frames to wait
 64+  8058              utilities_waitforkey_forframes0:
 65+  8058 7E               ld a,(hl)           ; new value of LAST K.
 66+  8059 FE 00            cp 0                ; is it still zero?
 67+  805B 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 68+  805D 1E 01            ld e,1              ; set the pressed flag
 69+  805F C9               ret                 ; key was pressed.
 70+  8060              utilities_waitforkey_forframes1:
 71+  8060 76               halt                ; wait for frame
 72+  8061 76               halt                ; wait for frame
 73+  8062 10 F4            djnz utilities_waitforkey_forframes0 ; loop again
 74+  8064 1E 00            ld e,0              ; nothing pressed in time
 75+  8066 C9               ret
 76+  8067
 77+  8067              ;
 78+  8067              ; Clears the screen
 79+  8067              ; Inputs:
 80+  8067              ; a - attribute colour
 81+  8067              utilities_clearscreen:
 82+  8067 76               halt
 83+  8068 21 00 58         ld hl,22528         ; attr
 84+  806B 11 01 58         ld de,22529         ; attr+1
 85+  806E 01 FF 02         ld bc,767
 86+  8071 77               ld (hl),a
 87+  8072 ED B0            ldir
 88+  8074
 89+  8074 21 00 40         ld hl, 16384        ;pixels
 90+  8077 11 01 40         ld de, 16385        ;pixels + 1
 91+  807A 01 FF 17         ld bc, 6143         ;pixels area length - 1
 92+  807D 36 00            ld (hl), 0          ;set first byte to '0'
 93+  807F ED B0            ldir                ;copy bytes
 94+  8081
 95+  8081 C9               ret
 96+  8082
 97+  8082              ;
 98+  8082              ; Wait for a number of frames
 99+  8082              ; Inputs:
100+  8082              ; b - number of frames
101+  8082              utilities_pauseforframes:
102+  8082 76               halt
103+  8083 10 FD            djnz utilities_pauseforframes
104+  8085 C9               ret
105+  8086
106+  8086              utilities_readkey:
107+  8086 21 A6 80         LD HL,utilties_keymap              ; Point HL at the keyboard list
108+  8089 16 08            LD D,8                                  ; This is the number of ports (rows) to check
109+  808B 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
110+  808D              utilities_readkey_0:
111+  808D 46               LD B,(HL)                               ; Get the keyboard port address from table
112+  808E 23               INC HL                                  ; Increment to list of keys
113+  808F ED 78            IN A,(C)                                ; Read the row of keys in
114+  8091 E6 1F            AND $1F                                     ; We are only interested in the first five bits
115+  8093 1E 05            LD E,5                                  ; This is the number of keys in the row
116+  8095              utilities_readkey_1:
117+  8095 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
118+  8097 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
119+  8099 23               INC HL                                  ; Go to next table address
120+  809A 1D               DEC E                                   ; Decrement key loop counter
121+  809B 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
122+  809D 15               DEC D                                   ; Decrement row loop counter
123+  809E 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
124+  80A0 A7               AND A                                   ; Clear A (no key found)
125+  80A1 C3 86 80         jp utilities_readkey
126+  80A4              utilities_readkey_2:
127+  80A4 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
128+  80A5 C9               RET
129+  80A6
130+  80A6              utilties_keymap:
131+  80A6 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
131+  80AA 43 56
132+  80AC FD 41 53 44      defb $FD,"A","S","D","F","G"
132+  80B0 46 47
133+  80B2 FB 51 57 45      defb $FB,"Q","W","E","R","T"
133+  80B6 52 54
134+  80B8 F7 31 32 33      defb $F7,"1","2","3","4","5"
134+  80BC 34 35
135+  80BE EF 30 39 38      defb $EF,"0","9","8","7","6"
135+  80C2 37 36
136+  80C4 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
136+  80C8 55 59
137+  80CA BF 23 4C 4B      defb $BF,"#","L","K","J","H"
137+  80CE 4A 48
138+  80D0 7F 20 23 4D      defb $7F," ","#","M","N","B"
138+  80D4 4E 42
139+  80D6
140+  80D6
141+  80D6              ;
142+  80D6              ; Generates a randomish number in the range 0 to e
143+  80D6              ; Inputs:
144+  80D6              ; e - upper value
145+  80D6              ; Outputs:
146+  80D6              ; a - random number
147+  80D6              utilities_randomupper
148+  80D6 3A 95 BA         ld a,(game_framenumber)
149+  80D9 6F               ld l,a
150+  80DA 26 00            ld h,0
151+  80DC 16 00            ld d,0
152+  80DE 42 4B            ld bc,de
153+  80E0              utilities_randomupper0:
154+  80E0 B7               or a
155+  80E1 ED 42            sbc hl,bc
156+  80E3 F2 E0 80         jp p,utilities_randomupper0
157+  80E6 09               add hl,bc
158+  80E7 01 00 00         ld bc,0
159+  80EA 09               add hl,bc
160+  80EB 7D               ld a,l
161+  80EC C9               ret
# file closed: utilities.asm
 22   80ED                  include "strings.asm"
# file opened: strings.asm
  1+  80ED              string_score1:
  2+  80ED 04 00 53 43      defb 4,0,'SCORE1',255
  2+  80F1 4F 52 45 31
  2+  80F5 FF
  3+  80F6              string_scorenumbers1:
  4+  80F6 04 01 30 30      defb 4,1,'000000',255
  4+  80FA 30 30 30 30
  4+  80FE FF
  5+  80FF              string_company:
  6+  80FF 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  8103 4E 54 55 52
  6+  8107 49 FF
  7+  8109              string_credits:
  8+  8109 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  810D 41 59 45 52
  8+  8111 20 31 FF
  9+  8114              string_score2:
 10+  8114 16 00 53 43      defb 22,0,'SCORE2',255
 10+  8118 4F 52 45 32
 10+  811C FF
 11+  811D              string_scorenumbers2:
 12+  811D 16 01 30 30      defb 22,1,'000000',255
 12+  8121 30 30 30 30
 12+  8125 FF
 13+  8126              string_titlescreen_copyright:
 14+  8126 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 14+  812A 39 38 32 20
 14+  812E 20 43 45 4E
 14+  8132 54 55 52 49
 14+  8136 20 49 4E 43
 14+  813A FF
 15+  813B
 16+  813B
 17+  813B              string_alttitlescreen_1:
 18+  813B 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  813F 45 44 49 54
 18+  8143 53 20 31 FF
 19+  8147              string_alttitlescreen_2:
 20+  8147 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  814B 20 20 20 20
 20+  814F 20 20 20 20
 20+  8153 20 54 48 45
 20+  8157 20 4F 42 4A
 20+  815B 45 43 54 FE
 21+  815F 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  8163 20 20 20 20
 21+  8167 20 20 20 20
 21+  816B 4F 46 20 54
 21+  816F 48 49 53 20
 21+  8173 47 41 4D 45
 21+  8177 FE
 22+  8178 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  817C 20 20 20 20
 22+  8180 20 20 20 49
 22+  8184 53 20 54 4F
 22+  8188 20 44 49 47
 22+  818C 20 44 4F 57
 22+  8190 4E FE
 23+  8192 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  8196 20 20 20 20
 23+  819A 20 20 54 4F
 23+  819E 20 54 48 45
 23+  81A2 20 42 4F 54
 23+  81A6 54 4F 4D 20
 23+  81AA 50 49 54 FE
 24+  81AE 00 06 20 20      defb 0,6,'               AND',254
 24+  81B2 20 20 20 20
 24+  81B6 20 20 20 20
 24+  81BA 20 20 20 20
 24+  81BE 20 41 4E 44
 24+  81C2 FE
 25+  81C3 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  81C7 20 20 20 20
 25+  81CB 20 20 43 4F
 25+  81CF 4C 4C 45 43
 25+  81D3 54 20 41 54
 25+  81D7 20 4C 45 41
 25+  81DB 53 54 FE
 26+  81DE 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  81E2 20 20 20 20
 26+  81E6 20 20 20 4F
 26+  81EA 4E 45 20 4C
 26+  81EE 41 52 47 45
 26+  81F2 20 4A 45 57
 26+  81F6 45 4C FE
 27+  81F9 00 09 20 20      defb 0,9,'              THEN',254
 27+  81FD 20 20 20 20
 27+  8201 20 20 20 20
 27+  8205 20 20 20 20
 27+  8209 54 48 45 4E
 27+  820D FE
 28+  820E 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  8212 20 20 20 20
 28+  8216 20 20 20 52
 28+  821A 45 54 55 52
 28+  821E 4E 20 54 4F
 28+  8222 20 53 48 49
 28+  8226 50 FE
 29+  8228 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  822C 20 20 20 20
 29+  8230 20 20 20 54
 29+  8234 48 52 55 20
 29+  8238 55 50 50 45
 29+  823C 52 20 50 49
 29+  8240 54 FF
 30+  8242              string_alttitlescreen_3:
 31+  8242 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  8246 20 20 53 49
 31+  824A 4E 47 4C 45
 31+  824E 20 42 4F 4E
 31+  8252 55 53 20 20
 31+  8256 35 30 30 30
 31+  825A 20 50 4F 49
 31+  825E 4E 54 53 FE
 32+  8262 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  8266 20 20 20 20
 32+  826A 43 4F 4C 4C
 32+  826E 45 43 54 20
 32+  8272 31 20 4C 41
 32+  8276 52 47 45 20
 32+  827A 4A 45 57 45
 32+  827E 4C FE
 33+  8280 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  8284 20 20 20 20
 33+  8288 20 41 4E 44
 33+  828C 20 52 45 54
 33+  8290 55 52 4E 20
 33+  8294 54 4F 20 53
 33+  8298 48 49 50 FE
 34+  829C 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  82A0 20 20 44 4F
 34+  82A4 55 42 4C 45
 34+  82A8 20 42 4F 4E
 34+  82AC 55 53 20 20
 34+  82B0 31 30 30 30
 34+  82B4 30 20 50 4F
 34+  82B8 49 4E 54 53
 34+  82BC FE
 35+  82BD 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  82C1 20 20 43 4F
 35+  82C5 4C 4C 45 43
 35+  82C9 54 20 41 4C
 35+  82CD 4C 20 33 20
 35+  82D1 4C 41 52 47
 35+  82D5 45 20 4A 45
 35+  82D9 57 45 4C 53
 35+  82DD FE
 36+  82DE 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  82E2 20 20 20 20
 36+  82E6 20 4F 52 20
 36+  82EA 20 20 41 4C
 36+  82EE 4C 20 34 20
 36+  82F2 53 4D 41 4C
 36+  82F6 4C 20 4A 45
 36+  82FA 57 45 4C 53
 36+  82FE FE
 37+  82FF 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  8303 20 20 54 52
 37+  8307 49 50 4C 45
 37+  830B 20 42 4F 4E
 37+  830F 55 53 20 20
 37+  8313 31 35 30 30
 37+  8317 30 20 50 4F
 37+  831B 49 4E 54 53
 37+  831F FE
 38+  8320 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  8324 20 20 20 20
 38+  8328 20 43 4F 4C
 38+  832C 4C 45 43 54
 38+  8330 20 41 4C 4C
 38+  8334 20 37 20 4A
 38+  8338 45 57 45 4C
 38+  833C 53 FF
 39+  833E
 40+  833E              string_lifescreen_player:
 41+  833E 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  8342 4C 41 59 45
 41+  8346 52 20 31 20
 41+  834A FF
 42+  834B              string_lifescreen_lives:
 43+  834B 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  834F 4D 45 4E 20
 43+  8353 4C 45 46 54
 43+  8357 FF
 44+  8358              string_lifescreen_lastman:
 45+  8358 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  835C 53 54 20 4D
 45+  8360 41 4E FF
 46+  8363
 47+  8363              string_gameoverscreen_gameover:
 48+  8363 0C 06 47 41      defb 12,6,'GAME OVER',255
 48+  8367 4D 45 20 4F
 48+  836B 56 45 52 FF
 49+  836F              string_gameoverscreen_copyright:
 50+  836F 05 12 7F 20      defb 5,18,127,' 1982 AW ZILEC ELC LTD',255
 50+  8373 31 39 38 32
 50+  8377 20 41 57 20
 50+  837B 5A 49 4C 45
 50+  837F 43 20 45 4C
 50+  8383 43 20 4C 54
 50+  8387 44 FF
 51+  8389              string_gameoverscreen_bestscores:
 52+  8389 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  838D 53 54 20 53
 52+  8391 43 4F 52 45
 52+  8395 53 20 54 4F
 52+  8399 44 41 59 FF
 53+  839D              string_gameover_credits:
 54+  839D 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  83A1 45 44 49 54
 54+  83A5 53 20 30 FF
 55+  83A9
 56+  83A9              string_highscore_congratulations:
 57+  83A9 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 57+  83AD 4E 47 52 41
 57+  83B1 54 55 4C 41
 57+  83B5 54 49 4F 4E
 57+  83B9 53 FF
 58+  83BB              string_highscore_player1:
 59+  83BB 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 59+  83BF 41 59 45 52
 59+  83C3 20 31 FF
 60+  83C6              string_highscore_player2:
 61+  83C6 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 61+  83CA 41 59 45 52
 61+  83CE 20 32 FF
 62+  83D1              string_highscore_youhaveearned:
 63+  83D1 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 63+  83D5 55 20 48 41
 63+  83D9 56 45 20 45
 63+  83DD 41 52 4E 45
 63+  83E1 44 FF
 64+  83E3              string_highscore_place1:
 65+  83E3 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 65+  83E7 45 20 47 52
 65+  83EB 45 41 54 45
 65+  83EF 53 54 20 53
 65+  83F3 43 4F 52 45
 65+  83F7 FF
 66+  83F8              string_highscore_place2:
 67+  83F8 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 67+  83FC 45 20 32 4E
 67+  8400 44 20 42 45
 67+  8404 53 54 20 53
 67+  8408 43 4F 52 45
 67+  840C FF
 68+  840D              string_highscore_place3:
 69+  840D 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 69+  8411 45 20 33 52
 69+  8415 44 20 42 45
 69+  8419 53 54 20 53
 69+  841D 43 4F 52 45
 69+  8421 FF
 70+  8422              string_highscore_pleaseenter
 71+  8422 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 71+  8426 43 4F 52 44
 71+  842A 20 59 4F 55
 71+  842E 52 20 49 4E
 71+  8432 49 54 49 41
 71+  8436 4C 53 20 42
 71+  843A 45 4C 4F 57
 71+  843E FF
 72+  843F
 73+  843F              string_endlevel_youhaveearned:
 74+  843F 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 74+  8443 55 20 48 41
 74+  8447 56 45 20 45
 74+  844B 41 52 4E 45
 74+  844F 44 FF
 75+  8451              string_endlevel_bonus1:
 76+  8451 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 76+  8455 4E 47 4C 45
 76+  8459 20 42 4F 4E
 76+  845D 55 53 FF
 77+  8460              string_endlevel_bonus2:
 78+  8460 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 78+  8464 55 42 4C 45
 78+  8468 20 42 4F 4E
 78+  846C 55 53 FF
 79+  846F              string_endlevel_bonus3:
 80+  846F 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 80+  8473 49 50 4C 45
 80+  8477 20 42 4F 4E
 80+  847B 55 53 FF
 81+  847E              string_endlevel_points1:
 82+  847E 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 82+  8482 30 30 20 50
 82+  8486 4F 49 4E 54
 82+  848A 53 FF
 83+  848C              string_endlevel_points2:
 84+  848C 09 0F 31 30      defb 9,15,'10000 POINTS',255
 84+  8490 30 30 30 20
 84+  8494 50 4F 49 4E
 84+  8498 54 53 FF
 85+  849B              string_endlevel_points3:
 86+  849B 09 0F 31 35      defb 9,15,'15000 POINTS',255
 86+  849F 30 30 30 20
 86+  84A3 50 4F 49 4E
 86+  84A7 54 53 FF
 87+  84AA              string_endlevel_anothergo:
 88+  84AA 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 88+  84AE 56 45 20 41
 88+  84B2 4E 4F 54 48
 88+  84B6 45 52 20 47
 88+  84BA 4F FF
 89+  84BC
 90+  84BC              string_zonk:
 91+  84BC 00 00 5A 4F      defb 0,0,'ZONK!',255
 91+  84C0 4E 4B 21 FF
 92+  84C4              ;
 93+  84C4              ; Prints specified string
 94+  84C4              ; Inputs:
 95+  84C4              ; de: pointer to string
 96+  84C4              ; bc: length of string
 97+  84C4              ;
 98+  84C4              ; Print String Data
 99+  84C4              ; First two bytes of string contain X and Y char position, then the string
100+  84C4              ; Individual strings are terminated with 0xFE
101+  84C4              ; End of data is terminated with 0xFF
102+  84C4              ; HL: Address of string
103+  84C4              ;
104+  84C4 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
105+  84C5 23                                   INC HL                          ; Increase HL to the next memory location
106+  84C6 56                                   LD D,(HL)                       ; Fetch the Y coordinate
107+  84C7 23                                   INC HL                          ; Increase HL to the next memory location
108+  84C8 CD DB 84                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
109+  84CB 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
110+  84CC 23                                   INC HL                          ; Increase HL to the next character
111+  84CD FE FE                                CP 0xFE                         ; Compare with 0xFE
112+  84CF 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
113+  84D1 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
114+  84D2 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
115+  84D3 CD EB 84                             CALL Print_Char                 ; Print the character
116+  84D6 E1                                   POP HL                          ; Retrieve HL back off the stack
117+  84D7 1C                                   INC E                           ; Go to the next screen address
118+  84D8 18 F1                                JR string_print_0               ; Loop back to print next character
119+  84DA C9                                   RET
120+  84DB
121+  84DB              ; Get screen address
122+  84DB              ; D = Y character position
123+  84DB              ; E = X character position
124+  84DB              ; Returns address in DE
125+  84DB              ;
126+  84DB 7A           string_getcharaddress:       LD A,D
127+  84DC E6 07                                AND %00000111
128+  84DE 1F                                   RRA
129+  84DF 1F                                   RRA
130+  84E0 1F                                   RRA
131+  84E1 1F                                   RRA
132+  84E2 B3                                   OR E
133+  84E3 5F                                   LD E,A
134+  84E4 7A                                   LD A,D
135+  84E5 E6 18                                AND %00011000
136+  84E7 F6 40                                OR %01000000
137+  84E9 57                                   LD D,A
138+  84EA C9                                   RET                             ; Returns screen address in DE
139+  84EB
140+  84EB              ; Print a single character out
141+  84EB              ; A:  Character to print
142+  84EB              ; DE: Screen address to print character at
143+  84EB              ;
144+  84EB 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
145+  84EE 06 00                                LD B,0                          ; Set BC to A
146+  84F0 4F                                   LD C,A
147+  84F1 E6 FF                                AND 0xFF                        ; Clear the carry bit
148+  84F3 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
149+  84F5 CB 10                                RL B
150+  84F7 CB 11                                RL C
151+  84F9 CB 10                                RL B
152+  84FB CB 11                                RL C
153+  84FD CB 10                                RL B
154+  84FF 09                                   ADD HL,BC                       ; Get the character address in HL
155+  8500 0E 08                                LD C,8                          ; Loop counter
156+  8502 D5                                   PUSH DE
157+  8503 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
158+  8504 12                                   LD (DE),A                       ; Stick A onto the screen
159+  8505 14                                   INC D                           ; Goto next line on screen
160+  8506 2C                                   INC L                           ; Goto next byte of character
161+  8507 0D                                   DEC C                           ; Decrease the loop counter
162+  8508 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
163+  850A D1                                   POP DE
164+  850B C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   850C                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  850C              buffer_buffer:
  2+  850C 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A20C
  4+  A20C              buffer_attr_buffer:
  5+  A20C 00 00 00...      defs 928                    ; attrs buffer area
  6+  A5AC
  7+  A5AC              buffer_tmp:
  8+  A5AC 00 00            defb 0,0                    ; temp area
  9+  A5AE
 10+  A5AE              buffer_updatedlines:
 11+  A5AE FF FF FF...      defs 21,255
 12+  A5C3
 13+  A5C3              ;
 14+  A5C3              ; This is a list of attr offsets
 15+  A5C3              ;
 16+  A5C3              buffer_updatedattroffsets:
 17+  A5C3 FF FF FF...      defs 40,255
 18+  A5EB
 19+  A5EB              buffer_updateall:
 20+  A5EB 00               defb 0
 21+  A5EC
 22+  A5EC              ;
 23+  A5EC              ; Stores a line number in the update list
 24+  A5EC              ; Inputs:
 25+  A5EC              ; a - row number
 26+  A5EC              buffer_marklineforupdate:
 27+  A5EC FE 15            cp 21
 28+  A5EE D0               ret nc                          ; dont store lines that we shouldn't draw
 29+  A5EF 5F               ld e,a                          ; store in e
 30+  A5F0 06 15            ld b,21
 31+  A5F2 21 AE A5         ld hl,buffer_updatedlines
 32+  A5F5              buffer_marklineforupdate0:
 33+  A5F5 7E               ld a,(hl)                       ; get the line stored in updated lines
 34+  A5F6 BB               cp e                            ; is this the same as the row number passed in?
 35+  A5F7 C8               ret z                           ; if so, don't need to do anything
 36+  A5F8 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 37+  A5FA C2 FF A5         jp nz,buffer_marklineforupdate1 ; if not, move to next
 38+  A5FD 73               ld (hl),e                       ; if it is, this spot is empty, so store the row number
 39+  A5FE C9               ret                             ; and finish
 40+  A5FF              buffer_marklineforupdate1:
 41+  A5FF 23               inc hl
 42+  A600 10 F3            djnz buffer_marklineforupdate0
 43+  A602 C9               ret
 44+  A603
 45+  A603              ;
 46+  A603              ; Stores an attr coord in the update list
 47+  A603              ; Inputs:
 48+  A603              ; bc - coords
 49+  A603              buffer_markattrforupdate:
 50+  A603 50 59            ld de,bc
 51+  A605 06 14            ld b,20
 52+  A607 DD 21 C3 A5      ld ix,buffer_updatedattroffsets
 53+  A60B              buffer_markattrforupdate0:
 54+  A60B DD 6E 00 DD      ld hl,(ix)                       ; get the line stored in updated attrs
 54+  A60F 66 01
 55+  A611 A7               and a                           ; clear carry
 56+  A612 7D               ld a,l                          ; store the low byte for later
 57+  A613 ED 52            sbc hl,de                       ; compare - is it the same
 58+  A615 C8               ret z                           ; if so, don't need to do anything
 59+  A616 DD 6E 00 DD      ld hl,(ix)                       ; get the line stored in updated attrs again
 59+  A61A 66 01
 60+  A61C FE FF            cp 255                          ; is this 255, ie the end of the buffer
 61+  A61E C2 28 A6         jp nz,buffer_markattrforupdate1 ; if not, move to next
 62+  A621 DD 73 00 DD      ld (ix),de                       ; if it is, this spot is empty, so store the coords
 62+  A625 72 01
 63+  A627 C9               ret                             ; and finish
 64+  A628              buffer_markattrforupdate1:
 65+  A628 DD 23            inc ix
 66+  A62A DD 23            inc ix
 67+  A62C 10 DD            djnz buffer_markattrforupdate0
 68+  A62E C9               ret
 69+  A62F
 70+  A62F              ;
 71+  A62F              ; Zeroes the updated lines list
 72+  A62F              ;
 73+  A62F              buffer_clearlist:
 74+  A62F 06 15            ld b,21                         ; includes attrs as well
 75+  A631 21 AE A5         ld hl,buffer_updatedlines
 76+  A634              buffer_clearlist0:
 77+  A634 36 FF            ld (hl),255
 78+  A636 23               inc hl
 79+  A637 10 FB            djnz buffer_clearlist0
 80+  A639
 81+  A639
 82+  A639 C9               ret
 83+  A63A
 84+  A63A              ;
 85+  A63A              ; Copies the buffer to the screen. Use stack.
 86+  A63A              ; Inputs:
 87+  A63A              ; a - row number to display - 0 is first line
 88+  A63A              ;
 89+  A63A              buffer_bufferlinetoscreen:
 90+  A63A 4F               ld c,a                          ; store a
 91+  A63B ED 5B A2 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
 92+  A63F 83               add a,e                       ; add the row number
 93+  A640 11 00 01         ld de,256
 94+  A643 CD 3A 80         call utilities_multiply
 95+  A646 54 5D            ld de,hl
 96+  A648 21 0C 85         ld hl,buffer_buffer
 97+  A64B 19               add hl,de                   ; add the offset
 98+  A64C 79               ld a,c                      ; get original row back
 99+  A64D ED 73 AB A6      ld (buffer_bufferlinetoscreen1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
100+  A651 D9               exx
101+  A652 0E 00            ld c,0                      ; zero horizontal
102+  A654 47               ld b,a                      ; load the row number into vertical coord
103+  A655 04               inc b
104+  A656 04               inc b                       ; move forward 2 to allow for scores
105+  A657 CD 8C A8         call screen_getcelladdress  ; get the memory into de
106+  A65A 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
107+  A65D 19               add hl,de
108+  A65E              buffer_bufferlinetoscreen0:
109+  A65E D9               exx                         ; hl is now buffer
110+  A65F 23               inc hl
111+  A660 23               inc hl                      ; move hl forward 2 to skip first two blocks
112+  A661 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
113+  A662 F1               pop af
114+  A663 C1               pop bc
115+  A664 D1               pop de
116+  A665 DD E1            pop ix
117+  A667 D9               exx                         ; hl is now screen
118+  A668 08               ex af,af'
119+  A669 F1               pop af
120+  A66A C1               pop bc
121+  A66B D1               pop de
122+  A66C F9               ld sp,hl                    ; sp pointing at screen
123+  A66D D5               push de
124+  A66E C5               push bc
125+  A66F F5               push af
126+  A670 08               ex af,af'
127+  A671 D9               exx                         ; hl is now buffer
128+  A672 DD E5            push ix
129+  A674 D5               push de
130+  A675 C5               push bc
131+  A676 F5               push af
132+  A677 1E 0E            ld e,14                    ; do another fourteen for right hand side
133+  A679 16 00            ld d,0
134+  A67B 19               add hl,de
135+  A67C F9               ld sp,hl                    ; sp pointing at buffer
136+  A67D F1               pop af
137+  A67E C1               pop bc
138+  A67F D1               pop de
139+  A680 DD E1            pop ix
140+  A682                  ;pop ix
141+  A682 D9               exx                         ; hl is now screen
142+  A683 08               ex af,af'
143+  A684 1E 0E            ld e,14
144+  A686 16 00            ld d,0
145+  A688 19               add hl,de
146+  A689 F1               pop af
147+  A68A C1               pop bc
148+  A68B D1               pop de
149+  A68C                  ;pop iy
150+  A68C F9               ld sp,hl                    ; sp pointing at screen
151+  A68D                  ;push iy
152+  A68D D5               push de
153+  A68E C5               push bc
154+  A68F F5               push af
155+  A690 08               ex af,af'
156+  A691 D9               exx                         ; hl is now buffer
157+  A692 DD E5            push ix
158+  A694 D5               push de
159+  A695 C5               push bc
160+  A696 F5               push af
161+  A697 1E 10            ld e,16
162+  A699 16 00            ld d,0
163+  A69B 19               add hl,de
164+  A69C D9               exx                         ; hl is now screen
165+  A69D 1E 0E            ld e,14
166+  A69F 16 00            ld d,0
167+  A6A1 ED 52            sbc hl,de
168+  A6A3 24               inc h
169+  A6A4 7C               ld a,h
170+  A6A5 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
171+  A6A7 C2 5E A6         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
172+  A6AA              buffer_bufferlinetoscreen1:
173+  A6AA 31 00 00         ld sp,0
174+  A6AD D9               exx
175+  A6AE C9               ret
176+  A6AF
177+  A6AF              ;
178+  A6AF              ; Copies the buffer to the screen for updated lines. Use stack.
179+  A6AF              ; Inputs: none
180+  A6AF              ;
181+  A6AF              buffer_buffertoscreen:
182+  A6AF 3A EB A5         ld a,(buffer_updateall)      ; get the all update flag
183+  A6B2 FE 00            cp 0
184+  A6B4 CA C0 A6         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
185+  A6B7 CD E1 A6         call buffer_allbuffertoscreen ; otherwise, draw whole screen
186+  A6BA 21 EB A5         ld hl,buffer_updateall
187+  A6BD 36 00            ld (hl),0                    ; reset flag
188+  A6BF C9               ret
189+  A6C0              buffer_buffertoscreen2:
190+  A6C0 06 15            ld b,21
191+  A6C2 FD 21 AE A5      ld iy,buffer_updatedlines    ; the location of the updated lines
192+  A6C6              buffer_buffertoscreen0:
193+  A6C6 FD 7E 00         ld a,(iy)
194+  A6C9 FE FF            cp 255
195+  A6CB CA DD A6         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
196+  A6CE C5               push bc
197+  A6CF FD E5            push iy
198+  A6D1 F3               di
199+  A6D2 CD 3A A6         call buffer_bufferlinetoscreen
200+  A6D5 FB               ei
201+  A6D6 FD E1            pop iy
202+  A6D8 C1               pop bc
203+  A6D9 FD 23            inc iy
204+  A6DB 10 E9            djnz buffer_buffertoscreen0
205+  A6DD              buffer_buffertoscreen1:
206+  A6DD CD 2F A7         call buffer_buffertoattrsfast
207+  A6E0 C9               ret
208+  A6E1
209+  A6E1              ;
210+  A6E1              ; Copies the buffer to the screen. Use stack.
211+  A6E1              ; Inputs: none
212+  A6E1              ;
213+  A6E1              buffer_allbuffertoscreen:
214+  A6E1 06 15            ld b,21
215+  A6E3 3E 00            ld a,0
216+  A6E5              buffer_allbuffertoscreen0:
217+  A6E5 C5               push bc
218+  A6E6 F5               push af
219+  A6E7 F3               di
220+  A6E8 CD 3A A6         call buffer_bufferlinetoscreen
221+  A6EB FB               ei
222+  A6EC F1               pop af
223+  A6ED C1               pop bc
224+  A6EE 3C               inc a
225+  A6EF 10 F4            djnz buffer_allbuffertoscreen0
226+  A6F1
227+  A6F1 F3               di
228+  A6F2 CD 2F A7         call buffer_buffertoattrsfast
229+  A6F5 FB               ei
230+  A6F6 C9               ret
231+  A6F7
232+  A6F7              ;
233+  A6F7              ; Copies the updated attrs from the buffer
234+  A6F7              ;
235+  A6F7              buffer_buffertoupdatedattrs:
236+  A6F7 06 28            ld b,40                         ; this many to check
237+  A6F9 DD 21 C3 A5      ld ix,buffer_updatedattroffsets
238+  A6FD              buffer_buffertoupdatedattrs0:
239+  A6FD C5               push bc
240+  A6FE DD 4E 00 DD      ld bc,(ix)
240+  A702 46 01
241+  A704 79               ld a,c                          ; get the low byte
242+  A705 FE FF            cp 255
243+  A707 CA 2D A7         jp z,buffer_buffertoupdatedattrs1 ; return if we've reached the end of the buffer
244+  A70A CD 9D A8         call screen_getcellattradress   ; get the buffer memory for these coords
245+  A70D 1A               ld a,(de)                       ; get the value in the buffer
246+  A70E 08               ex af,af'
247+  A70F DD 4E 00 DD      ld bc,(ix)
247+  A713 46 01
248+  A715 ED 5B A2 A7      ld de,(screen_offset)           ; get the offset
249+  A719 78               ld a,b
250+  A71A 93               sub e
251+  A71B 47               ld b,a                          ; subtract the offset from the vertical
252+  A71C CD C9 A8         call screen_getscreenattradress ; get screen memory into de
253+  A71F 21 40 00         ld hl,64                        ; 32 for score lines
254+  A722 19               add hl,de
255+  A723 08               ex af,af'
256+  A724 77               ld (hl),a                       ; write to the screen
257+  A725 DD 23            inc ix
258+  A727 DD 23            inc ix                          ; get to the next coord
259+  A729 C1               pop bc
260+  A72A 10 D1            djnz buffer_buffertoupdatedattrs0
261+  A72C C9               ret
262+  A72D              buffer_buffertoupdatedattrs1:
263+  A72D C1               pop bc
264+  A72E C9               ret
265+  A72F
266+  A72F              ;
267+  A72F              ; Copies the attrs buffer to screen with the stack
268+  A72F              ;
269+  A72F              buffer_buffertoattrsfast:
270+  A72F ED 73 9E A7      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
271+  A733 3A A2 A7         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
272+  A736 11 20 00         ld de,32
273+  A739 CD 3A 80         call utilities_multiply
274+  A73C 54 5D            ld de,hl
275+  A73E 21 0C A2         ld hl,buffer_attr_buffer
276+  A741 19               add hl,de                       ; add the offset, start of attr buffer now in hl
277+  A742 D9               exx
278+  A743 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
279+  A746 FD 21 AC A5      ld iy,buffer_tmp
280+  A74A FD 36 00 15      ld (iy),21              ; number of times to loop
281+  A74E              buffer_buffertoattrsfast0:
282+  A74E D9               exx                         ; hl is now buffer
283+  A74F 23               inc hl
284+  A750 23               inc hl                      ; move hl forward 2 to skip first two blocks
285+  A751 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
286+  A752 F1               pop af
287+  A753 C1               pop bc
288+  A754 D1               pop de
289+  A755 DD E1            pop ix
290+  A757 D9               exx                         ; hl is now screen
291+  A758 08               ex af,af'
292+  A759 F1               pop af
293+  A75A C1               pop bc
294+  A75B D1               pop de
295+  A75C F9               ld sp,hl                    ; sp pointing at screen
296+  A75D D5               push de
297+  A75E C5               push bc
298+  A75F F5               push af
299+  A760 08               ex af,af'
300+  A761 D9               exx                         ; hl is now buffer
301+  A762 DD E5            push ix
302+  A764 D5               push de
303+  A765 C5               push bc
304+  A766 F5               push af
305+  A767 1E 0E            ld e,14                    ; do another fourteen for right hand side
306+  A769 16 00            ld d,0
307+  A76B 19               add hl,de
308+  A76C F9               ld sp,hl                    ; sp pointing at buffer
309+  A76D F1               pop af
310+  A76E C1               pop bc
311+  A76F D1               pop de
312+  A770 DD E1            pop ix
313+  A772 D9               exx                         ; hl is now screen
314+  A773 08               ex af,af'
315+  A774 1E 0E            ld e,14
316+  A776 16 00            ld d,0
317+  A778 19               add hl,de
318+  A779 F1               pop af
319+  A77A C1               pop bc
320+  A77B D1               pop de
321+  A77C F9               ld sp,hl                    ; sp pointing at screen
322+  A77D D5               push de
323+  A77E C5               push bc
324+  A77F F5               push af
325+  A780 08               ex af,af'
326+  A781 D9               exx                         ; hl is now buffer
327+  A782 DD E5            push ix
328+  A784 D5               push de
329+  A785 C5               push bc
330+  A786 F5               push af
331+  A787 1E 10            ld e,16
332+  A789 16 00            ld d,0
333+  A78B 19               add hl,de
334+  A78C D9               exx                         ; hl is now screen
335+  A78D 11 12 00         ld de,18
336+  A790 19               add hl,de
337+  A791 FD 7E 00         ld a,(iy)
338+  A794 3D               dec a
339+  A795 FE 00            cp 0
340+  A797 FD 77 00         ld (iy),a
341+  A79A C2 4E A7         jp nz,buffer_buffertoattrsfast0 ; do another row
342+  A79D              buffer_buffertoattrsfast1:
343+  A79D 31 00 00         ld sp,0
344+  A7A0 D9               exx
345+  A7A1 C9               ret
# file closed: screen/buffer.asm
 24   A7A2                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A7A2              screen_offset:
  2+  A7A2 00               defb 0                      ; offset from top of screen in lines
  3+  A7A3
  4+  A7A3              screen_tmp:
  5+  A7A3 00 00            defb 0,0                      ; temporary memory
  6+  A7A5
  7+  A7A5              screen_setscorecolours:
  8+  A7A5 21 A7 B3         ld hl,score_colours
  9+  A7A8 11 00 58         ld de,22528                     ; attrs here
 10+  A7AB 01 40 00         ld bc,64
 11+  A7AE ED B0            ldir
 12+  A7B0 C9               ret
 13+  A7B1
 14+  A7B1              screen_sethighscorecolours:
 15+  A7B1 21 E7 B3         ld hl,high_score_colours
 16+  A7B4 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A7B7 01 20 00         ld bc,32
 18+  A7BA ED B0            ldir
 19+  A7BC C9               ret
 20+  A7BD
 21+  A7BD              ; Draw the screen
 22+  A7BD              ; Inputs:
 23+  A7BD              ; none
 24+  A7BD              ; Notes:
 25+  A7BD              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A7BD              screen_draw:
 27+  A7BD                  ;call clear_screen
 28+  A7BD 0E 00            ld c,0                      ; horiz
 29+  A7BF 06 00            ld b,0                      ; vert, 0 at top
 30+  A7C1 DD 21 69 AE      ld ix,level01               ; point ix at level data
 31+  A7C5 FD 21 0C A2      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A7C9              screen_draw0:
 33+  A7C9 DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A7CC C5               push bc                     ; store bc, contains loop count
 35+  A7CD CD 58 A9         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A7D0 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A7D1 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A7D4 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A7D7 CD 38 A9         call screen_getblock        ; get the block data into hl
 40+  A7DA CD 1E A9         call screen_showchar        ; show this character here
 41+  A7DD C1               pop bc                      ; get the loop counter back
 42+  A7DE DD 23            inc ix                      ; increment level location
 43+  A7E0 FD 23            inc iy                      ; increment attr location
 44+  A7E2 0C               inc c                       ; increment horiz
 45+  A7E3 79               ld a,c
 46+  A7E4 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A7E6 C2 C9 A7         jp nz,screen_draw0          ; if not, loop
 48+  A7E9 0E 00            ld c,0                      ; if so, reset horiz
 49+  A7EB 04               inc b                       ; increment vertical
 50+  A7EC 78               ld a,b
 51+  A7ED FE 1D            cp 29                       ; check if at bottom
 52+  A7EF C2 C9 A7         jp nz,screen_draw0          ; if not, loop
 53+  A7F2 21 A3 A7         ld hl, screen_tmp
 54+  A7F5 36 09            ld (hl),9                   ; load the block number into memory
 55+  A7F7 DD 21 09 B2      ld ix,level01rocks          ; rock memory
 56+  A7FB CD 5C A8         call screen_initobjects     ; draw rocks
 57+  A7FE 21 A3 A7         ld hl, screen_tmp
 58+  A801 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A803 DD 21 09 B3      ld ix,level01missiles       ; missile memory
 60+  A807 CD 5C A8         call screen_initobjects     ; draw missiles
 61+  A80A 21 A3 A7         ld hl, screen_tmp
 62+  A80D 36 08            ld (hl),08                  ; load the block number into memory
 63+  A80F DD 21 82 B3      ld ix,level01diamonds       ; diamond memory
 64+  A813 CD 5C A8         call screen_initobjects     ; draw diamonds
 65+  A816 21 A3 A7         ld hl, screen_tmp
 66+  A819 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A81B DD 21 92 B3      ld ix,level01gems           ; gems memory
 68+  A81F CD 5C A8         call screen_initobjects     ; draw gems
 69+  A822 CD 29 A8         call screen_setuptext       ; draws text on the screen
 70+  A825 CD B1 C1         call scores_printscores     ; print the current scores
 71+  A828 C9               ret
 72+  A829
 73+  A829              ;
 74+  A829              ; Sets up text on the screen
 75+  A829              ;
 76+  A829              screen_setuptext:
 77+  A829 CD D3 C1         call scores_showtable
 78+  A82C CD B1 A7         call screen_sethighscorecolours
 79+  A82F 21 ED 80         ld hl, string_score1
 80+  A832 CD C4 84         call string_print
 81+  A835 21 F6 80         ld hl, string_scorenumbers1
 82+  A838 CD C4 84         call string_print
 83+  A83B 21 FF 80         ld hl, string_company
 84+  A83E CD C4 84         call string_print
 85+  A841 21 14 81         ld hl, string_score2
 86+  A844 CD C4 84         call string_print
 87+  A847 21 1D 81         ld hl, string_scorenumbers2
 88+  A84A CD C4 84         call string_print
 89+  A84D 21 09 81         ld hl, string_credits
 90+  A850 CD C4 84         call string_print
 91+  A853 CD A5 A7         call screen_setscorecolours
 92+  A856 C9               ret
 93+  A857
 94+  A857              ;
 95+  A857              ; Sets a line of colours
 96+  A857              ; Inputs:
 97+  A857              ; a - colour to set
 98+  A857              ; b - number to set
 99+  A857              ; de - start memory location
100+  A857              ;
101+  A857              screen_setcolours:
102+  A857 12               ld (de),a
103+  A858 13               inc de
104+  A859 10 FC            djnz screen_setcolours
105+  A85B C9               ret
106+  A85C
107+  A85C              ;
108+  A85C              ; Draw initial object positions
109+  A85C              ; Inputs:
110+  A85C              ; ix - memory location of objects
111+  A85C              ; a - graphic
112+  A85C              screen_initobjects:
113+  A85C DD 4E 00         ld c,(ix)                   ; get the horiz coord
114+  A85F 79               ld a,c
115+  A860 FE FF            cp 255
116+  A862 CA 8B A8         jp z,screen_initobjects2
117+  A865 DD 23            inc ix                      ; move to next
118+  A867 DD 46 00         ld b,(ix)                   ; get the vert coord
119+  A86A DD 23            inc ix
120+  A86C CD 9D A8         call screen_getcellattradress ; get the memory address of b,c attr into de
121+  A86F D5               push de
122+  A870 3A A3 A7         ld a,(screen_tmp)                  ; get the block number back
123+  A873 CD 58 A9         call screen_getattr         ; get the memory location for this cell's attr into hl
124+  A876 D1               pop de
125+  A877 7E               ld a,(hl)                   ; get the attr value at the address
126+  A878 12               ld (de),a                   ; load the attr into memory
127+  A879 3A A3 A7         ld a,(screen_tmp)                  ; get the block number back
128+  A87C CD 38 A9         call screen_getblock        ; get the block data into hl
129+  A87F CD 1E A9         call screen_showchar        ; show this character here
130+  A882
131+  A882              screen_initobjects1:
132+  A882 DD 23            inc ix                      ; move past state
133+  A884 DD 23            inc ix
134+  A886 DD 23            inc ix                      ; move past mem
135+  A888 C3 5C A8         jp screen_initobjects
136+  A88B              screen_initobjects2:
137+  A88B C9               ret
138+  A88C
139+  A88C
140+  A88C              ;
141+  A88C              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
142+  A88C              ; Inputs:
143+  A88C              ; bc: coords
144+  A88C              ; Outputs:
145+  A88C              ; de: memory location
146+  A88C              ;
147+  A88C              screen_getcelladdress:
148+  A88C 78               ld a,b      ; vertical position.
149+  A88D E6 18            and 24      ; which segment, 0, 1 or 2?
150+  A88F C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
151+  A891 57               ld d,a      ; this is our high byte.
152+  A892 78               ld a,b      ; what was that vertical position again?
153+  A893 E6 07            and 7       ; which row within segment?
154+  A895 0F               rrca        ; multiply row by 32.
155+  A896 0F               rrca
156+  A897 0F               rrca
157+  A898 5F               ld e,a      ; low byte.
158+  A899 79               ld a,c      ; add on y coordinate.
159+  A89A 83               add a,e     ; mix with low byte.
160+  A89B 5F               ld e,a      ; address of screen position in de.
161+  A89C C9               ret
162+  A89D
163+  A89D              ;
164+  A89D              ; Calculate buffer address of attribute for character at (b, c).
165+  A89D              ; Inputs:
166+  A89D              ; bc: coords
167+  A89D              ; Outputs:
168+  A89D              ; de: memory location
169+  A89D              ;
170+  A89D              screen_getcellattradress:
171+  A89D 11 0C A2         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
172+  A8A0 69               ld l,c      ; x position.
173+  A8A1 26 00            ld h,0      ; 0 h
174+  A8A3 19               add hl,de
175+  A8A4 54 5D            ld de,hl    ; horiz done
176+  A8A6 78               ld a,b      ; do vert
177+  A8A7 D5               push de
178+  A8A8 C5               push bc
179+  A8A9 11 20 00         ld de,32
180+  A8AC CD 3A 80         call utilities_multiply
181+  A8AF C1               pop bc
182+  A8B0 D1               pop de
183+  A8B1 19               add hl,de
184+  A8B2 54 5D            ld de,hl    ; vert done
185+  A8B4 C9               ret
186+  A8B5
187+  A8B5              ;
188+  A8B5              ; Calculate buffer address offset of attribute for character at (b, c).
189+  A8B5              ; Inputs:
190+  A8B5              ; bc: coords
191+  A8B5              ; Outputs:
192+  A8B5              ; de: memory location
193+  A8B5              ;
194+  A8B5              screen_getcellattroffset:
195+  A8B5 69               ld l,c      ; x position.
196+  A8B6 26 00            ld h,0      ; 0 h
197+  A8B8 54 5D            ld de,hl    ; horiz done
198+  A8BA 78               ld a,b      ; do vert
199+  A8BB D5               push de
200+  A8BC C5               push bc
201+  A8BD 11 20 00         ld de,32
202+  A8C0 CD 3A 80         call utilities_multiply
203+  A8C3 C1               pop bc
204+  A8C4 D1               pop de
205+  A8C5 19               add hl,de
206+  A8C6 54 5D            ld de,hl    ; vert done
207+  A8C8 C9               ret
208+  A8C9
209+  A8C9              ;
210+  A8C9              ; Calculate buffer address of attribute for character at (b, c).
211+  A8C9              ; Inputs:
212+  A8C9              ; bc: coords
213+  A8C9              ; Outputs:
214+  A8C9              ; de: memory location
215+  A8C9              ;
216+  A8C9              screen_getscreenattradress:
217+  A8C9 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
218+  A8CC 69               ld l,c      ; x position.
219+  A8CD 26 00            ld h,0      ; 0 h
220+  A8CF 19               add hl,de
221+  A8D0 54 5D            ld de,hl    ; horiz done
222+  A8D2 78               ld a,b      ; do vert
223+  A8D3 D5               push de
224+  A8D4 C5               push bc
225+  A8D5 11 20 00         ld de,32
226+  A8D8 CD 3A 80         call utilities_multiply
227+  A8DB C1               pop bc
228+  A8DC D1               pop de
229+  A8DD 19               add hl,de
230+  A8DE 54 5D            ld de,hl    ; vert done
231+  A8E0 C9               ret
232+  A8E1
233+  A8E1              ;
234+  A8E1              ; Gets the attr memory location for a screen coord
235+  A8E1              ; Will overwrite bc
236+  A8E1              ; Inputs:
237+  A8E1              ; bc - screen coords
238+  A8E1              ; Outputs:
239+  A8E1              ; de - memory location
240+  A8E1              ; bc - character coords
241+  A8E1              ;
242+  A8E1              screen_getattraddressfromscreencoords:
243+  A8E1 78               ld a,b                          ; get the player block coords of current block
244+  A8E2 E6 F8            and 248                         ; find closest multiple of eight
245+  A8E4 0F               rrca
246+  A8E5 0F               rrca
247+  A8E6 0F               rrca                ; divide by 8
248+  A8E7 47               ld b,a
249+  A8E8 79               ld a,c
250+  A8E9 48               ld c,b                         ; swap b and c
251+  A8EA E6 F8            and 248
252+  A8EC 0F               rrca
253+  A8ED 0F               rrca
254+  A8EE 0F               rrca                ; divide by 8
255+  A8EF 47               ld b,a
256+  A8F0 CD 9D A8         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
257+  A8F3 C9               ret
258+  A8F4
259+  A8F4
260+  A8F4              ; Gets the nearest cell coords for a screen coord
261+  A8F4              ; Will overwrite bc
262+  A8F4              ; Inputs:
263+  A8F4              ; bc - screen coords
264+  A8F4              ; Outputs:
265+  A8F4              ; bc - character coords
266+  A8F4              ;
267+  A8F4              screen_getcharcoordsfromscreencoords:
268+  A8F4 78               ld a,b                          ; get the player block coords of current block
269+  A8F5 E6 F8            and 248                         ; find closest multiple of eight
270+  A8F7 0F               rrca
271+  A8F8 0F               rrca
272+  A8F9 0F               rrca                ; divide by 8
273+  A8FA 47               ld b,a
274+  A8FB 79               ld a,c
275+  A8FC 48               ld c,b                         ; swap b and c
276+  A8FD E6 F8            and 248
277+  A8FF 0F               rrca
278+  A900 0F               rrca
279+  A901 0F               rrca                ; divide by 8
280+  A902 47               ld b,a
281+  A903 C9               ret
282+  A904
283+  A904              ; Gets the screen coords for a cell coord
284+  A904              ; Will overwrite bc
285+  A904              ; Inputs:
286+  A904              ; bc - char coords
287+  A904              ; Outputs:
288+  A904              ; bc - screen coords
289+  A904              ;
290+  A904              screen_getscreencoordsfromcharcoords:
291+  A904 78               ld a,b                          ; get the player block coords of current block
292+  A905 07               rlca
293+  A906 07               rlca
294+  A907 07               rlca                ; multiply by 8
295+  A908 47               ld b,a
296+  A909 79               ld a,c
297+  A90A 48               ld c,b                         ; swap b and c
298+  A90B 07               rlca
299+  A90C 07               rlca
300+  A90D 07               rlca                ; divide by 8
301+  A90E 47               ld b,a
302+  A90F C9               ret
303+  A910
304+  A910              ;
305+  A910              ; Get buffer address for a character at b,c - b vert
306+  A910              ; Buffer memory is stored as sequential block
307+  A910              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
308+  A910              ; Inputs:
309+  A910              ; bc - coords
310+  A910              ; Outputs:
311+  A910              ; de - memory location of first byte
312+  A910              screen_getbufferaddress:
313+  A910 21 0C 85         ld hl, buffer_buffer    ; first get screen buffer start
314+  A913 50               ld d,b                  ; then work out vertical offset
315+  A914 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
316+  A916 19               add hl,de               ; add to base
317+  A917 59               ld e,c                  ; then add horizontal offset (c)
318+  A918 16 00            ld d,0
319+  A91A 19               add hl,de               ; add to base
320+  A91B 54 5D            ld de,hl
321+  A91D C9               ret
322+  A91E
323+  A91E              ;
324+  A91E              ; Display character hl at (b, c) to buffer.
325+  A91E              ; Stored sequentially
326+  A91E              ; Inputs:
327+  A91E              ; hl: block address
328+  A91E              ; bc: coords
329+  A91E              ;
330+  A91E              screen_showchar:
331+  A91E 3E 00            ld a,0
332+  A920 E5               push hl
333+  A921 CD 10 A9         call screen_getbufferaddress ; get the current screen buffer pointer
334+  A924 E1               pop hl
335+  A925 06 08            ld b,8              ; number of pixels high.
336+  A927              screen_showchar0:
337+  A927 7E               ld a,(hl)           ; source graphic.
338+  A928 12               ld (de),a           ; transfer to screen.
339+  A929 23               inc hl              ; next piece of data.
340+  A92A E5               push hl             ; store hl
341+  A92B 62 6B            ld hl,de            ; put de in hl
342+  A92D 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
343+  A92F 16 00            ld d,0
344+  A931 19               add hl,de              ; add de to hl
345+  A932 54 5D            ld de,hl            ; load back to de
346+  A934 E1               pop hl              ; restore hl
347+  A935
348+  A935 10 F0            djnz screen_showchar0 ; repeat
349+  A937 C9               ret
350+  A938
351+  A938
352+  A938              ;
353+  A938              ; Get cell graphic.
354+  A938              ; Inputs:
355+  A938              ; a: block
356+  A938              ; Outputs:
357+  A938              ; hl: memory
358+  A938              ;
359+  A938              screen_getblock:
360+  A938 07               rlca                        ; multiply block number by eight.
361+  A939 07               rlca
362+  A93A 07               rlca
363+  A93B 5F               ld e,a                      ; displacement to graphic address.
364+  A93C 16 00            ld d,0                      ; no high byte.
365+  A93E 21 07 B4         ld hl,sprites               ; address of character blocks.
366+  A941 19               add hl,de                   ; point to block.
367+  A942 C9               ret
368+  A943
369+  A943              ;
370+  A943              ; Set a the attr of a coord
371+  A943              ; Inputs:
372+  A943              ; bc - char coords
373+  A943              ; a - attr
374+  A943              ;
375+  A943              screen_setattr:
376+  A943 DD E5            push ix
377+  A945 C5               push bc
378+  A946 08               ex af, af'
379+  A947 CD B5 A8         call screen_getcellattroffset   ; get offset into de
380+  A94A 21 0C A2         ld hl,buffer_attr_buffer
381+  A94D 19               add hl,de                       ; get the memory location
382+  A94E 08               ex af, af'                      ; get attr back
383+  A94F 77               ld (hl),a                         ; set the attr
384+  A950 C1               pop bc
385+  A951 DD E1            pop ix
386+  A953 C9               ret
387+  A954              screen_setattr0:
388+  A954 C1               pop bc
389+  A955 DD E1            pop ix
390+  A957 C9               ret
391+  A958
392+  A958              ;
393+  A958              ; Get cell attribute.
394+  A958              ; Inputs:
395+  A958              ; a: block
396+  A958              ; Outputs:
397+  A958              ; hl: memory
398+  A958              ;
399+  A958              screen_getattr:
400+  A958 5F               ld e,a                      ; displacement to attribute address.
401+  A959 16 00            ld d,0                      ; no high byte.
402+  A95B 21 DF B4         ld hl,sprite_attrs          ; address of block attributes.
403+  A95E 19               add hl,de                   ; point to attribute.
404+  A95F C9               ret
405+  A960
406+  A960              ;
407+  A960              ; Checks whether a character block has anything in it
408+  A960              ; Inputs:
409+  A960              ; bc - char coords
410+  A960              ; Outputs:
411+  A960              ; a - 1, empty
412+  A960              screen_ischarempty:
413+  A960 CD 10 A9         call screen_getbufferaddress ; get the current screen buffer pointer
414+  A963 06 08            ld b,8                      ; check 8 rows
415+  A965              screen_ischarempty2:
416+  A965 1A               ld a,(de)                   ; check line
417+  A966 FE 00            cp 0
418+  A968 C2 76 A9         jp nz,screen_ischarempty1   ; if not zero, jump out with false
419+  A96B 21 20 00         ld hl,32
420+  A96E 19               add hl,de
421+  A96F 54 5D            ld de,hl                    ; move to next row
422+  A971 10 F2            djnz screen_ischarempty2
423+  A973              screen_ischarempty0:
424+  A973 3E 01            ld a,1
425+  A975 C9               ret
426+  A976              screen_ischarempty1:
427+  A976 3E 00            ld a,0
428+  A978 C9               ret
429+  A979
430+  A979              ;
431+  A979              ; Copies a block from one place to another directly underneath, leaves the original empty
432+  A979              ; Inputs:
433+  A979              ; bc - coords of block to copy from
434+  A979              screen_copyblockdown
435+  A979 CD 10 A9         call screen_getbufferaddress ; get the current screen buffer pointer for source
436+  A97C 06 08            ld b,8                      ; copy 8 rows
437+  A97E              screen_copyblock0:
438+  A97E 1A               ld a,(de)                    ; get what we're copying
439+  A97F 08               ex af,af'
440+  A980 3E 00            ld a,0
441+  A982 12               ld (de),a                    ; replace with empty
442+  A983 08               ex af,af'
443+  A984 14               inc d                        ; add 256 to get to the next row
444+  A985 12               ld (de),a                    ; copy to the next row
445+  A986 15               dec d
446+  A987 21 20 00         ld hl,32
447+  A98A 19               add hl,de                       ; return back to source, next row down
448+  A98B 54 5D            ld de,hl
449+  A98D 10 EF            djnz screen_copyblock0
450+  A98F C9               ret
451+  A990
452+  A990              ;
453+  A990              ; Returns the first byte of a character. Useful for figuring out what's there
454+  A990              ; Inputs:
455+  A990              ; bc - coords
456+  A990              ; Outputs:
457+  A990              ; a - first byte
458+  A990              ;
459+  A990              screen_getcharfirstbyte:
460+  A990 CD 10 A9         call screen_getbufferaddress ; get the current screen buffer pointer for source
461+  A993 1A               ld a,(de)
462+  A994 C9               ret
463+  A995
# file closed: screen/screen.asm
 25   A995                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  A995              ;
  2+  A995              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  A995              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  A995              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  A995              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  A995              ; routine takes care of all the shifting itself. This means that sprite
  7+  A995              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  A995              ; space they would require in pre-shifted form.
  9+  A995              ; Inputs:
 10+  A995              ; hl - sprite data
 11+  A995              ; bc - screen coords
 12+  A995              ;
 13+  A995              sprites_drawsprite7:
 14+  A995 EE 07            xor 7               ; complement last 3 bits.
 15+  A997 3C               inc a               ; add one for luck!
 16+  A998              sprites_drawsprite3:
 17+  A998 CB 11            rl c                ; ...into middle byte...
 18+  A99A CB 12            rl d                ; ...and finally into left character cell.
 19+  A99C 3D               dec a               ; count shifts we've done.
 20+  A99D 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  A99F                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  A99F 79               ld a,c              ; left edge of image is currently in e.
 23+  A9A0 4A               ld c,d              ; put right edge there instead.
 24+  A9A1 57               ld d,a              ; and the left edge back into c.
 25+  A9A2 18 25            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  A9A4              sprites_drawsprite:
 27+  A9A4 ED 43 6B AA      ld (dispx),bc       ; store coords in dispx for now.
 28+  A9A8 E5               push hl
 29+  A9A9 CD 49 AA         call sprites_scadd  ; calculate screen address.
 30+  A9AC E1               pop hl
 31+  A9AD 3E 08            ld a,8              ; height of sprite in pixels.
 32+  A9AF              sprites_drawsprite1:
 33+  A9AF 08               ex af,af'           ; store loop counter.
 34+  A9B0 D5               push de             ; store screen address.
 35+  A9B1 4E               ld c,(hl)           ; first sprite graphic.
 36+  A9B2 23               inc hl              ; increment poiinter to sprite data.
 37+  A9B3 22 6D AA         ld (sprtmp),hl      ; store it for later.
 38+  A9B6 16 00            ld d,0              ; blank right byte for now.
 39+  A9B8 78               ld a,b              ; b holds y position.
 40+  A9B9 E6 07            and 7               ; how are we straddling character cells?
 41+  A9BB 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 42+  A9BD FE 05            cp 5                ; 5 or more right shifts needed?
 43+  A9BF 30 D4            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 44+  A9C1 A7               and a               ; oops, carry flag is set so clear it.
 45+  A9C2              sprites_drawsprite2:
 46+  A9C2 CB 19            rr c                ; rotate left byte right...
 47+  A9C4 CB 1A            rr d                ; ...into right byte.
 48+  A9C6 3D               dec a               ; one less shift to do.
 49+  A9C7 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 50+  A9C9              sprites_drawsprite0:
 51+  A9C9 E1               pop hl              ; pop screen address from stack.
 52+  A9CA 7E               ld a,(hl)           ; what's there already.
 53+  A9CB A9               xor c               ; merge in image data.
 54+  A9CC 77               ld (hl),a           ; place onto screen.
 55+  A9CD 23               inc hl
 56+  A9CE 7E               ld a,(hl)           ; what's already there.
 57+  A9CF AA               xor d               ; right edge of sprite image data.
 58+  A9D0 77               ld (hl),a           ; plonk it on screen.
 59+  A9D1 3A 6B AA         ld a,(dispx)        ; vertical coordinate.
 60+  A9D4 3C               inc a               ; next line down.
 61+  A9D5 32 6B AA         ld (dispx),a        ; store new position.
 62+  A9D8 2B               dec hl
 63+  A9D9 11 20 00         ld de,32            ; add 32 to get to the next row
 64+  A9DC 19               add hl,de           ; add 32
 65+  A9DD              sprites_drawsprite6:
 66+  A9DD EB               ex de,hl            ; screen address in de.
 67+  A9DE 2A 6D AA         ld hl,(sprtmp)      ; restore graphic address.
 68+  A9E1 08               ex af,af'           ; restore loop counter.
 69+  A9E2 3D               dec a               ; decrement it.
 70+  A9E3 C2 AF A9         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 71+  A9E6 C9               ret                 ; job done.
 72+  A9E7
 73+  A9E7              ; Inputs:
 74+  A9E7              ; hl - sprite data
 75+  A9E7              ; bc - screen coords
 76+  A9E7              ;
 77+  A9E7              sprites_draw2by2sprite7
 78+  A9E7 EE 07            xor 7               ; complement last 3 bits.
 79+  A9E9 3C               inc a               ; add one for luck!
 80+  A9EA              sprites_draw2by2sprite3
 81+  A9EA CB 12            rl d                ; rotate left...
 82+  A9EC CB 11            rl c                ; ...into middle byte...
 83+  A9EE CB 13            rl e                ; ...and finally into left character cell.
 84+  A9F0 3D               dec a               ; count shifts we've done.
 85+  A9F1 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 86+  A9F3                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 87+  A9F3 7B               ld a,e              ; left edge of image is currently in e.
 88+  A9F4 5A               ld e,d              ; put right edge there instead.
 89+  A9F5 51               ld d,c              ; middle bit goes in d.
 90+  A9F6 4F               ld c,a              ; and the left edge back into c.
 91+  A9F7 18 2D            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 92+  A9F9              sprites_draw2by2sprite
 93+  A9F9 ED 43 6B AA      ld (dispx),bc       ; store coords in dispx for now.
 94+  A9FD 79               ld a,c
 95+  A9FE 32 6F AA         ld (sprtmp0),a         ; store vertical.
 96+  AA01 E5               push hl
 97+  AA02 CD 49 AA         call sprites_scadd          ; calculate screen address.
 98+  AA05 E1               pop hl
 99+  AA06 3E 10            ld a,16             ; height of sprite in pixels.
100+  AA08              sprites_draw2by2sprite1
101+  AA08 08               ex af,af'           ; store loop counter.
102+  AA09 D5               push de             ; store screen address.
103+  AA0A 4E               ld c,(hl)           ; first sprite graphic.
104+  AA0B 23               inc hl              ; increment poiinter to sprite data.
105+  AA0C 56               ld d,(hl)           ; next bit of sprite image.
106+  AA0D 23               inc hl              ; point to next row of sprite data.
107+  AA0E 22 6D AA         ld (sprtmp),hl        ; store in tmp0 for later.
108+  AA11 1E 00            ld e,0              ; blank right byte for now.
109+  AA13 78               ld a,b              ; b holds y position.
110+  AA14 E6 07            and 7               ; how are we straddling character cells?
111+  AA16 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
112+  AA18 FE 05            cp 5                ; 5 or more right shifts needed?
113+  AA1A 30 CB            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
114+  AA1C A7               and a               ; oops, carry flag is set so clear it.
115+  AA1D              sprites_draw2by2sprite2
116+  AA1D CB 19            rr c                ; rotate left byte right...
117+  AA1F CB 1A            rr d                ; ...through middle byte...
118+  AA21 CB 1B            rr e                ; ...into right byte.
119+  AA23 3D               dec a               ; one less shift to do.
120+  AA24 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
121+  AA26              sprites_draw2by2sprite0
122+  AA26 E1               pop hl              ; pop screen address from stack.
123+  AA27 7E               ld a,(hl)           ; what's there already.
124+  AA28 A9               xor c               ; merge in image data.
125+  AA29 77               ld (hl),a           ; place onto screen.
126+  AA2A 23               inc hl               ; next character cell to right please.
127+  AA2B 7E               ld a,(hl)           ; what's there already.
128+  AA2C AA               xor d               ; merge with middle bit of image.
129+  AA2D 77               ld (hl),a           ; put back onto screen.
130+  AA2E 23               inc hl              ; next bit of screen area.
131+  AA2F 7E               ld a,(hl)           ; what's already there.
132+  AA30 AB               xor e               ; right edge of sprite image data.
133+  AA31 77               ld (hl),a           ; plonk it on screen.
134+  AA32 3A 6F AA         ld a,(sprtmp0)         ; temporary vertical coordinate.
135+  AA35 3C               inc a               ; next line down.
136+  AA36 32 6F AA         ld (sprtmp0),a         ; store new position.
137+  AA39 2B               dec hl
138+  AA3A 2B               dec hl
139+  AA3B 11 20 00         ld de,32            ; add 32 to get to the next row
140+  AA3E 19               add hl,de           ; add 32
141+  AA3F              sprites_draw2by2sprite6
142+  AA3F EB               ex de,hl            ; screen address in de.
143+  AA40 2A 6D AA         ld hl,(sprtmp)        ; restore graphic address.
144+  AA43 08               ex af,af'           ; restore loop counter.
145+  AA44 3D               dec a               ; decrement it.
146+  AA45 C2 08 AA         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
147+  AA48 C9               ret                 ; job done.
148+  AA49
149+  AA49
150+  AA49              ;
151+  AA49              ; This routine returns a buffer address for (c, b) in de (c vert).
152+  AA49              ; For example: 0,0 will be at memory offset 0
153+  AA49              ; 1,0 (1 down) will be at memory offset 1
154+  AA49              ; 0,7 will be at memory offset 0
155+  AA49              ; 9,1 will be at memory offset 8+1
156+  AA49              ; 8,0 will be at memory offset 256
157+  AA49              ; 9,0 will be at memory offset 257
158+  AA49              ; Outputs:
159+  AA49              ; de - coords
160+  AA49              ;
161+  AA49              sprites_scadd:
162+  AA49 79               ld a,c               ; calculate vertical offset
163+  AA4A E6 F8            and 248             ;  to get nearest multiple of 8
164+  AA4C 0F               rrca
165+  AA4D 0F               rrca
166+  AA4E 0F               rrca                ; divide by 8
167+  AA4F 67               ld h,a
168+  AA50 78               ld a,b               ; calculate horizontal offset
169+  AA51 E6 F8            and 248             ;  to get nearest multiple of 8
170+  AA53 0F               rrca
171+  AA54 0F               rrca
172+  AA55 0F               rrca                ; divide by 8
173+  AA56 6F               ld l,a
174+  AA57 C5               push bc             ; store the screen coords
175+  AA58 44 4D            ld bc,hl            ; load bc with the character coords
176+  AA5A CD 10 A9         call screen_getbufferaddress
177+  AA5D C1               pop bc              ; get back screen coords, de is now memory of character
178+  AA5E 79               ld a,c              ; now add the vertical within the cell
179+  AA5F E6 07            and 7
180+  AA61 0F               rrca                ; multiply by 32.
181+  AA62 0F               rrca
182+  AA63 0F               rrca
183+  AA64 6F               ld l,a
184+  AA65 26 00            ld h,0
185+  AA67 19               add hl,de
186+  AA68 54 5D            ld de,hl
187+  AA6A C9               ret
188+  AA6B
189+  AA6B 00           dispx   defb 0           ; general-use coordinates.
190+  AA6C 00           dispy   defb 0
191+  AA6D 00 00        sprtmp  defb 0,0           ; sprite temporary address.
192+  AA6F 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
193+  AA71
# file closed: screen/sprites.asm
 26   AA71                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AA71              ;
  2+  AA71              ; Draws the title screen
  3+  AA71              ;
  4+  AA71              titlescreen_show:
  5+  AA71 CD E9 AA         call titlescreen_init
  6+  AA74 CD 92 AA         call titlescreen_drawtitle
  7+  AA77 3E FA            ld a,250                              ; wait for 200 frames
  8+  AA79 CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
  9+  AA7C 7B               ld a,e
 10+  AA7D FE 01            cp 1                                  ; was anything pressed?
 11+  AA7F C8               ret z                                 ; end titlescreen if so
 12+  AA80
 13+  AA80 CD FC AA         call titlescreen_alt_init             ; otherwise, draw alt screen
 14+  AA83 CD AE AA         call titlescreen_alt_drawtitle
 15+  AA86 3E FA            ld a,250                              ; wait for 200 frames
 16+  AA88 CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 17+  AA8B 7B               ld a,e
 18+  AA8C FE 01            cp 1                                  ; was anything pressed?
 19+  AA8E C2 71 AA         jp nz,titlescreen_show                ; start again if not
 20+  AA91 C9               ret
 21+  AA92
 22+  AA92              ;
 23+  AA92              ; Draws the iconic logo
 24+  AA92              ;
 25+  AA92              titlescreen_drawtitle:
 26+  AA92 06 67            ld b,103              ; number of points
 27+  AA94 DD 21 09 AB      ld ix,titlescreen_logo_data
 28+  AA98              titlescreen_drawtitle0:
 29+  AA98 C5               push bc
 30+  AA99 DD 4E 00         ld c,(ix)                   ; got horiz
 31+  AA9C DD 23            inc ix
 32+  AA9E DD 46 00         ld b,(ix)                   ; got vert
 33+  AAA1 DD 23            inc ix
 34+  AAA3 CD C9 A8         call screen_getscreenattradress ; memory in de
 35+  AAA6 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 36+  AAA7 3E 13            ld a,19
 37+  AAA9 12               ld (de),a
 38+  AAAA C1               pop bc
 39+  AAAB 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 40+  AAAD C9               ret
 41+  AAAE
 42+  AAAE              ;
 43+  AAAE              ; Draws the alternate title screen
 44+  AAAE              ;
 45+  AAAE              titlescreen_alt_drawtitle:
 46+  AAAE 21 3B 81         ld hl,string_alttitlescreen_1
 47+  AAB1 CD C4 84         call string_print
 48+  AAB4 21 47 81         ld hl,string_alttitlescreen_2
 49+  AAB7 CD C4 84         call string_print
 50+  AABA 21 42 82         ld hl,string_alttitlescreen_3
 51+  AABD CD C4 84         call string_print
 52+  AAC0 06 20            ld b,32
 53+  AAC2 3E 43            ld a,67
 54+  AAC4 11 00 58         ld de,22528                         ; top row attrs here
 55+  AAC7 CD 57 A8         call screen_setcolours
 56+  AACA 06 20            ld b,32
 57+  AACC 3E 46            ld a,70
 58+  AACE 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 59+  AAD1 CD 57 A8         call screen_setcolours
 60+  AAD4 06 20            ld b,32
 61+  AAD6 3E 43            ld a,67
 62+  AAD8 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 63+  AADB CD 57 A8         call screen_setcolours
 64+  AADE 06 20            ld b,32
 65+  AAE0 3E 42            ld a,66
 66+  AAE2 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 67+  AAE5 CD 57 A8         call screen_setcolours
 68+  AAE8 C9               ret
 69+  AAE9
 70+  AAE9              ;
 71+  AAE9              ; Initialises the screen
 72+  AAE9              ;
 73+  AAE9              titlescreen_init:
 74+  AAE9              ; We want a black screen.
 75+  AAE9 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 76+  AAEB                                      ; bright (64).
 77+  AAEB CD 67 80         call utilities_clearscreen
 78+  AAEE 32 8D 5C         ld (23693),a        ; set our screen colours.
 79+  AAF1 3E 01            ld a,1              ; 2 is the code for red.
 80+  AAF3 D3 FE            out (254),a         ; write to port 254.
 81+  AAF5
 82+  AAF5 21 26 81         ld hl,string_titlescreen_copyright
 83+  AAF8 CD C4 84         call string_print
 84+  AAFB
 85+  AAFB C9               ret
 86+  AAFC
 87+  AAFC              ;
 88+  AAFC              ; Initialises the screen
 89+  AAFC              ;
 90+  AAFC              titlescreen_alt_init:
 91+  AAFC              ; We want a black screen.
 92+  AAFC 3E 47            ld a,71             ; white ink (7) on black paper (0),
 93+  AAFE                                      ; bright (64).
 94+  AAFE CD 67 80         call utilities_clearscreen
 95+  AB01 32 8D 5C         ld (23693),a        ; set our screen colours.
 96+  AB04 3E 00            ld a,0              ; 2 is the code for red.
 97+  AB06 D3 FE            out (254),a         ; write to port 254.
 98+  AB08
 99+  AB08 C9               ret
100+  AB09
101+  AB09              ;
102+  AB09              ; Horiz, vert
103+  AB09              ;
104+  AB09              titlescreen_logo_data:
105+  AB09 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
105+  AB0D 0A 00 0C 00
105+  AB11 0F 00 11 00
105+  AB15 12 00 13 00
106+  AB19 09 01 0C 01      defb 9,1,12,1,15,1,17,1
106+  AB1D 0F 01 11 01
107+  AB21 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
107+  AB25 0D 02 0E 02
107+  AB29 0F 02 11 02
107+  AB2D 12 02 13 02
108+  AB31 09 03 0C 03      defb 9,3,12,3,15,3,17,3
108+  AB35 0F 03 11 03
109+  AB39 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
109+  AB3D 0F 04 11 04
109+  AB41 12 04 13 04
110+  AB45 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
110+  AB49 02 06 03 06
110+  AB4D 04 06 05 06
110+  AB51 06 06 07 06
110+  AB55 08 06 09 06
110+  AB59 0A 06 0B 06
111+  AB5D 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
111+  AB61 12 06 13 06
111+  AB65 14 06 15 06
111+  AB69 16 06 17 06
111+  AB6D 18 06 19 06
111+  AB71 1A 06 1B 06
112+  AB75 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
112+  AB79 02 09 02 0A
112+  AB7D 02 0B 02 0C
112+  AB81 02 0D 02 0E
112+  AB85 02 0F 02 10
112+  AB89 02 11 02 12
112+  AB8D 02 13 02 14
112+  AB91 02 15
113+  AB93 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
113+  AB97 19 09 19 0A
113+  AB9B 19 0B 19 0C
113+  AB9F 19 0D 19 0E
113+  ABA3 19 0F 19 10
113+  ABA7 19 11 19 12
113+  ABAB 19 13 19 14
113+  ABAF 19 15
114+  ABB1 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
114+  ABB5 05 0B 06 0B
114+  ABB9 07 0B 08 0B
114+  ABBD 09 0B 0A 0B
114+  ABC1 0B 0B
115+  ABC3 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
115+  ABC7 0B 09 0B 0A
116+  ABCB 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
116+  ABCF 10 10 10 11
116+  ABD3 10 12 10 13
117+  ABD7
# file closed: screen/titlescreen.asm
 27   ABD7                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ABD7              ;
  2+  ABD7              ; Draws the life remaining screen
  3+  ABD7              ;
  4+  ABD7              lifescreen_draw:
  5+  ABD7 CD 1D AC         call lifescreen_init
  6+  ABDA
  7+  ABDA 3A 97 BA         ld a,(game_currentplayer)             ; get the current player
  8+  ABDD C6 30            add 48                                ; add 48 to get char
  9+  ABDF 21 48 83         ld hl,string_lifescreen_player+10
 10+  ABE2 77               ld (hl),a                             ; load this to the string we're about to show
 11+  ABE3
 12+  ABE3 21 3E 83         ld hl,string_lifescreen_player
 13+  ABE6 CD C4 84         call string_print
 14+  ABE9
 15+  ABE9 3A CE BA         ld a,(player+9)                       ; get the current player lives
 16+  ABEC C6 30            add 48                                ; add 48 to get the character
 17+  ABEE FE 31            cp 49
 18+  ABF0 C2 03 AC         jp nz,lifescreen_draw0
 19+  ABF3 21 58 83         ld hl,string_lifescreen_lastman
 20+  ABF6
 21+  ABF6 06 08            ld b,8
 22+  ABF8 3E 0A            ld a,10                                ; set red
 23+  ABFA 11 6C 58         ld de,22528+108                        ; attrs here
 24+  ABFD CD 57 A8         call screen_setcolours
 25+  AC00
 26+  AC00 C3 0A AC         jp lifescreen_draw1
 27+  AC03              lifescreen_draw0:
 28+  AC03 21 4D 83         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  AC06 77               ld (hl),a                             ; load this to the string we're about to show
 30+  AC07 21 4B 83         ld hl,string_lifescreen_lives
 31+  AC0A              lifescreen_draw1:
 32+  AC0A CD C4 84         call string_print
 33+  AC0D
 34+  AC0D 3E 86            ld a,134
 35+  AC0F 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AC12 06 0A            ld b,10
 37+  AC14 CD 57 A8         call screen_setcolours
 38+  AC17
 39+  AC17 3E 64            ld a,100                              ; wait for 200 frames
 40+  AC19 CD 52 80         call utilities_waitforkey_forframes   ; wait for keypress
 41+  AC1C
 42+  AC1C C9               ret
 43+  AC1D
 44+  AC1D              ;
 45+  AC1D              ; Initialises the screen
 46+  AC1D              ;
 47+  AC1D              lifescreen_init:
 48+  AC1D              ; We want a blue screen.
 49+  AC1D                  ;call $0D6B
 50+  AC1D 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 51+  AC1F                                      ; bright (64).
 52+  AC1F CD 67 80         call utilities_clearscreen
 53+  AC22 32 8D 5C         ld (23693),a        ; set our screen colours.
 54+  AC25 3E 01            ld a,1              ; 1 is the code for blue.
 55+  AC27 D3 FE            out (254),a         ; write to port 254.
 56+  AC29                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 57+  AC29
 58+  AC29 C9               ret
# file closed: screen/lifescreen.asm
 28   AC2A                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AC2A              ;
  2+  AC2A              ; Draws the game over screen
  3+  AC2A              ;
  4+  AC2A              gameover_draw:
  5+  AC2A CD E7 C1         call scores_processhighscores
  6+  AC2D
  7+  AC2D              gameover_draw0:
  8+  AC2D CD 6D AC         call gameover_enterhighscores
  9+  AC30
 10+  AC30 CD 0B AD         call gameover_init
 11+  AC33
 12+  AC33 21 63 83         ld hl,string_gameoverscreen_gameover
 13+  AC36 CD C4 84         call string_print
 14+  AC39
 15+  AC39 21 6F 83         ld hl,string_gameoverscreen_copyright
 16+  AC3C CD C4 84         call string_print
 17+  AC3F
 18+  AC3F CD 50 AC         call gameover_commontext
 19+  AC42
 20+  AC42 06 0B            ld b,11
 21+  AC44 3E 42            ld a,66
 22+  AC46 11 2B 58         ld de,22528+43                         ; attrs here
 23+  AC49 CD 57 A8         call screen_setcolours
 24+  AC4C CD 47 80         call utilities_waitforkey   ; wait for keypress
 25+  AC4F
 26+  AC4F C9               ret
 27+  AC50
 28+  AC50              ;
 29+  AC50              ; Draws text shared by the game over and high score screens
 30+  AC50              ;
 31+  AC50              gameover_commontext:
 32+  AC50 CD 29 A8         call screen_setuptext       ; show scores
 33+  AC53 CD B1 C1         call scores_printscores     ; print the current scores
 34+  AC56
 35+  AC56 21 9D 83         ld hl,string_gameover_credits
 36+  AC59 CD C4 84         call string_print
 37+  AC5C
 38+  AC5C 21 89 83         ld hl,string_gameoverscreen_bestscores
 39+  AC5F CD C4 84         call string_print
 40+  AC62
 41+  AC62 06 20            ld b,32
 42+  AC64 3E 45            ld a,69
 43+  AC66 11 C0 5A         ld de,22528+704                         ; attrs here
 44+  AC69 CD 57 A8         call screen_setcolours
 45+  AC6C
 46+  AC6C C9               ret
 47+  AC6D
 48+  AC6D              ;
 49+  AC6D              ; If required, enter highscore
 50+  AC6D              ;
 51+  AC6D              gameover_enterhighscores:
 52+  AC6D                  ; check if we need to enter initial
 53+  AC6D 3A E6 C1         ld a,(scores_highscoretmp)
 54+  AC70 FE 00            cp 0
 55+  AC72 C8               ret z
 56+  AC73 CD A1 AC         call gameover_enterhighscores_init
 57+  AC76 3A E6 C1         ld a,(scores_highscoretmp)
 58+  AC79 3D               dec a
 59+  AC7A 3D               dec a
 60+  AC7B 3D               dec a                                   ; get high score location back to position of name
 61+  AC7C 16 00            ld d,0
 62+  AC7E 5F               ld e,a
 63+  AC7F 21 6D C1         ld hl,scores_table
 64+  AC82 19               add hl,de                               ; load memory into hl
 65+  AC83 08               ex af,af'
 66+  AC84 06 0F            ld b,15
 67+  AC86 CD 82 80         call utilities_pauseforframes           ; pause for a little bit
 68+  AC89 06 03            ld b,3                                  ; collect three chars
 69+  AC8B              gameover_draw2:
 70+  AC8B C5               push bc
 71+  AC8C E5               push hl
 72+  AC8D CD 86 80         call utilities_readkey               ; get key into a
 73+  AC90 E1               pop hl
 74+  AC91 77               ld (hl),a
 75+  AC92 23               inc hl
 76+  AC93 E5               push hl
 77+  AC94 CD D3 C1         call scores_showtable
 78+  AC97 E1               pop hl
 79+  AC98 06 0F            ld b,15
 80+  AC9A CD 82 80         call utilities_pauseforframes
 81+  AC9D C1               pop bc
 82+  AC9E 10 EB            djnz gameover_draw2
 83+  ACA0 C9               ret
 84+  ACA1
 85+  ACA1              ;
 86+  ACA1              ; Displays the screen text for high score entry
 87+  ACA1              ;
 88+  ACA1              gameover_enterhighscores_init:
 89+  ACA1
 90+  ACA1 CD 0B AD         call gameover_init
 91+  ACA4 CD 50 AC         call gameover_commontext
 92+  ACA7
 93+  ACA7 21 A9 83         ld hl,string_highscore_congratulations
 94+  ACAA CD C4 84         call string_print
 95+  ACAD
 96+  ACAD 3A 97 BA         ld a,(game_currentplayer)
 97+  ACB0 FE 01            cp 1
 98+  ACB2 21 BB 83         ld hl,string_highscore_player1
 99+  ACB5 C3 BB AC         jp gameover_enterhighscores_init1
100+  ACB8              gameover_enterhighscores_init0:
101+  ACB8 21 C6 83         ld hl,string_highscore_player2
102+  ACBB              gameover_enterhighscores_init1:
103+  ACBB CD C4 84         call string_print
104+  ACBE 06 60            ld b,96
105+  ACC0 3E 43            ld a,67
106+  ACC2 11 A0 58         ld de,22528+160                         ; attrs here
107+  ACC5 CD 57 A8         call screen_setcolours
108+  ACC8
109+  ACC8 21 D1 83         ld hl,string_highscore_youhaveearned
110+  ACCB CD C4 84         call string_print
111+  ACCE
112+  ACCE 3A E6 C1         ld a,(scores_highscoretmp)
113+  ACD1 FE 05            cp 5
114+  ACD3 CA E1 AC         jp z, gameover_enterhighscores_init2    ; first place
115+  ACD6 FE 11            cp 17
116+  ACD8 CA E7 AC         jp z, gameover_enterhighscores_init3    ; 2nd place
117+  ACDB 21 0D 84         ld hl,string_highscore_place3           ; 3rd place
118+  ACDE C3 ED AC         jp gameover_enterhighscores_init4
119+  ACE1              gameover_enterhighscores_init2
120+  ACE1 21 E3 83         ld hl,string_highscore_place1
121+  ACE4 C3 ED AC         jp gameover_enterhighscores_init4
122+  ACE7              gameover_enterhighscores_init3
123+  ACE7 21 F8 83         ld hl,string_highscore_place2
124+  ACEA C3 ED AC         jp gameover_enterhighscores_init4
125+  ACED              gameover_enterhighscores_init4
126+  ACED CD C4 84         call string_print
127+  ACF0
128+  ACF0 06 60            ld b,96
129+  ACF2 3E 42            ld a,66
130+  ACF4 11 40 59         ld de,22528+320                         ; attrs here
131+  ACF7 CD 57 A8         call screen_setcolours
132+  ACFA
133+  ACFA 21 22 84         ld hl,string_highscore_pleaseenter
134+  ACFD CD C4 84         call string_print
135+  AD00
136+  AD00 06 60            ld b,96
137+  AD02 3E 46            ld a,70
138+  AD04 11 E0 59         ld de,22528+480                         ; attrs here
139+  AD07 CD 57 A8         call screen_setcolours
140+  AD0A C9               ret
141+  AD0B
142+  AD0B              ;
143+  AD0B              ; Initialises the screen
144+  AD0B              ;
145+  AD0B              gameover_init:
146+  AD0B              ; We want a black screen.
147+  AD0B 3E 47            ld a,71             ; white ink (7) on black paper (0),
148+  AD0D                                      ; bright (64).
149+  AD0D CD 67 80         call utilities_clearscreen
150+  AD10 32 8D 5C         ld (23693),a        ; set our screen colours.
151+  AD13 3E 00            ld a,0              ; 2 is the code for red.
152+  AD15 D3 FE            out (254),a         ; write to port 254.
153+  AD17 C9               ret
# file closed: screen/gameover.asm
 29   AD18                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AD18              ;
  2+  AD18              ; Draws the level transition screen
  3+  AD18              ;
  4+  AD18              endlevel_draw:
  5+  AD18 CD 0E AE         call endlevel_init
  6+  AD1B CD F7 AD         call endlevel_commontext
  7+  AD1E
  8+  AD1E 21 A9 83         ld hl,string_highscore_congratulations
  9+  AD21 CD C4 84         call string_print
 10+  AD24
 11+  AD24 3A 97 BA         ld a,(game_currentplayer)
 12+  AD27 FE 01            cp 1
 13+  AD29 21 BB 83         ld hl,string_highscore_player1
 14+  AD2C C3 32 AD         jp endlevel_init1
 15+  AD2F              endlevel_init0:
 16+  AD2F 21 C6 83         ld hl,string_highscore_player2
 17+  AD32              endlevel_init1:
 18+  AD32 CD C4 84         call string_print
 19+  AD35
 20+  AD35 21 3F 84         ld hl,string_endlevel_youhaveearned
 21+  AD38 CD C4 84         call string_print
 22+  AD3B
 23+  AD3B CD 96 AD         call endlevel_workoutbonus
 24+  AD3E D5               push de
 25+  AD3F 08               ex af,af'                               ; store the a value for later
 26+  AD40 CD C4 84         call string_print
 27+  AD43 D1               pop de
 28+  AD44 62 6B            ld hl,de                                ; get the points text into de
 29+  AD46 CD C4 84         call string_print
 30+  AD49
 31+  AD49 21 AA 84         ld hl, string_endlevel_anothergo
 32+  AD4C CD C4 84         call string_print
 33+  AD4F
 34+  AD4F 06 20            ld b,32
 35+  AD51 3E 63            ld a,99
 36+  AD53 11 60 59         ld de,22528+352                         ; attrs here
 37+  AD56 CD 57 A8         call screen_setcolours
 38+  AD59
 39+  AD59 06 20            ld b,32
 40+  AD5B 3E 65            ld a,101
 41+  AD5D 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AD60 CD 57 A8         call screen_setcolours
 43+  AD63
 44+  AD63 06 20            ld b,32
 45+  AD65 3E 63            ld a,99
 46+  AD67 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AD6A CD 57 A8         call screen_setcolours
 48+  AD6D
 49+  AD6D 06 20            ld b,32
 50+  AD6F 3E 62            ld a,98
 51+  AD71 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AD74 CD 57 A8         call screen_setcolours
 53+  AD77
 54+  AD77 08               ex af,af'                               ; get back a value with bonus type
 55+  AD78 06 14            ld b,20
 56+  AD7A CD 82 80         call utilities_pauseforframes
 57+  AD7D
 58+  AD7D 47               ld b,a                      ; put the bonus count in b
 59+  AD7E              endlevel_init2:
 60+  AD7E C5               push bc
 61+  AD7F 06 01            ld b,1
 62+  AD81 CD 91 C1         call scores_addthousands
 63+  AD84 CD 75 BB         call player_recordcurrentscore
 64+  AD87 CD B1 C1         call scores_printscores     ; print the current scores
 65+  AD8A 06 0A            ld b,10
 66+  AD8C CD 82 80         call utilities_pauseforframes
 67+  AD8F C1               pop bc
 68+  AD90 10 EC            djnz endlevel_init2
 69+  AD92
 70+  AD92 CD 47 80         call utilities_waitforkey   ; wait for keypress
 71+  AD95
 72+  AD95 C9               ret
 73+  AD96
 74+  AD96              ;
 75+  AD96              ; Works out the bonus
 76+  AD96              ; Outputs:
 77+  AD96              ; a = 15 (all seven)
 78+  AD96              ; a = 10 (3 large or 4 small)
 79+  AD96              ; a = 5 (1 large diamond)
 80+  AD96              ; hl - pointer to bonus text
 81+  AD96              ; de - pointer to points text
 82+  AD96              ;
 83+  AD96              endlevel_workoutbonus:
 84+  AD96 21 84 B3         ld hl,level01diamonds+2     ; location of state of first diamond
 85+  AD99 06 03            ld b,3                      ; number to check
 86+  AD9B 16 00            ld d,0                      ; zero diamond count
 87+  AD9D              endlevel_workoutbonus0:
 88+  AD9D 7E               ld a,(hl)                   ; get state
 89+  AD9E FE 01            cp 1
 90+  ADA0 C2 A4 AD         jp nz,endlevel_workoutbonus1 ; if not, move on
 91+  ADA3 14               inc d                       ; increment diamond count
 92+  ADA4              endlevel_workoutbonus1:
 93+  ADA4 23               inc hl
 94+  ADA5 23               inc hl
 95+  ADA6 23               inc hl
 96+  ADA7 23               inc hl
 97+  ADA8 23               inc hl                      ; get to next state
 98+  ADA9 10 F2            djnz endlevel_workoutbonus0
 99+  ADAB
100+  ADAB 21 94 B3         ld hl,level01gems+2     ; location of state of first gem
101+  ADAE 06 04            ld b,4                      ; number to check
102+  ADB0 1E 00            ld e,0                      ; zero gem count
103+  ADB2              endlevel_workoutbonus2:
104+  ADB2 7E               ld a,(hl)                   ; get state
105+  ADB3 FE 01            cp 1
106+  ADB5 C2 B9 AD         jp nz,endlevel_workoutbonus3 ; if not, move on
107+  ADB8 1C               inc e                       ; increment diamond count
108+  ADB9              endlevel_workoutbonus3:
109+  ADB9 23               inc hl
110+  ADBA 23               inc hl
111+  ADBB 23               inc hl
112+  ADBC 23               inc hl
113+  ADBD 23               inc hl                     ; get to next state
114+  ADBE 10 F2            djnz endlevel_workoutbonus2
115+  ADC0
116+  ADC0 7A               ld a,d
117+  ADC1 83               add e
118+  ADC2 FE 07            cp 7                        ; check for max bonus
119+  ADC4 C2 D0 AD         jp nz,endlevel_workoutbonus4 ;
120+  ADC7 3E 0F            ld a,15
121+  ADC9 21 6F 84         ld hl, string_endlevel_bonus3
122+  ADCC 11 9B 84         ld de, string_endlevel_points3
123+  ADCF C9               ret                         ; return with bonus of 15
124+  ADD0              endlevel_workoutbonus4:
125+  ADD0 7A               ld a,d                      ; check for for diamonds
126+  ADD1 FE 03            cp 3
127+  ADD3 C2 DF AD         jp nz,endlevel_workoutbonus5
128+  ADD6 3E 0A            ld a,10
129+  ADD8 21 60 84         ld hl, string_endlevel_bonus2
130+  ADDB 11 8C 84         ld de, string_endlevel_points2
131+  ADDE C9               ret                         ; return with bonus of ten
132+  ADDF              endlevel_workoutbonus5:
133+  ADDF 7B               ld a,e                      ; check for four gems
134+  ADE0 FE 04            cp 4
135+  ADE2 C2 EE AD         jp nz,endlevel_workoutbonus6
136+  ADE5 3E 0A            ld a,10
137+  ADE7 21 60 84         ld hl, string_endlevel_bonus2
138+  ADEA 11 8C 84         ld de, string_endlevel_points2
139+  ADED C9               ret                         ; return with bonus of 10
140+  ADEE              endlevel_workoutbonus6:
141+  ADEE 3E 05            ld a,5                      ; otherwise, bonus is 5
142+  ADF0 21 51 84         ld hl, string_endlevel_bonus1
143+  ADF3 11 7E 84         ld de, string_endlevel_points1
144+  ADF6 C9               ret
145+  ADF7
146+  ADF7              ;
147+  ADF7              ; Draws text shared by the game over and high score screens
148+  ADF7              ;
149+  ADF7              endlevel_commontext:
150+  ADF7 CD 29 A8         call screen_setuptext       ; show scores
151+  ADFA CD B1 C1         call scores_printscores     ; print the current scores
152+  ADFD
153+  ADFD 21 89 83         ld hl,string_gameoverscreen_bestscores
154+  AE00 CD C4 84         call string_print
155+  AE03
156+  AE03 06 20            ld b,32
157+  AE05 3E 45            ld a,69
158+  AE07 11 C0 5A         ld de,22528+704                         ; attrs here
159+  AE0A CD 57 A8         call screen_setcolours
160+  AE0D
161+  AE0D C9               ret
162+  AE0E
163+  AE0E              ;
164+  AE0E              ; Initialises the screen
165+  AE0E              ;
166+  AE0E              endlevel_init:
167+  AE0E              ; We want a green screen.
168+  AE0E 3E 61            ld a,97             ; white ink (7) on black paper (0),
169+  AE10                                      ; bright (64).
170+  AE10 CD 67 80         call utilities_clearscreen
171+  AE13 32 8D 5C         ld (23693),a        ; set our screen colours.
172+  AE16 3E 00            ld a,0              ; 2 is the code for red.
173+  AE18 D3 FE            out (254),a         ; write to port 254.
174+  AE1A C9               ret
# file closed: screen/endlevel.asm
 30   AE1B
 31   AE1B                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  AE1B              sound_gemcollected:
  2+  AE1B 21 C8 00         ld hl,200 ; pitch.
  3+  AE1E 11 3E 00         ld de,62 ; duration.
  4+  AE21 CD B5 03         call 949 ; ROM beeper routine.
  5+  AE24 C9               ret
  6+  AE25
  7+  AE25              sound_pitchbend:
  8+  AE25 21 F4 01         ld hl,500 ; starting pitch.
  9+  AE28 06 FA            ld b,250 ; length of pitch bend.
 10+  AE2A              sound_pitchbend0:
 11+  AE2A C5                push bc
 12+  AE2B E5               push hl ; store pitch.
 13+  AE2C 11 01 00         ld de,1 ; very short duration.
 14+  AE2F CD B5 03         call 949 ; ROM beeper routine.
 15+  AE32 E1               pop hl ; restore pitch.
 16+  AE33 23               inc hl ; pitch going up.
 17+  AE34 C1               pop bc
 18+  AE35 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  AE37 C9               ret
 20+  AE38
 21+  AE38              sound_rockfell:
 22+  AE38 08               ex af,af'
 23+  AE39 1E 32            ld e,50 ; repeat 250 times.
 24+  AE3B 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  AE3E D5           sound_rockfell2 push de
 26+  AE3F 06 20            ld b,32 ; length of step.
 27+  AE41 C5           sound_rockfell0 push bc
 28+  AE42 7E               ld a,(hl) ; next "random" number.
 29+  AE43 23               inc hl ; pointer.
 30+  AE44 E6 F8            and 248 ; we want a black border.
 31+  AE46 D3 FE            out (254),a ; write to speaker.
 32+  AE48 7B               ld a,e ; as e gets smaller...
 33+  AE49 2F               cpl ; ...we increase the delay.
 34+  AE4A 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  AE4B 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  AE4D C1               pop bc
 37+  AE4E 10 F1            djnz sound_rockfell0 ; next step.
 38+  AE50 D1               pop de
 39+  AE51 7B               ld a,e
 40+  AE52 D6 18            sub 24 ; size of step.
 41+  AE54 FE 1E            cp 30 ; end of range.
 42+  AE56 CA 67 AE         jp z,sound_rockfell5
 43+  AE59 DA 67 AE         jp c, sound_rockfell5
 44+  AE5C 5F               ld e,a
 45+  AE5D 2F               cpl
 46+  AE5E 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  AE60 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  AE62 3D               dec a
 49+  AE63 20 F9            jr nz,sound_rockfell3
 50+  AE65 18 D7            jr sound_rockfell2
 51+  AE67              sound_rockfell5
 52+  AE67 08               ex af,af'
 53+  AE68 C9               ret
 54+  AE69
# file closed: sound/sound.asm
 32   AE69
 33   AE69                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  AE69              ; ###############################################################
  2+  AE69              ; Data for level 1
  3+  AE69              ; ###############################################################
  4+  AE69              level01:
  5+  AE69
  6+  AE69                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  AE69
  8+  AE69 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  AE6D 05 05 05 05
  8+  AE71 05 05 05 05
  8+  AE75 05 05 02 01
  8+  AE79 01 01 03 05
  8+  AE7D 05 05 05 05
  8+  AE81 05 05 05 05
  8+  AE85 05 05 00 00
  9+  AE89 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  AE8D 05 05 05 05
  9+  AE91 05 05 05 05
  9+  AE95 02 01 01 01
  9+  AE99 01 01 01 01
  9+  AE9D 03 05 05 05
  9+  AEA1 05 05 05 05
  9+  AEA5 05 05 00 00
 10+  AEA9 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  AEAD 05 05 05 05
 10+  AEB1 05 05 02 01
 10+  AEB5 01 01 01 01
 10+  AEB9 01 01 01 01
 10+  AEBD 01 01 03 05
 10+  AEC1 0D 0D 0D 0D
 10+  AEC5 0D 0D 00 00
 11+  AEC9 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  AECD 01 01 00 01
 11+  AED1 01 01 01 01
 11+  AED5 01 01 01 01
 11+  AED9 01 01 01 01
 11+  AEDD 01 01 01 03
 11+  AEE1 05 05 05 05
 11+  AEE5 05 05 00 00
 12+  AEE9 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  AEED 04 04 04 04
 12+  AEF1 04 04 01 01
 12+  AEF5 01 01 01 01
 12+  AEF9 01 01 01 01
 12+  AEFD 01 01 01 01
 12+  AF01 01 01 01 01
 12+  AF05 00 01 00 00
 13+  AF09 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  AF0D 04 04 04 04
 13+  AF11 04 04 04 04
 13+  AF15 01 01 01 01
 13+  AF19 01 01 01 01
 13+  AF1D 01 01 01 01
 13+  AF21 00 00 00 00
 13+  AF25 00 01 00 00
 14+  AF29 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  AF2D 04 01 01 01
 14+  AF31 01 01 04 04
 14+  AF35 04 04 01 01
 14+  AF39 01 01 01 01
 14+  AF3D 01 00 00 00
 14+  AF41 00 01 01 01
 14+  AF45 01 01 00 00
 15+  AF49 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  AF4D 04 04 04 04
 15+  AF51 04 01 04 04
 15+  AF55 04 04 04 04
 15+  AF59 04 04 00 00
 15+  AF5D 00 00 04 04
 15+  AF61 04 04 04 04
 15+  AF65 04 01 00 00
 16+  AF69 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  AF6D 01 04 01 01
 16+  AF71 01 01 04 04
 16+  AF75 04 04 04 04
 16+  AF79 04 04 00 04
 16+  AF7D 04 04 04 04
 16+  AF81 04 04 04 04
 16+  AF85 04 01 00 00
 17+  AF89 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  AF8D 00 00 00 00
 17+  AF91 00 04 04 04
 17+  AF95 04 04 04 04
 17+  AF99 04 04 00 04
 17+  AF9D 04 04 04 04
 17+  AFA1 04 04 04 04
 17+  AFA5 04 01 00 00
 18+  AFA9 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  AFAD 15 15 15 15
 18+  AFB1 15 01 04 04
 18+  AFB5 04 04 04 04
 18+  AFB9 04 04 00 04
 18+  AFBD 04 04 04 04
 18+  AFC1 04 04 04 04
 18+  AFC5 04 01 00 00
 19+  AFC9 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  AFCD 00 00 00 00
 19+  AFD1 00 01 04 04
 19+  AFD5 04 04 04 04
 19+  AFD9 04 04 00 04
 19+  AFDD 04 04 04 04
 19+  AFE1 04 00 00 00
 19+  AFE5 00 01 00 00
 20+  AFE9 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  AFED 00 00 00 00
 20+  AFF1 00 01 04 04
 20+  AFF5 04 04 04 04
 20+  AFF9 04 04 00 04
 20+  AFFD 04 04 04 04
 20+  B001 04 00 04 04
 20+  B005 00 01 00 00
 21+  B009 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B00D 06 06 06 06
 21+  B011 06 01 04 04
 21+  B015 04 04 04 04
 21+  B019 04 04 00 04
 21+  B01D 04 04 04 04
 21+  B021 04 00 04 04
 21+  B025 00 01 00 00
 22+  B029 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B02D 1A 1A 1A 1A
 22+  B031 1A 01 04 00
 22+  B035 00 00 00 00
 22+  B039 00 00 00 00
 22+  B03D 00 00 00 00
 22+  B041 00 00 04 04
 22+  B045 00 01 00 00
 23+  B049 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B04D 1A 1A 1A 1A
 23+  B051 1A 01 04 00
 23+  B055 04 04 04 04
 23+  B059 04 04 00 04
 23+  B05D 04 04 00 04
 23+  B061 04 04 04 04
 23+  B065 00 01 00 00
 24+  B069 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B06D 1A 1A 1A 1A
 24+  B071 1A 01 04 00
 24+  B075 04 04 04 04
 24+  B079 04 04 00 04
 24+  B07D 04 04 00 04
 24+  B081 04 04 04 04
 24+  B085 00 01 00 00
 25+  B089 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B08D 01 01 01 01
 25+  B091 01 01 04 00
 25+  B095 04 04 04 04
 25+  B099 04 04 00 04
 25+  B09D 04 04 00 04
 25+  B0A1 04 04 04 04
 25+  B0A5 00 01 00 00
 26+  B0A9 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B0AD 04 04 04 04
 26+  B0B1 04 04 04 00
 26+  B0B5 04 04 04 04
 26+  B0B9 04 04 00 04
 26+  B0BD 04 04 00 00
 26+  B0C1 00 00 04 04
 26+  B0C5 04 01 00 00
 27+  B0C9 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B0CD 04 04 00 00
 27+  B0D1 00 00 00 00
 27+  B0D5 04 04 04 04
 27+  B0D9 04 04 00 04
 27+  B0DD 04 04 04 04
 27+  B0E1 04 00 04 04
 27+  B0E5 04 01 00 00
 28+  B0E9 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B0ED 04 04 00 04
 28+  B0F1 04 04 04 04
 28+  B0F5 04 04 04 04
 28+  B0F9 04 04 00 04
 28+  B0FD 04 04 04 04
 28+  B101 04 00 04 04
 28+  B105 04 01 00 00
 29+  B109 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B10D 04 04 00 04
 29+  B111 04 04 01 01
 29+  B115 01 01 01 01
 29+  B119 01 01 01 01
 29+  B11D 01 01 01 01
 29+  B121 04 00 04 04
 29+  B125 04 01 00 00
 30+  B129 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B12D 04 04 00 04
 30+  B131 04 04 01 00
 30+  B135 00 00 00 00
 30+  B139 00 00 00 00
 30+  B13D 00 00 00 01
 30+  B141 04 00 04 04
 30+  B145 04 01 00 00
 31+  B149 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B14D 04 04 00 04
 31+  B151 04 04 01 00
 31+  B155 00 00 00 00
 31+  B159 00 00 00 00
 31+  B15D 00 00 00 01
 31+  B161 04 00 04 04
 31+  B165 04 01 00 00
 32+  B169 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B16D 04 04 00 04
 32+  B171 04 04 01 00
 32+  B175 00 00 00 00
 32+  B179 00 00 00 00
 32+  B17D 00 00 00 01
 32+  B181 04 00 04 04
 32+  B185 04 01 00 00
 33+  B189 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B18D 04 04 00 04
 33+  B191 04 04 04 00
 33+  B195 00 00 00 00
 33+  B199 00 00 00 00
 33+  B19D 00 00 00 04
 33+  B1A1 04 04 04 04
 33+  B1A5 04 01 00 00
 34+  B1A9 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B1AD 04 04 04 04
 34+  B1B1 04 04 01 00
 34+  B1B5 00 00 00 00
 34+  B1B9 00 00 00 00
 34+  B1BD 00 00 00 01
 34+  B1C1 04 04 04 04
 34+  B1C5 04 01 00 00
 35+  B1C9 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B1CD 04 04 04 04
 35+  B1D1 04 04 01 00
 35+  B1D5 00 00 01 00
 35+  B1D9 00 00 00 01
 35+  B1DD 00 00 00 01
 35+  B1E1 04 04 04 04
 35+  B1E5 04 01 00 00
 36+  B1E9 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B1ED 01 01 01 01
 36+  B1F1 01 01 01 01
 36+  B1F5 01 01 01 01
 36+  B1F9 01 01 01 01
 36+  B1FD 01 01 01 01
 36+  B201 01 01 01 01
 36+  B205 01 01 00 00
 37+  B209
 38+  B209              ; ###############################################################
 39+  B209              ; Object data: horiz, vert, state, memh, meml
 40+  B209              ; ###############################################################
 41+  B209              level01rocks:
 42+  B209 09 04 00 00      defb 9,4,0,0,0
 42+  B20D 00
 43+  B20E 0C 07 00 00      defb 12,7,0,0,0
 43+  B212 00
 44+  B213 10 07 00 00      defb 16,7,0,0,0
 44+  B217 00
 45+  B218 0B 08 00 00      defb 11,8,0,0,0
 45+  B21C 00
 46+  B21D 0A 0A 00 00      defb 10,10,0,0,0
 46+  B221 00
 47+  B222 0C 0A 00 00      defb 12,10,0,0,0
 47+  B226 00
 48+  B227 0D 09 00 00      defb 13,9,0,0,0
 48+  B22B 00
 49+  B22C 0E 08 00 00      defb 14,8,0,0,0
 49+  B230 00
 50+  B231 0F 0B 00 00      defb 15,11,0,0,0
 50+  B235 00
 51+  B236 0B 0C 00 00      defb 11,12,0,0,0
 51+  B23A 00
 52+  B23B 11 0C 00 00      defb 17,12,0,0,0
 52+  B23F 00
 53+  B240 13 08 00 00      defb 19,8,0,0,0
 53+  B244 00
 54+  B245 16 09 00 00      defb 22,9,0,0,0
 54+  B249 00
 55+  B24A 13 0A 00 00      defb 19,10,0,0,0
 55+  B24E 00
 56+  B24F 15 0A 00 00      defb 21,10,0,0,0
 56+  B253 00
 57+  B254 15 0C 00 00      defb 21,12,0,0,0
 57+  B258 00
 58+  B259 16 0C 00 00      defb 22,12,0,0,0
 58+  B25D 00
 59+  B25E 18 0A 00 00      defb 24,10,0,0,0
 59+  B262 00
 60+  B263 19 09 00 00      defb 25,9,0,0,0
 60+  B267 00
 61+  B268 1C 09 00 00      defb 28,9,0,0,0
 61+  B26C 00
 62+  B26D 1B 0C 00 00      defb 27,12,0,0,0
 62+  B271 00
 63+  B272 1A 0D 00 00      defb 26,13,0,0,0
 63+  B276 00
 64+  B277 19 0E 00 00      defb 25,14,0,0,0
 64+  B27B 00
 65+  B27C 19 10 00 00      defb 25,16,0,0,0
 65+  B280 00
 66+  B281 1A 11 00 00      defb 26,17,0,0,0
 66+  B285 00
 67+  B286 1B 11 00 00      defb 27,17,0,0,0
 67+  B28A 00
 68+  B28B 1C 12 00 00      defb 28,18,0,0,0
 68+  B28F 00
 69+  B290 1A 13 00 00      defb 26,19,0,0,0
 69+  B294 00
 70+  B295 1B 15 00 00      defb 27,21,0,0,0
 70+  B299 00
 71+  B29A 1A 17 00 00      defb 26,23,0,0,0
 71+  B29E 00
 72+  B29F 1B 18 00 00      defb 27,24,0,0,0
 72+  B2A3 00
 73+  B2A4 19 18 00 00      defb 25,24,0,0,0
 73+  B2A8 00
 74+  B2A9 18 17 00 00      defb 24,23,0,0,0
 74+  B2AD 00
 75+  B2AE 13 14 00 00      defb 19,20,0,0,0
 75+  B2B2 00
 76+  B2B3 14 12 00 00      defb 20,18,0,0,0
 76+  B2B7 00
 77+  B2B8 14 10 00 00      defb 20,16,0,0,0
 77+  B2BC 00
 78+  B2BD 15 10 00 00      defb 21,16,0,0,0
 78+  B2C1 00
 79+  B2C2 16 12 00 00      defb 22,18,0,0,0
 79+  B2C6 00
 80+  B2C7 11 14 00 00      defb 17,20,0,0,0
 80+  B2CB 00
 81+  B2CC 0D 11 00 00      defb 13,17,0,0,0
 81+  B2D0 00
 82+  B2D1 0C 13 00 00      defb 12,19,0,0,0
 82+  B2D5 00
 83+  B2D6 0B 13 00 00      defb 11,19,0,0,0
 83+  B2DA 00
 84+  B2DB 0A 11 00 00      defb 10,17,0,0,0
 84+  B2DF 00
 85+  B2E0 05 12 00 00      defb 5,18,0,0,0
 85+  B2E4 00
 86+  B2E5 07 16 00 00      defb 7,22,0,0,0
 86+  B2E9 00
 87+  B2EA 09 17 00 00      defb 9,23,0,0,0
 87+  B2EE 00
 88+  B2EF 07 18 00 00      defb 7,24,0,0,0
 88+  B2F3 00
 89+  B2F4 05 18 00 00      defb 5,24,0,0,0
 89+  B2F8 00
 90+  B2F9 06 19 00 00      defb 6,25,0,0,0
 90+  B2FD 00
 91+  B2FE 08 19 00 00      defb 8,25,0,0,0
 91+  B302 00
 92+  B303 04 17 00 00      defb 4,23,0,0,0
 92+  B307 00
 93+  B308 FF               defb 255
 94+  B309
 95+  B309              level01missiles:
 96+  B309 0B 17 00 00      defb 11,23,0,0,0
 96+  B30D 00
 97+  B30E 0B 16 00 00      defb 11,22,0,0,0
 97+  B312 00
 98+  B313 0C 17 00 00      defb 12,23,0,0,0
 98+  B317 00
 99+  B318 0C 16 00 00      defb 12,22,0,0,0
 99+  B31C 00
100+  B31D 0D 17 00 00      defb 13,23,0,0,0
100+  B321 00
101+  B322 0D 16 00 00      defb 13,22,0,0,0
101+  B326 00
102+  B327 0E 17 00 00      defb 14,23,0,0,0
102+  B32B 00
103+  B32C 0E 16 00 00      defb 14,22,0,0,0
103+  B330 00
104+  B331 0F 17 00 00      defb 15,23,0,0,0
104+  B335 00
105+  B336 0F 16 00 00      defb 15,22,0,0,0
105+  B33A 00
106+  B33B 10 17 00 00      defb 16,23,0,0,0
106+  B33F 00
107+  B340 10 16 00 00      defb 16,22,0,0,0
107+  B344 00
108+  B345 11 17 00 00      defb 17,23,0,0,0
108+  B349 00
109+  B34A 11 16 00 00      defb 17,22,0,0,0
109+  B34E 00
110+  B34F 12 17 00 00      defb 18,23,0,0,0
110+  B353 00
111+  B354 12 16 00 00      defb 18,22,0,0,0
111+  B358 00
112+  B359 13 17 00 00      defb 19,23,0,0,0
112+  B35D 00
113+  B35E 13 16 00 00      defb 19,22,0,0,0
113+  B362 00
114+  B363 14 17 00 00      defb 20,23,0,0,0
114+  B367 00
115+  B368 14 16 00 00      defb 20,22,0,0,0
115+  B36C 00
116+  B36D 15 17 00 00      defb 21,23,0,0,0
116+  B371 00
117+  B372 15 16 00 00      defb 21,22,0,0,0
117+  B376 00
118+  B377 16 17 00 00      defb 22,23,0,0,0
118+  B37B 00
119+  B37C 16 16 00 00      defb 22,22,0,0,0
119+  B380 00
120+  B381 FF               defb 255
121+  B382
122+  B382              ;
123+  B382              ; Diamonds: x,y,state,mem1+mem2
124+  B382              ;
125+  B382              level01diamonds:
126+  B382 0C 1B 00 00      defb 12,27,0,0,0
126+  B386 00
127+  B387 10 1B 00 00      defb 16,27,0,0,0
127+  B38B 00
128+  B38C 15 1B 00 00      defb 21,27,0,0,0
128+  B390 00
129+  B391 FF               defb 255
130+  B392
131+  B392              level01gems:
132+  B392 12 14 00 00      defb 18,20,0,0,0
132+  B396 00
133+  B397 06 18 00 00      defb 6,24,0,0,0
133+  B39B 00
134+  B39C 19 17 00 00      defb 25,23,0,0,0
134+  B3A0 00
135+  B3A1 1C 11 00 00      defb 28,17,0,0,0
135+  B3A5 00
136+  B3A6 FF               defb 255
137+  B3A7              ;
138+  B3A7              ; Score area colours
139+  B3A7              ;
140+  B3A7              score_colours:
141+  B3A7 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  B3AB 47 47 47 47
141+  B3AF 47 47 47 42
141+  B3B3 43 43 43 43
141+  B3B7 43 43 43 43
141+  B3BB 42 47 47 47
141+  B3BF 47 47 47 47
141+  B3C3 47 47 47 47
142+  B3C7 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  B3CB 47 47 47 47
142+  B3CF 47 47 47 46
142+  B3D3 46 46 46 46
142+  B3D7 46 46 46 46
142+  B3DB 46 47 47 47
142+  B3DF 47 47 47 47
142+  B3E3 47 47 47 47
143+  B3E7
144+  B3E7              high_score_colours:
145+  B3E7 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  B3EB 42 42 47 47
145+  B3EF 47 47 47 47
145+  B3F3 43 43 43 47
145+  B3F7 47 47 47 47
145+  B3FB 47 46 46 46
145+  B3FF 47 47 47 47
145+  B403 47 47 00 00
# file closed: leveldata/level01.asm
 34   B407                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B407              ; Tiles graphics.
  2+  B407              sprites:
  3+  B407 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B40B 00 00 00 00
  4+  B40F FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B413 FF FF FF FF
  5+  B417 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B41B 1F 3F 7F FF
  6+  B41F 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B423 F8 FC FE FF
  7+  B427 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B42B 55 AA 55 AA
  8+  B42F 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B433 00 00 00 00
  9+  B437 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  B43B FF FF FF FF
 10+  B43F 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  B443 00 00 00 00
 11+  B447 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B44B F1 72 34 18
 12+  B44F 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B453 FE FE FF 7E
 13+  B457 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B45B FE FF 7E 3C
 14+  B45F 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B463 00 00 FF FF
 15+  B467 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  B46B FF 42 24 18
 16+  B46F 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B473 00 00 00 00
 17+  B477 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B47B 00 3C 5A 34
 18+  B47F FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  B483 FD FE FD FE
 19+  B487 F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  B48B F4 F8 F4 F8
 20+  B48F D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  B493 D0 E0 D0 E0
 21+  B497 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  B49B 40 80 40 80
 22+  B49F 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  B4A3 ED 00 00 00
 23+  B4A7 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  B4AB FF 7E 3C 18
 24+  B4AF FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  B4B3 00 00 00 00
 25+  B4B7 FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  B4BB 00 00 00 00
 26+  B4BF F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  B4C3 00 00 00 00
 27+  B4C7 C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  B4CB 00 00 00 00
 28+  B4CF 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  B4D3 00 00 00 00
 29+  B4D7 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  B4DB FF FF FF FF
 30+  B4DF
 31+  B4DF
 32+  B4DF              sprite_attrs:
 33+  B4DF 46               defb    070 ; 0, space
 34+  B4E0 4D               defb    077 ; 1, cyan block
 35+  B4E1 4D               defb    077 ; 2, slope left
 36+  B4E2 4D               defb    077 ; 3, slope right
 37+  B4E3 46               defb    070 ; 4, dirt
 38+  B4E4 4E               defb    078 ; 5, sky
 39+  B4E5 4C               defb    076 ; 6, slime
 40+  B4E6 42               defb    066 ; 7, trapdoor
 41+  B4E7 46               defb    070 ; 8, diamond
 42+  B4E8 42               defb    066 ; 9, rock
 43+  B4E9 42               defb    066 ; 10, rock 2
 44+  B4EA 49           	defb    073 ; 11, sky, trapdoor
 45+  B4EB 43           	defb    067 ; 12, missile
 46+  B4EC 4A               defb    074 ; 13, sky, red ink (tank)
 47+  B4ED 46               defb    070 ; 14, gem
 48+  B4EE 4D               defb    077 ; 15, damaged mountain
 49+  B4EF 4D               defb    077 ; 16, damaged mountain 2
 50+  B4F0 4D               defb    077 ; 17, damaged mountain 3
 51+  B4F1 4D               defb    077 ; 18, damaged mountain 4
 52+  B4F2 00           	defb 	000 ; 19, tank missile (not used
 53+  B4F3 43           	defb    067 ; 20, missile active
 54+  B4F4 42           	defb	066	; 21, the pit 1
 55+  B4F5 42           	defb	066	; 22, the pit 2
 56+  B4F6 42           	defb	066	; 23, the pit 3
 57+  B4F7 42           	defb	066	; 24, the pit 4
 58+  B4F8 42           	defb	066	; 25, the pit 5
 59+  B4F9 64           	defb    100 ; 26, slime, green on green
 60+  B4FA
 61+  B4FA
 62+  B4FA              player_sprite:
 63+  B4FA 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 63+  B4FE 38 3D C3 80
 64+  B502 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 64+  B506 3C 1C 16 32
 65+  B50A 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 65+  B50E 3C 38 68 4C
 66+  B512 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 66+  B516 1C BC C3 01
 67+  B51A 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 67+  B51E 3C 3C 64 0C
 68+  B522 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 68+  B526 3C 3C 26 30
 69+  B52A 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 69+  B52E 1E 5C FD 5F
 70+  B532 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 70+  B536 4F 8F 19 03
 71+  B53A 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 71+  B53E F2 F1 98 C0
 72+  B542 FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 72+  B546 48 08 14 2A
 73+  B54A 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 73+  B54E 38 78 44 C3
 74+  B552 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 74+  B556 1C 1E 22 C3
 75+  B55A
 76+  B55A              ;
 77+  B55A              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 78+  B55A              ;
 79+  B55A              ship_sprite:
 80+  B55A 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 80+  B55E 03 1F 7F FF
 81+  B562 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 81+  B566 FF FF FF FF
 82+  B56A F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 82+  B56E FF FF FF FF
 83+  B572 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 83+  B576 C0 F8 FE FF
 84+  B57A B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 84+  B57E 03 03 02 07
 85+  B582 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 85+  B586 FF 0F 07 83
 86+  B58A 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 86+  B58E FF 10 20 C1
 87+  B592 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 87+  B596 C0 C0 40 E0
 88+  B59A 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 88+  B59E 03 03 02 07
 89+  B5A2 F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 89+  B5A6 FF 08 04 83
 90+  B5AA F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 90+  B5AE FF F0 E0 C1
 91+  B5B2 CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 91+  B5B6 C0 C0 40 E0
 92+  B5BA
 93+  B5BA              ;
 94+  B5BA              ;  First 8 frames are tank, last frame is the gun barrel
 95+  B5BA              ;
 96+  B5BA              tank_sprite:
 97+  B5BA 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
 97+  B5BE 7F 00 00 00
 98+  B5C2 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
 98+  B5C6 FE FF 7F 40
 99+  B5CA FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
 99+  B5CE 03 FF FF 01
100+  B5D2 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
100+  B5D6 E0 C0 00 00
101+  B5DA 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
101+  B5DE F7 E1 7F 3F
102+  B5E2 FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
102+  B5E6 54 16 FF FF
103+  B5EA FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
103+  B5EE 9B A8 FF FF
104+  B5F2 FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
104+  B5F6 9F AF FE FC
105+  B5FA 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
105+  B5FE 1F 00 00 00
106+  B602
107+  B602              monster_sprite:
108+  B602 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
108+  B606 0B D0 16 68
109+  B60A 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
109+  B60E 35 AC 7F FE
110+  B612 FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
110+  B616 8F F1 8F F1
111+  B61A 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
111+  B61E 18 18 00 00
112+  B622 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  B626 0B D0 16 68
113+  B62A 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
113+  B62E F5 AF FF FF
114+  B632 BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
114+  B636 0F F0 0F F0
115+  B63A 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
115+  B63E 00 00 00 00
# file closed: graphics/graphics.asm
 35   B642
 36   B642                  include "game\control.asm"
# file opened: game/control.asm
  1+  B642              ;
  2+  B642              ; Check the keyboard then move
  3+  B642              ;
  4+  B642              control_keyboard:
  5+  B642 3A D0 BA         ld a,(player+11)    ; first, check if player is dying
  6+  B645 FE 00            cp 0
  7+  B647 C0               ret nz               ; if so, can't move
  8+  B648 3A CA BA         ld a,(player+5)      ; next, check if the player has pixels left to move
  9+  B64B FE 00            cp 0
 10+  B64D CA 54 B6         jp z, control_keyboard5
 11+  B650 CD 59 B7         call control_automove
 12+  B653 C9               ret
 13+  B654              control_keyboard5:
 14+  B654 3A CB BA         ld a,(player+6)      ; next, check if the player is digging
 15+  B657 FE 00            cp 0
 16+  B659 CA 60 B6         jp z, control_keyboard0
 17+  B65C CD 97 B6         call control_dig
 18+  B65F C9               ret
 19+  B660              control_keyboard0:
 20+  B660 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 21+  B663 ED 78            in a,(c)            ; read keyboard.
 22+  B665 47               ld b,a              ; store result in b register.
 23+  B666 CB 18            rr b                ; check outermost key (q).
 24+  B668 D2 87 B6         jp nc,control_keyboard1
 25+  B66B 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 26+  B66E ED 78            in a,(c)            ; read keyboard.
 27+  B670 47               ld b,a              ; store result in b register.
 28+  B671 CB 18            rr b                ; check outermost key (a).
 29+  B673 D2 8B B6         jp nc,control_keyboard2
 30+  B676 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 31+  B679 ED 78            in a,(c)            ; read keyboard.
 32+  B67B 47               ld b,a              ; store result in b register.
 33+  B67C CB 18            rr b                ; check outermost key (p).
 34+  B67E D2 8F B6         jp nc,control_keyboard3
 35+  B681 CB 18            rr b                ; check next key.
 36+  B683 D2 93 B6         jp nc,control_keyboard4
 37+  B686 C9               ret
 38+  B687              control_keyboard1:
 39+  B687 CD A2 B7         call control_pl_moveup         ; player up.
 40+  B68A C9               ret
 41+  B68B              control_keyboard2:
 42+  B68B CD D1 B7         call control_pl_movedown       ; player down.
 43+  B68E C9               ret
 44+  B68F              control_keyboard3:
 45+  B68F CD 2E B8         call control_pl_moveright       ; player left.
 46+  B692 C9               ret
 47+  B693              control_keyboard4:
 48+  B693 CD FE B7         call control_pl_moveleft       ; player right.
 49+  B696 C9               ret
 50+  B697
 51+  B697              ;
 52+  B697              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
 53+  B697              ;
 54+  B697              control_dig:
 55+  B697 ED 4B C5 BA      ld bc,(player)      ; load the current coords into bc
 56+  B69B C5               push bc
 57+  B69C 3A C7 BA         ld a,(player+2)     ; get the direction
 58+  B69F FE 01            cp 1                ; left
 59+  B6A1 CA B9 B6         jp z,control_dig0
 60+  B6A4 FE 02            cp 2                ; right
 61+  B6A6 CA CE B6         jp z,control_dig1
 62+  B6A9 FE 03            cp 3                ; down
 63+  B6AB CA F2 B6         jp z,control_dig5
 64+  B6AE FE 00            cp 0                ; up
 65+  B6B0 CA E2 B6         jp z,control_dig4
 66+  B6B3 21 CB BA         ld hl,player+6
 67+  B6B6 36 00            ld (hl),0           ; turn off digging
 68+  B6B8 C9               ret                 ; return
 69+  B6B9              control_dig0:           ; going left
 70+  B6B9 CD 49 AA         call sprites_scadd  ; get the current coord
 71+  B6BC 62 6B            ld hl,de
 72+  B6BE 2B               dec hl              ; move one left
 73+  B6BF C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
 74+  B6C0 78               ld a,b
 75+  B6C1 06 08            ld b,8
 76+  B6C3 90               sub b
 77+  B6C4 47               ld b,a
 78+  B6C5 79               ld a,c
 79+  B6C6 0E 08            ld c,8
 80+  B6C8 91               sub c
 81+  B6C9 4F               ld c,a
 82+  B6CA C5               push bc
 83+  B6CB C3 FB B6         jp control_dig2
 84+  B6CE              control_dig1:
 85+  B6CE CD 49 AA         call sprites_scadd  ; get the current coord
 86+  B6D1 62 6B            ld hl,de
 87+  B6D3 23               inc hl              ; move one right
 88+  B6D4 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
 89+  B6D5 3E 08            ld a,8
 90+  B6D7 80               add a,b
 91+  B6D8 47               ld b,a
 92+  B6D9 79               ld a,c
 93+  B6DA 0E 08            ld c,8
 94+  B6DC 91               sub c
 95+  B6DD 4F               ld c,a
 96+  B6DE C5               push bc
 97+  B6DF C3 FB B6         jp control_dig2
 98+  B6E2              control_dig4:
 99+  B6E2 CD 49 AA         call sprites_scadd  ; get the current coord
100+  B6E5 62 6B            ld hl,de
101+  B6E7 11 20 00         ld de,32
102+  B6EA ED 52            sbc hl,de             ; move one up
103+  B6EC C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
104+  B6ED 0D               dec c
105+  B6EE C5               push bc
106+  B6EF C3 13 B7         jp control_dig6
107+  B6F2              control_dig5:
108+  B6F2 CD 49 AA         call sprites_scadd  ; get the current coord
109+  B6F5 62 6B            ld hl,de
110+  B6F7 24               inc h              ; move one down
111+  B6F8                                     ; not bothered about working out bc here, since rock will never fall if digging down
112+  B6F8 C3 FB B6         jp control_dig2
113+  B6FB              ; Normal (not up) digging
114+  B6FB              control_dig2:
115+  B6FB 3A CD BA         ld a,(player+8)     ; get the number of rows we need to overwrite
116+  B6FE 47               ld b,a              ; rows to copy over
117+  B6FF E5               push hl             ; store the memory location of the first row for later
118+  B700              control_dig3:
119+  B700 CD 42 B7         call control_getpixelrow
120+  B703 77               ld (hl),a           ; load contents into row
121+  B704 11 20 00         ld de,32
122+  B707 19               add hl,de           ; move to next row
123+  B708 10 F6            djnz control_dig3
124+  B70A E1               pop hl              ; get the original memory location back
125+  B70B 11 20 00         ld de,32
126+  B70E ED 52            sbc hl,de           ; move to above row, ready for checking for rock
127+  B710 C3 29 B7         jp control_dig10
128+  B713              ; Special case for going up
129+  B713              control_dig6:
130+  B713 3A CD BA         ld a,(player+8)     ; get the number of rows we need to overwrite
131+  B716 47               ld b,a              ; rows to copy over
132+  B717              control_dig7:
133+  B717 CD 42 B7         call control_getpixelrow
134+  B71A              control_dig12:
135+  B71A 77               ld (hl),a           ; load empty into row
136+  B71B 11 20 00         ld de,32
137+  B71E ED 52            sbc hl,de           ; move up to next row
138+  B720 0D               dec c               ; decrease c to track rows
139+  B721 10 F4            djnz control_dig7
140+  B723 79               ld a,c
141+  B724 D6 07            sub 7
142+  B726 C1               pop bc
143+  B727 4F               ld c,a
144+  B728 C5               push bc             ; store the decreased c coord
145+  B729              control_dig10:
146+  B729 DD 21 CC BA      ld ix,player+7
147+  B72D DD 7E 00         ld a,(ix)     ; get the dig frame number
148+  B730 3D               dec a
149+  B731 DD 77 00         ld (ix),a
150+  B734                  ; call the check for rocks above the removed dirt
151+  B734 DD 21 CB BA      ld ix,player+6
152+  B738 DD 7E 00         ld a,(ix)     ; get the dig state
153+  B73B FE 00            cp 0
154+  B73D C1               pop bc
155+  B73E CC EC BF         call z, rocks_checkforfalling ; make the check if we're no longer digging
156+  B741 C9               ret
157+  B742
158+  B742              ;
159+  B742              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
160+  B742              ; Inputs:
161+  B742              ; hl - memory of pixel row
162+  B742              ; Outputs:
163+  B742              ; a - modified row to write
164+  B742              ;
165+  B742              control_getpixelrow:
166+  B742 3A CC BA         ld a,(player+7)     ; get the dig frame number
167+  B745 FE 00            cp 0                ; is this the last dig
168+  B747 CA 4E B7         jp z,control_getpixelrow1
169+  B74A 7E               ld a,(hl)           ; if not, xor with 255 to flip it
170+  B74B EE FF            xor 255
171+  B74D C9               ret
172+  B74E              control_getpixelrow1:
173+  B74E DD 21 CB BA      ld ix,player+6
174+  B752 DD 36 00 00      ld (ix),0           ; turn off digging
175+  B756 3E 00            ld a,0              ; if it is, load with empty
176+  B758 C9               ret
177+  B759
178+  B759              ;
179+  B759              ; Auto move the player until pixels is zero
180+  B759              ;
181+  B759              control_automove:
182+  B759 5F               ld e,a              ; store the number of pixels left to move in e
183+  B75A ED 4B C5 BA      ld bc,(player)      ; load the current coords into bc
184+  B75E 21 C7 BA         ld hl,player+2      ; get the direction
185+  B761 7E               ld a,(hl)
186+  B762 FE 03            cp 3                ; down
187+  B764 CA 78 B7         jp z,control_automove3  ; don't need to do anything
188+  B767 FE 00            cp 0                ; going up
189+  B769 CA 84 B7         jp z,control_automove2
190+  B76C FE 01            cp 1                ; going left?
191+  B76E CA 90 B7         jp z,control_automove0
192+  B771 78               ld a,b
193+  B772 3C               inc a               ; if we're going right, increment a twice for two pixels
194+  B773 3C               inc a
195+  B774 47               ld b,a
196+  B775 C3 94 B7         jp control_automove1
197+  B778              control_automove3:
198+  B778 79               ld a,c
199+  B779 3C               inc a
200+  B77A 3C               inc a               ; if we're going down, increment twice
201+  B77B 4F               ld c,a
202+  B77C FE 90            cp 144
203+  B77E CC 5C B8         call z, control_scroll_down
204+  B781 C3 94 B7         jp control_automove1
205+  B784              control_automove2:
206+  B784 79               ld a,c
207+  B785 3D               dec a
208+  B786 3D               dec a               ; if we're going up, decrement twice
209+  B787 4F               ld c,a
210+  B788 FE 60            cp 96
211+  B78A CC 69 B8         call z, control_scroll_up
212+  B78D C3 94 B7         jp control_automove1
213+  B790              control_automove0:
214+  B790 78               ld a,b
215+  B791 3D               dec a               ; if we're going left, decrement a twice
216+  B792 3D               dec a
217+  B793 47               ld b,a
218+  B794              control_automove1:
219+  B794 ED 43 C5 BA      ld (player),bc      ; and back to player
220+  B798 7B               ld a,e              ; now get the pixel count back
221+  B799 3D               dec a               ; decrease by one
222+  B79A 21 CA BA         ld hl,player+5
223+  B79D 77               ld (hl),a           ; copy back
224+  B79E CD 50 BC         call player_justmoved
225+  B7A1 C9               ret
226+  B7A2
227+  B7A2              ;
228+  B7A2              ; Moves the player up
229+  B7A2              ;
230+  B7A2              control_pl_moveup:
231+  B7A2 C5               push bc
232+  B7A3 ED 4B C5 BA      ld bc,(player)          ; get the current coords, b horiz, c vert
233+  B7A7 79               ld a,c                  ; load c into the acc
234+  B7A8 FE 18            cp 24
235+  B7AA CA CA B7         jp z,control_pl_moveup0 ; are we at the edge of the screen
236+  B7AD FE 60            cp 96
237+  B7AF CC 69 B8         call z, control_scroll_up
238+  B7B2 CD 09 BA         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
239+  B7B5 F5               push af
240+  B7B6 7B               ld a,e                  ; put e in a
241+  B7B7 FE 00            cp 0
242+  B7B9 CA C9 B7         jp z,control_pl_moveup1 ; don't move if we can't
243+  B7BC F1               pop af
244+  B7BD D6 01            sub 1                   ; subtract 1
245+  B7BF D6 01            sub 1                   ; subtract 1
246+  B7C1 4F               ld c,a                  ; load back to c
247+  B7C2 ED 43 C5 BA      ld (player),bc          ; load back to player
248+  B7C6 C3 CA B7         jp control_pl_moveup0
249+  B7C9              control_pl_moveup1:
250+  B7C9 F1               pop af                  ; restore af if needed
251+  B7CA              control_pl_moveup0:
252+  B7CA 3E 00            ld a,0
253+  B7CC 32 C7 BA         ld (player+2),a        ; set direction to up
254+  B7CF C1               pop bc
255+  B7D0 C9               ret
256+  B7D1              ;
257+  B7D1              ; Moves the player down
258+  B7D1              ;
259+  B7D1              control_pl_movedown:
260+  B7D1 C5               push bc
261+  B7D2 ED 4B C5 BA      ld bc,(player)          ; get the current coords, b horiz, c vert
262+  B7D6 79               ld a,c                  ; load c into the acc
263+  B7D7 FE E0            cp 224
264+  B7D9 CA F7 B7         jp z,control_pl_movedown0 ; are we at the edge of the screen
265+  B7DC FE 80            cp 128
266+  B7DE CC 5C B8         call z, control_scroll_down
267+  B7E1 CD DD B9         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
268+  B7E4 F5               push af
269+  B7E5 7B               ld a,e                  ; put e in a
270+  B7E6 FE 00            cp 0
271+  B7E8 CA F6 B7         jp z,control_pl_movedown1 ; don't move if we can't
272+  B7EB F1               pop af
273+  B7EC 3C               inc a                   ; add 1
274+  B7ED 3C               inc a                   ; add 1
275+  B7EE 4F               ld c,a                  ; load back to c
276+  B7EF ED 43 C5 BA      ld (player),bc          ; load back to player
277+  B7F3 C3 F7 B7         jp control_pl_movedown0
278+  B7F6              control_pl_movedown1:
279+  B7F6 F1               pop af                  ; restore af if needed
280+  B7F7              control_pl_movedown0:
281+  B7F7 3E 03            ld a,3
282+  B7F9 32 C7 BA         ld (player+2),a        ; set direction to down
283+  B7FC C1               pop bc
284+  B7FD C9               ret
285+  B7FE              ;
286+  B7FE              ; Moves the player left
287+  B7FE              ;
288+  B7FE              control_pl_moveleft:
289+  B7FE C5               push bc
290+  B7FF ED 4B C5 BA      ld bc,(player)          ; get the current coords, b horiz, c vert
291+  B803 78               ld a,b                  ; load b into the acc
292+  B804 FE 10            cp 16
293+  B806 CA 27 B8         jp z,control_pl_moveleft0 ; are we at the edge of the screen
294+  B809 CD 68 BA         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
295+  B80C F5               push af
296+  B80D 7B               ld a,e                  ; put e in a
297+  B80E FE 00            cp 0
298+  B810 CA 26 B8         jp z,control_pl_moveleft1 ; don't move if we can't
299+  B813 21 CA BA         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
300+  B816 3E 03            ld a,3
301+  B818 77               ld (hl),a
302+  B819 F1               pop af
303+  B81A D6 01            sub 1                    ; subtract 2
304+  B81C D6 01            sub 1
305+  B81E 47               ld b,a                  ; load back to c
306+  B81F ED 43 C5 BA      ld (player),bc          ; load back to player
307+  B823 C3 27 B8         jp control_pl_moveleft0
308+  B826              control_pl_moveleft1:
309+  B826 F1               pop af
310+  B827              control_pl_moveleft0:
311+  B827 3E 01            ld a,1
312+  B829 32 C7 BA         ld (player+2),a        ; set direction to left
313+  B82C C1               pop bc
314+  B82D C9               ret
315+  B82E              ;
316+  B82E              ; Moves the player right
317+  B82E              ;
318+  B82E              control_pl_moveright:
319+  B82E C5               push bc
320+  B82F ED 4B C5 BA      ld bc,(player)          ; get the current coords, b horiz, c vert
321+  B833 78               ld a,b                  ; load b into the acc
322+  B834 FE F0            cp 240
323+  B836 CA 55 B8         jp z,control_pl_moveright0 ; are we at the edge of the screen
324+  B839 CD 3C BA         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
325+  B83C F5               push af
326+  B83D 7B               ld a,e                  ; put e in a
327+  B83E FE 00            cp 0
328+  B840 CA 54 B8         jp z,control_pl_moveright1 ; don't move if we can't
329+  B843 21 CA BA         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
330+  B846 3E 03            ld a,3
331+  B848 77               ld (hl),a
332+  B849 F1               pop af
333+  B84A 3C               inc a                   ; add 2
334+  B84B 3C               inc a
335+  B84C 47               ld b,a                  ; load back to b
336+  B84D ED 43 C5 BA      ld (player),bc          ; load back to player
337+  B851 C3 55 B8         jp control_pl_moveright0
338+  B854              control_pl_moveright1:
339+  B854 F1               pop af                  ; restore af if needed
340+  B855              control_pl_moveright0:
341+  B855 3E 02            ld a,2
342+  B857 32 C7 BA         ld (player+2),a        ; set direction to right
343+  B85A C1               pop bc
344+  B85B C9               ret
345+  B85C
346+  B85C              ;
347+  B85C              ; Scrolls the screen down
348+  B85C              ;
349+  B85C              control_scroll_down:
350+  B85C F5               push af
351+  B85D 3E 08            ld a,8
352+  B85F 32 A2 A7         ld (screen_offset),a
353+  B862 F1               pop af
354+  B863 21 EB A5         ld hl,buffer_updateall
355+  B866 36 01            ld (hl),1         ; flag as screen needing update
356+  B868 C9               ret
357+  B869
358+  B869              ;
359+  B869              ; Scrolls the screen up
360+  B869              ;
361+  B869              control_scroll_up:
362+  B869 F5               push af
363+  B86A 3E 00            ld a,0
364+  B86C 32 A2 A7         ld (screen_offset),a
365+  B86F F1               pop af
366+  B870 21 EB A5         ld hl,buffer_updateall
367+  B873 36 01            ld (hl),1         ; flag as screen needing update
368+  B875 C9               ret
369+  B876
370+  B876
371+  B876
372+  B876
# file closed: game/control.asm
 37   B876                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  B876              ;
  2+  B876              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  3+  B876              ; Inputs:
  4+  B876              ; hl - memory location of top pixel row
  5+  B876              ; bc - screen coords, b horiz, c vert
  6+  B876              ; Outputs:
  7+  B876              ; e - 0 if not empty, 1 if empty
  8+  B876              ;
  9+  B876              movement_spaceisempty:
 10+  B876 C5               push bc
 11+  B877 E5               push hl
 12+  B878 CD A0 B8         call movement_spaceisgem        ; check if space is a gem
 13+  B87B E1               pop hl
 14+  B87C C1               pop bc
 15+  B87D 7B               ld a,e
 16+  B87E FE 01            cp 1
 17+  B880 C8               ret z                           ; if e is 1, space is a gem so can move here, return
 18+  B881 3E 08            ld a,8                          ; 8 rows to check
 19+  B883              movement_spaceisempty0:
 20+  B883 08               ex af,af'                       ; store the loop counter
 21+  B884 7E               ld a,(hl)                       ; get current pixel row
 22+  B885 FE 00            cp 0
 23+  B887 C2 9B B8         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 24+  B88A 79               ld a,c                          ; load the vertical coord
 25+  B88B 3C               inc a                           ; next row down
 26+  B88C 11 20 00         ld de,32
 27+  B88F 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 28+  B890 4F               ld c,a                          ; copy vert coord back to c
 29+  B891 08               ex af,af'                       ; get loop counter back
 30+  B892 3D               dec a                           ; decrease loop counter
 31+  B893 C2 83 B8         jp nz, movement_spaceisempty0
 32+  B896 16 00            ld d,0
 33+  B898 1E 01            ld e,1                          ; got to end, so space is empty
 34+  B89A C9               ret
 35+  B89B              movement_spaceisempty1:
 36+  B89B 16 00            ld d,0
 37+  B89D 1E 00            ld e,0                          ; returning false, ie space not empty
 38+  B89F C9               ret
 39+  B8A0
 40+  B8A0              ;
 41+  B8A0              ; Check if a space contains a gem
 42+  B8A0              ; Inputs:
 43+  B8A0              ; bc - screen coords
 44+  B8A0              ; Outputs:
 45+  B8A0              ; e = 1 if gem
 46+  B8A0              movement_spaceisgem:
 47+  B8A0 CD F4 A8         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 48+  B8A3 21 82 B3         ld hl,level01diamonds           ; check diamonds first
 49+  B8A6              movement_spaceisgem0:
 50+  B8A6 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 51+  B8AA 7B               ld a,e                          ; check for end of data
 52+  B8AB FE FF            cp 255
 53+  B8AD CA C8 B8         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 54+  B8B0 23               inc hl
 55+  B8B1 23               inc hl                          ; move to state
 56+  B8B2 7E               ld a,(hl)
 57+  B8B3 23               inc hl
 58+  B8B4 23               inc hl
 59+  B8B5 23               inc hl                          ; get to next
 60+  B8B6 FE 01            cp 1                            ; check if collected
 61+  B8B8 CA A6 B8         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 62+  B8BB 7B               ld a,e                          ; load e again
 63+  B8BC B9               cp c                            ; otherwise, compare c with e
 64+  B8BD C2 A6 B8         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 65+  B8C0 7A               ld a,d                          ; get d coord
 66+  B8C1 B8               cp b                            ; compare b with d
 67+  B8C2 C2 A6 B8         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 68+  B8C5 1E 01            ld e,1                          ; otherwise, exit with e = 1
 69+  B8C7 C9               ret
 70+  B8C8              movement_spaceisgem1:
 71+  B8C8 21 92 B3         ld hl,level01gems              ; check gems
 72+  B8CB              movement_spaceisgem2:
 73+  B8CB 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 74+  B8CF 7B               ld a,e                          ; check for end of data
 75+  B8D0 FE FF            cp 255
 76+  B8D2 CA ED B8         jp z,movement_spaceisgem3       ; if yes, done with gems
 77+  B8D5 23               inc hl
 78+  B8D6 23               inc hl                          ; move to state
 79+  B8D7 7E               ld a,(hl)
 80+  B8D8 23               inc hl
 81+  B8D9 23               inc hl
 82+  B8DA 23               inc hl                          ; get to next
 83+  B8DB FE 01            cp 1                            ; check if collected
 84+  B8DD CA CB B8         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 85+  B8E0 7B               ld a,e                          ; load e again
 86+  B8E1 B9               cp c                            ; otherwise, compare c with e
 87+  B8E2 C2 CB B8         jp nz,movement_spaceisgem2      ; if different, move to next gem
 88+  B8E5 7A               ld a,d                          ; get d coord
 89+  B8E6 B8               cp b                            ; compare b with d
 90+  B8E7 C2 CB B8         jp nz,movement_spaceisgem2      ; if different, move to next gem
 91+  B8EA 1E 01            ld e,1                          ; otherwise, exit with e = 1
 92+  B8EC C9               ret
 93+  B8ED              movement_spaceisgem3:
 94+  B8ED 1E 00            ld e,0                          ; nothing found, return e = 0
 95+  B8EF C9               ret
 96+  B8F0
 97+  B8F0              ;
 98+  B8F0              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
 99+  B8F0              ; Inputs:
100+  B8F0              ; hl - memory location of top pixel row
101+  B8F0              ; bc - screen coords, b horiz, c vert
102+  B8F0              ; Outputs:
103+  B8F0              ; e - 0 if not empty, 1 if empty
104+  B8F0              ;
105+  B8F0              movement_linebelowisempty:
106+  B8F0 C5               push bc
107+  B8F1 E5               push hl
108+  B8F2 CD A0 B8         call movement_spaceisgem        ; check if space is a gem
109+  B8F5 E1               pop hl
110+  B8F6 C1               pop bc
111+  B8F7 7B               ld a,e
112+  B8F8 FE 01            cp 1
113+  B8FA C8               ret z                           ; if e is 1, space is a gem so can move here, return
114+  B8FB 7E               ld a,(hl)                       ; get current pixel row
115+  B8FC FE 00            cp 0
116+  B8FE C2 06 B9         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
117+  B901 16 00            ld d,0
118+  B903 1E 01            ld e,1                          ; got to end, so space is empty
119+  B905 C9               ret
120+  B906              movement_linebelowisempty1:
121+  B906 16 00            ld d,0
122+  B908 1E 00            ld e,0                          ; returning false, ie space not empty
123+  B90A C9               ret
124+  B90B
125+  B90B              ;
126+  B90B              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
127+  B90B              ; Inputs:
128+  B90B              ; hl - memory location of top pixel row
129+  B90B              ; bc - screen coords, b horiz, c vert
130+  B90B              ; Outputs:
131+  B90B              ; e - 0 if not empty, 1 if empty
132+  B90B              ;
133+  B90B              movement_lineaboveisempty:
134+  B90B C5               push bc
135+  B90C E5               push hl
136+  B90D CD A0 B8         call movement_spaceisgem        ; check if space is a gem
137+  B910 E1               pop hl
138+  B911 C1               pop bc
139+  B912 7B               ld a,e
140+  B913 FE 01            cp 1
141+  B915 C8               ret z
142+  B916 7E               ld a,(hl)                       ; get current pixel row
143+  B917 FE 00            cp 0
144+  B919 C2 21 B9         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
145+  B91C 16 00            ld d,0
146+  B91E 1E 01            ld e,1                          ; got to end, so space is empty
147+  B920 C9               ret
148+  B921              movement_lineaboveisempty1:
149+  B921 16 00            ld d,0
150+  B923 1E 00            ld e,0                          ; returning false, ie space not empty
151+  B925 C9               ret
152+  B926
153+  B926              ;
154+  B926              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
155+  B926              ; Inputs:
156+  B926              ; hl - memory location of top pixel row
157+  B926              ; bc - screen coords, b horiz, c vert
158+  B926              ; Outputs:
159+  B926              ; none - puts player into digging mode
160+  B926              ;
161+  B926              movement_spaceisdiggable:
162+  B926 3E 08            ld a,8                          ; 8 rows to check
163+  B928              movement_spaceisdiggable0:
164+  B928 08               ex af,af'                       ; store the loop counter
165+  B929 7E               ld a,(hl)                       ; get current pixel row
166+  B92A FE 00            cp 0
167+  B92C CA 3C B9         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
168+  B92F FE 55            cp 85
169+  B931 CA 3C B9         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
170+  B934 FE AA            cp 170
171+  B936 CA 3C B9         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
172+  B939 C3 54 B9         jp movement_spaceisdiggable1     ; otherwise, stop checking
173+  B93C              movement_spaceisdiggable2:
174+  B93C 79               ld a,c                          ; load the vertical coord
175+  B93D 3C               inc a                           ; next row down
176+  B93E 11 20 00         ld de,32
177+  B941 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
178+  B942 4F               ld c,a                          ; copy vert coord back to c
179+  B943 08               ex af,af'                       ; get loop counter back
180+  B944 3D               dec a                           ; decrease loop counter
181+  B945 C2 28 B9         jp nz, movement_spaceisdiggable0
182+  B948 21 CB BA         ld hl,player+6
183+  B94B 36 01            ld (hl),1                       ; set the player into digging mode
184+  B94D 23               inc hl
185+  B94E 36 05            ld (hl),5                      ; set the number of frame to dig for
186+  B950 23               inc hl
187+  B951 36 08            ld (hl),8                       ; set the number of pixels to dig
188+  B953 C9               ret
189+  B954              movement_spaceisdiggable1:
190+  B954 21 CB BA         ld hl,player+6
191+  B957 36 00            ld (hl),0                       ; set the player out of digging mode
192+  B959 C9               ret
193+  B95A
194+  B95A              ;
195+  B95A              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
196+  B95A              ; Inputs:
197+  B95A              ; hl - memory location of top pixel row
198+  B95A              ; bc - screen coords, b horiz, c vert
199+  B95A              ; Outputs:
200+  B95A              ; none - puts player into digging mode
201+  B95A              ;
202+  B95A              movement_spacebelowisdiggable:
203+  B95A 7E               ld a,(hl)                       ; get first pixel row
204+  B95B FE 55            cp 85
205+  B95D CA 68 B9         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
206+  B960 FE AA            cp 170
207+  B962 CA 68 B9         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
208+  B965 C3 54 B9         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
209+  B968              movement_spacebelowisdiggable3:
210+  B968 3E 08            ld a,8                          ; rows to check
211+  B96A 1E 00            ld e,0                          ; count of rows to dig
212+  B96C              movement_spacebelowisdiggable0:
213+  B96C 08               ex af,af'                       ; store the loop counter
214+  B96D 7E               ld a,(hl)                       ; get current pixel row
215+  B96E FE 55            cp 85
216+  B970 CA 7B B9         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
217+  B973 FE AA            cp 170
218+  B975 CA 7B B9         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
219+  B978 C3 8A B9         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
220+  B97B              movement_spacebelowisdiggable4:
221+  B97B 1C               inc e                           ; inc count of rows to dig
222+  B97C              movement_spacebelowisdiggable2:
223+  B97C 79               ld a,c                          ; load the vertical coord
224+  B97D 3C               inc a                           ; next row down
225+  B97E D5               push de                         ; need e for later
226+  B97F 11 20 00         ld de,32
227+  B982 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
228+  B983 4F               ld c,a                          ; copy vert coord back to c
229+  B984 D1               pop de                          ; get e back
230+  B985 08               ex af,af'                       ; get loop counter back
231+  B986 3D               dec a                           ; incease loop counter
232+  B987 C2 6C B9         jp nz, movement_spacebelowisdiggable0
233+  B98A              movement_spacebelowisdiggable5:
234+  B98A 21 CB BA         ld hl,player+6
235+  B98D 36 01            ld (hl),1                       ; set the player into digging mode
236+  B98F 23               inc hl
237+  B990 36 03            ld (hl),3                      ; set the number of frame to dig for
238+  B992 23               inc hl
239+  B993 73               ld (hl),e                       ; set the number of pixels to dig
240+  B994 C9               ret
241+  B995              movement_spacebelowisdiggable1:
242+  B995 21 CB BA         ld hl,player+6
243+  B998 36 00            ld (hl),0                       ; set the player out of digging mode
244+  B99A C9               ret
245+  B99B
246+  B99B              ;
247+  B99B              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
248+  B99B              ; Inputs:
249+  B99B              ; hl - memory location of top pixel row
250+  B99B              ; bc - screen coords, b horiz, c vert
251+  B99B              ; Outputs:
252+  B99B              ; none - puts player into digging mode
253+  B99B              ;
254+  B99B              movement_spaceaboveisdiggable:
255+  B99B 7E               ld a,(hl)                       ; get first pixel row
256+  B99C FE 55            cp 85
257+  B99E CA A9 B9         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
258+  B9A1 FE AA            cp 170
259+  B9A3 CA A9 B9         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
260+  B9A6 C3 54 B9         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
261+  B9A9              movement_spaceaboveisdiggable3:
262+  B9A9 3E 08            ld a,8                          ; rows to check
263+  B9AB 1E 00            ld e,0                          ; count of rows to dig
264+  B9AD              movement_spaceaboveisdiggable0:
265+  B9AD 08               ex af,af'                       ; store the loop counter
266+  B9AE 7E               ld a,(hl)                       ; get current pixel row
267+  B9AF FE 55            cp 85
268+  B9B1 CA BC B9         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
269+  B9B4 FE AA            cp 170
270+  B9B6 CA BC B9         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
271+  B9B9 C3 CC B9         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
272+  B9BC              movement_spaceaboveisdiggable4:
273+  B9BC 1C               inc e                           ; inc count of rows to dig
274+  B9BD              movement_spaceaboveisdiggable2:
275+  B9BD 79               ld a,c                          ; load the vertical coord
276+  B9BE 3D               dec a                           ; next row up
277+  B9BF D5               push de                         ; need e for later
278+  B9C0 11 20 00         ld de,32
279+  B9C3 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
280+  B9C5 4F               ld c,a                          ; copy vert coord back to c
281+  B9C6 D1               pop de                          ; get e back
282+  B9C7 08               ex af,af'                       ; get loop counter back
283+  B9C8 3D               dec a                           ; incease loop counter
284+  B9C9 C2 AD B9         jp nz, movement_spaceaboveisdiggable0
285+  B9CC              movement_spaceaboveisdiggable5:
286+  B9CC 21 CB BA         ld hl,player+6
287+  B9CF 36 01            ld (hl),1                       ; set the player into digging mode
288+  B9D1 23               inc hl
289+  B9D2 36 05            ld (hl),5                       ; set the number of frame to dig for
290+  B9D4 23               inc hl
291+  B9D5 73               ld (hl),e                       ; set the number of pixels to dig
292+  B9D6 C9               ret
293+  B9D7              movement_spaceaboveisdiggable1:
294+  B9D7 21 CB BA         ld hl,player+6
295+  B9DA 36 00            ld (hl),0                       ; set the player out of digging mode
296+  B9DC C9               ret
297+  B9DD
298+  B9DD              ;
299+  B9DD              ; Checks if the player can move down
300+  B9DD              ; Inputs:
301+  B9DD              ; bc - player coords, b horiz, c vert
302+  B9DD              ; Outputs:
303+  B9DD              ; de - 1 can move
304+  B9DD              movement_checkcanmove_down:
305+  B9DD F5               push af
306+  B9DE C5               push bc
307+  B9DF CD 49 AA         call sprites_scadd              ; get the memory location of cell into de
308+  B9E2 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
309+  B9E4 24               inc h                       ; memory location of cell beneath now in hl
310+  B9E5 3E 08            ld a,8                       ; look below
311+  B9E7 81               add c
312+  B9E8 4F               ld c,a
313+  B9E9 CD F0 B8         call movement_linebelowisempty       ; check space is empty
314+  B9EC 7B               ld a,e                          ; check space empty flag
315+  B9ED FE 00            cp 0
316+  B9EF CA F8 B9         jp z, movement_checkcanmove_down1 ; can't move
317+  B9F2 CD 50 BC         call player_justmoved
318+  B9F5 C1               pop bc
319+  B9F6 F1               pop af
320+  B9F7 C9               ret
321+  B9F8              movement_checkcanmove_down1:
322+  B9F8 C1               pop bc
323+  B9F9 CD 49 AA         call sprites_scadd              ; get the memory location of cell into de
324+  B9FC 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
325+  B9FE 24               inc h
326+  B9FF C5               push bc
327+  BA00 CD 5A B9         call movement_spacebelowisdiggable    ; can't move here, but can we dig
328+  BA03 11 00 00         ld de,0
329+  BA06 C1               pop bc
330+  BA07 F1               pop af
331+  BA08 C9               ret
332+  BA09
333+  BA09              ;
334+  BA09              ; Checks if the player can move up
335+  BA09              ; Inputs:
336+  BA09              ; bc - player coords, b horiz, c vert
337+  BA09              ; Outputs:
338+  BA09              ; de - 1 can move
339+  BA09              movement_checkcanmove_up:
340+  BA09 F5               push af
341+  BA0A C5               push bc
342+  BA0B CD 49 AA         call sprites_scadd              ; get the memory location of cell into de
343+  BA0E 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
344+  BA10 11 20 00         ld de,32
345+  BA13 ED 52            sbc hl,de                       ; memory location of line above now in hl
346+  BA15 0D               dec c                           ; look above
347+  BA16 CD 0B B9         call movement_lineaboveisempty       ; check space is empty
348+  BA19 7B               ld a,e                          ; check space empty flag
349+  BA1A FE 00            cp 0
350+  BA1C CA 27 BA         jp z, movement_checkcanmove_up1 ; can't move
351+  BA1F 1E 01            ld e,1
352+  BA21 CD 50 BC         call player_justmoved
353+  BA24 C1               pop bc
354+  BA25 F1               pop af
355+  BA26 C9               ret
356+  BA27              movement_checkcanmove_up1:
357+  BA27 C1               pop bc
358+  BA28 CD 49 AA         call sprites_scadd              ; get the memory location of cell into de
359+  BA2B 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
360+  BA2D 11 20 00         ld de,32
361+  BA30 ED 52            sbc hl,de                       ; memory location of line above now in hl
362+  BA32 C5               push bc
363+  BA33 CD 9B B9         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
364+  BA36 11 00 00         ld de,0
365+  BA39 C1               pop bc
366+  BA3A F1               pop af
367+  BA3B C9               ret
368+  BA3C
369+  BA3C              ;
370+  BA3C              ; Checks if the player can move right
371+  BA3C              ; Inputs:
372+  BA3C              ; bc - player coords, b horiz, c vert
373+  BA3C              ; Outputs:
374+  BA3C              ; de - 1 can move
375+  BA3C              movement_checkcanmove_right:
376+  BA3C F5               push af
377+  BA3D C5               push bc
378+  BA3E CD 49 AA         call sprites_scadd              ; get the memory location of cell into de
379+  BA41 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
380+  BA43 3E 08            ld a,8
381+  BA45 80               add b                           ; move one cell right
382+  BA46 47               ld b,a
383+  BA47 23               inc hl                          ; memory location of cell to the right now in hl
384+  BA48 CD 76 B8         call movement_spaceisempty       ; check space is empty
385+  BA4B 7B               ld a,e                          ; check space empty flag
386+  BA4C FE 00            cp 0
387+  BA4E CA 57 BA         jp z, movement_checkcanmove_right1 ; can't move
388+  BA51 CD 50 BC         call player_justmoved
389+  BA54 C1               pop bc
390+  BA55 F1               pop af
391+  BA56 C9               ret
392+  BA57              movement_checkcanmove_right1:
393+  BA57 C1               pop bc
394+  BA58 CD 49 AA         call sprites_scadd              ; get the memory location of cell into de
395+  BA5B 62 6B            ld hl,de
396+  BA5D 23               inc hl                          ; memory location of cell to the right now in hl
397+  BA5E C5               push bc
398+  BA5F CD 26 B9         call movement_spaceisdiggable    ; can't move here, but can we dig
399+  BA62 11 00 00         ld de,0
400+  BA65 C1               pop bc
401+  BA66 F1               pop af
402+  BA67 C9               ret
403+  BA68
404+  BA68              ;
405+  BA68              ; Checks if the player can move left
406+  BA68              ; Inputs:
407+  BA68              ; bc - player coords, b horiz, c vert
408+  BA68              ; Outputs:
409+  BA68              ; de - 1 can move
410+  BA68              movement_checkcanmove_left:
411+  BA68 F5               push af
412+  BA69 C5               push bc
413+  BA6A CD 49 AA         call sprites_scadd              ; get the memory location of cell into de
414+  BA6D 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
415+  BA6F 78               ld a,b
416+  BA70 06 08            ld b,8
417+  BA72 90               sub b                           ; move one cell left
418+  BA73 47               ld b,a
419+  BA74 2B               dec hl                          ; memory location of cell to the right now in hl
420+  BA75 CD 76 B8         call movement_spaceisempty       ; check space is empty
421+  BA78 7B               ld a,e                          ; check space empty flag
422+  BA79 FE 00            cp 0
423+  BA7B CA 84 BA         jp z, movement_checkcanmove_left1 ; can't move
424+  BA7E CD 50 BC         call player_justmoved
425+  BA81 C1               pop bc
426+  BA82 F1               pop af
427+  BA83 C9               ret
428+  BA84              movement_checkcanmove_left1:
429+  BA84 C1               pop bc
430+  BA85 CD 49 AA         call sprites_scadd              ; get the memory location of cell into de
431+  BA88 62 6B            ld hl,de
432+  BA8A 2B               dec hl                          ; memory location of cell to the right now in hl
433+  BA8B C5               push bc
434+  BA8C CD 26 B9         call movement_spaceisdiggable    ; can't move here, but can we dig
435+  BA8F 11 00 00         ld de,0
436+  BA92 C1               pop bc
437+  BA93 F1               pop af
438+  BA94 C9               ret
# file closed: game/movement.asm
 38   BA95                  include "game\game.asm"
# file opened: game/game.asm
  1+  BA95              ;
  2+  BA95              ; The current frame count, incremented each frame
  3+  BA95              ;
  4+  BA95              game_framenumber:
  5+  BA95 00               defb    0
  6+  BA96
  7+  BA96              ;
  8+  BA96              ; The number of players
  9+  BA96              ;
 10+  BA96              game_numberplayers:
 11+  BA96 01               defb 1
 12+  BA97
 13+  BA97              ;
 14+  BA97              ; The current player
 15+  BA97              ;
 16+  BA97              game_currentplayer:
 17+  BA97 01               defb 1
 18+  BA98
 19+  BA98              ;
 20+  BA98              ; The default number of lives
 21+  BA98              ;
 22+  BA98              game_numberlives:
 23+  BA98 04               defb 4
 24+  BA99
 25+  BA99              ;
 26+  BA99              ; Moves to the next player
 27+  BA99              ;
 28+  BA99              game_changeplayer:
 29+  BA99 3A 97 BA         ld a,(game_currentplayer)
 30+  BA9C FE 01            cp 1
 31+  BA9E C8               ret z                       ; if just one player, no need to change
 32+  BA9F 3D               dec a                       ; otherwise decrease by one
 33+  BAA0 EE 01            xor 1                       ; xor with one to flip
 34+  BAA2 3C               inc a                       ; increment
 35+  BAA3 21 97 BA         ld hl,game_currentplayer
 36+  BAA6 77               ld (hl),a                   ; store
 37+  BAA7 C9               ret
 38+  BAA8
 39+  BAA8              ;
 40+  BAA8              ; Sets the number of players at the start of the game
 41+  BAA8              ; Inputs:
 42+  BAA8              ; a - number of players
 43+  BAA8              game_setnumberofplayers:
 44+  BAA8 21 96 BA         ld hl,game_numberplayers
 45+  BAAB 77               ld (hl),a
 46+  BAAC
 47+  BAAC              ;
 48+  BAAC              ; Increment frame number by 1
 49+  BAAC              ;
 50+  BAAC              game_incrementframe:
 51+  BAAC 3A 95 BA         ld a,(game_framenumber)
 52+  BAAF FE FF            cp 255
 53+  BAB1 C2 B6 BA         jp nz,game_incrementframe0
 54+  BAB4 3E 00            ld a,0
 55+  BAB6              game_incrementframe0:
 56+  BAB6 3C               inc a
 57+  BAB7 32 95 BA         ld (game_framenumber),a
 58+  BABA C9               ret
 59+  BABB
 60+  BABB              ;
 61+  BABB              ; Returns current frame
 62+  BABB              ; Outputs:
 63+  BABB              ; a - current frame
 64+  BABB              ;
 65+  BABB              game_getcurrentframe:
 66+  BABB 3A 95 BA         ld a,(game_framenumber)
 67+  BABE C9               ret
 68+  BABF
 69+  BABF              ;
 70+  BABF              ; Resets current frame
 71+  BABF              ;
 72+  BABF              game_resetcurrentframe:
 73+  BABF 21 95 BA         ld hl,game_framenumber
 74+  BAC2 36 00            ld (hl),0
 75+  BAC4 C9               ret
# file closed: game/game.asm
 39   BAC5                  include "game\player.asm"
# file opened: game/player.asm
  1+  BAC5              ;
  2+  BAC5              ;   Data for current player
  3+  BAC5              ;
  4+  BAC5              player:
  5+  BAC5 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  BAC7 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  BACA 00               defb    0                   ; auto move remaining (+5)
  8+  BACB 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  BACE 00               defb    0                   ; lives remaining (+9)
 10+  BACF 00               defb    0                   ; died this life (+10)
 11+  BAD0 00 00            defb    0,0                 ; crushed (+11), frames (+12)
 12+  BAD2 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  BAD3
 14+  BAD3              player_location:
 15+  BAD3 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 16+  BAD4
 17+  BAD4              ;
 18+  BAD4              ; Works out which part of the screen the player is in
 19+  BAD4              ; Pit is between 3,9 and 8,9
 20+  BAD4              ; Diamond cavern is between 11,22 and 22,28
 21+  BAD4              ;
 22+  BAD4              player_getlocation:
 23+  BAD4 ED 4B C5 BA      ld bc,(player)              ; get screen coords
 24+  BAD8 CD F4 A8         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 25+  BADB 78               ld a,b                      ; check for pit first
 26+  BADC FE 09            cp 9                        ; if not on this row, not in the pit
 27+  BADE C2 ED BA         jp nz,player_getlocation0
 28+  BAE1 79               ld a,c                      ; check horizontal
 29+  BAE2 FE 08            cp 8
 30+  BAE4 D2 ED BA         jp nc, player_getlocation0  ; if more than 8, not in the pit
 31+  BAE7 21 D3 BA         ld hl,player_location
 32+  BAEA 36 02            ld (hl),2                   ; load location with 2, the pit
 33+  BAEC C9               ret                         ; done
 34+  BAED              player_getlocation0:            ; check for diamond cavern
 35+  BAED 78               ld a,b                      ; first check vertical
 36+  BAEE FE 16            cp 22                       ; if above row 22, then not in cavern
 37+  BAF0 DA 04 BB         jp c,player_getlocation1
 38+  BAF3 79               ld a,c                      ; get the horizontal next
 39+  BAF4 FE 0B            cp 11
 40+  BAF6 DA 04 BB         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 41+  BAF9 FE 16            cp 22
 42+  BAFB D2 04 BB         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 43+  BAFE 21 D3 BA         ld hl,player_location
 44+  BB01 36 01            ld (hl),1                   ; load location with 1, the cavern
 45+  BB03 C9               ret
 46+  BB04              player_getlocation1:
 47+  BB04 21 D3 BA         ld hl,player_location
 48+  BB07 36 00            ld (hl),0                   ; load location with 2, the pit
 49+  BB09 C9               ret                         ; done
 50+  BB0A
 51+  BB0A
 52+  BB0A              ;
 53+  BB0A              ; Initializes a player at start of game
 54+  BB0A              ; Copy initial coords, copy lives, copy score
 55+  BB0A              ;
 56+  BB0A              player_init_gamestart:
 57+  BB0A 3A 98 BA         ld a,(game_numberlives)
 58+  BB0D 32 99 BB         ld (player1_lives),a
 59+  BB10 32 9A BB         ld (player2_lives),a                        ; set the initial number of lives at game start
 60+  BB13
 61+  BB13 21 9D BB         ld hl,player1_score+2
 62+  BB16 06 06            ld b,6
 63+  BB18              player_init_gamestart0:
 64+  BB18 36 30            ld (hl),48
 65+  BB1A 23               inc hl
 66+  BB1B 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 67+  BB1D 21 A6 BB         ld hl,player2_score+2
 68+  BB20 06 06            ld b,6
 69+  BB22              player_init_gamestart1:
 70+  BB22 36 30            ld (hl),48
 71+  BB24 23               inc hl
 72+  BB25 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 73+  BB27 C9               ret
 74+  BB28
 75+  BB28              ;
 76+  BB28              ; Initializes a player at start of a life
 77+  BB28              ; Copy initial coords, copy lives, copy score
 78+  BB28              ;
 79+  BB28              player_init_lifestart:
 80+  BB28 21 CA BA         ld hl,player+5
 81+  BB2B 06 09            ld b,9                      ; initialise 9 properties
 82+  BB2D              player_init_lifestart2:
 83+  BB2D 36 00            ld (hl),0
 84+  BB2F 23               inc hl
 85+  BB30 10 FB            djnz player_init_lifestart2
 86+  BB32
 87+  BB32 21 C7 BA         ld hl,player+2              ; initialise some properties
 88+  BB35 36 02            ld (hl),2
 89+  BB37 23               inc hl
 90+  BB38 36 00            ld (hl),0
 91+  BB3A 23               inc hl
 92+  BB3B 36 01            ld (hl),1
 93+  BB3D
 94+  BB3D ED 4B 22 80      ld bc,(init_coord)
 95+  BB41 ED 43 C5 BA      ld (player),bc
 96+  BB45 01 CE BA         ld bc,player+9
 97+  BB48 3A 99 BB         ld a,(player1_lives)
 98+  BB4B 02               ld (bc),a
 99+  BB4C
100+  BB4C CD 2F C3         call diamonds_init      ; initialise gems
101+  BB4F
102+  BB4F 01 06 00         ld bc,6
103+  BB52 11 63 C1         ld de,scores_current+2
104+  BB55 3A 97 BA         ld a,(game_currentplayer)
105+  BB58 FE 01            cp 1
106+  BB5A C2 63 BB         jp nz,player_init_lifestart0
107+  BB5D 21 9D BB         ld hl,player1_score+2
108+  BB60 C3 66 BB         jp player_init_lifestart1
109+  BB63              player_init_lifestart0:
110+  BB63 21 A6 BB         ld hl,player2_score+2
111+  BB66              player_init_lifestart1:
112+  BB66 ED B0            ldir
113+  BB68 C9               ret
114+  BB69
115+  BB69              ;
116+  BB69              ; Finalises a player at end of a life
117+  BB69              ; Copy lives, copy score
118+  BB69              ;
119+  BB69              player_lifeend:
120+  BB69 01 CE BA         ld bc,player+9
121+  BB6C 0A               ld a,(bc)
122+  BB6D 01 99 BB         ld bc,player1_lives
123+  BB70 02               ld (bc),a
124+  BB71 CD 75 BB         call player_recordcurrentscore
125+  BB74 C9               ret
126+  BB75
127+  BB75              ;
128+  BB75              ; Copies the current score in the current
129+  BB75              ;
130+  BB75              player_recordcurrentscore:
131+  BB75 01 06 00         ld bc,6                  ; copy current score back to correct player
132+  BB78 21 63 C1         ld hl,scores_current+2
133+  BB7B 3A 97 BA         ld a,(game_currentplayer)
134+  BB7E FE 01            cp 1
135+  BB80 C2 89 BB         jp nz,player_lifeend0
136+  BB83 11 9D BB         ld de,player1_score+2
137+  BB86 C3 8C BB         jp player_lifeend1
138+  BB89              player_lifeend0:
139+  BB89 11 A6 BB         ld de,player2_score+2
140+  BB8C              player_lifeend1:
141+  BB8C ED B0            ldir
142+  BB8E C9               ret
143+  BB8F
144+  BB8F              ;
145+  BB8F              ; Player just died, subtract a life
146+  BB8F              ;
147+  BB8F              player_died:
148+  BB8F 01 CE BA         ld bc,player+9
149+  BB92 0A               ld a,(bc)
150+  BB93 3D               dec a
151+  BB94 02               ld (bc),a
152+  BB95 CD 69 BB         call player_lifeend
153+  BB98 C9               ret
154+  BB99
155+  BB99              ;
156+  BB99              ; Player lives
157+  BB99              ;
158+  BB99              player1_lives:
159+  BB99 03               defb 3
160+  BB9A              player2_lives:
161+  BB9A 03               defb 3
162+  BB9B
163+  BB9B              ;
164+  BB9B              ; Player scores
165+  BB9B              ;
166+  BB9B              player1_score:
167+  BB9B 04 01 30 30      defb 4,1,'000000',255
167+  BB9F 30 30 30 30
167+  BBA3 FF
168+  BBA4              player2_score:
169+  BBA4 16 01 30 30      defb 22,1,'000000',255
169+  BBA8 30 30 30 30
169+  BBAC FF
170+  BBAD
171+  BBAD              ;
172+  BBAD              ; Kills a player this life
173+  BBAD              ;
174+  BBAD              player_killplayer:
175+  BBAD 21 CF BA         ld hl,player+10
176+  BBB0 36 01            ld (hl),1
177+  BBB2 C9               ret
178+  BBB3
179+  BBB3              ;
180+  BBB3              ; Crush a player this life
181+  BBB3              ;
182+  BBB3              player_crushplayer:
183+  BBB3 21 D0 BA         ld hl,player+11             ; mark as crushed
184+  BBB6 36 01            ld (hl),1
185+  BBB8 C9               ret
186+  BBB9
187+  BBB9              player_tankkillplayer
188+  BBB9 21 D0 BA         ld hl,player+11             ; mark as tanked
189+  BBBC 36 02            ld (hl),2
190+  BBBE C9               ret
191+  BBBF
192+  BBBF              player_zonkplayer
193+  BBBF 21 D0 BA         ld hl,player+11             ; mark as zonked (missile)
194+  BBC2 36 03            ld (hl),3
195+  BBC4 C9               ret
196+  BBC5
197+  BBC5              ;
198+  BBC5              ; Draws the player at the current position or deletes them
199+  BBC5              ;
200+  BBC5              player_drawplayer:
201+  BBC5 3A C7 BA         ld a,(player+2)             ; get the current direction
202+  BBC8 FE 03            cp 3
203+  BBCA C2 CF BB         jp nz,player_drawplayer0
204+  BBCD 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
205+  BBCF              player_drawplayer0:
206+  BBCF 5F               ld e,a                      ; store in e
207+  BBD0 3A D0 BA         ld a,(player+11)             ; get the dying flag
208+  BBD3 FE 01            cp 1
209+  BBD5 CA E7 BB         jp z,player_drawplayer3     ; if it's one, we're being crushed
210+  BBD8              player_drawplayer4:
211+  BBD8 3A CB BA         ld a,(player+6)             ; get the dig flag
212+  BBDB FE 01            cp 1
213+  BBDD CA 36 BC         jp z,player_drawplayer1    ; get dig frame
214+  BBE0 3A C8 BA         ld a,(player+3)             ; this is normal movement so get the current frame
215+  BBE3 83               add a,e
216+  BBE4 C3 3B BC         jp player_drawplayer2
217+  BBE7              player_drawplayer3:
218+  BBE7 21 D1 BA         ld hl,player+12
219+  BBEA 7E               ld a,(hl)                  ; crushing, so get the current anim flag
220+  BBEB FE 00            cp 0
221+  BBED C2 F6 BB         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
222+  BBF0 3E 64            ld a,100
223+  BBF2 77               ld (hl),a                   ; otherwise, load up the anim frames
224+  BBF3 C3 D8 BB         jp player_drawplayer4       ; and return to the main loop to remove the current frame
225+  BBF6              player_drawplayer5:
226+  BBF6 3D               dec a
227+  BBF7 77               ld (hl),a
228+  BBF8 FE 00            cp 0
229+  BBFA CC AD BB         call z,player_killplayer     ; final animation, so kill the player
230+  BBFD FE 0A            cp 10                         ; play the sound
231+  BBFF CC 38 AE         call z, sound_rockfell
232+  BC02 FE 14            cp 20                        ; check if we should move the rock
233+  BC04 C2 18 BC         jp nz,player_drawplayer8
234+  BC07 D9               exx
235+  BC08 08               ex af,af'
236+  BC09 ED 4B EA BF      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
237+  BC0D 21 4F B4         ld hl,sprites+72
238+  BC10 CD A4 A9         call sprites_drawsprite     ; draw a rock over current
239+  BC13 08               ex af,af'
240+  BC14 D9               exx
241+  BC15 C3 2F BC         jp player_drawplayer6       ; continue drawing player
242+  BC18              player_drawplayer8:
243+  BC18 FE 14            cp 20
244+  BC1A D2 2F BC         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
245+  BC1D ED 4B C5 BA      ld bc,(player)
246+  BC21 CD F4 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
247+  BC24 3E 42            ld a,66             ; load red
248+  BC26 CD 43 A9         call screen_setattr
249+  BC29 21 4F B4         ld hl,sprites+72            ; otherwise, player is rock
250+  BC2C C3 45 BC         jp player_drawplayer7
251+  BC2F              player_drawplayer6:
252+  BC2F E6 01            and 1                       ; check for odd
253+  BC31 C6 0A            add 10                      ; add 10, to get either 10 or 11
254+  BC33 C3 3B BC         jp player_drawplayer2
255+  BC36              player_drawplayer1:
256+  BC36 3A C7 BA         ld a,(player+2)             ; digging, get the current direction again, because want all four
257+  BC39 C6 06            add a,6                     ; add direction to 6 to get frame
258+  BC3B              player_drawplayer2:
259+  BC3B 07               rlca
260+  BC3C 07               rlca
261+  BC3D 07               rlca                        ; multiply by eight
262+  BC3E 6F               ld l,a
263+  BC3F 26 00            ld h,0
264+  BC41 11 FA B4         ld de,player_sprite
265+  BC44 19               add hl,de                   ; load hl with the location of the player sprite data
266+  BC45              player_drawplayer7:
267+  BC45 ED 4B C5 BA      ld bc,(player)              ; load bc with the start coords
268+  BC49 CD A4 A9         call sprites_drawsprite     ; call the routine to draw the sprite
269+  BC4C CD 7C BC         call player_storeupdatedlines ; log updated rows
270+  BC4F C9               ret
271+  BC50
272+  BC50
273+  BC50              ;
274+  BC50              ; Runs after the player just moved. Changes animation frame if required
275+  BC50              ;
276+  BC50              player_justmoved:
277+  BC50 D9               exx
278+  BC51 3A C9 BA         ld a,(player+4)             ; get the transition count
279+  BC54 FE 00            cp 0
280+  BC56 CA 5C BC         jp z, player_justmoved2     ; if zero reset and change the frame
281+  BC59 C3 76 BC         jp player_justmoved1       ; otherwise decrease and continue
282+  BC5C              player_justmoved2:
283+  BC5C                  ; reset and change frame in here
284+  BC5C 3E 01            ld a,1
285+  BC5E 32 C9 BA         ld (player+4),a            ; reset back to whatever
286+  BC61 3A C8 BA         ld a,(player+3)             ; load the frame
287+  BC64 FE 03            cp 3                       ; flip between 3 and 0
288+  BC66 C2 6E BC         jp nz, player_justmoved4
289+  BC69 3E 00            ld a,0
290+  BC6B C3 70 BC         jp player_justmoved5
291+  BC6E              player_justmoved4:
292+  BC6E 3E 03            ld a,3
293+  BC70              player_justmoved5:
294+  BC70 32 C8 BA         ld (player+3),a           ; save back
295+  BC73 C3 7A BC         jp player_justmoved3
296+  BC76              player_justmoved1:
297+  BC76                  ; decrease count
298+  BC76 3D               dec a
299+  BC77 32 C9 BA         ld (player+4),a
300+  BC7A              player_justmoved3:
301+  BC7A D9               exx;
302+  BC7B C9               ret
303+  BC7C
304+  BC7C              ;
305+  BC7C              ; Stores the updated rows associated with the player
306+  BC7C              ;
307+  BC7C              player_storeupdatedlines:
308+  BC7C ED 4B C5 BA      ld bc,(player)          ; get the screen coords into bc
309+  BC80 79               ld a,c                  ; get the player block coords of current block
310+  BC81 E6 F8            and 248                 ; find closest multiple of eight
311+  BC83 0F               rrca
312+  BC84 0F               rrca
313+  BC85 0F               rrca                    ; divide by 8
314+  BC86 ED 5B A2 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
315+  BC8A 93               sub e
316+  BC8B F5               push af
317+  BC8C CD EC A5         call buffer_marklineforupdate  ; store current row in updated lines
318+  BC8F F1               pop af
319+  BC90 3D               dec a
320+  BC91 F5               push af
321+  BC92 CD EC A5         call buffer_marklineforupdate  ; store line above
322+  BC95 F1               pop af
323+  BC96 3C               inc a
324+  BC97 3C               inc a
325+  BC98 CD EC A5         call buffer_marklineforupdate  ; store line beneath
326+  BC9B C9               ret
327+  BC9C
328+  BC9C              ;
329+  BC9C              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
330+  BC9C              ; Outputs:
331+  BC9C              ; a - 1 for completed level
332+  BC9C              player_checkforexit:
333+  BC9C ED 4B C5 BA      ld bc,(player)                 ; get player coords
334+  BCA0 ED 5B 22 80      ld de,(init_coord)             ; get start coords
335+  BCA4 78               ld a,b
336+  BCA5 BA               cp d                         ; compare horiz
337+  BCA6 C2 B1 BC         jp nz,player_checkforexit1
338+  BCA9 79               ld a,c
339+  BCAA BB               cp e                        ; compare vert
340+  BCAB C2 B1 BC         jp nz,player_checkforexit1
341+  BCAE              player_checkforexit0:
342+  BCAE 3E 01            ld a,1                       ; hasn't completed
343+  BCB0 C9               ret
344+  BCB1              player_checkforexit1:
345+  BCB1 3E 00            ld a,0                       ; has completed
346+  BCB3 C9               ret
# file closed: game/player.asm
 40   BCB4                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  BCB4              ;
  2+  BCB4              ; Ship initial position: vert,horiz
  3+  BCB4              ;
  4+  BCB4              ship_initpos:
  5+  BCB4 00 24            defb 0,36
  6+  BCB6              ship_initpos2:
  7+  BCB6 00 00            defb 0,0
  8+  BCB8              ship_frame:
  9+  BCB8 00               defb 0
 10+  BCB9              ;
 11+  BCB9              ; The current memory location
 12+  BCB9              ;
 13+  BCB9              ship_current_sprite:
 14+  BCB9 00 00            defb 0,0
 15+  BCBB
 16+  BCBB              ship_current_coords:
 17+  BCBB 00 00            defb 0,0
 18+  BCBD
 19+  BCBD              ship_process:
 20+  BCBD 3A D0 BA         ld a,(player+11)
 21+  BCC0 FE 02            cp 2                        ; has the player been killed by tank?
 22+  BCC2 C0               ret nz                      ; do nothing if not
 23+  BCC3 CD 69 B8         call control_scroll_up           ; make sure the screen is on the top screen
 24+  BCC6 CD 35 BD         call ship_takeoff           ; bye bye
 25+  BCC9 CD AD BB         call player_killplayer      ; killed
 26+  BCCC 06 32            ld b,50
 27+  BCCE CD 82 80         call utilities_pauseforframes
 28+  BCD1 C9               ret
 29+  BCD2
 30+  BCD2              ;
 31+  BCD2              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  BCD2              ;
 33+  BCD2              ship_land:
 34+  BCD2 ED 4B B4 BC      ld bc,(ship_initpos)
 35+  BCD6 ED 43 B6 BC      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  BCDA 1E 00            ld e,0                      ; store a flag to track first time round
 37+  BCDC 06 09            ld b,9                      ; move down 8 pixels
 38+  BCDE              ship_land0:
 39+  BCDE C5               push bc
 40+  BCDF 7B               ld a,e
 41+  BCE0 D5               push de                     ; store de for next time round
 42+  BCE1 FE 01            cp 1                        ; check first time flag
 43+  BCE3 C2 F8 BC         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  BCE6 CD 8C BD         call ship_draw_full         ; delete old one
 45+  BCE9 CD 61 BD         call ship_change_frame      ; increment the frame
 46+  BCEC ED 4B B6 BC      ld bc,(ship_initpos2)       ; get the current coords
 47+  BCF0 81 C6 01         add c,1                     ; move down one pixels
 48+  BCF3 4F               ld c,a
 49+  BCF4 ED 43 B6 BC      ld (ship_initpos2),bc
 50+  BCF8              ship_land1:
 51+  BCF8 CD 8C BD         call ship_draw_full         ; draw the ship
 52+  BCFB CD 76 BD         call ship_draw_screen
 53+  BCFE D1               pop de
 54+  BCFF 1E 01            ld e,1
 55+  BD01 C1               pop bc
 56+  BD02 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  BD04                  ; done moving down
 58+  BD04                  ; now move across
 59+  BD04 CD C5 BB         call player_drawplayer      ; draw player
 60+  BD07 CD 8C BD         call ship_draw_full         ; delete old one
 61+  BD0A 1E 00            ld e,0                      ; store a flag to track first time round
 62+  BD0C 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  BD0E              ship_land3:
 64+  BD0E C5               push bc
 65+  BD0F 7B               ld a,e
 66+  BD10 D5               push de                     ; store de for next time round
 67+  BD11 FE 01            cp 1                        ; check first time flag
 68+  BD13 C2 28 BD         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  BD16 CD 8C BD         call ship_draw_full         ; delete old one
 70+  BD19 CD 61 BD         call ship_change_frame      ; increment the frame
 71+  BD1C ED 4B B6 BC      ld bc,(ship_initpos2)       ; get the current coords
 72+  BD20 78               ld a,b
 73+  BD21 D6 01            sub 1                       ; move back one pixels
 74+  BD23 47               ld b,a
 75+  BD24 ED 43 B6 BC      ld (ship_initpos2),bc
 76+  BD28              ship_land2:
 77+  BD28 CD 8C BD         call ship_draw_full         ; draw the ship
 78+  BD2B CD 76 BD         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  BD2E D1               pop de
 80+  BD2F 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  BD31 C1               pop bc
 82+  BD32 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  BD34 C9               ret
 84+  BD35
 85+  BD35              ;
 86+  BD35              ;   Take off the ship
 87+  BD35              ;
 88+  BD35              ship_takeoff:
 89+  BD35 1E 01            ld e,1                      ; store a flag to track first time round
 90+  BD37 06 08            ld b,8                      ; move up 8 pixels
 91+  BD39              ship_takeoff0:
 92+  BD39 C5               push bc
 93+  BD3A 7B               ld a,e
 94+  BD3B D5               push de                     ; store de for next time round
 95+  BD3C FE 01            cp 1                        ; check first time flag
 96+  BD3E C2 54 BD         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  BD41 ED 4B B6 BC      ld bc,(ship_initpos2)       ; get the current coords
 98+  BD45 CD 8C BD         call ship_draw_full         ; delete old one
 99+  BD48 CD 61 BD         call ship_change_frame      ; increment the frame
100+  BD4B ED 4B B6 BC      ld bc,(ship_initpos2)       ; get the current coords
101+  BD4F 0D               dec c                       ; move up one pixels
102+  BD50 ED 43 B6 BC      ld (ship_initpos2),bc
103+  BD54              ship_takeoff1:
104+  BD54 CD 8C BD         call ship_draw_full         ; draw the ship
105+  BD57 CD 76 BD         call ship_draw_screen
106+  BD5A D1               pop de
107+  BD5B 1E 01            ld e,1
108+  BD5D C1               pop bc
109+  BD5E 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  BD60                  ; done moving up
111+  BD60 C9               ret
112+  BD61
113+  BD61              ;
114+  BD61              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  BD61              ;
116+  BD61              ship_change_frame:
117+  BD61 F5               push af
118+  BD62 3A B8 BC         ld a,(ship_frame)
119+  BD65 FE 00            cp 0
120+  BD67 CA 6F BD         jp z,ship_change_frame0
121+  BD6A 3E 00            ld a,0                      ; flip to 0
122+  BD6C C3 71 BD         jp ship_change_frame1
123+  BD6F              ship_change_frame0:
124+  BD6F 3E 20            ld a,32                      ; flip to 32
125+  BD71              ship_change_frame1:
126+  BD71 32 B8 BC         ld (ship_frame),a            ; save the frame
127+  BD74 F1               pop af
128+  BD75 C9               ret
129+  BD76
130+  BD76              ship_draw_screen:
131+  BD76 3E 00            ld a,0
132+  BD78 CD EC A5         call buffer_marklineforupdate
133+  BD7B 3E 01            ld a,1
134+  BD7D CD EC A5         call buffer_marklineforupdate
135+  BD80 3E 02            ld a,2
136+  BD82 CD EC A5         call buffer_marklineforupdate   ; mark the first three rows for update
137+  BD85 76               halt
138+  BD86 F3               di
139+  BD87 CD AF A6         call buffer_buffertoscreen  ; copy buffer to screen
140+  BD8A FB               ei                          ; enable interupts
141+  BD8B C9               ret
142+  BD8C
143+  BD8C              ship_draw_full:
144+  BD8C 21 5A B5         ld hl,ship_sprite
145+  BD8F ED 4B B6 BC      ld bc,(ship_initpos2)         ; load bc with the start coords
146+  BD93 22 B9 BC         ld (ship_current_sprite),hl  ; put into memory
147+  BD96 ED 43 BB BC      ld (ship_current_coords),bc  ; put into memory
148+  BD9A CD B9 BD         call ship_draw
149+  BD9D 08               ex af,af'
150+  BD9E 3A B8 BC         ld a,(ship_frame)            ; get the animation frame
151+  BDA1 16 00            ld d,0
152+  BDA3 5F               ld e,a
153+  BDA4 19               add hl,de
154+  BDA5 22 B9 BC         ld (ship_current_sprite),hl  ; put into memory
155+  BDA8 08               ex af,af'
156+  BDA9 ED 4B B6 BC      ld bc,(ship_initpos2)         ; load bc with the start coords
157+  BDAD 81 C6 08         add c,8                      ; move one line down
158+  BDB0 4F               ld c,a
159+  BDB1 ED 43 BB BC      ld (ship_current_coords),bc  ; put into memory
160+  BDB5 CD B9 BD         call ship_draw
161+  BDB8 C9               ret
162+  BDB9
163+  BDB9              ;
164+  BDB9              ; Draw the ship
165+  BDB9              ; Inputs:
166+  BDB9              ; None, all in memory
167+  BDB9              ;
168+  BDB9              ship_draw:
169+  BDB9 3E 04            ld a,4                              ; 4 pieces per half
170+  BDBB              ship_draw0:
171+  BDBB F5               push af
172+  BDBC 2A B9 BC         ld hl,(ship_current_sprite)
173+  BDBF ED 4B BB BC      ld bc,(ship_current_coords)         ; load bc with the start coords
174+  BDC3 CD A4 A9         call sprites_drawsprite
175+  BDC6 2A B9 BC         ld hl,(ship_current_sprite)
176+  BDC9 ED 4B BB BC      ld bc,(ship_current_coords)         ; load bc with the start coords
177+  BDCD 11 08 00         ld de,8
178+  BDD0 19               add hl,de
179+  BDD1 80 C6 08         add b,8
180+  BDD4 47               ld b,a
181+  BDD5 22 B9 BC         ld (ship_current_sprite),hl         ; put into memory
182+  BDD8 ED 43 BB BC      ld (ship_current_coords),bc         ; put into memory
183+  BDDC F1               pop af
184+  BDDD 3D               dec a
185+  BDDE FE 00            cp 0
186+  BDE0 C2 BB BD         jp nz,ship_draw0
187+  BDE3
188+  BDE3 C9               ret
189+  BDE4
# file closed: game/ship.asm
 41   BDE4                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  BDE4              ;
  2+  BDE4              ; tank initial position: vert,horiz
  3+  BDE4              ;
  4+  BDE4              tank_initpos:
  5+  BDE4 10 D0            defb 16,208
  6+  BDE6              tank_initpos2:
  7+  BDE6 00 00            defb 0,0
  8+  BDE8              tank_frame:
  9+  BDE8 00               defb 0
 10+  BDE9              tank_anim:
 11+  BDE9 11               defb 17
 12+  BDEA
 13+  BDEA              ;
 14+  BDEA              ; The damage countdown
 15+  BDEA              ;
 16+  BDEA              tank_currentdamage:
 17+  BDEA F0               defb 240
 18+  BDEB
 19+  BDEB              ;
 20+  BDEB              ; The damage coordinate
 21+  BDEB              ;
 22+  BDEB              tank_currentdamagecoord:
 23+  BDEB 16 02            defb 22,2
 24+  BDED
 25+  BDED              ;
 26+  BDED              ; Controls when the tank shoots
 27+  BDED              ;
 28+  BDED              tank_count:
 29+  BDED 00               defb 0
 30+  BDEE
 31+  BDEE              ;
 32+  BDEE              ; Holds the block number of the current damage sprite
 33+  BDEE              ;
 34+  BDEE              tank_damageframe:
 35+  BDEE 00               defb 0
 36+  BDEF
 37+  BDEF              ;
 38+  BDEF              ; The current memory location
 39+  BDEF              ;
 40+  BDEF              tank_current_sprite:
 41+  BDEF 00 00            defb 0,0
 42+  BDF1
 43+  BDF1              tank_current_coords:
 44+  BDF1 00 00            defb 0,0
 45+  BDF3
 46+  BDF3              ;
 47+  BDF3              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  BDF3              ;
 49+  BDF3              tank_missile_displayed:
 50+  BDF3 00               defb 0
 51+  BDF4
 52+  BDF4              ;
 53+  BDF4              ; Initialise the tank
 54+  BDF4              ;
 55+  BDF4              tank_init:
 56+  BDF4 ED 4B E4 BD      ld bc,(tank_initpos)
 57+  BDF8 ED 43 E6 BD      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  BDFC 21 E8 BD         ld hl,tank_frame
 59+  BDFF 36 00            ld (hl),0
 60+  BE01 21 E9 BD         ld hl,tank_anim
 61+  BE04 36 11            ld (hl),17
 62+  BE06 21 EE BD         ld hl,tank_damageframe              ; reset tank
 63+  BE09 36 00            ld (hl),0
 64+  BE0B 21 ED BD         ld hl,tank_count
 65+  BE0E 36 00            ld (hl),0
 66+  BE10 21 EA BD         ld hl,tank_currentdamage
 67+  BE13 36 F0            ld (hl),240
 68+  BE15 21 EB BD         ld hl,tank_currentdamagecoord
 69+  BE18 36 16            ld (hl),22
 70+  BE1A 23               inc hl
 71+  BE1B 36 02            ld (hl),2
 72+  BE1D 21 F3 BD         ld hl,tank_missile_displayed
 73+  BE20 36 00            ld (hl),0
 74+  BE22
 75+  BE22 C9               ret
 76+  BE23
 77+  BE23              ;
 78+  BE23              ;   Draw and move the tank
 79+  BE23              ;   Start processing at frame 200
 80+  BE23              ;   Don't move if anim is zero
 81+  BE23              ;   Decrement frame if moved
 82+  BE23              ;
 83+  BE23              tank_process:
 84+  BE23 3A E9 BD         ld a,(tank_anim)
 85+  BE26 FE 00            cp 0
 86+  BE28 C2 2F BE         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  BE2B CD 40 BE         call tank_fire
 88+  BE2E C9               ret
 89+  BE2F              tank_process0:
 90+  BE2F CD BB BA         call game_getcurrentframe   ; get the current frame number into a
 91+  BE32 FE 4B            cp 75
 92+  BE34 D8               ret c                       ; return if the frame number is below 100
 93+  BE35 CD 54 BF         call tank_move              ; move tank if not
 94+  BE38 3A E9 BD         ld a,(tank_anim)
 95+  BE3B 3D               dec a
 96+  BE3C 32 E9 BD         ld (tank_anim),a            ; decrease the anim count
 97+  BE3F C9               ret
 98+  BE40
 99+  BE40              ;
100+  BE40              ; Fires the tank
101+  BE40              ;
102+  BE40              tank_fire:
103+  BE40 3A ED BD         ld a,(tank_count)            ; if not, don't do anything
104+  BE43 3C               inc a                        ; increment
105+  BE44 FE 19            cp 25                        ; have we reached fifty
106+  BE46 C2 4B BE         jp nz,tank_fire0
107+  BE49 3E 00            ld a,0                       ; reset if reached fifty
108+  BE4B              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  BE4B 32 ED BD         ld (tank_count),a            ; store tank count
110+  BE4E FE 00            cp 0
111+  BE50 CA 67 BE         jp z,tank_fire7              ; If this is zero, fire
112+  BE53 3A F3 BD         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  BE56 FE 00            cp 0
114+  BE58 C8               ret z                       ; don't do anything if not
115+  BE59 CD 0E BF         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  BE5C 3E 00            ld a,0                       ; reset the flag
117+  BE5E 32 F3 BD         ld (tank_missile_displayed),a
118+  BE61 3E 02            ld a,2
119+  BE63 CD EC A5         call buffer_marklineforupdate
120+  BE66 C9               ret                        ; only shoot if we're on 0
121+  BE67              tank_fire7:
122+  BE67 3A EA BD         ld a,(tank_currentdamage)    ; get the damage countdown
123+  BE6A E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
124+  BE6C C2 A2 BE         jp nz,tank_fire1            ; not, so just do a normal frame
125+  BE6F ED 4B EB BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
126+  BE73 79               ld a,c
127+  BE74 FE 0A            cp 10
128+  BE76 C2 7D BE         jp nz, tank_fire6
129+  BE79 CD 46 BF         call tank_killedbytank      ; we're through, so the player has died. Kill them.
130+  BE7C C9               ret                         ; return if we're through the mountain
131+  BE7D              tank_fire6:
132+  BE7D 3E 0F            ld a,15
133+  BE7F 32 EE BD         ld (tank_damageframe),a     ; reset the damage frame
134+  BE82 21 07 B4         ld hl,sprites               ; location of the empty block
135+  BE85 CD 1E A9         call screen_showchar        ; show this character here
136+  BE88 ED 4B EB BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
137+  BE8C 05               dec b                       ; look one above
138+  BE8D CD 60 A9         call screen_ischarempty     ; check if it is empty
139+  BE90 ED 4B EB BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
140+  BE94 FE 01            cp 1
141+  BE96 C2 D9 BE         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
142+  BE99 ED 4B EB BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
143+  BE9D 0D               dec c
144+  BE9E ED 43 EB BD      ld (tank_currentdamagecoord),bc ; store the coord
145+  BEA2              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
146+  BEA2 ED 4B EB BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  BEA6 3A EA BD         ld a,(tank_currentdamage)    ; get the damage countdown
148+  BEA9 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
149+  BEAB C2 B6 BE         jp nz, tank_fire5
150+  BEAE CD 90 A9         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
151+  BEB1 FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
152+  BEB3 C2 F7 BE         jp nz,tank_fire3            ; if it's a slope, handle this differently
153+  BEB6              tank_fire5:
154+  BEB6 3A EE BD         ld a,(tank_damageframe)
155+  BEB9 CD 38 A9         call screen_getblock        ; get the block data into hl
156+  BEBC CD 1E A9         call screen_showchar        ; show this character here
157+  BEBF 3A EE BD         ld a,(tank_damageframe)
158+  BEC2 3C               inc a
159+  BEC3 32 EE BD         ld (tank_damageframe),a     ; increment the damage block and store
160+  BEC6 3A EA BD         ld a,(tank_currentdamage)    ; get the damage countdown
161+  BEC9 3D               dec a
162+  BECA 3D               dec a
163+  BECB 32 EA BD         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
164+  BECE 3A F3 BD         ld a,(tank_missile_displayed) ; is the missile displaying?
165+  BED1 FE 00            cp 0
166+  BED3 CC 0E BF         call z, tank_missilegraphic
167+  BED6 C3 00 BF         jp tank_fire4
168+  BED9              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
169+  BED9 05               dec b
170+  BEDA C5               push bc
171+  BEDB CD 79 A9         call screen_copyblockdown       ; copy the block down
172+  BEDE ED 4B EB BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
173+  BEE2 C1               pop bc                      ; get the coord we just checked back
174+  BEE3 78               ld a,b
175+  BEE4 FE 00            cp 0
176+  BEE6 CA A2 BE         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
177+  BEE9 C5               push bc
178+  BEEA 05               dec b
179+  BEEB CD 60 A9         call screen_ischarempty     ; check if it is empty
180+  BEEE C1               pop bc
181+  BEEF FE 01            cp 1                        ; if empty
182+  BEF1 C2 D9 BE         jp nz, tank_fire2            ; copy another one down
183+  BEF4 C3 A2 BE         jp tank_fire1               ; otherwise, return to main thread
184+  BEF7              tank_fire3:                      ; dealing with slopes
185+  BEF7 3A EA BD         ld a,(tank_currentdamage)    ; get the damage countdown
186+  BEFA 06 08            ld b,8
187+  BEFC 90               sub b                        ; special case for slopes
188+  BEFD 32 EA BD         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
189+  BF00              tank_fire4:                     ; TIDY UP
190+  BF00 CD EC A5         call buffer_marklineforupdate
191+  BF03 3E 01            ld a,1
192+  BF05 CD EC A5         call buffer_marklineforupdate
193+  BF08 3E 02            ld a,2
194+  BF0A CD EC A5         call buffer_marklineforupdate
195+  BF0D C9               ret
196+  BF0E
197+  BF0E              ;
198+  BF0E              ; Displays or hides the missile graphic, and changes the gun
199+  BF0E              ;
200+  BF0E              tank_missilegraphic:
201+  BF0E 3A F3 BD         ld a,(tank_missile_displayed)
202+  BF11 FE 00            cp 0
203+  BF13 C2 1B BF         jp nz,tank_missilegraphic0
204+  BF16 3E 13            ld a,19
205+  BF18 C3 1D BF         jp tank_missilegraphic1
206+  BF1B              tank_missilegraphic0:
207+  BF1B 3E 00            ld a,0
208+  BF1D              tank_missilegraphic1:
209+  BF1D 32 F3 BD         ld (tank_missile_displayed),a ; store the flipped graphic
210+  BF20 ED 4B EB BD      ld bc,(tank_currentdamagecoord)
211+  BF24 0C               inc c
212+  BF25 0C               inc c                   ; print the graphic 2 spaces right
213+  BF26 CD 38 A9         call screen_getblock        ; get the block data into hl
214+  BF29 CD 1E A9         call screen_showchar        ; show this character here
215+  BF2C 06 02            ld b,2
216+  BF2E 0E 18            ld c,24                     ; set gunbarrel coords
217+  BF30 11 00 00         ld de,0
218+  BF33 21 BA B5         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
219+  BF36 3A F3 BD         ld a,(tank_missile_displayed)
220+  BF39 FE 00            cp 0
221+  BF3B CA 41 BF         jp z,tank_missilegraphic2
222+  BF3E 11 40 00         ld de,64
223+  BF41              tank_missilegraphic2:
224+  BF41 19               add hl,de                   ; work out missile graphic
225+  BF42 CD 1E A9         call screen_showchar        ; show this character here
226+  BF45 C9               ret
227+  BF46
228+  BF46              ;
229+  BF46              ; Deal with the player being killed by the tank
230+  BF46              ;
231+  BF46              tank_killedbytank:
232+  BF46 ED 4B EB BD      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
233+  BF4A 21 07 B4         ld hl,sprites                   ; empty sprite
234+  BF4D CD 1E A9         call screen_showchar            ; hide the last piece of dirt
235+  BF50 CD B9 BB         call player_tankkillplayer
236+  BF53 C9               ret
237+  BF54
238+  BF54              tank_move:
239+  BF54 ED 4B E6 BD      ld bc,(tank_initpos2)
240+  BF58 C5               push bc
241+  BF59 3A E9 BD         ld a,(tank_anim)
242+  BF5C FE 11            cp 17                       ; check first time flag
243+  BF5E CA 70 BF         jp z,tank_move1             ; don't draw over previous one if first time
244+  BF61 CD 75 BF         call tank_draw_full         ; delete old one
245+  BF64 ED 4B E6 BD      ld bc,(tank_initpos2)       ; get the current coords
246+  BF68 78               ld a,b
247+  BF69 D6 01            sub 1                       ; move back one pixels
248+  BF6B 47               ld b,a
249+  BF6C ED 43 E6 BD      ld (tank_initpos2),bc
250+  BF70              tank_move1:
251+  BF70 CD 75 BF         call tank_draw_full         ; draw the tank
252+  BF73 C1               pop bc
253+  BF74 C9               ret
254+  BF75
255+  BF75              tank_draw_full:
256+  BF75 21 BA B5         ld hl,tank_sprite
257+  BF78 ED 4B E6 BD      ld bc,(tank_initpos2)         ; load bc with the start coords
258+  BF7C 22 EF BD         ld (tank_current_sprite),hl  ; put into memory
259+  BF7F ED 43 F1 BD      ld (tank_current_coords),bc  ; put into memory
260+  BF83 CD AC BF         call tank_draw
261+  BF86 08               ex af,af'
262+  BF87 3A E8 BD         ld a,(tank_frame)            ; get the animation frame
263+  BF8A 16 00            ld d,0
264+  BF8C 5F               ld e,a
265+  BF8D 19               add hl,de
266+  BF8E 22 EF BD         ld (tank_current_sprite),hl  ; put into memory
267+  BF91 08               ex af,af'
268+  BF92 ED 4B E6 BD      ld bc,(tank_initpos2)         ; load bc with the start coords
269+  BF96 81 C6 08         add c,8                      ; move one line down
270+  BF99 4F               ld c,a
271+  BF9A ED 43 F1 BD      ld (tank_current_coords),bc  ; put into memory
272+  BF9E CD AC BF         call tank_draw
273+  BFA1 3E 02            ld a,2
274+  BFA3 CD EC A5         call buffer_marklineforupdate
275+  BFA6 3E 03            ld a,3
276+  BFA8 CD EC A5         call buffer_marklineforupdate   ; mark the first two rows for update
277+  BFAB C9               ret
278+  BFAC
279+  BFAC              ;
280+  BFAC              ; Draw the tank
281+  BFAC              ; Inputs:
282+  BFAC              ; None, all in memory
283+  BFAC              ;
284+  BFAC              tank_draw:
285+  BFAC 3E 04            ld a,4                              ; 4 pieces per half
286+  BFAE              tank_draw0:
287+  BFAE F5               push af
288+  BFAF 2A EF BD         ld hl,(tank_current_sprite)
289+  BFB2 ED 4B F1 BD      ld bc,(tank_current_coords)         ; load bc with the start coords
290+  BFB6 CD A4 A9         call sprites_drawsprite
291+  BFB9 2A EF BD         ld hl,(tank_current_sprite)
292+  BFBC ED 4B F1 BD      ld bc,(tank_current_coords)         ; load bc with the start coords
293+  BFC0 11 08 00         ld de,8
294+  BFC3 19               add hl,de
295+  BFC4 80 C6 08         add b,8
296+  BFC7 47               ld b,a
297+  BFC8 22 EF BD         ld (tank_current_sprite),hl         ; put into memory
298+  BFCB ED 43 F1 BD      ld (tank_current_coords),bc         ; put into memory
299+  BFCF F1               pop af
300+  BFD0 3D               dec a
301+  BFD1 FE 00            cp 0
302+  BFD3 C2 AE BF         jp nz,tank_draw0
303+  BFD6
304+  BFD6 C9               ret
305+  BFD7
# file closed: game/tank.asm
 42   BFD7                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  BFD7              ;
  2+  BFD7              ; A structure of falling rocks
  3+  BFD7              ; Assume we'll never have more than 4 falling at any one time
  4+  BFD7              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  BFD7              ;
  6+  BFD7              rocks_falling:
  7+  BFD7 00 00 00 00      defb 0,0,0,0
  8+  BFDB 00 00 00 00      defb 0,0,0,0
  9+  BFDF 00 00 00 00      defb 0,0,0,0
 10+  BFE3 00 00 00 00      defb 0,0,0,0
 11+  BFE7
 12+  BFE7              rocks_tmp:
 13+  BFE7 00               defb 0
 14+  BFE8
 15+  BFE8              rocks_tmp2:
 16+  BFE8 00 00            defb 0,0
 17+  BFEA
 18+  BFEA              ;
 19+  BFEA              ; Coords of the rock that killed us
 20+  BFEA              ;
 21+  BFEA              rocks_killerrock:
 22+  BFEA 00 00            defb 0,0
 23+  BFEC
 24+  BFEC              ;
 25+  BFEC              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 26+  BFEC              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 27+  BFEC              ; If the pixel row is not the rock bottom, stop checking.
 28+  BFEC              ; Inputs:
 29+  BFEC              ; hl- memory location
 30+  BFEC              ;
 31+  BFEC              rocks_checkforfalling:
 32+  BFEC 7E               ld a,(hl)           ; get the pixel row in this memory location
 33+  BFED FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 34+  BFEF C2 F5 BF         jp nz,rocks_checkforfalling2 ; not a rock, stop
 35+  BFF2 CD F6 BF         call rocks_addrocktofalling ; mark the rock as falling
 36+  BFF5              rocks_checkforfalling2:
 37+  BFF5 C9               ret
 38+  BFF6
 39+  BFF6              ;
 40+  BFF6              ; Adds the rock to the structure that tracks falling rocks
 41+  BFF6              ; Inputs:
 42+  BFF6              ; hl - memory location of falling rock graphic
 43+  BFF6              ; bc - coords of rock, c vert
 44+  BFF6              rocks_addrocktofalling:
 45+  BFF6 C5               push bc             ; store the coords
 46+  BFF7 11 D7 BF         ld de,rocks_falling
 47+  BFFA 06 04            ld b,4              ; number of possible falling rocks
 48+  BFFC              rocks_addrocktofalling0:
 49+  BFFC 13               inc de
 50+  BFFD                  ;inc de
 51+  BFFD 13               inc de              ; move three along to get the state
 52+  BFFE 1A               ld a,(de)           ; load the state
 53+  BFFF FE 00            cp 0                ; check if this is not falling
 54+  C001 C2 17 C0         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 55+  C004 13               inc de              ; move to frame
 56+  C005 3E 10            ld a,16             ; load the number of frames to wobble
 57+  C007 12               ld (de),a
 58+  C008 1B               dec de              ; move de back to state
 59+  C009 3E 02            ld a,2
 60+  C00B 12               ld (de),a           ; set the state to wobbling
 61+  C00C 1B               dec de              ; move back coords
 62+  C00D C1               pop bc              ; get back coords
 63+  C00E 78               ld a,b
 64+  C00F 12               ld (de),a           ; store the vertical
 65+  C010 1B               dec de
 66+  C011 79               ld a,c
 67+  C012 12               ld (de),a           ; store the horizontal
 68+  C013 C5               push bc
 69+  C014 C3 1B C0         jp rocks_addrocktofalling2 ; done
 70+  C017              rocks_addrocktofalling1:
 71+  C017 13               inc de
 72+  C018 13               inc de              ; move memory along to next rock
 73+  C019 10 E1            djnz rocks_addrocktofalling0 ; try the next rock
 74+  C01B              rocks_addrocktofalling2: ; done, return
 75+  C01B C1               pop bc              ; to tidy up
 76+  C01C C9               ret
 77+  C01D
 78+  C01D              ;
 79+  C01D              ; Processes any falling rocks
 80+  C01D              ;
 81+  C01D              rocks_processrocks:
 82+  C01D DD 21 D7 BF      ld ix,rocks_falling
 83+  C021 06 04            ld b,4              ; the number of rocks to check
 84+  C023              rocks_processrocks0:
 85+  C023 C5               push bc             ; store loop count
 86+  C024 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 86+  C028 46 01
 87+  C02A DD 23            inc ix
 88+  C02C DD 23            inc ix              ; move to the state
 89+  C02E DD 7E 00         ld a,(ix)           ; load the state into a
 90+  C031 FE 00            cp 0
 91+  C033 CA 57 C0         jp z,rocks_processrocks3 ; if not falling, check next
 92+  C036 FE 02            cp 2
 93+  C038 C2 48 C0         jp nz, rocks_processrocks2
 94+  C03B                  ; we're wobbling
 95+  C03B DD 23            inc ix              ; get frame number for wobble
 96+  C03D DD 7E 00         ld a,(ix)           ; get wobble frame into a
 97+  C040 CD 2F C1         call rocks_wobble
 98+  C043 DD 23            inc ix              ; increment for next
 99+  C045 C3 5B C0         jp rocks_processrocks1  ; do next rock
100+  C048              rocks_processrocks2:
101+  C048                  ; we're falling
102+  C048 C5               push bc
103+  C049 CD 74 C0         call rocks_fall
104+  C04C C1               pop bc
105+  C04D CD 5F C0         call rocks_storeupdatedlines
106+  C050 DD 23            inc ix
107+  C052 DD 23            inc ix              ; inc ix to get to next
108+  C054 C3 5B C0         jp rocks_processrocks1
109+  C057              rocks_processrocks3:
110+  C057 DD 23            inc ix
111+  C059 DD 23            inc ix
112+  C05B              rocks_processrocks1:
113+  C05B C1               pop bc              ; get loop count back
114+  C05C 10 C5            djnz rocks_processrocks0
115+  C05E C9               ret
116+  C05F
117+  C05F              ;
118+  C05F              ; Stores the updated rows associated with the rock
119+  C05F              ; Inputs:
120+  C05F              ; bc - coords
121+  C05F              ;
122+  C05F              rocks_storeupdatedlines:
123+  C05F 79               ld a,c                  ; get the rock block coords of current block
124+  C060 E6 F8            and 248                 ; find closest multiple of eight
125+  C062 0F               rrca
126+  C063 0F               rrca
127+  C064 0F               rrca                    ; divide by 8
128+  C065 ED 5B A2 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
129+  C069 93               sub e
130+  C06A F5               push af
131+  C06B CD EC A5         call buffer_marklineforupdate  ; store current row in updated lines
132+  C06E F1               pop af
133+  C06F 3C               inc a
134+  C070 CD EC A5         call buffer_marklineforupdate  ; store line beneath
135+  C073 C9               ret
136+  C074
137+  C074              ;
138+  C074              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
139+  C074              ; bc - coord of current rock graphic on screen
140+  C074              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
141+  C074              ;
142+  C074              rocks_fall:
143+  C074 DD 2B            dec ix
144+  C076 DD 2B            dec ix              ; decrease ix back to coords
145+  C078 ED 43 E8 BF      ld (rocks_tmp2),bc  ; store original coords
146+  C07C 3E 03            ld a,3              ; move this number of pixels
147+  C07E              rocks_fall1:
148+  C07E 32 E7 BF         ld (rocks_tmp),a    ; store loop counter
149+  C081 DD 4E 00 DD      ld bc,(ix)          ; get current coords
149+  C085 46 01
150+  C087 CD 49 AA         call sprites_scadd  ; get the memory of the coords into de
151+  C08A 14               inc d               ; add 256 to get next row
152+  C08B 1A               ld a,(de)           ; get the contents of the next row
153+  C08C FE 00            cp 0
154+  C08E C2 EE C0         jp nz,rocks_fall3    ; move the rock if the row is empty
155+  C091 0C               inc c               ; increment the vertical
156+  C092 DD 71 00 DD      ld (ix),bc          ; store the new coords
156+  C096 70 01
157+  C098 79               ld a,c              ; get the vertical coord into a
158+  C099 E6 07            and 7               ; divisible by 8?
159+  C09B FE 00            cp 0
160+  C09D C2 BA C0         jp nz,rocks_fall4   ; if not, carry on
161+  C0A0 CD F4 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
162+  C0A3 3E 42            ld a,66             ; load red
163+  C0A5 CD 43 A9         call screen_setattr
164+  C0A8 DD 4E 00 DD      ld bc,(ix)
164+  C0AC 46 01
165+  C0AE 79               ld a,c              ; get vertical
166+  C0AF D6 08            sub 8               ; look up one square
167+  C0B1 4F               ld c,a              ; put a back in c
168+  C0B2 CD F4 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
169+  C0B5 3E 46            ld a,70             ; load yellow
170+  C0B7 CD 43 A9         call screen_setattr
171+  C0BA              rocks_fall4:
172+  C0BA 3A E7 BF         ld a,(rocks_tmp)    ; get the loop counter
173+  C0BD 3D               dec a
174+  C0BE FE 00            cp 0
175+  C0C0 C2 7E C0         jp nz,rocks_fall1   ; do another pixel if needed
176+  C0C3              rocks_fall2:
177+  C0C3 3E 09            ld a,9              ; rock graphic
178+  C0C5 ED 4B E8 BF      ld bc,(rocks_tmp2)  ; get the original coords
179+  C0C9 CD 38 A9         call screen_getblock     ; get the memory into hl
180+  C0CC CD A4 A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
181+  C0CF 3E 09            ld a,9
182+  C0D1 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
182+  C0D5 46 01
183+  C0D7 CD 38 A9         call screen_getblock     ; get the memory into hl
184+  C0DA CD A4 A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
185+  C0DD DD 4E 00 DD      ld bc,(ix)          ; get the coords again
185+  C0E1 46 01
186+  C0E3 CD 14 C1         call rocks_checkforplayer ; check to see if we hit a player
187+  C0E6 DD 23            inc ix
188+  C0E8 DD 23            inc ix                  ; get ix back to state
189+  C0EA CD 04 C1         call rocks_makesound
190+  C0ED C9               ret
191+  C0EE              rocks_fall3:
192+  C0EE 3E 00            ld a,0              ; set the state to fell
193+  C0F0 DD 77 02         ld (ix+2),a           ; store the falling state
194+  C0F3 DD 4E 00 DD      ld bc,(ix)          ; get the coords
194+  C0F7 46 01
195+  C0F9 CD F4 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
196+  C0FC 3E 42            ld a,66             ; load magenta
197+  C0FE CD 43 A9         call screen_setattr
198+  C101 C3 C3 C0         jp rocks_fall2      ; rejoin main loop
199+  C104
200+  C104              ;
201+  C104              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
202+  C104              ;
203+  C104              rocks_makesound:
204+  C104 DD 7E 00         ld a,(ix)           ; get the state
205+  C107 FE 00            cp 0
206+  C109 C0               ret nz              ; if we haven't fallen, don't do anything
207+  C10A 21 D0 BA         ld hl,player+11
208+  C10D 7E               ld a,(hl)
209+  C10E FE 01            cp 1
210+  C110 C4 38 AE         call nz, sound_rockfell ; only make sound if didn't kill player
211+  C113 C9               ret
212+  C114
213+  C114              ;
214+  C114              ; Checks to see if the rock is hitting a player
215+  C114              ; Inputs:
216+  C114              ; bc - coords of rock we're checking
217+  C114              rocks_checkforplayer:
218+  C114 ED 5B C5 BA      ld de,(player)       ; get the player coords
219+  C118 7B               ld a,e               ; get the vert coord first
220+  C119 91               sub c                ; subtract the rock vertical coord from players
221+  C11A FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
222+  C11C C0               ret nz               ; if not, hasn't hit
223+  C11D 7A               ld a,d               ; get the player horiz coord
224+  C11E 90               sub b                ; subtract rock coord
225+  C11F C6 07            add 7                ; add max distance
226+  C121 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
227+  C123 DA 27 C1         jp c,rocks_checkforplayer0
228+  C126 C9               ret
229+  C127              rocks_checkforplayer0:
230+  C127 ED 43 EA BF      ld (rocks_killerrock),bc; store the coords of the killer rock
231+  C12B CD B3 BB         call player_crushplayer ; if so, jump out
232+  C12E C9               ret
233+  C12F
234+  C12F              ;
235+  C12F              ; Wobbles a rocks
236+  C12F              ; Inputs:
237+  C12F              ; bc - coord of current rock graphic on screen
238+  C12F              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
239+  C12F              ; a - wobble frame
240+  C12F              rocks_wobble:
241+  C12F DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
242+  C132 E6 01            and 1               ; is it odd or even, gets 1 or 0
243+  C134 1E 09            ld e,9              ; this is the rock frame
244+  C136 83               add a,e             ; add the frame toggle
245+  C137 C5               push bc
246+  C138 CD 38 A9         call screen_getblock     ; get the memory into hl
247+  C13B CD A4 A9         call sprites_drawsprite  ; draw the sprite - over the top of the current one
248+  C13E
249+  C13E DD 7E 00         ld a,(ix)           ; get the frame toggle again
250+  C141 3D               dec a               ; decrease
251+  C142 DD 77 00         ld (ix),a           ; store
252+  C145
253+  C145 E6 01            and 1
254+  C147 1E 09            ld e,9              ; this is the rock frame
255+  C149 83               add a,e             ; add the frame toggle
256+  C14A CD 38 A9         call screen_getblock     ; get the memory into hl
257+  C14D
258+  C14D C1               pop bc
259+  C14E CD A4 A9         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
260+  C151
261+  C151 DD 7E 00         ld a,(ix)           ; get the wobble count back
262+  C154 FE 00            cp 0
263+  C156 C0               ret nz              ; if we're not at zero, return
264+  C157 DD 2B            dec ix              ; otherwise look to state location
265+  C159 3E 01            ld a,1              ; set the state to falling
266+  C15B DD 77 00         ld (ix),a           ; store the falling state
267+  C15E DD 23            inc ix              ; set ix back to location of wobble count, and we're done
268+  C160 C9               ret
269+  C161
# file closed: game/rocks.asm
 43   C161                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  C161              ;
  2+  C161              ; The score of the current player
  3+  C161              ;
  4+  C161              scores_current:
  5+  C161 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  C165 30 30 30 30
  5+  C169 FF
  6+  C16A
  7+  C16A              scores_defaultname:
  8+  C16A 2D 2D 2D         defb '---'
  9+  C16D
 10+  C16D              ;
 11+  C16D              ; The current high score table
 12+  C16D              ;
 13+  C16D              scores_table:
 14+  C16D 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  C171 4D 30 30 30
 14+  C175 30 30 30 FF
 15+  C179 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  C17D 4D 30 30 30
 15+  C181 30 30 30 FF
 16+  C185 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  C189 4D 30 30 30
 16+  C18D 30 30 30 FF
 17+  C191
 18+  C191              ;
 19+  C191              ; Add thousands to the score
 20+  C191              ; Inputs:
 21+  C191              ; b - number to add
 22+  C191              ;
 23+  C191              scores_addthousands:
 24+  C191 21 65 C1         ld hl,scores_current+4
 25+  C194 CD BE C1         call scores_update
 26+  C197 C9               ret
 27+  C198
 28+  C198              ;
 29+  C198              ; Prints the score to screen
 30+  C198              ;
 31+  C198              scores_printscore:
 32+  C198 3A 97 BA         ld a,(game_currentplayer)   ; get current player
 33+  C19B 21 61 C1         ld hl,scores_current
 34+  C19E FE 01            cp 1
 35+  C1A0 C2 A8 C1         jp nz, score_printscore0    ; if not player 1
 36+  C1A3 36 04            ld (hl),4       ; set position for player 1
 37+  C1A5 C3 AA C1         jp score_printscore1
 38+  C1A8              score_printscore0:
 39+  C1A8 36 16            ld (hl),22       ; set position for player 2
 40+  C1AA              score_printscore1:
 41+  C1AA 21 61 C1         ld hl,scores_current
 42+  C1AD CD C4 84         call string_print
 43+  C1B0 C9               ret
 44+  C1B1
 45+  C1B1              ;
 46+  C1B1              ; Prints both scores to screen
 47+  C1B1              ;
 48+  C1B1              scores_printscores:
 49+  C1B1 21 9B BB         ld hl,player1_score
 50+  C1B4 CD C4 84         call string_print
 51+  C1B7 21 A4 BB         ld hl,player2_score
 52+  C1BA CD C4 84         call string_print
 53+  C1BD C9               ret
 54+  C1BE
 55+  C1BE              ;
 56+  C1BE              ; Updates the current score.
 57+  C1BE              ; Inputs:
 58+  C1BE              ; hl - memory location of the score column
 59+  C1BE              ; b - number to add
 60+  C1BE              ;
 61+  C1BE              scores_update:
 62+  C1BE 7E               ld a,(hl)           ; current value of digit.
 63+  C1BF 80               add a,b             ; add points to this digit.
 64+  C1C0 77               ld (hl),a           ; place new digit back in string.
 65+  C1C1 FE 3A            cp 58               ; more than ASCII value '9'?
 66+  C1C3 D8               ret c               ; no - relax.
 67+  C1C4 D6 0A            sub 10              ; subtract 10.
 68+  C1C6 77               ld (hl),a           ; put new character back in string.
 69+  C1C7              scores_update0:
 70+  C1C7 2B               dec hl              ; previous character in string.
 71+  C1C8 34               inc (hl)            ; up this by one.
 72+  C1C9 7E               ld a,(hl)           ; what's the new value?
 73+  C1CA FE 3A            cp 58               ; gone past ASCII nine?
 74+  C1CC D8               ret c               ; no, scoring done.
 75+  C1CD D6 0A            sub 10              ; down by ten.
 76+  C1CF 77               ld (hl),a           ; put it back
 77+  C1D0 C3 C7 C1         jp scores_update0   ; go round again.
 78+  C1D3
 79+  C1D3
 80+  C1D3              ;
 81+  C1D3              ; Displays the high score table at the bottom of the screen
 82+  C1D3              ;
 83+  C1D3              scores_showtable:
 84+  C1D3 21 6D C1         ld hl, scores_table
 85+  C1D6 CD C4 84         call string_print
 86+  C1D9 21 79 C1         ld hl, scores_table+12
 87+  C1DC CD C4 84         call string_print
 88+  C1DF 21 85 C1         ld hl, scores_table+24
 89+  C1E2 CD C4 84         call string_print
 90+  C1E5 C9               ret
 91+  C1E6
 92+  C1E6              ;
 93+  C1E6              ; Place to store the current position we're checking
 94+  C1E6              ;
 95+  C1E6              scores_highscoretmp:
 96+  C1E6 00               defb 0
 97+  C1E7
 98+  C1E7              ;
 99+  C1E7              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
100+  C1E7              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
101+  C1E7              ;
102+  C1E7              scores_processhighscores:
103+  C1E7 21 E6 C1         ld hl,scores_highscoretmp
104+  C1EA 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
105+  C1EC 3E 1D            ld a,29
106+  C1EE              scores_processhighscores3:
107+  C1EE 21 6D C1         ld hl,scores_table          ; position of first score column
108+  C1F1 5F               ld e,a
109+  C1F2 16 00            ld d,0
110+  C1F4 19               add hl,de
111+  C1F5 08               ex af,af'                   ; store a for later
112+  C1F6 11 63 C1         ld de,scores_current+2      ; position of current score column
113+  C1F9 06 06            ld b,6                      ; times to loop
114+  C1FB              scores_processhighscores0:
115+  C1FB 7E               ld a,(hl)
116+  C1FC 4F               ld c,a                      ; get first score column
117+  C1FD 1A               ld a,(de)                   ; get first current column
118+  C1FE B9               cp c                        ; compare current with first
119+  C1FF DA 10 C2         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
120+  C202 23               inc hl
121+  C203 13               inc de                      ; move to next column
122+  C204 10 F5            djnz scores_processhighscores0 ; loop
123+  C206 08               ex af,af'                     ; still here, so must be bigger
124+  C207 32 E6 C1         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
125+  C20A 0E 0C            ld c,12
126+  C20C 91               sub c
127+  C20D D2 EE C1         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
128+  C210              scores_processhighscores4
129+  C210 CD 14 C2         call scores_updatehighscores
130+  C213 C9               ret
131+  C214
132+  C214              ;
133+  C214              ; Update score table
134+  C214              ;
135+  C214              scores_updatehighscores:
136+  C214 3A E6 C1         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
137+  C217 FE 00            cp 0
138+  C219 C8               ret z                       ; if this is 0, didn't get a high score
139+  C21A FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
140+  C21C CA 4F C2         jp z, scores_updatehighscores3
141+  C21F                                              ; copy old score over one below, if not first
142+  C21F 21 6D C1         ld hl,scores_table
143+  C222 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
144+  C225 19               add hl,de                   ; position of first column
145+  C226 2B               dec hl
146+  C227 2B               dec hl
147+  C228 2B               dec hl
148+  C229 E5               push hl
149+  C22A 11 0C 00         ld de,12
150+  C22D 19               add hl,de                   ; get position of next score
151+  C22E 54 5D            ld de,hl
152+  C230 E1               pop hl                      ; get hl back
153+  C231 01 09 00         ld bc,9
154+  C234 ED B0            ldir
155+  C236 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
156+  C238 CA 4F C2         jp z,scores_updatehighscores3
157+  C23B 21 6D C1         ld hl,scores_table
158+  C23E 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
159+  C241 19               add hl,de                   ; position of first column
160+  C242 E5               push hl
161+  C243 11 0C 00         ld de,12
162+  C246 19               add hl,de                   ; get position of next score
163+  C247 54 5D            ld de,hl
164+  C249 E1               pop hl                      ; get hl back
165+  C24A 01 09 00         ld bc,9
166+  C24D ED B0            ldir
167+  C24F              scores_updatehighscores3:
168+  C24F 06 06            ld b,6                      ; now overwrite
169+  C251 21 6D C1         ld hl,scores_table
170+  C254 16 00            ld d,0
171+  C256 5F               ld e,a
172+  C257 19               add hl,de                   ; position of first column
173+  C258 08               ex af,af'
174+  C259 11 63 C1         ld de,scores_current+2      ; position of current score column
175+  C25C              scores_updatehighscores2:
176+  C25C 1A               ld a,(de)
177+  C25D 77               ld (hl),a
178+  C25E 23               inc hl
179+  C25F 13               inc de
180+  C260 10 FA            djnz scores_updatehighscores2
181+  C262 11 09 00         ld de,9
182+  C265 ED 52            sbc hl,de
183+  C267 54 5D            ld de,hl                    ; get back to start of entry
184+  C269 21 6A C1         ld hl,scores_defaultname    ; still need to overwrite the name
185+  C26C 01 03 00         ld bc,3                      ; 3 chars to copy
186+  C26F ED B0            ldir
187+  C271 C9               ret
# file closed: game/scores.asm
 44   C272                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  C272              diamonds_tmp:
  2+  C272 00               defb 0
  3+  C273
  4+  C273              diamonds_tmp2:
  5+  C273 00               defb 0
  6+  C274
  7+  C274              ;
  8+  C274              ; Holds the number of thousands for the current gem type
  9+  C274              ;
 10+  C274              diamonds_score:
 11+  C274 00               defb 0
 12+  C275
 13+  C275              ;
 14+  C275              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  C275              ; Inputs:
 16+  C275              ; hl - memory location of gem type
 17+  C275              diamonds_twinkle_type:
 18+  C275 CD BB BA         call game_getcurrentframe       ; get current frame number
 19+  C278 E6 07            and 7                           ; want a number from 0-7
 20+  C27A C6 40            add 64                          ; add to 60 to get attr colour
 21+  C27C 32 73 C2         ld (diamonds_tmp2),a             ; store the colour
 22+  C27F              diamonds_twinkle_type0:
 23+  C27F 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  C283 79               ld a,c                          ; load c into a
 25+  C284 FE FF            cp 255                          ; is this the end?
 26+  C286 CA AE C2         jp z,diamonds_twinkle_type1           ; step out if so
 27+  C289 23               inc hl
 28+  C28A 23               inc hl
 29+  C28B 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  C28C FE 01            cp 1
 31+  C28E CA AF C2         jp z,diamonds_twinkle_type2           ; step out if so
 32+  C291 CD EF C2         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  C294 DC B6 C2         call c,diamonds_collect     ; we collided
 34+  C297 23               inc hl
 35+  C298 E5               push hl
 36+  C299 E5 DD E1         ld ix,hl
 37+  C29C DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  C2A0 46 FE
 38+  C2A2 3A 73 C2         ld a,(diamonds_tmp2)
 39+  C2A5 CD 43 A9         call screen_setattr
 40+  C2A8 E1               pop hl
 41+  C2A9 23               inc hl
 42+  C2AA 23               inc hl                          ; move to next diamond
 43+  C2AB C3 7F C2         jp diamonds_twinkle_type0
 44+  C2AE              diamonds_twinkle_type1:
 45+  C2AE C9               ret
 46+  C2AF              diamonds_twinkle_type2:
 47+  C2AF 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  C2B0 23               inc hl
 49+  C2B1 23               inc hl
 50+  C2B2 08               ex af,af'
 51+  C2B3 C3 7F C2         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  C2B6
 53+  C2B6              ;
 54+  C2B6              ; Collect the diamond we collided with
 55+  C2B6              ; Inputs:
 56+  C2B6              ; hl - memory location of current diamond, currently on state
 57+  C2B6              ; Output:
 58+  C2B6              ; a - 70 - for yellow on black
 59+  C2B6              diamonds_collect:
 60+  C2B6 36 01            ld (hl),1                       ; collected
 61+  C2B8 E5               push hl
 62+  C2B9 2B               dec hl
 63+  C2BA 2B               dec hl
 64+  C2BB 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  C2BF CD 04 A9         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  C2C2 ED 5B 72 C2      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  C2C6 16 00            ld d,0
 68+  C2C8 21 07 B4         ld hl,sprites
 69+  C2CB 19               add hl,de
 70+  C2CC CD A4 A9         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  C2CF E1               pop hl
 72+  C2D0 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  C2D2 32 73 C2         ld (diamonds_tmp2),a
 74+  C2D5 D9               exx
 75+  C2D6 3A 74 C2         ld a,(diamonds_score)
 76+  C2D9 47               ld b,a
 77+  C2DA CD 91 C1         call scores_addthousands
 78+  C2DD 3A 72 C2         ld a,(diamonds_tmp)
 79+  C2E0 FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  C2E2 C2 EA C2         jp nz,diamonds_collect0
 81+  C2E5 21 D2 BA         ld hl,player+13
 82+  C2E8 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  C2EA              diamonds_collect0:
 84+  C2EA CD 1B AE         call sound_gemcollected
 85+  C2ED D9               exx
 86+  C2EE C9               ret
 87+  C2EF
 88+  C2EF              ;
 89+  C2EF              ; Checks to see if the gem is hitting a player
 90+  C2EF              ; Inputs:
 91+  C2EF              ; bc - coords of diamond we're checking
 92+  C2EF              diamonds_checkforplayer:
 93+  C2EF 78               ld a,b               ; multiply b by 8
 94+  C2F0 07               rlca
 95+  C2F1 07               rlca
 96+  C2F2 07               rlca
 97+  C2F3 47               ld b,a
 98+  C2F4 ED 5B C5 BA      ld de,(player)       ; get the player coords
 99+  C2F8 7B               ld a,e               ; get the vert coord first
100+  C2F9 90               sub b                ; subtract the diamond vertical coord from players
101+  C2FA C6 04            add 4                ; add the max distance
102+  C2FC FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  C2FE D0               ret nc               ; if not, hasn't hit
104+  C2FF 79               ld a,c               ; multiply c by 8
105+  C300 07               rlca
106+  C301 07               rlca
107+  C302 07               rlca
108+  C303 4F               ld c,a
109+  C304 7A               ld a,d               ; get the player horiz coord
110+  C305 91               sub c                ; subtract rock coord
111+  C306 C6 04            add 4                ; add max distance
112+  C308 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  C30A D0               ret nc
114+  C30B 3E 00            ld a,0
115+  C30D C9               ret
116+  C30E
117+  C30E
118+  C30E              ;
119+  C30E              ; Initialise diamonds and gems
120+  C30E              ;
121+  C30E              diamonds_twinkle
122+  C30E 21 74 C2         ld hl,diamonds_score
123+  C311 36 02            ld (hl),2         ; store the score we'll add
124+  C313 21 72 C2         ld hl,diamonds_tmp
125+  C316 36 40            ld (hl),64         ; store the location the diamond sprite
126+  C318 21 82 B3         ld hl, level01diamonds
127+  C31B CD 75 C2         call diamonds_twinkle_type
128+  C31E 21 74 C2         ld hl,diamonds_score
129+  C321 36 01            ld (hl),1         ; store the score we'll add
130+  C323 21 72 C2         ld hl,diamonds_tmp
131+  C326 36 70            ld (hl),112         ; store the location the gem sprite
132+  C328 21 92 B3         ld hl, level01gems
133+  C32B CD 75 C2         call diamonds_twinkle_type
134+  C32E C9               ret
135+  C32F
136+  C32F              ;
137+  C32F              ; Initialise diamonds and gems
138+  C32F              ;
139+  C32F              diamonds_init:
140+  C32F 21 82 B3         ld hl, level01diamonds
141+  C332 CD 3C C3         call diamonds_init_type
142+  C335 21 92 B3         ld hl, level01gems
143+  C338 CD 3C C3         call diamonds_init_type
144+  C33B C9               ret
145+  C33C
146+  C33C              ;
147+  C33C              ; Initialise diamonds or gems, get memory addresses
148+  C33C              ; Inputs:
149+  C33C              ; hl - memory location
150+  C33C              diamonds_init_type:
151+  C33C 4E               ld c,(hl)                      ; get coords into c
152+  C33D 79               ld a,c                          ; load c into add
153+  C33E FE FF            cp 255                          ; is this the end?
154+  C340 CA 57 C3         jp z,diamonds_init_type1             ; step out if so
155+  C343 23               inc hl
156+  C344 46               ld b,(hl)                       ; get coords into b
157+  C345 E5               push hl
158+  C346 CD B5 A8         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  C349 E1               pop hl
160+  C34A 23               inc hl                          ; move to state
161+  C34B 36 00            ld (hl),0
162+  C34D 23               inc hl                          ; move to memory
163+  C34E 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  C352 23               inc hl                          ; move to next diamond
165+  C353 23               inc hl
166+  C354 C3 3C C3         jp diamonds_init_type
167+  C357              diamonds_init_type1:
168+  C357 C9               ret
# file closed: game/diamonds.asm
 45   C358                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  C358              ;
  2+  C358              ; Controls when missiles fall
  3+  C358              ;
  4+  C358              missiles_count:
  5+  C358 00               defb 0
  6+  C359
  7+  C359              ;
  8+  C359              ; A structure of falling missiles
  9+  C359              ; Assume we'll never have more than 4 falling at any one time
 10+  C359              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  C359              ;
 12+  C359              missiles_falling:
 13+  C359 00 00 00         defb 0,0,0
 14+  C35C 00 00 00         defb 0,0,0
 15+  C35F 00 00 00         defb 0,0,0
 16+  C362 00 00 00         defb 0,0,0
 17+  C365
 18+  C365              ;
 19+  C365              ; The coords of the missile that killed us
 20+  C365              ;
 21+  C365              missiles_killermissile:
 22+  C365 00 00            defb 0,0
 23+  C367
 24+  C367              ;
 25+  C367              ; Zeroes the state of each missile
 26+  C367              ;
 27+  C367              missiles_init:
 28+  C367 06 0C            ld b,12
 29+  C369 DD 21 09 B3      ld ix,level01missiles
 30+  C36D              missiles_init0:
 31+  C36D DD 36 02 00      ld (ix+2),0               ; set the state to zero
 32+  C371 11 05 00         ld de,5
 33+  C374 DD 19            add ix,de
 34+  C376 DD 36 02 00      ld (ix+2),0
 35+  C37A DD 19            add ix,de
 36+  C37C 10 EF            djnz missiles_init0
 37+  C37E 06 04            ld b,4                  ; reset four falling missiles
 38+  C380 21 59 C3         ld hl,missiles_falling
 39+  C383              missiles_init1:
 40+  C383 36 00            ld (hl),0
 41+  C385 23               inc hl
 42+  C386 36 00            ld (hl),0
 43+  C388 23               inc hl
 44+  C389 36 00            ld (hl),0
 45+  C38B 23               inc hl
 46+  C38C 10 F5            djnz missiles_init1
 47+  C38E C9               ret
 48+  C38F
 49+  C38F              ;
 50+  C38F              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 51+  C38F              ; Processes any already falling missiles
 52+  C38F              ;
 53+  C38F              missiles_process:
 54+  C38F 3A D0 BA         ld a,(player+11)                        ; check if the player was hit by a missile previously
 55+  C392 FE 03            cp 3
 56+  C394 C2 9B C3         jp nz,missiles_process3                 ; if not, continue
 57+  C397 CD FD C4         call missiles_zonkplayer
 58+  C39A C9               ret
 59+  C39B              missiles_process3:
 60+  C39B 3A D3 BA         ld a,(player_location)
 61+  C39E FE 01            cp 1
 62+  C3A0 C2 13 C4         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 63+  C3A3 21 D2 BA         ld hl,player+13
 64+  C3A6 7E               ld a,(hl)                               ; check if player has collected a diamond
 65+  C3A7 FE 01            cp 1
 66+  C3A9 C2 13 C4         jp nz, missiles_process0                ; don't activate if not
 67+  C3AC 21 58 C3         ld hl,missiles_count
 68+  C3AF 7E               ld a,(hl)                   ; get the missiles count
 69+  C3B0 3C               inc a
 70+  C3B1 FE 32            cp 50                                   ; have we reached the count yet
 71+  C3B3 CA BA C3         jp z,missiles_process2                 ; if not, don't activate a new one
 72+  C3B6 77               ld (hl),a                               ; store the updated count, and continue without activating
 73+  C3B7 C3 13 C4         jp missiles_process0
 74+  C3BA              missiles_process2:
 75+  C3BA 36 00            ld (hl),0                               ; zero the counter
 76+  C3BC 1E 0C            ld e,12
 77+  C3BE CD D6 80         call utilities_randomupper              ; get random number from 0 to 11
 78+  C3C1 11 0A 00         ld de,10
 79+  C3C4 CD 3A 80         call utilities_multiply                 ; multiple random number by 10
 80+  C3C7 54 5D            ld de,hl                                ; this is the offset for the random missile
 81+  C3C9 DD 21 09 B3      ld ix,level01missiles                   ; load the location of the missile definitions
 82+  C3CD DD 19            add ix,de                               ; get to location of missile
 83+  C3CF DD 7E 02         ld a,(ix+2)
 84+  C3D2 FE 00            cp 0
 85+  C3D4 CA E4 C3         jp z,missiles_process1                  ; if this missile isn't active, activate it
 86+  C3D7 11 05 00         ld de,5                                 ; otherwise, check the missile above
 87+  C3DA DD 19            add ix,de
 88+  C3DC DD 7E 02         ld a,(ix+2)
 89+  C3DF FE 00            cp 0
 90+  C3E1 C2 13 C4         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 91+  C3E4              missiles_process1:                          ; activate a missile
 92+  C3E4 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
 93+  C3E8 DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
 93+  C3EC 46 01
 94+  C3EE 78               ld a,b
 95+  C3EF ED 5B A2 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
 96+  C3F3 93               sub e
 97+  C3F4 C5               push bc
 98+  C3F5 CD EC A5         call buffer_marklineforupdate
 99+  C3F8 C1               pop bc
100+  C3F9 CD 04 A9         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
101+  C3FC C5               push bc
102+  C3FD 3E 0C            ld a,12                                 ; inactive missile sprite
103+  C3FF CD 38 A9         call screen_getblock
104+  C402 CD A4 A9         call sprites_drawsprite                 ; draw the sprite over the old one
105+  C405 C1               pop bc
106+  C406 C5               push bc
107+  C407 3E 14            ld a,20                                 ; active missile sprite
108+  C409 CD 38 A9         call screen_getblock
109+  C40C CD A4 A9         call sprites_drawsprite                 ; draw the sprite over the old one
110+  C40F C1               pop bc
111+  C410 CD C1 C4         call missiles_addmissiletofalling
112+  C413              missiles_process0:
113+  C413 CD 17 C4         call missiles_fall
114+  C416 C9               ret
115+  C417
116+  C417              ;
117+  C417              ; Processes falling missiles
118+  C417              ;
119+  C417              missiles_fall:
120+  C417 06 04            ld b,4              ; number of possible falling missiles
121+  C419 DD 21 59 C3      ld ix,missiles_falling
122+  C41D              missiles_fall0:
123+  C41D C5               push bc
124+  C41E DD 7E 02         ld a,(ix+2)
125+  C421 FE 00            cp 0
126+  C423 CA 8B C4         jp z,missiles_fall1 ; not falling move to next
127+  C426 FE 01            cp 1                ; is this ready to fall
128+  C428 CA 2E C4         jp z, missiles_fall3
129+  C42B C3 A5 C4         jp missiles_fall4   ; if not, decrease the countdown
130+  C42E              missiles_fall3:
131+  C42E DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
131+  C432 46 01
132+  C434 CD 49 AA         call sprites_scadd  ; get the memory of the coords into de
133+  C437 14               inc d               ; add 256 to get next row
134+  C438 1A               ld a,(de)           ; get the contents of the next row
135+  C439 FE 00            cp 0
136+  C43B C2 9E C4         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
137+  C43E 3E 14            ld a,20                                 ; active missile sprite
138+  C440 CD 38 A9         call screen_getblock
139+  C443 CD A4 A9         call sprites_drawsprite                 ; draw the sprite over the old one
140+  C446 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
140+  C44A 46 01
141+  C44C CD AC C4         call missiles_storeupdatedlines
142+  C44F DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
142+  C453 46 01
143+  C455 0C               inc c               ; move down one pixel
144+  C456 DD 71 00 DD      ld (ix),bc          ; store the new coords
144+  C45A 70 01
145+  C45C 3E 14            ld a,20                                 ; active missile sprite
146+  C45E CD 38 A9         call screen_getblock
147+  C461 CD A4 A9         call sprites_drawsprite                 ; draw the sprite
148+  C464 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
148+  C468 46 01
149+  C46A 79               ld a,c              ; get the vertical coord into a
150+  C46B E6 07            and 7               ; divisible by 8?
151+  C46D FE 00            cp 0
152+  C46F C2 8B C4         jp nz,missiles_fall1   ; if not, carry on
153+  C472 CD F4 A8         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
154+  C475 3E 43            ld a,67             ; load magenta
155+  C477 CD 43 A9         call screen_setattr
156+  C47A DD 4E 00 DD      ld bc,(ix)
156+  C47E 46 01
157+  C480 79               ld a,c              ; get vertical
158+  C481 D6 08            sub 8               ; look up one square
159+  C483 4F               ld c,a              ; put a back in c
160+  C484 CD E1 A8         call screen_getattraddressfromscreencoords ; get the attr address into de
161+  C487 62 6B            ld hl,de
162+  C489 36 46            ld (hl),70          ; load this square with the yellow colour
163+  C48B              missiles_fall1:         ; hl at state
164+  C48B DD 4E 00 DD      ld bc,(ix)          ; get coords back
164+  C48F 46 01
165+  C491 CD E2 C4         call missiles_checkforplayer ; check for player
166+  C494 DD 23            inc ix
167+  C496 DD 23            inc ix
168+  C498 DD 23            inc ix              ; get to next missile
169+  C49A C1               pop bc
170+  C49B 10 80            djnz missiles_fall0
171+  C49D C9               ret
172+  C49E              missiles_fall2:
173+  C49E DD 36 02 00      ld (ix+2),0
174+  C4A2 C3 8B C4         jp missiles_fall1   ; rejoin the loop
175+  C4A5              missiles_fall4:
176+  C4A5 3D               dec a               ; decrease the countdown
177+  C4A6 DD 77 02         ld (ix+2),a         ; store back
178+  C4A9 C3 8B C4         jp missiles_fall1   ; do next missile
179+  C4AC
180+  C4AC              ;
181+  C4AC              ; Stores the updated rows associated with the missiles
182+  C4AC              ; Inputs:
183+  C4AC              ; bc - coords
184+  C4AC              ;
185+  C4AC              missiles_storeupdatedlines:
186+  C4AC 79               ld a,c                  ; get the missile block coords of current block
187+  C4AD E6 F8            and 248                 ; find closest multiple of eight
188+  C4AF 0F               rrca
189+  C4B0 0F               rrca
190+  C4B1 0F               rrca                    ; divide by 8
191+  C4B2 ED 5B A2 A7      ld de,(screen_offset)          ; load the screen offset, this is in rows
192+  C4B6 93               sub e
193+  C4B7 F5               push af
194+  C4B8 CD EC A5         call buffer_marklineforupdate  ; store current row in updated lines
195+  C4BB F1               pop af
196+  C4BC 3C               inc a
197+  C4BD CD EC A5         call buffer_marklineforupdate  ; store line beneath
198+  C4C0 C9               ret
199+  C4C1
200+  C4C1              ;
201+  C4C1              ; Adds the missile to the structure that tracks falling missile
202+  C4C1              ; Inputs:
203+  C4C1              ; bc - coords of missile, c vert
204+  C4C1              missiles_addmissiletofalling:
205+  C4C1 C5               push bc             ; store the coords
206+  C4C2 11 59 C3         ld de,missiles_falling
207+  C4C5 06 04            ld b,4              ; number of possible falling missiles
208+  C4C7              missiles_addmissiletofalling0:
209+  C4C7 13               inc de
210+  C4C8 13               inc de              ; move three along to get the state
211+  C4C9 1A               ld a,(de)           ; load the state
212+  C4CA FE 00            cp 0                ; check if this is not falling
213+  C4CC C2 DD C4         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
214+  C4CF 3E 19            ld a,25
215+  C4D1 12               ld (de),a           ; set the state to pre-falling
216+  C4D2 1B               dec de              ; move back coords
217+  C4D3 C1               pop bc              ; get back coords
218+  C4D4 78               ld a,b
219+  C4D5 12               ld (de),a           ; store the vertical
220+  C4D6 1B               dec de
221+  C4D7 79               ld a,c
222+  C4D8 12               ld (de),a           ; store the horizontal
223+  C4D9 C5               push bc
224+  C4DA C3 E0 C4         jp missiles_addmissiletofalling2 ; done
225+  C4DD              missiles_addmissiletofalling1:
226+  C4DD 13               inc de              ; move memory along to next rock
227+  C4DE 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
228+  C4E0              missiles_addmissiletofalling2: ; done, return
229+  C4E0 C1               pop bc              ; to tidy up
230+  C4E1 C9               ret
231+  C4E2
232+  C4E2              ;
233+  C4E2              ; Checks to see if the missile is hitting a player
234+  C4E2              ; Inputs:
235+  C4E2              ; bc - coords of missile we're checking
236+  C4E2              missiles_checkforplayer:
237+  C4E2 ED 5B C5 BA      ld de,(player)       ; get the player coords
238+  C4E6 7B               ld a,e               ; get the vert coord first
239+  C4E7 91               sub c                ; subtract the missile vertical coord from players
240+  C4E8 FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
241+  C4EA C0               ret nz               ; if not, hasn't hit
242+  C4EB 7A               ld a,d               ; get the player horiz coord
243+  C4EC 90               sub b                ; subtract missile coord
244+  C4ED C6 07            add 7                ; add max distance
245+  C4EF FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
246+  C4F1 DA F5 C4         jp c,missiles_checkforplayer0
247+  C4F4 C9               ret
248+  C4F5              missiles_checkforplayer0:
249+  C4F5 ED 43 65 C3      ld (missiles_killermissile),bc; store the coords of the killer missile
250+  C4F9 CD BF BB         call player_zonkplayer ; if so, jump out
251+  C4FC C9               ret
252+  C4FD
253+  C4FD              ;
254+  C4FD              ; Player has been hit, so draw text over them and mark as dead
255+  C4FD              ;
256+  C4FD              missiles_zonkplayer:
257+  C4FD CD AD BB         call player_killplayer      ; mark as dead
258+  C500 ED 4B C5 BA      ld bc,(player)              ; get player coords
259+  C504 CD F4 A8         call screen_getcharcoordsfromscreencoords ; get char coords
260+  C507 0D               dec c
261+  C508 0D               dec c
262+  C509 C5               push bc
263+  C50A CD 9D A8         call screen_getcellattradress ; attrs here
264+  C50D 06 05            ld b,5
265+  C50F 3E 42            ld a,66
266+  C511 CD 57 A8         call screen_setcolours
267+  C514 CD AF A6         call buffer_buffertoscreen  ; copy buffer to screen
268+  C517 C1               pop bc
269+  C518 ED 5B A2 A7      ld de,(screen_offset)
270+  C51C 78               ld a,b
271+  C51D 93               sub e
272+  C51E 47               ld b,a                      ; subtract the offset
273+  C51F 04               inc b
274+  C520 04               inc b                       ; add two for the score rows
275+  C521 ED 43 BC 84      ld (string_zonk),bc         ; set coords of string
276+  C525 21 BC 84         ld hl,string_zonk
277+  C528 CD C4 84         call string_print
278+  C52B 06 14            ld b,20
279+  C52D CD 82 80         call utilities_pauseforframes ; pause
280+  C530 C9               ret
281+  C531
# file closed: game/missiles.asm
 46   C531                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  C531              ;
  2+  C531              ; Timer for deciding how fast the trap withdraws
  3+  C531              ;
  4+  C531              thepit_timer:
  5+  C531 00               defb 0
  6+  C532
  7+  C532              ;
  8+  C532              ; Ticks for the trap state. Will count to 3 then reset
  9+  C532              ;
 10+  C532              thepit_trapcount:
 11+  C532 00               defb 0
 12+  C533
 13+  C533              ;
 14+  C533              ; The horizontal coordinate of the current pit trap
 15+  C533              ;
 16+  C533              thepit_trapcoord:
 17+  C533 08               defb 8
 18+  C534
 19+  C534              ;
 20+  C534              ; Initialises the pit
 21+  C534              ;
 22+  C534              thepit_init:
 23+  C534 21 33 C5         ld hl,thepit_trapcoord
 24+  C537 36 08            ld (hl),8
 25+  C539 21 32 C5         ld hl,thepit_trapcount
 26+  C53C 36 00            ld (hl),0
 27+  C53E C9               ret
 28+  C53F
 29+  C53F              ;
 30+  C53F              ; Performs per frame processing on the pit room
 31+  C53F              ;
 32+  C53F              thepit_process:
 33+  C53F 3A D3 BA         ld a,(player_location)
 34+  C542 FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 35+  C544 C2 88 C5         jp nz,thepit_process0
 36+  C547 3A 31 C5         ld a,(thepit_timer)             ; get the timer
 37+  C54A 3C               inc a
 38+  C54B 32 31 C5         ld (thepit_timer),a             ; store
 39+  C54E FE 02            cp 2                           ; have we reached the trigger?
 40+  C550 C2 88 C5         jp nz, thepit_process0          ; no need to do anything
 41+  C553 3E 00            ld a,0
 42+  C555 32 31 C5         ld (thepit_timer),a             ; zero the timer and process
 43+  C558 3A 32 C5         ld a,(thepit_trapcount)         ; get the current count
 44+  C55B 3C               inc a
 45+  C55C 32 32 C5         ld (thepit_trapcount),a         ; reset the trap count
 46+  C55F FE 04            cp 4                            ; do we need to begin another character?
 47+  C561 C2 70 C5         jp nz,thepit_process1           ; if not, draw as normal
 48+  C564 3E 00            ld a,0
 49+  C566 32 32 C5         ld (thepit_trapcount),a         ; reset the trap count
 50+  C569 3A 33 C5         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 51+  C56C 3D               dec a
 52+  C56D 32 33 C5         ld (thepit_trapcoord),a         ; store the reduced coord
 53+  C570
 54+  C570              thepit_process1:                    ; draw the trapdoor in current position
 55+  C570 3A 33 C5         ld a,(thepit_trapcoord)
 56+  C573 FE 02            cp 2
 57+  C575 CA 88 C5         jp z, thepit_process0           ; don't process outside of the pit
 58+  C578 4F               ld c,a
 59+  C579 06 0A            ld b,10                         ; vertical coord will always be the same
 60+  C57B 3A 32 C5         ld a,(thepit_trapcount)         ; get the trap count
 61+  C57E 5F               ld e,a                          ; store in e
 62+  C57F 3E 16            ld a,22                         ; 21 is full trapdoor
 63+  C581 83               add a,e
 64+  C582 CD 38 A9         call screen_getblock
 65+  C585 CD 1E A9         call screen_showchar            ; show the char
 66+  C588
 67+  C588              thepit_process0:
 68+  C588 C9               ret
 69+  C589
# file closed: game/thepit.asm
 47   C589                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  C589
  2+  C589              ;
  3+  C589              ; Where the monster currently is
  4+  C589              ;
  5+  C589              monster_currentcoords:
  6+  C589 00 00            defb 0,0
  7+  C58B
  8+  C58B              ;
  9+  C58B              ; The start coords of the monster
 10+  C58B              ;
 11+  C58B              monster_initcoords:
 12+  C58B 70 20            defb 112,32
 13+  C58D
 14+  C58D              ;
 15+  C58D              ; Store the memory location of the current jump position
 16+  C58D              ;
 17+  C58D              monster_jumppos:
 18+  C58D 00 00            defb 0,0
 19+  C58F
 20+  C58F              ;
 21+  C58F              ; The jump table for the monster.
 22+  C58F              ;
 23+  C58F              monster_jumptable:
 24+  C58F FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  C593 02 02 02 02
 24+  C597 02 02 01 01
 24+  C59B 01 01 01 01
 24+  C59F FF
 25+  C5A0
 26+  C5A0              ;
 27+  C5A0              ; The vertical direction: 0 up, 1 down
 28+  C5A0              ;
 29+  C5A0              monster_jumpdirectionvert:
 30+  C5A0 00               defb 0
 31+  C5A1
 32+  C5A1
 33+  C5A1              ;
 34+  C5A1              ; Initialises the pit monster
 35+  C5A1              ;
 36+  C5A1              monster_init:
 37+  C5A1 ED 4B 8B C5      ld bc,(monster_initcoords)              ; load the initial coords
 38+  C5A5 ED 43 89 C5      ld (monster_currentcoords),bc           ; save in current coords
 39+  C5A9 21 90 C5         ld hl,monster_jumptable+1
 40+  C5AC 22 8D C5         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 41+  C5AF 3E 00            ld a,0
 42+  C5B1 32 A0 C5         ld (monster_jumpdirectionvert),a        ; going up
 43+  C5B4 CD F1 C5         call monster_draw                       ; the monster
 44+  C5B7 C9               ret
 45+  C5B8
 46+  C5B8              ;
 47+  C5B8              ; Animate the monster
 48+  C5B8              ;
 49+  C5B8              monster_process:
 50+  C5B8 CD F1 C5         call monster_draw                       ; overwrite the old sprite
 51+  C5BB ED 4B 89 C5      ld bc,(monster_currentcoords)           ; get the current coords
 52+  C5BF 2A 8D C5         ld hl,(monster_jumppos)                 ; get the position in the jump table
 53+  C5C2 56               ld d,(hl)                               ; get the jump modifier
 54+  C5C3 3A A0 C5         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 55+  C5C6 FE 00            cp 0                                    ; if 0, going up, so dec vert
 56+  C5C8 C2 D1 C5         jp nz,monster_process0
 57+  C5CB 79               ld a,c
 58+  C5CC 92               sub d
 59+  C5CD 23               inc hl                                  ; move forward a jump pos
 60+  C5CE C3 D4 C5         jp monster_process1
 61+  C5D1              monster_process0:
 62+  C5D1 79               ld a,c                                   ; going down so inc c
 63+  C5D2 82               add a,d
 64+  C5D3 2B               dec hl                                  ; move back a jump pos
 65+  C5D4              monster_process1:
 66+  C5D4 4F               ld c,a                                  ; get the vertical coord back
 67+  C5D5 ED 43 89 C5      ld (monster_currentcoords),bc           ; store the new vertical coords
 68+  C5D9 7E               ld a,(hl)                               ; check the next jump pos
 69+  C5DA FE FF            cp 255                                  ; if 255 reverse
 70+  C5DC CA E5 C5         jp z,monster_process3
 71+  C5DF 22 8D C5         ld (monster_jumppos),hl                 ; store the new pos
 72+  C5E2 C3 ED C5         jp monster_process2                     ; keep going
 73+  C5E5              monster_process3:
 74+  C5E5 3A A0 C5         ld a,(monster_jumpdirectionvert)        ; get the direction
 75+  C5E8 EE 01            xor 1                                   ; flip it
 76+  C5EA 32 A0 C5         ld (monster_jumpdirectionvert),a        ; store it
 77+  C5ED              monster_process2:
 78+  C5ED CD F1 C5         call monster_draw                       ; finally, draw the monster
 79+  C5F0 C9               ret
 80+  C5F1
 81+  C5F1              ;
 82+  C5F1              ; Draw the monster at the current location
 83+  C5F1              ;
 84+  C5F1              monster_draw:
 85+  C5F1 ED 4B 89 C5      ld bc,(monster_currentcoords)
 86+  C5F5 21 02 B6         ld hl,monster_sprite                    ; load the first frame
 87+  C5F8 CD F9 A9         call sprites_draw2by2sprite
 88+  C5FB ED 4B 89 C5      ld bc,(monster_currentcoords)
 89+  C5FF 79               ld a,c
 90+  C600 E6 F8            and 248                                 ; work out the lines to update
 91+  C602 0F               rrca
 92+  C603 0F               rrca
 93+  C604 0F               rrca
 94+  C605 ED 4B A2 A7      ld bc,(screen_offset)
 95+  C609 91               sub c
 96+  C60A 4F               ld c,a
 97+  C60B CD EC A5         call buffer_marklineforupdate
 98+  C60E 0C               inc c
 99+  C60F 79               ld a,c
100+  C610 CD EC A5         call buffer_marklineforupdate
101+  C613 0C               inc c
102+  C614 79               ld a,c
103+  C615 CD EC A5         call buffer_marklineforupdate
104+  C618 C9               ret
# file closed: game/monster.asm
 48   C619
 49   C619              ;===========================================================================
 50   C619              ; main routine - the code execution starts here.
 51   C619              ; Sets up the new interrupt routine, the memory
 52   C619              ; banks and jumps to the start loop.
 53   C619              ;===========================================================================
 54   C619              main:
 55   C619
 56   C619                  ; Draw the title screen
 57   C619              main_titlescreen:
 58   C619 CD 71 AA         call titlescreen_show
 59   C61C CD 0A BB         call player_init_gamestart
 60   C61F
 61   C61F              main_lifestart:
 62   C61F
 63   C61F CD 28 BB         call player_init_lifestart
 64   C622
 65   C622 CD D7 AB         call lifescreen_draw        ; show the lives remaining screen
 66   C625
 67   C625 CD 00 80         call init_start
 68   C628 CD BD A7         call screen_draw
 69   C62B CD E1 A6         call buffer_allbuffertoscreen
 70   C62E
 71   C62E CD 67 C3         call missiles_init
 72   C631 CD D2 BC         call ship_land              ; land the ship
 73   C634 CD F4 BD         call tank_init
 74   C637 CD 2F C3         call diamonds_init
 75   C63A CD 34 C5         call thepit_init
 76   C63D CD A1 C5         call monster_init
 77   C640
 78   C640              mloop:
 79   C640 76               halt
 80   C641 CD 75 C6         call main_loop_processing
 81   C644
 82   C644                  ;
 83   C644                  ; Check if the player died
 84   C644                  ;
 85   C644 21 CF BA         ld hl,player+10
 86   C647 7E               ld a,(hl)                   ; check if the player died this frame
 87   C648 FE 01            cp 1
 88   C64A C2 61 C6         jp nz,mloop0
 89   C64D CD 8F BB         call player_died        ; do end of life housekeeping
 90   C650 06 28            ld b,40
 91   C652 CD 82 80         call utilities_pauseforframes
 92   C655 21 CE BA         ld hl,player+9        ; check lives remaining
 93   C658 7E               ld a,(hl)
 94   C659 FE 00            cp 0
 95   C65B CA A3 C6         jp z,main_gameover   ; leave the loop if we're done
 96   C65E C3 1F C6         jp main_lifestart    ; otherwise, start a new life
 97   C661              mloop0:
 98   C661                  ;
 99   C661                  ; Check if the player completed the level
100   C661                  ;
101   C661 21 D2 BA         ld hl,player+13
102   C664 7E               ld a,(hl)
103   C665 FE 01            cp 1
104   C667 C2 40 C6         jp nz,mloop
105   C66A CD 9C BC         call player_checkforexit
106   C66D FE 01            cp 1                        ; look at return, if 1, level has been completed
107   C66F CA A9 C6         jp z,main_endlevel          ; jump to level transition screen
108   C672 C3 40 C6         jp mloop                ; start the loop again
109   C675
110   C675
111   C675              main_loop_processing:
112   C675
113   C675 CD AF A6         call buffer_buffertoscreen  ; copy buffer to screen
114   C678 CD 2F A6         call buffer_clearlist       ; zero the updated lines list
115   C67B CD D4 BA         call player_getlocation     ; figure out where the player is
116   C67E CD C5 BB         call player_drawplayer      ; delete player
117   C681 CD 42 B6         call control_keyboard       ; check keyboard
118   C684 CD C5 BB         call player_drawplayer      ; draw player
119   C687 CD 23 BE         call tank_process           ; prcoess the tank
120   C68A CD BD BC         call ship_process           ; proces the ship
121   C68D CD 1D C0         call rocks_processrocks     ; process falling rocks
122   C690 CD 3F C5         call thepit_process         ; process the pit trap
123   C693 CD 8F C3         call missiles_process       ; process missiles
124   C696 CD B8 C5         call monster_process        ; process monster
125   C699 CD 0E C3         call diamonds_twinkle       ; make the diamonds twinkle
126   C69C CD 98 C1         call scores_printscore      ; update the score on screen
127   C69F CD AC BA         call game_incrementframe    ; increment the game frame
128   C6A2
129   C6A2 C9               ret
130   C6A3
131   C6A3              main_gameover:
132   C6A3 CD 2A AC         call gameover_draw          ; show the game over screen
133   C6A6 C3 19 C6         jp main_titlescreen         ; go back to title
134   C6A9
135   C6A9              main_endlevel:
136   C6A9 CD 75 BB         call player_recordcurrentscore
137   C6AC CD 18 AD         call endlevel_draw          ; show the end level screen
138   C6AF C3 1F C6         jp main_lifestart           ; start a new life
139   C6B2
140   C6B2              ;===========================================================================
141   C6B2              ; Stack.
142   C6B2              ;===========================================================================
143   C6B2
144   C6B2              ; Stack: this area is reserved for the stack
145   C6B2              STACK_SIZE: equ 100    ; in words
146   C6B2
147   C6B2              ; Reserve stack space
148   C6B2 00 00            defw 0  ; WPMEM, 2
149   C6B4              stack_bottom:
150   C6B4 00 00 00...      defs    STACK_SIZE*2, 0
151   C77C              stack_top:
152   C77C 00 00            defw 0  ; WPMEM, 2
153   C77E
154   C77E                     SAVESNA "ThePit.sna", main
# file closed: main.asm
