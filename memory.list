# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; Include modules
 19   8000              ;===========================================================================
 20   8000                  include "init.asm"
# file opened: init.asm
  1+  8000              ;
  2+  8000              ; Set up at start up
  3+  8000              ;
  4+  8000              init_start:
  5+  8000              ; We want a black screen.
  6+  8000
  7+  8000 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  8002                                      ; bright (64).
  9+  8002 CD 7E 80         call utilities_clearscreen
 10+  8005 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  8008 AF               xor a               ; quick way to load accumulator with zero.
 12+  8009 CD 9B 22         call 8859           ; set permanent border colours.
 13+  800C
 14+  800C 21 06 A8         ld hl,screen_offset ; reset some temp variables
 15+  800F 36 00            ld (hl),0
 16+  8011 21 07 A8         ld hl,screen_tmp
 17+  8014 36 00            ld (hl),0
 18+  8016 21 3C A6         ld hl,buffer_tmp
 19+  8019 36 00            ld (hl),0
 20+  801B 23               inc hl
 21+  801C 36 00            ld (hl),0
 22+  801E
 23+  801E CD 85 BD         call game_resetcurrentframe ; reset current frame
 24+  8021
 25+  8021 C9               ret
 26+  8022
 27+  8022              ;
 28+  8022              ;   Start coord
 29+  8022              ;   vert c, horiz b
 30+  8022              init_coord:
 31+  8022 18 30            defb 24,48
 32+  8024
 33+  8024              ;
 34+  8024              ; Number of lives to start
 35+  8024              ;
 36+  8024              init_lives:
 37+  8024 03               defb 3
 38+  8025
 39+  8025              ;
 40+  8025              ; Score to start
 41+  8025              ;
 42+  8025              init_score:
 43+  8025 30 30 30 30      defb '000000'
 43+  8029 30 30
# file closed: init.asm
 21   802B                  include "utilities.asm"
# file opened: utilities.asm
  1+  802B              ; ##########################################################################
  2+  802B              ; Print a character
  3+  802B              ; Inputs:
  4+  802B              ; b - x coord
  5+  802B              ; c - y coord
  6+  802B              ; d - character
  7+  802B              ; e - colour
  8+  802B              ; ##########################################################################
  9+  802B              utilities_print_char:
 10+  802B 7B               ld a,e
 11+  802C 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  802F 3E 16            ld a,22
 13+  8031 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  8032 78               ld a,b              ; Gets the X co-ordinate
 15+  8033 3D               dec a
 16+  8034 D7               rst 16
 17+  8035 79               ld a,c              ; and the Y co-ordinate
 18+  8036 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8037 7A               ld a,d              ; ASCII code for udg.
 20+  8038 D7               rst 16              ; draw block.
 21+  8039 C9               ret
 22+  803A
 23+  803A
 24+  803A              ;Inputs:
 25+  803A              ;     DE and A are factors
 26+  803A              ;Outputs:
 27+  803A              ;     A is not changed
 28+  803A              ;     B is 0
 29+  803A              ;     C is not changed
 30+  803A              ;     DE is not changed
 31+  803A              ;     HL is the product
 32+  803A              ;Time:
 33+  803A              ;     342+6x
 34+  803A              ;
 35+  803A              utilities_multiply:
 36+  803A 06 08            ld b,8          ;7           7
 37+  803C 21 00 00         ld hl,0         ;10         10
 38+  803F 29               add hl,hl     ;11*8       88
 39+  8040 07               rlca          ;4*8        32
 40+  8041 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8043 19                   add hl,de   ;--         --
 42+  8044 10 F9            djnz $-5      ;13*7+8     99
 43+  8046 C9               ret             ;10         10
 44+  8047
 45+  8047              utilities_waitforkey:
 46+  8047 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  804A 36 00            ld (hl),0           ; put null value there.
 48+  804C              utilities_waitforkey0:
 49+  804C 7E               ld a,(hl)           ; new value of LAST K.
 50+  804D FE 00            cp 0                ; is it still zero?
 51+  804F 20 0A            jr nz,utilities_waitforkey1           ; yes, so no key pressed.
 52+  8051 01 1F 00         ld bc,31                        ; Kempston joystick port.
 53+  8054 ED 78            in a,(c)                        ; read input.
 54+  8056 E6 10            and 16
 55+  8058 CA 4C 80         jp z,utilities_waitforkey0
 56+  805B              utilities_waitforkey1:
 57+  805B C9               ret                 ; key was pressed.
 58+  805C
 59+  805C              ;
 60+  805C              ; Waits number of frames for keypress. If got, returns 1, if not 0
 61+  805C              ; Inputs:
 62+  805C              ; a - number of frames to waits
 63+  805C              ; Ouputs:
 64+  805C              ; e - 0 not pressed, 1 pressed
 65+  805C              utilities_waitforkey_forframes:
 66+  805C 21 08 5C         ld hl,23560         ; LAST K system variable.
 67+  805F 36 00            ld (hl),0           ; put null value there.
 68+  8061 47               ld b,a              ; number of frames to wait
 69+  8062              utilities_waitforkey_forframes0:
 70+  8062 7E               ld a,(hl)           ; new value of LAST K.
 71+  8063 FE 00            cp 0                ; is it still zero?
 72+  8065 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 73+  8067 1E 01            ld e,1              ; set the pressed flag
 74+  8069 C9               ret                 ; key was pressed.
 75+  806A              utilities_waitforkey_forframes1:
 76+  806A 01 1F 00         ld bc,31                        ; Kempston joystick port.
 77+  806D ED 78            in a,(c)                        ; read input.
 78+  806F E6 10            and 16
 79+  8071 CA 77 80         jp z,utilities_waitforkey_forframes2
 80+  8074 1E 01            ld e,1              ; set the pressed flag
 81+  8076 C9               ret                 ; key was pressed.
 82+  8077              utilities_waitforkey_forframes2:
 83+  8077 76               halt                ; wait for frame
 84+  8078 76               halt                ; wait for frame
 85+  8079 10 E7            djnz utilities_waitforkey_forframes0 ; loop again
 86+  807B 1E 00            ld e,0              ; nothing pressed in time
 87+  807D C9               ret
 88+  807E
 89+  807E              ;
 90+  807E              ; Clears the screen
 91+  807E              ; Inputs:
 92+  807E              ; a - attribute colour
 93+  807E              utilities_clearscreen:
 94+  807E 76               halt
 95+  807F 21 00 58         ld hl,22528         ; attr
 96+  8082 11 01 58         ld de,22529         ; attr+1
 97+  8085 01 FF 02         ld bc,767
 98+  8088 77               ld (hl),a
 99+  8089 ED B0            ldir
100+  808B
101+  808B 21 00 40         ld hl, 16384        ;pixels
102+  808E 11 01 40         ld de, 16385        ;pixels + 1
103+  8091 01 FF 17         ld bc, 6143         ;pixels area length - 1
104+  8094 36 00            ld (hl), 0          ;set first byte to '0'
105+  8096 ED B0            ldir                ;copy bytes
106+  8098
107+  8098 C9               ret
108+  8099
109+  8099              ;
110+  8099              ; Wait for a number of frames
111+  8099              ; Inputs:
112+  8099              ; b - number of frames
113+  8099              utilities_pauseforframes:
114+  8099 76               halt
115+  809A 10 FD            djnz utilities_pauseforframes
116+  809C C9               ret
117+  809D
118+  809D              utilities_readkey:
119+  809D 21 BD 80         LD HL,utilties_keymap              ; Point HL at the keyboard list
120+  80A0 16 08            LD D,8                                  ; This is the number of ports (rows) to check
121+  80A2 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
122+  80A4              utilities_readkey_0:
123+  80A4 46               LD B,(HL)                               ; Get the keyboard port address from table
124+  80A5 23               INC HL                                  ; Increment to list of keys
125+  80A6 ED 78            IN A,(C)                                ; Read the row of keys in
126+  80A8 E6 1F            AND $1F                                     ; We are only interested in the first five bits
127+  80AA 1E 05            LD E,5                                  ; This is the number of keys in the row
128+  80AC              utilities_readkey_1:
129+  80AC CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
130+  80AE 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
131+  80B0 23               INC HL                                  ; Go to next table address
132+  80B1 1D               DEC E                                   ; Decrement key loop counter
133+  80B2 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
134+  80B4 15               DEC D                                   ; Decrement row loop counter
135+  80B5 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
136+  80B7 A7               AND A                                   ; Clear A (no key found)
137+  80B8 C3 9D 80         jp utilities_readkey
138+  80BB              utilities_readkey_2:
139+  80BB 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
140+  80BC C9               RET
141+  80BD
142+  80BD              utilties_keymap:
143+  80BD FE 23 5A 58      defb $FE,"#","Z","X","C","V"
143+  80C1 43 56
144+  80C3 FD 41 53 44      defb $FD,"A","S","D","F","G"
144+  80C7 46 47
145+  80C9 FB 51 57 45      defb $FB,"Q","W","E","R","T"
145+  80CD 52 54
146+  80CF F7 31 32 33      defb $F7,"1","2","3","4","5"
146+  80D3 34 35
147+  80D5 EF 30 39 38      defb $EF,"0","9","8","7","6"
147+  80D9 37 36
148+  80DB DF 50 4F 49      defb $DF,"P","O","I","U","Y"
148+  80DF 55 59
149+  80E1 BF 23 4C 4B      defb $BF,"#","L","K","J","H"
149+  80E5 4A 48
150+  80E7 7F 20 23 4D      defb $7F," ","#","M","N","B"
150+  80EB 4E 42
151+  80ED
152+  80ED
153+  80ED              ;
154+  80ED              ; Generates a randomish number in the range 0 to e
155+  80ED              ; Inputs:
156+  80ED              ; e - upper value
157+  80ED              ; Outputs:
158+  80ED              ; a - random number
159+  80ED              utilities_randomupper
160+  80ED 3A 59 BD         ld a,(game_framenumber)
161+  80F0 6F               ld l,a
162+  80F1 26 00            ld h,0
163+  80F3 16 00            ld d,0
164+  80F5 42 4B            ld bc,de
165+  80F7              utilities_randomupper0:
166+  80F7 B7               or a
167+  80F8 ED 42            sbc hl,bc
168+  80FA F2 F7 80         jp p,utilities_randomupper0
169+  80FD 09               add hl,bc
170+  80FE 01 00 00         ld bc,0
171+  8101 09               add hl,bc
172+  8102 7D               ld a,l
173+  8103 C9               ret
# file closed: utilities.asm
 22   8104                  include "strings.asm"
# file opened: strings.asm
  1+  8104              string_score1:
  2+  8104 04 00 53 43      defb 4,0,'SCORE1',255
  2+  8108 4F 52 45 31
  2+  810C FF
  3+  810D              string_scorenumbers1:
  4+  810D 04 01 30 30      defb 4,1,'000000',255
  4+  8111 30 30 30 30
  4+  8115 FF
  5+  8116              string_company:
  6+  8116 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  811A 4E 54 55 52
  6+  811E 49 FF
  7+  8120              string_credits:
  8+  8120 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  8124 41 59 45 52
  8+  8128 20 31 FF
  9+  812B              string_score2:
 10+  812B 16 00 53 43      defb 22,0,'SCORE2',255
 10+  812F 4F 52 45 32
 10+  8133 FF
 11+  8134              string_scorenumbers2:
 12+  8134 16 01 30 30      defb 22,1,'000000',255
 12+  8138 30 30 30 30
 12+  813C FF
 13+  813D              string_titlescreen_copyright:
 14+  813D 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 14+  8141 39 38 32 20
 14+  8145 20 43 45 4E
 14+  8149 54 55 52 49
 14+  814D 20 49 4E 43
 14+  8151 FF
 15+  8152
 16+  8152
 17+  8152              string_alttitlescreen_1:
 18+  8152 0C 00 43 52      defb 12,0,'CREDITS 1',255
 18+  8156 45 44 49 54
 18+  815A 53 20 31 FF
 19+  815E              string_alttitlescreen_2:
 20+  815E 00 02 20 20      defb 0,2,'           THE OBJECT',254
 20+  8162 20 20 20 20
 20+  8166 20 20 20 20
 20+  816A 20 54 48 45
 20+  816E 20 4F 42 4A
 20+  8172 45 43 54 FE
 21+  8176 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 21+  817A 20 20 20 20
 21+  817E 20 20 20 20
 21+  8182 4F 46 20 54
 21+  8186 48 49 53 20
 21+  818A 47 41 4D 45
 21+  818E FE
 22+  818F 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 22+  8193 20 20 20 20
 22+  8197 20 20 20 49
 22+  819B 53 20 54 4F
 22+  819F 20 44 49 47
 22+  81A3 20 44 4F 57
 22+  81A7 4E FE
 23+  81A9 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 23+  81AD 20 20 20 20
 23+  81B1 20 20 54 4F
 23+  81B5 20 54 48 45
 23+  81B9 20 42 4F 54
 23+  81BD 54 4F 4D 20
 23+  81C1 50 49 54 FE
 24+  81C5 00 06 20 20      defb 0,6,'               AND',254
 24+  81C9 20 20 20 20
 24+  81CD 20 20 20 20
 24+  81D1 20 20 20 20
 24+  81D5 20 41 4E 44
 24+  81D9 FE
 25+  81DA 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 25+  81DE 20 20 20 20
 25+  81E2 20 20 43 4F
 25+  81E6 4C 4C 45 43
 25+  81EA 54 20 41 54
 25+  81EE 20 4C 45 41
 25+  81F2 53 54 FE
 26+  81F5 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 26+  81F9 20 20 20 20
 26+  81FD 20 20 20 4F
 26+  8201 4E 45 20 4C
 26+  8205 41 52 47 45
 26+  8209 20 4A 45 57
 26+  820D 45 4C FE
 27+  8210 00 09 20 20      defb 0,9,'              THEN',254
 27+  8214 20 20 20 20
 27+  8218 20 20 20 20
 27+  821C 20 20 20 20
 27+  8220 54 48 45 4E
 27+  8224 FE
 28+  8225 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 28+  8229 20 20 20 20
 28+  822D 20 20 20 52
 28+  8231 45 54 55 52
 28+  8235 4E 20 54 4F
 28+  8239 20 53 48 49
 28+  823D 50 FE
 29+  823F 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 29+  8243 20 20 20 20
 29+  8247 20 20 20 54
 29+  824B 48 52 55 20
 29+  824F 55 50 50 45
 29+  8253 52 20 50 49
 29+  8257 54 FF
 30+  8259              string_alttitlescreen_3:
 31+  8259 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 31+  825D 20 20 53 49
 31+  8261 4E 47 4C 45
 31+  8265 20 42 4F 4E
 31+  8269 55 53 20 20
 31+  826D 35 30 30 30
 31+  8271 20 50 4F 49
 31+  8275 4E 54 53 FE
 32+  8279 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 32+  827D 20 20 20 20
 32+  8281 43 4F 4C 4C
 32+  8285 45 43 54 20
 32+  8289 31 20 4C 41
 32+  828D 52 47 45 20
 32+  8291 4A 45 57 45
 32+  8295 4C FE
 33+  8297 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 33+  829B 20 20 20 20
 33+  829F 20 41 4E 44
 33+  82A3 20 52 45 54
 33+  82A7 55 52 4E 20
 33+  82AB 54 4F 20 53
 33+  82AF 48 49 50 FE
 34+  82B3 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 34+  82B7 20 20 44 4F
 34+  82BB 55 42 4C 45
 34+  82BF 20 42 4F 4E
 34+  82C3 55 53 20 20
 34+  82C7 31 30 30 30
 34+  82CB 30 20 50 4F
 34+  82CF 49 4E 54 53
 34+  82D3 FE
 35+  82D4 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 35+  82D8 20 20 43 4F
 35+  82DC 4C 4C 45 43
 35+  82E0 54 20 41 4C
 35+  82E4 4C 20 33 20
 35+  82E8 4C 41 52 47
 35+  82EC 45 20 4A 45
 35+  82F0 57 45 4C 53
 35+  82F4 FE
 36+  82F5 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 36+  82F9 20 20 20 20
 36+  82FD 20 4F 52 20
 36+  8301 20 20 41 4C
 36+  8305 4C 20 34 20
 36+  8309 53 4D 41 4C
 36+  830D 4C 20 4A 45
 36+  8311 57 45 4C 53
 36+  8315 FE
 37+  8316 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 37+  831A 20 20 54 52
 37+  831E 49 50 4C 45
 37+  8322 20 42 4F 4E
 37+  8326 55 53 20 20
 37+  832A 31 35 30 30
 37+  832E 30 20 50 4F
 37+  8332 49 4E 54 53
 37+  8336 FE
 38+  8337 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 38+  833B 20 20 20 20
 38+  833F 20 43 4F 4C
 38+  8343 4C 45 43 54
 38+  8347 20 41 4C 4C
 38+  834B 20 37 20 4A
 38+  834F 45 57 45 4C
 38+  8353 53 FF
 39+  8355
 40+  8355              string_lifescreen_player:
 41+  8355 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 41+  8359 4C 41 59 45
 41+  835D 52 20 31 20
 41+  8361 FF
 42+  8362              string_lifescreen_lives:
 43+  8362 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 43+  8366 4D 45 4E 20
 43+  836A 4C 45 46 54
 43+  836E FF
 44+  836F              string_lifescreen_lastman:
 45+  836F 0C 03 4C 41      defb 12,3,'LAST MAN',255
 45+  8373 53 54 20 4D
 45+  8377 41 4E FF
 46+  837A
 47+  837A              string_gameoverscreen_gameover:
 48+  837A 0B 06 47 41      defb 11,6,'GAME OVER',255
 48+  837E 4D 45 20 4F
 48+  8382 56 45 52 FF
 49+  8386              string_gameoverscreen_copyright:
 50+  8386 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 50+  838A 39 38 32 20
 50+  838E 43 45 4E 54
 50+  8392 55 52 49 20
 50+  8396 49 4E 43 FF
 51+  839A              string_gameoverscreen_bestscores:
 52+  839A 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 52+  839E 53 54 20 53
 52+  83A2 43 4F 52 45
 52+  83A6 53 20 54 4F
 52+  83AA 44 41 59 FF
 53+  83AE              string_gameover_credits:
 54+  83AE 0C 01 43 52      defb 12,1,'CREDITS 0',255
 54+  83B2 45 44 49 54
 54+  83B6 53 20 30 FF
 55+  83BA
 56+  83BA              string_highscore_congratulations:
 57+  83BA 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 57+  83BE 4E 47 52 41
 57+  83C2 54 55 4C 41
 57+  83C6 54 49 4F 4E
 57+  83CA 53 FF
 58+  83CC              string_highscore_player1:
 59+  83CC 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 59+  83D0 41 59 45 52
 59+  83D4 20 31 FF
 60+  83D7              string_highscore_player2:
 61+  83D7 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 61+  83DB 41 59 45 52
 61+  83DF 20 32 FF
 62+  83E2              string_highscore_youhaveearned:
 63+  83E2 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 63+  83E6 55 20 48 41
 63+  83EA 56 45 20 45
 63+  83EE 41 52 4E 45
 63+  83F2 44 FF
 64+  83F4              string_highscore_place1:
 65+  83F4 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 65+  83F8 45 20 47 52
 65+  83FC 45 41 54 45
 65+  8400 53 54 20 53
 65+  8404 43 4F 52 45
 65+  8408 FF
 66+  8409              string_highscore_place2:
 67+  8409 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 67+  840D 45 20 32 4E
 67+  8411 44 20 42 45
 67+  8415 53 54 20 53
 67+  8419 43 4F 52 45
 67+  841D FF
 68+  841E              string_highscore_place3:
 69+  841E 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 69+  8422 45 20 33 52
 69+  8426 44 20 42 45
 69+  842A 53 54 20 53
 69+  842E 43 4F 52 45
 69+  8432 FF
 70+  8433              string_highscore_pleaseenter
 71+  8433 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 71+  8437 43 4F 52 44
 71+  843B 20 59 4F 55
 71+  843F 52 20 49 4E
 71+  8443 49 54 49 41
 71+  8447 4C 53 20 42
 71+  844B 45 4C 4F 57
 71+  844F FF
 72+  8450
 73+  8450              string_endlevel_youhaveearned:
 74+  8450 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 74+  8454 55 20 48 41
 74+  8458 56 45 20 45
 74+  845C 41 52 4E 45
 74+  8460 44 FF
 75+  8462              string_endlevel_bonus1:
 76+  8462 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 76+  8466 4E 47 4C 45
 76+  846A 20 42 4F 4E
 76+  846E 55 53 FF
 77+  8471              string_endlevel_bonus2:
 78+  8471 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 78+  8475 55 42 4C 45
 78+  8479 20 42 4F 4E
 78+  847D 55 53 FF
 79+  8480              string_endlevel_bonus3:
 80+  8480 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 80+  8484 49 50 4C 45
 80+  8488 20 42 4F 4E
 80+  848C 55 53 FF
 81+  848F              string_endlevel_points1:
 82+  848F 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 82+  8493 30 30 20 50
 82+  8497 4F 49 4E 54
 82+  849B 53 FF
 83+  849D              string_endlevel_points2:
 84+  849D 09 0F 31 30      defb 9,15,'10000 POINTS',255
 84+  84A1 30 30 30 20
 84+  84A5 50 4F 49 4E
 84+  84A9 54 53 FF
 85+  84AC              string_endlevel_points3:
 86+  84AC 09 0F 31 35      defb 9,15,'15000 POINTS',255
 86+  84B0 30 30 30 20
 86+  84B4 50 4F 49 4E
 86+  84B8 54 53 FF
 87+  84BB              string_endlevel_anothergo:
 88+  84BB 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 88+  84BF 56 45 20 41
 88+  84C3 4E 4F 54 48
 88+  84C7 45 52 20 47
 88+  84CB 4F FF
 89+  84CD
 90+  84CD              string_zonk:
 91+  84CD 00 00 5A 4F      defb 0,0,'ZONK!',255
 91+  84D1 4E 4B 21 FF
 92+  84D5
 93+  84D5
 94+  84D5              string_options_title:
 95+  84D5 0D 03 54 48      defb 13,3,'THE PIT',255
 95+  84D9 45 20 50 49
 95+  84DD 54 FF
 96+  84DF              string_options_1player:
 97+  84DF 0A 06 31 2E      defb 10,6,'1. ONE PLAYER',255
 97+  84E3 20 4F 4E 45
 97+  84E7 20 50 4C 41
 97+  84EB 59 45 52 FF
 98+  84EF              string_options_2player:
 99+  84EF 0A 07 32 2E      defb 10,7,'2. TWO PLAYER',255
 99+  84F3 20 54 57 4F
 99+  84F7 20 50 4C 41
 99+  84FB 59 45 52 FF
100+  84FF              string_options_keyboard:
101+  84FF 0A 08 33 2E      defb 10,8,'3. KEYBOARD',255
101+  8503 20 4B 45 59
101+  8507 42 4F 41 52
101+  850B 44 FF
102+  850D              string_options_joystick:
103+  850D 0A 09 34 2E      defb 10,9,'4. KEMPSTON',255
103+  8511 20 4B 45 4D
103+  8515 50 53 54 4F
103+  8519 4E FF
104+  851B              string_options_start:
105+  851B 0A 0A 35 2E      defb 10,10,'5. START',255
105+  851F 20 53 54 41
105+  8523 52 54 FF
106+  8526              string_options_vanity:
107+  8526 08 16 53 70      defb 8,22,'Spectrum Conversion',254
107+  852A 65 63 74 72
107+  852E 75 6D 20 43
107+  8532 6F 6E 76 65
107+  8536 72 73 69 6F
107+  853A 6E FE
108+  853C 07 17 62 79      defb 7,23,'by Dave Tansley, 2020',255
108+  8540 20 44 61 76
108+  8544 65 20 54 61
108+  8548 6E 73 6C 65
108+  854C 79 2C 20 32
108+  8550 30 32 30 FF
109+  8554
110+  8554              ;
111+  8554              ; Prints specified string
112+  8554              ; Inputs:
113+  8554              ; de: pointer to string
114+  8554              ; bc: length of string
115+  8554              ;
116+  8554              ; Print String Data
117+  8554              ; First two bytes of string contain X and Y char position, then the string
118+  8554              ; Individual strings are terminated with 0xFE
119+  8554              ; End of data is terminated with 0xFF
120+  8554              ; HL: Address of string
121+  8554              ;
122+  8554 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
123+  8555 23                                   INC HL                          ; Increase HL to the next memory location
124+  8556 56                                   LD D,(HL)                       ; Fetch the Y coordinate
125+  8557 23                                   INC HL                          ; Increase HL to the next memory location
126+  8558 CD 6B 85                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
127+  855B 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
128+  855C 23                                   INC HL                          ; Increase HL to the next character
129+  855D FE FE                                CP 0xFE                         ; Compare with 0xFE
130+  855F 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
131+  8561 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
132+  8562 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
133+  8563 CD 7B 85                             CALL Print_Char                 ; Print the character
134+  8566 E1                                   POP HL                          ; Retrieve HL back off the stack
135+  8567 1C                                   INC E                           ; Go to the next screen address
136+  8568 18 F1                                JR string_print_0               ; Loop back to print next character
137+  856A C9                                   RET
138+  856B
139+  856B              ; Get screen address
140+  856B              ; D = Y character position
141+  856B              ; E = X character position
142+  856B              ; Returns address in DE
143+  856B              ;
144+  856B 7A           string_getcharaddress:       LD A,D
145+  856C E6 07                                AND %00000111
146+  856E 1F                                   RRA
147+  856F 1F                                   RRA
148+  8570 1F                                   RRA
149+  8571 1F                                   RRA
150+  8572 B3                                   OR E
151+  8573 5F                                   LD E,A
152+  8574 7A                                   LD A,D
153+  8575 E6 18                                AND %00011000
154+  8577 F6 40                                OR %01000000
155+  8579 57                                   LD D,A
156+  857A C9                                   RET                             ; Returns screen address in DE
157+  857B
158+  857B              ; Print a single character out
159+  857B              ; A:  Character to print
160+  857B              ; DE: Screen address to print character at
161+  857B              ;
162+  857B 21 00 3C     Print_Char:             LD HL,0x3C00                    ; Address of character set table in ROM
163+  857E 06 00                                LD B,0                          ; Set BC to A
164+  8580 4F                                   LD C,A
165+  8581 E6 FF                                AND 0xFF                        ; Clear the carry bit
166+  8583 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
167+  8585 CB 10                                RL B
168+  8587 CB 11                                RL C
169+  8589 CB 10                                RL B
170+  858B CB 11                                RL C
171+  858D CB 10                                RL B
172+  858F 09                                   ADD HL,BC                       ; Get the character address in HL
173+  8590 0E 08                                LD C,8                          ; Loop counter
174+  8592 D5                                   PUSH DE
175+  8593 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
176+  8594 12                                   LD (DE),A                       ; Stick A onto the screen
177+  8595 14                                   INC D                           ; Goto next line on screen
178+  8596 2C                                   INC L                           ; Goto next byte of character
179+  8597 0D                                   DEC C                           ; Decrease the loop counter
180+  8598 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
181+  859A D1                                   POP DE
182+  859B C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
 23   859C                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  859C              buffer_buffer:
  2+  859C 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A29C
  4+  A29C              buffer_attr_buffer:
  5+  A29C 00 00 00...      defs 928                    ; attrs buffer area
  6+  A63C
  7+  A63C              buffer_tmp:
  8+  A63C 00 00            defb 0,0                    ; temp area
  9+  A63E
 10+  A63E              ;
 11+  A63E              ; This list stores lines to be updated by the buffer.
 12+  A63E              ; This is done by half line. Lines are encded with.
 13+  A63E              ; 00hlllll
 14+  A63E              ; Where h is the half of the screen (0 or 1), lllll is the line number
 15+  A63E              buffer_updatedlines:
 16+  A63E FF FF FF...      defs 21,255
 17+  A653
 18+  A653              buffer_updateall:
 19+  A653 00               defb 0
 20+  A654
 21+  A654              ;
 22+  A654              ; Stores a line number in the update list
 23+  A654              ; Inputs:
 24+  A654              ; a - row number
 25+  A654              buffer_marklineforupdate:
 26+  A654 FE 15            cp 21
 27+  A656 D0               ret nc                          ; dont store lines that we shouldn't draw
 28+  A657 5F               ld e,a                          ; store in e
 29+  A658 ED 4B 41 AB      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 30+  A65C 79               ld a,c                          ; get the horiz coord
 31+  A65D FE 0F            cp 15
 32+  A65F CA 76 A6         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 33+  A662 FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 34+  A664 CA 76 A6         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 35+  A667 DA 72 A6         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 36+  A66A 78               ld a,b                          ; get the vertical
 37+  A66B 3E 20            ld a,32                         ; set the 6th bit by adding 32
 38+  A66D 83               add a,e
 39+  A66E 5F               ld e,a                          ; store this value
 40+  A66F C3 7D A6         jp buffer_marklineforupdate2
 41+  A672              buffer_marklineforupdate4:
 42+  A672 78               ld a,b
 43+  A673 C3 7D A6         jp buffer_marklineforupdate2    ; just get the vertical
 44+  A676              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 45+  A676 CD 81 A6         call buffer_storelineforupdate  ; call store update for e
 46+  A679 3E 20            ld a,32
 47+  A67B 83               add a,e
 48+  A67C 5F               ld e,a
 49+  A67D              buffer_marklineforupdate2:
 50+  A67D CD 81 A6         call buffer_storelineforupdate  ; call store update for e
 51+  A680 C9               ret
 52+  A681
 53+  A681
 54+  A681              ;
 55+  A681              ; Stores the calculated line and half if needed
 56+  A681              ; Inputs:
 57+  A681              ; e - half/row
 58+  A681              ;
 59+  A681              buffer_storelineforupdate:
 60+  A681 06 15            ld b,21
 61+  A683 21 3E A6         ld hl,buffer_updatedlines
 62+  A686              buffer_storelineforupdate0:
 63+  A686 7E               ld a,(hl)                       ; get the line stored in updated lines
 64+  A687 BB               cp e                            ; is this the same as the row number passed in?
 65+  A688 C8               ret z                           ; if so, don't need to do anything
 66+  A689 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 67+  A68B C2 90 A6         jp nz,buffer_storelineforupdate1 ; if not, move to next
 68+  A68E 73               ld (hl),e
 69+  A68F C9               ret
 70+  A690              buffer_storelineforupdate1:
 71+  A690 23               inc hl
 72+  A691 10 F3            djnz buffer_storelineforupdate0
 73+  A693 C9               ret
 74+  A694
 75+  A694              ;
 76+  A694              ; Zeroes the updated lines list
 77+  A694              ;
 78+  A694              buffer_clearlist:
 79+  A694 06 15            ld b,21
 80+  A696 21 3E A6         ld hl,buffer_updatedlines
 81+  A699              buffer_clearlist0:
 82+  A699 36 FF            ld (hl),255
 83+  A69B 23               inc hl
 84+  A69C 10 FB            djnz buffer_clearlist0
 85+  A69E C9               ret
 86+  A69F
 87+  A69F              ;
 88+  A69F              ; Which half are we displaying? 0 left 1 right
 89+  A69F              ;
 90+  A69F              buffer_bufferhalf:
 91+  A69F 00               defb 0
 92+  A6A0
 93+  A6A0              ;
 94+  A6A0              ; Copies the buffer to the screen. Use stack.
 95+  A6A0              ; Inputs:
 96+  A6A0              ; hl - half/line number to display - 0 is first half, 0 is first line
 97+  A6A0              ;
 98+  A6A0              buffer_bufferlinetoscreen:
 99+  A6A0 7C               ld a,h
100+  A6A1 32 9F A6         ld (buffer_bufferhalf),a        ; store the half
101+  A6A4 7D               ld a,l
102+  A6A5 4F               ld c,a                          ; store a
103+  A6A6 ED 5B 06 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
104+  A6AA 83               add a,e                       ; add the row number
105+  A6AB 11 00 01         ld de,256
106+  A6AE CD 3A 80         call utilities_multiply
107+  A6B1 54 5D            ld de,hl
108+  A6B3 21 9C 85         ld hl,buffer_buffer
109+  A6B6 19               add hl,de                   ; add the offset
110+  A6B7 79               ld a,c                      ; get original row back
111+  A6B8 ED 73 2B A7      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
112+  A6BC D9               exx
113+  A6BD 0E 00            ld c,0                      ; zero horizontal
114+  A6BF 47               ld b,a                      ; load the row number into vertical coord
115+  A6C0 04               inc b
116+  A6C1 04               inc b                       ; move forward 2 to allow for scores
117+  A6C2 CD F0 A8         call screen_getcelladdress  ; get the memory into de
118+  A6C5 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
119+  A6C8 19               add hl,de
120+  A6C9 3A 9F A6         ld a,(buffer_bufferhalf)    ; get the half
121+  A6CC FE 01            cp 1
122+  A6CE CA FB A6         jp z,buffer_bufferlinetoscreen4
123+  A6D1              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
124+  A6D1 D9               exx                         ; hl is now buffer
125+  A6D2 23               inc hl
126+  A6D3 23               inc hl                      ; move hl forward 2 to skip first two blocks
127+  A6D4 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
128+  A6D5 F1               pop af
129+  A6D6 C1               pop bc
130+  A6D7 D1               pop de
131+  A6D8 DD E1            pop ix
132+  A6DA D9               exx                         ; hl is now screen
133+  A6DB 08               ex af,af'
134+  A6DC F1               pop af
135+  A6DD C1               pop bc
136+  A6DE D1               pop de
137+  A6DF F9               ld sp,hl                    ; sp pointing at screen
138+  A6E0 D5               push de
139+  A6E1 C5               push bc
140+  A6E2 F5               push af
141+  A6E3 08               ex af,af'
142+  A6E4 D9               exx                         ; hl is now buffer
143+  A6E5 DD E5            push ix
144+  A6E7 D5               push de
145+  A6E8 C5               push bc
146+  A6E9 F5               push af
147+  A6EA 11 1E 00         ld de,30                    ; add thirty to get to next line
148+  A6ED 19               add hl,de
149+  A6EE F9               ld sp,hl                    ; sp pointing at buffer
150+  A6EF D9               exx                         ; hl is now screen
151+  A6F0 08               ex af,af'
152+  A6F1 24               inc h
153+  A6F2 7C               ld a,h
154+  A6F3 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
155+  A6F5 C2 D1 A6         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
156+  A6F8              buffer_bufferlinetoscreen1:
157+  A6F8 C3 2A A7         jp buffer_bufferlinetoscreen3
158+  A6FB              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
159+  A6FB D9               exx                         ; hl is buffer
160+  A6FC 11 10 00         ld de,16
161+  A6FF 19               add hl,de                   ; move halfway across
162+  A700 D9               exx                         ; hl is screen
163+  A701 11 0E 00         ld de,14
164+  A704 19               add hl,de
165+  A705              buffer_bufferlinetoscreen2:
166+  A705 D9               exx                         ; hl is now buffer
167+  A706 F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
168+  A707 F1               pop af
169+  A708 C1               pop bc
170+  A709 D1               pop de
171+  A70A DD E1            pop ix
172+  A70C D9               exx                         ; hl is now screen
173+  A70D 08               ex af,af'
174+  A70E F1               pop af
175+  A70F C1               pop bc
176+  A710 D1               pop de
177+  A711 F9               ld sp,hl                    ; sp pointing at screen
178+  A712 D5               push de
179+  A713 C5               push bc
180+  A714 F5               push af
181+  A715 08               ex af,af'
182+  A716 D9               exx                         ; hl is now buffer
183+  A717 DD E5            push ix
184+  A719 D5               push de
185+  A71A C5               push bc
186+  A71B F5               push af
187+  A71C 11 20 00         ld de,32                    ; add thirty two to get to next line
188+  A71F 19               add hl,de
189+  A720 F9               ld sp,hl                    ; sp pointing at buffer
190+  A721 D9               exx                         ; hl is now screen
191+  A722 08               ex af,af'
192+  A723 24               inc h
193+  A724 7C               ld a,h
194+  A725 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
195+  A727 C2 05 A7         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
196+  A72A              buffer_bufferlinetoscreen3:
197+  A72A 31 00 00         ld sp,0
198+  A72D D9               exx
199+  A72E C9               ret
200+  A72F
201+  A72F              ;
202+  A72F              ; Copies the buffer to the screen for updated lines. Use stack.
203+  A72F              ; Inputs: none
204+  A72F              ;
205+  A72F              buffer_buffertoscreen:
206+  A72F 3A 53 A6         ld a,(buffer_updateall)      ; get the all update flag
207+  A732 FE 00            cp 0
208+  A734 CA 40 A7         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
209+  A737 CD 70 A7         call buffer_allbuffertoscreen ; otherwise, draw whole screen
210+  A73A 21 53 A6         ld hl,buffer_updateall
211+  A73D 36 00            ld (hl),0                    ; reset flag
212+  A73F C9               ret
213+  A740              buffer_buffertoscreen2:
214+  A740 06 15            ld b,21
215+  A742 FD 21 3E A6      ld iy,buffer_updatedlines    ; the location of the updated lines
216+  A746              buffer_buffertoscreen0:
217+  A746 FD 7E 00         ld a,(iy)
218+  A749 FE FF            cp 255
219+  A74B CA 6F A7         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
220+  A74E 6F               ld l,a
221+  A74F 26 00            ld h,0
222+  A751 E6 20            and 32                      ; and with 32 to see if 6th bit is set
223+  A753 FE 20            cp 32                       ; if so, second half of screen
224+  A755 C2 60 A7         jp nz,buffer_buffertoscreen3
225+  A758 26 01            ld h,1                      ; store half in h
226+  A75A FD 7E 00         ld a,(iy)
227+  A75D D6 20            sub 32                      ; remove 32
228+  A75F 6F               ld l,a                      ; stor in line number
229+  A760              buffer_buffertoscreen3:
230+  A760 C5               push bc
231+  A761 FD E5            push iy
232+  A763 F3               di
233+  A764 CD A0 A6         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
234+  A767 FB               ei
235+  A768 FD E1            pop iy
236+  A76A C1               pop bc
237+  A76B FD 23            inc iy
238+  A76D 10 D7            djnz buffer_buffertoscreen0
239+  A76F              buffer_buffertoscreen1:
240+  A76F                  ;call buffer_buffertoattrsfast
241+  A76F C9               ret
242+  A770
243+  A770              ;
244+  A770              ; Copies the buffer to the screen. Use stack.
245+  A770              ; Inputs: none
246+  A770              ;
247+  A770              buffer_allbuffertoscreen:
248+  A770 06 15            ld b,21
249+  A772 3E 00            ld a,0
250+  A774              buffer_allbuffertoscreen0:
251+  A774 C5               push bc
252+  A775 F5               push af
253+  A776 F3               di
254+  A777 26 00            ld h,0
255+  A779 6F               ld l,a
256+  A77A CD A0 A6         call buffer_bufferlinetoscreen
257+  A77D FB               ei
258+  A77E F1               pop af
259+  A77F F5               push af
260+  A780 F3               di
261+  A781 26 01            ld h,1
262+  A783 6F               ld l,a
263+  A784 CD A0 A6         call buffer_bufferlinetoscreen
264+  A787 FB               ei
265+  A788 F1               pop af
266+  A789 C1               pop bc
267+  A78A 3C               inc a
268+  A78B 10 E7            djnz buffer_allbuffertoscreen0
269+  A78D F3               di
270+  A78E CD 93 A7         call buffer_buffertoattrsfast
271+  A791 FB               ei
272+  A792 C9               ret
273+  A793
274+  A793              ;
275+  A793              ; Copies the attrs buffer to screen with the stack
276+  A793              ;
277+  A793              buffer_buffertoattrsfast:
278+  A793 ED 73 02 A8      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
279+  A797 3A 06 A8         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
280+  A79A 11 20 00         ld de,32
281+  A79D CD 3A 80         call utilities_multiply
282+  A7A0 54 5D            ld de,hl
283+  A7A2 21 9C A2         ld hl,buffer_attr_buffer
284+  A7A5 19               add hl,de                       ; add the offset, start of attr buffer now in hl
285+  A7A6 D9               exx
286+  A7A7 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
287+  A7AA FD 21 3C A6      ld iy,buffer_tmp
288+  A7AE FD 36 00 15      ld (iy),21              ; number of times to loop
289+  A7B2              buffer_buffertoattrsfast0:
290+  A7B2 D9               exx                         ; hl is now buffer
291+  A7B3 23               inc hl
292+  A7B4 23               inc hl                      ; move hl forward 2 to skip first two blocks
293+  A7B5 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
294+  A7B6 F1               pop af
295+  A7B7 C1               pop bc
296+  A7B8 D1               pop de
297+  A7B9 DD E1            pop ix
298+  A7BB D9               exx                         ; hl is now screen
299+  A7BC 08               ex af,af'
300+  A7BD F1               pop af
301+  A7BE C1               pop bc
302+  A7BF D1               pop de
303+  A7C0 F9               ld sp,hl                    ; sp pointing at screen
304+  A7C1 D5               push de
305+  A7C2 C5               push bc
306+  A7C3 F5               push af
307+  A7C4 08               ex af,af'
308+  A7C5 D9               exx                         ; hl is now buffer
309+  A7C6 DD E5            push ix
310+  A7C8 D5               push de
311+  A7C9 C5               push bc
312+  A7CA F5               push af
313+  A7CB 1E 0E            ld e,14                    ; do another fourteen for right hand side
314+  A7CD 16 00            ld d,0
315+  A7CF 19               add hl,de
316+  A7D0 F9               ld sp,hl                    ; sp pointing at buffer
317+  A7D1 F1               pop af
318+  A7D2 C1               pop bc
319+  A7D3 D1               pop de
320+  A7D4 DD E1            pop ix
321+  A7D6 D9               exx                         ; hl is now screen
322+  A7D7 08               ex af,af'
323+  A7D8 1E 0E            ld e,14
324+  A7DA 16 00            ld d,0
325+  A7DC 19               add hl,de
326+  A7DD F1               pop af
327+  A7DE C1               pop bc
328+  A7DF D1               pop de
329+  A7E0 F9               ld sp,hl                    ; sp pointing at screen
330+  A7E1 D5               push de
331+  A7E2 C5               push bc
332+  A7E3 F5               push af
333+  A7E4 08               ex af,af'
334+  A7E5 D9               exx                         ; hl is now buffer
335+  A7E6 DD E5            push ix
336+  A7E8 D5               push de
337+  A7E9 C5               push bc
338+  A7EA F5               push af
339+  A7EB 1E 10            ld e,16
340+  A7ED 16 00            ld d,0
341+  A7EF 19               add hl,de
342+  A7F0 D9               exx                         ; hl is now screen
343+  A7F1 11 12 00         ld de,18
344+  A7F4 19               add hl,de
345+  A7F5 FD 7E 00         ld a,(iy)
346+  A7F8 3D               dec a
347+  A7F9 FE 00            cp 0
348+  A7FB FD 77 00         ld (iy),a
349+  A7FE C2 B2 A7         jp nz,buffer_buffertoattrsfast0 ; do another row
350+  A801              buffer_buffertoattrsfast1:
351+  A801 31 00 00         ld sp,0
352+  A804 D9               exx
353+  A805 C9               ret
# file closed: screen/buffer.asm
 24   A806                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A806              screen_offset:
  2+  A806 00               defb 0                      ; offset from top of screen in lines
  3+  A807
  4+  A807              screen_tmp:
  5+  A807 00 00            defb 0,0                      ; temporary memory
  6+  A809
  7+  A809              screen_setscorecolours:
  8+  A809 21 4F B5         ld hl,score_colours
  9+  A80C 11 00 58         ld de,22528                     ; attrs here
 10+  A80F 01 40 00         ld bc,64
 11+  A812 ED B0            ldir
 12+  A814 C9               ret
 13+  A815
 14+  A815              screen_sethighscorecolours:
 15+  A815 21 8F B5         ld hl,high_score_colours
 16+  A818 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A81B 01 20 00         ld bc,32
 18+  A81E ED B0            ldir
 19+  A820 C9               ret
 20+  A821
 21+  A821              ; Draw the screen
 22+  A821              ; Inputs:
 23+  A821              ; none
 24+  A821              ; Notes:
 25+  A821              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A821              screen_draw:
 27+  A821                  ;call clear_screen
 28+  A821 0E 00            ld c,0                      ; horiz
 29+  A823 06 00            ld b,0                      ; vert, 0 at top
 30+  A825 DD 21 11 B0      ld ix,level01               ; point ix at level data
 31+  A829 FD 21 9C A2      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A82D              screen_draw0:
 33+  A82D DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A830 C5               push bc                     ; store bc, contains loop count
 35+  A831 CD DE A9         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A834 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A835 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A838 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A83B CD A5 A9         call screen_getblock        ; get the block data into hl
 40+  A83E CD 82 A9         call screen_showchar        ; show this character here
 41+  A841 C1               pop bc                      ; get the loop counter back
 42+  A842 DD 23            inc ix                      ; increment level location
 43+  A844 FD 23            inc iy                      ; increment attr location
 44+  A846 0C               inc c                       ; increment horiz
 45+  A847 79               ld a,c
 46+  A848 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A84A C2 2D A8         jp nz,screen_draw0          ; if not, loop
 48+  A84D 0E 00            ld c,0                      ; if so, reset horiz
 49+  A84F 04               inc b                       ; increment vertical
 50+  A850 78               ld a,b
 51+  A851 FE 1D            cp 29                       ; check if at bottom
 52+  A853 C2 2D A8         jp nz,screen_draw0          ; if not, loop
 53+  A856 21 07 A8         ld hl, screen_tmp
 54+  A859 36 09            ld (hl),9                   ; load the block number into memory
 55+  A85B DD 21 B1 B3      ld ix,level01rocks          ; rock memory
 56+  A85F CD C0 A8         call screen_initobjects     ; draw rocks
 57+  A862 21 07 A8         ld hl, screen_tmp
 58+  A865 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A867 DD 21 B1 B4      ld ix,level01missiles       ; missile memory
 60+  A86B CD C0 A8         call screen_initobjects     ; draw missiles
 61+  A86E 21 07 A8         ld hl, screen_tmp
 62+  A871 36 08            ld (hl),08                  ; load the block number into memory
 63+  A873 DD 21 2A B5      ld ix,level01diamonds       ; diamond memory
 64+  A877 CD C0 A8         call screen_initobjects     ; draw diamonds
 65+  A87A 21 07 A8         ld hl, screen_tmp
 66+  A87D 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A87F DD 21 3A B5      ld ix,level01gems           ; gems memory
 68+  A883 CD C0 A8         call screen_initobjects     ; draw gems
 69+  A886 CD 8D A8         call screen_setuptext       ; draws text on the screen
 70+  A889 CD B6 C4         call scores_printscores     ; print the current scores
 71+  A88C C9               ret
 72+  A88D
 73+  A88D              ;
 74+  A88D              ; Sets up text on the screen
 75+  A88D              ;
 76+  A88D              screen_setuptext:
 77+  A88D CD D8 C4         call scores_showtable
 78+  A890 CD 15 A8         call screen_sethighscorecolours
 79+  A893 21 04 81         ld hl, string_score1
 80+  A896 CD 54 85         call string_print
 81+  A899 21 0D 81         ld hl, string_scorenumbers1
 82+  A89C CD 54 85         call string_print
 83+  A89F 21 16 81         ld hl, string_company
 84+  A8A2 CD 54 85         call string_print
 85+  A8A5 21 2B 81         ld hl, string_score2
 86+  A8A8 CD 54 85         call string_print
 87+  A8AB 21 34 81         ld hl, string_scorenumbers2
 88+  A8AE CD 54 85         call string_print
 89+  A8B1 21 20 81         ld hl, string_credits
 90+  A8B4 CD 54 85         call string_print
 91+  A8B7 CD 09 A8         call screen_setscorecolours
 92+  A8BA C9               ret
 93+  A8BB
 94+  A8BB              ;
 95+  A8BB              ; Sets a line of colours
 96+  A8BB              ; Inputs:
 97+  A8BB              ; a - colour to set
 98+  A8BB              ; b - number to set
 99+  A8BB              ; de - start memory location
100+  A8BB              ;
101+  A8BB              screen_setcolours:
102+  A8BB 12               ld (de),a
103+  A8BC 13               inc de
104+  A8BD 10 FC            djnz screen_setcolours
105+  A8BF C9               ret
106+  A8C0
107+  A8C0              ;
108+  A8C0              ; Draw initial object positions
109+  A8C0              ; Inputs:
110+  A8C0              ; ix - memory location of objects
111+  A8C0              ; a - graphic
112+  A8C0              screen_initobjects:
113+  A8C0 DD 4E 00         ld c,(ix)                   ; get the horiz coord
114+  A8C3 79               ld a,c
115+  A8C4 FE FF            cp 255
116+  A8C6 CA EF A8         jp z,screen_initobjects2
117+  A8C9 DD 23            inc ix                      ; move to next
118+  A8CB DD 46 00         ld b,(ix)                   ; get the vert coord
119+  A8CE DD 23            inc ix
120+  A8D0 CD 01 A9         call screen_getcellattradress ; get the memory address of b,c attr into de
121+  A8D3 D5               push de
122+  A8D4 3A 07 A8         ld a,(screen_tmp)                  ; get the block number back
123+  A8D7 CD DE A9         call screen_getattr         ; get the memory location for this cell's attr into hl
124+  A8DA D1               pop de
125+  A8DB 7E               ld a,(hl)                   ; get the attr value at the address
126+  A8DC 12               ld (de),a                   ; load the attr into memory
127+  A8DD 3A 07 A8         ld a,(screen_tmp)                  ; get the block number back
128+  A8E0 CD A5 A9         call screen_getblock        ; get the block data into hl
129+  A8E3 CD 82 A9         call screen_showchar        ; show this character here
130+  A8E6
131+  A8E6              screen_initobjects1:
132+  A8E6 DD 23            inc ix                      ; move past state
133+  A8E8 DD 23            inc ix
134+  A8EA DD 23            inc ix                      ; move past mem
135+  A8EC C3 C0 A8         jp screen_initobjects
136+  A8EF              screen_initobjects2:
137+  A8EF C9               ret
138+  A8F0
139+  A8F0
140+  A8F0              ;
141+  A8F0              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
142+  A8F0              ; Inputs:
143+  A8F0              ; bc: coords
144+  A8F0              ; Outputs:
145+  A8F0              ; de: memory location
146+  A8F0              ;
147+  A8F0              screen_getcelladdress:
148+  A8F0 78               ld a,b      ; vertical position.
149+  A8F1 E6 18            and 24      ; which segment, 0, 1 or 2?
150+  A8F3 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
151+  A8F5 57               ld d,a      ; this is our high byte.
152+  A8F6 78               ld a,b      ; what was that vertical position again?
153+  A8F7 E6 07            and 7       ; which row within segment?
154+  A8F9 0F               rrca        ; multiply row by 32.
155+  A8FA 0F               rrca
156+  A8FB 0F               rrca
157+  A8FC 5F               ld e,a      ; low byte.
158+  A8FD 79               ld a,c      ; add on y coordinate.
159+  A8FE 83               add a,e     ; mix with low byte.
160+  A8FF 5F               ld e,a      ; address of screen position in de.
161+  A900 C9               ret
162+  A901
163+  A901              ;
164+  A901              ; Calculate buffer address of attribute for character at (b, c).
165+  A901              ; Inputs:
166+  A901              ; bc: coords
167+  A901              ; Outputs:
168+  A901              ; de: memory location
169+  A901              ;
170+  A901              screen_getcellattradress:
171+  A901 11 9C A2         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
172+  A904 69               ld l,c      ; x position.
173+  A905 26 00            ld h,0      ; 0 h
174+  A907 19               add hl,de
175+  A908 54 5D            ld de,hl    ; horiz done
176+  A90A 78               ld a,b      ; do vert
177+  A90B D5               push de
178+  A90C C5               push bc
179+  A90D 11 20 00         ld de,32
180+  A910 CD 3A 80         call utilities_multiply
181+  A913 C1               pop bc
182+  A914 D1               pop de
183+  A915 19               add hl,de
184+  A916 54 5D            ld de,hl    ; vert done
185+  A918 C9               ret
186+  A919
187+  A919              ;
188+  A919              ; Calculate buffer address offset of attribute for character at (b, c).
189+  A919              ; Inputs:
190+  A919              ; bc: coords
191+  A919              ; Outputs:
192+  A919              ; de: memory location
193+  A919              ;
194+  A919              screen_getcellattroffset:
195+  A919 69               ld l,c      ; x position.
196+  A91A 26 00            ld h,0      ; 0 h
197+  A91C 54 5D            ld de,hl    ; horiz done
198+  A91E 78               ld a,b      ; do vert
199+  A91F D5               push de
200+  A920 C5               push bc
201+  A921 11 20 00         ld de,32
202+  A924 CD 3A 80         call utilities_multiply
203+  A927 C1               pop bc
204+  A928 D1               pop de
205+  A929 19               add hl,de
206+  A92A 54 5D            ld de,hl    ; vert done
207+  A92C C9               ret
208+  A92D
209+  A92D              ;
210+  A92D              ; Calculate buffer address of attribute for character at (b, c).
211+  A92D              ; Inputs:
212+  A92D              ; bc: coords
213+  A92D              ; Outputs:
214+  A92D              ; de: memory location
215+  A92D              ;
216+  A92D              screen_getscreenattradress:
217+  A92D 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
218+  A930 69               ld l,c      ; x position.
219+  A931 26 00            ld h,0      ; 0 h
220+  A933 19               add hl,de
221+  A934 54 5D            ld de,hl    ; horiz done
222+  A936 78               ld a,b      ; do vert
223+  A937 D5               push de
224+  A938 C5               push bc
225+  A939 11 20 00         ld de,32
226+  A93C CD 3A 80         call utilities_multiply
227+  A93F C1               pop bc
228+  A940 D1               pop de
229+  A941 19               add hl,de
230+  A942 54 5D            ld de,hl    ; vert done
231+  A944 C9               ret
232+  A945
233+  A945              ;
234+  A945              ; Gets the attr memory location for a screen coord
235+  A945              ; Will overwrite bc
236+  A945              ; Inputs:
237+  A945              ; bc - screen coords
238+  A945              ; Outputs:
239+  A945              ; de - memory location
240+  A945              ; bc - character coords
241+  A945              ;
242+  A945              screen_getattraddressfromscreencoords:
243+  A945 78               ld a,b                          ; get the player block coords of current block
244+  A946 E6 F8            and 248                         ; find closest multiple of eight
245+  A948 0F               rrca
246+  A949 0F               rrca
247+  A94A 0F               rrca                ; divide by 8
248+  A94B 47               ld b,a
249+  A94C 79               ld a,c
250+  A94D 48               ld c,b                         ; swap b and c
251+  A94E E6 F8            and 248
252+  A950 0F               rrca
253+  A951 0F               rrca
254+  A952 0F               rrca                ; divide by 8
255+  A953 47               ld b,a
256+  A954 CD 01 A9         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
257+  A957 C9               ret
258+  A958
259+  A958
260+  A958              ; Gets the nearest cell coords for a screen coord
261+  A958              ; Will overwrite bc
262+  A958              ; Inputs:
263+  A958              ; bc - screen coords
264+  A958              ; Outputs:
265+  A958              ; bc - character coords
266+  A958              ;
267+  A958              screen_getcharcoordsfromscreencoords:
268+  A958 78               ld a,b                          ; get the player block coords of current block
269+  A959 E6 F8            and 248                         ; find closest multiple of eight
270+  A95B 0F               rrca
271+  A95C 0F               rrca
272+  A95D 0F               rrca                ; divide by 8
273+  A95E 47               ld b,a
274+  A95F 79               ld a,c
275+  A960 48               ld c,b                         ; swap b and c
276+  A961 E6 F8            and 248
277+  A963 0F               rrca
278+  A964 0F               rrca
279+  A965 0F               rrca                ; divide by 8
280+  A966 47               ld b,a
281+  A967 C9               ret
282+  A968
283+  A968              ; Gets the screen coords for a cell coord
284+  A968              ; Will overwrite bc
285+  A968              ; Inputs:
286+  A968              ; bc - char coords
287+  A968              ; Outputs:
288+  A968              ; bc - screen coords
289+  A968              ;
290+  A968              screen_getscreencoordsfromcharcoords:
291+  A968 78               ld a,b                          ; get the player block coords of current block
292+  A969 07               rlca
293+  A96A 07               rlca
294+  A96B 07               rlca                ; multiply by 8
295+  A96C 47               ld b,a
296+  A96D 79               ld a,c
297+  A96E 48               ld c,b                         ; swap b and c
298+  A96F 07               rlca
299+  A970 07               rlca
300+  A971 07               rlca                ; divide by 8
301+  A972 47               ld b,a
302+  A973 C9               ret
303+  A974
304+  A974              ;
305+  A974              ; Get buffer address for a character at b,c - b vert
306+  A974              ; Buffer memory is stored as sequential block
307+  A974              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
308+  A974              ; Inputs:
309+  A974              ; bc - coords
310+  A974              ; Outputs:
311+  A974              ; de - memory location of first byte
312+  A974              screen_getbufferaddress:
313+  A974 21 9C 85         ld hl, buffer_buffer    ; first get screen buffer start
314+  A977 50               ld d,b                  ; then work out vertical offset
315+  A978 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
316+  A97A 19               add hl,de               ; add to base
317+  A97B 59               ld e,c                  ; then add horizontal offset (c)
318+  A97C 16 00            ld d,0
319+  A97E 19               add hl,de               ; add to base
320+  A97F 54 5D            ld de,hl
321+  A981 C9               ret
322+  A982
323+  A982              ;
324+  A982              ; Display character hl at (b, c) to buffer.
325+  A982              ; Stored sequentially
326+  A982              ; Inputs:
327+  A982              ; hl: block address
328+  A982              ; bc: coords
329+  A982              ;
330+  A982              screen_showchar:
331+  A982 ED 43 41 AB      ld (origcoords),bc   ; store char coords
332+  A986 3E 00            ld a,0
333+  A988 E5               push hl
334+  A989 CD 74 A9         call screen_getbufferaddress ; get the current screen buffer pointer
335+  A98C E1               pop hl
336+  A98D 06 08            ld b,8              ; number of pixels high.
337+  A98F              screen_showchar0:
338+  A98F 7E               ld a,(hl)           ; source graphic.
339+  A990 12               ld (de),a           ; transfer to screen.
340+  A991 23               inc hl              ; next piece of data.
341+  A992 E5               push hl             ; store hl
342+  A993 62 6B            ld hl,de            ; put de in hl
343+  A995 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
344+  A997 16 00            ld d,0
345+  A999 19               add hl,de              ; add de to hl
346+  A99A 54 5D            ld de,hl            ; load back to de
347+  A99C E1               pop hl              ; restore hl
348+  A99D
349+  A99D 10 F0            djnz screen_showchar0 ; repeat
350+  A99F 2E 01            ld l,1
351+  A9A1 CD F2 AA         call sprites_marklinesforupdatechar
352+  A9A4
353+  A9A4 C9               ret
354+  A9A5
355+  A9A5
356+  A9A5              ;
357+  A9A5              ; Get cell graphic.
358+  A9A5              ; Inputs:
359+  A9A5              ; a: block
360+  A9A5              ; Outputs:
361+  A9A5              ; hl: memory
362+  A9A5              ;
363+  A9A5              screen_getblock:
364+  A9A5 07               rlca                        ; multiply block number by eight.
365+  A9A6 07               rlca
366+  A9A7 07               rlca
367+  A9A8 5F               ld e,a                      ; displacement to graphic address.
368+  A9A9 16 00            ld d,0                      ; no high byte.
369+  A9AB 21 AF B5         ld hl,sprites               ; address of character blocks.
370+  A9AE 19               add hl,de                   ; point to block.
371+  A9AF C9               ret
372+  A9B0
373+  A9B0              ;
374+  A9B0              ; Set a the attr of a coord
375+  A9B0              ; Inputs:
376+  A9B0              ; bc - char coords
377+  A9B0              ; a - attr
378+  A9B0              ;
379+  A9B0              screen_setattr:
380+  A9B0 DD E5            push ix
381+  A9B2 C5               push bc
382+  A9B3 08               ex af, af'
383+  A9B4 CD 19 A9         call screen_getcellattroffset   ; get offset into de
384+  A9B7 21 9C A2         ld hl,buffer_attr_buffer
385+  A9BA 19               add hl,de                       ; get the memory location
386+  A9BB 08               ex af, af'                      ; get attr back
387+  A9BC 77               ld (hl),a                         ; set the attr
388+  A9BD 08               ex af, af'                      ; get attr back
389+  A9BE ED 5B 06 A8      ld de,(screen_offset)           ; get the offset
390+  A9C2 78               ld a,b                          ; get the vertical
391+  A9C3 93               sub e                           ; subtract the offset
392+  A9C4 DA DA A9         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
393+  A9C7 FE 15            cp 21
394+  A9C9 D2 DA A9         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
395+  A9CC 47               ld b,a                          ; put the coord back in b
396+  A9CD CD 2D A9         call screen_getscreenattradress ; screen attr address in de
397+  A9D0 21 40 00         ld hl,64                        ; attr memory + two rows for scores
398+  A9D3 19               add hl,de
399+  A9D4 08               ex af, af'                      ; get attr back
400+  A9D5 77               ld (hl),a
401+  A9D6 C1               pop bc
402+  A9D7 DD E1            pop ix
403+  A9D9 C9               ret
404+  A9DA              screen_setattr0:
405+  A9DA C1               pop bc
406+  A9DB DD E1            pop ix
407+  A9DD C9               ret
408+  A9DE
409+  A9DE              ;
410+  A9DE              ; Get cell attribute.
411+  A9DE              ; Inputs:
412+  A9DE              ; a: block
413+  A9DE              ; Outputs:
414+  A9DE              ; hl: memory
415+  A9DE              ;
416+  A9DE              screen_getattr:
417+  A9DE 5F               ld e,a                      ; displacement to attribute address.
418+  A9DF 16 00            ld d,0                      ; no high byte.
419+  A9E1 21 8F B6         ld hl,sprite_attrs          ; address of block attributes.
420+  A9E4 19               add hl,de                   ; point to attribute.
421+  A9E5 C9               ret
422+  A9E6
423+  A9E6              ;
424+  A9E6              ; Checks whether a character block has anything in it
425+  A9E6              ; Inputs:
426+  A9E6              ; bc - char coords
427+  A9E6              ; Outputs:
428+  A9E6              ; a - 1, empty
429+  A9E6              screen_ischarempty:
430+  A9E6 CD 74 A9         call screen_getbufferaddress ; get the current screen buffer pointer
431+  A9E9 06 08            ld b,8                      ; check 8 rows
432+  A9EB              screen_ischarempty2:
433+  A9EB 1A               ld a,(de)                   ; check line
434+  A9EC FE 00            cp 0
435+  A9EE C2 FC A9         jp nz,screen_ischarempty1   ; if not zero, jump out with false
436+  A9F1 21 20 00         ld hl,32
437+  A9F4 19               add hl,de
438+  A9F5 54 5D            ld de,hl                    ; move to next row
439+  A9F7 10 F2            djnz screen_ischarempty2
440+  A9F9              screen_ischarempty0:
441+  A9F9 3E 01            ld a,1
442+  A9FB C9               ret
443+  A9FC              screen_ischarempty1:
444+  A9FC 3E 00            ld a,0
445+  A9FE C9               ret
446+  A9FF
447+  A9FF              ;
448+  A9FF              ; Copies a block from one place to another directly underneath, leaves the original empty
449+  A9FF              ; Inputs:
450+  A9FF              ; bc - coords of block to copy from
451+  A9FF              screen_copyblockdown
452+  A9FF CD 74 A9         call screen_getbufferaddress ; get the current screen buffer pointer for source
453+  AA02 06 08            ld b,8                      ; copy 8 rows
454+  AA04              screen_copyblock0:
455+  AA04 1A               ld a,(de)                    ; get what we're copying
456+  AA05 08               ex af,af'
457+  AA06 3E 00            ld a,0
458+  AA08 12               ld (de),a                    ; replace with empty
459+  AA09 08               ex af,af'
460+  AA0A 14               inc d                        ; add 256 to get to the next row
461+  AA0B 12               ld (de),a                    ; copy to the next row
462+  AA0C 15               dec d
463+  AA0D 21 20 00         ld hl,32
464+  AA10 19               add hl,de                       ; return back to source, next row down
465+  AA11 54 5D            ld de,hl
466+  AA13 10 EF            djnz screen_copyblock0
467+  AA15 C9               ret
468+  AA16
469+  AA16              ;
470+  AA16              ; Returns the first byte of a character. Useful for figuring out what's there
471+  AA16              ; Inputs:
472+  AA16              ; bc - coords
473+  AA16              ; Outputs:
474+  AA16              ; a - first byte
475+  AA16              ;
476+  AA16              screen_getcharfirstbyte:
477+  AA16 CD 74 A9         call screen_getbufferaddress ; get the current screen buffer pointer for source
478+  AA19 1A               ld a,(de)
479+  AA1A C9               ret
480+  AA1B
# file closed: screen/screen.asm
 25   AA1B                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  AA1B              ;
  2+  AA1B              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  AA1B              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  AA1B              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  AA1B              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  AA1B              ; routine takes care of all the shifting itself. This means that sprite
  7+  AA1B              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  AA1B              ; space they would require in pre-shifted form.
  9+  AA1B              ; Inputs:
 10+  AA1B              ; hl - sprite data
 11+  AA1B              ; bc - screen coords
 12+  AA1B              ;
 13+  AA1B              sprites_drawsprite7:
 14+  AA1B EE 07            xor 7               ; complement last 3 bits.
 15+  AA1D 3C               inc a               ; add one for luck!
 16+  AA1E              sprites_drawsprite3:
 17+  AA1E CB 11            rl c                ; ...into middle byte...
 18+  AA20 CB 12            rl d                ; ...and finally into left character cell.
 19+  AA22 3D               dec a               ; count shifts we've done.
 20+  AA23 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  AA25                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  AA25 79               ld a,c              ; left edge of image is currently in e.
 23+  AA26 4A               ld c,d              ; put right edge there instead.
 24+  AA27 57               ld d,a              ; and the left edge back into c.
 25+  AA28 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  AA2A              sprites_drawsprite:
 27+  AA2A ED 43 41 AB      ld (origcoords),bc  ; store coords
 28+  AA2E ED 43 43 AB      ld (dispx),bc       ; store coords in dispx for now.
 29+  AA32 E5               push hl
 30+  AA33 CD 1F AB         call sprites_scadd  ; calculate screen address.
 31+  AA36 E1               pop hl
 32+  AA37 3E 08            ld a,8              ; height of sprite in pixels.
 33+  AA39              sprites_drawsprite1:
 34+  AA39 08               ex af,af'           ; store loop counter.
 35+  AA3A D5               push de             ; store screen address.
 36+  AA3B 4E               ld c,(hl)           ; first sprite graphic.
 37+  AA3C 23               inc hl              ; increment poiinter to sprite data.
 38+  AA3D 22 45 AB         ld (sprtmp),hl      ; store it for later.
 39+  AA40 16 00            ld d,0              ; blank right byte for now.
 40+  AA42 78               ld a,b              ; b holds y position.
 41+  AA43 E6 07            and 7               ; how are we straddling character cells?
 42+  AA45 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  AA47 FE 05            cp 5                ; 5 or more right shifts needed?
 44+  AA49 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  AA4B A7               and a               ; oops, carry flag is set so clear it.
 46+  AA4C              sprites_drawsprite2:
 47+  AA4C CB 19            rr c                ; rotate left byte right...
 48+  AA4E CB 1A            rr d                ; ...into right byte.
 49+  AA50 3D               dec a               ; one less shift to do.
 50+  AA51 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  AA53              sprites_drawsprite0:
 52+  AA53 E1               pop hl              ; pop screen address from stack.
 53+  AA54 7E               ld a,(hl)           ; what's there already.
 54+  AA55 A9               xor c               ; merge in image data.
 55+  AA56 77               ld (hl),a           ; place onto screen.
 56+  AA57 23               inc hl
 57+  AA58 7E               ld a,(hl)           ; what's already there.
 58+  AA59 AA               xor d               ; right edge of sprite image data.
 59+  AA5A 77               ld (hl),a           ; plonk it on screen.
 60+  AA5B 3A 43 AB         ld a,(dispx)        ; vertical coordinate.
 61+  AA5E 3C               inc a               ; next line down.
 62+  AA5F 32 43 AB         ld (dispx),a        ; store new position.
 63+  AA62 2B               dec hl
 64+  AA63 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  AA66 19               add hl,de           ; add 32
 66+  AA67              sprites_drawsprite6:
 67+  AA67 EB               ex de,hl            ; screen address in de.
 68+  AA68 2A 45 AB         ld hl,(sprtmp)      ; restore graphic address.
 69+  AA6B 08               ex af,af'           ; restore loop counter.
 70+  AA6C 3D               dec a               ; decrement it.
 71+  AA6D C2 39 AA         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  AA70 2E 02            ld l,2
 73+  AA72 CD E1 AA         call sprites_marklinesforupdatescreen
 74+  AA75 C9               ret                 ; job done.
 75+  AA76
 76+  AA76              ; Inputs:
 77+  AA76              ; hl - sprite data
 78+  AA76              ; bc - screen coords
 79+  AA76              ;
 80+  AA76              sprites_draw2by2sprite7
 81+  AA76 EE 07            xor 7               ; complement last 3 bits.
 82+  AA78 3C               inc a               ; add one for luck!
 83+  AA79              sprites_draw2by2sprite3
 84+  AA79 CB 12            rl d                ; rotate left...
 85+  AA7B CB 11            rl c                ; ...into middle byte...
 86+  AA7D CB 13            rl e                ; ...and finally into left character cell.
 87+  AA7F 3D               dec a               ; count shifts we've done.
 88+  AA80 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  AA82                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  AA82 7B               ld a,e              ; left edge of image is currently in e.
 91+  AA83 5A               ld e,d              ; put right edge there instead.
 92+  AA84 51               ld d,c              ; middle bit goes in d.
 93+  AA85 4F               ld c,a              ; and the left edge back into c.
 94+  AA86 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  AA88              sprites_draw2by2sprite
 96+  AA88 ED 43 41 AB      ld (origcoords),bc  ; store coords
 97+  AA8C ED 43 43 AB      ld (dispx),bc       ; store coords in dispx for now.
 98+  AA90 79               ld a,c
 99+  AA91 32 47 AB         ld (sprtmp0),a         ; store vertical.
100+  AA94 E5               push hl
101+  AA95 CD 1F AB         call sprites_scadd          ; calculate screen address.
102+  AA98 E1               pop hl
103+  AA99 3E 10            ld a,16             ; height of sprite in pixels.
104+  AA9B              sprites_draw2by2sprite1
105+  AA9B 08               ex af,af'           ; store loop counter.
106+  AA9C D5               push de             ; store screen address.
107+  AA9D 4E               ld c,(hl)           ; first sprite graphic.
108+  AA9E 23               inc hl              ; increment poiinter to sprite data.
109+  AA9F 56               ld d,(hl)           ; next bit of sprite image.
110+  AAA0 23               inc hl              ; point to next row of sprite data.
111+  AAA1 22 45 AB         ld (sprtmp),hl        ; store in tmp0 for later.
112+  AAA4 1E 00            ld e,0              ; blank right byte for now.
113+  AAA6 78               ld a,b              ; b holds y position.
114+  AAA7 E6 07            and 7               ; how are we straddling character cells?
115+  AAA9 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  AAAB FE 05            cp 5                ; 5 or more right shifts needed?
117+  AAAD 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  AAAF A7               and a               ; oops, carry flag is set so clear it.
119+  AAB0              sprites_draw2by2sprite2
120+  AAB0 CB 19            rr c                ; rotate left byte right...
121+  AAB2 CB 1A            rr d                ; ...through middle byte...
122+  AAB4 CB 1B            rr e                ; ...into right byte.
123+  AAB6 3D               dec a               ; one less shift to do.
124+  AAB7 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  AAB9              sprites_draw2by2sprite0
126+  AAB9 E1               pop hl              ; pop screen address from stack.
127+  AABA 7E               ld a,(hl)           ; what's there already.
128+  AABB A9               xor c               ; merge in image data.
129+  AABC 77               ld (hl),a           ; place onto screen.
130+  AABD 23               inc hl               ; next character cell to right please.
131+  AABE 7E               ld a,(hl)           ; what's there already.
132+  AABF AA               xor d               ; merge with middle bit of image.
133+  AAC0 77               ld (hl),a           ; put back onto screen.
134+  AAC1 23               inc hl              ; next bit of screen area.
135+  AAC2 7E               ld a,(hl)           ; what's already there.
136+  AAC3 AB               xor e               ; right edge of sprite image data.
137+  AAC4 77               ld (hl),a           ; plonk it on screen.
138+  AAC5 3A 47 AB         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  AAC8 3C               inc a               ; next line down.
140+  AAC9 32 47 AB         ld (sprtmp0),a         ; store new position.
141+  AACC 2B               dec hl
142+  AACD 2B               dec hl
143+  AACE 11 20 00         ld de,32            ; add 32 to get to the next row
144+  AAD1 19               add hl,de           ; add 32
145+  AAD2              sprites_draw2by2sprite6
146+  AAD2 EB               ex de,hl            ; screen address in de.
147+  AAD3 2A 45 AB         ld hl,(sprtmp)        ; restore graphic address.
148+  AAD6 08               ex af,af'           ; restore loop counter.
149+  AAD7 3D               dec a               ; decrement it.
150+  AAD8 C2 9B AA         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  AADB 2E 03            ld l,3
152+  AADD CD E1 AA         call sprites_marklinesforupdatescreen
153+  AAE0 C9               ret                 ; job done.
154+  AAE1
155+  AAE1              ;
156+  AAE1              ; Marks lines for update with screen coords
157+  AAE1              ; Inputs:
158+  AAE1              ; l - number to update
159+  AAE1              ;
160+  AAE1              sprites_marklinesforupdatescreen:
161+  AAE1 F5               push af
162+  AAE2 ED 4B 41 AB      ld bc,(origcoords)
163+  AAE6 CD 58 A9         call screen_getcharcoordsfromscreencoords
164+  AAE9 ED 43 41 AB      ld (origcoords),bc
165+  AAED CD FC AA         call sprites_marklinesforupdate
166+  AAF0 F1               pop af
167+  AAF1 C9               ret
168+  AAF2
169+  AAF2              ;
170+  AAF2              ; Marks lines for update with char coords
171+  AAF2              ; Inputs:
172+  AAF2              ; l - number to update
173+  AAF2              ;
174+  AAF2              sprites_marklinesforupdatechar:
175+  AAF2 F5               push af
176+  AAF3 ED 43 41 AB      ld (origcoords),bc
177+  AAF7 CD FC AA         call sprites_marklinesforupdate
178+  AAFA F1               pop af
179+  AAFB C9               ret
180+  AAFC
181+  AAFC              ;
182+  AAFC              ; Marks lines for update
183+  AAFC              ; Inputs:
184+  AAFC              ; l - number to update
185+  AAFC              ;
186+  AAFC              sprites_marklinesforupdate:
187+  AAFC ED 4B 41 AB      ld bc,(origcoords)
188+  AB00 ED 5B 06 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
189+  AB04 78               ld a,b
190+  AB05 93               sub e
191+  AB06 47               ld b,a
192+  AB07 7D               ld a,l                          ; get loop counter
193+  AB08              sprites_marklinesforupdate0:
194+  AB08 C5               push bc
195+  AB09 08               ex af,af'                     ; store loop counter
196+  AB0A 78               ld a,b
197+  AB0B CD 54 A6         call buffer_marklineforupdate ; mark this line for update
198+  AB0E ED 4B 41 AB      ld bc,(origcoords)            ; move the coords for the next line
199+  AB12 04               inc b
200+  AB13 ED 43 41 AB      ld (origcoords),bc
201+  AB17 C1               pop bc
202+  AB18 04               inc b
203+  AB19 08               ex af,af'                     ; restore loop counter
204+  AB1A 3D               dec a
205+  AB1B C2 08 AB         jp nz,sprites_marklinesforupdate0
206+  AB1E C9               ret
207+  AB1F
208+  AB1F              ;
209+  AB1F              ; This routine returns a buffer address for (c, b) in de (c vert).
210+  AB1F              ; For example: 0,0 will be at memory offset 0
211+  AB1F              ; 1,0 (1 down) will be at memory offset 1
212+  AB1F              ; 0,7 will be at memory offset 0
213+  AB1F              ; 9,1 will be at memory offset 8+1
214+  AB1F              ; 8,0 will be at memory offset 256
215+  AB1F              ; 9,0 will be at memory offset 257
216+  AB1F              ; Outputs:
217+  AB1F              ; de - coords
218+  AB1F              ;
219+  AB1F              sprites_scadd:
220+  AB1F 79               ld a,c               ; calculate vertical offset
221+  AB20 E6 F8            and 248             ;  to get nearest multiple of 8
222+  AB22 0F               rrca
223+  AB23 0F               rrca
224+  AB24 0F               rrca                ; divide by 8
225+  AB25 67               ld h,a
226+  AB26 78               ld a,b               ; calculate horizontal offset
227+  AB27 E6 F8            and 248             ;  to get nearest multiple of 8
228+  AB29 0F               rrca
229+  AB2A 0F               rrca
230+  AB2B 0F               rrca                ; divide by 8
231+  AB2C 6F               ld l,a
232+  AB2D C5               push bc             ; store the screen coords
233+  AB2E 44 4D            ld bc,hl            ; load bc with the character coords
234+  AB30 CD 74 A9         call screen_getbufferaddress
235+  AB33 C1               pop bc              ; get back screen coords, de is now memory of character
236+  AB34 79               ld a,c              ; now add the vertical within the cell
237+  AB35 E6 07            and 7
238+  AB37 0F               rrca                ; multiply by 32.
239+  AB38 0F               rrca
240+  AB39 0F               rrca
241+  AB3A 6F               ld l,a
242+  AB3B 26 00            ld h,0
243+  AB3D 19               add hl,de
244+  AB3E 54 5D            ld de,hl
245+  AB40 C9               ret
246+  AB41
247+  AB41 00 00        origcoords   defb 0,0           ; general-use coordinates.
248+  AB43
249+  AB43 00           dispx   defb 0           ; general-use coordinates.
250+  AB44 00           dispy   defb 0
251+  AB45 00 00        sprtmp  defb 0,0           ; sprite temporary address.
252+  AB47 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
253+  AB49
# file closed: screen/sprites.asm
 26   AB49                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AB49              ;
  2+  AB49              ; Draws the title screen
  3+  AB49              ;
  4+  AB49              titlescreen_show:
  5+  AB49 CD DB AB         call titlescreen_init
  6+  AB4C CD 84 AB         call titlescreen_drawtitle
  7+  AB4F 3A 5E BD         ld a,(game_control)
  8+  AB52 FE 00            cp 0
  9+  AB54 CA 5C AB         jp z,titlescreen_show1
 10+  AB57 06 32            ld b,50
 11+  AB59 CD 99 80         call utilities_pauseforframes         ; pause for a second
 12+  AB5C              titlescreen_show1:
 13+  AB5C 3E FA            ld a,250                              ; wait for 200 frames
 14+  AB5E CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 15+  AB61 7B               ld a,e
 16+  AB62 FE 01            cp 1                                  ; was anything pressed?
 17+  AB64 C8               ret z                                 ; end titlescreen if so
 18+  AB65
 19+  AB65 CD EE AB         call titlescreen_alt_init             ; otherwise, draw alt screen
 20+  AB68 CD A0 AB         call titlescreen_alt_drawtitle
 21+  AB6B 3A 5E BD         ld a,(game_control)
 22+  AB6E FE 00            cp 0
 23+  AB70 CA 78 AB         jp z,titlescreen_show0
 24+  AB73 06 32            ld b,50
 25+  AB75 CD 99 80         call utilities_pauseforframes         ; pause for a second if joystick
 26+  AB78              titlescreen_show0:
 27+  AB78 3E FA            ld a,250                              ; wait for 200 frames
 28+  AB7A CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 29+  AB7D 7B               ld a,e
 30+  AB7E FE 01            cp 1                                  ; was anything pressed?
 31+  AB80 C2 49 AB         jp nz,titlescreen_show                ; start again if not
 32+  AB83 C9               ret
 33+  AB84
 34+  AB84              ;
 35+  AB84              ; Draws the iconic logo
 36+  AB84              ;
 37+  AB84              titlescreen_drawtitle:
 38+  AB84 06 67            ld b,103              ; number of points
 39+  AB86 DD 21 FB AB      ld ix,titlescreen_logo_data
 40+  AB8A              titlescreen_drawtitle0:
 41+  AB8A C5               push bc
 42+  AB8B DD 4E 00         ld c,(ix)                   ; got horiz
 43+  AB8E DD 23            inc ix
 44+  AB90 DD 46 00         ld b,(ix)                   ; got vert
 45+  AB93 DD 23            inc ix
 46+  AB95 CD 2D A9         call screen_getscreenattradress ; memory in de
 47+  AB98 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 48+  AB99 3E 13            ld a,19
 49+  AB9B 12               ld (de),a
 50+  AB9C C1               pop bc
 51+  AB9D 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 52+  AB9F C9               ret
 53+  ABA0
 54+  ABA0              ;
 55+  ABA0              ; Draws the alternate title screen
 56+  ABA0              ;
 57+  ABA0              titlescreen_alt_drawtitle:
 58+  ABA0 21 52 81         ld hl,string_alttitlescreen_1
 59+  ABA3 CD 54 85         call string_print
 60+  ABA6 21 5E 81         ld hl,string_alttitlescreen_2
 61+  ABA9 CD 54 85         call string_print
 62+  ABAC 21 59 82         ld hl,string_alttitlescreen_3
 63+  ABAF CD 54 85         call string_print
 64+  ABB2 06 20            ld b,32
 65+  ABB4 3E 43            ld a,67
 66+  ABB6 11 00 58         ld de,22528                         ; top row attrs here
 67+  ABB9 CD BB A8         call screen_setcolours
 68+  ABBC 06 20            ld b,32
 69+  ABBE 3E 46            ld a,70
 70+  ABC0 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 71+  ABC3 CD BB A8         call screen_setcolours
 72+  ABC6 06 20            ld b,32
 73+  ABC8 3E 43            ld a,67
 74+  ABCA 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 75+  ABCD CD BB A8         call screen_setcolours
 76+  ABD0 06 20            ld b,32
 77+  ABD2 3E 42            ld a,66
 78+  ABD4 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 79+  ABD7 CD BB A8         call screen_setcolours
 80+  ABDA C9               ret
 81+  ABDB
 82+  ABDB              ;
 83+  ABDB              ; Initialises the screen
 84+  ABDB              ;
 85+  ABDB              titlescreen_init:
 86+  ABDB              ; We want a black screen.
 87+  ABDB 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 88+  ABDD                                      ; bright (64).
 89+  ABDD CD 7E 80         call utilities_clearscreen
 90+  ABE0 32 8D 5C         ld (23693),a        ; set our screen colours.
 91+  ABE3 3E 01            ld a,1              ; 2 is the code for red.
 92+  ABE5 D3 FE            out (254),a         ; write to port 254.
 93+  ABE7
 94+  ABE7 21 3D 81         ld hl,string_titlescreen_copyright
 95+  ABEA CD 54 85         call string_print
 96+  ABED
 97+  ABED C9               ret
 98+  ABEE
 99+  ABEE              ;
100+  ABEE              ; Initialises the screen
101+  ABEE              ;
102+  ABEE              titlescreen_alt_init:
103+  ABEE              ; We want a black screen.
104+  ABEE 3E 47            ld a,71             ; white ink (7) on black paper (0),
105+  ABF0                                      ; bright (64).
106+  ABF0 CD 7E 80         call utilities_clearscreen
107+  ABF3 32 8D 5C         ld (23693),a        ; set our screen colours.
108+  ABF6 3E 00            ld a,0              ; 2 is the code for red.
109+  ABF8 D3 FE            out (254),a         ; write to port 254.
110+  ABFA
111+  ABFA C9               ret
112+  ABFB
113+  ABFB              ;
114+  ABFB              ; Horiz, vert
115+  ABFB              ;
116+  ABFB              titlescreen_logo_data:
117+  ABFB 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
117+  ABFF 0A 00 0C 00
117+  AC03 0F 00 11 00
117+  AC07 12 00 13 00
118+  AC0B 09 01 0C 01      defb 9,1,12,1,15,1,17,1
118+  AC0F 0F 01 11 01
119+  AC13 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
119+  AC17 0D 02 0E 02
119+  AC1B 0F 02 11 02
119+  AC1F 12 02 13 02
120+  AC23 09 03 0C 03      defb 9,3,12,3,15,3,17,3
120+  AC27 0F 03 11 03
121+  AC2B 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
121+  AC2F 0F 04 11 04
121+  AC33 12 04 13 04
122+  AC37 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
122+  AC3B 02 06 03 06
122+  AC3F 04 06 05 06
122+  AC43 06 06 07 06
122+  AC47 08 06 09 06
122+  AC4B 0A 06 0B 06
123+  AC4F 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
123+  AC53 12 06 13 06
123+  AC57 14 06 15 06
123+  AC5B 16 06 17 06
123+  AC5F 18 06 19 06
123+  AC63 1A 06 1B 06
124+  AC67 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
124+  AC6B 02 09 02 0A
124+  AC6F 02 0B 02 0C
124+  AC73 02 0D 02 0E
124+  AC77 02 0F 02 10
124+  AC7B 02 11 02 12
124+  AC7F 02 13 02 14
124+  AC83 02 15
125+  AC85 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
125+  AC89 19 09 19 0A
125+  AC8D 19 0B 19 0C
125+  AC91 19 0D 19 0E
125+  AC95 19 0F 19 10
125+  AC99 19 11 19 12
125+  AC9D 19 13 19 14
125+  ACA1 19 15
126+  ACA3 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
126+  ACA7 05 0B 06 0B
126+  ACAB 07 0B 08 0B
126+  ACAF 09 0B 0A 0B
126+  ACB3 0B 0B
127+  ACB5 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
127+  ACB9 0B 09 0B 0A
128+  ACBD 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
128+  ACC1 10 10 10 11
128+  ACC5 10 12 10 13
129+  ACC9
# file closed: screen/titlescreen.asm
 27   ACC9                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ACC9              ;
  2+  ACC9              ; Draws the life remaining screen
  3+  ACC9              ;
  4+  ACC9              lifescreen_draw:
  5+  ACC9 CD 1C AD         call lifescreen_init
  6+  ACCC
  7+  ACCC 3A 5B BD         ld a,(game_currentplayer)             ; get the current player
  8+  ACCF C6 30            add 48                                ; add 48 to get char
  9+  ACD1 21 5F 83         ld hl,string_lifescreen_player+10
 10+  ACD4 77               ld (hl),a                             ; load this to the string we're about to show
 11+  ACD5
 12+  ACD5 21 55 83         ld hl,string_lifescreen_player
 13+  ACD8 CD 54 85         call string_print
 14+  ACDB
 15+  ACDB 3A 9B BD         ld a,(player+9)                       ; get the current player lives
 16+  ACDE C6 30            add 48                                ; add 48 to get the character
 17+  ACE0 FE 31            cp 49
 18+  ACE2 C2 F5 AC         jp nz,lifescreen_draw0
 19+  ACE5 21 6F 83         ld hl,string_lifescreen_lastman
 20+  ACE8
 21+  ACE8 06 08            ld b,8
 22+  ACEA 3E 0A            ld a,10                                ; set red
 23+  ACEC 11 6C 58         ld de,22528+108                        ; attrs here
 24+  ACEF CD BB A8         call screen_setcolours
 25+  ACF2
 26+  ACF2 C3 FC AC         jp lifescreen_draw1
 27+  ACF5              lifescreen_draw0:
 28+  ACF5 21 64 83         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  ACF8 77               ld (hl),a                             ; load this to the string we're about to show
 30+  ACF9 21 62 83         ld hl,string_lifescreen_lives
 31+  ACFC              lifescreen_draw1:
 32+  ACFC CD 54 85         call string_print
 33+  ACFF
 34+  ACFF 3E 86            ld a,134
 35+  AD01 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AD04 06 0A            ld b,10
 37+  AD06 CD BB A8         call screen_setcolours
 38+  AD09 3A 5E BD         ld a,(game_control)
 39+  AD0C FE 00            cp 0
 40+  AD0E CA 16 AD         jp z,lifescreen_draw2
 41+  AD11 06 32            ld b,50
 42+  AD13 CD 99 80         call utilities_pauseforframes         ; pause for a second if joystick
 43+  AD16              lifescreen_draw2:
 44+  AD16 3E 64            ld a,100                              ; wait for 200 frames
 45+  AD18 CD 5C 80         call utilities_waitforkey_forframes   ; wait for keypress
 46+  AD1B
 47+  AD1B C9               ret
 48+  AD1C
 49+  AD1C              ;
 50+  AD1C              ; Initialises the screen
 51+  AD1C              ;
 52+  AD1C              lifescreen_init:
 53+  AD1C              ; We want a blue screen.
 54+  AD1C                  ;call $0D6B
 55+  AD1C 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 56+  AD1E                                      ; bright (64).
 57+  AD1E CD 7E 80         call utilities_clearscreen
 58+  AD21 32 8D 5C         ld (23693),a        ; set our screen colours.
 59+  AD24 3E 01            ld a,1              ; 1 is the code for blue.
 60+  AD26 D3 FE            out (254),a         ; write to port 254.
 61+  AD28                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 62+  AD28
 63+  AD28 C9               ret
# file closed: screen/lifescreen.asm
 28   AD29                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AD29              ;
  2+  AD29              ; Draws the game over screen
  3+  AD29              ;
  4+  AD29              gameover_draw:
  5+  AD29 CD EC C4         call scores_processhighscores
  6+  AD2C
  7+  AD2C              gameover_draw0:
  8+  AD2C CD 6C AD         call gameover_enterhighscores
  9+  AD2F
 10+  AD2F CD 0A AE         call gameover_init
 11+  AD32
 12+  AD32 21 7A 83         ld hl,string_gameoverscreen_gameover
 13+  AD35 CD 54 85         call string_print
 14+  AD38
 15+  AD38 21 86 83         ld hl,string_gameoverscreen_copyright
 16+  AD3B CD 54 85         call string_print
 17+  AD3E
 18+  AD3E CD 4F AD         call gameover_commontext
 19+  AD41
 20+  AD41 06 0B            ld b,11
 21+  AD43 3E 42            ld a,66
 22+  AD45 11 2B 58         ld de,22528+43                         ; attrs here
 23+  AD48 CD BB A8         call screen_setcolours
 24+  AD4B CD 47 80         call utilities_waitforkey   ; wait for keypress
 25+  AD4E
 26+  AD4E C9               ret
 27+  AD4F
 28+  AD4F              ;
 29+  AD4F              ; Draws text shared by the game over and high score screens
 30+  AD4F              ;
 31+  AD4F              gameover_commontext:
 32+  AD4F CD 8D A8         call screen_setuptext       ; show scores
 33+  AD52 CD B6 C4         call scores_printscores     ; print the current scores
 34+  AD55
 35+  AD55 21 AE 83         ld hl,string_gameover_credits
 36+  AD58 CD 54 85         call string_print
 37+  AD5B
 38+  AD5B 21 9A 83         ld hl,string_gameoverscreen_bestscores
 39+  AD5E CD 54 85         call string_print
 40+  AD61
 41+  AD61 06 20            ld b,32
 42+  AD63 3E 45            ld a,69
 43+  AD65 11 C0 5A         ld de,22528+704                         ; attrs here
 44+  AD68 CD BB A8         call screen_setcolours
 45+  AD6B
 46+  AD6B C9               ret
 47+  AD6C
 48+  AD6C              ;
 49+  AD6C              ; If required, enter highscore
 50+  AD6C              ;
 51+  AD6C              gameover_enterhighscores:
 52+  AD6C                  ; check if we need to enter initial
 53+  AD6C 3A EB C4         ld a,(scores_highscoretmp)
 54+  AD6F FE 00            cp 0
 55+  AD71 C8               ret z
 56+  AD72 CD A0 AD         call gameover_enterhighscores_init
 57+  AD75 3A EB C4         ld a,(scores_highscoretmp)
 58+  AD78 3D               dec a
 59+  AD79 3D               dec a
 60+  AD7A 3D               dec a                                   ; get high score location back to position of name
 61+  AD7B 16 00            ld d,0
 62+  AD7D 5F               ld e,a
 63+  AD7E 21 6B C4         ld hl,scores_table
 64+  AD81 19               add hl,de                               ; load memory into hl
 65+  AD82 08               ex af,af'
 66+  AD83 06 0F            ld b,15
 67+  AD85 CD 99 80         call utilities_pauseforframes           ; pause for a little bit
 68+  AD88 06 03            ld b,3                                  ; collect three chars
 69+  AD8A              gameover_draw2:
 70+  AD8A C5               push bc
 71+  AD8B E5               push hl
 72+  AD8C CD 9D 80         call utilities_readkey               ; get key into a
 73+  AD8F E1               pop hl
 74+  AD90 77               ld (hl),a
 75+  AD91 23               inc hl
 76+  AD92 E5               push hl
 77+  AD93 CD D8 C4         call scores_showtable
 78+  AD96 E1               pop hl
 79+  AD97 06 0F            ld b,15
 80+  AD99 CD 99 80         call utilities_pauseforframes
 81+  AD9C C1               pop bc
 82+  AD9D 10 EB            djnz gameover_draw2
 83+  AD9F C9               ret
 84+  ADA0
 85+  ADA0              ;
 86+  ADA0              ; Displays the screen text for high score entry
 87+  ADA0              ;
 88+  ADA0              gameover_enterhighscores_init:
 89+  ADA0
 90+  ADA0 CD 0A AE         call gameover_init
 91+  ADA3 CD 4F AD         call gameover_commontext
 92+  ADA6
 93+  ADA6 21 BA 83         ld hl,string_highscore_congratulations
 94+  ADA9 CD 54 85         call string_print
 95+  ADAC
 96+  ADAC 3A 5B BD         ld a,(game_currentplayer)
 97+  ADAF FE 01            cp 1
 98+  ADB1 21 CC 83         ld hl,string_highscore_player1
 99+  ADB4 C3 BA AD         jp gameover_enterhighscores_init1
100+  ADB7              gameover_enterhighscores_init0:
101+  ADB7 21 D7 83         ld hl,string_highscore_player2
102+  ADBA              gameover_enterhighscores_init1:
103+  ADBA CD 54 85         call string_print
104+  ADBD 06 60            ld b,96
105+  ADBF 3E 43            ld a,67
106+  ADC1 11 A0 58         ld de,22528+160                         ; attrs here
107+  ADC4 CD BB A8         call screen_setcolours
108+  ADC7
109+  ADC7 21 E2 83         ld hl,string_highscore_youhaveearned
110+  ADCA CD 54 85         call string_print
111+  ADCD
112+  ADCD 3A EB C4         ld a,(scores_highscoretmp)
113+  ADD0 FE 05            cp 5
114+  ADD2 CA E0 AD         jp z, gameover_enterhighscores_init2    ; first place
115+  ADD5 FE 11            cp 17
116+  ADD7 CA E6 AD         jp z, gameover_enterhighscores_init3    ; 2nd place
117+  ADDA 21 1E 84         ld hl,string_highscore_place3           ; 3rd place
118+  ADDD C3 EC AD         jp gameover_enterhighscores_init4
119+  ADE0              gameover_enterhighscores_init2
120+  ADE0 21 F4 83         ld hl,string_highscore_place1
121+  ADE3 C3 EC AD         jp gameover_enterhighscores_init4
122+  ADE6              gameover_enterhighscores_init3
123+  ADE6 21 09 84         ld hl,string_highscore_place2
124+  ADE9 C3 EC AD         jp gameover_enterhighscores_init4
125+  ADEC              gameover_enterhighscores_init4
126+  ADEC CD 54 85         call string_print
127+  ADEF
128+  ADEF 06 60            ld b,96
129+  ADF1 3E 42            ld a,66
130+  ADF3 11 40 59         ld de,22528+320                         ; attrs here
131+  ADF6 CD BB A8         call screen_setcolours
132+  ADF9
133+  ADF9 21 33 84         ld hl,string_highscore_pleaseenter
134+  ADFC CD 54 85         call string_print
135+  ADFF
136+  ADFF 06 60            ld b,96
137+  AE01 3E 46            ld a,70
138+  AE03 11 E0 59         ld de,22528+480                         ; attrs here
139+  AE06 CD BB A8         call screen_setcolours
140+  AE09 C9               ret
141+  AE0A
142+  AE0A              ;
143+  AE0A              ; Initialises the screen
144+  AE0A              ;
145+  AE0A              gameover_init:
146+  AE0A              ; We want a black screen.
147+  AE0A 3E 47            ld a,71             ; white ink (7) on black paper (0),
148+  AE0C                                      ; bright (64).
149+  AE0C CD 7E 80         call utilities_clearscreen
150+  AE0F 32 8D 5C         ld (23693),a        ; set our screen colours.
151+  AE12 3E 00            ld a,0              ; 2 is the code for red.
152+  AE14 D3 FE            out (254),a         ; write to port 254.
153+  AE16 C9               ret
# file closed: screen/gameover.asm
 29   AE17                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AE17              ;
  2+  AE17              ; Draws the level transition screen
  3+  AE17              ;
  4+  AE17              endlevel_draw:
  5+  AE17 CD 0D AF         call endlevel_init
  6+  AE1A CD F6 AE         call endlevel_commontext
  7+  AE1D
  8+  AE1D 21 BA 83         ld hl,string_highscore_congratulations
  9+  AE20 CD 54 85         call string_print
 10+  AE23
 11+  AE23 3A 5B BD         ld a,(game_currentplayer)
 12+  AE26 FE 01            cp 1
 13+  AE28 21 CC 83         ld hl,string_highscore_player1
 14+  AE2B C3 31 AE         jp endlevel_init1
 15+  AE2E              endlevel_init0:
 16+  AE2E 21 D7 83         ld hl,string_highscore_player2
 17+  AE31              endlevel_init1:
 18+  AE31 CD 54 85         call string_print
 19+  AE34
 20+  AE34 21 50 84         ld hl,string_endlevel_youhaveearned
 21+  AE37 CD 54 85         call string_print
 22+  AE3A
 23+  AE3A CD 95 AE         call endlevel_workoutbonus
 24+  AE3D D5               push de
 25+  AE3E 08               ex af,af'                               ; store the a value for later
 26+  AE3F CD 54 85         call string_print
 27+  AE42 D1               pop de
 28+  AE43 62 6B            ld hl,de                                ; get the points text into de
 29+  AE45 CD 54 85         call string_print
 30+  AE48
 31+  AE48 21 BB 84         ld hl, string_endlevel_anothergo
 32+  AE4B CD 54 85         call string_print
 33+  AE4E
 34+  AE4E 06 20            ld b,32
 35+  AE50 3E 23            ld a,35
 36+  AE52 11 60 59         ld de,22528+352                         ; attrs here
 37+  AE55 CD BB A8         call screen_setcolours
 38+  AE58
 39+  AE58 06 20            ld b,32
 40+  AE5A 3E 25            ld a,37
 41+  AE5C 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AE5F CD BB A8         call screen_setcolours
 43+  AE62
 44+  AE62 06 20            ld b,32
 45+  AE64 3E 23            ld a,35
 46+  AE66 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AE69 CD BB A8         call screen_setcolours
 48+  AE6C
 49+  AE6C 06 20            ld b,32
 50+  AE6E 3E 22            ld a,34
 51+  AE70 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AE73 CD BB A8         call screen_setcolours
 53+  AE76
 54+  AE76 08               ex af,af'                               ; get back a value with bonus type
 55+  AE77 06 14            ld b,20
 56+  AE79 CD 99 80         call utilities_pauseforframes
 57+  AE7C
 58+  AE7C 47               ld b,a                      ; put the bonus count in b
 59+  AE7D              endlevel_init2:
 60+  AE7D C5               push bc
 61+  AE7E 06 01            ld b,1
 62+  AE80 CD 8F C4         call scores_addthousands
 63+  AE83 CD B6 C4         call scores_printscores     ; print the current scores
 64+  AE86 06 0A            ld b,10
 65+  AE88 CD 99 80         call utilities_pauseforframes
 66+  AE8B C1               pop bc
 67+  AE8C 10 EF            djnz endlevel_init2
 68+  AE8E CD 8B BD         call game_increasedifficulty ; move the difficulty up a level
 69+  AE91 CD 47 80         call utilities_waitforkey   ; wait for keypress
 70+  AE94
 71+  AE94 C9               ret
 72+  AE95
 73+  AE95              ;
 74+  AE95              ; Works out the bonus
 75+  AE95              ; Outputs:
 76+  AE95              ; a = 15 (all seven)
 77+  AE95              ; a = 10 (3 large or 4 small)
 78+  AE95              ; a = 5 (1 large diamond)
 79+  AE95              ; hl - pointer to bonus text
 80+  AE95              ; de - pointer to points text
 81+  AE95              ;
 82+  AE95              endlevel_workoutbonus:
 83+  AE95 21 2C B5         ld hl,level01diamonds+2     ; location of state of first diamond
 84+  AE98 06 03            ld b,3                      ; number to check
 85+  AE9A 16 00            ld d,0                      ; zero diamond count
 86+  AE9C              endlevel_workoutbonus0:
 87+  AE9C 7E               ld a,(hl)                   ; get state
 88+  AE9D FE 01            cp 1
 89+  AE9F C2 A3 AE         jp nz,endlevel_workoutbonus1 ; if not, move on
 90+  AEA2 14               inc d                       ; increment diamond count
 91+  AEA3              endlevel_workoutbonus1:
 92+  AEA3 23               inc hl
 93+  AEA4 23               inc hl
 94+  AEA5 23               inc hl
 95+  AEA6 23               inc hl
 96+  AEA7 23               inc hl                      ; get to next state
 97+  AEA8 10 F2            djnz endlevel_workoutbonus0
 98+  AEAA
 99+  AEAA 21 3C B5         ld hl,level01gems+2     ; location of state of first gem
100+  AEAD 06 04            ld b,4                      ; number to check
101+  AEAF 1E 00            ld e,0                      ; zero gem count
102+  AEB1              endlevel_workoutbonus2:
103+  AEB1 7E               ld a,(hl)                   ; get state
104+  AEB2 FE 01            cp 1
105+  AEB4 C2 B8 AE         jp nz,endlevel_workoutbonus3 ; if not, move on
106+  AEB7 1C               inc e                       ; increment diamond count
107+  AEB8              endlevel_workoutbonus3:
108+  AEB8 23               inc hl
109+  AEB9 23               inc hl
110+  AEBA 23               inc hl
111+  AEBB 23               inc hl
112+  AEBC 23               inc hl                     ; get to next state
113+  AEBD 10 F2            djnz endlevel_workoutbonus2
114+  AEBF
115+  AEBF 7A               ld a,d
116+  AEC0 83               add e
117+  AEC1 FE 07            cp 7                        ; check for max bonus
118+  AEC3 C2 CF AE         jp nz,endlevel_workoutbonus4 ;
119+  AEC6 3E 0F            ld a,15
120+  AEC8 21 80 84         ld hl, string_endlevel_bonus3
121+  AECB 11 AC 84         ld de, string_endlevel_points3
122+  AECE C9               ret                         ; return with bonus of 15
123+  AECF              endlevel_workoutbonus4:
124+  AECF 7A               ld a,d                      ; check for for diamonds
125+  AED0 FE 03            cp 3
126+  AED2 C2 DE AE         jp nz,endlevel_workoutbonus5
127+  AED5 3E 0A            ld a,10
128+  AED7 21 71 84         ld hl, string_endlevel_bonus2
129+  AEDA 11 9D 84         ld de, string_endlevel_points2
130+  AEDD C9               ret                         ; return with bonus of ten
131+  AEDE              endlevel_workoutbonus5:
132+  AEDE 7B               ld a,e                      ; check for four gems
133+  AEDF FE 04            cp 4
134+  AEE1 C2 ED AE         jp nz,endlevel_workoutbonus6
135+  AEE4 3E 0A            ld a,10
136+  AEE6 21 71 84         ld hl, string_endlevel_bonus2
137+  AEE9 11 9D 84         ld de, string_endlevel_points2
138+  AEEC C9               ret                         ; return with bonus of 10
139+  AEED              endlevel_workoutbonus6:
140+  AEED 3E 05            ld a,5                      ; otherwise, bonus is 5
141+  AEEF 21 62 84         ld hl, string_endlevel_bonus1
142+  AEF2 11 8F 84         ld de, string_endlevel_points1
143+  AEF5 C9               ret
144+  AEF6
145+  AEF6              ;
146+  AEF6              ; Draws text shared by the game over and high score screens
147+  AEF6              ;
148+  AEF6              endlevel_commontext:
149+  AEF6 CD 8D A8         call screen_setuptext       ; show scores
150+  AEF9 CD B6 C4         call scores_printscores     ; print the current scores
151+  AEFC
152+  AEFC 21 9A 83         ld hl,string_gameoverscreen_bestscores
153+  AEFF CD 54 85         call string_print
154+  AF02
155+  AF02 06 20            ld b,32
156+  AF04 3E 45            ld a,69
157+  AF06 11 C0 5A         ld de,22528+704                         ; attrs here
158+  AF09 CD BB A8         call screen_setcolours
159+  AF0C
160+  AF0C C9               ret
161+  AF0D
162+  AF0D              ;
163+  AF0D              ; Initialises the screen
164+  AF0D              ;
165+  AF0D              endlevel_init:
166+  AF0D              ; We want a green screen.
167+  AF0D 3E 21            ld a,33             ; white ink (7) on black paper (0),
168+  AF0F                                      ; bright (64).
169+  AF0F CD 7E 80         call utilities_clearscreen
170+  AF12 32 8D 5C         ld (23693),a        ; set our screen colours.
171+  AF15 3E 00            ld a,0              ; 2 is the code for red.
172+  AF17 D3 FE            out (254),a         ; write to port 254.
173+  AF19 C9               ret
# file closed: screen/endlevel.asm
 30   AF1A                  include "screen\options.asm"
# file opened: screen/options.asm
  1+  AF1A              ;
  2+  AF1A              ; Show the options screen
  3+  AF1A              ;
  4+  AF1A              options_show:
  5+  AF1A CD B5 AF         call options_init
  6+  AF1D
  7+  AF1D 21 D5 84         ld hl,string_options_title
  8+  AF20 CD 54 85         call string_print
  9+  AF23 21 DF 84         ld hl,string_options_1player
 10+  AF26 CD 54 85         call string_print
 11+  AF29 21 EF 84         ld hl,string_options_2player
 12+  AF2C CD 54 85         call string_print
 13+  AF2F 21 FF 84         ld hl,string_options_keyboard
 14+  AF32 CD 54 85         call string_print
 15+  AF35 21 0D 85         ld hl,string_options_joystick
 16+  AF38 CD 54 85         call string_print
 17+  AF3B 21 1B 85         ld hl,string_options_start
 18+  AF3E CD 54 85         call string_print
 19+  AF41 21 26 85         ld hl,string_options_vanity
 20+  AF44 CD 54 85         call string_print
 21+  AF47
 22+  AF47 3A 5A BD         ld a,(game_numberplayers)
 23+  AF4A FE 01            cp 1
 24+  AF4C C2 55 AF         jp nz,options_show0
 25+  AF4F 11 CA 58         ld de,22528+202                         ; top row attrs here
 26+  AF52 C3 58 AF         jp options_show1
 27+  AF55              options_show0:
 28+  AF55 11 EA 58         ld de,22528+234                         ; top row attrs here
 29+  AF58              options_show1:
 30+  AF58 06 0D            ld b,13
 31+  AF5A 3E C7            ld a,199
 32+  AF5C CD BB A8         call screen_setcolours                  ; highlight current player
 33+  AF5F
 34+  AF5F 3A 5E BD         ld a,(game_control)
 35+  AF62 FE 00            cp 0
 36+  AF64 C2 6D AF         jp nz,options_show6
 37+  AF67 11 0A 59         ld de,22528+266                         ; top row attrs here
 38+  AF6A C3 70 AF         jp options_show7
 39+  AF6D              options_show6:
 40+  AF6D 11 2A 59         ld de,22528+298                         ; top row attrs here
 41+  AF70              options_show7:
 42+  AF70 06 0D            ld b,13
 43+  AF72 3E C7            ld a,199
 44+  AF74 CD BB A8         call screen_setcolours                  ; highlight current control
 45+  AF77              options_show8:
 46+  AF77 CD 9D 80         call utilities_readkey
 47+  AF7A FE 31            cp 49                                   ; was 1 pressed
 48+  AF7C C2 87 AF         jp nz,options_show2
 49+  AF7F 21 5A BD         ld hl,game_numberplayers
 50+  AF82 36 01            ld (hl),1
 51+  AF84 C3 1A AF         jp options_show
 52+  AF87              options_show2:
 53+  AF87 FE 32            cp 50                                   ; was 2 pressed
 54+  AF89 C2 94 AF         jp nz,options_show3
 55+  AF8C 21 5A BD         ld hl,game_numberplayers
 56+  AF8F 36 02            ld (hl),2
 57+  AF91 C3 1A AF         jp options_show
 58+  AF94              options_show3:
 59+  AF94 FE 33            cp 51                                   ; was 3 pressed
 60+  AF96 C2 A1 AF         jp nz,options_show4
 61+  AF99 21 5E BD         ld hl,game_control
 62+  AF9C 36 00            ld (hl),0
 63+  AF9E C3 1A AF         jp options_show
 64+  AFA1              options_show4:
 65+  AFA1 FE 34            cp 52                                   ; was 4 pressed
 66+  AFA3 C2 AE AF         jp nz,options_show5
 67+  AFA6 21 5E BD         ld hl,game_control
 68+  AFA9 36 01            ld (hl),1
 69+  AFAB C3 1A AF         jp options_show
 70+  AFAE              options_show5:
 71+  AFAE FE 35            cp 53                                   ; was 5 pressed
 72+  AFB0 C8               ret z                                   ; exit if so
 73+  AFB1 C3 77 AF         jp options_show8                         ; otherwise, jump to top
 74+  AFB4 C9               ret
 75+  AFB5
 76+  AFB5              ;
 77+  AFB5              ; Initialise the options screen
 78+  AFB5              ;
 79+  AFB5              options_init:
 80+  AFB5 3E 47            ld a,71             ; white ink (7) on black paper (0),
 81+  AFB7                                      ; bright (64).
 82+  AFB7 CD 7E 80         call utilities_clearscreen
 83+  AFBA 32 8D 5C         ld (23693),a        ; set our screen colours.
 84+  AFBD 3E 00            ld a,0              ; 2 is the code for red.
 85+  AFBF D3 FE            out (254),a         ; write to port 254.
 86+  AFC1
 87+  AFC1 C9               ret
 88+  AFC2 C9               ret
# file closed: screen/options.asm
 31   AFC3
 32   AFC3                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  AFC3              sound_gemcollected:
  2+  AFC3 21 C8 00         ld hl,200 ; pitch.
  3+  AFC6 11 3E 00         ld de,62 ; duration.
  4+  AFC9 CD B5 03         call 949 ; ROM beeper routine.
  5+  AFCC C9               ret
  6+  AFCD
  7+  AFCD              sound_pitchbend:
  8+  AFCD 21 F4 01         ld hl,500 ; starting pitch.
  9+  AFD0 06 FA            ld b,250 ; length of pitch bend.
 10+  AFD2              sound_pitchbend0:
 11+  AFD2 C5                push bc
 12+  AFD3 E5               push hl ; store pitch.
 13+  AFD4 11 01 00         ld de,1 ; very short duration.
 14+  AFD7 CD B5 03         call 949 ; ROM beeper routine.
 15+  AFDA E1               pop hl ; restore pitch.
 16+  AFDB 23               inc hl ; pitch going up.
 17+  AFDC C1               pop bc
 18+  AFDD 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  AFDF C9               ret
 20+  AFE0
 21+  AFE0              sound_rockfell:
 22+  AFE0 08               ex af,af'
 23+  AFE1 1E 32            ld e,50 ; repeat 250 times.
 24+  AFE3 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  AFE6 D5           sound_rockfell2 push de
 26+  AFE7 06 20            ld b,32 ; length of step.
 27+  AFE9 C5           sound_rockfell0 push bc
 28+  AFEA 7E               ld a,(hl) ; next "random" number.
 29+  AFEB 23               inc hl ; pointer.
 30+  AFEC E6 F8            and 248 ; we want a black border.
 31+  AFEE D3 FE            out (254),a ; write to speaker.
 32+  AFF0 7B               ld a,e ; as e gets smaller...
 33+  AFF1 2F               cpl ; ...we increase the delay.
 34+  AFF2 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  AFF3 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  AFF5 C1               pop bc
 37+  AFF6 10 F1            djnz sound_rockfell0 ; next step.
 38+  AFF8 D1               pop de
 39+  AFF9 7B               ld a,e
 40+  AFFA D6 18            sub 24 ; size of step.
 41+  AFFC FE 1E            cp 30 ; end of range.
 42+  AFFE CA 0F B0         jp z,sound_rockfell5
 43+  B001 DA 0F B0         jp c, sound_rockfell5
 44+  B004 5F               ld e,a
 45+  B005 2F               cpl
 46+  B006 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  B008 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  B00A 3D               dec a
 49+  B00B 20 F9            jr nz,sound_rockfell3
 50+  B00D 18 D7            jr sound_rockfell2
 51+  B00F              sound_rockfell5
 52+  B00F 08               ex af,af'
 53+  B010 C9               ret
 54+  B011
# file closed: sound/sound.asm
 33   B011
 34   B011                  include "leveldata\level01.asm"
# file opened: leveldata/level01.asm
  1+  B011              ; ###############################################################
  2+  B011              ; Data for level 1
  3+  B011              ; ###############################################################
  4+  B011              level01:
  5+  B011
  6+  B011                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  B011
  8+  B011 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  B015 05 05 05 05
  8+  B019 05 05 05 05
  8+  B01D 05 05 02 01
  8+  B021 01 01 03 05
  8+  B025 05 05 05 05
  8+  B029 05 05 05 05
  8+  B02D 05 05 00 00
  9+  B031 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  B035 05 05 05 05
  9+  B039 05 05 05 05
  9+  B03D 02 01 01 01
  9+  B041 01 01 01 01
  9+  B045 03 05 05 05
  9+  B049 05 05 05 05
  9+  B04D 05 05 00 00
 10+  B051 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  B055 05 05 05 05
 10+  B059 05 05 02 01
 10+  B05D 01 01 01 01
 10+  B061 01 01 01 01
 10+  B065 01 01 03 05
 10+  B069 0D 0D 0D 0D
 10+  B06D 0D 0D 00 00
 11+  B071 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  B075 01 01 00 01
 11+  B079 01 01 01 01
 11+  B07D 01 01 01 01
 11+  B081 01 01 01 01
 11+  B085 01 01 01 03
 11+  B089 05 05 05 05
 11+  B08D 05 05 00 00
 12+  B091 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  B095 04 04 04 04
 12+  B099 04 04 01 01
 12+  B09D 01 01 01 01
 12+  B0A1 01 01 01 01
 12+  B0A5 01 01 01 01
 12+  B0A9 01 01 01 01
 12+  B0AD 00 01 00 00
 13+  B0B1 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  B0B5 04 04 04 04
 13+  B0B9 04 04 04 04
 13+  B0BD 01 01 01 01
 13+  B0C1 01 01 01 01
 13+  B0C5 01 01 01 01
 13+  B0C9 00 00 00 00
 13+  B0CD 00 01 00 00
 14+  B0D1 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  B0D5 04 01 01 01
 14+  B0D9 01 01 04 04
 14+  B0DD 04 04 01 01
 14+  B0E1 01 01 01 01
 14+  B0E5 01 00 00 00
 14+  B0E9 00 01 01 01
 14+  B0ED 01 01 00 00
 15+  B0F1 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  B0F5 04 04 04 04
 15+  B0F9 04 01 04 04
 15+  B0FD 04 04 04 04
 15+  B101 04 04 00 00
 15+  B105 00 00 04 04
 15+  B109 04 04 04 04
 15+  B10D 04 01 00 00
 16+  B111 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  B115 01 04 01 01
 16+  B119 01 01 04 04
 16+  B11D 04 04 04 04
 16+  B121 04 04 00 04
 16+  B125 04 04 04 04
 16+  B129 04 04 04 04
 16+  B12D 04 01 00 00
 17+  B131 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  B135 00 00 00 00
 17+  B139 00 04 04 04
 17+  B13D 04 04 04 04
 17+  B141 04 04 00 04
 17+  B145 04 04 04 04
 17+  B149 04 04 04 04
 17+  B14D 04 01 00 00
 18+  B151 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  B155 15 15 15 15
 18+  B159 15 01 04 04
 18+  B15D 04 04 04 04
 18+  B161 04 04 00 04
 18+  B165 04 04 04 04
 18+  B169 04 04 04 04
 18+  B16D 04 01 00 00
 19+  B171 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B175 00 00 00 00
 19+  B179 00 01 04 04
 19+  B17D 04 04 04 04
 19+  B181 04 04 00 04
 19+  B185 04 04 04 04
 19+  B189 04 00 00 00
 19+  B18D 00 01 00 00
 20+  B191 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B195 00 00 00 00
 20+  B199 00 01 04 04
 20+  B19D 04 04 04 04
 20+  B1A1 04 04 00 04
 20+  B1A5 04 04 04 04
 20+  B1A9 04 00 04 04
 20+  B1AD 00 01 00 00
 21+  B1B1 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B1B5 06 06 06 06
 21+  B1B9 06 01 04 04
 21+  B1BD 04 04 04 04
 21+  B1C1 04 04 00 04
 21+  B1C5 04 04 04 04
 21+  B1C9 04 00 04 04
 21+  B1CD 00 01 00 00
 22+  B1D1 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B1D5 1A 1A 1A 1A
 22+  B1D9 1A 01 04 00
 22+  B1DD 00 00 00 00
 22+  B1E1 00 00 00 00
 22+  B1E5 00 00 00 00
 22+  B1E9 00 00 04 04
 22+  B1ED 00 01 00 00
 23+  B1F1 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B1F5 1A 1A 1A 1A
 23+  B1F9 1A 01 04 00
 23+  B1FD 04 04 04 04
 23+  B201 04 04 00 04
 23+  B205 04 04 00 04
 23+  B209 04 04 04 04
 23+  B20D 00 01 00 00
 24+  B211 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B215 1A 1A 1A 1A
 24+  B219 1A 01 04 00
 24+  B21D 04 04 04 04
 24+  B221 04 04 00 04
 24+  B225 04 04 00 04
 24+  B229 04 04 04 04
 24+  B22D 00 01 00 00
 25+  B231 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B235 01 01 01 01
 25+  B239 01 01 04 00
 25+  B23D 04 04 04 04
 25+  B241 04 04 00 04
 25+  B245 04 04 00 04
 25+  B249 04 04 04 04
 25+  B24D 00 01 00 00
 26+  B251 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B255 04 04 04 04
 26+  B259 04 04 04 00
 26+  B25D 04 04 04 04
 26+  B261 04 04 00 04
 26+  B265 04 04 00 00
 26+  B269 00 00 04 04
 26+  B26D 04 01 00 00
 27+  B271 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B275 04 04 00 00
 27+  B279 00 00 00 00
 27+  B27D 04 04 04 04
 27+  B281 04 04 00 04
 27+  B285 04 04 04 04
 27+  B289 04 00 04 04
 27+  B28D 04 01 00 00
 28+  B291 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B295 04 04 00 04
 28+  B299 04 04 04 04
 28+  B29D 04 04 04 04
 28+  B2A1 04 04 00 04
 28+  B2A5 04 04 04 04
 28+  B2A9 04 00 04 04
 28+  B2AD 04 01 00 00
 29+  B2B1 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B2B5 04 04 00 04
 29+  B2B9 04 04 01 01
 29+  B2BD 01 01 01 01
 29+  B2C1 01 01 01 01
 29+  B2C5 01 01 01 01
 29+  B2C9 04 00 04 04
 29+  B2CD 04 01 00 00
 30+  B2D1 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B2D5 04 04 00 04
 30+  B2D9 04 04 01 00
 30+  B2DD 00 00 00 00
 30+  B2E1 00 00 00 00
 30+  B2E5 00 00 00 01
 30+  B2E9 04 00 04 04
 30+  B2ED 04 01 00 00
 31+  B2F1 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B2F5 04 04 00 04
 31+  B2F9 04 04 01 00
 31+  B2FD 00 00 00 00
 31+  B301 00 00 00 00
 31+  B305 00 00 00 01
 31+  B309 04 00 04 04
 31+  B30D 04 01 00 00
 32+  B311 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B315 04 04 00 04
 32+  B319 04 04 01 00
 32+  B31D 00 00 00 00
 32+  B321 00 00 00 00
 32+  B325 00 00 00 01
 32+  B329 04 00 04 04
 32+  B32D 04 01 00 00
 33+  B331 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B335 04 04 00 04
 33+  B339 04 04 04 00
 33+  B33D 00 00 00 00
 33+  B341 00 00 00 00
 33+  B345 00 00 00 04
 33+  B349 04 04 04 04
 33+  B34D 04 01 00 00
 34+  B351 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B355 04 04 04 04
 34+  B359 04 04 01 00
 34+  B35D 00 00 00 00
 34+  B361 00 00 00 00
 34+  B365 00 00 00 01
 34+  B369 04 04 04 04
 34+  B36D 04 01 00 00
 35+  B371 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B375 04 04 04 04
 35+  B379 04 04 01 00
 35+  B37D 00 00 01 00
 35+  B381 00 00 00 01
 35+  B385 00 00 00 01
 35+  B389 04 04 04 04
 35+  B38D 04 01 00 00
 36+  B391 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B395 01 01 01 01
 36+  B399 01 01 01 01
 36+  B39D 01 01 01 01
 36+  B3A1 01 01 01 01
 36+  B3A5 01 01 01 01
 36+  B3A9 01 01 01 01
 36+  B3AD 01 01 00 00
 37+  B3B1
 38+  B3B1              ; ###############################################################
 39+  B3B1              ; Object data: horiz, vert, state, memh, meml
 40+  B3B1              ; ###############################################################
 41+  B3B1              level01rocks:
 42+  B3B1 09 04 00 00      defb 9,4,0,0,0
 42+  B3B5 00
 43+  B3B6 0C 07 00 00      defb 12,7,0,0,0
 43+  B3BA 00
 44+  B3BB 10 07 00 00      defb 16,7,0,0,0
 44+  B3BF 00
 45+  B3C0 0B 08 00 00      defb 11,8,0,0,0
 45+  B3C4 00
 46+  B3C5 0A 0A 00 00      defb 10,10,0,0,0
 46+  B3C9 00
 47+  B3CA 0C 0A 00 00      defb 12,10,0,0,0
 47+  B3CE 00
 48+  B3CF 0D 09 00 00      defb 13,9,0,0,0
 48+  B3D3 00
 49+  B3D4 0E 08 00 00      defb 14,8,0,0,0
 49+  B3D8 00
 50+  B3D9 0F 0B 00 00      defb 15,11,0,0,0
 50+  B3DD 00
 51+  B3DE 0B 0C 00 00      defb 11,12,0,0,0
 51+  B3E2 00
 52+  B3E3 11 0C 00 00      defb 17,12,0,0,0
 52+  B3E7 00
 53+  B3E8 13 08 00 00      defb 19,8,0,0,0
 53+  B3EC 00
 54+  B3ED 16 09 00 00      defb 22,9,0,0,0
 54+  B3F1 00
 55+  B3F2 13 0A 00 00      defb 19,10,0,0,0
 55+  B3F6 00
 56+  B3F7 15 0A 00 00      defb 21,10,0,0,0
 56+  B3FB 00
 57+  B3FC 15 0C 00 00      defb 21,12,0,0,0
 57+  B400 00
 58+  B401 16 0C 00 00      defb 22,12,0,0,0
 58+  B405 00
 59+  B406 18 0A 00 00      defb 24,10,0,0,0
 59+  B40A 00
 60+  B40B 19 09 00 00      defb 25,9,0,0,0
 60+  B40F 00
 61+  B410 1C 09 00 00      defb 28,9,0,0,0
 61+  B414 00
 62+  B415 1B 0C 00 00      defb 27,12,0,0,0
 62+  B419 00
 63+  B41A 1A 0D 00 00      defb 26,13,0,0,0
 63+  B41E 00
 64+  B41F 19 0E 00 00      defb 25,14,0,0,0
 64+  B423 00
 65+  B424 19 10 00 00      defb 25,16,0,0,0
 65+  B428 00
 66+  B429 1A 11 00 00      defb 26,17,0,0,0
 66+  B42D 00
 67+  B42E 1B 11 00 00      defb 27,17,0,0,0
 67+  B432 00
 68+  B433 1C 12 00 00      defb 28,18,0,0,0
 68+  B437 00
 69+  B438 1A 13 00 00      defb 26,19,0,0,0
 69+  B43C 00
 70+  B43D 1B 15 00 00      defb 27,21,0,0,0
 70+  B441 00
 71+  B442 1A 17 00 00      defb 26,23,0,0,0
 71+  B446 00
 72+  B447 1B 18 00 00      defb 27,24,0,0,0
 72+  B44B 00
 73+  B44C 19 18 00 00      defb 25,24,0,0,0
 73+  B450 00
 74+  B451 18 17 00 00      defb 24,23,0,0,0
 74+  B455 00
 75+  B456 13 14 00 00      defb 19,20,0,0,0
 75+  B45A 00
 76+  B45B 14 12 00 00      defb 20,18,0,0,0
 76+  B45F 00
 77+  B460 14 10 00 00      defb 20,16,0,0,0
 77+  B464 00
 78+  B465 15 10 00 00      defb 21,16,0,0,0
 78+  B469 00
 79+  B46A 16 12 00 00      defb 22,18,0,0,0
 79+  B46E 00
 80+  B46F 11 14 00 00      defb 17,20,0,0,0
 80+  B473 00
 81+  B474 0D 11 00 00      defb 13,17,0,0,0
 81+  B478 00
 82+  B479 0C 13 00 00      defb 12,19,0,0,0
 82+  B47D 00
 83+  B47E 0B 13 00 00      defb 11,19,0,0,0
 83+  B482 00
 84+  B483 0A 11 00 00      defb 10,17,0,0,0
 84+  B487 00
 85+  B488 05 12 00 00      defb 5,18,0,0,0
 85+  B48C 00
 86+  B48D 07 16 00 00      defb 7,22,0,0,0
 86+  B491 00
 87+  B492 09 16 00 00      defb 9,22,0,0,0
 87+  B496 00
 88+  B497 07 18 00 00      defb 7,24,0,0,0
 88+  B49B 00
 89+  B49C 05 18 00 00      defb 5,24,0,0,0
 89+  B4A0 00
 90+  B4A1 06 19 00 00      defb 6,25,0,0,0
 90+  B4A5 00
 91+  B4A6 08 19 00 00      defb 8,25,0,0,0
 91+  B4AA 00
 92+  B4AB 04 17 00 00      defb 4,23,0,0,0
 92+  B4AF 00
 93+  B4B0 FF               defb 255
 94+  B4B1
 95+  B4B1              level01missiles:
 96+  B4B1 0B 17 00 00      defb 11,23,0,0,0
 96+  B4B5 00
 97+  B4B6 0B 16 00 00      defb 11,22,0,0,0
 97+  B4BA 00
 98+  B4BB 0C 17 00 00      defb 12,23,0,0,0
 98+  B4BF 00
 99+  B4C0 0C 16 00 00      defb 12,22,0,0,0
 99+  B4C4 00
100+  B4C5 0D 17 00 00      defb 13,23,0,0,0
100+  B4C9 00
101+  B4CA 0D 16 00 00      defb 13,22,0,0,0
101+  B4CE 00
102+  B4CF 0E 17 00 00      defb 14,23,0,0,0
102+  B4D3 00
103+  B4D4 0E 16 00 00      defb 14,22,0,0,0
103+  B4D8 00
104+  B4D9 0F 17 00 00      defb 15,23,0,0,0
104+  B4DD 00
105+  B4DE 0F 16 00 00      defb 15,22,0,0,0
105+  B4E2 00
106+  B4E3 10 17 00 00      defb 16,23,0,0,0
106+  B4E7 00
107+  B4E8 10 16 00 00      defb 16,22,0,0,0
107+  B4EC 00
108+  B4ED 11 17 00 00      defb 17,23,0,0,0
108+  B4F1 00
109+  B4F2 11 16 00 00      defb 17,22,0,0,0
109+  B4F6 00
110+  B4F7 12 17 00 00      defb 18,23,0,0,0
110+  B4FB 00
111+  B4FC 12 16 00 00      defb 18,22,0,0,0
111+  B500 00
112+  B501 13 17 00 00      defb 19,23,0,0,0
112+  B505 00
113+  B506 13 16 00 00      defb 19,22,0,0,0
113+  B50A 00
114+  B50B 14 17 00 00      defb 20,23,0,0,0
114+  B50F 00
115+  B510 14 16 00 00      defb 20,22,0,0,0
115+  B514 00
116+  B515 15 17 00 00      defb 21,23,0,0,0
116+  B519 00
117+  B51A 15 16 00 00      defb 21,22,0,0,0
117+  B51E 00
118+  B51F 16 17 00 00      defb 22,23,0,0,0
118+  B523 00
119+  B524 16 16 00 00      defb 22,22,0,0,0
119+  B528 00
120+  B529 FF               defb 255
121+  B52A
122+  B52A              ;
123+  B52A              ; Diamonds: x,y,state,mem1+mem2
124+  B52A              ;
125+  B52A              level01diamonds:
126+  B52A 0C 1B 00 00      defb 12,27,0,0,0
126+  B52E 00
127+  B52F 10 1B 00 00      defb 16,27,0,0,0
127+  B533 00
128+  B534 15 1B 00 00      defb 21,27,0,0,0
128+  B538 00
129+  B539 FF               defb 255
130+  B53A
131+  B53A              level01gems:
132+  B53A 12 14 00 00      defb 18,20,0,0,0
132+  B53E 00
133+  B53F 06 18 00 00      defb 6,24,0,0,0
133+  B543 00
134+  B544 19 17 00 00      defb 25,23,0,0,0
134+  B548 00
135+  B549 1C 11 00 00      defb 28,17,0,0,0
135+  B54D 00
136+  B54E FF               defb 255
137+  B54F              ;
138+  B54F              ; Score area colours
139+  B54F              ;
140+  B54F              score_colours:
141+  B54F 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
141+  B553 47 47 47 47
141+  B557 47 47 47 42
141+  B55B 43 43 43 43
141+  B55F 43 43 43 43
141+  B563 42 47 47 47
141+  B567 47 47 47 47
141+  B56B 47 47 47 47
142+  B56F 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
142+  B573 47 47 47 47
142+  B577 47 47 47 46
142+  B57B 46 46 46 46
142+  B57F 46 46 46 46
142+  B583 46 47 47 47
142+  B587 47 47 47 47
142+  B58B 47 47 47 47
143+  B58F
144+  B58F              high_score_colours:
145+  B58F 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
145+  B593 42 42 47 47
145+  B597 47 47 47 47
145+  B59B 43 43 43 47
145+  B59F 47 47 47 47
145+  B5A3 47 46 46 46
145+  B5A7 47 47 47 47
145+  B5AB 47 47 00 00
# file closed: leveldata/level01.asm
 35   B5AF                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  B5AF              ; Tiles graphics.
  2+  B5AF              sprites:
  3+  B5AF 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  B5B3 00 00 00 00
  4+  B5B7 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  B5BB FF FF FF FF
  5+  B5BF 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  B5C3 1F 3F 7F FF
  6+  B5C7 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  B5CB F8 FC FE FF
  7+  B5CF 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  B5D3 55 AA 55 AA
  8+  B5D7 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  B5DB 00 00 00 00
  9+  B5DF FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 6, slime block
  9+  B5E3 FF FF FF FF
 10+  B5E7 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  B5EB 00 00 00 00
 11+  B5EF 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  B5F3 F1 72 34 18
 12+  B5F7 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  B5FB FE FE FF 7E
 13+  B5FF 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  B603 FE FF 7E 3C
 14+  B607 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  B60B 00 00 FF FF
 15+  B60F 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  B613 FF 42 24 18
 16+  B617 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  B61B 00 00 00 00
 17+  B61F 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  B623 00 3C 5A 34
 18+  B627 FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  B62B FD FE FD FE
 19+  B62F F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  B633 F4 F8 F4 F8
 20+  B637 D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  B63B D0 E0 D0 E0
 21+  B63F 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  B643 40 80 40 80
 22+  B647 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  B64B ED 00 00 00
 23+  B64F 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  B653 FF 7E 3C 18
 24+  B657 FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  B65B 00 00 00 00
 25+  B65F FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  B663 00 00 00 00
 26+  B667 F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  B66B 00 00 00 00
 27+  B66F C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  B673 00 00 00 00
 28+  B677 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  B67B 00 00 00 00
 29+  B67F FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  B683 FF FF FF FF
 30+  B687 00 00 00 66  	defb    0,  0,  0,102,  0,  0,  0,  0     ; 27, bullet
 30+  B68B 00 00 00 00
 31+  B68F
 32+  B68F
 33+  B68F              sprite_attrs:
 34+  B68F 46               defb    070 ; 0, space
 35+  B690 4D               defb    077 ; 1, cyan block
 36+  B691 4D               defb    077 ; 2, slope left
 37+  B692 4D               defb    077 ; 3, slope right
 38+  B693 46               defb    070 ; 4, dirt
 39+  B694 4E               defb    078 ; 5, sky
 40+  B695 4C               defb    076 ; 6, slime
 41+  B696 42               defb    066 ; 7, trapdoor
 42+  B697 46               defb    070 ; 8, diamond
 43+  B698 42               defb    066 ; 9, rock
 44+  B699 42               defb    066 ; 10, rock 2
 45+  B69A 49           	defb    073 ; 11, sky, trapdoor
 46+  B69B 43           	defb    067 ; 12, missile
 47+  B69C 4A               defb    074 ; 13, sky, red ink (tank)
 48+  B69D 46               defb    070 ; 14, gem
 49+  B69E 4D               defb    077 ; 15, damaged mountain
 50+  B69F 4D               defb    077 ; 16, damaged mountain 2
 51+  B6A0 4D               defb    077 ; 17, damaged mountain 3
 52+  B6A1 4D               defb    077 ; 18, damaged mountain 4
 53+  B6A2 00           	defb 	000 ; 19, tank missile (not used
 54+  B6A3 43           	defb    067 ; 20, missile active
 55+  B6A4 42           	defb	066	; 21, the pit 1
 56+  B6A5 42           	defb	066	; 22, the pit 2
 57+  B6A6 42           	defb	066	; 23, the pit 3
 58+  B6A7 42           	defb	066	; 24, the pit 4
 59+  B6A8 42           	defb	066	; 25, the pit 5
 60+  B6A9 64           	defb    100 ; 26, slime, green on green
 61+  B6AA 46           	defb 	070 ; 27, bullet
 62+  B6AB
 63+  B6AB
 64+  B6AB              player_sprite:
 65+  B6AB 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 65+  B6AF 38 3D C3 80
 66+  B6B3 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 66+  B6B7 3C 1C 16 32
 67+  B6BB 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 67+  B6BF 3C 38 68 4C
 68+  B6C3 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 68+  B6C7 1C BC C3 01
 69+  B6CB 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 69+  B6CF 3C 3C 64 0C
 70+  B6D3 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 70+  B6D7 3C 3C 26 30
 71+  B6DB 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 71+  B6DF 1E 5C FD 5F
 72+  B6E3 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 72+  B6E7 4F 8F 19 03
 73+  B6EB 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 73+  B6EF F2 F1 98 C0
 74+  B6F3 FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 74+  B6F7 48 08 14 2A
 75+  B6FB 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 75+  B6FF 38 78 44 C3
 76+  B703 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 76+  B707 1C 1E 22 C3
 77+  B70B 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 77+  B70F 6F 45 E1 9B
 78+  B713 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 78+  B717 F6 A2 87 D9
 79+  B71B
 80+  B71B              ;
 81+  B71B              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 82+  B71B              ;
 83+  B71B              ship_sprite:
 84+  B71B 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 84+  B71F 03 1F 7F FF
 85+  B723 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 85+  B727 FF FF FF FF
 86+  B72B F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 86+  B72F FF FF FF FF
 87+  B733 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 87+  B737 C0 F8 FE FF
 88+  B73B B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 88+  B73F 03 03 02 07
 89+  B743 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 89+  B747 FF 0F 07 83
 90+  B74B 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 90+  B74F FF 10 20 C1
 91+  B753 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 91+  B757 C0 C0 40 E0
 92+  B75B 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 92+  B75F 03 03 02 07
 93+  B763 F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 93+  B767 FF 08 04 83
 94+  B76B F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 94+  B76F FF F0 E0 C1
 95+  B773 CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 95+  B777 C0 C0 40 E0
 96+  B77B
 97+  B77B              ;
 98+  B77B              ;  First 8 frames are tank, last frame is the gun barrel
 99+  B77B              ;
100+  B77B              tank_sprite:
101+  B77B 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
101+  B77F 7F 00 00 00
102+  B783 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
102+  B787 FE FF 7F 40
103+  B78B FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
103+  B78F 03 FF FF 01
104+  B793 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
104+  B797 E0 C0 00 00
105+  B79B 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
105+  B79F F7 E1 7F 3F
106+  B7A3 FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
106+  B7A7 54 16 FF FF
107+  B7AB FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
107+  B7AF 9B A8 FF FF
108+  B7B3 FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
108+  B7B7 9F AF FE FC
109+  B7BB 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
109+  B7BF 1F 00 00 00
110+  B7C3
111+  B7C3              monster_sprite:
112+  B7C3 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  B7C7 0B D0 16 68
113+  B7CB 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
113+  B7CF 35 AC 7F FE
114+  B7D3 FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
114+  B7D7 8F F1 8F F1
115+  B7DB 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
115+  B7DF 18 18 00 00
116+  B7E3 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
116+  B7E7 0B D0 16 68
117+  B7EB 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
117+  B7EF F5 AF FF FF
118+  B7F3 BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
118+  B7F7 0F F0 0F F0
119+  B7FB 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
119+  B7FF 00 00 00 00
120+  B803
121+  B803              robot_sprite:
122+  B803 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
122+  B807 CE 12 22 66
123+  B80B 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
123+  B80F 4E 12 24 6C
124+  B813 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
124+  B817 4E 32 63 03
125+  B81B 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
125+  B81F CE 0A 09 1B
126+  B823 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
126+  B827 73 48 44 66
127+  B82B 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
127+  B82F 72 48 24 36
128+  B833 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
128+  B837 72 4C C6 C0
129+  B83B 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
129+  B83F 73 50 90 D8
130+  B843 38 A9 BA 7C  	defb     56,169,186,124, 56, 42, 38, 96     ; dead 1
130+  B847 38 2A 26 60
131+  B84B 1C 95 5D 3E  	defb	 28,149, 93, 62, 28, 84,100,  6		; dead 2
131+  B84F 1C 54 64 06
# file closed: graphics/graphics.asm
 36   B853
 37   B853                  include "game\control.asm"
# file opened: game/control.asm
  1+  B853              ;
  2+  B853              ; Check the preferred input method then move
  3+  B853              ;
  4+  B853              control_input:
  5+  B853 3A 9D BD         ld a,(player+11)    ; first, check if player is dying
  6+  B856 FE 04            cp 4                ; is the player falling
  7+  B858 CC 22 B9         call z, control_fall
  8+  B85B FE 05            cp 5                ; is the player fighting
  9+  B85D CC 0F B9         call z, control_fight
 10+  B860 3A 9D BD         ld a,(player+11)    ; first, check if player is dying
 11+  B863 FE 00            cp 0
 12+  B865 C0               ret nz               ; if so, can't move
 13+  B866 3A 97 BD         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  B869 FE 00            cp 0
 15+  B86B CA 72 B8         jp z, control_input0
 16+  B86E CD 00 BA         call control_automove
 17+  B871 C9               ret
 18+  B872              control_input0:
 19+  B872 3A 98 BD         ld a,(player+6)      ; next, check if the player is digging
 20+  B875 FE 00            cp 0
 21+  B877 CA 7E B8         jp z, control_input1
 22+  B87A CD 3E B9         call control_dig
 23+  B87D C9               ret
 24+  B87E              control_input1:
 25+  B87E 3A 5E BD         ld a,(game_control)
 26+  B881 FE 00            cp 0                ; is this keyboard
 27+  B883 C2 8A B8         jp nz,control_input2
 28+  B886 CD 8E B8         call control_keyboard
 29+  B889 C9               ret
 30+  B88A              control_input2:
 31+  B88A                  ; do joystick
 32+  B88A CD D4 B8         call control_joystick
 33+  B88D C9               ret
 34+  B88E
 35+  B88E              ;
 36+  B88E              ; Check the keyboard
 37+  B88E              ;
 38+  B88E              control_keyboard:
 39+  B88E 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 40+  B891 ED 78            in a,(c)            ; read keyboard.
 41+  B893 47               ld b,a              ; store result in b register.
 42+  B894 CB 18            rr b                ; check outermost key (q).
 43+  B896 D2 C0 B8         jp nc,control_keyboard1
 44+  B899 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 45+  B89C ED 78            in a,(c)            ; read keyboard.
 46+  B89E 47               ld b,a              ; store result in b register.
 47+  B89F CB 18            rr b                ; check outermost key (a).
 48+  B8A1 D2 C4 B8         jp nc,control_keyboard2
 49+  B8A4 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 50+  B8A7 ED 78            in a,(c)            ; read keyboard.
 51+  B8A9 47               ld b,a              ; store result in b register.
 52+  B8AA CB 18            rr b                ; check outermost key (p).
 53+  B8AC D2 C8 B8         jp nc,control_keyboard3
 54+  B8AF CB 18            rr b                ; check next key.
 55+  B8B1 D2 CC B8         jp nc,control_keyboard4
 56+  B8B4 01 FE 7F         ld bc,32766         ; port for keyboard row b-space.
 57+  B8B7 ED 78            in a,(c)            ; read keyboard.
 58+  B8B9 47               ld b,a              ; store result in b register.
 59+  B8BA CB 18            rr b                ; check outermost key (space).
 60+  B8BC D2 D0 B8         jp nc,control_keyboard5
 61+  B8BF C9               ret
 62+  B8C0              control_keyboard1:
 63+  B8C0 CD 49 BA         call control_pl_moveup         ; player up.
 64+  B8C3 C9               ret
 65+  B8C4              control_keyboard2:
 66+  B8C4 CD 78 BA         call control_pl_movedown       ; player down.
 67+  B8C7 C9               ret
 68+  B8C8              control_keyboard3:
 69+  B8C8 CD D5 BA         call control_pl_moveright       ; player left.
 70+  B8CB C9               ret
 71+  B8CC              control_keyboard4:
 72+  B8CC CD A5 BA         call control_pl_moveleft       ; player right.
 73+  B8CF C9               ret
 74+  B8D0              control_keyboard5:
 75+  B8D0 CD 03 BB         call control_pl_fire       ; player fire.
 76+  B8D3 C9               ret
 77+  B8D4
 78+  B8D4              ;
 79+  B8D4              ; Check the joystick
 80+  B8D4              ;
 81+  B8D4              control_joystick:
 82+  B8D4 01 1F 00         ld bc,31                        ; Kempston joystick port.
 83+  B8D7 ED 78            in a,(c)                        ; read input.
 84+  B8D9 E6 02            and 2                           ; check "left" bit.
 85+  B8DB C2 03 B9         jp nz,control_joystick3       ; move left.
 86+  B8DE ED 78            in a,(c)                        ; read input.
 87+  B8E0 E6 01            and 1                           ; test "right" bit.
 88+  B8E2 C2 07 B9         jp nz,control_joystick4       ; move right.
 89+  B8E5 ED 78            in a,(c)                        ; read input.
 90+  B8E7 E6 08            and 8                           ; check "up" bit.
 91+  B8E9 C2 FB B8         jp nz,control_joystick1       ; move up.
 92+  B8EC ED 78            in a,(c)                        ; read input.
 93+  B8EE E6 04            and 4                           ; check "down" bit.
 94+  B8F0 C2 FF B8         jp nz,control_joystick2       ; move down.
 95+  B8F3 ED 78            in a,(c)                        ; read input.
 96+  B8F5 E6 10            and 16                          ; try the fire bit.
 97+  B8F7 C2 0B B9         jp nz,control_joystick5       ; fire pressed.
 98+  B8FA C9               ret
 99+  B8FB              control_joystick1:
100+  B8FB CD 49 BA         call control_pl_moveup         ; player up.
101+  B8FE C9               ret
102+  B8FF              control_joystick2:
103+  B8FF CD 78 BA         call control_pl_movedown       ; player down.
104+  B902 C9               ret
105+  B903              control_joystick3:
106+  B903 CD A5 BA         call control_pl_moveleft       ; player left.
107+  B906 C9               ret
108+  B907              control_joystick4:
109+  B907 CD D5 BA         call control_pl_moveright       ; player right.
110+  B90A C9               ret
111+  B90B              control_joystick5:
112+  B90B CD 03 BB         call control_pl_fire
113+  B90E C9               ret
114+  B90F
115+  B90F              ;
116+  B90F              ; Fights the player - just flips the players anim frame
117+  B90F              ;
118+  B90F              control_fight:
119+  B90F 3A 95 BD         ld a,(player+3)             ; load the frame
120+  B912 FE 0C            cp 12                       ; flip between 12 and 13
121+  B914 CA 1C B9         jp z,control_fight0
122+  B917 3E 0C            ld a,12
123+  B919 C3 1E B9         jp control_fight1
124+  B91C              control_fight0:
125+  B91C 3E 0D            ld a,13
126+  B91E              control_fight1:
127+  B91E 32 95 BD         ld (player+3),a           ; save back
128+  B921 C9               ret
129+  B922
130+  B922              ;
131+  B922              ; Falls the player
132+  B922              ;
133+  B922              control_fall:
134+  B922 ED 4B 92 BD      ld bc,(player)              ; get coords
135+  B926 0C               inc c
136+  B927 ED 43 92 BD      ld (player),bc
137+  B92B 3A 95 BD         ld a,(player+3)             ; load the frame
138+  B92E FE 03            cp 3                       ; flip between 3 and 0
139+  B930 C2 38 B9         jp nz, control_fall0
140+  B933 3E 00            ld a,0
141+  B935 C3 3A B9         jp control_fall1
142+  B938              control_fall0:
143+  B938 3E 03            ld a,3
144+  B93A              control_fall1:
145+  B93A 32 95 BD         ld (player+3),a           ; save back
146+  B93D C9               ret
147+  B93E
148+  B93E              ;
149+  B93E              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
150+  B93E              ;
151+  B93E              control_dig:
152+  B93E ED 4B 92 BD      ld bc,(player)      ; load the current coords into bc
153+  B942 C5               push bc
154+  B943 3A 94 BD         ld a,(player+2)     ; get the direction
155+  B946 FE 01            cp 1                ; left
156+  B948 CA 60 B9         jp z,control_dig0
157+  B94B FE 02            cp 2                ; right
158+  B94D CA 75 B9         jp z,control_dig1
159+  B950 FE 03            cp 3                ; down
160+  B952 CA 99 B9         jp z,control_dig5
161+  B955 FE 00            cp 0                ; up
162+  B957 CA 89 B9         jp z,control_dig4
163+  B95A 21 98 BD         ld hl,player+6
164+  B95D 36 00            ld (hl),0           ; turn off digging
165+  B95F C9               ret                 ; return
166+  B960              control_dig0:           ; going left
167+  B960 CD 1F AB         call sprites_scadd  ; get the current coord
168+  B963 62 6B            ld hl,de
169+  B965 2B               dec hl              ; move one left
170+  B966 C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
171+  B967 78               ld a,b
172+  B968 06 08            ld b,8
173+  B96A 90               sub b
174+  B96B 47               ld b,a
175+  B96C 79               ld a,c
176+  B96D 0E 08            ld c,8
177+  B96F 91               sub c
178+  B970 4F               ld c,a
179+  B971 C5               push bc
180+  B972 C3 A2 B9         jp control_dig2
181+  B975              control_dig1:
182+  B975 CD 1F AB         call sprites_scadd  ; get the current coord
183+  B978 62 6B            ld hl,de
184+  B97A 23               inc hl              ; move one right
185+  B97B C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
186+  B97C 3E 08            ld a,8
187+  B97E 80               add a,b
188+  B97F 47               ld b,a
189+  B980 79               ld a,c
190+  B981 0E 08            ld c,8
191+  B983 91               sub c
192+  B984 4F               ld c,a
193+  B985 C5               push bc
194+  B986 C3 A2 B9         jp control_dig2
195+  B989              control_dig4:
196+  B989 CD 1F AB         call sprites_scadd  ; get the current coord
197+  B98C 62 6B            ld hl,de
198+  B98E 11 20 00         ld de,32
199+  B991 ED 52            sbc hl,de             ; move one up
200+  B993 C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
201+  B994 0D               dec c
202+  B995 C5               push bc
203+  B996 C3 BA B9         jp control_dig6
204+  B999              control_dig5:
205+  B999 CD 1F AB         call sprites_scadd  ; get the current coord
206+  B99C 62 6B            ld hl,de
207+  B99E 24               inc h              ; move one down
208+  B99F                                     ; not bothered about working out bc here, since rock will never fall if digging down
209+  B99F C3 A2 B9         jp control_dig2
210+  B9A2              ; Normal (not up) digging
211+  B9A2              control_dig2:
212+  B9A2 3A 9A BD         ld a,(player+8)     ; get the number of rows we need to overwrite
213+  B9A5 47               ld b,a              ; rows to copy over
214+  B9A6 E5               push hl             ; store the memory location of the first row for later
215+  B9A7              control_dig3:
216+  B9A7 CD E9 B9         call control_getpixelrow
217+  B9AA 77               ld (hl),a           ; load contents into row
218+  B9AB 11 20 00         ld de,32
219+  B9AE 19               add hl,de           ; move to next row
220+  B9AF 10 F6            djnz control_dig3
221+  B9B1 E1               pop hl              ; get the original memory location back
222+  B9B2 11 20 00         ld de,32
223+  B9B5 ED 52            sbc hl,de           ; move to above row, ready for checking for rock
224+  B9B7 C3 D0 B9         jp control_dig10
225+  B9BA              ; Special case for going up
226+  B9BA              control_dig6:
227+  B9BA 3A 9A BD         ld a,(player+8)     ; get the number of rows we need to overwrite
228+  B9BD 47               ld b,a              ; rows to copy over
229+  B9BE              control_dig7:
230+  B9BE CD E9 B9         call control_getpixelrow
231+  B9C1              control_dig12:
232+  B9C1 77               ld (hl),a           ; load empty into row
233+  B9C2 11 20 00         ld de,32
234+  B9C5 ED 52            sbc hl,de           ; move up to next row
235+  B9C7 0D               dec c               ; decrease c to track rows
236+  B9C8 10 F4            djnz control_dig7
237+  B9CA 79               ld a,c
238+  B9CB D6 07            sub 7
239+  B9CD C1               pop bc
240+  B9CE 4F               ld c,a
241+  B9CF C5               push bc             ; store the decreased c coord
242+  B9D0              control_dig10:
243+  B9D0 DD 21 99 BD      ld ix,player+7
244+  B9D4 DD 7E 00         ld a,(ix)     ; get the dig frame number
245+  B9D7 3D               dec a
246+  B9D8 DD 77 00         ld (ix),a
247+  B9DB                  ; call the check for rocks above the removed dirt
248+  B9DB DD 21 98 BD      ld ix,player+6
249+  B9DF DD 7E 00         ld a,(ix)     ; get the dig state
250+  B9E2 FE 00            cp 0
251+  B9E4 C1               pop bc
252+  B9E5 CC 01 C3         call z, rocks_checkforfalling ; make the check if we're no longer digging
253+  B9E8 C9               ret
254+  B9E9
255+  B9E9              ;
256+  B9E9              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
257+  B9E9              ; Inputs:
258+  B9E9              ; hl - memory of pixel row
259+  B9E9              ; Outputs:
260+  B9E9              ; a - modified row to write
261+  B9E9              ;
262+  B9E9              control_getpixelrow:
263+  B9E9 3A 99 BD         ld a,(player+7)     ; get the dig frame number
264+  B9EC FE 00            cp 0                ; is this the last dig
265+  B9EE CA F5 B9         jp z,control_getpixelrow1
266+  B9F1 7E               ld a,(hl)           ; if not, xor with 255 to flip it
267+  B9F2 EE FF            xor 255
268+  B9F4 C9               ret
269+  B9F5              control_getpixelrow1:
270+  B9F5 DD 21 98 BD      ld ix,player+6
271+  B9F9 DD 36 00 00      ld (ix),0           ; turn off digging
272+  B9FD 3E 00            ld a,0              ; if it is, load with empty
273+  B9FF C9               ret
274+  BA00
275+  BA00              ;
276+  BA00              ; Auto move the player until pixels is zero
277+  BA00              ;
278+  BA00              control_automove:
279+  BA00 5F               ld e,a              ; store the number of pixels left to move in e
280+  BA01 ED 4B 92 BD      ld bc,(player)      ; load the current coords into bc
281+  BA05 21 94 BD         ld hl,player+2      ; get the direction
282+  BA08 7E               ld a,(hl)
283+  BA09 FE 03            cp 3                ; down
284+  BA0B CA 1F BA         jp z,control_automove3  ; don't need to do anything
285+  BA0E FE 00            cp 0                ; going up
286+  BA10 CA 2B BA         jp z,control_automove2
287+  BA13 FE 01            cp 1                ; going left?
288+  BA15 CA 37 BA         jp z,control_automove0
289+  BA18 78               ld a,b
290+  BA19 3C               inc a               ; if we're going right, increment a twice for two pixels
291+  BA1A 3C               inc a
292+  BA1B 47               ld b,a
293+  BA1C C3 3B BA         jp control_automove1
294+  BA1F              control_automove3:
295+  BA1F 79               ld a,c
296+  BA20 3C               inc a
297+  BA21 3C               inc a               ; if we're going down, increment twice
298+  BA22 4F               ld c,a
299+  BA23 FE 90            cp 144
300+  BA25 CC 19 BB         call z, control_scroll_down
301+  BA28 C3 3B BA         jp control_automove1
302+  BA2B              control_automove2:
303+  BA2B 79               ld a,c
304+  BA2C 3D               dec a
305+  BA2D 3D               dec a               ; if we're going up, decrement twice
306+  BA2E 4F               ld c,a
307+  BA2F FE 60            cp 96
308+  BA31 CC 26 BB         call z, control_scroll_up
309+  BA34 C3 3B BA         jp control_automove1
310+  BA37              control_automove0:
311+  BA37 78               ld a,b
312+  BA38 3D               dec a               ; if we're going left, decrement a twice
313+  BA39 3D               dec a
314+  BA3A 47               ld b,a
315+  BA3B              control_automove1:
316+  BA3B ED 43 92 BD      ld (player),bc      ; and back to player
317+  BA3F 7B               ld a,e              ; now get the pixel count back
318+  BA40 3D               dec a               ; decrease by one
319+  BA41 21 97 BD         ld hl,player+5
320+  BA44 77               ld (hl),a           ; copy back
321+  BA45 CD 8B BF         call player_justmoved
322+  BA48 C9               ret
323+  BA49
324+  BA49              ;
325+  BA49              ; Moves the player up
326+  BA49              ;
327+  BA49              control_pl_moveup:
328+  BA49 C5               push bc
329+  BA4A ED 4B 92 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
330+  BA4E 79               ld a,c                  ; load c into the acc
331+  BA4F FE 18            cp 24
332+  BA51 CA 71 BA         jp z,control_pl_moveup0 ; are we at the edge of the screen
333+  BA54 FE 60            cp 96
334+  BA56 CC 26 BB         call z, control_scroll_up
335+  BA59 CD CD BC         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
336+  BA5C F5               push af
337+  BA5D 7B               ld a,e                  ; put e in a
338+  BA5E FE 00            cp 0
339+  BA60 CA 70 BA         jp z,control_pl_moveup1 ; don't move if we can't
340+  BA63 F1               pop af
341+  BA64 D6 01            sub 1                   ; subtract 1
342+  BA66 D6 01            sub 1                   ; subtract 1
343+  BA68 4F               ld c,a                  ; load back to c
344+  BA69 ED 43 92 BD      ld (player),bc          ; load back to player
345+  BA6D C3 71 BA         jp control_pl_moveup0
346+  BA70              control_pl_moveup1:
347+  BA70 F1               pop af                  ; restore af if needed
348+  BA71              control_pl_moveup0:
349+  BA71 3E 00            ld a,0
350+  BA73 32 94 BD         ld (player+2),a        ; set direction to up
351+  BA76 C1               pop bc
352+  BA77 C9               ret
353+  BA78              ;
354+  BA78              ; Moves the player down
355+  BA78              ;
356+  BA78              control_pl_movedown:
357+  BA78 C5               push bc
358+  BA79 ED 4B 92 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
359+  BA7D 79               ld a,c                  ; load c into the acc
360+  BA7E FE E0            cp 224
361+  BA80 CA 9E BA         jp z,control_pl_movedown0 ; are we at the edge of the screen
362+  BA83 FE 80            cp 128
363+  BA85 CC 19 BB         call z, control_scroll_down
364+  BA88 CD A1 BC         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
365+  BA8B F5               push af
366+  BA8C 7B               ld a,e                  ; put e in a
367+  BA8D FE 00            cp 0
368+  BA8F CA 9D BA         jp z,control_pl_movedown1 ; don't move if we can't
369+  BA92 F1               pop af
370+  BA93 3C               inc a                   ; add 1
371+  BA94 3C               inc a                   ; add 1
372+  BA95 4F               ld c,a                  ; load back to c
373+  BA96 ED 43 92 BD      ld (player),bc          ; load back to player
374+  BA9A C3 9E BA         jp control_pl_movedown0
375+  BA9D              control_pl_movedown1:
376+  BA9D F1               pop af                  ; restore af if needed
377+  BA9E              control_pl_movedown0:
378+  BA9E 3E 03            ld a,3
379+  BAA0 32 94 BD         ld (player+2),a        ; set direction to down
380+  BAA3 C1               pop bc
381+  BAA4 C9               ret
382+  BAA5              ;
383+  BAA5              ; Moves the player left
384+  BAA5              ;
385+  BAA5              control_pl_moveleft:
386+  BAA5 C5               push bc
387+  BAA6 ED 4B 92 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
388+  BAAA 78               ld a,b                  ; load b into the acc
389+  BAAB FE 10            cp 16
390+  BAAD CA CE BA         jp z,control_pl_moveleft0 ; are we at the edge of the screen
391+  BAB0 CD 2C BD         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
392+  BAB3 F5               push af
393+  BAB4 7B               ld a,e                  ; put e in a
394+  BAB5 FE 00            cp 0
395+  BAB7 CA CD BA         jp z,control_pl_moveleft1 ; don't move if we can't
396+  BABA 21 97 BD         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
397+  BABD 3E 03            ld a,3
398+  BABF 77               ld (hl),a
399+  BAC0 F1               pop af
400+  BAC1 D6 01            sub 1                    ; subtract 2
401+  BAC3 D6 01            sub 1
402+  BAC5 47               ld b,a                  ; load back to c
403+  BAC6 ED 43 92 BD      ld (player),bc          ; load back to player
404+  BACA C3 CE BA         jp control_pl_moveleft0
405+  BACD              control_pl_moveleft1:
406+  BACD F1               pop af
407+  BACE              control_pl_moveleft0:
408+  BACE 3E 01            ld a,1
409+  BAD0 32 94 BD         ld (player+2),a        ; set direction to left
410+  BAD3 C1               pop bc
411+  BAD4 C9               ret
412+  BAD5              ;
413+  BAD5              ; Moves the player right
414+  BAD5              ;
415+  BAD5              control_pl_moveright:
416+  BAD5 C5               push bc
417+  BAD6 ED 4B 92 BD      ld bc,(player)          ; get the current coords, b horiz, c vert
418+  BADA 78               ld a,b                  ; load b into the acc
419+  BADB FE F0            cp 240
420+  BADD CA FC BA         jp z,control_pl_moveright0 ; are we at the edge of the screen
421+  BAE0 CD 00 BD         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
422+  BAE3 F5               push af
423+  BAE4 7B               ld a,e                  ; put e in a
424+  BAE5 FE 00            cp 0
425+  BAE7 CA FB BA         jp z,control_pl_moveright1 ; don't move if we can't
426+  BAEA 21 97 BD         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
427+  BAED 3E 03            ld a,3
428+  BAEF 77               ld (hl),a
429+  BAF0 F1               pop af
430+  BAF1 3C               inc a                   ; add 2
431+  BAF2 3C               inc a
432+  BAF3 47               ld b,a                  ; load back to b
433+  BAF4 ED 43 92 BD      ld (player),bc          ; load back to player
434+  BAF8 C3 FC BA         jp control_pl_moveright0
435+  BAFB              control_pl_moveright1:
436+  BAFB F1               pop af                  ; restore af if needed
437+  BAFC              control_pl_moveright0:
438+  BAFC 3E 02            ld a,2
439+  BAFE 32 94 BD         ld (player+2),a        ; set direction to right
440+  BB01 C1               pop bc
441+  BB02 C9               ret
442+  BB03
443+  BB03              ;
444+  BB03              ; Player fires
445+  BB03              ;
446+  BB03              control_pl_fire:
447+  BB03 3A 94 BD         ld a,(player+2)         ; get player direction
448+  BB06 FE 00            cp 0
449+  BB08 C8               ret z
450+  BB09 FE 03            cp 3
451+  BB0B C8               ret z                   ; if up or down, don't fire
452+  BB0C 3A 0F CD         ld a,(bullet_state+3)       ; get the state
453+  BB0F FE 01            cp 1
454+  BB11 C8               ret z                   ; if currently firing, don't fire
455+  BB12 CD 10 CD         call bullet_init        ; initialise the bullet
456+  BB15 CD 25 CD         call bullet_shoot       ; shoot the bullet
457+  BB18 C9               ret
458+  BB19
459+  BB19              ;
460+  BB19              ; Scrolls the screen down
461+  BB19              ;
462+  BB19              control_scroll_down:
463+  BB19 F5               push af
464+  BB1A 3E 08            ld a,8
465+  BB1C 32 06 A8         ld (screen_offset),a
466+  BB1F F1               pop af
467+  BB20 21 53 A6         ld hl,buffer_updateall
468+  BB23 36 01            ld (hl),1         ; flag as screen needing update
469+  BB25 C9               ret
470+  BB26
471+  BB26              ;
472+  BB26              ; Scrolls the screen up
473+  BB26              ;
474+  BB26              control_scroll_up:
475+  BB26 F5               push af
476+  BB27 3E 00            ld a,0
477+  BB29 32 06 A8         ld (screen_offset),a
478+  BB2C F1               pop af
479+  BB2D 21 53 A6         ld hl,buffer_updateall
480+  BB30 36 01            ld (hl),1         ; flag as screen needing update
481+  BB32 C9               ret
482+  BB33
483+  BB33
484+  BB33
485+  BB33
# file closed: game/control.asm
 38   BB33                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  BB33              ;
  2+  BB33              ; The number of frames to dig for
  3+  BB33              ;
  4+  BB33              movement_numberdigframes:
  5+  BB33 0A               defb 10
  6+  BB34
  7+  BB34              ;
  8+  BB34              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  BB34              ; Inputs:
 10+  BB34              ; hl - memory location of top pixel row
 11+  BB34              ; bc - screen coords, b horiz, c vert
 12+  BB34              ; Outputs:
 13+  BB34              ; e - 0 if not empty, 1 if empty
 14+  BB34              ;
 15+  BB34              movement_spaceisempty:
 16+  BB34 C5               push bc
 17+  BB35 E5               push hl
 18+  BB36 CD 5E BB         call movement_spaceisgem        ; check if space is a gem
 19+  BB39 E1               pop hl
 20+  BB3A C1               pop bc
 21+  BB3B 7B               ld a,e
 22+  BB3C FE 01            cp 1
 23+  BB3E C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  BB3F 3E 08            ld a,8                          ; 8 rows to check
 25+  BB41              movement_spaceisempty0:
 26+  BB41 08               ex af,af'                       ; store the loop counter
 27+  BB42 7E               ld a,(hl)                       ; get current pixel row
 28+  BB43 FE 00            cp 0
 29+  BB45 C2 59 BB         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  BB48 79               ld a,c                          ; load the vertical coord
 31+  BB49 3C               inc a                           ; next row down
 32+  BB4A 11 20 00         ld de,32
 33+  BB4D 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  BB4E 4F               ld c,a                          ; copy vert coord back to c
 35+  BB4F 08               ex af,af'                       ; get loop counter back
 36+  BB50 3D               dec a                           ; decrease loop counter
 37+  BB51 C2 41 BB         jp nz, movement_spaceisempty0
 38+  BB54 16 00            ld d,0
 39+  BB56 1E 01            ld e,1                          ; got to end, so space is empty
 40+  BB58 C9               ret
 41+  BB59              movement_spaceisempty1:
 42+  BB59 16 00            ld d,0
 43+  BB5B 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  BB5D C9               ret
 45+  BB5E
 46+  BB5E              ;
 47+  BB5E              ; Check if a space contains a gem
 48+  BB5E              ; Inputs:
 49+  BB5E              ; bc - screen coords
 50+  BB5E              ; Outputs:
 51+  BB5E              ; e = 1 if gem
 52+  BB5E              movement_spaceisgem:
 53+  BB5E CD 58 A9         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  BB61 21 2A B5         ld hl,level01diamonds           ; check diamonds first
 55+  BB64              movement_spaceisgem0:
 56+  BB64 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  BB68 7B               ld a,e                          ; check for end of data
 58+  BB69 FE FF            cp 255
 59+  BB6B CA 86 BB         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  BB6E 23               inc hl
 61+  BB6F 23               inc hl                          ; move to state
 62+  BB70 7E               ld a,(hl)
 63+  BB71 23               inc hl
 64+  BB72 23               inc hl
 65+  BB73 23               inc hl                          ; get to next
 66+  BB74 FE 01            cp 1                            ; check if collected
 67+  BB76 CA 64 BB         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  BB79 7B               ld a,e                          ; load e again
 69+  BB7A B9               cp c                            ; otherwise, compare c with e
 70+  BB7B C2 64 BB         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  BB7E 7A               ld a,d                          ; get d coord
 72+  BB7F B8               cp b                            ; compare b with d
 73+  BB80 C2 64 BB         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  BB83 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  BB85 C9               ret
 76+  BB86              movement_spaceisgem1:
 77+  BB86 21 3A B5         ld hl,level01gems              ; check gems
 78+  BB89              movement_spaceisgem2:
 79+  BB89 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  BB8D 7B               ld a,e                          ; check for end of data
 81+  BB8E FE FF            cp 255
 82+  BB90 CA AB BB         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  BB93 23               inc hl
 84+  BB94 23               inc hl                          ; move to state
 85+  BB95 7E               ld a,(hl)
 86+  BB96 23               inc hl
 87+  BB97 23               inc hl
 88+  BB98 23               inc hl                          ; get to next
 89+  BB99 FE 01            cp 1                            ; check if collected
 90+  BB9B CA 89 BB         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  BB9E 7B               ld a,e                          ; load e again
 92+  BB9F B9               cp c                            ; otherwise, compare c with e
 93+  BBA0 C2 89 BB         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  BBA3 7A               ld a,d                          ; get d coord
 95+  BBA4 B8               cp b                            ; compare b with d
 96+  BBA5 C2 89 BB         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  BBA8 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  BBAA C9               ret
 99+  BBAB              movement_spaceisgem3:
100+  BBAB 1E 00            ld e,0                          ; nothing found, return e = 0
101+  BBAD C9               ret
102+  BBAE
103+  BBAE              ;
104+  BBAE              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  BBAE              ; Inputs:
106+  BBAE              ; hl - memory location of top pixel row
107+  BBAE              ; bc - screen coords, b horiz, c vert
108+  BBAE              ; Outputs:
109+  BBAE              ; e - 0 if not empty, 1 if empty
110+  BBAE              ;
111+  BBAE              movement_linebelowisempty:
112+  BBAE C5               push bc
113+  BBAF E5               push hl
114+  BBB0 CD 5E BB         call movement_spaceisgem        ; check if space is a gem
115+  BBB3 E1               pop hl
116+  BBB4 C1               pop bc
117+  BBB5 7B               ld a,e
118+  BBB6 FE 01            cp 1
119+  BBB8 C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  BBB9 7E               ld a,(hl)                       ; get current pixel row
121+  BBBA FE 00            cp 0
122+  BBBC C2 C4 BB         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  BBBF 16 00            ld d,0
124+  BBC1 1E 01            ld e,1                          ; got to end, so space is empty
125+  BBC3 C9               ret
126+  BBC4              movement_linebelowisempty1:
127+  BBC4 16 00            ld d,0
128+  BBC6 1E 00            ld e,0                          ; returning false, ie space not empty
129+  BBC8 C9               ret
130+  BBC9
131+  BBC9              ;
132+  BBC9              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  BBC9              ; Inputs:
134+  BBC9              ; hl - memory location of top pixel row
135+  BBC9              ; bc - screen coords, b horiz, c vert
136+  BBC9              ; Outputs:
137+  BBC9              ; e - 0 if not empty, 1 if empty
138+  BBC9              ;
139+  BBC9              movement_lineaboveisempty:
140+  BBC9 C5               push bc
141+  BBCA E5               push hl
142+  BBCB CD 5E BB         call movement_spaceisgem        ; check if space is a gem
143+  BBCE E1               pop hl
144+  BBCF C1               pop bc
145+  BBD0 7B               ld a,e
146+  BBD1 FE 01            cp 1
147+  BBD3 C8               ret z
148+  BBD4 7E               ld a,(hl)                       ; get current pixel row
149+  BBD5 FE 00            cp 0
150+  BBD7 C2 DF BB         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  BBDA 16 00            ld d,0
152+  BBDC 1E 01            ld e,1                          ; got to end, so space is empty
153+  BBDE C9               ret
154+  BBDF              movement_lineaboveisempty1:
155+  BBDF 16 00            ld d,0
156+  BBE1 1E 00            ld e,0                          ; returning false, ie space not empty
157+  BBE3 C9               ret
158+  BBE4
159+  BBE4              ;
160+  BBE4              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  BBE4              ; Inputs:
162+  BBE4              ; hl - memory location of top pixel row
163+  BBE4              ; bc - screen coords, b horiz, c vert
164+  BBE4              ; Outputs:
165+  BBE4              ; none - puts player into digging mode
166+  BBE4              ;
167+  BBE4              movement_spaceisdiggable:
168+  BBE4 3E 08            ld a,8                          ; 8 rows to check
169+  BBE6              movement_spaceisdiggable0:
170+  BBE6 08               ex af,af'                       ; store the loop counter
171+  BBE7 7E               ld a,(hl)                       ; get current pixel row
172+  BBE8 FE 00            cp 0
173+  BBEA CA FA BB         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  BBED FE 55            cp 85
175+  BBEF CA FA BB         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  BBF2 FE AA            cp 170
177+  BBF4 CA FA BB         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  BBF7 C3 14 BC         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  BBFA              movement_spaceisdiggable2:
180+  BBFA 79               ld a,c                          ; load the vertical coord
181+  BBFB 3C               inc a                           ; next row down
182+  BBFC 11 20 00         ld de,32
183+  BBFF 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  BC00 4F               ld c,a                          ; copy vert coord back to c
185+  BC01 08               ex af,af'                       ; get loop counter back
186+  BC02 3D               dec a                           ; decrease loop counter
187+  BC03 C2 E6 BB         jp nz, movement_spaceisdiggable0
188+  BC06 21 98 BD         ld hl,player+6
189+  BC09 36 01            ld (hl),1                       ; set the player into digging mode
190+  BC0B 23               inc hl
191+  BC0C 3A 33 BB         ld a,(movement_numberdigframes)
192+  BC0F 77               ld (hl),a                       ; set the number of frame to dig for
193+  BC10 23               inc hl
194+  BC11 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  BC13 C9               ret
196+  BC14              movement_spaceisdiggable1:
197+  BC14 21 98 BD         ld hl,player+6
198+  BC17 36 00            ld (hl),0                       ; set the player out of digging mode
199+  BC19 C9               ret
200+  BC1A
201+  BC1A              ;
202+  BC1A              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
203+  BC1A              ; Inputs:
204+  BC1A              ; hl - memory location of top pixel row
205+  BC1A              ; bc - screen coords, b horiz, c vert
206+  BC1A              ; Outputs:
207+  BC1A              ; none - puts player into digging mode
208+  BC1A              ;
209+  BC1A              movement_spacebelowisdiggable:
210+  BC1A 7E               ld a,(hl)                       ; get first pixel row
211+  BC1B FE 55            cp 85
212+  BC1D CA 28 BC         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
213+  BC20 FE AA            cp 170
214+  BC22 CA 28 BC         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
215+  BC25 C3 14 BC         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
216+  BC28              movement_spacebelowisdiggable3:
217+  BC28 3E 08            ld a,8                          ; rows to check
218+  BC2A 1E 00            ld e,0                          ; count of rows to dig
219+  BC2C              movement_spacebelowisdiggable0:
220+  BC2C 08               ex af,af'                       ; store the loop counter
221+  BC2D 7E               ld a,(hl)                       ; get current pixel row
222+  BC2E FE 55            cp 85
223+  BC30 CA 3B BC         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
224+  BC33 FE AA            cp 170
225+  BC35 CA 3B BC         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
226+  BC38 C3 4A BC         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
227+  BC3B              movement_spacebelowisdiggable4:
228+  BC3B 1C               inc e                           ; inc count of rows to dig
229+  BC3C              movement_spacebelowisdiggable2:
230+  BC3C 79               ld a,c                          ; load the vertical coord
231+  BC3D 3C               inc a                           ; next row down
232+  BC3E D5               push de                         ; need e for later
233+  BC3F 11 20 00         ld de,32
234+  BC42 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
235+  BC43 4F               ld c,a                          ; copy vert coord back to c
236+  BC44 D1               pop de                          ; get e back
237+  BC45 08               ex af,af'                       ; get loop counter back
238+  BC46 3D               dec a                           ; incease loop counter
239+  BC47 C2 2C BC         jp nz, movement_spacebelowisdiggable0
240+  BC4A              movement_spacebelowisdiggable5:
241+  BC4A 21 98 BD         ld hl,player+6
242+  BC4D 36 01            ld (hl),1                       ; set the player into digging mode
243+  BC4F 23               inc hl
244+  BC50 3A 33 BB         ld a,(movement_numberdigframes)
245+  BC53 77               ld (hl),a                       ; set the number of frame to dig for
246+  BC54 23               inc hl
247+  BC55 73               ld (hl),e                       ; set the number of pixels to dig
248+  BC56 C9               ret
249+  BC57              movement_spacebelowisdiggable1:
250+  BC57 21 98 BD         ld hl,player+6
251+  BC5A 36 00            ld (hl),0                       ; set the player out of digging mode
252+  BC5C C9               ret
253+  BC5D
254+  BC5D              ;
255+  BC5D              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
256+  BC5D              ; Inputs:
257+  BC5D              ; hl - memory location of top pixel row
258+  BC5D              ; bc - screen coords, b horiz, c vert
259+  BC5D              ; Outputs:
260+  BC5D              ; none - puts player into digging mode
261+  BC5D              ;
262+  BC5D              movement_spaceaboveisdiggable:
263+  BC5D 7E               ld a,(hl)                       ; get first pixel row
264+  BC5E FE 55            cp 85
265+  BC60 CA 6B BC         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
266+  BC63 FE AA            cp 170
267+  BC65 CA 6B BC         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
268+  BC68 C3 14 BC         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
269+  BC6B              movement_spaceaboveisdiggable3:
270+  BC6B 3E 08            ld a,8                          ; rows to check
271+  BC6D 1E 00            ld e,0                          ; count of rows to dig
272+  BC6F              movement_spaceaboveisdiggable0:
273+  BC6F 08               ex af,af'                       ; store the loop counter
274+  BC70 7E               ld a,(hl)                       ; get current pixel row
275+  BC71 FE 55            cp 85
276+  BC73 CA 7E BC         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
277+  BC76 FE AA            cp 170
278+  BC78 CA 7E BC         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
279+  BC7B C3 8E BC         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
280+  BC7E              movement_spaceaboveisdiggable4:
281+  BC7E 1C               inc e                           ; inc count of rows to dig
282+  BC7F              movement_spaceaboveisdiggable2:
283+  BC7F 79               ld a,c                          ; load the vertical coord
284+  BC80 3D               dec a                           ; next row up
285+  BC81 D5               push de                         ; need e for later
286+  BC82 11 20 00         ld de,32
287+  BC85 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
288+  BC87 4F               ld c,a                          ; copy vert coord back to c
289+  BC88 D1               pop de                          ; get e back
290+  BC89 08               ex af,af'                       ; get loop counter back
291+  BC8A 3D               dec a                           ; incease loop counter
292+  BC8B C2 6F BC         jp nz, movement_spaceaboveisdiggable0
293+  BC8E              movement_spaceaboveisdiggable5:
294+  BC8E 21 98 BD         ld hl,player+6
295+  BC91 36 01            ld (hl),1                       ; set the player into digging mode
296+  BC93 23               inc hl
297+  BC94 3A 33 BB         ld a,(movement_numberdigframes)
298+  BC97 77               ld (hl),a                       ; set the number of frame to dig for
299+  BC98 23               inc hl
300+  BC99 73               ld (hl),e                       ; set the number of pixels to dig
301+  BC9A C9               ret
302+  BC9B              movement_spaceaboveisdiggable1:
303+  BC9B 21 98 BD         ld hl,player+6
304+  BC9E 36 00            ld (hl),0                       ; set the player out of digging mode
305+  BCA0 C9               ret
306+  BCA1
307+  BCA1              ;
308+  BCA1              ; Checks if the player can move down
309+  BCA1              ; Inputs:
310+  BCA1              ; bc - player coords, b horiz, c vert
311+  BCA1              ; Outputs:
312+  BCA1              ; de - 1 can move
313+  BCA1              movement_checkcanmove_down:
314+  BCA1 F5               push af
315+  BCA2 C5               push bc
316+  BCA3 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
317+  BCA6 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
318+  BCA8 24               inc h                       ; memory location of cell beneath now in hl
319+  BCA9 3E 08            ld a,8                       ; look below
320+  BCAB 81               add c
321+  BCAC 4F               ld c,a
322+  BCAD CD AE BB         call movement_linebelowisempty       ; check space is empty
323+  BCB0 7B               ld a,e                          ; check space empty flag
324+  BCB1 FE 00            cp 0
325+  BCB3 CA BC BC         jp z, movement_checkcanmove_down1 ; can't move
326+  BCB6 CD 8B BF         call player_justmoved
327+  BCB9 C1               pop bc
328+  BCBA F1               pop af
329+  BCBB C9               ret
330+  BCBC              movement_checkcanmove_down1:
331+  BCBC C1               pop bc
332+  BCBD CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
333+  BCC0 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
334+  BCC2 24               inc h
335+  BCC3 C5               push bc
336+  BCC4 CD 1A BC         call movement_spacebelowisdiggable    ; can't move here, but can we dig
337+  BCC7 11 00 00         ld de,0
338+  BCCA C1               pop bc
339+  BCCB F1               pop af
340+  BCCC C9               ret
341+  BCCD
342+  BCCD              ;
343+  BCCD              ; Checks if the player can move up
344+  BCCD              ; Inputs:
345+  BCCD              ; bc - player coords, b horiz, c vert
346+  BCCD              ; Outputs:
347+  BCCD              ; de - 1 can move
348+  BCCD              movement_checkcanmove_up:
349+  BCCD F5               push af
350+  BCCE C5               push bc
351+  BCCF CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
352+  BCD2 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
353+  BCD4 11 20 00         ld de,32
354+  BCD7 ED 52            sbc hl,de                       ; memory location of line above now in hl
355+  BCD9 0D               dec c                           ; look above
356+  BCDA CD C9 BB         call movement_lineaboveisempty       ; check space is empty
357+  BCDD 7B               ld a,e                          ; check space empty flag
358+  BCDE FE 00            cp 0
359+  BCE0 CA EB BC         jp z, movement_checkcanmove_up1 ; can't move
360+  BCE3 1E 01            ld e,1
361+  BCE5 CD 8B BF         call player_justmoved
362+  BCE8 C1               pop bc
363+  BCE9 F1               pop af
364+  BCEA C9               ret
365+  BCEB              movement_checkcanmove_up1:
366+  BCEB C1               pop bc
367+  BCEC CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
368+  BCEF 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
369+  BCF1 11 20 00         ld de,32
370+  BCF4 ED 52            sbc hl,de                       ; memory location of line above now in hl
371+  BCF6 C5               push bc
372+  BCF7 CD 5D BC         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
373+  BCFA 11 00 00         ld de,0
374+  BCFD C1               pop bc
375+  BCFE F1               pop af
376+  BCFF C9               ret
377+  BD00
378+  BD00              ;
379+  BD00              ; Checks if the player can move right
380+  BD00              ; Inputs:
381+  BD00              ; bc - player coords, b horiz, c vert
382+  BD00              ; Outputs:
383+  BD00              ; de - 1 can move
384+  BD00              movement_checkcanmove_right:
385+  BD00 F5               push af
386+  BD01 C5               push bc
387+  BD02 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
388+  BD05 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
389+  BD07 3E 08            ld a,8
390+  BD09 80               add b                           ; move one cell right
391+  BD0A 47               ld b,a
392+  BD0B 23               inc hl                          ; memory location of cell to the right now in hl
393+  BD0C CD 34 BB         call movement_spaceisempty       ; check space is empty
394+  BD0F 7B               ld a,e                          ; check space empty flag
395+  BD10 FE 00            cp 0
396+  BD12 CA 1B BD         jp z, movement_checkcanmove_right1 ; can't move
397+  BD15 CD 8B BF         call player_justmoved
398+  BD18 C1               pop bc
399+  BD19 F1               pop af
400+  BD1A C9               ret
401+  BD1B              movement_checkcanmove_right1:
402+  BD1B C1               pop bc
403+  BD1C CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
404+  BD1F 62 6B            ld hl,de
405+  BD21 23               inc hl                          ; memory location of cell to the right now in hl
406+  BD22 C5               push bc
407+  BD23 CD E4 BB         call movement_spaceisdiggable    ; can't move here, but can we dig
408+  BD26 11 00 00         ld de,0
409+  BD29 C1               pop bc
410+  BD2A F1               pop af
411+  BD2B C9               ret
412+  BD2C
413+  BD2C              ;
414+  BD2C              ; Checks if the player can move left
415+  BD2C              ; Inputs:
416+  BD2C              ; bc - player coords, b horiz, c vert
417+  BD2C              ; Outputs:
418+  BD2C              ; de - 1 can move
419+  BD2C              movement_checkcanmove_left:
420+  BD2C F5               push af
421+  BD2D C5               push bc
422+  BD2E CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
423+  BD31 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
424+  BD33 78               ld a,b
425+  BD34 06 08            ld b,8
426+  BD36 90               sub b                           ; move one cell left
427+  BD37 47               ld b,a
428+  BD38 2B               dec hl                          ; memory location of cell to the right now in hl
429+  BD39 CD 34 BB         call movement_spaceisempty       ; check space is empty
430+  BD3C 7B               ld a,e                          ; check space empty flag
431+  BD3D FE 00            cp 0
432+  BD3F CA 48 BD         jp z, movement_checkcanmove_left1 ; can't move
433+  BD42 CD 8B BF         call player_justmoved
434+  BD45 C1               pop bc
435+  BD46 F1               pop af
436+  BD47 C9               ret
437+  BD48              movement_checkcanmove_left1:
438+  BD48 C1               pop bc
439+  BD49 CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
440+  BD4C 62 6B            ld hl,de
441+  BD4E 2B               dec hl                          ; memory location of cell to the right now in hl
442+  BD4F C5               push bc
443+  BD50 CD E4 BB         call movement_spaceisdiggable    ; can't move here, but can we dig
444+  BD53 11 00 00         ld de,0
445+  BD56 C1               pop bc
446+  BD57 F1               pop af
447+  BD58 C9               ret
# file closed: game/movement.asm
 39   BD59                  include "game\game.asm"
# file opened: game/game.asm
  1+  BD59              ;
  2+  BD59              ; The current frame count, incremented each frame
  3+  BD59              ;
  4+  BD59              game_framenumber:
  5+  BD59 00               defb    0
  6+  BD5A
  7+  BD5A              ;
  8+  BD5A              ; The number of players
  9+  BD5A              ;
 10+  BD5A              game_numberplayers:
 11+  BD5A 01               defb 1
 12+  BD5B
 13+  BD5B              ;
 14+  BD5B              ; The current player
 15+  BD5B              ;
 16+  BD5B              game_currentplayer:
 17+  BD5B 01               defb 1
 18+  BD5C
 19+  BD5C              ;
 20+  BD5C              ; The default number of lives
 21+  BD5C              ;
 22+  BD5C              game_numberlives:
 23+  BD5C 04               defb 4
 24+  BD5D
 25+  BD5D              ;
 26+  BD5D              ; The current difficulty
 27+  BD5D              ;
 28+  BD5D              game_difficulty:
 29+  BD5D 00               defb 0
 30+  BD5E
 31+  BD5E              ;
 32+  BD5E              ; Control method: 0 for keyboard, 1 for kempston
 33+  BD5E              ;
 34+  BD5E              game_control:
 35+  BD5E 00               defb 0
 36+  BD5F
 37+  BD5F              ;
 38+  BD5F              ; Moves to the next player
 39+  BD5F              ;
 40+  BD5F              game_changeplayer:
 41+  BD5F 3A 5B BD         ld a,(game_currentplayer)
 42+  BD62 FE 01            cp 1
 43+  BD64 C8               ret z                       ; if just one player, no need to change
 44+  BD65 3D               dec a                       ; otherwise decrease by one
 45+  BD66 EE 01            xor 1                       ; xor with one to flip
 46+  BD68 3C               inc a                       ; increment
 47+  BD69 21 5B BD         ld hl,game_currentplayer
 48+  BD6C 77               ld (hl),a                   ; store
 49+  BD6D C9               ret
 50+  BD6E
 51+  BD6E              ;
 52+  BD6E              ; Sets the number of players at the start of the game
 53+  BD6E              ; Inputs:
 54+  BD6E              ; a - number of players
 55+  BD6E              game_setnumberofplayers:
 56+  BD6E 21 5A BD         ld hl,game_numberplayers
 57+  BD71 77               ld (hl),a
 58+  BD72
 59+  BD72              ;
 60+  BD72              ; Increment frame number by 1
 61+  BD72              ;
 62+  BD72              game_incrementframe:
 63+  BD72 3A 59 BD         ld a,(game_framenumber)
 64+  BD75 FE FF            cp 255
 65+  BD77 C2 7C BD         jp nz,game_incrementframe0
 66+  BD7A 3E 00            ld a,0
 67+  BD7C              game_incrementframe0:
 68+  BD7C 3C               inc a
 69+  BD7D 32 59 BD         ld (game_framenumber),a
 70+  BD80 C9               ret
 71+  BD81
 72+  BD81              ;
 73+  BD81              ; Returns current frame
 74+  BD81              ; Outputs:
 75+  BD81              ; a - current frame
 76+  BD81              ;
 77+  BD81              game_getcurrentframe:
 78+  BD81 3A 59 BD         ld a,(game_framenumber)
 79+  BD84 C9               ret
 80+  BD85
 81+  BD85              ;
 82+  BD85              ; Resets current frame
 83+  BD85              ;
 84+  BD85              game_resetcurrentframe:
 85+  BD85 21 59 BD         ld hl,game_framenumber
 86+  BD88 36 00            ld (hl),0
 87+  BD8A C9               ret
 88+  BD8B
 89+  BD8B              ;
 90+  BD8B              ; Increases the current difficulty
 91+  BD8B              ;
 92+  BD8B              game_increasedifficulty:
 93+  BD8B 3A 5D BD         ld a,(game_difficulty)
 94+  BD8E 3C               inc a
 95+  BD8F 32 5D BD         ld (game_difficulty),a
# file closed: game/game.asm
 40   BD92                  include "game\player.asm"
# file opened: game/player.asm
  1+  BD92              ;
  2+  BD92              ;   Data for current player
  3+  BD92              ;
  4+  BD92              player:
  5+  BD92 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  BD94 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  BD97 00               defb    0                   ; auto move remaining (+5)
  8+  BD98 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  BD9B 00               defb    0                   ; lives remaining (+9)
 10+  BD9C 00               defb    0                   ; died this life (+10)
 11+  BD9D 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  BD9F 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  BDA0 00               defb    0                   ; difficulty (+14)
 14+  BDA1
 15+  BDA1              player_location:
 16+  BDA1 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 17+  BDA2
 18+  BDA2              ;
 19+  BDA2              ; Works out which part of the screen the player is in
 20+  BDA2              ; Pit is between 3,9 and 8,9
 21+  BDA2              ; Diamond cavern is between 11,22 and 22,28
 22+  BDA2              ;
 23+  BDA2              player_getlocation:
 24+  BDA2 ED 4B 92 BD      ld bc,(player)              ; get screen coords
 25+  BDA6 CD 58 A9         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 26+  BDA9 78               ld a,b                      ; check for pit first
 27+  BDAA FE 09            cp 9                        ; if not on this row, not in the pit
 28+  BDAC C2 BB BD         jp nz,player_getlocation0
 29+  BDAF 79               ld a,c                      ; check horizontal
 30+  BDB0 FE 09            cp 9
 31+  BDB2 D2 BB BD         jp nc, player_getlocation0  ; if more than 9, not in the pit
 32+  BDB5 21 A1 BD         ld hl,player_location
 33+  BDB8 36 02            ld (hl),2                   ; load location with 2, the pit
 34+  BDBA C9               ret                         ; done
 35+  BDBB              player_getlocation0:            ; check for diamond cavern
 36+  BDBB 78               ld a,b                      ; first check vertical
 37+  BDBC FE 16            cp 22                       ; if above row 22, then not in cavern
 38+  BDBE DA D2 BD         jp c,player_getlocation1
 39+  BDC1 79               ld a,c                      ; get the horizontal next
 40+  BDC2 FE 0B            cp 11
 41+  BDC4 DA D2 BD         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 42+  BDC7 FE 16            cp 22
 43+  BDC9 D2 D2 BD         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 44+  BDCC 21 A1 BD         ld hl,player_location
 45+  BDCF 36 01            ld (hl),1                   ; load location with 1, the cavern
 46+  BDD1 C9               ret
 47+  BDD2              player_getlocation1:
 48+  BDD2 21 A1 BD         ld hl,player_location
 49+  BDD5 36 00            ld (hl),0                   ; load location with 2, the pit
 50+  BDD7 C9               ret                         ; done
 51+  BDD8
 52+  BDD8
 53+  BDD8              ;
 54+  BDD8              ; Initializes a player at start of game
 55+  BDD8              ; Copy initial coords, copy lives, copy score
 56+  BDD8              ;
 57+  BDD8              player_init_gamestart:
 58+  BDD8 3A 5C BD         ld a,(game_numberlives)
 59+  BDDB 32 87 BE         ld (player1_lives),a
 60+  BDDE 32 88 BE         ld (player2_lives),a                        ; set the initial number of lives at game start
 61+  BDE1
 62+  BDE1 21 8B BE         ld hl,player1_score+2
 63+  BDE4 06 06            ld b,6
 64+  BDE6              player_init_gamestart0:
 65+  BDE6 36 30            ld (hl),48
 66+  BDE8 23               inc hl
 67+  BDE9 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 68+  BDEB 21 94 BE         ld hl,player2_score+2
 69+  BDEE 06 06            ld b,6
 70+  BDF0              player_init_gamestart1:
 71+  BDF0 36 30            ld (hl),48
 72+  BDF2 23               inc hl
 73+  BDF3 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 74+  BDF5 3E 00            ld a,0
 75+  BDF7 32 9B BE         ld (player1_difficulty),a
 76+  BDFA 32 9C BE         ld (player2_difficulty),a                   ; set player difficulties to zero
 77+  BDFD C9               ret
 78+  BDFE
 79+  BDFE              ;
 80+  BDFE              ; Initializes a player at start of a life
 81+  BDFE              ; Copy initial coords, copy lives, copy score
 82+  BDFE              ;
 83+  BDFE              player_init_lifestart:
 84+  BDFE 21 97 BD         ld hl,player+5
 85+  BE01 06 09            ld b,9                      ; initialise 9 properties
 86+  BE03              player_init_lifestart2:
 87+  BE03 36 00            ld (hl),0
 88+  BE05 23               inc hl
 89+  BE06 10 FB            djnz player_init_lifestart2
 90+  BE08
 91+  BE08 21 94 BD         ld hl,player+2              ; initialise some properties
 92+  BE0B 36 02            ld (hl),2
 93+  BE0D 23               inc hl
 94+  BE0E 36 00            ld (hl),0
 95+  BE10 23               inc hl
 96+  BE11 36 01            ld (hl),1
 97+  BE13
 98+  BE13 ED 4B 22 80      ld bc,(init_coord)
 99+  BE17 ED 43 92 BD      ld (player),bc
100+  BE1B 01 9B BD         ld bc,player+9
101+  BE1E 3A 87 BE         ld a,(player1_lives)
102+  BE21 02               ld (bc),a
103+  BE22
104+  BE22 CD 34 C6         call diamonds_init      ; initialise gems
105+  BE25
106+  BE25 01 06 00         ld bc,6
107+  BE28 11 61 C4         ld de,scores_current+2
108+  BE2B 3A 5B BD         ld a,(game_currentplayer)
109+  BE2E FE 01            cp 1
110+  BE30 C2 3F BE         jp nz,player_init_lifestart0
111+  BE33 3A 9B BE         ld a,(player1_difficulty)       ; initialise player 1 difficulty
112+  BE36 32 5D BD         ld (game_difficulty),a
113+  BE39 21 8B BE         ld hl,player1_score+2           ; itialise player 1 scores
114+  BE3C C3 48 BE         jp player_init_lifestart1
115+  BE3F              player_init_lifestart0:
116+  BE3F 3A 9C BE         ld a,(player2_difficulty)       ; initialise player 2 difficulty
117+  BE42 32 5D BD         ld (game_difficulty),a
118+  BE45 21 94 BE         ld hl,player2_score+2           ; initialise player 2 scores
119+  BE48              player_init_lifestart1:
120+  BE48 ED B0            ldir
121+  BE4A C9               ret
122+  BE4B
123+  BE4B              ;
124+  BE4B              ; Finalises a player at end of a life
125+  BE4B              ; Copy lives, copy score
126+  BE4B              ;
127+  BE4B              player_lifeend:
128+  BE4B 01 9B BD         ld bc,player+9
129+  BE4E 0A               ld a,(bc)
130+  BE4F 01 87 BE         ld bc,player1_lives
131+  BE52 02               ld (bc),a
132+  BE53 CD 57 BE         call player_recordcurrentstate
133+  BE56 C9               ret
134+  BE57
135+  BE57              ;
136+  BE57              ; Copies the current score and difficulty in the current player
137+  BE57              ;
138+  BE57              player_recordcurrentstate:
139+  BE57 01 06 00         ld bc,6                  ; copy current score back to correct player
140+  BE5A 21 61 C4         ld hl,scores_current+2
141+  BE5D 3A 5B BD         ld a,(game_currentplayer)
142+  BE60 FE 01            cp 1
143+  BE62 C2 71 BE         jp nz,player_recordcurrentstate0
144+  BE65 3A 5D BD         ld a,(game_difficulty)
145+  BE68 32 9B BE         ld (player1_difficulty),a       ; store difficulty
146+  BE6B 11 8B BE         ld de,player1_score+2
147+  BE6E C3 7A BE         jp player_recordcurrentstate1
148+  BE71              player_recordcurrentstate0:         ; do player 2
149+  BE71 3A 5D BD         ld a,(game_difficulty)
150+  BE74 32 9C BE         ld (player2_difficulty),a       ; store difficulty
151+  BE77 11 94 BE         ld de,player2_score+2
152+  BE7A              player_recordcurrentstate1:
153+  BE7A ED B0            ldir
154+  BE7C C9               ret
155+  BE7D
156+  BE7D              ;
157+  BE7D              ; Player just died, subtract a life
158+  BE7D              ;
159+  BE7D              player_died:
160+  BE7D 01 9B BD         ld bc,player+9
161+  BE80 0A               ld a,(bc)
162+  BE81 3D               dec a
163+  BE82 02               ld (bc),a
164+  BE83 CD 4B BE         call player_lifeend
165+  BE86 C9               ret
166+  BE87
167+  BE87              ;
168+  BE87              ; Player lives
169+  BE87              ;
170+  BE87              player1_lives:
171+  BE87 03               defb 3
172+  BE88              player2_lives:
173+  BE88 03               defb 3
174+  BE89
175+  BE89              ;
176+  BE89              ; Player scores
177+  BE89              ;
178+  BE89              player1_score:
179+  BE89 04 01 30 30      defb 4,1,'000000',255
179+  BE8D 30 30 30 30
179+  BE91 FF
180+  BE92              player2_score:
181+  BE92 16 01 30 30      defb 22,1,'000000',255
181+  BE96 30 30 30 30
181+  BE9A FF
182+  BE9B
183+  BE9B              ;
184+  BE9B              ; Player difficulties
185+  BE9B              ;
186+  BE9B              player1_difficulty:
187+  BE9B 00               defb 0
188+  BE9C              player2_difficulty:
189+  BE9C 00               defb 0
190+  BE9D
191+  BE9D              ;
192+  BE9D              ; Kills a player this life
193+  BE9D              ;
194+  BE9D              player_killplayer:
195+  BE9D 21 9C BD         ld hl,player+10
196+  BEA0 36 01            ld (hl),1
197+  BEA2 C9               ret
198+  BEA3
199+  BEA3              ;
200+  BEA3              ; Crush a player this life
201+  BEA3              ;
202+  BEA3              player_crushplayer:
203+  BEA3 21 9D BD         ld hl,player+11             ; mark as crushed
204+  BEA6 36 01            ld (hl),1
205+  BEA8 C9               ret
206+  BEA9
207+  BEA9              player_tankkillplayer
208+  BEA9 21 9D BD         ld hl,player+11             ; mark as tanked
209+  BEAC 36 02            ld (hl),2
210+  BEAE C9               ret
211+  BEAF
212+  BEAF              player_zonkplayer
213+  BEAF 21 9D BD         ld hl,player+11             ; mark as zonked (missile)
214+  BEB2 36 03            ld (hl),3
215+  BEB4 C9               ret
216+  BEB5
217+  BEB5              player_pitkillplayer
218+  BEB5 21 9D BD         ld hl,player+11             ; mark as pit killed
219+  BEB8 36 04            ld (hl),4
220+  BEBA C9               ret
221+  BEBB
222+  BEBB              player_robotkillplayer
223+  BEBB 21 9D BD         ld hl,player+11             ; mark as robot killed
224+  BEBE 36 05            ld (hl),5
225+  BEC0 C9               ret
226+  BEC1
227+  BEC1              ;
228+  BEC1              ; Draws the player at the current position or deletes them
229+  BEC1              ;
230+  BEC1              player_drawplayer:
231+  BEC1 3A 94 BD         ld a,(player+2)             ; get the current direction
232+  BEC4 FE 03            cp 3
233+  BEC6 C2 CB BE         jp nz,player_drawplayer0
234+  BEC9 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
235+  BECB              player_drawplayer0:             ; DYING CHECKS
236+  BECB 5F               ld e,a                      ; store in e
237+  BECC 3A 9D BD         ld a,(player+11)             ; get the dying flag
238+  BECF FE 01            cp 1
239+  BED1 CA 0B BF         jp z,player_drawplayer3     ; if it's one, we're being crushed
240+  BED4 FE 04            cp 4
241+  BED6 CA 53 BF         jp z,player_drawplayer9     ; player is falling into the pit
242+  BED9 FE 05            cp 5
243+  BEDB CA 6F BF         jp z,player_drawplayer12    ; player has been killed by a robot
244+  BEDE              player_drawplayer4:             ; CHECK FOR DIGGING
245+  BEDE 3A 98 BD         ld a,(player+6)             ; get the dig flag
246+  BEE1 FE 01            cp 1
247+  BEE3 CA F4 BE         jp z,player_drawplayer1    ; get dig frame
248+  BEE6 3A 95 BD         ld a,(player+3)             ; this is normal movement so get the current frame
249+  BEE9 83               add a,e
250+  BEEA C3 F9 BE         jp player_drawplayer2
251+  BEED              player_drawplayer6:             ; GETTING THE DIG FRAM
252+  BEED E6 01            and 1                       ; check for odd
253+  BEEF C6 0A            add 10                      ; add 10, to get either 10 or 11
254+  BEF1 C3 F9 BE         jp player_drawplayer2
255+  BEF4              player_drawplayer1:             ; GET THE NORMAL FRAME
256+  BEF4 3A 94 BD         ld a,(player+2)             ; digging, get the current direction again, because want all four
257+  BEF7 C6 06            add a,6                     ; add direction to 6 to get frame
258+  BEF9              player_drawplayer2:             ; WORK OUT THE FRAME
259+  BEF9 07               rlca
260+  BEFA 07               rlca
261+  BEFB 07               rlca                        ; multiply by eight
262+  BEFC 6F               ld l,a
263+  BEFD 26 00            ld h,0
264+  BEFF 11 AB B6         ld de,player_sprite
265+  BF02 19               add hl,de                   ; load hl with the location of the player sprite data
266+  BF03              player_drawplayer7:             ; DRAW THE PlAYER
267+  BF03 ED 4B 92 BD      ld bc,(player)              ; load bc with the start coords
268+  BF07 CD 2A AA         call sprites_drawsprite     ; call the routine to draw the sprite
269+  BF0A                  ;call player_storeupdatedlines ; log updated rows
270+  BF0A C9               ret
271+  BF0B              ;
272+  BF0B              ; CRUSHING
273+  BF0B              ;
274+  BF0B              player_drawplayer3:
275+  BF0B 21 9E BD         ld hl,player+12
276+  BF0E 7E               ld a,(hl)                  ; crushing, so get the current anim flag
277+  BF0F FE 00            cp 0
278+  BF11 C2 1A BF         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
279+  BF14 3E 64            ld a,100
280+  BF16 77               ld (hl),a                   ; otherwise, load up the anim frames
281+  BF17 C3 DE BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
282+  BF1A              player_drawplayer5:
283+  BF1A 3D               dec a
284+  BF1B 77               ld (hl),a
285+  BF1C FE 00            cp 0
286+  BF1E CC 9D BE         call z,player_killplayer     ; final animation, so kill the player
287+  BF21 FE 0A            cp 10                         ; play the sound
288+  BF23 CC E0 AF         call z, sound_rockfell
289+  BF26 FE 14            cp 20                        ; check if we should move the rock
290+  BF28 C2 3C BF         jp nz,player_drawplayer8
291+  BF2B D9               exx
292+  BF2C F5               push af
293+  BF2D ED 4B FF C2      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
294+  BF31 21 F7 B5         ld hl,sprites+72
295+  BF34 CD 2A AA         call sprites_drawsprite     ; draw a rock over current
296+  BF37 F1               pop af
297+  BF38 D9               exx
298+  BF39 C3 ED BE         jp player_drawplayer6       ; continue drawing player
299+  BF3C              player_drawplayer8:
300+  BF3C FE 14            cp 20
301+  BF3E D2 ED BE         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
302+  BF41 ED 4B 92 BD      ld bc,(player)
303+  BF45 CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
304+  BF48 3E 42            ld a,66             ; load red
305+  BF4A CD B0 A9         call screen_setattr
306+  BF4D 21 F7 B5         ld hl,sprites+72            ; otherwise, player is rock
307+  BF50 C3 03 BF         jp player_drawplayer7
308+  BF53              ;
309+  BF53              ; FALLING
310+  BF53              ;
311+  BF53              player_drawplayer9:             ; player is falling into the pit
312+  BF53 21 9E BD         ld hl,player+12
313+  BF56 7E               ld a,(hl)                   ; get the frames
314+  BF57 FE 00            cp 0
315+  BF59 C2 62 BF         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
316+  BF5C 3E 50            ld a,80
317+  BF5E 77               ld (hl),a                   ; otherwise, load up the anim frames
318+  BF5F C3 DE BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
319+  BF62              player_drawplayer10:
320+  BF62 3D               dec a
321+  BF63 77               ld (hl),a
322+  BF64 FE 00            cp 0
323+  BF66 CC 9D BE         call z,player_killplayer     ; final frame, so kill the player
324+  BF69 3A 95 BD         ld a,(player+3)
325+  BF6C C3 F9 BE         jp player_drawplayer2
326+  BF6F              ;
327+  BF6F              ; ROBOT KILLED
328+  BF6F              ;
329+  BF6F              player_drawplayer12:
330+  BF6F 21 9E BD         ld hl,player+12
331+  BF72 7E               ld a,(hl)                   ; get the frames
332+  BF73 FE 00            cp 0
333+  BF75 C2 7E BF         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
334+  BF78 3E C8            ld a,200
335+  BF7A 77               ld (hl),a                   ; otherwise, load up the anim frames
336+  BF7B C3 DE BE         jp player_drawplayer4       ; and return to the main loop to remove the current frame
337+  BF7E              player_drawplayer13:
338+  BF7E 3D               dec a
339+  BF7F 77               ld (hl),a
340+  BF80 FE 00            cp 0
341+  BF82 CC 9D BE         call z,player_killplayer     ; final frame, so kill the player
342+  BF85 3A 95 BD         ld a,(player+3)
343+  BF88 C3 F9 BE         jp player_drawplayer2
344+  BF8B
345+  BF8B              ;
346+  BF8B              ; Runs after the player just moved. Changes animation frame if required
347+  BF8B              ;
348+  BF8B              player_justmoved:
349+  BF8B D9               exx
350+  BF8C 3A 96 BD         ld a,(player+4)             ; get the transition count
351+  BF8F FE 00            cp 0
352+  BF91 CA 97 BF         jp z, player_justmoved2     ; if zero reset and change the frame
353+  BF94 C3 B1 BF         jp player_justmoved1       ; otherwise decrease and continue
354+  BF97              player_justmoved2:
355+  BF97                  ; reset and change frame in here
356+  BF97 3E 01            ld a,1
357+  BF99 32 96 BD         ld (player+4),a            ; reset back to whatever
358+  BF9C 3A 95 BD         ld a,(player+3)             ; load the frame
359+  BF9F FE 03            cp 3                       ; flip between 3 and 0
360+  BFA1 C2 A9 BF         jp nz, player_justmoved4
361+  BFA4 3E 00            ld a,0
362+  BFA6 C3 AB BF         jp player_justmoved5
363+  BFA9              player_justmoved4:
364+  BFA9 3E 03            ld a,3
365+  BFAB              player_justmoved5:
366+  BFAB 32 95 BD         ld (player+3),a           ; save back
367+  BFAE C3 B5 BF         jp player_justmoved3
368+  BFB1              player_justmoved1:
369+  BFB1                  ; decrease count
370+  BFB1 3D               dec a
371+  BFB2 32 96 BD         ld (player+4),a
372+  BFB5              player_justmoved3:
373+  BFB5 D9               exx;
374+  BFB6 C9               ret
375+  BFB7
376+  BFB7              ;
377+  BFB7              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
378+  BFB7              ; Outputs:
379+  BFB7              ; a - 1 for completed level
380+  BFB7              player_checkforexit:
381+  BFB7 ED 4B 92 BD      ld bc,(player)                 ; get player coords
382+  BFBB ED 5B 22 80      ld de,(init_coord)             ; get start coords
383+  BFBF 78               ld a,b
384+  BFC0 BA               cp d                         ; compare horiz
385+  BFC1 C2 CC BF         jp nz,player_checkforexit1
386+  BFC4 79               ld a,c
387+  BFC5 BB               cp e                        ; compare vert
388+  BFC6 C2 CC BF         jp nz,player_checkforexit1
389+  BFC9              player_checkforexit0:
390+  BFC9 3E 01            ld a,1                       ; hasn't completed
391+  BFCB C9               ret
392+  BFCC              player_checkforexit1:
393+  BFCC 3E 00            ld a,0                       ; has completed
394+  BFCE C9               ret
# file closed: game/player.asm
 41   BFCF                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  BFCF              ;
  2+  BFCF              ; Ship initial position: vert,horiz
  3+  BFCF              ;
  4+  BFCF              ship_initpos:
  5+  BFCF 00 24            defb 0,36
  6+  BFD1              ship_initpos2:
  7+  BFD1 00 00            defb 0,0
  8+  BFD3              ship_frame:
  9+  BFD3 00               defb 0
 10+  BFD4              ;
 11+  BFD4              ; The current memory location
 12+  BFD4              ;
 13+  BFD4              ship_current_sprite:
 14+  BFD4 00 00            defb 0,0
 15+  BFD6
 16+  BFD6              ship_current_coords:
 17+  BFD6 00 00            defb 0,0
 18+  BFD8
 19+  BFD8              ship_process:
 20+  BFD8 3A 9D BD         ld a,(player+11)
 21+  BFDB FE 02            cp 2                        ; has the player been killed by tank?
 22+  BFDD C0               ret nz                      ; do nothing if not
 23+  BFDE CD 26 BB         call control_scroll_up           ; make sure the screen is on the top screen
 24+  BFE1 CD 50 C0         call ship_takeoff           ; bye bye
 25+  BFE4 CD 9D BE         call player_killplayer      ; killed
 26+  BFE7 06 32            ld b,50
 27+  BFE9 CD 99 80         call utilities_pauseforframes
 28+  BFEC C9               ret
 29+  BFED
 30+  BFED              ;
 31+  BFED              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  BFED              ;
 33+  BFED              ship_land:
 34+  BFED ED 4B CF BF      ld bc,(ship_initpos)
 35+  BFF1 ED 43 D1 BF      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  BFF5 1E 00            ld e,0                      ; store a flag to track first time round
 37+  BFF7 06 09            ld b,9                      ; move down 8 pixels
 38+  BFF9              ship_land0:
 39+  BFF9 C5               push bc
 40+  BFFA 7B               ld a,e
 41+  BFFB D5               push de                     ; store de for next time round
 42+  BFFC FE 01            cp 1                        ; check first time flag
 43+  BFFE C2 13 C0         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  C001 CD 98 C0         call ship_draw_full         ; delete old one
 45+  C004 CD 7C C0         call ship_change_frame      ; increment the frame
 46+  C007 ED 4B D1 BF      ld bc,(ship_initpos2)       ; get the current coords
 47+  C00B 81 C6 01         add c,1                     ; move down one pixels
 48+  C00E 4F               ld c,a
 49+  C00F ED 43 D1 BF      ld (ship_initpos2),bc
 50+  C013              ship_land1:
 51+  C013 CD 98 C0         call ship_draw_full         ; draw the ship
 52+  C016 CD 91 C0         call ship_draw_screen
 53+  C019 D1               pop de
 54+  C01A 1E 01            ld e,1
 55+  C01C C1               pop bc
 56+  C01D 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  C01F                  ; done moving down
 58+  C01F                  ; now move across
 59+  C01F CD C1 BE         call player_drawplayer      ; draw player
 60+  C022 CD 98 C0         call ship_draw_full         ; delete old one
 61+  C025 1E 00            ld e,0                      ; store a flag to track first time round
 62+  C027 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  C029              ship_land3:
 64+  C029 C5               push bc
 65+  C02A 7B               ld a,e
 66+  C02B D5               push de                     ; store de for next time round
 67+  C02C FE 01            cp 1                        ; check first time flag
 68+  C02E C2 43 C0         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  C031 CD 98 C0         call ship_draw_full         ; delete old one
 70+  C034 CD 7C C0         call ship_change_frame      ; increment the frame
 71+  C037 ED 4B D1 BF      ld bc,(ship_initpos2)       ; get the current coords
 72+  C03B 78               ld a,b
 73+  C03C D6 01            sub 1                       ; move back one pixels
 74+  C03E 47               ld b,a
 75+  C03F ED 43 D1 BF      ld (ship_initpos2),bc
 76+  C043              ship_land2:
 77+  C043 CD 98 C0         call ship_draw_full         ; draw the ship
 78+  C046 CD 91 C0         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  C049 D1               pop de
 80+  C04A 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  C04C C1               pop bc
 82+  C04D 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  C04F C9               ret
 84+  C050
 85+  C050              ;
 86+  C050              ;   Take off the ship
 87+  C050              ;
 88+  C050              ship_takeoff:
 89+  C050 1E 01            ld e,1                      ; store a flag to track first time round
 90+  C052 06 08            ld b,8                      ; move up 8 pixels
 91+  C054              ship_takeoff0:
 92+  C054 C5               push bc
 93+  C055 7B               ld a,e
 94+  C056 D5               push de                     ; store de for next time round
 95+  C057 FE 01            cp 1                        ; check first time flag
 96+  C059 C2 6F C0         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  C05C ED 4B D1 BF      ld bc,(ship_initpos2)       ; get the current coords
 98+  C060 CD 98 C0         call ship_draw_full         ; delete old one
 99+  C063 CD 7C C0         call ship_change_frame      ; increment the frame
100+  C066 ED 4B D1 BF      ld bc,(ship_initpos2)       ; get the current coords
101+  C06A 0D               dec c                       ; move up one pixels
102+  C06B ED 43 D1 BF      ld (ship_initpos2),bc
103+  C06F              ship_takeoff1:
104+  C06F CD 98 C0         call ship_draw_full         ; draw the ship
105+  C072 CD 91 C0         call ship_draw_screen
106+  C075 D1               pop de
107+  C076 1E 01            ld e,1
108+  C078 C1               pop bc
109+  C079 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  C07B                  ; done moving up
111+  C07B C9               ret
112+  C07C
113+  C07C              ;
114+  C07C              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  C07C              ;
116+  C07C              ship_change_frame:
117+  C07C F5               push af
118+  C07D 3A D3 BF         ld a,(ship_frame)
119+  C080 FE 00            cp 0
120+  C082 CA 8A C0         jp z,ship_change_frame0
121+  C085 3E 00            ld a,0                      ; flip to 0
122+  C087 C3 8C C0         jp ship_change_frame1
123+  C08A              ship_change_frame0:
124+  C08A 3E 20            ld a,32                      ; flip to 32
125+  C08C              ship_change_frame1:
126+  C08C 32 D3 BF         ld (ship_frame),a            ; save the frame
127+  C08F F1               pop af
128+  C090 C9               ret
129+  C091
130+  C091              ship_draw_screen:
131+  C091 76               halt
132+  C092 F3               di
133+  C093 CD 2F A7         call buffer_buffertoscreen  ; copy buffer to screen
134+  C096 FB               ei                          ; enable interupts
135+  C097 C9               ret
136+  C098
137+  C098              ship_draw_full:
138+  C098 21 1B B7         ld hl,ship_sprite
139+  C09B ED 4B D1 BF      ld bc,(ship_initpos2)         ; load bc with the start coords
140+  C09F 22 D4 BF         ld (ship_current_sprite),hl  ; put into memory
141+  C0A2 ED 43 D6 BF      ld (ship_current_coords),bc  ; put into memory
142+  C0A6 CD C5 C0         call ship_draw
143+  C0A9 08               ex af,af'
144+  C0AA 3A D3 BF         ld a,(ship_frame)            ; get the animation frame
145+  C0AD 16 00            ld d,0
146+  C0AF 5F               ld e,a
147+  C0B0 19               add hl,de
148+  C0B1 22 D4 BF         ld (ship_current_sprite),hl  ; put into memory
149+  C0B4 08               ex af,af'
150+  C0B5 ED 4B D1 BF      ld bc,(ship_initpos2)         ; load bc with the start coords
151+  C0B9 81 C6 08         add c,8                      ; move one line down
152+  C0BC 4F               ld c,a
153+  C0BD ED 43 D6 BF      ld (ship_current_coords),bc  ; put into memory
154+  C0C1 CD C5 C0         call ship_draw
155+  C0C4 C9               ret
156+  C0C5
157+  C0C5              ;
158+  C0C5              ; Draw the ship
159+  C0C5              ; Inputs:
160+  C0C5              ; None, all in memory
161+  C0C5              ;
162+  C0C5              ship_draw:
163+  C0C5 3E 04            ld a,4                              ; 4 pieces per half
164+  C0C7              ship_draw0:
165+  C0C7 F5               push af
166+  C0C8 2A D4 BF         ld hl,(ship_current_sprite)
167+  C0CB ED 4B D6 BF      ld bc,(ship_current_coords)         ; load bc with the start coords
168+  C0CF CD 2A AA         call sprites_drawsprite
169+  C0D2 2A D4 BF         ld hl,(ship_current_sprite)
170+  C0D5 ED 4B D6 BF      ld bc,(ship_current_coords)         ; load bc with the start coords
171+  C0D9 11 08 00         ld de,8
172+  C0DC 19               add hl,de
173+  C0DD 80 C6 08         add b,8
174+  C0E0 47               ld b,a
175+  C0E1 22 D4 BF         ld (ship_current_sprite),hl         ; put into memory
176+  C0E4 ED 43 D6 BF      ld (ship_current_coords),bc         ; put into memory
177+  C0E8 F1               pop af
178+  C0E9 3D               dec a
179+  C0EA FE 00            cp 0
180+  C0EC C2 C7 C0         jp nz,ship_draw0
181+  C0EF
182+  C0EF C9               ret
183+  C0F0
# file closed: game/ship.asm
 42   C0F0                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  C0F0              ;
  2+  C0F0              ; tank initial position: vert,horiz
  3+  C0F0              ;
  4+  C0F0              tank_initpos:
  5+  C0F0 10 D0            defb 16,208
  6+  C0F2              tank_initpos2:
  7+  C0F2 00 00            defb 0,0
  8+  C0F4              tank_frame:
  9+  C0F4 00               defb 0
 10+  C0F5              tank_anim:
 11+  C0F5 11               defb 17
 12+  C0F6
 13+  C0F6              ;
 14+  C0F6              ; The damage countdown
 15+  C0F6              ;
 16+  C0F6              tank_currentdamage:
 17+  C0F6 F0               defb 240
 18+  C0F7
 19+  C0F7              ;
 20+  C0F7              ; The damage coordinate
 21+  C0F7              ;
 22+  C0F7              tank_currentdamagecoord:
 23+  C0F7 16 02            defb 22,2
 24+  C0F9
 25+  C0F9              ;
 26+  C0F9              ; Controls when the tank shoots
 27+  C0F9              ;
 28+  C0F9              tank_count:
 29+  C0F9 00               defb 0
 30+  C0FA
 31+  C0FA              ;
 32+  C0FA              ; Holds the block number of the current damage sprite
 33+  C0FA              ;
 34+  C0FA              tank_damageframe:
 35+  C0FA 00               defb 0
 36+  C0FB
 37+  C0FB              ;
 38+  C0FB              ; The current memory location
 39+  C0FB              ;
 40+  C0FB              tank_current_sprite:
 41+  C0FB 00 00            defb 0,0
 42+  C0FD
 43+  C0FD              tank_current_coords:
 44+  C0FD 00 00            defb 0,0
 45+  C0FF
 46+  C0FF              ;
 47+  C0FF              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  C0FF              ;
 49+  C0FF              tank_missile_displayed:
 50+  C0FF 00               defb 0
 51+  C100
 52+  C100              ;
 53+  C100              ; Initialise the tank
 54+  C100              ;
 55+  C100              tank_init:
 56+  C100 ED 4B F0 C0      ld bc,(tank_initpos)
 57+  C104 ED 43 F2 C0      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  C108 21 F4 C0         ld hl,tank_frame
 59+  C10B 36 00            ld (hl),0
 60+  C10D 21 F5 C0         ld hl,tank_anim
 61+  C110 36 11            ld (hl),17
 62+  C112 21 FA C0         ld hl,tank_damageframe              ; reset tank
 63+  C115 36 00            ld (hl),0
 64+  C117 21 F9 C0         ld hl,tank_count
 65+  C11A 36 00            ld (hl),0
 66+  C11C 21 F6 C0         ld hl,tank_currentdamage
 67+  C11F 36 F0            ld (hl),240
 68+  C121 21 F7 C0         ld hl,tank_currentdamagecoord
 69+  C124 36 16            ld (hl),22
 70+  C126 23               inc hl
 71+  C127 36 02            ld (hl),2
 72+  C129 21 FF C0         ld hl,tank_missile_displayed
 73+  C12C 36 00            ld (hl),0
 74+  C12E
 75+  C12E C9               ret
 76+  C12F
 77+  C12F              ;
 78+  C12F              ;   Draw and move the tank
 79+  C12F              ;   Start processing at frame 200
 80+  C12F              ;   Don't move if anim is zero
 81+  C12F              ;   Decrement frame if moved
 82+  C12F              ;
 83+  C12F              tank_process:
 84+  C12F 3A F5 C0         ld a,(tank_anim)
 85+  C132 FE 00            cp 0
 86+  C134 C2 3B C1         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  C137 CD 4C C1         call tank_fire
 88+  C13A C9               ret
 89+  C13B              tank_process0:
 90+  C13B CD 81 BD         call game_getcurrentframe   ; get the current frame number into a
 91+  C13E FE 4B            cp 75
 92+  C140 D8               ret c                       ; return if the frame number is below 100
 93+  C141 CD 72 C2         call tank_move              ; move tank if not
 94+  C144 3A F5 C0         ld a,(tank_anim)
 95+  C147 3D               dec a
 96+  C148 32 F5 C0         ld (tank_anim),a            ; decrease the anim count
 97+  C14B C9               ret
 98+  C14C
 99+  C14C              ;
100+  C14C              ; Fires the tank
101+  C14C              ;
102+  C14C              tank_fire:
103+  C14C 3A F9 C0         ld a,(tank_count)            ; if not, don't do anything
104+  C14F 3C               inc a                        ; increment
105+  C150 FE 32            cp 50                        ; have we reached fifty
106+  C152 C2 57 C1         jp nz,tank_fire0
107+  C155 3E 00            ld a,0                       ; reset if reached fifty
108+  C157              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  C157 32 F9 C0         ld (tank_count),a            ; store tank count
110+  C15A FE 00            cp 0
111+  C15C CA 7D C1         jp z,tank_fire7              ; If this is zero, fire
112+  C15F 3A FF C0         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  C162 FE 00            cp 0
114+  C164 C8               ret z                       ; don't do anything if not
115+  C165 CD 2C C2         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  C168 3E 00            ld a,0                       ; reset the flag
117+  C16A 32 FF C0         ld (tank_missile_displayed),a
118+  C16D 3E 02            ld a,2
119+  C16F ED 4B F7 C0      ld bc,(tank_currentdamagecoord)
120+  C173 0C               inc c
121+  C174 0C               inc c
122+  C175 ED 43 41 AB      ld (origcoords),bc
123+  C179 CD 54 A6         call buffer_marklineforupdate
124+  C17C C9               ret                        ; only shoot if we're on 0
125+  C17D              tank_fire7:
126+  C17D 3A F6 C0         ld a,(tank_currentdamage)    ; get the damage countdown
127+  C180 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
128+  C182 C2 B8 C1         jp nz,tank_fire1            ; not, so just do a normal frame
129+  C185 ED 4B F7 C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
130+  C189 79               ld a,c
131+  C18A FE 0A            cp 10
132+  C18C C2 93 C1         jp nz, tank_fire6
133+  C18F CD 64 C2         call tank_killedbytank      ; we're through, so the player has died. Kill them.
134+  C192 C9               ret                         ; return if we're through the mountain
135+  C193              tank_fire6:
136+  C193 3E 0F            ld a,15
137+  C195 32 FA C0         ld (tank_damageframe),a     ; reset the damage frame
138+  C198 21 AF B5         ld hl,sprites               ; location of the empty block
139+  C19B CD 82 A9         call screen_showchar        ; show this character here
140+  C19E ED 4B F7 C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
141+  C1A2 05               dec b                       ; look one above
142+  C1A3 CD E6 A9         call screen_ischarempty     ; check if it is empty
143+  C1A6 ED 4B F7 C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
144+  C1AA FE 01            cp 1
145+  C1AC C2 EF C1         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
146+  C1AF ED 4B F7 C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  C1B3 0D               dec c
148+  C1B4 ED 43 F7 C0      ld (tank_currentdamagecoord),bc ; store the coord
149+  C1B8              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
150+  C1B8 ED 4B F7 C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
151+  C1BC 3A F6 C0         ld a,(tank_currentdamage)    ; get the damage countdown
152+  C1BF E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
153+  C1C1 C2 CC C1         jp nz, tank_fire5
154+  C1C4 CD 16 AA         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
155+  C1C7 FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
156+  C1C9 C2 0D C2         jp nz,tank_fire3            ; if it's a slope, handle this differently
157+  C1CC              tank_fire5:
158+  C1CC 3A FA C0         ld a,(tank_damageframe)
159+  C1CF CD A5 A9         call screen_getblock        ; get the block data into hl
160+  C1D2 CD 82 A9         call screen_showchar        ; show this character here
161+  C1D5 3A FA C0         ld a,(tank_damageframe)
162+  C1D8 3C               inc a
163+  C1D9 32 FA C0         ld (tank_damageframe),a     ; increment the damage block and store
164+  C1DC 3A F6 C0         ld a,(tank_currentdamage)    ; get the damage countdown
165+  C1DF 3D               dec a
166+  C1E0 3D               dec a
167+  C1E1 32 F6 C0         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
168+  C1E4 3A FF C0         ld a,(tank_missile_displayed) ; is the missile displaying?
169+  C1E7 FE 00            cp 0
170+  C1E9 CC 2C C2         call z, tank_missilegraphic
171+  C1EC C3 16 C2         jp tank_fire4
172+  C1EF              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
173+  C1EF 05               dec b
174+  C1F0 C5               push bc
175+  C1F1 CD FF A9         call screen_copyblockdown       ; copy the block down
176+  C1F4 ED 4B F7 C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
177+  C1F8 C1               pop bc                      ; get the coord we just checked back
178+  C1F9 78               ld a,b
179+  C1FA FE 00            cp 0
180+  C1FC CA B8 C1         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
181+  C1FF C5               push bc
182+  C200 05               dec b
183+  C201 CD E6 A9         call screen_ischarempty     ; check if it is empty
184+  C204 C1               pop bc
185+  C205 FE 01            cp 1                        ; if empty
186+  C207 C2 EF C1         jp nz, tank_fire2            ; copy another one down
187+  C20A C3 B8 C1         jp tank_fire1               ; otherwise, return to main thread
188+  C20D              tank_fire3:                      ; dealing with slopes
189+  C20D 3A F6 C0         ld a,(tank_currentdamage)    ; get the damage countdown
190+  C210 06 08            ld b,8
191+  C212 90               sub b                        ; special case for slopes
192+  C213 32 F6 C0         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
193+  C216              tank_fire4:                     ; TIDY UP
194+  C216 ED 4B F7 C0      ld bc,(tank_currentdamagecoord)
195+  C21A ED 43 41 AB      ld (origcoords),bc
196+  C21E CD 54 A6         call buffer_marklineforupdate
197+  C221 3E 01            ld a,1
198+  C223 CD 54 A6         call buffer_marklineforupdate
199+  C226 3E 02            ld a,2
200+  C228 CD 54 A6         call buffer_marklineforupdate
201+  C22B C9               ret
202+  C22C
203+  C22C              ;
204+  C22C              ; Displays or hides the missile graphic, and changes the gun
205+  C22C              ;
206+  C22C              tank_missilegraphic:
207+  C22C 3A FF C0         ld a,(tank_missile_displayed)
208+  C22F FE 00            cp 0
209+  C231 C2 39 C2         jp nz,tank_missilegraphic0
210+  C234 3E 13            ld a,19
211+  C236 C3 3B C2         jp tank_missilegraphic1
212+  C239              tank_missilegraphic0:
213+  C239 3E 00            ld a,0
214+  C23B              tank_missilegraphic1:
215+  C23B 32 FF C0         ld (tank_missile_displayed),a ; store the flipped graphic
216+  C23E ED 4B F7 C0      ld bc,(tank_currentdamagecoord)
217+  C242 0C               inc c
218+  C243 0C               inc c                   ; print the graphic 2 spaces right
219+  C244 CD A5 A9         call screen_getblock        ; get the block data into hl
220+  C247 CD 82 A9         call screen_showchar        ; show this character here
221+  C24A 06 02            ld b,2
222+  C24C 0E 18            ld c,24                     ; set gunbarrel coords
223+  C24E 11 00 00         ld de,0
224+  C251 21 7B B7         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
225+  C254 3A FF C0         ld a,(tank_missile_displayed)
226+  C257 FE 00            cp 0
227+  C259 CA 5F C2         jp z,tank_missilegraphic2
228+  C25C 11 40 00         ld de,64
229+  C25F              tank_missilegraphic2:
230+  C25F 19               add hl,de                   ; work out missile graphic
231+  C260 CD 82 A9         call screen_showchar        ; show this character here
232+  C263 C9               ret
233+  C264
234+  C264              ;
235+  C264              ; Deal with the player being killed by the tank
236+  C264              ;
237+  C264              tank_killedbytank:
238+  C264 ED 4B F7 C0      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
239+  C268 21 AF B5         ld hl,sprites                   ; empty sprite
240+  C26B CD 82 A9         call screen_showchar            ; hide the last piece of dirt
241+  C26E CD A9 BE         call player_tankkillplayer
242+  C271 C9               ret
243+  C272
244+  C272              tank_move:
245+  C272 ED 4B F2 C0      ld bc,(tank_initpos2)
246+  C276 C5               push bc
247+  C277 3A F5 C0         ld a,(tank_anim)
248+  C27A FE 11            cp 17                       ; check first time flag
249+  C27C CA 8E C2         jp z,tank_move1             ; don't draw over previous one if first time
250+  C27F CD 93 C2         call tank_draw_full         ; delete old one
251+  C282 ED 4B F2 C0      ld bc,(tank_initpos2)       ; get the current coords
252+  C286 78               ld a,b
253+  C287 D6 01            sub 1                       ; move back one pixels
254+  C289 47               ld b,a
255+  C28A ED 43 F2 C0      ld (tank_initpos2),bc
256+  C28E              tank_move1:
257+  C28E CD 93 C2         call tank_draw_full         ; draw the tank
258+  C291 C1               pop bc
259+  C292 C9               ret
260+  C293
261+  C293              tank_draw_full:
262+  C293 21 7B B7         ld hl,tank_sprite
263+  C296 ED 4B F2 C0      ld bc,(tank_initpos2)         ; load bc with the start coords
264+  C29A 22 FB C0         ld (tank_current_sprite),hl  ; put into memory
265+  C29D ED 43 FD C0      ld (tank_current_coords),bc  ; put into memory
266+  C2A1 CD C0 C2         call tank_draw
267+  C2A4 08               ex af,af'
268+  C2A5 3A F4 C0         ld a,(tank_frame)            ; get the animation frame
269+  C2A8 16 00            ld d,0
270+  C2AA 5F               ld e,a
271+  C2AB 19               add hl,de
272+  C2AC 22 FB C0         ld (tank_current_sprite),hl  ; put into memory
273+  C2AF 08               ex af,af'
274+  C2B0 ED 4B F2 C0      ld bc,(tank_initpos2)         ; load bc with the start coords
275+  C2B4 81 C6 08         add c,8                      ; move one line down
276+  C2B7 4F               ld c,a
277+  C2B8 ED 43 FD C0      ld (tank_current_coords),bc  ; put into memory
278+  C2BC CD C0 C2         call tank_draw
279+  C2BF C9               ret
280+  C2C0
281+  C2C0              ;
282+  C2C0              ; Draw the tank
283+  C2C0              ; Inputs:
284+  C2C0              ; None, all in memory
285+  C2C0              ;
286+  C2C0              tank_draw:
287+  C2C0 3E 04            ld a,4                              ; 4 pieces per half
288+  C2C2              tank_draw0:
289+  C2C2 F5               push af
290+  C2C3 2A FB C0         ld hl,(tank_current_sprite)
291+  C2C6 ED 4B FD C0      ld bc,(tank_current_coords)         ; load bc with the start coords
292+  C2CA CD 2A AA         call sprites_drawsprite
293+  C2CD 2A FB C0         ld hl,(tank_current_sprite)
294+  C2D0 ED 4B FD C0      ld bc,(tank_current_coords)         ; load bc with the start coords
295+  C2D4 11 08 00         ld de,8
296+  C2D7 19               add hl,de
297+  C2D8 80 C6 08         add b,8
298+  C2DB 47               ld b,a
299+  C2DC 22 FB C0         ld (tank_current_sprite),hl         ; put into memory
300+  C2DF ED 43 FD C0      ld (tank_current_coords),bc         ; put into memory
301+  C2E3 F1               pop af
302+  C2E4 3D               dec a
303+  C2E5 FE 00            cp 0
304+  C2E7 C2 C2 C2         jp nz,tank_draw0
305+  C2EA
306+  C2EA C9               ret
307+  C2EB
# file closed: game/tank.asm
 43   C2EB                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  C2EB              ;
  2+  C2EB              ; A structure of falling rocks
  3+  C2EB              ; Assume we'll never have more than 4 falling at any one time
  4+  C2EB              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  C2EB              ;
  6+  C2EB              rocks_falling:
  7+  C2EB 00 00 00 00      defb 0,0,0,0
  8+  C2EF 00 00 00 00      defb 0,0,0,0
  9+  C2F3 00 00 00 00      defb 0,0,0,0
 10+  C2F7 00 00 00 00      defb 0,0,0,0
 11+  C2FB
 12+  C2FB              rocks_tmp:
 13+  C2FB 00               defb 0
 14+  C2FC
 15+  C2FC              rocks_tmp2:
 16+  C2FC 00 00            defb 0,0
 17+  C2FE
 18+  C2FE              ;
 19+  C2FE              ; The number of frames to wobble for
 20+  C2FE              ; Must always be 10 more than the number of frames a player digs
 21+  C2FE              ;
 22+  C2FE              rocks_numberofframestowobble:
 23+  C2FE 14               defb 20
 24+  C2FF
 25+  C2FF              ;
 26+  C2FF              ; Coords of the rock that killed us
 27+  C2FF              ;
 28+  C2FF              rocks_killerrock:
 29+  C2FF 00 00            defb 0,0
 30+  C301
 31+  C301              ;
 32+  C301              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  C301              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  C301              ; If the pixel row is not the rock bottom, stop checking.
 35+  C301              ; Inputs:
 36+  C301              ; hl- memory location
 37+  C301              ;
 38+  C301              rocks_checkforfalling:
 39+  C301 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  C302 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  C304 C2 0A C3         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  C307 CD 0B C3         call rocks_addrocktofalling ; mark the rock as falling
 43+  C30A              rocks_checkforfalling2:
 44+  C30A C9               ret
 45+  C30B
 46+  C30B              ;
 47+  C30B              ; Adds the rock to the structure that tracks falling rocks
 48+  C30B              ; Inputs:
 49+  C30B              ; hl - memory location of falling rock graphic
 50+  C30B              ; bc - coords of rock, c vert
 51+  C30B              rocks_addrocktofalling:
 52+  C30B C5               push bc             ; store the coords
 53+  C30C 11 EB C2         ld de,rocks_falling
 54+  C30F 06 04            ld b,4              ; number of possible falling rocks
 55+  C311              rocks_addrocktofalling0:
 56+  C311 13               inc de
 57+  C312                  ;inc de
 58+  C312 13               inc de              ; move three along to get the state
 59+  C313 1A               ld a,(de)           ; load the state
 60+  C314 FE 00            cp 0                ; check if this is not falling
 61+  C316 C2 2D C3         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  C319 13               inc de              ; move to frame
 63+  C31A 3A FE C2         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  C31D 12               ld (de),a
 65+  C31E 1B               dec de              ; move de back to state
 66+  C31F 3E 02            ld a,2
 67+  C321 12               ld (de),a           ; set the state to wobbling
 68+  C322 1B               dec de              ; move back coords
 69+  C323 C1               pop bc              ; get back coords
 70+  C324 78               ld a,b
 71+  C325 12               ld (de),a           ; store the vertical
 72+  C326 1B               dec de
 73+  C327 79               ld a,c
 74+  C328 12               ld (de),a           ; store the horizontal
 75+  C329 C5               push bc
 76+  C32A C3 31 C3         jp rocks_addrocktofalling2 ; done
 77+  C32D              rocks_addrocktofalling1:
 78+  C32D 13               inc de
 79+  C32E 13               inc de              ; move memory along to next rock
 80+  C32F 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  C331              rocks_addrocktofalling2: ; done, return
 82+  C331 C1               pop bc              ; to tidy up
 83+  C332 C9               ret
 84+  C333
 85+  C333              ;
 86+  C333              ; Processes any falling rocks
 87+  C333              ;
 88+  C333              rocks_processrocks:
 89+  C333 DD 21 EB C2      ld ix,rocks_falling
 90+  C337 06 04            ld b,4              ; the number of rocks to check
 91+  C339              rocks_processrocks0:
 92+  C339 C5               push bc             ; store loop count
 93+  C33A DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  C33E 46 01
 94+  C340 DD 23            inc ix
 95+  C342 DD 23            inc ix              ; move to the state
 96+  C344 DD 7E 00         ld a,(ix)           ; load the state into a
 97+  C347 FE 00            cp 0
 98+  C349 CA 6A C3         jp z,rocks_processrocks3 ; if not falling, check next
 99+  C34C FE 02            cp 2
100+  C34E C2 5E C3         jp nz, rocks_processrocks2
101+  C351                  ; we're wobbling
102+  C351 DD 23            inc ix              ; get frame number for wobble
103+  C353 DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  C356 CD 2D C4         call rocks_wobble
105+  C359 DD 23            inc ix              ; increment for next
106+  C35B C3 6E C3         jp rocks_processrocks1  ; do next rock
107+  C35E              rocks_processrocks2:
108+  C35E                  ; we're falling
109+  C35E C5               push bc
110+  C35F CD 72 C3         call rocks_fall
111+  C362 C1               pop bc
112+  C363 DD 23            inc ix
113+  C365 DD 23            inc ix              ; inc ix to get to next
114+  C367 C3 6E C3         jp rocks_processrocks1
115+  C36A              rocks_processrocks3:
116+  C36A DD 23            inc ix
117+  C36C DD 23            inc ix
118+  C36E              rocks_processrocks1:
119+  C36E C1               pop bc              ; get loop count back
120+  C36F 10 C8            djnz rocks_processrocks0
121+  C371 C9               ret
122+  C372
123+  C372              ;
124+  C372              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  C372              ; bc - coord of current rock graphic on screen
126+  C372              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  C372              ;
128+  C372              rocks_fall:
129+  C372 DD 2B            dec ix
130+  C374 DD 2B            dec ix              ; decrease ix back to coords
131+  C376 ED 43 FC C2      ld (rocks_tmp2),bc  ; store original coords
132+  C37A 3E 03            ld a,3              ; move this number of pixels
133+  C37C              rocks_fall1:
134+  C37C 32 FB C2         ld (rocks_tmp),a    ; store loop counter
135+  C37F DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  C383 46 01
136+  C385 CD 1F AB         call sprites_scadd  ; get the memory of the coords into de
137+  C388 14               inc d               ; add 256 to get next row
138+  C389 1A               ld a,(de)           ; get the contents of the next row
139+  C38A FE 00            cp 0
140+  C38C C2 EC C3         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  C38F 0C               inc c               ; increment the vertical
142+  C390 DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  C394 70 01
143+  C396 79               ld a,c              ; get the vertical coord into a
144+  C397 E6 07            and 7               ; divisible by 8?
145+  C399 FE 00            cp 0
146+  C39B C2 B8 C3         jp nz,rocks_fall4   ; if not, carry on
147+  C39E CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  C3A1 3E 42            ld a,66             ; load red
149+  C3A3 CD B0 A9         call screen_setattr
150+  C3A6 DD 4E 00 DD      ld bc,(ix)
150+  C3AA 46 01
151+  C3AC 79               ld a,c              ; get vertical
152+  C3AD D6 08            sub 8               ; look up one square
153+  C3AF 4F               ld c,a              ; put a back in c
154+  C3B0 CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  C3B3 3E 46            ld a,70             ; load yellow
156+  C3B5 CD B0 A9         call screen_setattr
157+  C3B8              rocks_fall4:
158+  C3B8 3A FB C2         ld a,(rocks_tmp)    ; get the loop counter
159+  C3BB 3D               dec a
160+  C3BC FE 00            cp 0
161+  C3BE C2 7C C3         jp nz,rocks_fall1   ; do another pixel if needed
162+  C3C1              rocks_fall2:
163+  C3C1 3E 09            ld a,9              ; rock graphic
164+  C3C3 ED 4B FC C2      ld bc,(rocks_tmp2)  ; get the original coords
165+  C3C7 CD A5 A9         call screen_getblock     ; get the memory into hl
166+  C3CA CD 2A AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  C3CD 3E 09            ld a,9
168+  C3CF DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  C3D3 46 01
169+  C3D5 CD A5 A9         call screen_getblock     ; get the memory into hl
170+  C3D8 CD 2A AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  C3DB DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  C3DF 46 01
172+  C3E1 CD 12 C4         call rocks_checkforplayer ; check to see if we hit a player
173+  C3E4 DD 23            inc ix
174+  C3E6 DD 23            inc ix                  ; get ix back to state
175+  C3E8 CD 02 C4         call rocks_makesound
176+  C3EB C9               ret
177+  C3EC              rocks_fall3:
178+  C3EC 3E 00            ld a,0              ; set the state to fell
179+  C3EE DD 77 02         ld (ix+2),a           ; store the falling state
180+  C3F1 DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  C3F5 46 01
181+  C3F7 CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  C3FA 3E 42            ld a,66             ; load magenta
183+  C3FC CD B0 A9         call screen_setattr
184+  C3FF C3 C1 C3         jp rocks_fall2      ; rejoin main loop
185+  C402
186+  C402              ;
187+  C402              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  C402              ;
189+  C402              rocks_makesound:
190+  C402 DD 7E 00         ld a,(ix)           ; get the state
191+  C405 FE 00            cp 0
192+  C407 C0               ret nz              ; if we haven't fallen, don't do anything
193+  C408 21 9D BD         ld hl,player+11
194+  C40B 7E               ld a,(hl)
195+  C40C FE 01            cp 1
196+  C40E C4 E0 AF         call nz, sound_rockfell ; only make sound if didn't kill player
197+  C411 C9               ret
198+  C412
199+  C412              ;
200+  C412              ; Checks to see if the rock is hitting a player
201+  C412              ; Inputs:
202+  C412              ; bc - coords of rock we're checking
203+  C412              rocks_checkforplayer:
204+  C412 ED 5B 92 BD      ld de,(player)       ; get the player coords
205+  C416 7B               ld a,e               ; get the vert coord first
206+  C417 91               sub c                ; subtract the rock vertical coord from players
207+  C418 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  C41A C0               ret nz               ; if not, hasn't hit
209+  C41B 7A               ld a,d               ; get the player horiz coord
210+  C41C 90               sub b                ; subtract rock coord
211+  C41D C6 07            add 7                ; add max distance
212+  C41F FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  C421 DA 25 C4         jp c,rocks_checkforplayer0
214+  C424 C9               ret
215+  C425              rocks_checkforplayer0:
216+  C425 ED 43 FF C2      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  C429 CD A3 BE         call player_crushplayer ; if so, jump out
218+  C42C C9               ret
219+  C42D
220+  C42D              ;
221+  C42D              ; Wobbles a rocks
222+  C42D              ; Inputs:
223+  C42D              ; bc - coord of current rock graphic on screen
224+  C42D              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  C42D              ; a - wobble frame
226+  C42D              rocks_wobble:
227+  C42D DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  C430 E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  C432 1E 09            ld e,9              ; this is the rock frame
230+  C434 83               add a,e             ; add the frame toggle
231+  C435 C5               push bc
232+  C436 CD A5 A9         call screen_getblock     ; get the memory into hl
233+  C439 CD 2A AA         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  C43C DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  C43F 3D               dec a               ; decrease
236+  C440 DD 77 00         ld (ix),a           ; store
237+  C443 E6 01            and 1
238+  C445 1E 09            ld e,9              ; this is the rock frame
239+  C447 83               add a,e             ; add the frame toggle
240+  C448 CD A5 A9         call screen_getblock     ; get the memory into hl
241+  C44B C1               pop bc
242+  C44C CD 2A AA         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  C44F DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  C452 FE 00            cp 0
245+  C454 C0               ret nz              ; if we're not at zero, return
246+  C455 DD 2B            dec ix              ; otherwise look to state location
247+  C457 3E 01            ld a,1              ; set the state to falling
248+  C459 DD 77 00         ld (ix),a           ; store the falling state
249+  C45C DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  C45E C9               ret
251+  C45F
# file closed: game/rocks.asm
 44   C45F                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  C45F              ;
  2+  C45F              ; The score of the current player
  3+  C45F              ;
  4+  C45F              scores_current:
  5+  C45F 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  C463 30 30 30 30
  5+  C467 FF
  6+  C468
  7+  C468              scores_defaultname:
  8+  C468 2D 2D 2D         defb '---'
  9+  C46B
 10+  C46B              ;
 11+  C46B              ; The current high score table
 12+  C46B              ;
 13+  C46B              scores_table:
 14+  C46B 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  C46F 4D 30 30 30
 14+  C473 30 30 30 FF
 15+  C477 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  C47B 4D 30 30 30
 15+  C47F 30 30 30 FF
 16+  C483 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  C487 4D 30 30 30
 16+  C48B 30 30 30 FF
 17+  C48F
 18+  C48F              ;
 19+  C48F              ; Add thousands to the score
 20+  C48F              ; Inputs:
 21+  C48F              ; b - number to add
 22+  C48F              ;
 23+  C48F              scores_addthousands:
 24+  C48F 21 63 C4         ld hl,scores_current+4
 25+  C492 CD C3 C4         call scores_update
 26+  C495 C9               ret
 27+  C496
 28+  C496              ;
 29+  C496              ; Add hundreds to the score
 30+  C496              ; Inputs:
 31+  C496              ; b - number to add
 32+  C496              ;
 33+  C496              scores_addhundreds:
 34+  C496 21 64 C4         ld hl,scores_current+5
 35+  C499 CD C3 C4         call scores_update
 36+  C49C C9               ret
 37+  C49D
 38+  C49D              ;
 39+  C49D              ; Prints the score to screen
 40+  C49D              ;
 41+  C49D              scores_printscore:
 42+  C49D 3A 5B BD         ld a,(game_currentplayer)   ; get current player
 43+  C4A0 21 5F C4         ld hl,scores_current
 44+  C4A3 FE 01            cp 1
 45+  C4A5 C2 AD C4         jp nz, score_printscore0    ; if not player 1
 46+  C4A8 36 04            ld (hl),4       ; set position for player 1
 47+  C4AA C3 AF C4         jp score_printscore1
 48+  C4AD              score_printscore0:
 49+  C4AD 36 16            ld (hl),22       ; set position for player 2
 50+  C4AF              score_printscore1:
 51+  C4AF 21 5F C4         ld hl,scores_current
 52+  C4B2 CD 54 85         call string_print
 53+  C4B5 C9               ret
 54+  C4B6
 55+  C4B6              ;
 56+  C4B6              ; Prints both scores to screen
 57+  C4B6              ;
 58+  C4B6              scores_printscores:
 59+  C4B6 21 89 BE         ld hl,player1_score
 60+  C4B9 CD 54 85         call string_print
 61+  C4BC 21 92 BE         ld hl,player2_score
 62+  C4BF CD 54 85         call string_print
 63+  C4C2 C9               ret
 64+  C4C3
 65+  C4C3              ;
 66+  C4C3              ; Updates the current score.
 67+  C4C3              ; Inputs:
 68+  C4C3              ; hl - memory location of the score column
 69+  C4C3              ; b - number to add
 70+  C4C3              ;
 71+  C4C3              scores_update:
 72+  C4C3 7E               ld a,(hl)           ; current value of digit.
 73+  C4C4 80               add a,b             ; add points to this digit.
 74+  C4C5 77               ld (hl),a           ; place new digit back in string.
 75+  C4C6 FE 3A            cp 58               ; more than ASCII value '9'?
 76+  C4C8 D8               ret c               ; no - relax.
 77+  C4C9 D6 0A            sub 10              ; subtract 10.
 78+  C4CB 77               ld (hl),a           ; put new character back in string.
 79+  C4CC              scores_update0:
 80+  C4CC 2B               dec hl              ; previous character in string.
 81+  C4CD 34               inc (hl)            ; up this by one.
 82+  C4CE 7E               ld a,(hl)           ; what's the new value?
 83+  C4CF FE 3A            cp 58               ; gone past ASCII nine?
 84+  C4D1 D8               ret c               ; no, scoring done.
 85+  C4D2 D6 0A            sub 10              ; down by ten.
 86+  C4D4 77               ld (hl),a           ; put it back
 87+  C4D5 C3 CC C4         jp scores_update0   ; go round again.
 88+  C4D8
 89+  C4D8
 90+  C4D8              ;
 91+  C4D8              ; Displays the high score table at the bottom of the screen
 92+  C4D8              ;
 93+  C4D8              scores_showtable:
 94+  C4D8 21 6B C4         ld hl, scores_table
 95+  C4DB CD 54 85         call string_print
 96+  C4DE 21 77 C4         ld hl, scores_table+12
 97+  C4E1 CD 54 85         call string_print
 98+  C4E4 21 83 C4         ld hl, scores_table+24
 99+  C4E7 CD 54 85         call string_print
100+  C4EA C9               ret
101+  C4EB
102+  C4EB              ;
103+  C4EB              ; Place to store the current position we're checking
104+  C4EB              ;
105+  C4EB              scores_highscoretmp:
106+  C4EB 00               defb 0
107+  C4EC
108+  C4EC              ;
109+  C4EC              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
110+  C4EC              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
111+  C4EC              ;
112+  C4EC              scores_processhighscores:
113+  C4EC 21 EB C4         ld hl,scores_highscoretmp
114+  C4EF 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
115+  C4F1 3E 1D            ld a,29
116+  C4F3              scores_processhighscores3:
117+  C4F3 21 6B C4         ld hl,scores_table          ; position of first score column
118+  C4F6 5F               ld e,a
119+  C4F7 16 00            ld d,0
120+  C4F9 19               add hl,de
121+  C4FA 08               ex af,af'                   ; store a for later
122+  C4FB 11 61 C4         ld de,scores_current+2      ; position of current score column
123+  C4FE 06 06            ld b,6                      ; times to loop
124+  C500              scores_processhighscores0:
125+  C500 7E               ld a,(hl)
126+  C501 4F               ld c,a                      ; get first score column
127+  C502 1A               ld a,(de)                   ; get first current column
128+  C503 B9               cp c                        ; compare current with first
129+  C504 DA 15 C5         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
130+  C507 23               inc hl
131+  C508 13               inc de                      ; move to next column
132+  C509 10 F5            djnz scores_processhighscores0 ; loop
133+  C50B 08               ex af,af'                     ; still here, so must be bigger
134+  C50C 32 EB C4         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
135+  C50F 0E 0C            ld c,12
136+  C511 91               sub c
137+  C512 D2 F3 C4         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
138+  C515              scores_processhighscores4
139+  C515 CD 19 C5         call scores_updatehighscores
140+  C518 C9               ret
141+  C519
142+  C519              ;
143+  C519              ; Update score table
144+  C519              ;
145+  C519              scores_updatehighscores:
146+  C519 3A EB C4         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
147+  C51C FE 00            cp 0
148+  C51E C8               ret z                       ; if this is 0, didn't get a high score
149+  C51F FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
150+  C521 CA 54 C5         jp z, scores_updatehighscores3
151+  C524                                              ; copy old score over one below, if not first
152+  C524 21 6B C4         ld hl,scores_table
153+  C527 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
154+  C52A 19               add hl,de                   ; position of first column
155+  C52B 2B               dec hl
156+  C52C 2B               dec hl
157+  C52D 2B               dec hl
158+  C52E E5               push hl
159+  C52F 11 0C 00         ld de,12
160+  C532 19               add hl,de                   ; get position of next score
161+  C533 54 5D            ld de,hl
162+  C535 E1               pop hl                      ; get hl back
163+  C536 01 09 00         ld bc,9
164+  C539 ED B0            ldir
165+  C53B FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
166+  C53D CA 54 C5         jp z,scores_updatehighscores3
167+  C540 21 6B C4         ld hl,scores_table
168+  C543 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
169+  C546 19               add hl,de                   ; position of first column
170+  C547 E5               push hl
171+  C548 11 0C 00         ld de,12
172+  C54B 19               add hl,de                   ; get position of next score
173+  C54C 54 5D            ld de,hl
174+  C54E E1               pop hl                      ; get hl back
175+  C54F 01 09 00         ld bc,9
176+  C552 ED B0            ldir
177+  C554              scores_updatehighscores3:
178+  C554 06 06            ld b,6                      ; now overwrite
179+  C556 21 6B C4         ld hl,scores_table
180+  C559 16 00            ld d,0
181+  C55B 5F               ld e,a
182+  C55C 19               add hl,de                   ; position of first column
183+  C55D 08               ex af,af'
184+  C55E 11 61 C4         ld de,scores_current+2      ; position of current score column
185+  C561              scores_updatehighscores2:
186+  C561 1A               ld a,(de)
187+  C562 77               ld (hl),a
188+  C563 23               inc hl
189+  C564 13               inc de
190+  C565 10 FA            djnz scores_updatehighscores2
191+  C567 11 09 00         ld de,9
192+  C56A ED 52            sbc hl,de
193+  C56C 54 5D            ld de,hl                    ; get back to start of entry
194+  C56E 21 68 C4         ld hl,scores_defaultname    ; still need to overwrite the name
195+  C571 01 03 00         ld bc,3                      ; 3 chars to copy
196+  C574 ED B0            ldir
197+  C576 C9               ret
# file closed: game/scores.asm
 45   C577                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  C577              diamonds_tmp:
  2+  C577 00               defb 0
  3+  C578
  4+  C578              diamonds_tmp2:
  5+  C578 00               defb 0
  6+  C579
  7+  C579              ;
  8+  C579              ; Holds the number of thousands for the current gem type
  9+  C579              ;
 10+  C579              diamonds_score:
 11+  C579 00               defb 0
 12+  C57A
 13+  C57A              ;
 14+  C57A              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  C57A              ; Inputs:
 16+  C57A              ; hl - memory location of gem type
 17+  C57A              diamonds_twinkle_type:
 18+  C57A CD 81 BD         call game_getcurrentframe       ; get current frame number
 19+  C57D E6 07            and 7                           ; want a number from 0-7
 20+  C57F C6 40            add 64                          ; add to 60 to get attr colour
 21+  C581 32 78 C5         ld (diamonds_tmp2),a             ; store the colour
 22+  C584              diamonds_twinkle_type0:
 23+  C584 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  C588 79               ld a,c                          ; load c into a
 25+  C589 FE FF            cp 255                          ; is this the end?
 26+  C58B CA B3 C5         jp z,diamonds_twinkle_type1           ; step out if so
 27+  C58E 23               inc hl
 28+  C58F 23               inc hl
 29+  C590 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  C591 FE 01            cp 1
 31+  C593 CA B4 C5         jp z,diamonds_twinkle_type2           ; step out if so
 32+  C596 CD F4 C5         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  C599 DC BB C5         call c,diamonds_collect     ; we collided
 34+  C59C 23               inc hl
 35+  C59D E5               push hl
 36+  C59E E5 DD E1         ld ix,hl
 37+  C5A1 DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  C5A5 46 FE
 38+  C5A7 3A 78 C5         ld a,(diamonds_tmp2)
 39+  C5AA CD B0 A9         call screen_setattr
 40+  C5AD E1               pop hl
 41+  C5AE 23               inc hl
 42+  C5AF 23               inc hl                          ; move to next diamond
 43+  C5B0 C3 84 C5         jp diamonds_twinkle_type0
 44+  C5B3              diamonds_twinkle_type1:
 45+  C5B3 C9               ret
 46+  C5B4              diamonds_twinkle_type2:
 47+  C5B4 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  C5B5 23               inc hl
 49+  C5B6 23               inc hl
 50+  C5B7 08               ex af,af'
 51+  C5B8 C3 84 C5         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  C5BB
 53+  C5BB              ;
 54+  C5BB              ; Collect the diamond we collided with
 55+  C5BB              ; Inputs:
 56+  C5BB              ; hl - memory location of current diamond, currently on state
 57+  C5BB              ; Output:
 58+  C5BB              ; a - 70 - for yellow on black
 59+  C5BB              diamonds_collect:
 60+  C5BB 36 01            ld (hl),1                       ; collected
 61+  C5BD E5               push hl
 62+  C5BE 2B               dec hl
 63+  C5BF 2B               dec hl
 64+  C5C0 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  C5C4 CD 68 A9         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  C5C7 ED 5B 77 C5      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  C5CB 16 00            ld d,0
 68+  C5CD 21 AF B5         ld hl,sprites
 69+  C5D0 19               add hl,de
 70+  C5D1 CD 2A AA         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  C5D4 E1               pop hl
 72+  C5D5 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  C5D7 32 78 C5         ld (diamonds_tmp2),a
 74+  C5DA D9               exx
 75+  C5DB 3A 79 C5         ld a,(diamonds_score)
 76+  C5DE 47               ld b,a
 77+  C5DF CD 8F C4         call scores_addthousands
 78+  C5E2 3A 77 C5         ld a,(diamonds_tmp)
 79+  C5E5 FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  C5E7 C2 EF C5         jp nz,diamonds_collect0
 81+  C5EA 21 9F BD         ld hl,player+13
 82+  C5ED 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  C5EF              diamonds_collect0:
 84+  C5EF CD C3 AF         call sound_gemcollected
 85+  C5F2 D9               exx
 86+  C5F3 C9               ret
 87+  C5F4
 88+  C5F4              ;
 89+  C5F4              ; Checks to see if the gem is hitting a player
 90+  C5F4              ; Inputs:
 91+  C5F4              ; bc - coords of diamond we're checking
 92+  C5F4              diamonds_checkforplayer:
 93+  C5F4 78               ld a,b               ; multiply b by 8
 94+  C5F5 07               rlca
 95+  C5F6 07               rlca
 96+  C5F7 07               rlca
 97+  C5F8 47               ld b,a
 98+  C5F9 ED 5B 92 BD      ld de,(player)       ; get the player coords
 99+  C5FD 7B               ld a,e               ; get the vert coord first
100+  C5FE 90               sub b                ; subtract the diamond vertical coord from players
101+  C5FF C6 04            add 4                ; add the max distance
102+  C601 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  C603 D0               ret nc               ; if not, hasn't hit
104+  C604 79               ld a,c               ; multiply c by 8
105+  C605 07               rlca
106+  C606 07               rlca
107+  C607 07               rlca
108+  C608 4F               ld c,a
109+  C609 7A               ld a,d               ; get the player horiz coord
110+  C60A 91               sub c                ; subtract rock coord
111+  C60B C6 04            add 4                ; add max distance
112+  C60D FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  C60F D0               ret nc
114+  C610 3E 00            ld a,0
115+  C612 C9               ret
116+  C613
117+  C613
118+  C613              ;
119+  C613              ; Initialise diamonds and gems
120+  C613              ;
121+  C613              diamonds_twinkle
122+  C613 21 79 C5         ld hl,diamonds_score
123+  C616 36 02            ld (hl),2         ; store the score we'll add
124+  C618 21 77 C5         ld hl,diamonds_tmp
125+  C61B 36 40            ld (hl),64         ; store the location the diamond sprite
126+  C61D 21 2A B5         ld hl, level01diamonds
127+  C620 CD 7A C5         call diamonds_twinkle_type
128+  C623 21 79 C5         ld hl,diamonds_score
129+  C626 36 01            ld (hl),1         ; store the score we'll add
130+  C628 21 77 C5         ld hl,diamonds_tmp
131+  C62B 36 70            ld (hl),112         ; store the location the gem sprite
132+  C62D 21 3A B5         ld hl, level01gems
133+  C630 CD 7A C5         call diamonds_twinkle_type
134+  C633 C9               ret
135+  C634
136+  C634              ;
137+  C634              ; Initialise diamonds and gems
138+  C634              ;
139+  C634              diamonds_init:
140+  C634 21 2A B5         ld hl, level01diamonds
141+  C637 CD 41 C6         call diamonds_init_type
142+  C63A 21 3A B5         ld hl, level01gems
143+  C63D CD 41 C6         call diamonds_init_type
144+  C640 C9               ret
145+  C641
146+  C641              ;
147+  C641              ; Initialise diamonds or gems, get memory addresses
148+  C641              ; Inputs:
149+  C641              ; hl - memory location
150+  C641              diamonds_init_type:
151+  C641 4E               ld c,(hl)                      ; get coords into c
152+  C642 79               ld a,c                          ; load c into add
153+  C643 FE FF            cp 255                          ; is this the end?
154+  C645 CA 5C C6         jp z,diamonds_init_type1             ; step out if so
155+  C648 23               inc hl
156+  C649 46               ld b,(hl)                       ; get coords into b
157+  C64A E5               push hl
158+  C64B CD 19 A9         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  C64E E1               pop hl
160+  C64F 23               inc hl                          ; move to state
161+  C650 36 00            ld (hl),0
162+  C652 23               inc hl                          ; move to memory
163+  C653 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  C657 23               inc hl                          ; move to next diamond
165+  C658 23               inc hl
166+  C659 C3 41 C6         jp diamonds_init_type
167+  C65C              diamonds_init_type1:
168+  C65C C9               ret
# file closed: game/diamonds.asm
 46   C65D                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  C65D              ;
  2+  C65D              ; Controls when missiles fall
  3+  C65D              ;
  4+  C65D              missiles_count:
  5+  C65D 00               defb 0
  6+  C65E
  7+  C65E              ;
  8+  C65E              ; A structure of falling missiles
  9+  C65E              ; Assume we'll never have more than 4 falling at any one time
 10+  C65E              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  C65E              ;
 12+  C65E              missiles_falling:
 13+  C65E 00 00 00         defb 0,0,0
 14+  C661 00 00 00         defb 0,0,0
 15+  C664 00 00 00         defb 0,0,0
 16+  C667 00 00 00         defb 0,0,0
 17+  C66A
 18+  C66A              ;
 19+  C66A              ; The coords of the missile that killed us
 20+  C66A              ;
 21+  C66A              missiles_killermissile:
 22+  C66A 00 00            defb 0,0
 23+  C66C
 24+  C66C              ;
 25+  C66C              ; Zeroes the state of each missile
 26+  C66C              ;
 27+  C66C              missiles_init:
 28+  C66C 06 0C            ld b,12
 29+  C66E DD 21 B1 B4      ld ix,level01missiles
 30+  C672              missiles_init0:
 31+  C672 DD 36 02 00      ld (ix+2),0               ; set the state to zero
 32+  C676 11 05 00         ld de,5
 33+  C679 DD 19            add ix,de
 34+  C67B DD 36 02 00      ld (ix+2),0
 35+  C67F DD 19            add ix,de
 36+  C681 10 EF            djnz missiles_init0
 37+  C683 06 04            ld b,4                  ; reset four falling missiles
 38+  C685 21 5E C6         ld hl,missiles_falling
 39+  C688              missiles_init1:
 40+  C688 36 00            ld (hl),0
 41+  C68A 23               inc hl
 42+  C68B 36 00            ld (hl),0
 43+  C68D 23               inc hl
 44+  C68E 36 00            ld (hl),0
 45+  C690 23               inc hl
 46+  C691 10 F5            djnz missiles_init1
 47+  C693 C9               ret
 48+  C694
 49+  C694              ;
 50+  C694              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 51+  C694              ; Processes any already falling missiles
 52+  C694              ;
 53+  C694              missiles_process:
 54+  C694 3A 9D BD         ld a,(player+11)                        ; check if the player was hit by a missile previously
 55+  C697 FE 03            cp 3
 56+  C699 C2 A0 C6         jp nz,missiles_process3                 ; if not, continue
 57+  C69C CD DD C7         call missiles_zonkplayer
 58+  C69F C9               ret
 59+  C6A0              missiles_process3:
 60+  C6A0 3A A1 BD         ld a,(player_location)
 61+  C6A3 FE 01            cp 1
 62+  C6A5 C2 13 C7         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 63+  C6A8 21 9F BD         ld hl,player+13
 64+  C6AB 7E               ld a,(hl)                               ; check if player has collected a diamond
 65+  C6AC FE 01            cp 1
 66+  C6AE C2 13 C7         jp nz, missiles_process0                ; don't activate if not
 67+  C6B1 21 5D C6         ld hl,missiles_count
 68+  C6B4 7E               ld a,(hl)                   ; get the missiles count
 69+  C6B5 3C               inc a
 70+  C6B6 FE 32            cp 50                                   ; have we reached the count yet
 71+  C6B8 CA BF C6         jp z,missiles_process2                 ; if not, don't activate a new one
 72+  C6BB 77               ld (hl),a                               ; store the updated count, and continue without activating
 73+  C6BC C3 13 C7         jp missiles_process0
 74+  C6BF              missiles_process2:
 75+  C6BF 36 00            ld (hl),0                               ; zero the counter
 76+  C6C1 1E 0C            ld e,12
 77+  C6C3 CD ED 80         call utilities_randomupper              ; get random number from 0 to 11
 78+  C6C6 11 0A 00         ld de,10
 79+  C6C9 CD 3A 80         call utilities_multiply                 ; multiple random number by 10
 80+  C6CC 54 5D            ld de,hl                                ; this is the offset for the random missile
 81+  C6CE DD 21 B1 B4      ld ix,level01missiles                   ; load the location of the missile definitions
 82+  C6D2 DD 19            add ix,de                               ; get to location of missile
 83+  C6D4 DD 7E 02         ld a,(ix+2)
 84+  C6D7 FE 00            cp 0
 85+  C6D9 CA E9 C6         jp z,missiles_process1                  ; if this missile isn't active, activate it
 86+  C6DC 11 05 00         ld de,5                                 ; otherwise, check the missile above
 87+  C6DF DD 19            add ix,de
 88+  C6E1 DD 7E 02         ld a,(ix+2)
 89+  C6E4 FE 00            cp 0
 90+  C6E6 C2 13 C7         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 91+  C6E9              missiles_process1:                          ; activate a missile
 92+  C6E9 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
 93+  C6ED DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
 93+  C6F1 46 01
 94+  C6F3 78               ld a,b
 95+  C6F4 ED 5B 06 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
 96+  C6F8 93               sub e
 97+  C6F9 CD 68 A9         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
 98+  C6FC C5               push bc
 99+  C6FD 3E 0C            ld a,12                                 ; inactive missile sprite
100+  C6FF CD A5 A9         call screen_getblock
101+  C702 CD 2A AA         call sprites_drawsprite                 ; draw the sprite over the old one
102+  C705 C1               pop bc
103+  C706 C5               push bc
104+  C707 3E 14            ld a,20                                 ; active missile sprite
105+  C709 CD A5 A9         call screen_getblock
106+  C70C CD 2A AA         call sprites_drawsprite                 ; draw the sprite over the old one
107+  C70F C1               pop bc
108+  C710 CD A1 C7         call missiles_addmissiletofalling
109+  C713              missiles_process0:
110+  C713 CD 17 C7         call missiles_fall
111+  C716 C9               ret
112+  C717
113+  C717              ;
114+  C717              ; Processes falling missiles
115+  C717              ;
116+  C717              missiles_fall:
117+  C717 06 04            ld b,4              ; number of possible falling missiles
118+  C719 DD 21 5E C6      ld ix,missiles_falling
119+  C71D              missiles_fall0:
120+  C71D C5               push bc
121+  C71E DD 7E 02         ld a,(ix+2)
122+  C721 FE 00            cp 0
123+  C723 CA 80 C7         jp z,missiles_fall1 ; not falling move to next
124+  C726 FE 01            cp 1                ; is this ready to fall
125+  C728 CA 2E C7         jp z, missiles_fall3
126+  C72B C3 9A C7         jp missiles_fall4   ; if not, decrease the countdown
127+  C72E              missiles_fall3:
128+  C72E DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
128+  C732 46 01
129+  C734 CD 1F AB         call sprites_scadd  ; get the memory of the coords into de
130+  C737 14               inc d               ; add 256 to get next row
131+  C738 1A               ld a,(de)           ; get the contents of the next row
132+  C739 FE 00            cp 0
133+  C73B C2 93 C7         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
134+  C73E 3E 14            ld a,20                                 ; active missile sprite
135+  C740 CD A5 A9         call screen_getblock
136+  C743 CD 2A AA         call sprites_drawsprite                 ; draw the sprite over the old one
137+  C746 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
137+  C74A 46 01
138+  C74C 0C               inc c               ; move down one pixel
139+  C74D DD 71 00 DD      ld (ix),bc          ; store the new coords
139+  C751 70 01
140+  C753 3E 14            ld a,20                                 ; active missile sprite
141+  C755 CD A5 A9         call screen_getblock
142+  C758 CD 2A AA         call sprites_drawsprite                 ; draw the sprite
143+  C75B DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
143+  C75F 46 01
144+  C761 79               ld a,c              ; get the vertical coord into a
145+  C762 E6 07            and 7               ; divisible by 8?
146+  C764 FE 00            cp 0
147+  C766 C2 80 C7         jp nz,missiles_fall1   ; if not, carry on
148+  C769 CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
149+  C76C 3E 43            ld a,67             ; load magenta
150+  C76E CD B0 A9         call screen_setattr
151+  C771 DD 4E 00 DD      ld bc,(ix)
151+  C775 46 01
152+  C777 CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the attr address into de
153+  C77A 05               dec b               ; look one square above
154+  C77B 3E 46            ld a,70             ; load yellow
155+  C77D CD B0 A9         call screen_setattr
156+  C780              missiles_fall1:         ; hl at state
157+  C780 DD 4E 00 DD      ld bc,(ix)          ; get coords back
157+  C784 46 01
158+  C786 CD C2 C7         call missiles_checkforplayer ; check for player
159+  C789 DD 23            inc ix
160+  C78B DD 23            inc ix
161+  C78D DD 23            inc ix              ; get to next missile
162+  C78F C1               pop bc
163+  C790 10 8B            djnz missiles_fall0
164+  C792 C9               ret
165+  C793              missiles_fall2:
166+  C793 DD 36 02 00      ld (ix+2),0
167+  C797 C3 80 C7         jp missiles_fall1   ; rejoin the loop
168+  C79A              missiles_fall4:
169+  C79A 3D               dec a               ; decrease the countdown
170+  C79B DD 77 02         ld (ix+2),a         ; store back
171+  C79E C3 80 C7         jp missiles_fall1   ; do next missile
172+  C7A1
173+  C7A1              ;
174+  C7A1              ; Adds the missile to the structure that tracks falling missile
175+  C7A1              ; Inputs:
176+  C7A1              ; bc - coords of missile, c vert
177+  C7A1              missiles_addmissiletofalling:
178+  C7A1 C5               push bc             ; store the coords
179+  C7A2 11 5E C6         ld de,missiles_falling
180+  C7A5 06 04            ld b,4              ; number of possible falling missiles
181+  C7A7              missiles_addmissiletofalling0:
182+  C7A7 13               inc de
183+  C7A8 13               inc de              ; move three along to get the state
184+  C7A9 1A               ld a,(de)           ; load the state
185+  C7AA FE 00            cp 0                ; check if this is not falling
186+  C7AC C2 BD C7         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
187+  C7AF 3E 19            ld a,25
188+  C7B1 12               ld (de),a           ; set the state to pre-falling
189+  C7B2 1B               dec de              ; move back coords
190+  C7B3 C1               pop bc              ; get back coords
191+  C7B4 78               ld a,b
192+  C7B5 12               ld (de),a           ; store the vertical
193+  C7B6 1B               dec de
194+  C7B7 79               ld a,c
195+  C7B8 12               ld (de),a           ; store the horizontal
196+  C7B9 C5               push bc
197+  C7BA C3 C0 C7         jp missiles_addmissiletofalling2 ; done
198+  C7BD              missiles_addmissiletofalling1:
199+  C7BD 13               inc de              ; move memory along to next rock
200+  C7BE 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
201+  C7C0              missiles_addmissiletofalling2: ; done, return
202+  C7C0 C1               pop bc              ; to tidy up
203+  C7C1 C9               ret
204+  C7C2
205+  C7C2              ;
206+  C7C2              ; Checks to see if the missile is hitting a player
207+  C7C2              ; Inputs:
208+  C7C2              ; bc - coords of missile we're checking
209+  C7C2              missiles_checkforplayer:
210+  C7C2 ED 5B 92 BD      ld de,(player)       ; get the player coords
211+  C7C6 7B               ld a,e               ; get the vert coord first
212+  C7C7 91               sub c                ; subtract the missile vertical coord from players
213+  C7C8 FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
214+  C7CA C0               ret nz               ; if not, hasn't hit
215+  C7CB 7A               ld a,d               ; get the player horiz coord
216+  C7CC 90               sub b                ; subtract missile coord
217+  C7CD C6 07            add 7                ; add max distance
218+  C7CF FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
219+  C7D1 DA D5 C7         jp c,missiles_checkforplayer0
220+  C7D4 C9               ret
221+  C7D5              missiles_checkforplayer0:
222+  C7D5 ED 43 6A C6      ld (missiles_killermissile),bc; store the coords of the killer missile
223+  C7D9 CD AF BE         call player_zonkplayer ; if so, jump out
224+  C7DC C9               ret
225+  C7DD
226+  C7DD              ;
227+  C7DD              ; Player has been hit, so draw text over them and mark as dead
228+  C7DD              ;
229+  C7DD              missiles_zonkplayer:
230+  C7DD CD 9D BE         call player_killplayer      ; mark as dead
231+  C7E0 ED 4B 92 BD      ld bc,(player)              ; get player coords
232+  C7E4 CD 58 A9         call screen_getcharcoordsfromscreencoords
233+  C7E7 0D               dec c
234+  C7E8 0D               dec c
235+  C7E9 04               inc b
236+  C7EA C5               push bc
237+  C7EB 3E 42            ld a,66
238+  C7ED CD B0 A9         call screen_setattr
239+  C7F0 0C               inc c
240+  C7F1 CD B0 A9         call screen_setattr
241+  C7F4 0C               inc c
242+  C7F5 CD B0 A9         call screen_setattr
243+  C7F8 0C               inc c
244+  C7F9 CD B0 A9         call screen_setattr
245+  C7FC 0C               inc c
246+  C7FD CD B0 A9         call screen_setattr
247+  C800 C1               pop bc
248+  C801 ED 5B 06 A8      ld de,(screen_offset)
249+  C805 78               ld a,b
250+  C806 93               sub e
251+  C807 47               ld b,a                      ; subtract the offset
252+  C808 04               inc b
253+  C809 04               inc b                       ; add two for the score rows
254+  C80A ED 43 CD 84      ld (string_zonk),bc         ; set coords of string
255+  C80E 21 CD 84         ld hl,string_zonk
256+  C811 CD 54 85         call string_print
257+  C814 06 14            ld b,20
258+  C816 CD 99 80         call utilities_pauseforframes ; pause
259+  C819 C9               ret
260+  C81A
# file closed: game/missiles.asm
 47   C81A                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  C81A              ;
  2+  C81A              ; Timer for deciding how fast the trap withdraws
  3+  C81A              ;
  4+  C81A              thepit_timer:
  5+  C81A 00               defb 0
  6+  C81B
  7+  C81B              ;
  8+  C81B              ; Ticks for the trap state. Will count to 3 then reset
  9+  C81B              ;
 10+  C81B              thepit_trapcount:
 11+  C81B 00               defb 0
 12+  C81C
 13+  C81C              ;
 14+  C81C              ; The horizontal coordinate of the current pit trap
 15+  C81C              ;
 16+  C81C              thepit_trapcoord:
 17+  C81C 08               defb 8
 18+  C81D
 19+  C81D              ;
 20+  C81D              ; Initialises the pit
 21+  C81D              ;
 22+  C81D              thepit_init:
 23+  C81D 21 1C C8         ld hl,thepit_trapcoord
 24+  C820 36 08            ld (hl),8
 25+  C822 21 1B C8         ld hl,thepit_trapcount
 26+  C825 36 00            ld (hl),0
 27+  C827 C9               ret
 28+  C828
 29+  C828              ;
 30+  C828              ; Performs per frame processing on the pit room
 31+  C828              ;
 32+  C828              thepit_process:
 33+  C828 3A A1 BD         ld a,(player_location)
 34+  C82B FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 35+  C82D C2 89 C8         jp nz,thepit_process0
 36+  C830 ED 4B 92 BD      ld bc,(player)                  ; get the player's coords to check if about to fall
 37+  C834 3E 08            ld a,8
 38+  C836 81               add a,c
 39+  C837 4F               ld c,a                          ; look at the square underneath
 40+  C838 CD 58 A9         call screen_getcharcoordsfromscreencoords ; get the cell coords
 41+  C83B CD E6 A9         call screen_ischarempty
 42+  C83E FE 01            cp 1                            ; check if this is 1=empty
 43+  C840 CA 8A C8         jp z,thepit_process2
 44+  C843 3A 1A C8         ld a,(thepit_timer)             ; get the timer
 45+  C846 3C               inc a
 46+  C847 32 1A C8         ld (thepit_timer),a             ; store
 47+  C84A FE 02            cp 2                           ; have we reached the trigger?
 48+  C84C C2 89 C8         jp nz, thepit_process0          ; no need to do anything
 49+  C84F 3E 00            ld a,0
 50+  C851 32 1A C8         ld (thepit_timer),a             ; zero the timer and process
 51+  C854 3A 1B C8         ld a,(thepit_trapcount)         ; get the current count
 52+  C857 3C               inc a
 53+  C858 32 1B C8         ld (thepit_trapcount),a         ; reset the trap count
 54+  C85B FE 04            cp 4                            ; do we need to begin another character?
 55+  C85D C2 71 C8         jp nz,thepit_process1           ; if not, draw as normal
 56+  C860 3E 00            ld a,0
 57+  C862 32 1B C8         ld (thepit_trapcount),a         ; reset the trap count
 58+  C865 3A 1C C8         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 59+  C868 FE 02            cp 2
 60+  C86A CA 89 C8         jp z,thepit_process0
 61+  C86D 3D               dec a
 62+  C86E 32 1C C8         ld (thepit_trapcoord),a         ; store the reduced coord
 63+  C871
 64+  C871              thepit_process1:                    ; draw the trapdoor in current position
 65+  C871 3A 1C C8         ld a,(thepit_trapcoord)
 66+  C874 FE 02            cp 2
 67+  C876 CA 89 C8         jp z, thepit_process0           ; don't process outside of the pit
 68+  C879 4F               ld c,a
 69+  C87A 06 0A            ld b,10                         ; vertical coord will always be the same
 70+  C87C 3A 1B C8         ld a,(thepit_trapcount)         ; get the trap count
 71+  C87F 5F               ld e,a                          ; store in e
 72+  C880 3E 16            ld a,22                         ; 21 is full trapdoor
 73+  C882 83               add a,e
 74+  C883 CD A5 A9         call screen_getblock
 75+  C886 CD 82 A9         call screen_showchar            ; show the char
 76+  C889
 77+  C889              thepit_process0:
 78+  C889 C9               ret
 79+  C88A              thepit_process2:
 80+  C88A CD B5 BE         call player_pitkillplayer
 81+  C88D C9               ret
 82+  C88E
# file closed: game/thepit.asm
 48   C88E                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  C88E
  2+  C88E              ;
  3+  C88E              ; Where the monster currently is
  4+  C88E              ;
  5+  C88E              monster_currentcoords:
  6+  C88E 00 00            defb 0,0
  7+  C890
  8+  C890              ;
  9+  C890              ; The start coords of the monster
 10+  C890              ;
 11+  C890              monster_initcoords:
 12+  C890 70 1B            defb 112,27
 13+  C892
 14+  C892              ;
 15+  C892              ; Store the memory location of the current jump position
 16+  C892              ;
 17+  C892              monster_jumppos:
 18+  C892 00 00            defb 0,0
 19+  C894
 20+  C894              ;
 21+  C894              ; The jump table for the monster.
 22+  C894              ;
 23+  C894              monster_jumptable:
 24+  C894 FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  C898 02 02 02 02
 24+  C89C 02 02 01 01
 24+  C8A0 01 01 01 01
 24+  C8A4 FF
 25+  C8A5
 26+  C8A5              ;
 27+  C8A5              ; The vertical direction: 0 up, 1 down
 28+  C8A5              ;
 29+  C8A5              monster_jumpdirectionvert:
 30+  C8A5 00               defb 0
 31+  C8A6
 32+  C8A6              ;
 33+  C8A6              ; The horiz direction: 0 right, 1 left
 34+  C8A6              ;
 35+  C8A6              monster_jumpdirectionhoriz:
 36+  C8A6 00               defb 0
 37+  C8A7
 38+  C8A7              ;
 39+  C8A7              ; Frame offset, 0 or 32
 40+  C8A7              ;
 41+  C8A7              monster_frameoffset:
 42+  C8A7 00               defb 0
 43+  C8A8
 44+  C8A8              ;
 45+  C8A8              ; Monster tick
 46+  C8A8              ;
 47+  C8A8              monster_tick:
 48+  C8A8 00               defb 0
 49+  C8A9
 50+  C8A9              ;
 51+  C8A9              ; Initialises the pit monster
 52+  C8A9              ;
 53+  C8A9              monster_init:
 54+  C8A9 ED 4B 90 C8      ld bc,(monster_initcoords)              ; load the initial coords
 55+  C8AD ED 43 8E C8      ld (monster_currentcoords),bc           ; save in current coords
 56+  C8B1 21 95 C8         ld hl,monster_jumptable+1
 57+  C8B4 22 92 C8         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 58+  C8B7 3E 00            ld a,0
 59+  C8B9 32 A5 C8         ld (monster_jumpdirectionvert),a        ; going up
 60+  C8BC 32 A7 C8         ld (monster_frameoffset),a
 61+  C8BF 32 A8 C8         ld (monster_tick),a
 62+  C8C2 CD 42 C9         call monster_draw                       ; the monster
 63+  C8C5 C9               ret
 64+  C8C6
 65+  C8C6              ;
 66+  C8C6              ; Animate the monster
 67+  C8C6              ;
 68+  C8C6              monster_process:
 69+  C8C6 3A A8 C8         ld a,(monster_tick)                     ; check if we should draw this frame
 70+  C8C9 FE 01            cp 1
 71+  C8CB CA D3 C8         jp z,monster_process6
 72+  C8CE 3C               inc a
 73+  C8CF 32 A8 C8         ld (monster_tick),a                     ; increase the tick and continue
 74+  C8D2 C9               ret
 75+  C8D3              monster_process6:
 76+  C8D3 3E 00            ld a,0
 77+  C8D5 32 A8 C8         ld (monster_tick),a                     ; zero the tick
 78+  C8D8 CD 42 C9         call monster_draw                       ; overwrite the old sprite
 79+  C8DB 3A A7 C8         ld a,(monster_frameoffset)              ; get the anim frame offset
 80+  C8DE EE 20            xor 32                                  ; flip between 0 and 32
 81+  C8E0 32 A7 C8         ld (monster_frameoffset),a              ; store
 82+  C8E3 ED 4B 8E C8      ld bc,(monster_currentcoords)           ; get the current coords
 83+  C8E7 2A 92 C8         ld hl,(monster_jumppos)                 ; get the position in the jump table
 84+  C8EA 56               ld d,(hl)                               ; get the jump modifier
 85+  C8EB 3A A5 C8         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 86+  C8EE FE 00            cp 0                                    ; if 0, going up, so dec vert
 87+  C8F0 C2 F9 C8         jp nz,monster_process0
 88+  C8F3 79               ld a,c
 89+  C8F4 92               sub d
 90+  C8F5 23               inc hl                                  ; move forward a jump pos
 91+  C8F6 C3 FC C8         jp monster_process1
 92+  C8F9              monster_process0:
 93+  C8F9 79               ld a,c                                   ; going down so inc c
 94+  C8FA 82               add a,d
 95+  C8FB 2B               dec hl                                  ; move back a jump pos
 96+  C8FC              monster_process1:
 97+  C8FC 4F               ld c,a                                  ; get the vertical coord back
 98+  C8FD 7E               ld a,(hl)                               ; check the next jump pos
 99+  C8FE FE FF            cp 255                                  ; if 255 reverse
100+  C900 CA 09 C9         jp z,monster_process3
101+  C903 22 92 C8         ld (monster_jumppos),hl                 ; store the new pos
102+  C906 C3 11 C9         jp monster_process2                     ; keep going
103+  C909              monster_process3:
104+  C909 3A A5 C8         ld a,(monster_jumpdirectionvert)        ; get the direction
105+  C90C EE 01            xor 1                                   ; flip it
106+  C90E 32 A5 C8         ld (monster_jumpdirectionvert),a        ; store it
107+  C911              monster_process2:
108+  C911 3A A6 C8         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
109+  C914 FE 00            cp 0                                    ; is it right?
110+  C916 C2 2B C9         jp nz,monster_process4
111+  C919 04               inc b                                   ; 1 pixel right
112+  C91A 78               ld a,b
113+  C91B FE 38            cp 56                                   ; reached the edge of the pit?
114+  C91D C2 3A C9         jp nz,monster_process5
115+  C920 3A A6 C8         ld a,(monster_jumpdirectionhoriz)
116+  C923 EE 01            xor 1
117+  C925 32 A6 C8         ld (monster_jumpdirectionhoriz),a       ; flip direction
118+  C928 C3 3A C9         jp monster_process5
119+  C92B              monster_process4:
120+  C92B 05               dec b                                   ; 1 pixel left
121+  C92C 78               ld a,b
122+  C92D FE 18            cp 24                                   ; reached the edge of the pit?
123+  C92F C2 3A C9         jp nz,monster_process5
124+  C932 3A A6 C8         ld a,(monster_jumpdirectionhoriz)
125+  C935 EE 01            xor 1
126+  C937 32 A6 C8         ld (monster_jumpdirectionhoriz),a       ; flip direction
127+  C93A              monster_process5:
128+  C93A ED 43 8E C8      ld (monster_currentcoords),bc           ; store the new vertical coords
129+  C93E CD 42 C9         call monster_draw                       ; finally, draw the monster
130+  C941 C9               ret
131+  C942
132+  C942              ;
133+  C942              ; Draw the monster at the current location
134+  C942              ;
135+  C942              monster_draw:
136+  C942 ED 4B 8E C8      ld bc,(monster_currentcoords)
137+  C946 3A A7 C8         ld a,(monster_frameoffset)
138+  C949 11 00 00         ld de,0
139+  C94C 5F               ld e,a
140+  C94D 21 C3 B7         ld hl,monster_sprite                    ; load the first frame
141+  C950 19               add hl,de
142+  C951 CD 88 AA         call sprites_draw2by2sprite
143+  C954 C9               ret
# file closed: game/monster.asm
 49   C955                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  C955
  2+  C955              ;
  3+  C955              ; Array of robot states
  4+  C955              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  C955              robots_robots:
  6+  C955 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  C959 00 00 00
  7+  C95C 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  C960 00 00 00
  8+  C963 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  C967 00 00 00
  9+  C96A 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  C96E 00 00 00
 10+  C971 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  C975 00 00 00
 11+  C978
 12+  C978              robots_initcoords:
 13+  C978 18 E8            defb 24,232
 14+  C97A
 15+  C97A              ;
 16+  C97A              ; When this reaches zero, spawn a new robot
 17+  C97A              ;
 18+  C97A              robots_spawntimer:
 19+  C97A FA               defb 250
 20+  C97B
 21+  C97B              ;
 22+  C97B              ; When this reaches max, change the anim frame
 23+  C97B              ;
 24+  C97B              robots_animtimer:
 25+  C97B 00               defb 0
 26+  C97C
 27+  C97C              ;
 28+  C97C              ; When this reaches max, change move the robot
 29+  C97C              ;
 30+  C97C              robots_movetimer:
 31+  C97C 00               defb 0
 32+  C97D
 33+  C97D
 34+  C97D              ;
 35+  C97D              ; The number of robots active
 36+  C97D              ;
 37+  C97D              robots_numberactive:
 38+  C97D 00               defb 0
 39+  C97E
 40+  C97E              ;
 41+  C97E              ; Tracks which directions a robot can move
 42+  C97E              ; up,down,left,right
 43+  C97E              robots_canmovedirections:
 44+  C97E 00 00 00 00      defb 0,0,0,0
 45+  C982
 46+  C982              ;
 47+  C982              ; The current robot speed
 48+  C982              ;
 49+  C982              robots_robotspeed:
 50+  C982 02               defb 2
 51+  C983
 52+  C983              ;
 53+  C983              ; The current max robots
 54+  C983              ;
 55+  C983              robots_robotsmax:
 56+  C983 02               defb 2
 57+  C984
 58+  C984              ;
 59+  C984              ; Initialises the robots
 60+  C984              ;
 61+  C984              robots_init:
 62+  C984 06 23            ld b,35
 63+  C986 DD 21 55 C9      ld ix,robots_robots
 64+  C98A              robots_init0:
 65+  C98A DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 66+  C98E DD 23            inc ix
 67+  C990 10 F8            djnz robots_init0
 68+  C992 3E 00            ld a,0
 69+  C994 32 7D C9         ld (robots_numberactive),a
 70+  C997 3E FA            ld a,250
 71+  C999 32 7A C9         ld (robots_spawntimer),a
 72+  C99C                  ; Self writing code
 73+  C99C                  ; Robot speed
 74+  C99C 3A 82 C9         ld a,(robots_robotspeed)
 75+  C99F 32 39 CA         ld (robots_process7+1),a
 76+  C9A2 3C               inc a
 77+  C9A3 32 69 CA         ld (robots_process6+1),a
 78+  C9A6                  ; Robots max
 79+  C9A6 3A 83 C9         ld a,(robots_robotsmax)
 80+  C9A9 32 B4 C9         ld (robots_spawn+1),a
 81+  C9AC 32 0B CA         ld (robots_process8+1),a
 82+  C9AF 32 27 CA         ld (robots_process0+1),a
 83+  C9B2 C9               ret
 84+  C9B3
 85+  C9B3              ;
 86+  C9B3              ; Spawns a new robot
 87+  C9B3              ; Inputs:
 88+  C9B3              ; ix - pointer to start of robot array entry
 89+  C9B3              ;
 90+  C9B3              robots_spawn:
 91+  C9B3 06 03            ld b,3                      ;(SELF WRITING CODE)
 92+  C9B5 DD 21 55 C9      ld ix,robots_robots
 93+  C9B9              robots_spawn0:
 94+  C9B9 DD 7E 02         ld a,(ix+2)                 ; get the state
 95+  C9BC FE 00            cp 0
 96+  C9BE C2 EA C9         jp nz,robots_spawn1         ; if already active, move on
 97+  C9C1 ED 4B 78 C9      ld bc,(robots_initcoords)
 98+  C9C5 DD 71 00 DD      ld (ix),bc
 98+  C9C9 70 01
 99+  C9CB DD 36 02 01      ld (ix+2),1
100+  C9CF DD 36 03 00      ld (ix+3),0
101+  C9D3 DD 36 04 00      ld (ix+4),0
102+  C9D7 DD 36 05 00      ld (ix+5),0
103+  C9DB DD 36 06 00      ld (ix+6),0
104+  C9DF 3A 7D C9         ld a,(robots_numberactive)
105+  C9E2 3C               inc a
106+  C9E3 32 7D C9         ld (robots_numberactive),a  ; increase the number active
107+  C9E6 CD 9D CC         call robots_draw            ; draw initial frame
108+  C9E9 C9               ret
109+  C9EA              robots_spawn1:
110+  C9EA 11 07 00         ld de,7
111+  C9ED DD 19            add ix,de
112+  C9EF 10 C8            djnz robots_spawn0
113+  C9F1 C9               ret
114+  C9F2              ;
115+  C9F2              ; Kills robot
116+  C9F2              ; Inputs:
117+  C9F2              ; ix - pointer to start of robot array entry
118+  C9F2              ;
119+  C9F2              robots_kill:
120+  C9F2 3A 7D C9         ld a,(robots_numberactive)
121+  C9F5 3D               dec a
122+  C9F6 32 7D C9         ld (robots_numberactive),a
123+  C9F9 DD 36 02 00      ld (ix+2),0                     ; set to inactive
124+  C9FD C5               push bc
125+  C9FE E5               push hl
126+  C9FF 06 01            ld b,1
127+  CA01 CD 96 C4         call scores_addhundreds
128+  CA04 E1               pop hl
129+  CA05 C1               pop bc
130+  CA06 C9               ret
131+  CA07
132+  CA07              ;
133+  CA07              ; Processes the robots
134+  CA07              ;
135+  CA07              robots_process:
136+  CA07 3A 7D C9         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
137+  CA0A              robots_process8:
138+  CA0A FE 03            cp 3                                    ; 3 is the maximum
139+  CA0C CA 26 CA         jp z,robots_process0                    ; if already three, nothing to do
140+  CA0F 3A 7A C9         ld a,(robots_spawntimer)                ; now check the spawn timer
141+  CA12 FE 00            cp 0
142+  CA14 C2 22 CA         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
143+  CA17 3E FA            ld a,250
144+  CA19 32 7A C9         ld (robots_spawntimer),a                ; reset the spawn timer
145+  CA1C CD B3 C9         call robots_spawn                       ; spawn a robot
146+  CA1F C3 26 CA         jp robots_process0                      ; carry on
147+  CA22              robots_process1:
148+  CA22 3D               dec a
149+  CA23 32 7A C9         ld (robots_spawntimer),a                ; decrease the spawn timer and store
150+  CA26              robots_process0:
151+  CA26 06 03            ld b,3                                  ; max number of robots (SELF WRITING CODE)
152+  CA28 DD 21 55 C9      ld ix, robots_robots                    ; point ix at the robot array
153+  CA2C              robots_process2:
154+  CA2C C5               push bc
155+  CA2D DD 7E 02         ld a,(ix+2)                             ; check the state
156+  CA30 FE 00            cp 0
157+  CA32 CA 4E CA         jp z,robots_process3                    ; if not active, move on
158+  CA35 3A 7C C9         ld a,(robots_movetimer)
159+  CA38              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
160+  CA38 FE 04            cp 4
161+  CA3A C2 4E CA         jp nz,robots_process3                   ; can we move this frame
162+  CA3D CD 9D CC         call robots_draw                        ; draw over existing
163+  CA40 CD 73 CA         call robots_move                        ; move the
164+  CA43 DD 7E 02         ld a,(ix+2)                             ; get the state again
165+  CA46 FE 00            cp 0
166+  CA48 CA 4E CA         jp z,robots_process3                    ; move to next if this robot has become inactive
167+  CA4B CD 9D CC         call robots_draw                        ; draw the new robot
168+  CA4E              robots_process3:
169+  CA4E C1               pop bc
170+  CA4F 11 07 00         ld de,7
171+  CA52 DD 19            add ix,de
172+  CA54 10 D6            djnz robots_process2
173+  CA56 3A 7B C9         ld a,(robots_animtimer)
174+  CA59 3C               inc a
175+  CA5A FE 08            cp 8
176+  CA5C C2 61 CA         jp nz,robots_process4
177+  CA5F 3E 00            ld a,0                                  ; reset if we reached max
178+  CA61              robots_process4:
179+  CA61 32 7B C9         ld (robots_animtimer),a
180+  CA64 3A 7C C9         ld a,(robots_movetimer)                 ; increment the robot move timer
181+  CA67 3C               inc a
182+  CA68              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
183+  CA68 FE 05            cp 5                                    ; there is another reference to this number above
184+  CA6A C2 6F CA         jp nz,robots_process5
185+  CA6D 3E 00            ld a,0
186+  CA6F              robots_process5:
187+  CA6F 32 7C C9         ld (robots_movetimer),a
188+  CA72
189+  CA72 C9               ret
190+  CA73
191+  CA73
192+  CA73              ;
193+  CA73              ; Moves a robot
194+  CA73              ; Inputs:
195+  CA73              ; ix - points to first byte of robot in array
196+  CA73              robots_move:
197+  CA73 DD 7E 02         ld a,(ix+2)                             ; get the state
198+  CA76 FE 02            cp 2
199+  CA78 CA A9 CA         jp z,robots_move4                       ; don't move if shot, just change the anim
200+  CA7B 3A 7B C9         ld a,(robots_animtimer)                 ; get the anim timer
201+  CA7E FE 07            cp 7                                    ; compare with 8
202+  CA80 C2 93 CA         jp nz,robots_move1                       ; if even, don't increment frame
203+  CA83 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
204+  CA86 06 08            ld b,8
205+  CA88 80               add a,b                                 ; add to anim frame
206+  CA89 FE 20            cp 32
207+  CA8B C2 90 CA         jp nz,robots_move0                      ; if not 32, then just store
208+  CA8E 3E 00            ld a,0                                  ; otherwise, reset
209+  CA90              robots_move0:
210+  CA90 DD 77 04         ld (ix+4),a                             ; store
211+  CA93              robots_move1:
212+  CA93 DD 7E 05         ld a,(ix+5)
213+  CA96 FE 00            cp 0                                    ; are we automoving
214+  CA98 CA A1 CA         jp z,robots_move2                       ; if not, keep directions
215+  CA9B CD BD CA         call robots_automove
216+  CA9E C3 A5 CA         jp robots_move3
217+  CAA1              robots_move2:
218+  CAA1 CD F0 CA         call robots_checkdirectionsandmove
219+  CAA4 C9               ret
220+  CAA5              robots_move3:
221+  CAA5 CD E6 CC         call robots_checkforplayer              ; check to see if we collided with a player
222+  CAA8 C9               ret
223+  CAA9              robots_move4:
224+  CAA9 DD 7E 04         ld a,(ix+4)
225+  CAAC FE 48            cp 72
226+  CAAE C2 B7 CA         jp nz,robots_move5
227+  CAB1 3E 40            ld a,64
228+  CAB3 DD 77 04         ld (ix+4),a
229+  CAB6 C9               ret
230+  CAB7              robots_move5:
231+  CAB7 3E 48            ld a,72
232+  CAB9 DD 77 04         ld (ix+4),a
233+  CABC C9               ret
234+  CABD
235+  CABD
236+  CABD              ;
237+  CABD              ; Processes automove
238+  CABD              ; Inputs:
239+  CABD              ; ix - points to the current robot
240+  CABD              ; a - number of frames left to move
241+  CABD              robots_automove:
242+  CABD 3D               dec a
243+  CABE DD 77 05         ld (ix+5),a                         ; store the decreased frames
244+  CAC1 DD 4E 00 DD      ld bc,(ix)                          ; get coords
244+  CAC5 46 01
245+  CAC7 DD 7E 06         ld a,(ix+6)                         ; get the direction
246+  CACA FE 00            cp 0                                ; left
247+  CACC CA DD CA         jp z,robots_automove1
248+  CACF FE 02            cp 2                                ; up
249+  CAD1 CA E1 CA         jp z,robots_automove3
250+  CAD4 FE 03            cp 3                                ; down
251+  CAD6 CA E5 CA         jp z,robots_automove4
252+  CAD9 04               inc b                               ; right
253+  CADA C3 E9 CA         jp robots_automove2
254+  CADD              robots_automove1:
255+  CADD 05               dec b
256+  CADE C3 E9 CA         jp robots_automove2
257+  CAE1              robots_automove3:
258+  CAE1 0D               dec c
259+  CAE2 C3 E9 CA         jp robots_automove2
260+  CAE5              robots_automove4:
261+  CAE5 0C               inc c
262+  CAE6 C3 E9 CA         jp robots_automove2
263+  CAE9              robots_automove2:
264+  CAE9 DD 71 00 DD      ld (ix),bc
264+  CAED 70 01
265+  CAEF C9               ret
266+  CAF0
267+  CAF0              ;
268+  CAF0              ; Checks if a robot can move in all directions, then picks one and moves there.
269+  CAF0              ; This looks complicated, but really what it does is:
270+  CAF0              ; 1) Look at the current direction
271+  CAF0              ; 2) Randomly determine which orthoganal direction check first
272+  CAF0              ; 3) If orthogonal can't be moved, keep going in direction we're going
273+  CAF0              ; 4) Otherwise, back the way we came
274+  CAF0              ; Inputs:
275+  CAF0              ; ix - points to the current robot
276+  CAF0              ;
277+  CAF0              robots_checkdirectionsandmove:
278+  CAF0 DD 7E 06         ld a,(ix+6)                 ; get the direction
279+  CAF3 FE 00            cp 0                        ; left
280+  CAF5 C2 1C CB         jp nz,robots_checkdirectionsandmove0
281+  CAF8                  ; random check
282+  CAF8 CD 81 BD         call game_getcurrentframe
283+  CAFB E6 01            and 1                       ; odd or even
284+  CAFD CA 09 CB         jp z,robots_checkdirectionsandmove3
285+  CB00 CD A2 CB         call robots_checkupthendown ; prefer up over down
286+  CB03 FE 01            cp 1
287+  CB05 C8               ret z
288+  CB06 C3 0F CB         jp robots_checkdirectionsandmove4
289+  CB09              robots_checkdirectionsandmove3:
290+  CB09 CD 98 CB         call robots_checkdownthenup ; prefer down over up
291+  CB0C FE 01            cp 1
292+  CB0E C8               ret z
293+  CB0F              robots_checkdirectionsandmove4:
294+  CB0F                  ; check left
295+  CB0F CD 26 CC         call robots_checkleftandmove
296+  CB12 FE 01            cp 1
297+  CB14 C8               ret z                       ; if we moved, don't check again
298+  CB15                  ; check right
299+  CB15 CD 5F CC         call robots_checkrightandmove
300+  CB18 FE 01            cp 1
301+  CB1A C8               ret z                       ; if we moved, don't check again
302+  CB1B                  ; if we're here and haven't moved...
303+  CB1B C9               ret
304+  CB1C              robots_checkdirectionsandmove0
305+  CB1C FE 01            cp 1                        ; right
306+  CB1E C2 45 CB         jp nz,robots_checkdirectionsandmove1
307+  CB21                  ; ALREADY MOVING RIGHT
308+  CB21                  ; random check
309+  CB21 CD 81 BD         call game_getcurrentframe
310+  CB24 E6 01            and 1                       ; odd or even
311+  CB26 CA 32 CB         jp z,robots_checkdirectionsandmove5
312+  CB29 CD 98 CB         call robots_checkdownthenup ; prefer down over up
313+  CB2C FE 01            cp 1
314+  CB2E C8               ret z
315+  CB2F C3 38 CB         jp robots_checkdirectionsandmove6
316+  CB32              robots_checkdirectionsandmove5:
317+  CB32 CD A2 CB         call robots_checkupthendown ; prefer down over up
318+  CB35 FE 01            cp 1
319+  CB37 C8               ret z
320+  CB38              robots_checkdirectionsandmove6:
321+  CB38                  ; check right
322+  CB38 CD 5F CC         call robots_checkrightandmove
323+  CB3B FE 01            cp 1
324+  CB3D C8               ret z                       ; if we moved, don't check again
325+  CB3E                  ; check left
326+  CB3E CD 26 CC         call robots_checkleftandmove
327+  CB41 FE 01            cp 1
328+  CB43 C8               ret z                       ; if we moved, don't check again
329+  CB44                  ; if we're here and haven't moved...
330+  CB44 C9               ret
331+  CB45              robots_checkdirectionsandmove1
332+  CB45 FE 02            cp 2                        ; up
333+  CB47 C2 6E CB         jp nz,robots_checkdirectionsandmove2
334+  CB4A                  ; ALREADY MOVING UP
335+  CB4A                  ; random check
336+  CB4A CD 81 BD         call game_getcurrentframe
337+  CB4D E6 01            and 1                       ; odd or even
338+  CB4F CA 5B CB         jp z,robots_checkdirectionsandmove7
339+  CB52 CD B8 CB         call robots_checkleftthenright ; prefer left over right
340+  CB55 FE 01            cp 1
341+  CB57 C8               ret z
342+  CB58 C3 61 CB         jp robots_checkdirectionsandmove8
343+  CB5B              robots_checkdirectionsandmove7:
344+  CB5B CD AE CB         call robots_checkrightthenleft ; prefer right over left
345+  CB5E FE 01            cp 1
346+  CB60 C8               ret z
347+  CB61              robots_checkdirectionsandmove8:
348+  CB61                  ; check up
349+  CB61 CD C4 CB         call robots_checkupandmove
350+  CB64 FE 01            cp 1
351+  CB66 C8               ret z                       ; if we moved, don't check again
352+  CB67                  ; check down
353+  CB67 CD F9 CB         call robots_checkdownandmove
354+  CB6A FE 01            cp 1
355+  CB6C C8               ret z                       ; if we moved, don't check again
356+  CB6D                  ; if we're here and haven't moved...
357+  CB6D C9               ret
358+  CB6E              robots_checkdirectionsandmove2
359+  CB6E                  ; ALREADY MOVING DOWN
360+  CB6E                  ; random check
361+  CB6E CD 81 BD         call game_getcurrentframe
362+  CB71 E6 01            and 1                       ; odd or even
363+  CB73 CA 7F CB         jp z,robots_checkdirectionsandmove9
364+  CB76 CD AE CB         call robots_checkrightthenleft ; prefer right over left
365+  CB79 FE 01            cp 1
366+  CB7B C8               ret z
367+  CB7C C3 85 CB         jp robots_checkdirectionsandmove10
368+  CB7F              robots_checkdirectionsandmove9:
369+  CB7F CD B8 CB         call robots_checkleftthenright ; prefer left over right
370+  CB82 FE 01            cp 1
371+  CB84 C8               ret z
372+  CB85              robots_checkdirectionsandmove10:
373+  CB85                  ; check down
374+  CB85 CD F9 CB         call robots_checkdownandmove
375+  CB88 FE 01            cp 1
376+  CB8A C8               ret z                       ; if we moved, don't check again
377+  CB8B                  ; check right first
378+  CB8B CD 5F CC         call robots_checkrightandmove
379+  CB8E FE 01            cp 1
380+  CB90 C8               ret z                       ; if we moved, don't check again
381+  CB91                  ; check up
382+  CB91 CD C4 CB         call robots_checkupandmove
383+  CB94 FE 01            cp 1
384+  CB96 C8               ret z                       ; if we moved, don't check again
385+  CB97                  ; if we're here and haven't moved...
386+  CB97 C9               ret
387+  CB98
388+  CB98              ;
389+  CB98              ; Different orders of checking directions, for pseudo random motion
390+  CB98              ;
391+  CB98              robots_checkdownthenup:
392+  CB98                  ; check down
393+  CB98 CD F9 CB         call robots_checkdownandmove
394+  CB9B FE 01            cp 1
395+  CB9D C8               ret z                       ; if we moved, don't check again
396+  CB9E                  ; check up
397+  CB9E CD C4 CB         call robots_checkupandmove
398+  CBA1 C9               ret
399+  CBA2
400+  CBA2              robots_checkupthendown:
401+  CBA2                  ; check up
402+  CBA2 CD C4 CB         call robots_checkupandmove
403+  CBA5 FE 01            cp 1
404+  CBA7 C8               ret z
405+  CBA8                  ; check down
406+  CBA8 CD F9 CB         call robots_checkdownandmove
407+  CBAB FE 01            cp 1
408+  CBAD C9               ret
409+  CBAE              robots_checkrightthenleft:
410+  CBAE                  ; check right
411+  CBAE CD 5F CC         call robots_checkrightandmove
412+  CBB1 FE 01            cp 1
413+  CBB3 C8               ret z                       ; if we moved, don't check again
414+  CBB4                  ; check left
415+  CBB4 CD 26 CC         call robots_checkleftandmove
416+  CBB7 C9               ret
417+  CBB8
418+  CBB8              robots_checkleftthenright:
419+  CBB8                  ; check left
420+  CBB8 CD 26 CC         call robots_checkleftandmove
421+  CBBB FE 01            cp 1
422+  CBBD C8               ret z
423+  CBBE                  ; check right
424+  CBBE CD 5F CC         call robots_checkrightandmove
425+  CBC1 FE 01            cp 1
426+  CBC3 C9               ret
427+  CBC4
428+  CBC4              ;
429+  CBC4              ; Checks up for movement
430+  CBC4              ; Outputs:
431+  CBC4              ; a - 1 if have moved
432+  CBC4              robots_checkupandmove:
433+  CBC4                  ; check above
434+  CBC4 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
434+  CBC8 46 01
435+  CBCA 79               ld a,c
436+  CBCB FE 20            cp 32
437+  CBCD D8               ret c
438+  CBCE CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
439+  CBD1 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
440+  CBD3 11 20 00         ld de,32
441+  CBD6 ED 52            sbc hl,de                       ; memory location of line above now in hl
442+  CBD8 7E               ld a,(hl)                       ; get the contents of the line
443+  CBD9 FE 00            cp 0
444+  CBDB C2 F6 CB         jp nz,robots_checkupandmove0    ; can't move here so return
445+  CBDE DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
445+  CBE2 46 01
446+  CBE4 0D               dec c                       ; move up
447+  CBE5 DD 71 00 DD      ld (ix),bc
447+  CBE9 70 01
448+  CBEB DD 36 06 02      ld (ix+6),2
449+  CBEF DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
450+  CBF3 3E 01            ld a,1
451+  CBF5 C9               ret
452+  CBF6              robots_checkupandmove0:
453+  CBF6 3E 00            ld a,0
454+  CBF8 C9               ret
455+  CBF9
456+  CBF9              ;
457+  CBF9              ; Checks down for movement
458+  CBF9              ; Outputs:
459+  CBF9              ; a - 1 if have moved
460+  CBF9              robots_checkdownandmove:
461+  CBF9                  ; check below
462+  CBF9 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
462+  CBFD 46 01
463+  CBFF CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
464+  CC02 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
465+  CC04 24               inc h                       ; memory location of cell beneath now in hl
466+  CC05 7E               ld a,(hl)                       ; get the contents of the line
467+  CC06 FE 00            cp 0
468+  CC08 C2 23 CC         jp nz,robots_checkdownandmove0    ; can't move here so return
469+  CC0B DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
469+  CC0F 46 01
470+  CC11 0C               inc c                       ; move up
471+  CC12 DD 71 00 DD      ld (ix),bc
471+  CC16 70 01
472+  CC18 DD 36 06 03      ld (ix+6),3
473+  CC1C DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
474+  CC20 3E 01            ld a,1
475+  CC22 C9               ret
476+  CC23              robots_checkdownandmove0:
477+  CC23 3E 00            ld a,0
478+  CC25 C9               ret
479+  CC26
480+  CC26              ;
481+  CC26              ; Checks left for movement
482+  CC26              ; Outputs:
483+  CC26              ; a - 1 if have moved
484+  CC26              robots_checkleftandmove:
485+  CC26                  ; check below
486+  CC26 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
486+  CC2A 46 01
487+  CC2C CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
488+  CC2F 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
489+  CC31 78               ld a,b
490+  CC32 06 08            ld b,8
491+  CC34 90               sub b                           ; move one cell left
492+  CC35 47               ld b,a
493+  CC36 2B               dec hl                          ; memory location of cell to the right now in hl
494+  CC37 CD 34 BB         call movement_spaceisempty       ; check space is empty
495+  CC3A 7B               ld a,e                          ; check space empty flag
496+  CC3B FE 00            cp 0
497+  CC3D CA 5C CC         jp z,robots_checkleftandmove0    ; if zero can't move
498+  CC40 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
498+  CC44 46 01
499+  CC46 05               dec b
500+  CC47 DD 71 00 DD      ld (ix),bc
500+  CC4B 70 01
501+  CC4D DD 36 06 00      ld (ix+6),0
502+  CC51 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
503+  CC55 DD 36 03 00      ld (ix+3),0                 ; set to right
504+  CC59 3E 01            ld a,1
505+  CC5B C9               ret
506+  CC5C              robots_checkleftandmove0:
507+  CC5C 3E 00            ld a,0
508+  CC5E C9               ret
509+  CC5F
510+  CC5F              ;
511+  CC5F              ; Checks right for movement
512+  CC5F              ; Outputs:
513+  CC5F              ; a - 1 if have moved
514+  CC5F              robots_checkrightandmove:
515+  CC5F                  ; check below
516+  CC5F DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
516+  CC63 46 01
517+  CC65 78               ld a,b
518+  CC66 FE E8            cp 232
519+  CC68 CA 9A CC         jp z,robots_checkrightandmove0  ; can't move if at edge
520+  CC6B CD 1F AB         call sprites_scadd              ; get the memory location of cell into de
521+  CC6E 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
522+  CC70 3E 08            ld a,8
523+  CC72 80               add b                           ; move one cell right
524+  CC73 47               ld b,a
525+  CC74 23               inc hl                          ; memory location of cell to the right now in hl
526+  CC75 CD 34 BB         call movement_spaceisempty       ; check space is empty
527+  CC78 7B               ld a,e                          ; check space empty flag
528+  CC79 FE 00            cp 0
529+  CC7B CA 9A CC         jp z,robots_checkrightandmove0    ; if zero can't move
530+  CC7E DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
530+  CC82 46 01
531+  CC84 04               inc b
532+  CC85 DD 71 00 DD      ld (ix),bc
532+  CC89 70 01
533+  CC8B DD 36 06 01      ld (ix+6),1
534+  CC8F DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
535+  CC93 DD 36 03 01      ld (ix+3),1                 ; set to right
536+  CC97 3E 01            ld a,1
537+  CC99 C9               ret
538+  CC9A              robots_checkrightandmove0:
539+  CC9A 3E 00            ld a,0
540+  CC9C C9               ret
541+  CC9D
542+  CC9D              ;
543+  CC9D              ; Draws a robot
544+  CC9D              ; Inputs:
545+  CC9D              ; ix - points to first byte of robot in array
546+  CC9D              robots_draw:
547+  CC9D DD 4E 00 DD      ld bc,(ix)
547+  CCA1 46 01
548+  CCA3 21 03 B8         ld hl,robot_sprite                      ; set to the robot sprite
549+  CCA6 DD 7E 02         ld a,(ix+2)                             ; get the state
550+  CCA9 FE 02            cp 2                                    ; is this dying
551+  CCAB CA C6 CC         jp z,robots_draw1
552+  CCAE              robots_draw3:
553+  CCAE DD 7E 03         ld a,(ix+3)                             ; get the direction
554+  CCB1 FE 00            cp 0
555+  CCB3 CA BA CC         jp z,robots_draw0                       ; if left, nothing to do
556+  CCB6 11 20 00         ld de,32
557+  CCB9 19               add hl,de                               ; add four frames to sprite
558+  CCBA              robots_draw0:
559+  CCBA DD 7E 04         ld a,(ix+4)                             ; get the anim frame
560+  CCBD 11 00 00         ld de,0
561+  CCC0 5F               ld e,a
562+  CCC1 19               add hl,de                               ; add to base
563+  CCC2 CD 2A AA         call sprites_drawsprite
564+  CCC5 C9               ret
565+  CCC6              ;
566+  CCC6              ; Dying
567+  CCC6              ;
568+  CCC6              robots_draw1:
569+  CCC6 DD 7E 05         ld a,(ix+5)                             ; get anim frames
570+  CCC9 FE 00            cp 0                                    ; if zero this is the first time around
571+  CCCB C2 D6 CC         jp nz,robots_draw2
572+  CCCE 3E 18            ld a,24
573+  CCD0 DD 77 05         ld (ix+5),a                             ; load up the anim frames
574+  CCD3 C3 AE CC         jp robots_draw3                         ; return to main loop to draw as normal
575+  CCD6              robots_draw2:
576+  CCD6 3D               dec a
577+  CCD7 DD 77 05         ld (ix+5),a
578+  CCDA FE 00            cp 0                                    ; have we reached the end yet
579+  CCDC C2 E2 CC         jp nz, robots_draw4
580+  CCDF CD F2 C9         call robots_kill
581+  CCE2              robots_draw4:
582+  CCE2 C3 BA CC         jp robots_draw0
583+  CCE5 C9               ret
584+  CCE6
585+  CCE6              ;
586+  CCE6              ; Checks to see if the robot is hitting a player
587+  CCE6              ; Inputs:
588+  CCE6              ; ix - memory location of robot we're checking
589+  CCE6              robots_checkforplayer:
590+  CCE6 3A 9D BD         ld a,(player+11)     ; get player state
591+  CCE9 FE 00            cp 0
592+  CCEB C0               ret nz               ; if already dying, don't kill again
593+  CCEC DD 4E 00 DD      ld bc,(ix)           ; get coords
593+  CCF0 46 01
594+  CCF2 ED 5B 92 BD      ld de,(player)       ; get the player coords
595+  CCF6 7B               ld a,e               ; get the vert coord first
596+  CCF7 91               sub c                ; subtract the diamond vertical coord from players
597+  CCF8 C6 08            add 8                ; add the max distance
598+  CCFA FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
599+  CCFC D0               ret nc               ; if not, hasn't hit
600+  CCFD 7A               ld a,d               ; get the player horiz coord
601+  CCFE 90               sub b                ; subtract rock coord
602+  CCFF C6 08            add 8                ; add max distance
603+  CD01 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
604+  CD03 D0               ret nc
605+  CD04 DD 36 02 00      ld (ix+2),0          ; mark as inactive
606+  CD08 CD BB BE         call player_robotkillplayer ; mark the player as killed
607+  CD0B C9               ret
# file closed: game/robots.asm
 50   CD0C                  include "game\bullet.asm"
# file opened: game/bullet.asm
  1+  CD0C              ;
  2+  CD0C              ; Current state: x & y coords (screen), direction (0 left, 1 right), state
  3+  CD0C              ;
  4+  CD0C              bullet_state:
  5+  CD0C 00 00 00 00      defb 0,0,0,0
  6+  CD10
  7+  CD10              ;
  8+  CD10              ; Initialise a the bullet
  9+  CD10              ;
 10+  CD10              bullet_init:
 11+  CD10 DD 21 0C CD      ld ix,bullet_state
 12+  CD14 DD 36 00 00      ld (ix),0
 13+  CD18 DD 36 01 00      ld (ix+1),0
 14+  CD1C DD 36 02 00      ld (ix+2),0
 15+  CD20 DD 36 03 00      ld (ix+3),0
 16+  CD24 C9               ret
 17+  CD25
 18+  CD25              ;
 19+  CD25              ; Shoots the bullet
 20+  CD25              ;
 21+  CD25              bullet_shoot:
 22+  CD25 DD 21 0C CD      ld ix,bullet_state
 23+  CD29 ED 4B 92 BD      ld bc,(player)              ; get the player coords
 24+  CD2D 3A 94 BD         ld a,(player+2)             ; get the player direction
 25+  CD30 FE 01            cp 1                        ; going left?
 26+  CD32 CA 40 CD         jp z,bullet_shoot0
 27+  CD35 3E 08            ld a,8
 28+  CD37 80               add a,b                     ; going right so add eight to start coords
 29+  CD38 47               ld b,a
 30+  CD39 DD 36 02 01      ld (ix+2),1                 ; set right
 31+  CD3D C3 49 CD         jp bullet_shoot1
 32+  CD40              bullet_shoot0:
 33+  CD40 78               ld a,b
 34+  CD41 06 08            ld b,8
 35+  CD43 90               sub b
 36+  CD44 47               ld b,a                      ; going left so subtract eight to start coords
 37+  CD45 DD 36 02 00      ld (ix+2),0                 ; set right
 38+  CD49              bullet_shoot1:
 39+  CD49 DD 71 00 DD      ld (ix),bc        ; store coords
 39+  CD4D 70 01
 40+  CD4F DD 36 03 01      ld (ix+3),1       ; set state to 1
 41+  CD53 CD A9 CD         call bullet_draw ; draw the initial frame
 42+  CD56 C9               ret
 43+  CD57
 44+  CD57              ;
 45+  CD57              ; Performs bullet processing
 46+  CD57              ;
 47+  CD57              bullet_process:
 48+  CD57 3A 0F CD         ld a,(bullet_state+3)       ; get the state
 49+  CD5A FE 00            cp 0
 50+  CD5C C8               ret z                       ; don't draw if this has become inactive
 51+  CD5D CD A9 CD         call bullet_draw            ; delete current frame
 52+  CD60 CD 6D CD         call bullet_move            ; move the bullet
 53+  CD63 3A 0F CD         ld a,(bullet_state+3)       ; get the state
 54+  CD66 FE 00            cp 0
 55+  CD68 C8               ret z                       ; don't draw if this has become inactive
 56+  CD69 CD A9 CD         call bullet_draw            ; draw new frame
 57+  CD6C C9               ret
 58+  CD6D
 59+  CD6D              ;
 60+  CD6D              ; Moves the bullet, checking for collisions
 61+  CD6D              ;
 62+  CD6D              bullet_move:
 63+  CD6D DD 21 0C CD      ld ix,bullet_state
 64+  CD71 DD 4E 00 DD      ld bc,(ix)
 64+  CD75 46 01
 65+  CD77 DD 7E 02         ld a,(ix+2)                 ; get the direction
 66+  CD7A FE 00            cp 0                        ; going left?
 67+  CD7C CA 86 CD         jp z,bullet_move0
 68+  CD7F 3E 08            ld a,8
 69+  CD81 80               add b
 70+  CD82 47               ld b,a                      ; add 8 since going right
 71+  CD83 C3 8B CD         jp bullet_move1
 72+  CD86              bullet_move0:
 73+  CD86 78               ld a,b
 74+  CD87 06 08            ld b,8
 75+  CD89 90               sub b
 76+  CD8A 47               ld b,a                      ; subtract 8 since going left
 77+  CD8B              bullet_move1:
 78+  CD8B DD 71 00 DD      ld (ix),bc                  ; store new coords
 78+  CD8F 70 01
 79+  CD91 C5               push bc
 80+  CD92 CD B6 CD         call bullets_checkforrobot
 81+  CD95 C1               pop bc
 82+  CD96 FE 01            cp 1                        ; if we hit a robot, keep moving
 83+  CD98 C8               ret z
 84+  CD99 CD 1F AB         call sprites_scadd          ; get memory loc of this block into de
 85+  CD9C 21 60 00         ld hl,96
 86+  CD9F 19               add hl,de
 87+  CDA0 7E               ld a,(hl)                   ; get the content
 88+  CDA1 FE 00            cp 0
 89+  CDA3 C8               ret z                       ; if empty, continue
 90+  CDA4 DD 36 03 00      ld (ix+3),0                 ; otherwise, mark bullet as inactive
 91+  CDA8 C9               ret
 92+  CDA9
 93+  CDA9              ;
 94+  CDA9              ; Draw the bullet
 95+  CDA9              ;
 96+  CDA9              bullet_draw:
 97+  CDA9 ED 4B 0C CD      ld bc,(bullet_state)        ; get coords
 98+  CDAD 3E 1B            ld a,27
 99+  CDAF CD A5 A9         call screen_getblock        ; get the block address
100+  CDB2 CD 2A AA         call sprites_drawsprite     ; draw the sprite
101+  CDB5 C9               ret
102+  CDB6
103+  CDB6              ;
104+  CDB6              ; Checks to see if the robot is hitting a bullet
105+  CDB6              ; Outputs:
106+  CDB6              ; a = 0 if not robot hit
107+  CDB6              ; a = 1 if robot not hit
108+  CDB6              bullets_checkforrobot:
109+  CDB6 3E 00            ld a,0
110+  CDB8 32 0C CE         ld (bullets_tmp),a
111+  CDBB 3A 83 C9         ld a,(robots_robotsmax) ; robots to check
112+  CDBE 47               ld b,a
113+  CDBF FD 21 55 C9      ld iy,robots_robots   ; start of robot array
114+  CDC3              bullets_checkforrobot0:
115+  CDC3 C5               push bc
116+  CDC4 FD 7E 02         ld a,(iy+2)             ; get the state
117+  CDC7 FE 01            cp 1
118+  CDC9 C2 00 CE         jp nz,bullets_checkforrobot1 ; if not active, don't check
119+  CDCC FD 5E 00 FD      ld de,(iy)              ; get robot coords
119+  CDD0 56 01
120+  CDD2 7A               ld a,d
121+  CDD3 E6 F8            and 248                 ; get nearest multiple of 8
122+  CDD5 57               ld d,a
123+  CDD6 ED 4B 0C CD      ld bc,(bullet_state)    ; get bullet coords
124+  CDDA 7A               ld a,d               ; get the player horiz coord
125+  CDDB 90               sub b                ; subtract robot coord
126+  CDDC FE 00            cp 0                ; should be the same
127+  CDDE C2 EA CD         jp nz,bullets_checkforrobot2 ; if not, might have hit, so check the next char along... if matched, check vert
128+  CDE1 3E 08            ld a,8
129+  CDE3 82               add a,d
130+  CDE4 90               sub b                ; check again for the next char along
131+  CDE5 FE 00            cp 0
132+  CDE7 C2 00 CE         jp nz,bullets_checkforrobot1 ; if not, haven't hit
133+  CDEA              bullets_checkforrobot2:
134+  CDEA 7B               ld a,e               ; get the vert coord
135+  CDEB 91               sub c                ; subtract the bullet vertical coord from robots
136+  CDEC C6 04            add 4                ; add the max distance
137+  CDEE FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
138+  CDF0 D2 00 CE         jp nc,bullets_checkforrobot1   ; if not, hasn't hit
139+  CDF3 FD 36 02 02      ld (iy+2),2             ; mark the robot as killed
140+  CDF7 FD 36 05 00      ld (iy+5),0             ; mark the anim frames as zero
141+  CDFB 3E 01            ld a,1
142+  CDFD 32 0C CE         ld (bullets_tmp),a      ; hit the flag to say we killed a robot
143+  CE00              bullets_checkforrobot1:
144+  CE00 11 07 00         ld de,7
145+  CE03 FD 19            add iy,de              ; move to next robot
146+  CE05 C1               pop bc
147+  CE06 10 BB            djnz bullets_checkforrobot0
148+  CE08 3A 0C CE         ld a,(bullets_tmp)
149+  CE0B C9               ret
150+  CE0C
151+  CE0C              bullets_tmp:
152+  CE0C 00               defb 0
153+  CE0D
# file closed: game/bullet.asm
 51   CE0D
 52   CE0D              ;===========================================================================
 53   CE0D              ; main routine - the code execution starts here.
 54   CE0D              ; Sets up the new interrupt routine, the memory
 55   CE0D              ; banks and jumps to the start loop.
 56   CE0D              ;===========================================================================
 57   CE0D              main:
 58   CE0D CD 1A AF         call options_show
 59   CE10
 60   CE10                  ; Draw the title screen
 61   CE10              main_titlescreen:
 62   CE10 CD 49 AB         call titlescreen_show
 63   CE13 CD D8 BD         call player_init_gamestart
 64   CE16
 65   CE16              main_lifestart:
 66   CE16
 67   CE16 CD FE BD         call player_init_lifestart
 68   CE19
 69   CE19 CD C9 AC         call lifescreen_draw        ; show the lives remaining screen
 70   CE1C
 71   CE1C CD 00 80         call init_start
 72   CE1F CD 21 A8         call screen_draw
 73   CE22 CD 70 A7         call buffer_allbuffertoscreen
 74   CE25
 75   CE25 CD 6C C6         call missiles_init
 76   CE28 CD ED BF         call ship_land              ; land the ship
 77   CE2B CD 00 C1         call tank_init
 78   CE2E CD 34 C6         call diamonds_init
 79   CE31 CD 1D C8         call thepit_init
 80   CE34 CD A9 C8         call monster_init
 81   CE37 CD 84 C9         call robots_init
 82   CE3A CD 10 CD         call bullet_init
 83   CE3D
 84   CE3D              mloop:
 85   CE3D                  ;halt
 86   CE3D CD 71 CE         call main_loop_processing
 87   CE40
 88   CE40                  ;
 89   CE40                  ; Check if the player died
 90   CE40                  ;
 91   CE40 21 9C BD         ld hl,player+10
 92   CE43 7E               ld a,(hl)                   ; check if the player died this frame
 93   CE44 FE 01            cp 1
 94   CE46 C2 5D CE         jp nz,mloop0
 95   CE49 CD 7D BE         call player_died        ; do end of life housekeeping
 96   CE4C 06 28            ld b,40
 97   CE4E CD 99 80         call utilities_pauseforframes
 98   CE51 21 9B BD         ld hl,player+9        ; check lives remaining
 99   CE54 7E               ld a,(hl)
100   CE55 FE 00            cp 0
101   CE57 CA A5 CE         jp z,main_gameover   ; leave the loop if we're done
102   CE5A C3 16 CE         jp main_lifestart    ; otherwise, start a new life
103   CE5D              mloop0:
104   CE5D                  ;
105   CE5D                  ; Check if the player completed the level
106   CE5D                  ;
107   CE5D 21 9F BD         ld hl,player+13
108   CE60 7E               ld a,(hl)
109   CE61 FE 01            cp 1
110   CE63 C2 3D CE         jp nz,mloop
111   CE66 CD B7 BF         call player_checkforexit
112   CE69 FE 01            cp 1                        ; look at return, if 1, level has been completed
113   CE6B CA AB CE         jp z,main_endlevel          ; jump to level transition screen
114   CE6E C3 3D CE         jp mloop                ; start the loop again
115   CE71
116   CE71
117   CE71              main_loop_processing:
118   CE71
119   CE71 CD 2F A7         call buffer_buffertoscreen  ; copy buffer to screen
120   CE74 CD 94 A6         call buffer_clearlist       ; zero the updated lines list
121   CE77 CD A2 BD         call player_getlocation     ; figure out where the player is
122   CE7A CD C1 BE         call player_drawplayer      ; delete player
123   CE7D CD 53 B8         call control_input          ; check input
124   CE80 CD C1 BE         call player_drawplayer      ; draw player
125   CE83 CD 2F C1         call tank_process           ; prcoess the tank
126   CE86 CD D8 BF         call ship_process           ; proces the ship
127   CE89 CD 33 C3         call rocks_processrocks     ; process falling rocks
128   CE8C CD 28 C8         call thepit_process         ; process the pit trap
129   CE8F CD 94 C6         call missiles_process       ; process missiles
130   CE92 CD C6 C8         call monster_process        ; process monster
131   CE95 CD 07 CA         call robots_process         ; process robots
132   CE98 CD 57 CD         call bullet_process         ; process the bullet
133   CE9B CD 13 C6         call diamonds_twinkle       ; make the diamonds twinkle
134   CE9E CD 9D C4         call scores_printscore      ; update the score on screen
135   CEA1 CD 72 BD         call game_incrementframe    ; increment the game frame
136   CEA4
137   CEA4 C9               ret
138   CEA5
139   CEA5              main_gameover:
140   CEA5 CD 29 AD         call gameover_draw          ; show the game over screen
141   CEA8 C3 10 CE         jp main_titlescreen         ; go back to title
142   CEAB
143   CEAB              main_endlevel:
144   CEAB CD 57 BE         call player_recordcurrentstate
145   CEAE CD 17 AE         call endlevel_draw          ; show the end level screen
146   CEB1 C3 16 CE         jp main_lifestart           ; start a new life
147   CEB4
148   CEB4              ;===========================================================================
149   CEB4              ; Stack.
150   CEB4              ;===========================================================================
151   CEB4
152   CEB4              ; Stack: this area is reserved for the stack
153   CEB4              STACK_SIZE: equ 100    ; in words
154   CEB4
155   CEB4              ; Reserve stack space
156   CEB4 00 00            defw 0  ; WPMEM, 2
157   CEB6              stack_bottom:
158   CEB6 00 00 00...      defs    STACK_SIZE*2, 0
159   CF7E              stack_top:
160   CF7E 00 00            defw 0  ; WPMEM, 2
161   CF80
162   CF80                     SAVESNA "ThePit.sna", main
# file closed: main.asm
